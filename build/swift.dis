
/home/huyong/Public/github/switft/build/swift.elf:     file format elf32-littlearm


Disassembly of section .text:

08000184 <__do_global_dtors_aux>:
 8000184:	b510      	push	{r4, lr}
 8000186:	4c05      	ldr	r4, [pc, #20]	; (800019c <__do_global_dtors_aux+0x18>)
 8000188:	7823      	ldrb	r3, [r4, #0]
 800018a:	b933      	cbnz	r3, 800019a <__do_global_dtors_aux+0x16>
 800018c:	4b04      	ldr	r3, [pc, #16]	; (80001a0 <__do_global_dtors_aux+0x1c>)
 800018e:	b113      	cbz	r3, 8000196 <__do_global_dtors_aux+0x12>
 8000190:	4804      	ldr	r0, [pc, #16]	; (80001a4 <__do_global_dtors_aux+0x20>)
 8000192:	f3af 8000 	nop.w
 8000196:	2301      	movs	r3, #1
 8000198:	7023      	strb	r3, [r4, #0]
 800019a:	bd10      	pop	{r4, pc}
 800019c:	20000204 	.word	0x20000204
 80001a0:	00000000 	.word	0x00000000
 80001a4:	08018954 	.word	0x08018954

080001a8 <frame_dummy>:
 80001a8:	4b08      	ldr	r3, [pc, #32]	; (80001cc <frame_dummy+0x24>)
 80001aa:	b510      	push	{r4, lr}
 80001ac:	b11b      	cbz	r3, 80001b6 <frame_dummy+0xe>
 80001ae:	4908      	ldr	r1, [pc, #32]	; (80001d0 <frame_dummy+0x28>)
 80001b0:	4808      	ldr	r0, [pc, #32]	; (80001d4 <frame_dummy+0x2c>)
 80001b2:	f3af 8000 	nop.w
 80001b6:	4808      	ldr	r0, [pc, #32]	; (80001d8 <frame_dummy+0x30>)
 80001b8:	6803      	ldr	r3, [r0, #0]
 80001ba:	b903      	cbnz	r3, 80001be <frame_dummy+0x16>
 80001bc:	bd10      	pop	{r4, pc}
 80001be:	4b07      	ldr	r3, [pc, #28]	; (80001dc <frame_dummy+0x34>)
 80001c0:	2b00      	cmp	r3, #0
 80001c2:	d0fb      	beq.n	80001bc <frame_dummy+0x14>
 80001c4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80001c8:	4718      	bx	r3
 80001ca:	bf00      	nop
 80001cc:	00000000 	.word	0x00000000
 80001d0:	20000208 	.word	0x20000208
 80001d4:	08018954 	.word	0x08018954
 80001d8:	20000204 	.word	0x20000204
 80001dc:	00000000 	.word	0x00000000

080001e0 <SystemInit>:
  */
void SystemInit(void)
{
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 80001e0:	4b32      	ldr	r3, [pc, #200]	; (80002ac <SystemInit+0xcc>)

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 80001e2:	2000      	movs	r0, #0
  */
void SystemInit(void)
{
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 80001e4:	6819      	ldr	r1, [r3, #0]
  *         SystemFrequency variable.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 80001e6:	b410      	push	{r4}
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 80001e8:	f041 0101 	orr.w	r1, r1, #1
 80001ec:	6019      	str	r1, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 80001ee:	6098      	str	r0, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 80001f0:	6819      	ldr	r1, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 80001f2:	4c2f      	ldr	r4, [pc, #188]	; (80002b0 <SystemInit+0xd0>)

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 80001f4:	f021 7184 	bic.w	r1, r1, #17301504	; 0x1080000
 80001f8:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
 80001fc:	6019      	str	r1, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 80001fe:	605c      	str	r4, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8000200:	6819      	ldr	r1, [r3, #0]
  *         SystemFrequency variable.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 8000202:	b083      	sub	sp, #12

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8000204:	f421 2180 	bic.w	r1, r1, #262144	; 0x40000
 8000208:	6019      	str	r1, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 800020a:	60d8      	str	r0, [r3, #12]
static void SetSysClock(void)
{
/******************************************************************************/
/*            PLL (clocked by HSE) used as System clock source                */
/******************************************************************************/
  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
 800020c:	9000      	str	r0, [sp, #0]
 800020e:	9001      	str	r0, [sp, #4]
  
  /* Enable HSE */
  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 8000210:	6819      	ldr	r1, [r3, #0]
 
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC->CR & RCC_CR_HSERDY;
 8000212:	461a      	mov	r2, r3
/*            PLL (clocked by HSE) used as System clock source                */
/******************************************************************************/
  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
  
  /* Enable HSE */
  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 8000214:	f441 3180 	orr.w	r1, r1, #65536	; 0x10000
 8000218:	6019      	str	r1, [r3, #0]
 800021a:	e003      	b.n	8000224 <SystemInit+0x44>
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC->CR & RCC_CR_HSERDY;
    StartUpCounter++;
  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
 800021c:	9b00      	ldr	r3, [sp, #0]
 800021e:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 8000222:	d009      	beq.n	8000238 <SystemInit+0x58>
  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC->CR & RCC_CR_HSERDY;
 8000224:	6813      	ldr	r3, [r2, #0]
 8000226:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800022a:	9301      	str	r3, [sp, #4]
    StartUpCounter++;
 800022c:	9b00      	ldr	r3, [sp, #0]
 800022e:	3301      	adds	r3, #1
 8000230:	9300      	str	r3, [sp, #0]
  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
 8000232:	9b01      	ldr	r3, [sp, #4]
 8000234:	2b00      	cmp	r3, #0
 8000236:	d0f1      	beq.n	800021c <SystemInit+0x3c>

  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
 8000238:	4b1c      	ldr	r3, [pc, #112]	; (80002ac <SystemInit+0xcc>)
 800023a:	681b      	ldr	r3, [r3, #0]
 800023c:	f413 3300 	ands.w	r3, r3, #131072	; 0x20000
  {
    HSEStatus = (uint32_t)0x01;
 8000240:	bf18      	it	ne
 8000242:	2301      	movne	r3, #1
  }
  else
  {
    HSEStatus = (uint32_t)0x00;
 8000244:	9301      	str	r3, [sp, #4]
  }

  if (HSEStatus == (uint32_t)0x01)
 8000246:	9b01      	ldr	r3, [sp, #4]
 8000248:	2b01      	cmp	r3, #1
 800024a:	d006      	beq.n	800025a <SystemInit+0x7a>

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 800024c:	4b19      	ldr	r3, [pc, #100]	; (80002b4 <SystemInit+0xd4>)
 800024e:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8000252:	609a      	str	r2, [r3, #8]
#endif
}
 8000254:	b003      	add	sp, #12
 8000256:	bc10      	pop	{r4}
 8000258:	4770      	bx	lr
  }

  if (HSEStatus == (uint32_t)0x01)
  {
    /* HCLK = SYSCLK / 1*/
    RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
 800025a:	4b14      	ldr	r3, [pc, #80]	; (80002ac <SystemInit+0xcc>)
    
    /* PCLK1 = HCLK / 2*/
    RCC->CFGR |= RCC_CFGR_PPRE1_DIV2;

    /* Configure the main PLL */
    RCC->PLLCFGR = PLL_M | (PLL_N << 6) | (((PLL_P >> 1) -1) << 16) |
 800025c:	4816      	ldr	r0, [pc, #88]	; (80002b8 <SystemInit+0xd8>)

    /* Enable the main PLL */
    RCC->CR |= RCC_CR_PLLON;

    /* Wait till the main PLL is ready */
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
 800025e:	4619      	mov	r1, r3
  }

  if (HSEStatus == (uint32_t)0x01)
  {
    /* HCLK = SYSCLK / 1*/
    RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
 8000260:	689a      	ldr	r2, [r3, #8]
 8000262:	609a      	str	r2, [r3, #8]
      
    /* PCLK2 = HCLK / 2*/
    RCC->CFGR |= RCC_CFGR_PPRE2_DIV2;
 8000264:	689a      	ldr	r2, [r3, #8]
 8000266:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 800026a:	609a      	str	r2, [r3, #8]
    
    /* PCLK1 = HCLK / 2*/
    RCC->CFGR |= RCC_CFGR_PPRE1_DIV2;
 800026c:	689a      	ldr	r2, [r3, #8]
 800026e:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8000272:	609a      	str	r2, [r3, #8]

    /* Configure the main PLL */
    RCC->PLLCFGR = PLL_M | (PLL_N << 6) | (((PLL_P >> 1) -1) << 16) |
 8000274:	6058      	str	r0, [r3, #4]
                   (RCC_PLLCFGR_PLLSRC_HSE) | (PLL_Q << 24);

    /* Enable the main PLL */
    RCC->CR |= RCC_CR_PLLON;
 8000276:	681a      	ldr	r2, [r3, #0]
 8000278:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 800027c:	601a      	str	r2, [r3, #0]

    /* Wait till the main PLL is ready */
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
 800027e:	680b      	ldr	r3, [r1, #0]
 8000280:	4a0a      	ldr	r2, [pc, #40]	; (80002ac <SystemInit+0xcc>)
 8000282:	019b      	lsls	r3, r3, #6
 8000284:	d5fb      	bpl.n	800027e <SystemInit+0x9e>
    {
    }
   
    /* Configure Flash prefetch, Instruction cache, Data cache and wait state */
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN | FLASH_ACR_DCEN | FLASH_ACR_LATENCY_3WS;
 8000286:	f240 7003 	movw	r0, #1795	; 0x703
    /* Select the main PLL as system clock source */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
    RCC->CFGR |= RCC_CFGR_SW_PLL;

    /* Wait till the main PLL is used as system clock source */
    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS ) != RCC_CFGR_SWS_PLL);
 800028a:	4611      	mov	r1, r2
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
    {
    }
   
    /* Configure Flash prefetch, Instruction cache, Data cache and wait state */
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN | FLASH_ACR_DCEN | FLASH_ACR_LATENCY_3WS;
 800028c:	4b0b      	ldr	r3, [pc, #44]	; (80002bc <SystemInit+0xdc>)
 800028e:	6018      	str	r0, [r3, #0]

    /* Select the main PLL as system clock source */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
 8000290:	6893      	ldr	r3, [r2, #8]
 8000292:	f023 0303 	bic.w	r3, r3, #3
 8000296:	6093      	str	r3, [r2, #8]
    RCC->CFGR |= RCC_CFGR_SW_PLL;
 8000298:	6893      	ldr	r3, [r2, #8]
 800029a:	f043 0302 	orr.w	r3, r3, #2
 800029e:	6093      	str	r3, [r2, #8]

    /* Wait till the main PLL is used as system clock source */
    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS ) != RCC_CFGR_SWS_PLL);
 80002a0:	688b      	ldr	r3, [r1, #8]
 80002a2:	f003 030c 	and.w	r3, r3, #12
 80002a6:	2b08      	cmp	r3, #8
 80002a8:	d1fa      	bne.n	80002a0 <SystemInit+0xc0>
 80002aa:	e7cf      	b.n	800024c <SystemInit+0x6c>
 80002ac:	40023800 	.word	0x40023800
 80002b0:	24003010 	.word	0x24003010
 80002b4:	e000ed00 	.word	0xe000ed00
 80002b8:	05403c18 	.word	0x05403c18
 80002bc:	40023c00 	.word	0x40023c00

080002c0 <SystemCoreClockUpdate>:
  *     
  * @param  None
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
 80002c0:	b410      	push	{r4}
  uint32_t tmp = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
  
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 80002c2:	4c1a      	ldr	r4, [pc, #104]	; (800032c <SystemCoreClockUpdate+0x6c>)
 80002c4:	68a3      	ldr	r3, [r4, #8]

  switch (tmp)
 80002c6:	f003 030c 	and.w	r3, r3, #12
 80002ca:	2b04      	cmp	r3, #4
 80002cc:	d023      	beq.n	8000316 <SystemCoreClockUpdate+0x56>
 80002ce:	2b08      	cmp	r3, #8
 80002d0:	d00a      	beq.n	80002e8 <SystemCoreClockUpdate+0x28>
 80002d2:	4b17      	ldr	r3, [pc, #92]	; (8000330 <SystemCoreClockUpdate+0x70>)
      SystemCoreClock = HSI_VALUE;
      break;
  }
  /* Compute HCLK frequency --------------------------------------------------*/
  /* Get HCLK prescaler */
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 80002d4:	4a15      	ldr	r2, [pc, #84]	; (800032c <SystemCoreClockUpdate+0x6c>)
 80002d6:	4917      	ldr	r1, [pc, #92]	; (8000334 <SystemCoreClockUpdate+0x74>)
 80002d8:	6892      	ldr	r2, [r2, #8]
  /* HCLK frequency */
  SystemCoreClock >>= tmp;
}
 80002da:	bc10      	pop	{r4}
      SystemCoreClock = HSI_VALUE;
      break;
  }
  /* Compute HCLK frequency --------------------------------------------------*/
  /* Get HCLK prescaler */
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 80002dc:	f3c2 1203 	ubfx	r2, r2, #4, #4
 80002e0:	5c8a      	ldrb	r2, [r1, r2]
  /* HCLK frequency */
  SystemCoreClock >>= tmp;
 80002e2:	40d3      	lsrs	r3, r2
 80002e4:	610b      	str	r3, [r1, #16]
}
 80002e6:	4770      	bx	lr
    case 0x08:  /* PLL used as system clock source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL_M) * PLL_N
         SYSCLK = PLL_VCO / PLL_P
         */    
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
 80002e8:	6863      	ldr	r3, [r4, #4]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 80002ea:	6861      	ldr	r1, [r4, #4]
      
      if (pllsource != 0)
 80002ec:	025b      	lsls	r3, r3, #9

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL_M) * PLL_N
         SYSCLK = PLL_VCO / PLL_P
         */    
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 80002ee:	f001 023f 	and.w	r2, r1, #63	; 0x3f
      
      if (pllsource != 0)
 80002f2:	d412      	bmi.n	800031a <SystemCoreClockUpdate+0x5a>
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 80002f4:	490e      	ldr	r1, [pc, #56]	; (8000330 <SystemCoreClockUpdate+0x70>)
 80002f6:	6863      	ldr	r3, [r4, #4]
 80002f8:	fbb1 f1f2 	udiv	r1, r1, r2
 80002fc:	f3c3 1388 	ubfx	r3, r3, #6, #9
 8000300:	fb01 f203 	mul.w	r2, r1, r3
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 8000304:	4b09      	ldr	r3, [pc, #36]	; (800032c <SystemCoreClockUpdate+0x6c>)
 8000306:	685b      	ldr	r3, [r3, #4]
      SystemCoreClock = pllvco/pllp;
 8000308:	f3c3 4301 	ubfx	r3, r3, #16, #2
 800030c:	3301      	adds	r3, #1
 800030e:	005b      	lsls	r3, r3, #1
 8000310:	fbb2 f3f3 	udiv	r3, r2, r3
      break;
 8000314:	e7de      	b.n	80002d4 <SystemCoreClockUpdate+0x14>
    case 0x00:  /* HSI used as system clock source */
      SystemCoreClock = HSI_VALUE;
      break;
    case 0x04:  /* HSE used as system clock source */
      SystemCoreClock = HSE_VALUE;
      break;
 8000316:	4b08      	ldr	r3, [pc, #32]	; (8000338 <SystemCoreClockUpdate+0x78>)
 8000318:	e7dc      	b.n	80002d4 <SystemCoreClockUpdate+0x14>
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
      
      if (pllsource != 0)
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 800031a:	4807      	ldr	r0, [pc, #28]	; (8000338 <SystemCoreClockUpdate+0x78>)
 800031c:	6863      	ldr	r3, [r4, #4]
 800031e:	fbb0 f1f2 	udiv	r1, r0, r2
 8000322:	f3c3 1388 	ubfx	r3, r3, #6, #9
 8000326:	fb01 f203 	mul.w	r2, r1, r3
 800032a:	e7eb      	b.n	8000304 <SystemCoreClockUpdate+0x44>
 800032c:	40023800 	.word	0x40023800
 8000330:	00f42400 	.word	0x00f42400
 8000334:	20000000 	.word	0x20000000
 8000338:	016e3600 	.word	0x016e3600

0800033c <TaskSatGradientTrack>:
**return: none
**autor:  andiman
**date:
************************************************************/
static  void  TaskSatGradientTrack(void *p_arg)
{
 800033c:	4c09      	ldr	r4, [pc, #36]	; (8000364 <TaskSatGradientTrack+0x28>)
 800033e:	b508      	push	{r3, lr}


    Task_Run_Flag[1] = 1;
    while (DEF_TRUE) 
    {         
        if( ACUDevInfo.ACUParam.SeekSatParam.SeekSat_Mode == 0x03)
 8000340:	4626      	mov	r6, r4
static  void  TaskSatGradientTrack(void *p_arg)
{
    OS_ERR err;


    Task_Run_Flag[1] = 1;
 8000342:	4b09      	ldr	r3, [pc, #36]	; (8000368 <TaskSatGradientTrack+0x2c>)
 8000344:	2201      	movs	r2, #1
 8000346:	705a      	strb	r2, [r3, #1]
    {         
        if( ACUDevInfo.ACUParam.SeekSatParam.SeekSat_Mode == 0x03)
        {
            //if(APP_Sat_GradientTrack() == FAIL)
            {
                ACUDevInfo.ACUParam.SeekSatParam.SeekSat_Mode = 0x00;
 8000348:	2500      	movs	r5, #0


    Task_Run_Flag[1] = 1;
    while (DEF_TRUE) 
    {         
        if( ACUDevInfo.ACUParam.SeekSatParam.SeekSat_Mode == 0x03)
 800034a:	f894 31dc 	ldrb.w	r3, [r4, #476]	; 0x1dc
                ACUDevInfo.ACUCurrSta.dev_work_sta = 0x00;

                //APP_OptLOG_SaveCode(LOG_OPT_FOLLOW_STAR_END_BY_ACU);
            }
        }
        BSP_Delay_ms(50);
 800034e:	2032      	movs	r0, #50	; 0x32


    Task_Run_Flag[1] = 1;
    while (DEF_TRUE) 
    {         
        if( ACUDevInfo.ACUParam.SeekSatParam.SeekSat_Mode == 0x03)
 8000350:	2b03      	cmp	r3, #3
        {
            //if(APP_Sat_GradientTrack() == FAIL)
            {
                ACUDevInfo.ACUParam.SeekSatParam.SeekSat_Mode = 0x00;
 8000352:	bf04      	itt	eq
 8000354:	f886 51dc 	strbeq.w	r5, [r6, #476]	; 0x1dc
                ACUDevInfo.ACUCurrSta.dev_work_sta = 0x00;
 8000358:	f886 527d 	strbeq.w	r5, [r6, #637]	; 0x27d

                //APP_OptLOG_SaveCode(LOG_OPT_FOLLOW_STAR_END_BY_ACU);
            }
        }
        BSP_Delay_ms(50);
 800035c:	f000 fc1c 	bl	8000b98 <BSP_Delay_ms>
    }
 8000360:	e7f3      	b.n	800034a <TaskSatGradientTrack+0xe>
 8000362:	bf00      	nop
 8000364:	20004d00 	.word	0x20004d00
 8000368:	20007124 	.word	0x20007124

0800036c <TaskStart>:
*                  used.  The compiler should not generate any code for this statement.
*********************************************************************************************************
*/

static  void  TaskStart (void *p_arg)
{
 800036c:	b570      	push	{r4, r5, r6, lr}
 800036e:	b08c      	sub	sp, #48	; 0x30
	INT32U period_ms1 = 100,period_ms2,period_cnt1=0,period_cnt2=0;
	INT16U delay_ms;

	(void)p_arg;

	CPU_Init();                                                 /* Init CPU name & int. dis. time measuring fncts.          */	
 8000370:	f001 fc86 	bl	8001c80 <CPU_Init>
	Mem_Init();                                                 /* Initialize Memory managment                              */
 8000374:	f001 ff2e 	bl	80021d4 <Mem_Init>
	BSP_CPU_TickInit();                                         /* Start Tick Initialization                                */
 8000378:	f000 f92a 	bl	80005d0 <BSP_CPU_TickInit>
	                                                /* Init BSP fncts.                                          */
	
	 ACUDevInfo.ACUCurrSta.dev_work_sta = 0xFF;                                               
 800037c:	4b1c      	ldr	r3, [pc, #112]	; (80003f0 <TaskStart+0x84>)
 800037e:	22ff      	movs	r2, #255	; 0xff
 8000380:	f883 227d 	strb.w	r2, [r3, #637]	; 0x27d
	BSP_Init(); 
 8000384:	f000 f8ee 	bl	8000564 <BSP_Init>
	

	APP_Shell_Init(); 
 8000388:	f000 f8d8 	bl	800053c <APP_Shell_Init>
	//APP_ElecEncoder_Init();	
	//APP_PARAM_Init();
	
	//APP_PCCOMM_Init();
	
	BSP_Delay_ms(500);
 800038c:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8000390:	f000 fc02 	bl	8000b98 <BSP_Delay_ms>
                 (void       *) 0,
                 (OS_OPT      )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR),
                 (OS_ERR     *)&err); 
#endif
                 
        OSTaskCreate((OS_TCB     *)&TaskShellTCB,                /* Create the start task                                    */
 8000394:	4e17      	ldr	r6, [pc, #92]	; (80003f4 <TaskStart+0x88>)
	
	//APP_PCCOMM_Init();
	
	BSP_Delay_ms(500);

 	LWIP_Init();
 8000396:	f003 f993 	bl	80036c0 <LWIP_Init>
	
    //APP_TRACE_INFO(("Creating Application Tasks... \n\r"));
	
	
	
	udpecho_init();
 800039a:	f00b fa53 	bl	800b844 <udpecho_init>

 	//APP_PDUCOMM_Init();
 	//APP_PDUCOMM_VersionQue();
 	BSP_Delay_ms(100);
 800039e:	2064      	movs	r0, #100	; 0x64
 80003a0:	f000 fbfa 	bl	8000b98 <BSP_Delay_ms>
                 (void       *) 0,
                 (OS_OPT      )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR),
                 (OS_ERR     *)&err); 
#endif
                 
        OSTaskCreate((OS_TCB     *)&TaskShellTCB,                /* Create the start task                                    */
 80003a4:	f10d 052e 	add.w	r5, sp, #46	; 0x2e
 80003a8:	2300      	movs	r3, #0
 80003aa:	f44f 7040 	mov.w	r0, #768	; 0x300
 80003ae:	214c      	movs	r1, #76	; 0x4c
 80003b0:	2207      	movs	r2, #7
 80003b2:	2403      	movs	r4, #3
 80003b4:	9003      	str	r0, [sp, #12]
 80003b6:	9102      	str	r1, [sp, #8]
 80003b8:	9200      	str	r2, [sp, #0]
 80003ba:	9601      	str	r6, [sp, #4]
 80003bc:	9508      	str	r5, [sp, #32]
 80003be:	9407      	str	r4, [sp, #28]
 80003c0:	9306      	str	r3, [sp, #24]
 80003c2:	9305      	str	r3, [sp, #20]
 80003c4:	9304      	str	r3, [sp, #16]
 80003c6:	4a0c      	ldr	r2, [pc, #48]	; (80003f8 <TaskStart+0x8c>)
 80003c8:	490c      	ldr	r1, [pc, #48]	; (80003fc <TaskStart+0x90>)
 80003ca:	480d      	ldr	r0, [pc, #52]	; (8000400 <TaskStart+0x94>)
 80003cc:	f006 fe1e 	bl	800700c <OSTaskCreate>
  	//从时钟芯片 获取时间，随后在本任务中自动计时
	//DATETIME_ReadFromRtcIC(&ACUDevInfo.SysDateTime);
	while (DEF_TRUE) 
	{     
		//HW_WTD_Feed();
		HW_LED1_ON();
 80003d0:	f001 fe48 	bl	8002064 <HW_LED1_ON>
		HW_LED2_ON();
 80003d4:	f001 fe4c 	bl	8002070 <HW_LED2_ON>
		BSP_Delay_ms(250);
 80003d8:	20fa      	movs	r0, #250	; 0xfa
 80003da:	f000 fbdd 	bl	8000b98 <BSP_Delay_ms>
		HW_LED1_OFF();
 80003de:	f001 fe35 	bl	800204c <HW_LED1_OFF>
		HW_LED2_OFF();
 80003e2:	f001 fe39 	bl	8002058 <HW_LED2_OFF>
		BSP_Delay_ms(250);
 80003e6:	20fa      	movs	r0, #250	; 0xfa
 80003e8:	f000 fbd6 	bl	8000b98 <BSP_Delay_ms>
 80003ec:	e7f0      	b.n	80003d0 <TaskStart+0x64>
 80003ee:	bf00      	nop
 80003f0:	20004d00 	.word	0x20004d00
 80003f4:	20005014 	.word	0x20005014
 80003f8:	08000405 	.word	0x08000405
 80003fc:	08016228 	.word	0x08016228
 8000400:	20005e60 	.word	0x20005e60

08000404 <TaskShell>:
**return: none
**autor:  andiman
**date:
************************************************************/
static  void  TaskShell(void *p_arg)
{
 8000404:	b508      	push	{r3, lr}
    while (DEF_TRUE) 
    {         
        //if(BSP_OS_Sem_Pend(&SWIFT_UART6_Rev_Sem, 0) == SUCC)
        {
            //shell_proc();
			cli_loop();
 8000406:	f000 fd53 	bl	8000eb0 <cli_loop>
 800040a:	e7fc      	b.n	8000406 <TaskShell+0x2>

0800040c <TaskSatelliteTrack>:
**return: none
**autor:  andiman
**date:
************************************************************/
static  void  TaskSatelliteTrack(void *p_arg)
{
 800040c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800040e:	4d0c      	ldr	r5, [pc, #48]	; (8000440 <TaskSatelliteTrack+0x34>)
    OS_ERR err;


    Task_Run_Flag[0] = 1;
 8000410:	4e0c      	ldr	r6, [pc, #48]	; (8000444 <TaskSatelliteTrack+0x38>)
    while (DEF_TRUE) 
    {         
        if( ACUDevInfo.ACUParam.SeekSatParam.SeekSat_Mode == 0x02)
 8000412:	462f      	mov	r7, r5
**return: none
**autor:  andiman
**date:
************************************************************/
static  void  TaskSatelliteTrack(void *p_arg)
{
 8000414:	b083      	sub	sp, #12
    {         
        if( ACUDevInfo.ACUParam.SeekSatParam.SeekSat_Mode == 0x02)
        {
            //if( APP_Satellite_Track_Start() == FAIL)
            {
                ACUDevInfo.ACUParam.SeekSatParam.SeekSat_Mode = 0x00;
 8000416:	2400      	movs	r4, #0


    Task_Run_Flag[0] = 1;
    while (DEF_TRUE) 
    {         
        if( ACUDevInfo.ACUParam.SeekSatParam.SeekSat_Mode == 0x02)
 8000418:	f895 31dc 	ldrb.w	r3, [r5, #476]	; 0x1dc
        }
        Task_Run_Flag[0] = 0;

        //if(Antenna_AllDriveEnd() == FAIL)
        //    Antenna_AllDriveEnd();
        OSTaskDel ((OS_TCB  *)0,&err);
 800041c:	f10d 0106 	add.w	r1, sp, #6


    Task_Run_Flag[0] = 1;
    while (DEF_TRUE) 
    {         
        if( ACUDevInfo.ACUParam.SeekSatParam.SeekSat_Mode == 0x02)
 8000420:	2b02      	cmp	r3, #2
        }
        Task_Run_Flag[0] = 0;

        //if(Antenna_AllDriveEnd() == FAIL)
        //    Antenna_AllDriveEnd();
        OSTaskDel ((OS_TCB  *)0,&err);
 8000422:	f04f 0000 	mov.w	r0, #0
    {         
        if( ACUDevInfo.ACUParam.SeekSatParam.SeekSat_Mode == 0x02)
        {
            //if( APP_Satellite_Track_Start() == FAIL)
            {
                ACUDevInfo.ACUParam.SeekSatParam.SeekSat_Mode = 0x00;
 8000426:	bf04      	itt	eq
 8000428:	f887 41dc 	strbeq.w	r4, [r7, #476]	; 0x1dc
                ACUDevInfo.ACUCurrSta.dev_work_sta = 0x00;
 800042c:	f887 427d 	strbeq.w	r4, [r7, #637]	; 0x27d
            //else
            {
                //APP_OptLOG_SaveCode(LOG_OPT_AUTO_AIM_STAR_END_BY_ACU_LOCK);
            }
        }
        Task_Run_Flag[0] = 0;
 8000430:	7034      	strb	r4, [r6, #0]

        //if(Antenna_AllDriveEnd() == FAIL)
        //    Antenna_AllDriveEnd();
        OSTaskDel ((OS_TCB  *)0,&err);
 8000432:	f006 ff2d 	bl	8007290 <OSTaskDel>
        BSP_Delay_ms(50);
 8000436:	2032      	movs	r0, #50	; 0x32
 8000438:	f000 fbae 	bl	8000b98 <BSP_Delay_ms>
    }
 800043c:	e7ec      	b.n	8000418 <TaskSatelliteTrack+0xc>
 800043e:	bf00      	nop
 8000440:	20004d00 	.word	0x20004d00
 8000444:	20007124 	.word	0x20007124

08000448 <TaskSatelliteTrackDel>:
*
* Note(s)     : none.
*********************************************************************************************************
*/
void  TaskSatelliteTrackDel (void)
{
 8000448:	b500      	push	{lr}
    OS_ERR err;

    Task_Run_Flag[0] = 0;
 800044a:	4b06      	ldr	r3, [pc, #24]	; (8000464 <TaskSatelliteTrackDel+0x1c>)
*
* Note(s)     : none.
*********************************************************************************************************
*/
void  TaskSatelliteTrackDel (void)
{
 800044c:	b083      	sub	sp, #12
    OS_ERR err;

    Task_Run_Flag[0] = 0;
 800044e:	2200      	movs	r2, #0
    OSTaskDel ((OS_TCB  *)&TaskSatelliteTrackTCB,&err);
 8000450:	f10d 0106 	add.w	r1, sp, #6
 8000454:	4804      	ldr	r0, [pc, #16]	; (8000468 <TaskSatelliteTrackDel+0x20>)
*/
void  TaskSatelliteTrackDel (void)
{
    OS_ERR err;

    Task_Run_Flag[0] = 0;
 8000456:	701a      	strb	r2, [r3, #0]
    OSTaskDel ((OS_TCB  *)&TaskSatelliteTrackTCB,&err);
 8000458:	f006 ff1a 	bl	8007290 <OSTaskDel>
    
}
 800045c:	b003      	add	sp, #12
 800045e:	f85d fb04 	ldr.w	pc, [sp], #4
 8000462:	bf00      	nop
 8000464:	20007124 	.word	0x20007124
 8000468:	20005c14 	.word	0x20005c14

0800046c <TaskSatelliteTrackCreate>:
*
* Note(s)     : none.
*********************************************************************************************************
*/
void  TaskSatelliteTrackCreate(void)
{
 800046c:	b570      	push	{r4, r5, r6, lr}
    OS_ERR err;
    OSTaskCreate((OS_TCB     *)&TaskSatelliteTrackTCB,                /* Create the start task                                    */
 800046e:	4e0d      	ldr	r6, [pc, #52]	; (80004a4 <TaskSatelliteTrackCreate+0x38>)
*
* Note(s)     : none.
*********************************************************************************************************
*/
void  TaskSatelliteTrackCreate(void)
{
 8000470:	b08c      	sub	sp, #48	; 0x30
    OS_ERR err;
    OSTaskCreate((OS_TCB     *)&TaskSatelliteTrackTCB,                /* Create the start task                                    */
 8000472:	2300      	movs	r3, #0
 8000474:	f10d 052e 	add.w	r5, sp, #46	; 0x2e
 8000478:	2403      	movs	r4, #3
 800047a:	f44f 7000 	mov.w	r0, #512	; 0x200
 800047e:	2133      	movs	r1, #51	; 0x33
 8000480:	221e      	movs	r2, #30
 8000482:	9003      	str	r0, [sp, #12]
 8000484:	9102      	str	r1, [sp, #8]
 8000486:	9200      	str	r2, [sp, #0]
 8000488:	9601      	str	r6, [sp, #4]
 800048a:	9508      	str	r5, [sp, #32]
 800048c:	9407      	str	r4, [sp, #28]
 800048e:	9306      	str	r3, [sp, #24]
 8000490:	9305      	str	r3, [sp, #20]
 8000492:	9304      	str	r3, [sp, #16]
 8000494:	4a04      	ldr	r2, [pc, #16]	; (80004a8 <TaskSatelliteTrackCreate+0x3c>)
 8000496:	4905      	ldr	r1, [pc, #20]	; (80004ac <TaskSatelliteTrackCreate+0x40>)
 8000498:	4805      	ldr	r0, [pc, #20]	; (80004b0 <TaskSatelliteTrackCreate+0x44>)
 800049a:	f006 fdb7 	bl	800700c <OSTaskCreate>
                 (OS_MSG_QTY  ) 0,
                 (OS_TICK     ) 0,
                 (void       *) 0,
                 (OS_OPT      )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR),
                 (OS_ERR     *)&err);     
}
 800049e:	b00c      	add	sp, #48	; 0x30
 80004a0:	bd70      	pop	{r4, r5, r6, pc}
 80004a2:	bf00      	nop
 80004a4:	2000aa00 	.word	0x2000aa00
 80004a8:	0800040d 	.word	0x0800040d
 80004ac:	08016240 	.word	0x08016240
 80004b0:	20005c14 	.word	0x20005c14

080004b4 <TaskAntennaRecordGotoDel>:
*/
void  TaskAntennaRecordGotoDel (void)
{
    OS_ERR err;

    Task_Run_Flag[2] = 0;
 80004b4:	4b01      	ldr	r3, [pc, #4]	; (80004bc <TaskAntennaRecordGotoDel+0x8>)
 80004b6:	2200      	movs	r2, #0
 80004b8:	709a      	strb	r2, [r3, #2]
 80004ba:	4770      	bx	lr
 80004bc:	20007124 	.word	0x20007124

080004c0 <TaskAntennaRecordGotoCreate>:
*/
void  TaskAntennaRecordGotoCreate(void)
{
    OS_ERR err;

    Task_Run_Flag[2] = 1;
 80004c0:	4b01      	ldr	r3, [pc, #4]	; (80004c8 <TaskAntennaRecordGotoCreate+0x8>)
 80004c2:	2201      	movs	r2, #1
 80004c4:	709a      	strb	r2, [r3, #2]
 80004c6:	4770      	bx	lr
 80004c8:	20007124 	.word	0x20007124

080004cc <TaskSatGradientTrackDel>:
*
* Note(s)     : none.
*********************************************************************************************************
*/
void  TaskSatGradientTrackDel (void)
{
 80004cc:	b500      	push	{lr}
    OS_ERR err;
    Task_Run_Flag[1] = 0;
 80004ce:	4b06      	ldr	r3, [pc, #24]	; (80004e8 <TaskSatGradientTrackDel+0x1c>)
*
* Note(s)     : none.
*********************************************************************************************************
*/
void  TaskSatGradientTrackDel (void)
{
 80004d0:	b083      	sub	sp, #12
    OS_ERR err;
    Task_Run_Flag[1] = 0;
 80004d2:	2200      	movs	r2, #0
    OSTaskDel ((OS_TCB  *)&TaskSatGradientTrackTCB,&err);
 80004d4:	f10d 0106 	add.w	r1, sp, #6
 80004d8:	4804      	ldr	r0, [pc, #16]	; (80004ec <TaskSatGradientTrackDel+0x20>)
*********************************************************************************************************
*/
void  TaskSatGradientTrackDel (void)
{
    OS_ERR err;
    Task_Run_Flag[1] = 0;
 80004da:	705a      	strb	r2, [r3, #1]
    OSTaskDel ((OS_TCB  *)&TaskSatGradientTrackTCB,&err);
 80004dc:	f006 fed8 	bl	8007290 <OSTaskDel>
}
 80004e0:	b003      	add	sp, #12
 80004e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80004e6:	bf00      	nop
 80004e8:	20007124 	.word	0x20007124
 80004ec:	2000a53c 	.word	0x2000a53c

080004f0 <TaskSatGradientTrackCreate>:
*
* Note(s)     : none.
*********************************************************************************************************
*/
void  TaskSatGradientTrackCreate(void)
{
 80004f0:	b570      	push	{r4, r5, r6, lr}
    OS_ERR err;
    OSTaskCreate((OS_TCB     *)&TaskSatGradientTrackTCB,                /* Create the start task                                    */
 80004f2:	4e0d      	ldr	r6, [pc, #52]	; (8000528 <TaskSatGradientTrackCreate+0x38>)
*
* Note(s)     : none.
*********************************************************************************************************
*/
void  TaskSatGradientTrackCreate(void)
{
 80004f4:	b08c      	sub	sp, #48	; 0x30
    OS_ERR err;
    OSTaskCreate((OS_TCB     *)&TaskSatGradientTrackTCB,                /* Create the start task                                    */
 80004f6:	2300      	movs	r3, #0
 80004f8:	f10d 052e 	add.w	r5, sp, #46	; 0x2e
 80004fc:	2403      	movs	r4, #3
 80004fe:	f44f 7000 	mov.w	r0, #512	; 0x200
 8000502:	2133      	movs	r1, #51	; 0x33
 8000504:	2220      	movs	r2, #32
 8000506:	9003      	str	r0, [sp, #12]
 8000508:	9102      	str	r1, [sp, #8]
 800050a:	9200      	str	r2, [sp, #0]
 800050c:	9601      	str	r6, [sp, #4]
 800050e:	9508      	str	r5, [sp, #32]
 8000510:	9407      	str	r4, [sp, #28]
 8000512:	9306      	str	r3, [sp, #24]
 8000514:	9305      	str	r3, [sp, #20]
 8000516:	9304      	str	r3, [sp, #16]
 8000518:	4a04      	ldr	r2, [pc, #16]	; (800052c <TaskSatGradientTrackCreate+0x3c>)
 800051a:	4905      	ldr	r1, [pc, #20]	; (8000530 <TaskSatGradientTrackCreate+0x40>)
 800051c:	4805      	ldr	r0, [pc, #20]	; (8000534 <TaskSatGradientTrackCreate+0x44>)
 800051e:	f006 fd75 	bl	800700c <OSTaskCreate>
                 (OS_MSG_QTY  ) 0,
                 (OS_TICK     ) 0,
                 (void       *) 0,
                 (OS_OPT      )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR),
                 (OS_ERR     *)&err);     
}
 8000522:	b00c      	add	sp, #48	; 0x30
 8000524:	bd70      	pop	{r4, r5, r6, pc}
 8000526:	bf00      	nop
 8000528:	20005f24 	.word	0x20005f24
 800052c:	0800033d 	.word	0x0800033d
 8000530:	08016254 	.word	0x08016254
 8000534:	2000a53c 	.word	0x2000a53c

08000538 <AppObjCreate>:
}



void    AppObjCreate(void)
{
 8000538:	4770      	bx	lr
 800053a:	bf00      	nop

0800053c <APP_Shell_Init>:
**return:  FAIL:   SUCC
**autor:  andiman
**date:
************************************************************/
int APP_Shell_Init(void)
{
 800053c:	b508      	push	{r3, lr}
	// 对应的串口驱动初始化
	SWIFT_UART6_Init(115200);
 800053e:	f44f 30e1 	mov.w	r0, #115200	; 0x1c200
 8000542:	f001 fcc5 	bl	8001ed0 <SWIFT_UART6_Init>

	cmd_help_init();
 8000546:	f000 fe73 	bl	8001230 <cmd_help_init>
	cmd_ver_init();
 800054a:	f000 ff0f 	bl	800136c <cmd_ver_init>
	cmd_d_init();
 800054e:	f000 fe3f 	bl	80011d0 <cmd_d_init>
	cmd_m_init();
 8000552:	f000 fead 	bl	80012b0 <cmd_m_init>
	cmd_reset_init();
 8000556:	f000 fecd 	bl	80012f4 <cmd_reset_init>

	cli_init();
 800055a:	f000 fcab 	bl	8000eb4 <cli_init>
	
	return SUCC;
}
 800055e:	2000      	movs	r0, #0
 8000560:	bd08      	pop	{r3, pc}
 8000562:	bf00      	nop

08000564 <BSP_Init>:
*                       requirements.
*********************************************************************************************************
*/

void  BSP_Init (void)
{
 8000564:	b508      	push	{r3, lr}
	INT8U readbuff[10]={0};
	
	BSP_IntInit();
 8000566:	f000 fba5 	bl	8000cb4 <BSP_IntInit>
	//HW_EEPROM_Init();

	//APP_BUZZER_Init();

	//APP_BEACON_Init();
}
 800056a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
{
	INT8U readbuff[10]={0};
	
	BSP_IntInit();

	HW_LED_Init();
 800056e:	f001 bd57 	b.w	8002020 <HW_LED_Init>
 8000572:	bf00      	nop

08000574 <BSP_RNG_Read>:
CPU_INT32U  BSP_RNG_Read (void)
{
    CPU_INT32U  rng_val;


    RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_RNG, ENABLE);         /* Enable RNG clock.                                    */
 8000574:	2101      	movs	r1, #1
* Note(s)     : none.
*********************************************************************************************************
*/

CPU_INT32U  BSP_RNG_Read (void)
{
 8000576:	b510      	push	{r4, lr}
    CPU_INT32U  rng_val;


    RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_RNG, ENABLE);         /* Enable RNG clock.                                    */
 8000578:	2040      	movs	r0, #64	; 0x40
 800057a:	f008 fc53 	bl	8008e24 <RCC_AHB2PeriphClockCmd>

    RNG_REG->CR |= RNG_CR_IE;                                   /* Enable RNG ISR.                                      */
 800057e:	4b0e      	ldr	r3, [pc, #56]	; (80005b8 <BSP_RNG_Read+0x44>)
    RNG_REG->CR |= RNG_CR_RNGEN;                                /* Enable LFSR & err detector.                          */

    while ((RNG_REG->SR & RNG_SR_DRDY) == 0) {
 8000580:	4619      	mov	r1, r3
    CPU_INT32U  rng_val;


    RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_RNG, ENABLE);         /* Enable RNG clock.                                    */

    RNG_REG->CR |= RNG_CR_IE;                                   /* Enable RNG ISR.                                      */
 8000582:	681a      	ldr	r2, [r3, #0]
 8000584:	f042 0208 	orr.w	r2, r2, #8
 8000588:	601a      	str	r2, [r3, #0]
    RNG_REG->CR |= RNG_CR_RNGEN;                                /* Enable LFSR & err detector.                          */
 800058a:	681a      	ldr	r2, [r3, #0]
 800058c:	f042 0204 	orr.w	r2, r2, #4
 8000590:	601a      	str	r2, [r3, #0]

    while ((RNG_REG->SR & RNG_SR_DRDY) == 0) {
 8000592:	684b      	ldr	r3, [r1, #4]
 8000594:	4a08      	ldr	r2, [pc, #32]	; (80005b8 <BSP_RNG_Read+0x44>)
 8000596:	07db      	lsls	r3, r3, #31
 8000598:	d5fb      	bpl.n	8000592 <BSP_RNG_Read+0x1e>
            ;
    }
    rng_val = (CPU_INT32U)RNG_REG->DR;                          /* Save RNG data reg.                                   */
 800059a:	6894      	ldr	r4, [r2, #8]

    RNG_REG->CR &= ~RNG_CR_IE;                                  /* Disable RNG ISR.                                     */
 800059c:	6813      	ldr	r3, [r2, #0]
    RNG_REG->CR &= ~RNG_CR_RNGEN;                               /* Disable LFSR & err detector.                         */
    RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_RNG, DISABLE);        /* Disable RNG clock.                                   */
 800059e:	2100      	movs	r1, #0
    while ((RNG_REG->SR & RNG_SR_DRDY) == 0) {
            ;
    }
    rng_val = (CPU_INT32U)RNG_REG->DR;                          /* Save RNG data reg.                                   */

    RNG_REG->CR &= ~RNG_CR_IE;                                  /* Disable RNG ISR.                                     */
 80005a0:	f023 0308 	bic.w	r3, r3, #8
 80005a4:	6013      	str	r3, [r2, #0]
    RNG_REG->CR &= ~RNG_CR_RNGEN;                               /* Disable LFSR & err detector.                         */
 80005a6:	6813      	ldr	r3, [r2, #0]
    RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_RNG, DISABLE);        /* Disable RNG clock.                                   */
 80005a8:	2040      	movs	r0, #64	; 0x40
            ;
    }
    rng_val = (CPU_INT32U)RNG_REG->DR;                          /* Save RNG data reg.                                   */

    RNG_REG->CR &= ~RNG_CR_IE;                                  /* Disable RNG ISR.                                     */
    RNG_REG->CR &= ~RNG_CR_RNGEN;                               /* Disable LFSR & err detector.                         */
 80005aa:	f023 0304 	bic.w	r3, r3, #4
 80005ae:	6013      	str	r3, [r2, #0]
    RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_RNG, DISABLE);        /* Disable RNG clock.                                   */
 80005b0:	f008 fc38 	bl	8008e24 <RCC_AHB2PeriphClockCmd>

    return (rng_val);                                           /* Return rand value.                                   */
}
 80005b4:	4620      	mov	r0, r4
 80005b6:	bd10      	pop	{r4, pc}
 80005b8:	50060800 	.word	0x50060800

080005bc <BSP_CPU_ClkFreq>:
* Note(s)     : none.
*********************************************************************************************************
*/

CPU_INT32U  BSP_CPU_ClkFreq (void)
{
 80005bc:	b500      	push	{lr}
 80005be:	b085      	sub	sp, #20
    RCC_ClocksTypeDef  rcc_clocks;


    RCC_GetClocksFreq(&rcc_clocks);
 80005c0:	4668      	mov	r0, sp
 80005c2:	f008 fba3 	bl	8008d0c <RCC_GetClocksFreq>
    return ((CPU_INT32U)rcc_clocks.HCLK_Frequency);
}
 80005c6:	9801      	ldr	r0, [sp, #4]
 80005c8:	b005      	add	sp, #20
 80005ca:	f85d fb04 	ldr.w	pc, [sp], #4
 80005ce:	bf00      	nop

080005d0 <BSP_CPU_TickInit>:
* Note(s)     : none.
*********************************************************************************************************
*/

void  BSP_CPU_TickInit  (void)
{
 80005d0:	b500      	push	{lr}
 80005d2:	b085      	sub	sp, #20
CPU_INT32U  BSP_CPU_ClkFreq (void)
{
    RCC_ClocksTypeDef  rcc_clocks;


    RCC_GetClocksFreq(&rcc_clocks);
 80005d4:	4668      	mov	r0, sp
 80005d6:	f008 fb99 	bl	8008d0c <RCC_GetClocksFreq>
    CPU_INT32U  cnts;


    cpu_clk_freq = BSP_CPU_ClkFreq();                           /* Determine SysTick reference freq.                    */
#if (OS_VERSION >= 30000u)
    cnts         = (cpu_clk_freq / OSCfg_TickRate_Hz);          /* Determine nbr SysTick increments                     */
 80005da:	4b05      	ldr	r3, [pc, #20]	; (80005f0 <BSP_CPU_TickInit+0x20>)
{
    RCC_ClocksTypeDef  rcc_clocks;


    RCC_GetClocksFreq(&rcc_clocks);
    return ((CPU_INT32U)rcc_clocks.HCLK_Frequency);
 80005dc:	9801      	ldr	r0, [sp, #4]
#if (OS_VERSION >= 30000u)
    cnts         = (cpu_clk_freq / OSCfg_TickRate_Hz);          /* Determine nbr SysTick increments                     */
#else
    cnts         = (cpu_clk_freq / OS_TICKS_PER_SEC);
#endif
    OS_CPU_SysTickInit(cnts);                                   /* Initialize the SysTick.                            */
 80005de:	681b      	ldr	r3, [r3, #0]
 80005e0:	fbb0 f0f3 	udiv	r0, r0, r3
 80005e4:	f004 fa16 	bl	8004a14 <OS_CPU_SysTickInit>
}
 80005e8:	b005      	add	sp, #20
 80005ea:	f85d fb04 	ldr.w	pc, [sp], #4
 80005ee:	bf00      	nop
 80005f0:	080160cc 	.word	0x080160cc

080005f4 <BSP_PSRAM_Init>:
* Note(s)     : none.
*********************************************************************************************************
*/

void  BSP_PSRAM_Init(void)
{
 80005f4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
    GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;

    GPIO_Init(GPIOB, &GPIO_InitStructure);

    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0  | GPIO_Pin_1  |
 80005f8:	f64f 79fb 	movw	r9, #65531	; 0xfffb

void  BSP_PSRAM_Init(void)
{
    GPIO_InitTypeDef GPIO_InitStructure;

    RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FSMC, ENABLE);
 80005fc:	2101      	movs	r1, #1
* Note(s)     : none.
*********************************************************************************************************
*/

void  BSP_PSRAM_Init(void)
{
 80005fe:	b083      	sub	sp, #12
    GPIO_InitTypeDef GPIO_InitStructure;

    RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FSMC, ENABLE);
 8000600:	4608      	mov	r0, r1
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
    GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;

    GPIO_Init(GPIOD, &GPIO_InitStructure);
 8000602:	4da5      	ldr	r5, [pc, #660]	; (8000898 <BSP_PSRAM_Init+0x2a4>)

void  BSP_PSRAM_Init(void)
{
    GPIO_InitTypeDef GPIO_InitStructure;

    RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FSMC, ENABLE);
 8000604:	f008 fc1c 	bl	8008e40 <RCC_AHB3PeriphClockCmd>
    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB |
 8000608:	2101      	movs	r1, #1
 800060a:	207a      	movs	r0, #122	; 0x7a
 800060c:	f008 fbfc 	bl	8008e08 <RCC_AHB1PeriphClockCmd>


    GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_7;
    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8000610:	2600      	movs	r6, #0
                           RCC_AHB1Periph_GPIOE |
                           RCC_AHB1Periph_GPIOF |
                           RCC_AHB1Periph_GPIOG, ENABLE);


    GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_7;
 8000612:	2380      	movs	r3, #128	; 0x80
    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
    GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
 8000614:	f04f 0801 	mov.w	r8, #1
                           RCC_AHB1Periph_GPIOF |
                           RCC_AHB1Periph_GPIOG, ENABLE);


    GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_7;
    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
 8000618:	2702      	movs	r7, #2
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
    GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;

    GPIO_Init(GPIOB, &GPIO_InitStructure);
 800061a:	4669      	mov	r1, sp
 800061c:	489f      	ldr	r0, [pc, #636]	; (800089c <BSP_PSRAM_Init+0x2a8>)
                           RCC_AHB1Periph_GPIOE |
                           RCC_AHB1Periph_GPIOF |
                           RCC_AHB1Periph_GPIOG, ENABLE);


    GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_7;
 800061e:	9300      	str	r3, [sp, #0]
    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
 8000620:	f88d 7004 	strb.w	r7, [sp, #4]
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8000624:	f88d 7005 	strb.w	r7, [sp, #5]
    GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8000628:	f88d 6006 	strb.w	r6, [sp, #6]
    GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
    GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
 800062c:	f88d 8007 	strb.w	r8, [sp, #7]

    GPIO_Init(GPIOB, &GPIO_InitStructure);
 8000630:	f008 f9f2 	bl	8008a18 <GPIO_Init>
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
    GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;

    GPIO_Init(GPIOD, &GPIO_InitStructure);
 8000634:	4669      	mov	r1, sp
 8000636:	4628      	mov	r0, r5
                                  GPIO_Pin_9  | GPIO_Pin_10 |
                                  GPIO_Pin_11 | GPIO_Pin_12 |
                                  GPIO_Pin_13 | GPIO_Pin_14 |
                                  GPIO_Pin_15;

    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
 8000638:	f88d 7004 	strb.w	r7, [sp, #4]
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800063c:	f88d 7005 	strb.w	r7, [sp, #5]
    GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8000640:	f88d 6006 	strb.w	r6, [sp, #6]
    GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
    GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
 8000644:	f88d 8007 	strb.w	r8, [sp, #7]
    GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
    GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;

    GPIO_Init(GPIOB, &GPIO_InitStructure);

    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0  | GPIO_Pin_1  |
 8000648:	f8cd 9000 	str.w	r9, [sp]
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
    GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;

    GPIO_Init(GPIOD, &GPIO_InitStructure);
 800064c:	f008 f9e4 	bl	8008a18 <GPIO_Init>

    GPIO_PinAFConfig(GPIOD, GPIO_PinSource0, GPIO_AF_FSMC);
 8000650:	4631      	mov	r1, r6
 8000652:	4628      	mov	r0, r5
 8000654:	220c      	movs	r2, #12
 8000656:	f008 fa71 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOD, GPIO_PinSource1, GPIO_AF_FSMC);
 800065a:	4641      	mov	r1, r8
 800065c:	4628      	mov	r0, r5
 800065e:	220c      	movs	r2, #12
 8000660:	f008 fa6c 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOD, GPIO_PinSource3, GPIO_AF_FSMC);
 8000664:	4628      	mov	r0, r5
 8000666:	220c      	movs	r2, #12
 8000668:	2103      	movs	r1, #3
 800066a:	f008 fa67 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOD, GPIO_PinSource4, GPIO_AF_FSMC);
 800066e:	4628      	mov	r0, r5
 8000670:	220c      	movs	r2, #12
 8000672:	2104      	movs	r1, #4
 8000674:	f008 fa62 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOD, GPIO_PinSource5, GPIO_AF_FSMC);
 8000678:	4628      	mov	r0, r5
 800067a:	220c      	movs	r2, #12
 800067c:	2105      	movs	r1, #5
 800067e:	f008 fa5d 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOD, GPIO_PinSource6, GPIO_AF_FSMC);
 8000682:	4628      	mov	r0, r5
 8000684:	220c      	movs	r2, #12
 8000686:	2106      	movs	r1, #6
 8000688:	f008 fa58 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOD, GPIO_PinSource7, GPIO_AF_FSMC);
 800068c:	4628      	mov	r0, r5
 800068e:	220c      	movs	r2, #12
 8000690:	2107      	movs	r1, #7
 8000692:	f008 fa53 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOD, GPIO_PinSource8, GPIO_AF_FSMC);
 8000696:	4628      	mov	r0, r5
 8000698:	220c      	movs	r2, #12
 800069a:	2108      	movs	r1, #8
 800069c:	f008 fa4e 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOD, GPIO_PinSource9, GPIO_AF_FSMC);
 80006a0:	4628      	mov	r0, r5
 80006a2:	220c      	movs	r2, #12
 80006a4:	2109      	movs	r1, #9
 80006a6:	f008 fa49 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOD, GPIO_PinSource10, GPIO_AF_FSMC);
 80006aa:	4628      	mov	r0, r5
 80006ac:	220c      	movs	r2, #12
 80006ae:	210a      	movs	r1, #10
 80006b0:	f008 fa44 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOD, GPIO_PinSource11, GPIO_AF_FSMC);
 80006b4:	4628      	mov	r0, r5
 80006b6:	220c      	movs	r2, #12
 80006b8:	210b      	movs	r1, #11
 80006ba:	f008 fa3f 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOD, GPIO_PinSource12, GPIO_AF_FSMC);
 80006be:	220c      	movs	r2, #12
 80006c0:	4628      	mov	r0, r5
 80006c2:	4611      	mov	r1, r2
 80006c4:	f008 fa3a 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOD, GPIO_PinSource13, GPIO_AF_FSMC);
 80006c8:	4628      	mov	r0, r5
 80006ca:	220c      	movs	r2, #12
 80006cc:	210d      	movs	r1, #13
                                  GPIO_Pin_9  | GPIO_Pin_10 |
                                  GPIO_Pin_11 | GPIO_Pin_12 |
                                  GPIO_Pin_13 | GPIO_Pin_14 |
                                  GPIO_Pin_15;

    GPIO_Init(GPIOE, &GPIO_InitStructure);
 80006ce:	4c74      	ldr	r4, [pc, #464]	; (80008a0 <BSP_PSRAM_Init+0x2ac>)
    GPIO_PinAFConfig(GPIOD, GPIO_PinSource8, GPIO_AF_FSMC);
    GPIO_PinAFConfig(GPIOD, GPIO_PinSource9, GPIO_AF_FSMC);
    GPIO_PinAFConfig(GPIOD, GPIO_PinSource10, GPIO_AF_FSMC);
    GPIO_PinAFConfig(GPIOD, GPIO_PinSource11, GPIO_AF_FSMC);
    GPIO_PinAFConfig(GPIOD, GPIO_PinSource12, GPIO_AF_FSMC);
    GPIO_PinAFConfig(GPIOD, GPIO_PinSource13, GPIO_AF_FSMC);
 80006d0:	f008 fa34 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOD, GPIO_PinSource14, GPIO_AF_FSMC);
 80006d4:	4628      	mov	r0, r5
 80006d6:	220c      	movs	r2, #12
 80006d8:	210e      	movs	r1, #14
 80006da:	f008 fa2f 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOD, GPIO_PinSource15, GPIO_AF_FSMC);
 80006de:	4628      	mov	r0, r5
 80006e0:	220c      	movs	r2, #12
 80006e2:	210f      	movs	r1, #15
 80006e4:	f008 fa2a 	bl	8008b3c <GPIO_PinAFConfig>
                                  GPIO_Pin_9  | GPIO_Pin_10 |
                                  GPIO_Pin_11 | GPIO_Pin_12 |
                                  GPIO_Pin_13 | GPIO_Pin_14 |
                                  GPIO_Pin_15;

    GPIO_Init(GPIOE, &GPIO_InitStructure);
 80006e8:	4669      	mov	r1, sp
 80006ea:	4620      	mov	r0, r4
    GPIO_PinAFConfig(GPIOD, GPIO_PinSource12, GPIO_AF_FSMC);
    GPIO_PinAFConfig(GPIOD, GPIO_PinSource13, GPIO_AF_FSMC);
    GPIO_PinAFConfig(GPIOD, GPIO_PinSource14, GPIO_AF_FSMC);
    GPIO_PinAFConfig(GPIOD, GPIO_PinSource15, GPIO_AF_FSMC);

    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0  | GPIO_Pin_1  |
 80006ec:	f8cd 9000 	str.w	r9, [sp]
                                  GPIO_Pin_9  | GPIO_Pin_10 |
                                  GPIO_Pin_11 | GPIO_Pin_12 |
                                  GPIO_Pin_13 | GPIO_Pin_14 |
                                  GPIO_Pin_15;

    GPIO_Init(GPIOE, &GPIO_InitStructure);
 80006f0:	f008 f992 	bl	8008a18 <GPIO_Init>

    GPIO_PinAFConfig(GPIOE, GPIO_PinSource0, GPIO_AF_FSMC);
 80006f4:	4631      	mov	r1, r6
 80006f6:	4620      	mov	r0, r4
 80006f8:	220c      	movs	r2, #12
 80006fa:	f008 fa1f 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOE, GPIO_PinSource1, GPIO_AF_FSMC);
 80006fe:	4641      	mov	r1, r8
 8000700:	4620      	mov	r0, r4
 8000702:	220c      	movs	r2, #12
 8000704:	f008 fa1a 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOE, GPIO_PinSource3, GPIO_AF_FSMC);
 8000708:	4620      	mov	r0, r4
 800070a:	220c      	movs	r2, #12
 800070c:	2103      	movs	r1, #3
 800070e:	f008 fa15 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOE, GPIO_PinSource4, GPIO_AF_FSMC);
 8000712:	4620      	mov	r0, r4
 8000714:	220c      	movs	r2, #12
 8000716:	2104      	movs	r1, #4
 8000718:	f008 fa10 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOE, GPIO_PinSource5, GPIO_AF_FSMC);
 800071c:	4620      	mov	r0, r4
 800071e:	220c      	movs	r2, #12
 8000720:	2105      	movs	r1, #5
 8000722:	f008 fa0b 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOE, GPIO_PinSource6, GPIO_AF_FSMC);
 8000726:	4620      	mov	r0, r4
 8000728:	220c      	movs	r2, #12
 800072a:	2106      	movs	r1, #6
 800072c:	f008 fa06 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOE, GPIO_PinSource7, GPIO_AF_FSMC);
 8000730:	4620      	mov	r0, r4
 8000732:	220c      	movs	r2, #12
 8000734:	2107      	movs	r1, #7
 8000736:	f008 fa01 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOE, GPIO_PinSource8, GPIO_AF_FSMC);
 800073a:	4620      	mov	r0, r4
 800073c:	220c      	movs	r2, #12
 800073e:	2108      	movs	r1, #8
 8000740:	f008 f9fc 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOE, GPIO_PinSource9, GPIO_AF_FSMC);
 8000744:	4620      	mov	r0, r4
 8000746:	220c      	movs	r2, #12
 8000748:	2109      	movs	r1, #9
 800074a:	f008 f9f7 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOE, GPIO_PinSource10, GPIO_AF_FSMC);
 800074e:	4620      	mov	r0, r4
 8000750:	220c      	movs	r2, #12
 8000752:	210a      	movs	r1, #10
 8000754:	f008 f9f2 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOE, GPIO_PinSource11, GPIO_AF_FSMC);
 8000758:	4620      	mov	r0, r4
 800075a:	220c      	movs	r2, #12
 800075c:	210b      	movs	r1, #11
 800075e:	f008 f9ed 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOE, GPIO_PinSource12, GPIO_AF_FSMC);
 8000762:	220c      	movs	r2, #12
 8000764:	4620      	mov	r0, r4
 8000766:	4611      	mov	r1, r2
 8000768:	f008 f9e8 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOE, GPIO_PinSource13, GPIO_AF_FSMC);
 800076c:	4620      	mov	r0, r4
 800076e:	220c      	movs	r2, #12
 8000770:	210d      	movs	r1, #13
 8000772:	f008 f9e3 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOE, GPIO_PinSource14, GPIO_AF_FSMC);
 8000776:	4620      	mov	r0, r4
 8000778:	220c      	movs	r2, #12
 800077a:	210e      	movs	r1, #14
 800077c:	f008 f9de 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOE, GPIO_PinSource15, GPIO_AF_FSMC);
 8000780:	4620      	mov	r0, r4
 8000782:	220c      	movs	r2, #12
 8000784:	210f      	movs	r1, #15
 8000786:	f008 f9d9 	bl	8008b3c <GPIO_PinAFConfig>

    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0  | GPIO_Pin_1  |
 800078a:	f24f 033f 	movw	r3, #61503	; 0xf03f
                                  GPIO_Pin_2  | GPIO_Pin_3  |
                                  GPIO_Pin_4  | GPIO_Pin_5  |
                                  GPIO_Pin_12 | GPIO_Pin_13 |
                                  GPIO_Pin_14 | GPIO_Pin_15;

    GPIO_Init(GPIOF, &GPIO_InitStructure);
 800078e:	f504 6480 	add.w	r4, r4, #1024	; 0x400
 8000792:	4669      	mov	r1, sp
 8000794:	4620      	mov	r0, r4
    GPIO_PinAFConfig(GPIOE, GPIO_PinSource12, GPIO_AF_FSMC);
    GPIO_PinAFConfig(GPIOE, GPIO_PinSource13, GPIO_AF_FSMC);
    GPIO_PinAFConfig(GPIOE, GPIO_PinSource14, GPIO_AF_FSMC);
    GPIO_PinAFConfig(GPIOE, GPIO_PinSource15, GPIO_AF_FSMC);

    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0  | GPIO_Pin_1  |
 8000796:	9300      	str	r3, [sp, #0]
                                  GPIO_Pin_2  | GPIO_Pin_3  |
                                  GPIO_Pin_4  | GPIO_Pin_5  |
                                  GPIO_Pin_12 | GPIO_Pin_13 |
                                  GPIO_Pin_14 | GPIO_Pin_15;

    GPIO_Init(GPIOF, &GPIO_InitStructure);
 8000798:	f008 f93e 	bl	8008a18 <GPIO_Init>

    GPIO_PinAFConfig(GPIOF, GPIO_PinSource0, GPIO_AF_FSMC);
 800079c:	4631      	mov	r1, r6
 800079e:	4620      	mov	r0, r4
 80007a0:	220c      	movs	r2, #12
 80007a2:	f008 f9cb 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOF, GPIO_PinSource1, GPIO_AF_FSMC);
 80007a6:	4641      	mov	r1, r8
 80007a8:	4620      	mov	r0, r4
 80007aa:	220c      	movs	r2, #12
 80007ac:	f008 f9c6 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOF, GPIO_PinSource2, GPIO_AF_FSMC);
 80007b0:	4639      	mov	r1, r7
 80007b2:	4620      	mov	r0, r4
 80007b4:	220c      	movs	r2, #12
 80007b6:	f008 f9c1 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOF, GPIO_PinSource3, GPIO_AF_FSMC);
 80007ba:	4620      	mov	r0, r4
 80007bc:	220c      	movs	r2, #12
 80007be:	2103      	movs	r1, #3
 80007c0:	f008 f9bc 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOF, GPIO_PinSource4, GPIO_AF_FSMC);
 80007c4:	4620      	mov	r0, r4
 80007c6:	220c      	movs	r2, #12
 80007c8:	2104      	movs	r1, #4
 80007ca:	f008 f9b7 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOF, GPIO_PinSource5, GPIO_AF_FSMC);
 80007ce:	4620      	mov	r0, r4
 80007d0:	220c      	movs	r2, #12
 80007d2:	2105      	movs	r1, #5
 80007d4:	f008 f9b2 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOF, GPIO_PinSource12, GPIO_AF_FSMC);
 80007d8:	220c      	movs	r2, #12
 80007da:	4620      	mov	r0, r4
 80007dc:	4611      	mov	r1, r2
 80007de:	f008 f9ad 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOF, GPIO_PinSource13, GPIO_AF_FSMC);
 80007e2:	4620      	mov	r0, r4
 80007e4:	220c      	movs	r2, #12
 80007e6:	210d      	movs	r1, #13
 80007e8:	f008 f9a8 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOF, GPIO_PinSource14, GPIO_AF_FSMC);
 80007ec:	4620      	mov	r0, r4
 80007ee:	220c      	movs	r2, #12
 80007f0:	210e      	movs	r1, #14

    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 |
                                  GPIO_Pin_2 | GPIO_Pin_3 |
                                  GPIO_Pin_4 | GPIO_Pin_5;

    GPIO_Init(GPIOG, &GPIO_InitStructure);
 80007f2:	f505 6540 	add.w	r5, r5, #3072	; 0xc00
    GPIO_PinAFConfig(GPIOF, GPIO_PinSource3, GPIO_AF_FSMC);
    GPIO_PinAFConfig(GPIOF, GPIO_PinSource4, GPIO_AF_FSMC);
    GPIO_PinAFConfig(GPIOF, GPIO_PinSource5, GPIO_AF_FSMC);
    GPIO_PinAFConfig(GPIOF, GPIO_PinSource12, GPIO_AF_FSMC);
    GPIO_PinAFConfig(GPIOF, GPIO_PinSource13, GPIO_AF_FSMC);
    GPIO_PinAFConfig(GPIOF, GPIO_PinSource14, GPIO_AF_FSMC);
 80007f6:	f008 f9a1 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOF, GPIO_PinSource15, GPIO_AF_FSMC);
 80007fa:	4620      	mov	r0, r4
 80007fc:	220c      	movs	r2, #12
 80007fe:	210f      	movs	r1, #15
 8000800:	f008 f99c 	bl	8008b3c <GPIO_PinAFConfig>


    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 |
 8000804:	233f      	movs	r3, #63	; 0x3f
                                  GPIO_Pin_2 | GPIO_Pin_3 |
                                  GPIO_Pin_4 | GPIO_Pin_5;

    GPIO_Init(GPIOG, &GPIO_InitStructure);
 8000806:	4669      	mov	r1, sp
 8000808:	4628      	mov	r0, r5
    GPIO_PinAFConfig(GPIOF, GPIO_PinSource13, GPIO_AF_FSMC);
    GPIO_PinAFConfig(GPIOF, GPIO_PinSource14, GPIO_AF_FSMC);
    GPIO_PinAFConfig(GPIOF, GPIO_PinSource15, GPIO_AF_FSMC);


    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 |
 800080a:	9300      	str	r3, [sp, #0]
                                  GPIO_Pin_2 | GPIO_Pin_3 |
                                  GPIO_Pin_4 | GPIO_Pin_5;

    GPIO_Init(GPIOG, &GPIO_InitStructure);
 800080c:	f008 f904 	bl	8008a18 <GPIO_Init>

    GPIO_PinAFConfig(GPIOG, GPIO_PinSource0, GPIO_AF_FSMC);
 8000810:	4631      	mov	r1, r6
 8000812:	4628      	mov	r0, r5
 8000814:	220c      	movs	r2, #12
 8000816:	f008 f991 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOG, GPIO_PinSource1, GPIO_AF_FSMC);
 800081a:	4641      	mov	r1, r8
 800081c:	4628      	mov	r0, r5
 800081e:	220c      	movs	r2, #12
 8000820:	f008 f98c 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOG, GPIO_PinSource2, GPIO_AF_FSMC);
 8000824:	4639      	mov	r1, r7
 8000826:	4628      	mov	r0, r5
 8000828:	220c      	movs	r2, #12
 800082a:	f008 f987 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOG, GPIO_PinSource3, GPIO_AF_FSMC);
 800082e:	4628      	mov	r0, r5
 8000830:	220c      	movs	r2, #12
 8000832:	2103      	movs	r1, #3
 8000834:	f008 f982 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOG, GPIO_PinSource4, GPIO_AF_FSMC);
 8000838:	4628      	mov	r0, r5
 800083a:	220c      	movs	r2, #12
 800083c:	2104      	movs	r1, #4
 800083e:	f008 f97d 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOG, GPIO_PinSource5, GPIO_AF_FSMC);
 8000842:	220c      	movs	r2, #12
 8000844:	4628      	mov	r0, r5
 8000846:	2105      	movs	r1, #5
 8000848:	f008 f978 	bl	8008b3c <GPIO_PinAFConfig>


    GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_6;
 800084c:	2540      	movs	r5, #64	; 0x40
    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
    GPIO_Init(GPIOF, &GPIO_InitStructure);
 800084e:	4669      	mov	r1, sp
 8000850:	4620      	mov	r0, r4
    GPIO_PinAFConfig(GPIOG, GPIO_PinSource4, GPIO_AF_FSMC);
    GPIO_PinAFConfig(GPIOG, GPIO_PinSource5, GPIO_AF_FSMC);


    GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_6;
    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;
 8000852:	f88d 8004 	strb.w	r8, [sp, #4]
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8000856:	f88d 7005 	strb.w	r7, [sp, #5]
    GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800085a:	f88d 6006 	strb.w	r6, [sp, #6]
    GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
 800085e:	f88d 6007 	strb.w	r6, [sp, #7]
    GPIO_PinAFConfig(GPIOG, GPIO_PinSource3, GPIO_AF_FSMC);
    GPIO_PinAFConfig(GPIOG, GPIO_PinSource4, GPIO_AF_FSMC);
    GPIO_PinAFConfig(GPIOG, GPIO_PinSource5, GPIO_AF_FSMC);


    GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_6;
 8000862:	9500      	str	r5, [sp, #0]
    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
    GPIO_Init(GPIOF, &GPIO_InitStructure);
 8000864:	f008 f8d8 	bl	8008a18 <GPIO_Init>

    GPIO_ResetBits(GPIOF, GPIO_Pin_6);
 8000868:	4629      	mov	r1, r5
 800086a:	4620      	mov	r0, r4
 800086c:	f008 f958 	bl	8008b20 <GPIO_ResetBits>

    FSMC_Bank1->BTCR[0] = FSMC_DataAddressMux_Disable | FSMC_MemoryType_SRAM       |
 8000870:	f241 0410 	movw	r4, #4112	; 0x1010

    FSMC_Bank1->BTCR[0] = FSMC_DataAddressMux_Disable | FSMC_MemoryType_SRAM       |
                          FSMC_MemoryDataWidth_16b    | FSMC_WriteOperation_Enable |
                          FSMC_ExtendedMode_Enable    | FSMC_AsynchronousWait_Disable;

    FSMC_Bank1->BTCR[1]  = 0x00000404;
 8000874:	f240 4204 	movw	r2, #1028	; 0x404

    FSMC_Bank1->BTCR[0] = FSMC_DataAddressMux_Disable | FSMC_MemoryType_SRAM       |
                          FSMC_MemoryDataWidth_16b    | FSMC_WriteOperation_Enable |
                          FSMC_ExtendedMode_Disable   | FSMC_AsynchronousWait_Disable;

    FSMC_Bank1->BTCR[0] = FSMC_DataAddressMux_Disable | FSMC_MemoryType_SRAM       |
 8000878:	f245 0010 	movw	r0, #20496	; 0x5010
                          FSMC_MemoryDataWidth_16b    | FSMC_WriteOperation_Enable |
                          FSMC_ExtendedMode_Enable    | FSMC_AsynchronousWait_Disable;

    FSMC_Bank1->BTCR[1]  = 0x00000404;
    FSMC_Bank1E->BWTR[0] = 0x00000404;
 800087c:	4909      	ldr	r1, [pc, #36]	; (80008a4 <BSP_PSRAM_Init+0x2b0>)
    GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
    GPIO_Init(GPIOF, &GPIO_InitStructure);

    GPIO_ResetBits(GPIOF, GPIO_Pin_6);

    FSMC_Bank1->BTCR[0] = FSMC_DataAddressMux_Disable | FSMC_MemoryType_SRAM       |
 800087e:	f04f 4320 	mov.w	r3, #2684354560	; 0xa0000000
 8000882:	601c      	str	r4, [r3, #0]
                          FSMC_MemoryDataWidth_16b    | FSMC_WriteOperation_Enable |
                          FSMC_ExtendedMode_Disable   | FSMC_AsynchronousWait_Disable;

    FSMC_Bank1->BTCR[0] = FSMC_DataAddressMux_Disable | FSMC_MemoryType_SRAM       |
 8000884:	6018      	str	r0, [r3, #0]
                          FSMC_MemoryDataWidth_16b    | FSMC_WriteOperation_Enable |
                          FSMC_ExtendedMode_Enable    | FSMC_AsynchronousWait_Disable;

    FSMC_Bank1->BTCR[1]  = 0x00000404;
 8000886:	605a      	str	r2, [r3, #4]
    FSMC_Bank1E->BWTR[0] = 0x00000404;
 8000888:	600a      	str	r2, [r1, #0]

    FSMC_Bank1->BTCR[0] |= 0x0001;
 800088a:	681a      	ldr	r2, [r3, #0]
 800088c:	ea42 0208 	orr.w	r2, r2, r8
 8000890:	601a      	str	r2, [r3, #0]
}
 8000892:	b003      	add	sp, #12
 8000894:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8000898:	40020c00 	.word	0x40020c00
 800089c:	40020400 	.word	0x40020400
 80008a0:	40021000 	.word	0x40021000
 80008a4:	a0000104 	.word	0xa0000104

080008a8 <BSP_SRAM_Init>:
* Note(s)     : none.
*********************************************************************************************************
*/

void  BSP_SRAM_Init(void)
{
 80008a8:	b5f0      	push	{r4, r5, r6, r7, lr}
    FSMC_NORSRAMInitTypeDef        FSMC_SRAM_Init;
    FSMC_NORSRAMTimingInitTypeDef  FSMC_SRAM_TimingInit;
    GPIO_InitTypeDef               GPIO_InitStructure;


    RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FSMC, ENABLE);
 80008aa:	2101      	movs	r1, #1
* Note(s)     : none.
*********************************************************************************************************
*/

void  BSP_SRAM_Init(void)
{
 80008ac:	b099      	sub	sp, #100	; 0x64
    FSMC_NORSRAMInitTypeDef        FSMC_SRAM_Init;
    FSMC_NORSRAMTimingInitTypeDef  FSMC_SRAM_TimingInit;
    GPIO_InitTypeDef               GPIO_InitStructure;


    RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FSMC, ENABLE);
 80008ae:	4608      	mov	r0, r1
 80008b0:	f008 fac6 	bl	8008e40 <RCC_AHB3PeriphClockCmd>
    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD |
 80008b4:	2101      	movs	r1, #1
 80008b6:	2078      	movs	r0, #120	; 0x78
 80008b8:	f008 faa6 	bl	8008e08 <RCC_AHB1PeriphClockCmd>
                           RCC_AHB1Periph_GPIOE |
                           RCC_AHB1Periph_GPIOF |
                           RCC_AHB1Periph_GPIOG,
                           ENABLE);

    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0  | GPIO_Pin_1  |
 80008bc:	f64f 7333 	movw	r3, #65331	; 0xff33
    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
    GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;

    GPIO_Init(GPIOD, &GPIO_InitStructure);
 80008c0:	4d98      	ldr	r5, [pc, #608]	; (8000b24 <BSP_SRAM_Init+0x27c>)
                                  GPIO_Pin_12 | GPIO_Pin_13 |
                                  GPIO_Pin_14 | GPIO_Pin_15;

    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
    GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 80008c2:	2400      	movs	r4, #0
                                  GPIO_Pin_8  | GPIO_Pin_9  |
                                  GPIO_Pin_10 | GPIO_Pin_11 |
                                  GPIO_Pin_12 | GPIO_Pin_13 |
                                  GPIO_Pin_14 | GPIO_Pin_15;

    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
 80008c4:	2602      	movs	r6, #2
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 80008c6:	2703      	movs	r7, #3
    GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;

    GPIO_Init(GPIOD, &GPIO_InitStructure);
 80008c8:	4628      	mov	r0, r5
 80008ca:	4669      	mov	r1, sp
                           RCC_AHB1Periph_GPIOE |
                           RCC_AHB1Periph_GPIOF |
                           RCC_AHB1Periph_GPIOG,
                           ENABLE);

    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0  | GPIO_Pin_1  |
 80008cc:	9300      	str	r3, [sp, #0]
                                  GPIO_Pin_10 | GPIO_Pin_11 |
                                  GPIO_Pin_12 | GPIO_Pin_13 |
                                  GPIO_Pin_14 | GPIO_Pin_15;

    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 80008ce:	f88d 7005 	strb.w	r7, [sp, #5]
                                  GPIO_Pin_8  | GPIO_Pin_9  |
                                  GPIO_Pin_10 | GPIO_Pin_11 |
                                  GPIO_Pin_12 | GPIO_Pin_13 |
                                  GPIO_Pin_14 | GPIO_Pin_15;

    GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF;
 80008d2:	f88d 6004 	strb.w	r6, [sp, #4]
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
    GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 80008d6:	f88d 4006 	strb.w	r4, [sp, #6]
    GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
 80008da:	f88d 4007 	strb.w	r4, [sp, #7]

    GPIO_Init(GPIOD, &GPIO_InitStructure);
 80008de:	f008 f89b 	bl	8008a18 <GPIO_Init>

    GPIO_PinAFConfig(GPIOD, GPIO_PinSource0,  GPIO_AF_FSMC);
 80008e2:	4621      	mov	r1, r4
 80008e4:	4628      	mov	r0, r5
 80008e6:	220c      	movs	r2, #12
 80008e8:	f008 f928 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOD, GPIO_PinSource1,  GPIO_AF_FSMC);
 80008ec:	4628      	mov	r0, r5
 80008ee:	220c      	movs	r2, #12
 80008f0:	2101      	movs	r1, #1
 80008f2:	f008 f923 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOD, GPIO_PinSource4,  GPIO_AF_FSMC);
 80008f6:	4628      	mov	r0, r5
 80008f8:	220c      	movs	r2, #12
 80008fa:	2104      	movs	r1, #4
 80008fc:	f008 f91e 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOD, GPIO_PinSource5,  GPIO_AF_FSMC);
 8000900:	4628      	mov	r0, r5
 8000902:	220c      	movs	r2, #12
 8000904:	2105      	movs	r1, #5
 8000906:	f008 f919 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOD, GPIO_PinSource8,  GPIO_AF_FSMC);
 800090a:	4628      	mov	r0, r5
 800090c:	220c      	movs	r2, #12
 800090e:	2108      	movs	r1, #8
 8000910:	f008 f914 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOD, GPIO_PinSource9,  GPIO_AF_FSMC);
 8000914:	4628      	mov	r0, r5
 8000916:	220c      	movs	r2, #12
 8000918:	2109      	movs	r1, #9
 800091a:	f008 f90f 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOD, GPIO_PinSource10, GPIO_AF_FSMC);
 800091e:	4628      	mov	r0, r5
 8000920:	220c      	movs	r2, #12
 8000922:	210a      	movs	r1, #10
 8000924:	f008 f90a 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOD, GPIO_PinSource11, GPIO_AF_FSMC);
 8000928:	4628      	mov	r0, r5
 800092a:	220c      	movs	r2, #12
 800092c:	210b      	movs	r1, #11
 800092e:	f008 f905 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOD, GPIO_PinSource12, GPIO_AF_FSMC);
 8000932:	220c      	movs	r2, #12
 8000934:	4628      	mov	r0, r5
 8000936:	4611      	mov	r1, r2
 8000938:	f008 f900 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOD, GPIO_PinSource13, GPIO_AF_FSMC);
 800093c:	4628      	mov	r0, r5
 800093e:	220c      	movs	r2, #12
 8000940:	210d      	movs	r1, #13
 8000942:	f008 f8fb 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOD, GPIO_PinSource14, GPIO_AF_FSMC);
 8000946:	4628      	mov	r0, r5
 8000948:	220c      	movs	r2, #12
 800094a:	210e      	movs	r1, #14
 800094c:	f008 f8f6 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOD, GPIO_PinSource15, GPIO_AF_FSMC);
 8000950:	4628      	mov	r0, r5
 8000952:	220c      	movs	r2, #12
 8000954:	210f      	movs	r1, #15
 8000956:	f008 f8f1 	bl	8008b3c <GPIO_PinAFConfig>


    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0  | GPIO_Pin_1   |
 800095a:	f64f 73fb 	movw	r3, #65531	; 0xfffb
                                  GPIO_Pin_9  | GPIO_Pin_10  |
                                  GPIO_Pin_11 | GPIO_Pin_12  |
                                  GPIO_Pin_13 | GPIO_Pin_14  |
                                  GPIO_Pin_15;

    GPIO_Init(GPIOE, &GPIO_InitStructure);
 800095e:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000962:	4669      	mov	r1, sp
 8000964:	4628      	mov	r0, r5
    GPIO_PinAFConfig(GPIOD, GPIO_PinSource13, GPIO_AF_FSMC);
    GPIO_PinAFConfig(GPIOD, GPIO_PinSource14, GPIO_AF_FSMC);
    GPIO_PinAFConfig(GPIOD, GPIO_PinSource15, GPIO_AF_FSMC);


    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0  | GPIO_Pin_1   |
 8000966:	9300      	str	r3, [sp, #0]
                                  GPIO_Pin_9  | GPIO_Pin_10  |
                                  GPIO_Pin_11 | GPIO_Pin_12  |
                                  GPIO_Pin_13 | GPIO_Pin_14  |
                                  GPIO_Pin_15;

    GPIO_Init(GPIOE, &GPIO_InitStructure);
 8000968:	f008 f856 	bl	8008a18 <GPIO_Init>

    GPIO_PinAFConfig(GPIOE, GPIO_PinSource0,  GPIO_AF_FSMC);
 800096c:	4621      	mov	r1, r4
 800096e:	4628      	mov	r0, r5
 8000970:	220c      	movs	r2, #12
 8000972:	f008 f8e3 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOE, GPIO_PinSource1,  GPIO_AF_FSMC);
 8000976:	4628      	mov	r0, r5
 8000978:	220c      	movs	r2, #12
 800097a:	2101      	movs	r1, #1
 800097c:	f008 f8de 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOE, GPIO_PinSource3,  GPIO_AF_FSMC);
 8000980:	4639      	mov	r1, r7
 8000982:	4628      	mov	r0, r5
 8000984:	220c      	movs	r2, #12
 8000986:	f008 f8d9 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOE, GPIO_PinSource4,  GPIO_AF_FSMC);
 800098a:	4628      	mov	r0, r5
 800098c:	220c      	movs	r2, #12
 800098e:	2104      	movs	r1, #4
 8000990:	f008 f8d4 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOE, GPIO_PinSource5,  GPIO_AF_FSMC);
 8000994:	4628      	mov	r0, r5
 8000996:	220c      	movs	r2, #12
 8000998:	2105      	movs	r1, #5
 800099a:	f008 f8cf 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOE, GPIO_PinSource6,  GPIO_AF_FSMC);
 800099e:	4628      	mov	r0, r5
 80009a0:	220c      	movs	r2, #12
 80009a2:	2106      	movs	r1, #6
 80009a4:	f008 f8ca 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOE, GPIO_PinSource7,  GPIO_AF_FSMC);
 80009a8:	4628      	mov	r0, r5
 80009aa:	220c      	movs	r2, #12
 80009ac:	2107      	movs	r1, #7
 80009ae:	f008 f8c5 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOE, GPIO_PinSource8,  GPIO_AF_FSMC);
 80009b2:	4628      	mov	r0, r5
 80009b4:	220c      	movs	r2, #12
 80009b6:	2108      	movs	r1, #8
 80009b8:	f008 f8c0 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOE, GPIO_PinSource9,  GPIO_AF_FSMC);
 80009bc:	4628      	mov	r0, r5
 80009be:	220c      	movs	r2, #12
 80009c0:	2109      	movs	r1, #9
 80009c2:	f008 f8bb 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOE, GPIO_PinSource10, GPIO_AF_FSMC);
 80009c6:	4628      	mov	r0, r5
 80009c8:	220c      	movs	r2, #12
 80009ca:	210a      	movs	r1, #10
 80009cc:	f008 f8b6 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOE, GPIO_PinSource11, GPIO_AF_FSMC);
 80009d0:	4628      	mov	r0, r5
 80009d2:	220c      	movs	r2, #12
 80009d4:	210b      	movs	r1, #11
 80009d6:	f008 f8b1 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOE, GPIO_PinSource12, GPIO_AF_FSMC);
 80009da:	220c      	movs	r2, #12
 80009dc:	4628      	mov	r0, r5
 80009de:	4611      	mov	r1, r2
 80009e0:	f008 f8ac 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOE, GPIO_PinSource13, GPIO_AF_FSMC);
 80009e4:	4628      	mov	r0, r5
 80009e6:	220c      	movs	r2, #12
 80009e8:	210d      	movs	r1, #13
 80009ea:	f008 f8a7 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOE, GPIO_PinSource14, GPIO_AF_FSMC);
 80009ee:	4628      	mov	r0, r5
 80009f0:	220c      	movs	r2, #12
 80009f2:	210e      	movs	r1, #14
 80009f4:	f008 f8a2 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOE, GPIO_PinSource15, GPIO_AF_FSMC);
 80009f8:	4628      	mov	r0, r5
 80009fa:	220c      	movs	r2, #12
 80009fc:	210f      	movs	r1, #15
 80009fe:	f008 f89d 	bl	8008b3c <GPIO_PinAFConfig>

    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0  | GPIO_Pin_1  |
 8000a02:	f24f 033f 	movw	r3, #61503	; 0xf03f
                                  GPIO_Pin_2  | GPIO_Pin_3  |
                                  GPIO_Pin_4  | GPIO_Pin_5  |
                                  GPIO_Pin_12 | GPIO_Pin_13 |
                                  GPIO_Pin_14 | GPIO_Pin_15;

    GPIO_Init(GPIOF, &GPIO_InitStructure);
 8000a06:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000a0a:	4669      	mov	r1, sp
 8000a0c:	4628      	mov	r0, r5
    GPIO_PinAFConfig(GPIOE, GPIO_PinSource12, GPIO_AF_FSMC);
    GPIO_PinAFConfig(GPIOE, GPIO_PinSource13, GPIO_AF_FSMC);
    GPIO_PinAFConfig(GPIOE, GPIO_PinSource14, GPIO_AF_FSMC);
    GPIO_PinAFConfig(GPIOE, GPIO_PinSource15, GPIO_AF_FSMC);

    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0  | GPIO_Pin_1  |
 8000a0e:	9300      	str	r3, [sp, #0]
                                  GPIO_Pin_2  | GPIO_Pin_3  |
                                  GPIO_Pin_4  | GPIO_Pin_5  |
                                  GPIO_Pin_12 | GPIO_Pin_13 |
                                  GPIO_Pin_14 | GPIO_Pin_15;

    GPIO_Init(GPIOF, &GPIO_InitStructure);
 8000a10:	f008 f802 	bl	8008a18 <GPIO_Init>

    GPIO_PinAFConfig(GPIOF, GPIO_PinSource0,  GPIO_AF_FSMC);
 8000a14:	4621      	mov	r1, r4
 8000a16:	4628      	mov	r0, r5
 8000a18:	220c      	movs	r2, #12
 8000a1a:	f008 f88f 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOF, GPIO_PinSource1,  GPIO_AF_FSMC);
 8000a1e:	4628      	mov	r0, r5
 8000a20:	220c      	movs	r2, #12
 8000a22:	2101      	movs	r1, #1
 8000a24:	f008 f88a 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOF, GPIO_PinSource2,  GPIO_AF_FSMC);
 8000a28:	4631      	mov	r1, r6
 8000a2a:	4628      	mov	r0, r5
 8000a2c:	220c      	movs	r2, #12
 8000a2e:	f008 f885 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOF, GPIO_PinSource3,  GPIO_AF_FSMC);
 8000a32:	4639      	mov	r1, r7
 8000a34:	4628      	mov	r0, r5
 8000a36:	220c      	movs	r2, #12
 8000a38:	f008 f880 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOF, GPIO_PinSource4,  GPIO_AF_FSMC);
 8000a3c:	4628      	mov	r0, r5
 8000a3e:	220c      	movs	r2, #12
 8000a40:	2104      	movs	r1, #4
 8000a42:	f008 f87b 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOF, GPIO_PinSource5,  GPIO_AF_FSMC);
 8000a46:	4628      	mov	r0, r5
 8000a48:	220c      	movs	r2, #12
 8000a4a:	2105      	movs	r1, #5
 8000a4c:	f008 f876 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOF, GPIO_PinSource12, GPIO_AF_FSMC);
 8000a50:	220c      	movs	r2, #12
 8000a52:	4628      	mov	r0, r5
 8000a54:	4611      	mov	r1, r2
 8000a56:	f008 f871 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOF, GPIO_PinSource13, GPIO_AF_FSMC);
 8000a5a:	4628      	mov	r0, r5
 8000a5c:	220c      	movs	r2, #12
 8000a5e:	210d      	movs	r1, #13
 8000a60:	f008 f86c 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOF, GPIO_PinSource14, GPIO_AF_FSMC);
 8000a64:	4628      	mov	r0, r5
 8000a66:	220c      	movs	r2, #12
 8000a68:	210e      	movs	r1, #14
 8000a6a:	f008 f867 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOF, GPIO_PinSource15, GPIO_AF_FSMC);
 8000a6e:	4628      	mov	r0, r5
 8000a70:	220c      	movs	r2, #12
 8000a72:	210f      	movs	r1, #15
 8000a74:	f008 f862 	bl	8008b3c <GPIO_PinAFConfig>


    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 |
 8000a78:	f240 233f 	movw	r3, #575	; 0x23f
                                  GPIO_Pin_2 | GPIO_Pin_3 |
                                  GPIO_Pin_4 | GPIO_Pin_5 |
                                  GPIO_Pin_9;

    GPIO_Init(GPIOG, &GPIO_InitStructure);
 8000a7c:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000a80:	4669      	mov	r1, sp
 8000a82:	4628      	mov	r0, r5
    GPIO_PinAFConfig(GPIOF, GPIO_PinSource13, GPIO_AF_FSMC);
    GPIO_PinAFConfig(GPIOF, GPIO_PinSource14, GPIO_AF_FSMC);
    GPIO_PinAFConfig(GPIOF, GPIO_PinSource15, GPIO_AF_FSMC);


    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 |
 8000a84:	9300      	str	r3, [sp, #0]
                                  GPIO_Pin_2 | GPIO_Pin_3 |
                                  GPIO_Pin_4 | GPIO_Pin_5 |
                                  GPIO_Pin_9;

    GPIO_Init(GPIOG, &GPIO_InitStructure);
 8000a86:	f007 ffc7 	bl	8008a18 <GPIO_Init>

    GPIO_PinAFConfig(GPIOG, GPIO_PinSource0,  GPIO_AF_FSMC);
 8000a8a:	4621      	mov	r1, r4
 8000a8c:	4628      	mov	r0, r5
 8000a8e:	220c      	movs	r2, #12
 8000a90:	f008 f854 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOG, GPIO_PinSource1,  GPIO_AF_FSMC);
 8000a94:	4628      	mov	r0, r5
 8000a96:	220c      	movs	r2, #12
 8000a98:	2101      	movs	r1, #1
 8000a9a:	f008 f84f 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOG, GPIO_PinSource2,  GPIO_AF_FSMC);
 8000a9e:	4631      	mov	r1, r6
 8000aa0:	4628      	mov	r0, r5
 8000aa2:	220c      	movs	r2, #12
 8000aa4:	f008 f84a 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOG, GPIO_PinSource3,  GPIO_AF_FSMC);
 8000aa8:	4639      	mov	r1, r7
 8000aaa:	4628      	mov	r0, r5
 8000aac:	220c      	movs	r2, #12
 8000aae:	f008 f845 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOG, GPIO_PinSource4,  GPIO_AF_FSMC);
 8000ab2:	4628      	mov	r0, r5
 8000ab4:	220c      	movs	r2, #12
 8000ab6:	2104      	movs	r1, #4
 8000ab8:	f008 f840 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOG, GPIO_PinSource5,  GPIO_AF_FSMC);
 8000abc:	4628      	mov	r0, r5
 8000abe:	220c      	movs	r2, #12
 8000ac0:	2105      	movs	r1, #5
 8000ac2:	f008 f83b 	bl	8008b3c <GPIO_PinAFConfig>
    GPIO_PinAFConfig(GPIOG, GPIO_PinSource9,  GPIO_AF_FSMC);
 8000ac6:	4628      	mov	r0, r5
 8000ac8:	220c      	movs	r2, #12
 8000aca:	2109      	movs	r1, #9
 8000acc:	f008 f836 	bl	8008b3c <GPIO_PinAFConfig>

                                                                /*------------------- SRAM BANK 2 ----------------------*/
    FSMC_SRAM_TimingInit.FSMC_AddressSetupTime      = 0;
    FSMC_SRAM_TimingInit.FSMC_AddressHoldTime       = 0;
    FSMC_SRAM_TimingInit.FSMC_DataSetupTime         = 4;
    FSMC_SRAM_TimingInit.FSMC_BusTurnAroundDuration = 1;
 8000ad0:	2501      	movs	r5, #1
    FSMC_SRAM_TimingInit.FSMC_CLKDivision           = 0;
    FSMC_SRAM_TimingInit.FSMC_DataLatency           = 0;
    FSMC_SRAM_TimingInit.FSMC_AccessMode            = FSMC_AccessMode_A;

    FSMC_SRAM_Init.FSMC_ReadWriteTimingStruct = &FSMC_SRAM_TimingInit;
 8000ad2:	ab02      	add	r3, sp, #8
    GPIO_PinAFConfig(GPIOG, GPIO_PinSource9,  GPIO_AF_FSMC);

                                                                /*------------------- SRAM BANK 2 ----------------------*/
    FSMC_SRAM_TimingInit.FSMC_AddressSetupTime      = 0;
    FSMC_SRAM_TimingInit.FSMC_AddressHoldTime       = 0;
    FSMC_SRAM_TimingInit.FSMC_DataSetupTime         = 4;
 8000ad4:	f04f 0e04 	mov.w	lr, #4
    FSMC_SRAM_Init.FSMC_DataAddressMux        = FSMC_DataAddressMux_Disable;
    FSMC_SRAM_Init.FSMC_MemoryType            = FSMC_MemoryType_SRAM;
    FSMC_SRAM_Init.FSMC_MemoryDataWidth       = FSMC_MemoryDataWidth_16b;
    FSMC_SRAM_Init.FSMC_AsynchronousWait      = FSMC_AsynchronousWait_Disable;
    FSMC_SRAM_Init.FSMC_ExtendedMode          = FSMC_ExtendedMode_Enable;
    FSMC_SRAM_Init.FSMC_WriteOperation        = FSMC_WriteOperation_Enable;
 8000ad8:	f44f 5280 	mov.w	r2, #4096	; 0x1000

    FSMC_SRAM_Init.FSMC_DataAddressMux        = FSMC_DataAddressMux_Disable;
    FSMC_SRAM_Init.FSMC_MemoryType            = FSMC_MemoryType_SRAM;
    FSMC_SRAM_Init.FSMC_MemoryDataWidth       = FSMC_MemoryDataWidth_16b;
    FSMC_SRAM_Init.FSMC_AsynchronousWait      = FSMC_AsynchronousWait_Disable;
    FSMC_SRAM_Init.FSMC_ExtendedMode          = FSMC_ExtendedMode_Enable;
 8000adc:	f44f 4180 	mov.w	r1, #16384	; 0x4000
    FSMC_SRAM_Init.FSMC_WrapMode              = FSMC_WrapMode_Disable;
    FSMC_SRAM_Init.FSMC_WaitSignalActive      = FSMC_WaitSignalActive_BeforeWaitState;
    FSMC_SRAM_Init.FSMC_WaitSignal            = FSMC_WaitSignal_Disable;
    FSMC_SRAM_Init.FSMC_WriteBurst            = FSMC_WriteBurst_Disable;

    FSMC_NORSRAMInit(&FSMC_SRAM_Init);
 8000ae0:	a809      	add	r0, sp, #36	; 0x24

    FSMC_SRAM_Init.FSMC_Bank                  = FSMC_Bank1_NORSRAM2;

    FSMC_SRAM_Init.FSMC_DataAddressMux        = FSMC_DataAddressMux_Disable;
    FSMC_SRAM_Init.FSMC_MemoryType            = FSMC_MemoryType_SRAM;
    FSMC_SRAM_Init.FSMC_MemoryDataWidth       = FSMC_MemoryDataWidth_16b;
 8000ae2:	2710      	movs	r7, #16
    GPIO_PinAFConfig(GPIOG, GPIO_PinSource9,  GPIO_AF_FSMC);

                                                                /*------------------- SRAM BANK 2 ----------------------*/
    FSMC_SRAM_TimingInit.FSMC_AddressSetupTime      = 0;
    FSMC_SRAM_TimingInit.FSMC_AddressHoldTime       = 0;
    FSMC_SRAM_TimingInit.FSMC_DataSetupTime         = 4;
 8000ae4:	f8cd e010 	str.w	lr, [sp, #16]
    FSMC_SRAM_TimingInit.FSMC_BusTurnAroundDuration = 1;
    FSMC_SRAM_TimingInit.FSMC_CLKDivision           = 0;
    FSMC_SRAM_TimingInit.FSMC_DataLatency           = 0;
    FSMC_SRAM_TimingInit.FSMC_AccessMode            = FSMC_AccessMode_A;

    FSMC_SRAM_Init.FSMC_ReadWriteTimingStruct = &FSMC_SRAM_TimingInit;
 8000ae8:	9316      	str	r3, [sp, #88]	; 0x58
    FSMC_SRAM_Init.FSMC_WriteTimingStruct     = &FSMC_SRAM_TimingInit;
 8000aea:	9317      	str	r3, [sp, #92]	; 0x5c

    FSMC_SRAM_Init.FSMC_DataAddressMux        = FSMC_DataAddressMux_Disable;
    FSMC_SRAM_Init.FSMC_MemoryType            = FSMC_MemoryType_SRAM;
    FSMC_SRAM_Init.FSMC_MemoryDataWidth       = FSMC_MemoryDataWidth_16b;
    FSMC_SRAM_Init.FSMC_AsynchronousWait      = FSMC_AsynchronousWait_Disable;
    FSMC_SRAM_Init.FSMC_ExtendedMode          = FSMC_ExtendedMode_Enable;
 8000aec:	9114      	str	r1, [sp, #80]	; 0x50
    FSMC_SRAM_Init.FSMC_WriteOperation        = FSMC_WriteOperation_Enable;
 8000aee:	9212      	str	r2, [sp, #72]	; 0x48
    GPIO_PinAFConfig(GPIOG, GPIO_PinSource4,  GPIO_AF_FSMC);
    GPIO_PinAFConfig(GPIOG, GPIO_PinSource5,  GPIO_AF_FSMC);
    GPIO_PinAFConfig(GPIOG, GPIO_PinSource9,  GPIO_AF_FSMC);

                                                                /*------------------- SRAM BANK 2 ----------------------*/
    FSMC_SRAM_TimingInit.FSMC_AddressSetupTime      = 0;
 8000af0:	9402      	str	r4, [sp, #8]
    FSMC_SRAM_TimingInit.FSMC_AddressHoldTime       = 0;
 8000af2:	9403      	str	r4, [sp, #12]
    FSMC_SRAM_TimingInit.FSMC_DataSetupTime         = 4;
    FSMC_SRAM_TimingInit.FSMC_BusTurnAroundDuration = 1;
    FSMC_SRAM_TimingInit.FSMC_CLKDivision           = 0;
 8000af4:	9406      	str	r4, [sp, #24]
    FSMC_SRAM_TimingInit.FSMC_DataLatency           = 0;
 8000af6:	9407      	str	r4, [sp, #28]
    FSMC_SRAM_TimingInit.FSMC_AccessMode            = FSMC_AccessMode_A;
 8000af8:	9408      	str	r4, [sp, #32]

    FSMC_SRAM_Init.FSMC_ReadWriteTimingStruct = &FSMC_SRAM_TimingInit;
    FSMC_SRAM_Init.FSMC_WriteTimingStruct     = &FSMC_SRAM_TimingInit;

    FSMC_SRAM_Init.FSMC_Bank                  = FSMC_Bank1_NORSRAM2;
 8000afa:	9609      	str	r6, [sp, #36]	; 0x24

    FSMC_SRAM_Init.FSMC_DataAddressMux        = FSMC_DataAddressMux_Disable;
 8000afc:	940a      	str	r4, [sp, #40]	; 0x28
    FSMC_SRAM_Init.FSMC_MemoryType            = FSMC_MemoryType_SRAM;
 8000afe:	940b      	str	r4, [sp, #44]	; 0x2c
    FSMC_SRAM_Init.FSMC_MemoryDataWidth       = FSMC_MemoryDataWidth_16b;
    FSMC_SRAM_Init.FSMC_AsynchronousWait      = FSMC_AsynchronousWait_Disable;
 8000b00:	940e      	str	r4, [sp, #56]	; 0x38
    FSMC_SRAM_Init.FSMC_ExtendedMode          = FSMC_ExtendedMode_Enable;
    FSMC_SRAM_Init.FSMC_WriteOperation        = FSMC_WriteOperation_Enable;

    FSMC_SRAM_Init.FSMC_BurstAccessMode       = FSMC_BurstAccessMode_Disable;
 8000b02:	940d      	str	r4, [sp, #52]	; 0x34
    FSMC_SRAM_Init.FSMC_WaitSignalPolarity    = FSMC_WaitSignalPolarity_Low;
 8000b04:	940f      	str	r4, [sp, #60]	; 0x3c
    FSMC_SRAM_Init.FSMC_WrapMode              = FSMC_WrapMode_Disable;
 8000b06:	9410      	str	r4, [sp, #64]	; 0x40
    FSMC_SRAM_Init.FSMC_WaitSignalActive      = FSMC_WaitSignalActive_BeforeWaitState;
 8000b08:	9411      	str	r4, [sp, #68]	; 0x44
    FSMC_SRAM_Init.FSMC_WaitSignal            = FSMC_WaitSignal_Disable;
 8000b0a:	9413      	str	r4, [sp, #76]	; 0x4c
    FSMC_SRAM_Init.FSMC_WriteBurst            = FSMC_WriteBurst_Disable;
 8000b0c:	9415      	str	r4, [sp, #84]	; 0x54

                                                                /*------------------- SRAM BANK 2 ----------------------*/
    FSMC_SRAM_TimingInit.FSMC_AddressSetupTime      = 0;
    FSMC_SRAM_TimingInit.FSMC_AddressHoldTime       = 0;
    FSMC_SRAM_TimingInit.FSMC_DataSetupTime         = 4;
    FSMC_SRAM_TimingInit.FSMC_BusTurnAroundDuration = 1;
 8000b0e:	9505      	str	r5, [sp, #20]

    FSMC_SRAM_Init.FSMC_Bank                  = FSMC_Bank1_NORSRAM2;

    FSMC_SRAM_Init.FSMC_DataAddressMux        = FSMC_DataAddressMux_Disable;
    FSMC_SRAM_Init.FSMC_MemoryType            = FSMC_MemoryType_SRAM;
    FSMC_SRAM_Init.FSMC_MemoryDataWidth       = FSMC_MemoryDataWidth_16b;
 8000b10:	970c      	str	r7, [sp, #48]	; 0x30
    FSMC_SRAM_Init.FSMC_WrapMode              = FSMC_WrapMode_Disable;
    FSMC_SRAM_Init.FSMC_WaitSignalActive      = FSMC_WaitSignalActive_BeforeWaitState;
    FSMC_SRAM_Init.FSMC_WaitSignal            = FSMC_WaitSignal_Disable;
    FSMC_SRAM_Init.FSMC_WriteBurst            = FSMC_WriteBurst_Disable;

    FSMC_NORSRAMInit(&FSMC_SRAM_Init);
 8000b12:	f007 fcd3 	bl	80084bc <FSMC_NORSRAMInit>

    FSMC_NORSRAMCmd(FSMC_Bank1_NORSRAM2, ENABLE);
 8000b16:	4629      	mov	r1, r5
 8000b18:	4630      	mov	r0, r6
 8000b1a:	f007 fd4f 	bl	80085bc <FSMC_NORSRAMCmd>
}
 8000b1e:	b019      	add	sp, #100	; 0x64
 8000b20:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000b22:	bf00      	nop
 8000b24:	40020c00 	.word	0x40020c00

08000b28 <BSP_SoftReset>:

    \param [in]    faultMask  Fault Mask value to set
 */
__attribute__( ( always_inline ) ) static __INLINE void __set_FAULTMASK(uint32_t faultMask)
{
  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) );
 8000b28:	2301      	movs	r3, #1
 8000b2a:	f383 8813 	msr	FAULTMASK, r3
    This function acts as a special kind of Data Memory Barrier. 
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__( ( always_inline ) ) static __INLINE void __DSB(void)
{
  __ASM volatile ("dsb");
 8000b2e:	f3bf 8f4f 	dsb	sy
static __INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                     /* Ensure all outstanding memory accesses included
                                                                  buffered write are completed before reset */              
  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      | 
                 (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) | 
 8000b32:	4905      	ldr	r1, [pc, #20]	; (8000b48 <BSP_SoftReset+0x20>)
 8000b34:	4b05      	ldr	r3, [pc, #20]	; (8000b4c <BSP_SoftReset+0x24>)
 8000b36:	68ca      	ldr	r2, [r1, #12]
 8000b38:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 8000b3c:	4313      	orrs	r3, r2
 */
static __INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                     /* Ensure all outstanding memory accesses included
                                                                  buffered write are completed before reset */              
  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      | 
 8000b3e:	60cb      	str	r3, [r1, #12]
 8000b40:	f3bf 8f4f 	dsb	sy
 8000b44:	e7fe      	b.n	8000b44 <BSP_SoftReset+0x1c>
 8000b46:	bf00      	nop
 8000b48:	e000ed00 	.word	0xe000ed00
 8000b4c:	05fa0004 	.word	0x05fa0004

08000b50 <CPU_TS_TmrInit>:
void  CPU_TS_TmrInit (void)
{
    CPU_INT32U  cpu_clk_freq_hz;


    DEM_CR         |= (CPU_INT32U)DEM_CR_TRCENA;                /* Enable Cortex-M3's DWT CYCCNT reg.                   */
 8000b50:	490b      	ldr	r1, [pc, #44]	; (8000b80 <CPU_TS_TmrInit+0x30>)
*********************************************************************************************************
*/

#if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)
void  CPU_TS_TmrInit (void)
{
 8000b52:	b510      	push	{r4, lr}
    CPU_INT32U  cpu_clk_freq_hz;


    DEM_CR         |= (CPU_INT32U)DEM_CR_TRCENA;                /* Enable Cortex-M3's DWT CYCCNT reg.                   */
 8000b54:	680b      	ldr	r3, [r1, #0]
    DWT_CYCCNT      = (CPU_INT32U)0u;
 8000b56:	480b      	ldr	r0, [pc, #44]	; (8000b84 <CPU_TS_TmrInit+0x34>)
    DWT_CR         |= (CPU_INT32U)DWT_CR_CYCCNTENA;
 8000b58:	4a0b      	ldr	r2, [pc, #44]	; (8000b88 <CPU_TS_TmrInit+0x38>)
{
    CPU_INT32U  cpu_clk_freq_hz;


    DEM_CR         |= (CPU_INT32U)DEM_CR_TRCENA;                /* Enable Cortex-M3's DWT CYCCNT reg.                   */
    DWT_CYCCNT      = (CPU_INT32U)0u;
 8000b5a:	2400      	movs	r4, #0
void  CPU_TS_TmrInit (void)
{
    CPU_INT32U  cpu_clk_freq_hz;


    DEM_CR         |= (CPU_INT32U)DEM_CR_TRCENA;                /* Enable Cortex-M3's DWT CYCCNT reg.                   */
 8000b5c:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8000b60:	600b      	str	r3, [r1, #0]
    DWT_CYCCNT      = (CPU_INT32U)0u;
 8000b62:	6004      	str	r4, [r0, #0]
    DWT_CR         |= (CPU_INT32U)DWT_CR_CYCCNTENA;
 8000b64:	6813      	ldr	r3, [r2, #0]
*********************************************************************************************************
*/

#if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)
void  CPU_TS_TmrInit (void)
{
 8000b66:	b084      	sub	sp, #16
    CPU_INT32U  cpu_clk_freq_hz;


    DEM_CR         |= (CPU_INT32U)DEM_CR_TRCENA;                /* Enable Cortex-M3's DWT CYCCNT reg.                   */
    DWT_CYCCNT      = (CPU_INT32U)0u;
    DWT_CR         |= (CPU_INT32U)DWT_CR_CYCCNTENA;
 8000b68:	f043 0301 	orr.w	r3, r3, #1
CPU_INT32U  BSP_CPU_ClkFreq (void)
{
    RCC_ClocksTypeDef  rcc_clocks;


    RCC_GetClocksFreq(&rcc_clocks);
 8000b6c:	4668      	mov	r0, sp
    CPU_INT32U  cpu_clk_freq_hz;


    DEM_CR         |= (CPU_INT32U)DEM_CR_TRCENA;                /* Enable Cortex-M3's DWT CYCCNT reg.                   */
    DWT_CYCCNT      = (CPU_INT32U)0u;
    DWT_CR         |= (CPU_INT32U)DWT_CR_CYCCNTENA;
 8000b6e:	6013      	str	r3, [r2, #0]
CPU_INT32U  BSP_CPU_ClkFreq (void)
{
    RCC_ClocksTypeDef  rcc_clocks;


    RCC_GetClocksFreq(&rcc_clocks);
 8000b70:	f008 f8cc 	bl	8008d0c <RCC_GetClocksFreq>
    DEM_CR         |= (CPU_INT32U)DEM_CR_TRCENA;                /* Enable Cortex-M3's DWT CYCCNT reg.                   */
    DWT_CYCCNT      = (CPU_INT32U)0u;
    DWT_CR         |= (CPU_INT32U)DWT_CR_CYCCNTENA;

    cpu_clk_freq_hz = BSP_CPU_ClkFreq();
    CPU_TS_TmrFreqSet(cpu_clk_freq_hz);
 8000b74:	9801      	ldr	r0, [sp, #4]
 8000b76:	f001 f8dd 	bl	8001d34 <CPU_TS_TmrFreqSet>
}
 8000b7a:	b004      	add	sp, #16
 8000b7c:	bd10      	pop	{r4, pc}
 8000b7e:	bf00      	nop
 8000b80:	e000edfc 	.word	0xe000edfc
 8000b84:	e0001004 	.word	0xe0001004
 8000b88:	e0001000 	.word	0xe0001000

08000b8c <CPU_TS_TmrRd>:
*/

#if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)
CPU_TS_TMR  CPU_TS_TmrRd (void)
{
    return ((CPU_TS_TMR)DWT_CYCCNT);
 8000b8c:	4b01      	ldr	r3, [pc, #4]	; (8000b94 <CPU_TS_TmrRd+0x8>)
 8000b8e:	6818      	ldr	r0, [r3, #0]
}
 8000b90:	4770      	bx	lr
 8000b92:	bf00      	nop
 8000b94:	e0001004 	.word	0xe0001004

08000b98 <BSP_Delay_ms>:

void BSP_Delay_ms(INT16U ms)
{
	INT16U ms_time;
	OS_ERR    os_err;
	while(ms)
 8000b98:	b1d8      	cbz	r0, 8000bd2 <BSP_Delay_ms+0x3a>

#include "bsp_delay.h"


void BSP_Delay_ms(INT16U ms)
{
 8000b9a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000b9e:	4604      	mov	r4, r0
 8000ba0:	f240 38e7 	movw	r8, #999	; 0x3e7
 8000ba4:	b084      	sub	sp, #16
 8000ba6:	f10d 070e 	add.w	r7, sp, #14
	{
		if(ms > 999)
			ms_time = 999;
		else
			ms_time = ms;
		OSTimeDlyHMSM(0, 0, 0, ms_time,OS_OPT_TIME_HMSM_STRICT, &os_err);
 8000baa:	2600      	movs	r6, #0
 8000bac:	4544      	cmp	r4, r8
 8000bae:	4625      	mov	r5, r4
 8000bb0:	bf28      	it	cs
 8000bb2:	4645      	movcs	r5, r8
 8000bb4:	2200      	movs	r2, #0
		ms -= ms_time;
 8000bb6:	1b64      	subs	r4, r4, r5
	{
		if(ms > 999)
			ms_time = 999;
		else
			ms_time = ms;
		OSTimeDlyHMSM(0, 0, 0, ms_time,OS_OPT_TIME_HMSM_STRICT, &os_err);
 8000bb8:	e88d 00c0 	stmia.w	sp, {r6, r7}
 8000bbc:	462b      	mov	r3, r5
 8000bbe:	4611      	mov	r1, r2
 8000bc0:	4610      	mov	r0, r2
		ms -= ms_time;
 8000bc2:	b2a4      	uxth	r4, r4
	{
		if(ms > 999)
			ms_time = 999;
		else
			ms_time = ms;
		OSTimeDlyHMSM(0, 0, 0, ms_time,OS_OPT_TIME_HMSM_STRICT, &os_err);
 8000bc4:	f006 ff9e 	bl	8007b04 <OSTimeDlyHMSM>

void BSP_Delay_ms(INT16U ms)
{
	INT16U ms_time;
	OS_ERR    os_err;
	while(ms)
 8000bc8:	2c00      	cmp	r4, #0
 8000bca:	d1ef      	bne.n	8000bac <BSP_Delay_ms+0x14>
		else
			ms_time = ms;
		OSTimeDlyHMSM(0, 0, 0, ms_time,OS_OPT_TIME_HMSM_STRICT, &os_err);
		ms -= ms_time;
	}
}
 8000bcc:	b004      	add	sp, #16
 8000bce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000bd2:	4770      	bx	lr

08000bd4 <BSP_Delay_s>:

void BSP_Delay_s(INT8U sec)
{
	INT8U s_time;
	OS_ERR    os_err;
	while(sec)
 8000bd4:	b1b8      	cbz	r0, 8000c06 <BSP_Delay_s+0x32>
		ms -= ms_time;
	}
}

void BSP_Delay_s(INT8U sec)
{
 8000bd6:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000bd8:	4604      	mov	r4, r0
 8000bda:	b085      	sub	sp, #20
 8000bdc:	f10d 070e 	add.w	r7, sp, #14
	{
		if(sec > 59)
			s_time = 59;
		else
			s_time = sec;
		OSTimeDlyHMSM(0, 0, s_time, 0,OS_OPT_TIME_HMSM_STRICT, &os_err);
 8000be0:	2600      	movs	r6, #0
 8000be2:	4625      	mov	r5, r4
 8000be4:	2c3b      	cmp	r4, #59	; 0x3b
 8000be6:	bf28      	it	cs
 8000be8:	253b      	movcs	r5, #59	; 0x3b
 8000bea:	2300      	movs	r3, #0
 8000bec:	e88d 00c0 	stmia.w	sp, {r6, r7}
 8000bf0:	462a      	mov	r2, r5
 8000bf2:	4619      	mov	r1, r3
 8000bf4:	4618      	mov	r0, r3
		sec -= s_time;
 8000bf6:	1b64      	subs	r4, r4, r5
	{
		if(sec > 59)
			s_time = 59;
		else
			s_time = sec;
		OSTimeDlyHMSM(0, 0, s_time, 0,OS_OPT_TIME_HMSM_STRICT, &os_err);
 8000bf8:	f006 ff84 	bl	8007b04 <OSTimeDlyHMSM>

void BSP_Delay_s(INT8U sec)
{
	INT8U s_time;
	OS_ERR    os_err;
	while(sec)
 8000bfc:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
 8000c00:	d1ef      	bne.n	8000be2 <BSP_Delay_s+0xe>
		else
			s_time = sec;
		OSTimeDlyHMSM(0, 0, s_time, 0,OS_OPT_TIME_HMSM_STRICT, &os_err);
		sec -= s_time;
	}
}
 8000c02:	b005      	add	sp, #20
 8000c04:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000c06:	4770      	bx	lr

08000c08 <BSP_Delay_us>:

void BSP_Delay_us(INT32U us)
{
 8000c08:	4770      	bx	lr
 8000c0a:	bf00      	nop

08000c0c <BSP_IntHandlerDummy>:
* Note(s)     : none.
*********************************************************************************************************
*/

static  void  BSP_IntHandlerDummy (void)
{
 8000c0c:	4770      	bx	lr
 8000c0e:	bf00      	nop

08000c10 <BSP_IntHandler>:
* Note(s)     : none.
*********************************************************************************************************
*/

static  void  BSP_IntHandler (CPU_DATA  int_id)
{
 8000c10:	b538      	push	{r3, r4, r5, lr}
 8000c12:	4604      	mov	r4, r0
    CPU_FNCT_VOID  isr;
    CPU_SR_ALLOC();


    CPU_CRITICAL_ENTER();                                       /* Tell the OS that we are starting an ISR            */
 8000c14:	f000 fdae 	bl	8001774 <CPU_SR_Save>
 8000c18:	4605      	mov	r5, r0

    OSIntEnter();
 8000c1a:	f002 ff29 	bl	8003a70 <OSIntEnter>

    CPU_CRITICAL_EXIT();
 8000c1e:	4628      	mov	r0, r5
 8000c20:	f000 fdac 	bl	800177c <CPU_SR_Restore>

    if (int_id < BSP_INT_SRC_NBR) {
 8000c24:	2c50      	cmp	r4, #80	; 0x50
 8000c26:	d804      	bhi.n	8000c32 <BSP_IntHandler+0x22>
        isr = BSP_IntVectTbl[int_id];
 8000c28:	4b04      	ldr	r3, [pc, #16]	; (8000c3c <BSP_IntHandler+0x2c>)
 8000c2a:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
        if (isr != (CPU_FNCT_VOID)0) {
 8000c2e:	b103      	cbz	r3, 8000c32 <BSP_IntHandler+0x22>
            isr();
 8000c30:	4798      	blx	r3
        }
    }

    OSIntExit();                                                /* Tell the OS that we are leaving the ISR            */
}
 8000c32:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        if (isr != (CPU_FNCT_VOID)0) {
            isr();
        }
    }

    OSIntExit();                                                /* Tell the OS that we are leaving the ISR            */
 8000c36:	f002 bf2b 	b.w	8003a90 <OSIntExit>
 8000c3a:	bf00      	nop
 8000c3c:	20000220 	.word	0x20000220

08000c40 <BSP_IntClr>:
* Note(s)     : (1) An interrupt does not need to be cleared within the interrupt controller.
*********************************************************************************************************
*/

void  BSP_IntClr (CPU_DATA  int_id)
{
 8000c40:	4770      	bx	lr
 8000c42:	bf00      	nop

08000c44 <BSP_IntDis>:
*********************************************************************************************************
*/

void  BSP_IntDis (CPU_DATA  int_id)
{
    if (int_id < BSP_INT_SRC_NBR) {
 8000c44:	2850      	cmp	r0, #80	; 0x50
 8000c46:	d900      	bls.n	8000c4a <BSP_IntDis+0x6>
 8000c48:	4770      	bx	lr
        CPU_IntSrcDis(int_id + 16);
 8000c4a:	3010      	adds	r0, #16
 8000c4c:	b2c0      	uxtb	r0, r0
 8000c4e:	f000 bddb 	b.w	8001808 <CPU_IntSrcDis>
 8000c52:	bf00      	nop

08000c54 <BSP_IntDisAll>:
*********************************************************************************************************
*/

void  BSP_IntDisAll (void)
{
    CPU_IntDis();
 8000c54:	f000 bd8a 	b.w	800176c <CPU_IntDis>

08000c58 <BSP_IntEn>:
*********************************************************************************************************
*/

void  BSP_IntEn (CPU_DATA  int_id)
{
    if (int_id < BSP_INT_SRC_NBR) {
 8000c58:	2850      	cmp	r0, #80	; 0x50
 8000c5a:	d900      	bls.n	8000c5e <BSP_IntEn+0x6>
 8000c5c:	4770      	bx	lr
        CPU_IntSrcEn(int_id + 16);
 8000c5e:	3010      	adds	r0, #16
 8000c60:	b2c0      	uxtb	r0, r0
 8000c62:	f000 be3f 	b.w	80018e4 <CPU_IntSrcEn>
 8000c66:	bf00      	nop

08000c68 <BSP_IntVectSet>:
                      CPU_FNCT_VOID  isr)
{
    CPU_SR_ALLOC();


    if (int_id < BSP_INT_SRC_NBR) {
 8000c68:	2850      	cmp	r0, #80	; 0x50
 8000c6a:	d900      	bls.n	8000c6e <BSP_IntVectSet+0x6>
 8000c6c:	4770      	bx	lr
*********************************************************************************************************
*/

void  BSP_IntVectSet (CPU_DATA       int_id,
                      CPU_FNCT_VOID  isr)
{
 8000c6e:	b538      	push	{r3, r4, r5, lr}
 8000c70:	460d      	mov	r5, r1
 8000c72:	4604      	mov	r4, r0
    CPU_SR_ALLOC();


    if (int_id < BSP_INT_SRC_NBR) {
        CPU_CRITICAL_ENTER();
 8000c74:	f000 fd7e 	bl	8001774 <CPU_SR_Save>
        BSP_IntVectTbl[int_id] = isr;
 8000c78:	4b03      	ldr	r3, [pc, #12]	; (8000c88 <BSP_IntVectSet+0x20>)
 8000c7a:	f843 5024 	str.w	r5, [r3, r4, lsl #2]
        CPU_CRITICAL_EXIT();
    }
}
 8000c7e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}


    if (int_id < BSP_INT_SRC_NBR) {
        CPU_CRITICAL_ENTER();
        BSP_IntVectTbl[int_id] = isr;
        CPU_CRITICAL_EXIT();
 8000c82:	f000 bd7b 	b.w	800177c <CPU_SR_Restore>
 8000c86:	bf00      	nop
 8000c88:	20000220 	.word	0x20000220

08000c8c <BSP_IntPrioSet>:
                      CPU_INT08U  prio)
{
    CPU_SR_ALLOC();


    if (int_id < BSP_INT_SRC_NBR) {
 8000c8c:	2850      	cmp	r0, #80	; 0x50
 8000c8e:	d900      	bls.n	8000c92 <BSP_IntPrioSet+0x6>
 8000c90:	4770      	bx	lr
*********************************************************************************************************
*/

void  BSP_IntPrioSet (CPU_DATA    int_id,
                      CPU_INT08U  prio)
{
 8000c92:	b570      	push	{r4, r5, r6, lr}
 8000c94:	460d      	mov	r5, r1
 8000c96:	4604      	mov	r4, r0
    CPU_SR_ALLOC();


    if (int_id < BSP_INT_SRC_NBR) {
        CPU_CRITICAL_ENTER();
 8000c98:	f000 fd6c 	bl	8001774 <CPU_SR_Save>
 8000c9c:	4606      	mov	r6, r0
        CPU_IntSrcPrioSet(int_id + 16, prio);
 8000c9e:	f104 0010 	add.w	r0, r4, #16
 8000ca2:	b2c0      	uxtb	r0, r0
 8000ca4:	4629      	mov	r1, r5
 8000ca6:	f000 fec1 	bl	8001a2c <CPU_IntSrcPrioSet>
        CPU_CRITICAL_EXIT();
 8000caa:	4630      	mov	r0, r6
    }
}
 8000cac:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}


    if (int_id < BSP_INT_SRC_NBR) {
        CPU_CRITICAL_ENTER();
        CPU_IntSrcPrioSet(int_id + 16, prio);
        CPU_CRITICAL_EXIT();
 8000cb0:	f000 bd64 	b.w	800177c <CPU_SR_Restore>

08000cb4 <BSP_IntInit>:
* Note(s)     : none.
*********************************************************************************************************
*/

void  BSP_IntInit (void)
{
 8000cb4:	b570      	push	{r4, r5, r6, lr}
 8000cb6:	4c06      	ldr	r4, [pc, #24]	; (8000cd0 <BSP_IntInit+0x1c>)
 8000cb8:	4e06      	ldr	r6, [pc, #24]	; (8000cd4 <BSP_IntInit+0x20>)
 8000cba:	f504 75a2 	add.w	r5, r4, #324	; 0x144
{
    CPU_SR_ALLOC();


    if (int_id < BSP_INT_SRC_NBR) {
        CPU_CRITICAL_ENTER();
 8000cbe:	f000 fd59 	bl	8001774 <CPU_SR_Save>
        BSP_IntVectTbl[int_id] = isr;
 8000cc2:	f844 6f04 	str.w	r6, [r4, #4]!
        CPU_CRITICAL_EXIT();
 8000cc6:	f000 fd59 	bl	800177c <CPU_SR_Restore>
void  BSP_IntInit (void)
{
    CPU_DATA  int_id;


    for (int_id = 0; int_id < BSP_INT_SRC_NBR; int_id++) {
 8000cca:	42ac      	cmp	r4, r5
 8000ccc:	d1f7      	bne.n	8000cbe <BSP_IntInit+0xa>
        BSP_IntVectSet(int_id, BSP_IntHandlerDummy);
    }

    //BSP_IntVectSet(BSP_INT_ID_EXTI15_10, BSP_EXTI_15_10_IntHandler);
	//BSP_IntEn(BSP_INT_ID_EXTI15_10);
}
 8000cce:	bd70      	pop	{r4, r5, r6, pc}
 8000cd0:	2000021c 	.word	0x2000021c
 8000cd4:	08000c0d 	.word	0x08000c0d

08000cd8 <BSP_IntHandlerWWDG>:
*
* Note(s)     : none.
*********************************************************************************************************
*/

void  BSP_IntHandlerWWDG               (void)  { BSP_IntHandler(BSP_INT_ID_WWDG);                }
 8000cd8:	2000      	movs	r0, #0
 8000cda:	e799      	b.n	8000c10 <BSP_IntHandler>

08000cdc <BSP_IntHandlerPVD>:
void  BSP_IntHandlerPVD                (void)  { BSP_IntHandler(BSP_INT_ID_PVD);                 }
 8000cdc:	2001      	movs	r0, #1
 8000cde:	e797      	b.n	8000c10 <BSP_IntHandler>

08000ce0 <BSP_IntHandlerTAMPER>:
void  BSP_IntHandlerTAMPER             (void)  { BSP_IntHandler(BSP_INT_ID_TAMPER);              }
 8000ce0:	2002      	movs	r0, #2
 8000ce2:	e795      	b.n	8000c10 <BSP_IntHandler>

08000ce4 <BSP_IntHandlerRTC>:
void  BSP_IntHandlerRTC                (void)  { BSP_IntHandler(BSP_INT_ID_RTC);                 }
 8000ce4:	2003      	movs	r0, #3
 8000ce6:	e793      	b.n	8000c10 <BSP_IntHandler>

08000ce8 <BSP_IntHandlerFLASH>:
void  BSP_IntHandlerFLASH              (void)  { BSP_IntHandler(BSP_INT_ID_FLASH);               }
 8000ce8:	2004      	movs	r0, #4
 8000cea:	e791      	b.n	8000c10 <BSP_IntHandler>

08000cec <BSP_IntHandlerRCC>:
void  BSP_IntHandlerRCC                (void)  { BSP_IntHandler(BSP_INT_ID_RCC);                 }
 8000cec:	2005      	movs	r0, #5
 8000cee:	e78f      	b.n	8000c10 <BSP_IntHandler>

08000cf0 <BSP_IntHandlerEXTI0>:
void  BSP_IntHandlerEXTI0              (void)  { BSP_IntHandler(BSP_INT_ID_EXTI0);               }
 8000cf0:	2006      	movs	r0, #6
 8000cf2:	e78d      	b.n	8000c10 <BSP_IntHandler>

08000cf4 <BSP_IntHandlerEXTI1>:
void  BSP_IntHandlerEXTI1              (void)  { BSP_IntHandler(BSP_INT_ID_EXTI1);               }
 8000cf4:	2007      	movs	r0, #7
 8000cf6:	e78b      	b.n	8000c10 <BSP_IntHandler>

08000cf8 <BSP_IntHandlerEXTI2>:
void  BSP_IntHandlerEXTI2              (void)  { BSP_IntHandler(BSP_INT_ID_EXTI2);               }
 8000cf8:	2008      	movs	r0, #8
 8000cfa:	e789      	b.n	8000c10 <BSP_IntHandler>

08000cfc <BSP_IntHandlerEXTI3>:
void  BSP_IntHandlerEXTI3              (void)  { BSP_IntHandler(BSP_INT_ID_EXTI3);               }
 8000cfc:	2009      	movs	r0, #9
 8000cfe:	e787      	b.n	8000c10 <BSP_IntHandler>

08000d00 <BSP_IntHandlerEXTI4>:
void  BSP_IntHandlerEXTI4              (void)  { BSP_IntHandler(BSP_INT_ID_EXTI4);               }
 8000d00:	200a      	movs	r0, #10
 8000d02:	e785      	b.n	8000c10 <BSP_IntHandler>

08000d04 <BSP_IntHandlerDMA1_CH1>:
void  BSP_IntHandlerDMA1_CH1           (void)  { BSP_IntHandler(BSP_INT_ID_DMA1_CH1);            }
 8000d04:	200b      	movs	r0, #11
 8000d06:	e783      	b.n	8000c10 <BSP_IntHandler>

08000d08 <BSP_IntHandlerDMA1_CH2>:
void  BSP_IntHandlerDMA1_CH2           (void)  { BSP_IntHandler(BSP_INT_ID_DMA1_CH2);            }
 8000d08:	200c      	movs	r0, #12
 8000d0a:	e781      	b.n	8000c10 <BSP_IntHandler>

08000d0c <BSP_IntHandlerDMA1_CH3>:
void  BSP_IntHandlerDMA1_CH3           (void)  { BSP_IntHandler(BSP_INT_ID_DMA1_CH3);            }
 8000d0c:	200d      	movs	r0, #13
 8000d0e:	e77f      	b.n	8000c10 <BSP_IntHandler>

08000d10 <BSP_IntHandlerDMA1_CH4>:
void  BSP_IntHandlerDMA1_CH4           (void)  { BSP_IntHandler(BSP_INT_ID_DMA1_CH4);            }
 8000d10:	200e      	movs	r0, #14
 8000d12:	e77d      	b.n	8000c10 <BSP_IntHandler>

08000d14 <BSP_IntHandlerDMA1_CH5>:
void  BSP_IntHandlerDMA1_CH5           (void)  { BSP_IntHandler(BSP_INT_ID_DMA1_CH5);            }
 8000d14:	200f      	movs	r0, #15
 8000d16:	e77b      	b.n	8000c10 <BSP_IntHandler>

08000d18 <BSP_IntHandlerDMA1_CH6>:
void  BSP_IntHandlerDMA1_CH6           (void)  { BSP_IntHandler(BSP_INT_ID_DMA1_CH6);            }
 8000d18:	2010      	movs	r0, #16
 8000d1a:	e779      	b.n	8000c10 <BSP_IntHandler>

08000d1c <BSP_IntHandlerDMA1_CH7>:
void  BSP_IntHandlerDMA1_CH7           (void)  { BSP_IntHandler(BSP_INT_ID_DMA1_CH7);            }
 8000d1c:	2011      	movs	r0, #17
 8000d1e:	e777      	b.n	8000c10 <BSP_IntHandler>

08000d20 <BSP_IntHandlerADC1_2>:
void  BSP_IntHandlerADC1_2             (void)  { BSP_IntHandler(BSP_INT_ID_ADC1_2);              }
 8000d20:	2012      	movs	r0, #18
 8000d22:	e775      	b.n	8000c10 <BSP_IntHandler>

08000d24 <BSP_IntHandlerCAN1_TX>:
void  BSP_IntHandlerCAN1_TX            (void)  { BSP_IntHandler(BSP_INT_ID_CAN1_TX);             }
 8000d24:	2013      	movs	r0, #19
 8000d26:	e773      	b.n	8000c10 <BSP_IntHandler>

08000d28 <BSP_IntHandlerCAN1_RX0>:
void  BSP_IntHandlerCAN1_RX0           (void)  { BSP_IntHandler(BSP_INT_ID_CAN1_RX0);            }
 8000d28:	2014      	movs	r0, #20
 8000d2a:	e771      	b.n	8000c10 <BSP_IntHandler>

08000d2c <BSP_IntHandlerCAN1_RX1>:
void  BSP_IntHandlerCAN1_RX1           (void)  { BSP_IntHandler(BSP_INT_ID_CAN1_RX1);            }
 8000d2c:	2015      	movs	r0, #21
 8000d2e:	e76f      	b.n	8000c10 <BSP_IntHandler>

08000d30 <BSP_IntHandlerCAN1_SCE>:
void  BSP_IntHandlerCAN1_SCE           (void)  { BSP_IntHandler(BSP_INT_ID_CAN1_SCE);            }
 8000d30:	2016      	movs	r0, #22
 8000d32:	e76d      	b.n	8000c10 <BSP_IntHandler>

08000d34 <BSP_IntHandlerEXTI9_5>:
void  BSP_IntHandlerEXTI9_5            (void)  { BSP_IntHandler(BSP_INT_ID_EXTI9_5);             }
 8000d34:	2017      	movs	r0, #23
 8000d36:	e76b      	b.n	8000c10 <BSP_IntHandler>

08000d38 <BSP_IntHandlerTIM1_BRK>:
void  BSP_IntHandlerTIM1_BRK           (void)  { BSP_IntHandler(BSP_INT_ID_TIM1_BRK);            }
 8000d38:	2018      	movs	r0, #24
 8000d3a:	e769      	b.n	8000c10 <BSP_IntHandler>

08000d3c <BSP_IntHandlerTIM1_UP>:
void  BSP_IntHandlerTIM1_UP            (void)  { BSP_IntHandler(BSP_INT_ID_TIM1_UP);             }
 8000d3c:	2019      	movs	r0, #25
 8000d3e:	e767      	b.n	8000c10 <BSP_IntHandler>

08000d40 <BSP_IntHandlerTIM1_TRG_COM>:
void  BSP_IntHandlerTIM1_TRG_COM       (void)  { BSP_IntHandler(BSP_INT_ID_TIM1_TRG_COM);        }
 8000d40:	201a      	movs	r0, #26
 8000d42:	e765      	b.n	8000c10 <BSP_IntHandler>

08000d44 <BSP_IntHandlerTIM1_CC>:
void  BSP_IntHandlerTIM1_CC            (void)  { BSP_IntHandler(BSP_INT_ID_TIM1_CC);             }
 8000d44:	201b      	movs	r0, #27
 8000d46:	e763      	b.n	8000c10 <BSP_IntHandler>

08000d48 <BSP_IntHandlerTIM2>:
void  BSP_IntHandlerTIM2               (void)  { BSP_IntHandler(BSP_INT_ID_TIM2);                }
 8000d48:	201c      	movs	r0, #28
 8000d4a:	e761      	b.n	8000c10 <BSP_IntHandler>

08000d4c <BSP_IntHandlerTIM3>:
void  BSP_IntHandlerTIM3               (void)  { BSP_IntHandler(BSP_INT_ID_TIM3);                }
 8000d4c:	201d      	movs	r0, #29
 8000d4e:	e75f      	b.n	8000c10 <BSP_IntHandler>

08000d50 <BSP_IntHandlerTIM4>:
void  BSP_IntHandlerTIM4               (void)  { BSP_IntHandler(BSP_INT_ID_TIM4);                }
 8000d50:	201e      	movs	r0, #30
 8000d52:	e75d      	b.n	8000c10 <BSP_IntHandler>

08000d54 <BSP_IntHandlerI2C1_EV>:
void  BSP_IntHandlerI2C1_EV            (void)  { BSP_IntHandler(BSP_INT_ID_I2C1_EV);             }
 8000d54:	201f      	movs	r0, #31
 8000d56:	e75b      	b.n	8000c10 <BSP_IntHandler>

08000d58 <BSP_IntHandlerI2C1_ER>:
void  BSP_IntHandlerI2C1_ER            (void)  { BSP_IntHandler(BSP_INT_ID_I2C1_ER);             }
 8000d58:	2020      	movs	r0, #32
 8000d5a:	e759      	b.n	8000c10 <BSP_IntHandler>

08000d5c <BSP_IntHandlerI2C2_EV>:
void  BSP_IntHandlerI2C2_EV            (void)  { BSP_IntHandler(BSP_INT_ID_I2C2_EV);             }
 8000d5c:	2021      	movs	r0, #33	; 0x21
 8000d5e:	e757      	b.n	8000c10 <BSP_IntHandler>

08000d60 <BSP_IntHandlerI2C2_ER>:
void  BSP_IntHandlerI2C2_ER            (void)  { BSP_IntHandler(BSP_INT_ID_I2C2_ER);             }
 8000d60:	2022      	movs	r0, #34	; 0x22
 8000d62:	e755      	b.n	8000c10 <BSP_IntHandler>

08000d64 <BSP_IntHandlerSPI1>:
void  BSP_IntHandlerSPI1               (void)  { BSP_IntHandler(BSP_INT_ID_SPI1);                }
 8000d64:	2023      	movs	r0, #35	; 0x23
 8000d66:	e753      	b.n	8000c10 <BSP_IntHandler>

08000d68 <BSP_IntHandlerSPI2>:
void  BSP_IntHandlerSPI2               (void)  { BSP_IntHandler(BSP_INT_ID_SPI2);                }
 8000d68:	2024      	movs	r0, #36	; 0x24
 8000d6a:	e751      	b.n	8000c10 <BSP_IntHandler>

08000d6c <BSP_IntHandlerUSART1>:
void  BSP_IntHandlerUSART1             (void)  { BSP_IntHandler(BSP_INT_ID_USART1);              }
 8000d6c:	2025      	movs	r0, #37	; 0x25
 8000d6e:	e74f      	b.n	8000c10 <BSP_IntHandler>

08000d70 <BSP_IntHandlerUSART2>:
void  BSP_IntHandlerUSART2             (void)  { BSP_IntHandler(BSP_INT_ID_USART2);              }
 8000d70:	2026      	movs	r0, #38	; 0x26
 8000d72:	e74d      	b.n	8000c10 <BSP_IntHandler>

08000d74 <BSP_IntHandlerUSART3>:
void  BSP_IntHandlerUSART3             (void)  { BSP_IntHandler(BSP_INT_ID_USART3);              }
 8000d74:	2027      	movs	r0, #39	; 0x27
 8000d76:	e74b      	b.n	8000c10 <BSP_IntHandler>

08000d78 <BSP_IntHandlerEXTI15_10>:
void  BSP_IntHandlerEXTI15_10          (void)  { BSP_IntHandler(BSP_INT_ID_EXTI15_10);           }
 8000d78:	2028      	movs	r0, #40	; 0x28
 8000d7a:	e749      	b.n	8000c10 <BSP_IntHandler>

08000d7c <BSP_IntHandlerRTCAlarm>:
void  BSP_IntHandlerRTCAlarm           (void)  { BSP_IntHandler(BSP_INT_ID_RTC_ALARM);           }
 8000d7c:	2029      	movs	r0, #41	; 0x29
 8000d7e:	e747      	b.n	8000c10 <BSP_IntHandler>

08000d80 <BSP_IntHandlerUSBWakeUp>:
void  BSP_IntHandlerUSBWakeUp          (void)  { BSP_IntHandler(BSP_INT_ID_OTG_FS_WKUP);         }
 8000d80:	202a      	movs	r0, #42	; 0x2a
 8000d82:	e745      	b.n	8000c10 <BSP_IntHandler>

08000d84 <BSP_IntHandlerTIM8_BRK_TIM12>:
void  BSP_IntHandlerTIM8_BRK_TIM12     (void)  { BSP_IntHandler(BSP_INT_ID_TIM8_BRK_TIM12);      }
 8000d84:	202b      	movs	r0, #43	; 0x2b
 8000d86:	e743      	b.n	8000c10 <BSP_IntHandler>

08000d88 <BSP_IntHandlerTIM8_UP_TIM13>:
void  BSP_IntHandlerTIM8_UP_TIM13      (void)  { BSP_IntHandler(BSP_INT_ID_TIM8_UP_TIM13);       }
 8000d88:	202c      	movs	r0, #44	; 0x2c
 8000d8a:	e741      	b.n	8000c10 <BSP_IntHandler>

08000d8c <BSP_IntHandlerTIM8_TRG_COM_TIM14>:
void  BSP_IntHandlerTIM8_TRG_COM_TIM14 (void)  { BSP_IntHandler(BSP_INT_ID_TIM8_TRG_COM_TIM14);  }
 8000d8c:	202d      	movs	r0, #45	; 0x2d
 8000d8e:	e73f      	b.n	8000c10 <BSP_IntHandler>

08000d90 <BSP_IntHandlerTIM8_CC>:
void  BSP_IntHandlerTIM8_CC            (void)  { BSP_IntHandler(BSP_INT_ID_TIM8_CC);             }
 8000d90:	202e      	movs	r0, #46	; 0x2e
 8000d92:	e73d      	b.n	8000c10 <BSP_IntHandler>

08000d94 <BSP_IntHandlerDMA1_STREAM7>:
void  BSP_IntHandlerDMA1_STREAM7       (void)  { BSP_IntHandler(BSP_INT_ID_DMA1_STREAM7);        }
 8000d94:	202f      	movs	r0, #47	; 0x2f
 8000d96:	e73b      	b.n	8000c10 <BSP_IntHandler>

08000d98 <BSP_IntHandlerFSMC>:
void  BSP_IntHandlerFSMC               (void)  { BSP_IntHandler(BSP_INT_ID_FSMC);                }
 8000d98:	2030      	movs	r0, #48	; 0x30
 8000d9a:	e739      	b.n	8000c10 <BSP_IntHandler>

08000d9c <BSP_IntHandlerSDIO>:
void  BSP_IntHandlerSDIO               (void)  { BSP_IntHandler(BSP_INT_ID_SDIO);                }
 8000d9c:	2031      	movs	r0, #49	; 0x31
 8000d9e:	e737      	b.n	8000c10 <BSP_IntHandler>

08000da0 <BSP_IntHandlerTIM5>:
void  BSP_IntHandlerTIM5               (void)  { BSP_IntHandler(BSP_INT_ID_TIM5);                }
 8000da0:	2032      	movs	r0, #50	; 0x32
 8000da2:	e735      	b.n	8000c10 <BSP_IntHandler>

08000da4 <BSP_IntHandlerSPI3>:
void  BSP_IntHandlerSPI3               (void)  { BSP_IntHandler(BSP_INT_ID_SPI3);                }
 8000da4:	2033      	movs	r0, #51	; 0x33
 8000da6:	e733      	b.n	8000c10 <BSP_IntHandler>

08000da8 <BSP_IntHandlerUSART4>:
void  BSP_IntHandlerUSART4             (void)  { BSP_IntHandler(BSP_INT_ID_USART4);              }
 8000da8:	2034      	movs	r0, #52	; 0x34
 8000daa:	e731      	b.n	8000c10 <BSP_IntHandler>

08000dac <BSP_IntHandlerUSART5>:
void  BSP_IntHandlerUSART5             (void)  { BSP_IntHandler(BSP_INT_ID_USART5);              }
 8000dac:	2035      	movs	r0, #53	; 0x35
 8000dae:	e72f      	b.n	8000c10 <BSP_IntHandler>

08000db0 <BSP_IntHandlerTIM6>:
void  BSP_IntHandlerTIM6               (void)  { BSP_IntHandler(BSP_INT_ID_TIM6);                }
 8000db0:	2036      	movs	r0, #54	; 0x36
 8000db2:	e72d      	b.n	8000c10 <BSP_IntHandler>

08000db4 <BSP_IntHandlerTIM7>:
void  BSP_IntHandlerTIM7               (void)  { BSP_IntHandler(BSP_INT_ID_TIM7);                }
 8000db4:	2037      	movs	r0, #55	; 0x37
 8000db6:	e72b      	b.n	8000c10 <BSP_IntHandler>

08000db8 <BSP_IntHandlerDMA2_CH1>:
void  BSP_IntHandlerDMA2_CH1           (void)  { BSP_IntHandler(BSP_INT_ID_DMA2_CH1);            }
 8000db8:	2038      	movs	r0, #56	; 0x38
 8000dba:	e729      	b.n	8000c10 <BSP_IntHandler>

08000dbc <BSP_IntHandlerDMA2_CH2>:
void  BSP_IntHandlerDMA2_CH2           (void)  { BSP_IntHandler(BSP_INT_ID_DMA2_CH2);            }
 8000dbc:	2039      	movs	r0, #57	; 0x39
 8000dbe:	e727      	b.n	8000c10 <BSP_IntHandler>

08000dc0 <BSP_IntHandlerDMA2_CH3>:
void  BSP_IntHandlerDMA2_CH3           (void)  { BSP_IntHandler(BSP_INT_ID_DMA2_CH3);            }
 8000dc0:	203a      	movs	r0, #58	; 0x3a
 8000dc2:	e725      	b.n	8000c10 <BSP_IntHandler>

08000dc4 <BSP_IntHandlerDMA2_CH4>:
void  BSP_IntHandlerDMA2_CH4           (void)  { BSP_IntHandler(BSP_INT_ID_DMA2_CH4);            }
 8000dc4:	203b      	movs	r0, #59	; 0x3b
 8000dc6:	e723      	b.n	8000c10 <BSP_IntHandler>

08000dc8 <BSP_IntHandlerDMA2_CH5>:
void  BSP_IntHandlerDMA2_CH5           (void)  { BSP_IntHandler(BSP_INT_ID_DMA2_CH5);            }
 8000dc8:	203c      	movs	r0, #60	; 0x3c
 8000dca:	e721      	b.n	8000c10 <BSP_IntHandler>

08000dcc <BSP_IntHandlerETH>:
void  BSP_IntHandlerETH                (void)  { BSP_IntHandler(BSP_INT_ID_ETH);                 }
 8000dcc:	203d      	movs	r0, #61	; 0x3d
 8000dce:	e71f      	b.n	8000c10 <BSP_IntHandler>

08000dd0 <BSP_IntHandlerETHWakeup>:
void  BSP_IntHandlerETHWakeup          (void)  { BSP_IntHandler(BSP_INT_ID_ETH_WKUP);            }
 8000dd0:	203e      	movs	r0, #62	; 0x3e
 8000dd2:	e71d      	b.n	8000c10 <BSP_IntHandler>

08000dd4 <BSP_IntHandlerCAN2_TX>:
void  BSP_IntHandlerCAN2_TX            (void)  { BSP_IntHandler(BSP_INT_ID_CAN2_TX);             }
 8000dd4:	203f      	movs	r0, #63	; 0x3f
 8000dd6:	e71b      	b.n	8000c10 <BSP_IntHandler>

08000dd8 <BSP_IntHandlerCAN2_RX0>:
void  BSP_IntHandlerCAN2_RX0           (void)  { BSP_IntHandler(BSP_INT_ID_CAN2_RX0);            }
 8000dd8:	2040      	movs	r0, #64	; 0x40
 8000dda:	e719      	b.n	8000c10 <BSP_IntHandler>

08000ddc <BSP_IntHandlerCAN2_RX1>:
void  BSP_IntHandlerCAN2_RX1           (void)  { BSP_IntHandler(BSP_INT_ID_CAN2_RX1);            }
 8000ddc:	2041      	movs	r0, #65	; 0x41
 8000dde:	e717      	b.n	8000c10 <BSP_IntHandler>

08000de0 <BSP_IntHandlerCAN2_SCE>:
void  BSP_IntHandlerCAN2_SCE           (void)  { BSP_IntHandler(BSP_INT_ID_CAN2_SCE);            }
 8000de0:	2042      	movs	r0, #66	; 0x42
 8000de2:	e715      	b.n	8000c10 <BSP_IntHandler>

08000de4 <BSP_IntHandlerOTG>:
void  BSP_IntHandlerOTG                (void)  { BSP_IntHandler(BSP_INT_ID_OTG_FS);              }
 8000de4:	2043      	movs	r0, #67	; 0x43
 8000de6:	e713      	b.n	8000c10 <BSP_IntHandler>

08000de8 <BSP_IntHandlerDMA2_CH6>:
void  BSP_IntHandlerDMA2_CH6           (void)  { BSP_IntHandler(BSP_INT_ID_DMA2_CH6);            }
 8000de8:	2044      	movs	r0, #68	; 0x44
 8000dea:	e711      	b.n	8000c10 <BSP_IntHandler>

08000dec <BSP_IntHandlerDMA2_CH7>:
void  BSP_IntHandlerDMA2_CH7           (void)  { BSP_IntHandler(BSP_INT_ID_DMA2_CH7);            }
 8000dec:	2045      	movs	r0, #69	; 0x45
 8000dee:	e70f      	b.n	8000c10 <BSP_IntHandler>

08000df0 <BSP_IntHandlerDMA2_CH8>:
void  BSP_IntHandlerDMA2_CH8           (void)  { BSP_IntHandler(BSP_INT_ID_DMA2_CH8);            }
 8000df0:	2046      	movs	r0, #70	; 0x46
 8000df2:	e70d      	b.n	8000c10 <BSP_IntHandler>

08000df4 <BSP_IntHandlerUSART6>:
void  BSP_IntHandlerUSART6             (void)  { BSP_IntHandler(BSP_INT_ID_USART6);              }
 8000df4:	2047      	movs	r0, #71	; 0x47
 8000df6:	e70b      	b.n	8000c10 <BSP_IntHandler>

08000df8 <BSP_IntHandlerI2C3_EV>:
void  BSP_IntHandlerI2C3_EV            (void)  { BSP_IntHandler(BSP_INT_ID_I2C3_EV);             }
 8000df8:	2048      	movs	r0, #72	; 0x48
 8000dfa:	e709      	b.n	8000c10 <BSP_IntHandler>

08000dfc <BSP_IntHandlerI2C3_ER>:
void  BSP_IntHandlerI2C3_ER            (void)  { BSP_IntHandler(BSP_INT_ID_I2C3_ER);             }
 8000dfc:	2049      	movs	r0, #73	; 0x49
 8000dfe:	e707      	b.n	8000c10 <BSP_IntHandler>

08000e00 <BSP_IntHandlerOTG_HS_EP1_OUT>:
void  BSP_IntHandlerOTG_HS_EP1_OUT     (void)  { BSP_IntHandler(BSP_INT_ID_OTG_HS_EP1_OUT);      }
 8000e00:	204a      	movs	r0, #74	; 0x4a
 8000e02:	e705      	b.n	8000c10 <BSP_IntHandler>

08000e04 <BSP_IntHandlerOTG_HS_EP1_IN>:
void  BSP_IntHandlerOTG_HS_EP1_IN      (void)  { BSP_IntHandler(BSP_INT_ID_OTG_HS_EP1_IN);       }
 8000e04:	204b      	movs	r0, #75	; 0x4b
 8000e06:	e703      	b.n	8000c10 <BSP_IntHandler>

08000e08 <BSP_IntHandlerOTG_HS_WKUP>:
void  BSP_IntHandlerOTG_HS_WKUP        (void)  { BSP_IntHandler(BSP_INT_ID_OTG_HS_WKUP);         }
 8000e08:	204c      	movs	r0, #76	; 0x4c
 8000e0a:	e701      	b.n	8000c10 <BSP_IntHandler>

08000e0c <BSP_IntHandlerOTG_HS>:
void  BSP_IntHandlerOTG_HS             (void)  { BSP_IntHandler(BSP_INT_ID_OTG_HS);              }
 8000e0c:	204d      	movs	r0, #77	; 0x4d
 8000e0e:	e6ff      	b.n	8000c10 <BSP_IntHandler>

08000e10 <BSP_IntHandlerDCMI>:
void  BSP_IntHandlerDCMI               (void)  { BSP_IntHandler(BSP_INT_ID_DCMI);                }
 8000e10:	204e      	movs	r0, #78	; 0x4e
 8000e12:	e6fd      	b.n	8000c10 <BSP_IntHandler>

08000e14 <BSP_IntHandlerCRYP>:
void  BSP_IntHandlerCRYP               (void)  { BSP_IntHandler(BSP_INT_ID_CRYP);                }
 8000e14:	204f      	movs	r0, #79	; 0x4f
 8000e16:	e6fb      	b.n	8000c10 <BSP_IntHandler>

08000e18 <BSP_IntHandlerHASH_RNG>:
void  BSP_IntHandlerHASH_RNG           (void)  { BSP_IntHandler(BSP_INT_ID_HASH_RNG);            }
 8000e18:	2050      	movs	r0, #80	; 0x50
 8000e1a:	e6f9      	b.n	8000c10 <BSP_IntHandler>

08000e1c <BSP_EXTI_15_10_IntHandler>:
*
* Note(s)     : none.
*********************************************************************************************************
*/
void BSP_EXTI_15_10_IntHandler(void)
{
 8000e1c:	b508      	push	{r3, lr}
	if(EXTI_GetFlagStatus(EXTI_Line10))
 8000e1e:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8000e22:	f007 fb11 	bl	8008448 <EXTI_GetFlagStatus>
 8000e26:	b9f8      	cbnz	r0, 8000e68 <BSP_EXTI_15_10_IntHandler+0x4c>
	{
		;
		EXTI_ClearITPendingBit(EXTI_Line10);
	}
	else if(EXTI_GetFlagStatus(EXTI_Line11))
 8000e28:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8000e2c:	f007 fb0c 	bl	8008448 <EXTI_GetFlagStatus>
 8000e30:	b9a0      	cbnz	r0, 8000e5c <BSP_EXTI_15_10_IntHandler+0x40>
	{
		
		EXTI_ClearITPendingBit(EXTI_Line11);
	}
	else if(EXTI_GetFlagStatus(EXTI_Line12))
 8000e32:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8000e36:	f007 fb07 	bl	8008448 <EXTI_GetFlagStatus>
 8000e3a:	bb08      	cbnz	r0, 8000e80 <BSP_EXTI_15_10_IntHandler+0x64>
	{
		Eth_Link_ITHandler(DP83848_PHY_ADDRESS);
		EXTI_ClearITPendingBit(EXTI_Line12);
	}
	else if(EXTI_GetFlagStatus(EXTI_Line13))
 8000e3c:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 8000e40:	f007 fb02 	bl	8008448 <EXTI_GetFlagStatus>
 8000e44:	b9b0      	cbnz	r0, 8000e74 <BSP_EXTI_15_10_IntHandler+0x58>
	{
		EXTI_ClearITPendingBit(EXTI_Line13);
	}
	else if(EXTI_GetFlagStatus(EXTI_Line14))
 8000e46:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8000e4a:	f007 fafd 	bl	8008448 <EXTI_GetFlagStatus>
 8000e4e:	bb00      	cbnz	r0, 8000e92 <BSP_EXTI_15_10_IntHandler+0x76>
	{
		;
		EXTI_ClearITPendingBit(EXTI_Line14);
	}
	else if(EXTI_GetFlagStatus(EXTI_Line15))
 8000e50:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8000e54:	f007 faf8 	bl	8008448 <EXTI_GetFlagStatus>
 8000e58:	bb08      	cbnz	r0, 8000e9e <BSP_EXTI_15_10_IntHandler+0x82>
 8000e5a:	bd08      	pop	{r3, pc}
		EXTI_ClearITPendingBit(EXTI_Line10);
	}
	else if(EXTI_GetFlagStatus(EXTI_Line11))
	{
		
		EXTI_ClearITPendingBit(EXTI_Line11);
 8000e5c:	f44f 6000 	mov.w	r0, #2048	; 0x800
	{
		;
		EXTI_ClearITPendingBit(EXTI_Line15);
	}
	
}
 8000e60:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		EXTI_ClearITPendingBit(EXTI_Line10);
	}
	else if(EXTI_GetFlagStatus(EXTI_Line11))
	{
		
		EXTI_ClearITPendingBit(EXTI_Line11);
 8000e64:	f007 bb0e 	b.w	8008484 <EXTI_ClearITPendingBit>
void BSP_EXTI_15_10_IntHandler(void)
{
	if(EXTI_GetFlagStatus(EXTI_Line10))
	{
		;
		EXTI_ClearITPendingBit(EXTI_Line10);
 8000e68:	f44f 6080 	mov.w	r0, #1024	; 0x400
	{
		;
		EXTI_ClearITPendingBit(EXTI_Line15);
	}
	
}
 8000e6c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
void BSP_EXTI_15_10_IntHandler(void)
{
	if(EXTI_GetFlagStatus(EXTI_Line10))
	{
		;
		EXTI_ClearITPendingBit(EXTI_Line10);
 8000e70:	f007 bb08 	b.w	8008484 <EXTI_ClearITPendingBit>
		Eth_Link_ITHandler(DP83848_PHY_ADDRESS);
		EXTI_ClearITPendingBit(EXTI_Line12);
	}
	else if(EXTI_GetFlagStatus(EXTI_Line13))
	{
		EXTI_ClearITPendingBit(EXTI_Line13);
 8000e74:	f44f 5000 	mov.w	r0, #8192	; 0x2000
	{
		;
		EXTI_ClearITPendingBit(EXTI_Line15);
	}
	
}
 8000e78:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		Eth_Link_ITHandler(DP83848_PHY_ADDRESS);
		EXTI_ClearITPendingBit(EXTI_Line12);
	}
	else if(EXTI_GetFlagStatus(EXTI_Line13))
	{
		EXTI_ClearITPendingBit(EXTI_Line13);
 8000e7c:	f007 bb02 	b.w	8008484 <EXTI_ClearITPendingBit>
		
		EXTI_ClearITPendingBit(EXTI_Line11);
	}
	else if(EXTI_GetFlagStatus(EXTI_Line12))
	{
		Eth_Link_ITHandler(DP83848_PHY_ADDRESS);
 8000e80:	2001      	movs	r0, #1
 8000e82:	f00c fa33 	bl	800d2ec <Eth_Link_ITHandler>
	{
		;
		EXTI_ClearITPendingBit(EXTI_Line15);
	}
	
}
 8000e86:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		EXTI_ClearITPendingBit(EXTI_Line11);
	}
	else if(EXTI_GetFlagStatus(EXTI_Line12))
	{
		Eth_Link_ITHandler(DP83848_PHY_ADDRESS);
		EXTI_ClearITPendingBit(EXTI_Line12);
 8000e8a:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8000e8e:	f007 baf9 	b.w	8008484 <EXTI_ClearITPendingBit>
		EXTI_ClearITPendingBit(EXTI_Line13);
	}
	else if(EXTI_GetFlagStatus(EXTI_Line14))
	{
		;
		EXTI_ClearITPendingBit(EXTI_Line14);
 8000e92:	f44f 4080 	mov.w	r0, #16384	; 0x4000
	{
		;
		EXTI_ClearITPendingBit(EXTI_Line15);
	}
	
}
 8000e96:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		EXTI_ClearITPendingBit(EXTI_Line13);
	}
	else if(EXTI_GetFlagStatus(EXTI_Line14))
	{
		;
		EXTI_ClearITPendingBit(EXTI_Line14);
 8000e9a:	f007 baf3 	b.w	8008484 <EXTI_ClearITPendingBit>
	}
	else if(EXTI_GetFlagStatus(EXTI_Line15))
	{
		;
		EXTI_ClearITPendingBit(EXTI_Line15);
 8000e9e:	f44f 4000 	mov.w	r0, #32768	; 0x8000
	}
	
}
 8000ea2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		EXTI_ClearITPendingBit(EXTI_Line14);
	}
	else if(EXTI_GetFlagStatus(EXTI_Line15))
	{
		;
		EXTI_ClearITPendingBit(EXTI_Line15);
 8000ea6:	f007 baed 	b.w	8008484 <EXTI_ClearITPendingBit>
 8000eaa:	bf00      	nop

08000eac <run_command_repeatable>:
 * @return 0 (not repeatable) or 1 (repeatable) on success, -1 on error.
 */
int run_command_repeatable(const char *cmd, int flag)
{
#if 1
	return cli_simple_run_command(cmd, flag);
 8000eac:	f000 b8c4 	b.w	8001038 <cli_simple_run_command>

08000eb0 <cli_loop>:
#endif
}

void cli_loop(void)
{
	cli_simple_loop();
 8000eb0:	f000 b926 	b.w	8001100 <cli_simple_loop>

08000eb4 <cli_init>:
}

void cli_init(void)
{
 8000eb4:	4770      	bx	lr
 8000eb6:	bf00      	nop

08000eb8 <cli_simple_parse_line>:

#define debug_parser(fmt, args...)	


int cli_simple_parse_line(char *line, char *argv[])
{
 8000eb8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	int nargs = 0;
 8000ebc:	2600      	movs	r6, #0

#define debug_parser(fmt, args...)	


int cli_simple_parse_line(char *line, char *argv[])
{
 8000ebe:	4689      	mov	r9, r1
			argv[nargs] = NULL;
			debug_parser("parse_line: nargs=%d\n", nargs);
			return nargs;
		}

		*line++ = '\0';		/* terminate current arg	 */
 8000ec0:	46b0      	mov	r8, r6
 8000ec2:	1f0f      	subs	r7, r1, #4
 8000ec4:	4605      	mov	r5, r0
	int nargs = 0;

	debug_parser("%s: \"%s\"\n", __func__, line);
	while (nargs < SHELL_SYS_MAXARGS) {
		/* skip any white space */
		while (isblank(*line))
 8000ec6:	7828      	ldrb	r0, [r5, #0]
 8000ec8:	462c      	mov	r4, r5
 8000eca:	3501      	adds	r5, #1
 8000ecc:	f013 fef6 	bl	8014cbc <isblank>
 8000ed0:	2800      	cmp	r0, #0
 8000ed2:	d1f8      	bne.n	8000ec6 <cli_simple_parse_line+0xe>
			++line;

		if (*line == '\0') {	/* end of line, no more args	*/
 8000ed4:	7823      	ldrb	r3, [r4, #0]
 8000ed6:	b1e3      	cbz	r3, 8000f12 <cli_simple_parse_line+0x5a>
			argv[nargs] = NULL;
			debug_parser("%s: nargs=%d\n", __func__, nargs);
			return nargs;
		}

		argv[nargs++] = line;	/* begin of argument string	*/
 8000ed8:	f847 4f04 	str.w	r4, [r7, #4]!

		/* find end of string */
		while (*line && !isblank(*line))
 8000edc:	7820      	ldrb	r0, [r4, #0]
			argv[nargs] = NULL;
			debug_parser("%s: nargs=%d\n", __func__, nargs);
			return nargs;
		}

		argv[nargs++] = line;	/* begin of argument string	*/
 8000ede:	3601      	adds	r6, #1

		/* find end of string */
		while (*line && !isblank(*line))
 8000ee0:	b918      	cbnz	r0, 8000eea <cli_simple_parse_line+0x32>
 8000ee2:	e015      	b.n	8000f10 <cli_simple_parse_line+0x58>
 8000ee4:	f814 0f01 	ldrb.w	r0, [r4, #1]!
 8000ee8:	b190      	cbz	r0, 8000f10 <cli_simple_parse_line+0x58>
 8000eea:	f013 fee7 	bl	8014cbc <isblank>
 8000eee:	2800      	cmp	r0, #0
 8000ef0:	d0f8      	beq.n	8000ee4 <cli_simple_parse_line+0x2c>
			++line;

		if (*line == '\0') {	/* end of line, no more args	*/
 8000ef2:	7823      	ldrb	r3, [r4, #0]
 8000ef4:	b163      	cbz	r3, 8000f10 <cli_simple_parse_line+0x58>
int cli_simple_parse_line(char *line, char *argv[])
{
	int nargs = 0;

	debug_parser("%s: \"%s\"\n", __func__, line);
	while (nargs < SHELL_SYS_MAXARGS) {
 8000ef6:	2e10      	cmp	r6, #16
			argv[nargs] = NULL;
			debug_parser("parse_line: nargs=%d\n", nargs);
			return nargs;
		}

		*line++ = '\0';		/* terminate current arg	 */
 8000ef8:	f884 8000 	strb.w	r8, [r4]
 8000efc:	f104 0001 	add.w	r0, r4, #1
int cli_simple_parse_line(char *line, char *argv[])
{
	int nargs = 0;

	debug_parser("%s: \"%s\"\n", __func__, line);
	while (nargs < SHELL_SYS_MAXARGS) {
 8000f00:	d1e0      	bne.n	8000ec4 <cli_simple_parse_line+0xc>
		}

		*line++ = '\0';		/* terminate current arg	 */
	}

	printf("** Too many args (max. %d) **\n", SHELL_SYS_MAXARGS);
 8000f02:	4631      	mov	r1, r6
 8000f04:	4805      	ldr	r0, [pc, #20]	; (8000f1c <cli_simple_parse_line+0x64>)
 8000f06:	f013 ff37 	bl	8014d78 <iprintf>

	debug_parser("%s: nargs=%d\n", __func__, nargs);
	return nargs;
}
 8000f0a:	4630      	mov	r0, r6
 8000f0c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		/* find end of string */
		while (*line && !isblank(*line))
			++line;

		if (*line == '\0') {	/* end of line, no more args	*/
			argv[nargs] = NULL;
 8000f10:	2300      	movs	r3, #0
 8000f12:	f849 3026 	str.w	r3, [r9, r6, lsl #2]

	printf("** Too many args (max. %d) **\n", SHELL_SYS_MAXARGS);

	debug_parser("%s: nargs=%d\n", __func__, nargs);
	return nargs;
}
 8000f16:	4630      	mov	r0, r6
 8000f18:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8000f1c:	0801626c 	.word	0x0801626c

08000f20 <cli_simple_process_macros>:

#if 1
void cli_simple_process_macros(const char *input, char *output)
{
 8000f20:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000f24:	4688      	mov	r8, r1
 8000f26:	4604      	mov	r4, r0
	char c, prev;
	const char *varname_start = NULL;
	int inputcnt = strlen(input);
 8000f28:	f013 fe6e 	bl	8014c08 <strlen>
	debug_parser("[PROCESS_MACROS] INPUT len %zd: \"%s\"\n", strlen(input),
		     input);

	prev = '\0';		/* previous character   */

	while (inputcnt && outputcnt) {
 8000f2c:	b390      	cbz	r0, 8000f94 <cli_simple_process_macros+0x74>
 8000f2e:	2500      	movs	r5, #0
		c = *input++;
		inputcnt--;

		if (state != 3) {
 8000f30:	2d03      	cmp	r5, #3
	debug_parser("[PROCESS_MACROS] INPUT len %zd: \"%s\"\n", strlen(input),
		     input);

	prev = '\0';		/* previous character   */

	while (inputcnt && outputcnt) {
 8000f32:	4629      	mov	r1, r5
 8000f34:	f04f 0740 	mov.w	r7, #64	; 0x40
			if (c == '(' || c == '{') {
				state++;
				varname_start = input;
			} else {
				state = 0;
				*(output++) = '$';
 8000f38:	f04f 0e24 	mov.w	lr, #36	; 0x24
		     input);

	prev = '\0';		/* previous character   */

	while (inputcnt && outputcnt) {
		c = *input++;
 8000f3c:	f104 0601 	add.w	r6, r4, #1
 8000f40:	7823      	ldrb	r3, [r4, #0]
		inputcnt--;
 8000f42:	f100 32ff 	add.w	r2, r0, #4294967295

		if (state != 3) {
 8000f46:	d017      	beq.n	8000f78 <cli_simple_process_macros+0x58>
			/* remove one level of escape characters */
			if ((c == '\\') && (prev != '\\')) {
 8000f48:	2b5c      	cmp	r3, #92	; 0x5c
 8000f4a:	d036      	beq.n	8000fba <cli_simple_process_macros+0x9a>
				prev = c;
				c = *input++;
			}
		}

		switch (state) {
 8000f4c:	2d01      	cmp	r5, #1
 8000f4e:	d040      	beq.n	8000fd2 <cli_simple_process_macros+0xb2>
 8000f50:	2d02      	cmp	r5, #2
 8000f52:	d124      	bne.n	8000f9e <cli_simple_process_macros+0x7e>
					outputcnt--;
				}
			}
			break;
		case 2:	/* Waiting for )        */
			if (c == ')' || c == '}') {
 8000f54:	2b29      	cmp	r3, #41	; 0x29
 8000f56:	d050      	beq.n	8000ffa <cli_simple_process_macros+0xda>
 8000f58:	2b7d      	cmp	r3, #125	; 0x7d
 8000f5a:	d04e      	beq.n	8000ffa <cli_simple_process_macros+0xda>
 8000f5c:	4619      	mov	r1, r3
 8000f5e:	4634      	mov	r4, r6
 8000f60:	4610      	mov	r0, r2
 8000f62:	2502      	movs	r5, #2
	debug_parser("[PROCESS_MACROS] INPUT len %zd: \"%s\"\n", strlen(input),
		     input);

	prev = '\0';		/* previous character   */

	while (inputcnt && outputcnt) {
 8000f64:	b1a2      	cbz	r2, 8000f90 <cli_simple_process_macros+0x70>
 8000f66:	2f00      	cmp	r7, #0
 8000f68:	d05a      	beq.n	8001020 <cli_simple_process_macros+0x100>
		c = *input++;
		inputcnt--;

		if (state != 3) {
 8000f6a:	2d03      	cmp	r5, #3
		     input);

	prev = '\0';		/* previous character   */

	while (inputcnt && outputcnt) {
		c = *input++;
 8000f6c:	f104 0601 	add.w	r6, r4, #1
 8000f70:	7823      	ldrb	r3, [r4, #0]
		inputcnt--;
 8000f72:	f100 32ff 	add.w	r2, r0, #4294967295

		if (state != 3) {
 8000f76:	d1e7      	bne.n	8000f48 <cli_simple_process_macros+0x28>
				/* Look for another '$' */
				state = 0;
			}
			break;
		case 3:	/* Waiting for '        */
			if ((c == '\'') && (prev != '\\')) {
 8000f78:	2b27      	cmp	r3, #39	; 0x27
 8000f7a:	d03c      	beq.n	8000ff6 <cli_simple_process_macros+0xd6>
				state = 0;
			} else {
				*(output++) = c;
 8000f7c:	f888 3000 	strb.w	r3, [r8]
				outputcnt--;
 8000f80:	3f01      	subs	r7, #1
		     input);

	prev = '\0';		/* previous character   */

	while (inputcnt && outputcnt) {
		c = *input++;
 8000f82:	4619      	mov	r1, r3
			break;
		case 3:	/* Waiting for '        */
			if ((c == '\'') && (prev != '\\')) {
				state = 0;
			} else {
				*(output++) = c;
 8000f84:	f108 0801 	add.w	r8, r8, #1
		     input);

	prev = '\0';		/* previous character   */

	while (inputcnt && outputcnt) {
		c = *input++;
 8000f88:	4634      	mov	r4, r6
		inputcnt--;
 8000f8a:	4610      	mov	r0, r2
	debug_parser("[PROCESS_MACROS] INPUT len %zd: \"%s\"\n", strlen(input),
		     input);

	prev = '\0';		/* previous character   */

	while (inputcnt && outputcnt) {
 8000f8c:	2a00      	cmp	r2, #0
 8000f8e:	d1ea      	bne.n	8000f66 <cli_simple_process_macros+0x46>
			break;
		}
		prev = c;
	}

	if (outputcnt)
 8000f90:	2f00      	cmp	r7, #0
 8000f92:	d045      	beq.n	8001020 <cli_simple_process_macros+0x100>
		*output = 0;
 8000f94:	2300      	movs	r3, #0
 8000f96:	f888 3000 	strb.w	r3, [r8]
 8000f9a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			}
		}

		switch (state) {
		case 0:	/* Waiting for (unescaped) $    */
			if ((c == '\'') && (prev != '\\')) {
 8000f9e:	2b27      	cmp	r3, #39	; 0x27
 8000fa0:	d035      	beq.n	800100e <cli_simple_process_macros+0xee>
				state = 3;
				break;
			}
			if ((c == '$') && (prev != '\\')) {
 8000fa2:	2b24      	cmp	r3, #36	; 0x24
 8000fa4:	d041      	beq.n	800102a <cli_simple_process_macros+0x10a>
				state++;
			} else {
				*(output++) = c;
 8000fa6:	f888 3000 	strb.w	r3, [r8]
				outputcnt--;
 8000faa:	3f01      	subs	r7, #1
 8000fac:	4619      	mov	r1, r3
				break;
			}
			if ((c == '$') && (prev != '\\')) {
				state++;
			} else {
				*(output++) = c;
 8000fae:	f108 0801 	add.w	r8, r8, #1
				outputcnt--;
 8000fb2:	4634      	mov	r4, r6
 8000fb4:	4610      	mov	r0, r2
 8000fb6:	2500      	movs	r5, #0
 8000fb8:	e7d4      	b.n	8000f64 <cli_simple_process_macros+0x44>
		c = *input++;
		inputcnt--;

		if (state != 3) {
			/* remove one level of escape characters */
			if ((c == '\\') && (prev != '\\')) {
 8000fba:	295c      	cmp	r1, #92	; 0x5c
 8000fbc:	d022      	beq.n	8001004 <cli_simple_process_macros+0xe4>
				if (inputcnt-- == 0)
 8000fbe:	3802      	subs	r0, #2
 8000fc0:	2a00      	cmp	r2, #0
 8000fc2:	d0e5      	beq.n	8000f90 <cli_simple_process_macros+0x70>
				prev = c;
				c = *input++;
			}
		}

		switch (state) {
 8000fc4:	2d01      	cmp	r5, #1
			/* remove one level of escape characters */
			if ((c == '\\') && (prev != '\\')) {
				if (inputcnt-- == 0)
					break;
				prev = c;
				c = *input++;
 8000fc6:	4619      	mov	r1, r3
		inputcnt--;

		if (state != 3) {
			/* remove one level of escape characters */
			if ((c == '\\') && (prev != '\\')) {
				if (inputcnt-- == 0)
 8000fc8:	4602      	mov	r2, r0
					break;
				prev = c;
				c = *input++;
 8000fca:	7863      	ldrb	r3, [r4, #1]
 8000fcc:	f104 0602 	add.w	r6, r4, #2
			}
		}

		switch (state) {
 8000fd0:	d1be      	bne.n	8000f50 <cli_simple_process_macros+0x30>
				*(output++) = c;
				outputcnt--;
			}
			break;
		case 1:	/* Waiting for (        */
			if (c == '(' || c == '{') {
 8000fd2:	2b28      	cmp	r3, #40	; 0x28
 8000fd4:	d0c2      	beq.n	8000f5c <cli_simple_process_macros+0x3c>
 8000fd6:	2b7b      	cmp	r3, #123	; 0x7b
 8000fd8:	d0c0      	beq.n	8000f5c <cli_simple_process_macros+0x3c>
			} else {
				state = 0;
				*(output++) = '$';
				outputcnt--;

				if (outputcnt) {
 8000fda:	2f01      	cmp	r7, #1
			if (c == '(' || c == '{') {
				state++;
				varname_start = input;
			} else {
				state = 0;
				*(output++) = '$';
 8000fdc:	f888 e000 	strb.w	lr, [r8]
				outputcnt--;

				if (outputcnt) {
 8000fe0:	d01c      	beq.n	800101c <cli_simple_process_macros+0xfc>
					*(output++) = c;
 8000fe2:	f888 3001 	strb.w	r3, [r8, #1]
					outputcnt--;
 8000fe6:	3f02      	subs	r7, #2
 8000fe8:	4619      	mov	r1, r3
				state = 0;
				*(output++) = '$';
				outputcnt--;

				if (outputcnt) {
					*(output++) = c;
 8000fea:	f108 0802 	add.w	r8, r8, #2
					outputcnt--;
 8000fee:	4634      	mov	r4, r6
 8000ff0:	4610      	mov	r0, r2
		case 1:	/* Waiting for (        */
			if (c == '(' || c == '{') {
				state++;
				varname_start = input;
			} else {
				state = 0;
 8000ff2:	2500      	movs	r5, #0
 8000ff4:	e7b6      	b.n	8000f64 <cli_simple_process_macros+0x44>
				/* Look for another '$' */
				state = 0;
			}
			break;
		case 3:	/* Waiting for '        */
			if ((c == '\'') && (prev != '\\')) {
 8000ff6:	295c      	cmp	r1, #92	; 0x5c
 8000ff8:	d0c0      	beq.n	8000f7c <cli_simple_process_macros+0x5c>
 8000ffa:	4619      	mov	r1, r3
		     input);

	prev = '\0';		/* previous character   */

	while (inputcnt && outputcnt) {
		c = *input++;
 8000ffc:	4634      	mov	r4, r6
		inputcnt--;
 8000ffe:	4610      	mov	r0, r2
				state = 0;
			}
			break;
		case 3:	/* Waiting for '        */
			if ((c == '\'') && (prev != '\\')) {
				state = 0;
 8001000:	2500      	movs	r5, #0
 8001002:	e7af      	b.n	8000f64 <cli_simple_process_macros+0x44>
				prev = c;
				c = *input++;
			}
		}

		switch (state) {
 8001004:	2d01      	cmp	r5, #1
 8001006:	d0e8      	beq.n	8000fda <cli_simple_process_macros+0xba>
 8001008:	2d02      	cmp	r5, #2
 800100a:	d0a7      	beq.n	8000f5c <cli_simple_process_macros+0x3c>
 800100c:	e7cb      	b.n	8000fa6 <cli_simple_process_macros+0x86>
		case 0:	/* Waiting for (unescaped) $    */
			if ((c == '\'') && (prev != '\\')) {
 800100e:	295c      	cmp	r1, #92	; 0x5c
 8001010:	d0c9      	beq.n	8000fa6 <cli_simple_process_macros+0x86>
 8001012:	4619      	mov	r1, r3
 8001014:	4634      	mov	r4, r6
 8001016:	4610      	mov	r0, r2
				state = 3;
 8001018:	2503      	movs	r5, #3
 800101a:	e7a3      	b.n	8000f64 <cli_simple_process_macros+0x44>
			if (c == '(' || c == '{') {
				state++;
				varname_start = input;
			} else {
				state = 0;
				*(output++) = '$';
 800101c:	f108 0801 	add.w	r8, r8, #1
	}

	if (outputcnt)
		*output = 0;
	else
		*(output - 1) = 0;
 8001020:	2300      	movs	r3, #0
 8001022:	f808 3c01 	strb.w	r3, [r8, #-1]

	debug_parser("[PROCESS_MACROS] OUTPUT len %zd: \"%s\"\n",
		     strlen(output_start), output_start);
}
 8001026:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		case 0:	/* Waiting for (unescaped) $    */
			if ((c == '\'') && (prev != '\\')) {
				state = 3;
				break;
			}
			if ((c == '$') && (prev != '\\')) {
 800102a:	295c      	cmp	r1, #92	; 0x5c
 800102c:	d0bb      	beq.n	8000fa6 <cli_simple_process_macros+0x86>
 800102e:	4619      	mov	r1, r3
 8001030:	4634      	mov	r4, r6
 8001032:	4610      	mov	r0, r2
				state++;
 8001034:	2501      	movs	r5, #1
 8001036:	e795      	b.n	8000f64 <cli_simple_process_macros+0x44>

08001038 <cli_simple_run_command>:
 * may be the result from env_get(), which returns a pointer directly to
 * the environment data, which may change magicly when the command we run
 * creates or modifies environment variables (like "bootp" does).
 */
int cli_simple_run_command(const char *cmd, int flag)
{
 8001038:	b570      	push	{r4, r5, r6, lr}
 800103a:	4604      	mov	r4, r0
 800103c:	b0b4      	sub	sp, #208	; 0xd0
	char *sep;			/* end of token (separator) in cmdbuf */
	char finaltoken[SHELL_SYS_CBSIZE];
	char *str = cmdbuf;
	char *argv[SHELL_SYS_MAXARGS + 1];	/* NULL terminated	*/
	int argc, inquotes;
	int repeatable = 1;
 800103e:	2301      	movs	r3, #1
 * may be the result from env_get(), which returns a pointer directly to
 * the environment data, which may change magicly when the command we run
 * creates or modifies environment variables (like "bootp" does).
 */
int cli_simple_run_command(const char *cmd, int flag)
{
 8001040:	460e      	mov	r6, r1
	char *sep;			/* end of token (separator) in cmdbuf */
	char finaltoken[SHELL_SYS_CBSIZE];
	char *str = cmdbuf;
	char *argv[SHELL_SYS_MAXARGS + 1];	/* NULL terminated	*/
	int argc, inquotes;
	int repeatable = 1;
 8001042:	9302      	str	r3, [sp, #8]
	if (DEBUG_PARSER) {
		/* use puts - string may be loooong */
		puts(cmd ? cmd : "NULL");
		puts("\"\n");
	}
	clear_ctrlc();		/* forget any previous Control C */
 8001044:	f000 fb8c 	bl	8001760 <clear_ctrlc>

	if (!cmd || !*cmd)
 8001048:	2c00      	cmp	r4, #0
 800104a:	d04e      	beq.n	80010ea <cli_simple_run_command+0xb2>
 800104c:	7823      	ldrb	r3, [r4, #0]
 800104e:	2b00      	cmp	r3, #0
 8001050:	d04b      	beq.n	80010ea <cli_simple_run_command+0xb2>
		return -1;	/* empty command */

	if (strlen(cmd) >= SHELL_SYS_CBSIZE) {
 8001052:	4620      	mov	r0, r4
 8001054:	f013 fdd8 	bl	8014c08 <strlen>
 8001058:	283f      	cmp	r0, #63	; 0x3f
 800105a:	dc4a      	bgt.n	80010f2 <cli_simple_run_command+0xba>
		puts("## Command too long!\n");
		return -1;
	}

	strcpy(cmdbuf, cmd);
 800105c:	4621      	mov	r1, r4
 800105e:	a803      	add	r0, sp, #12
 8001060:	f013 ff42 	bl	8014ee8 <strcpy>
{
	char cmdbuf[SHELL_SYS_CBSIZE];	/* working copy of cmd		*/
	char *token;			/* start of token in cmdbuf	*/
	char *sep;			/* end of token (separator) in cmdbuf */
	char finaltoken[SHELL_SYS_CBSIZE];
	char *str = cmdbuf;
 8001064:	a803      	add	r0, sp, #12
	/* Process separators and check for invalid
	 * repeatable commands
	 */

	debug_parser("[PROCESS_SEPARATORS] %s\n", cmd);
	while (*str) {
 8001066:	7803      	ldrb	r3, [r0, #0]
	char finaltoken[SHELL_SYS_CBSIZE];
	char *str = cmdbuf;
	char *argv[SHELL_SYS_MAXARGS + 1];	/* NULL terminated	*/
	int argc, inquotes;
	int repeatable = 1;
	int rc = 0;
 8001068:	2500      	movs	r5, #0
	/* Process separators and check for invalid
	 * repeatable commands
	 */

	debug_parser("[PROCESS_SEPARATORS] %s\n", cmd);
	while (*str) {
 800106a:	b353      	cbz	r3, 80010c2 <cli_simple_run_command+0x8a>
 800106c:	4604      	mov	r4, r0
 800106e:	2200      	movs	r2, #0
 8001070:	e004      	b.n	800107c <cli_simple_run_command+0x44>
		for (inquotes = 0, sep = str; *sep; sep++) {
			if ((*sep == '\'') &&
			    (*(sep - 1) != '\\'))
				inquotes = !inquotes;

			if (!inquotes &&
 8001072:	2b3b      	cmp	r3, #59	; 0x3b
 8001074:	d00f      	beq.n	8001096 <cli_simple_run_command+0x5e>
	while (*str) {
		/*
		 * Find separator, or string end
		 * Allow simple escape of ';' by writing "\;"
		 */
		for (inquotes = 0, sep = str; *sep; sep++) {
 8001076:	f814 3f01 	ldrb.w	r3, [r4, #1]!
 800107a:	b1a3      	cbz	r3, 80010a6 <cli_simple_run_command+0x6e>
			if ((*sep == '\'') &&
 800107c:	2b27      	cmp	r3, #39	; 0x27
 800107e:	d003      	beq.n	8001088 <cli_simple_run_command+0x50>
			    (*(sep - 1) != '\\'))
				inquotes = !inquotes;

			if (!inquotes &&
 8001080:	2a00      	cmp	r2, #0
 8001082:	d0f6      	beq.n	8001072 <cli_simple_run_command+0x3a>
 8001084:	2201      	movs	r2, #1
 8001086:	e7f6      	b.n	8001076 <cli_simple_run_command+0x3e>
		/*
		 * Find separator, or string end
		 * Allow simple escape of ';' by writing "\;"
		 */
		for (inquotes = 0, sep = str; *sep; sep++) {
			if ((*sep == '\'') &&
 8001088:	f814 3c01 	ldrb.w	r3, [r4, #-1]
 800108c:	2b5c      	cmp	r3, #92	; 0x5c
 800108e:	d0f2      	beq.n	8001076 <cli_simple_run_command+0x3e>
 8001090:	f082 0201 	eor.w	r2, r2, #1
 8001094:	e7ef      	b.n	8001076 <cli_simple_run_command+0x3e>
			    (*(sep - 1) != '\\'))
				inquotes = !inquotes;

			if (!inquotes &&
			    (*sep == ';') &&	/* separator		*/
 8001096:	42a0      	cmp	r0, r4
 8001098:	d0ed      	beq.n	8001076 <cli_simple_run_command+0x3e>
			    (sep != str) &&	/* past string start	*/
 800109a:	f814 3c01 	ldrb.w	r3, [r4, #-1]
 800109e:	2b5c      	cmp	r3, #92	; 0x5c
 80010a0:	d0e9      	beq.n	8001076 <cli_simple_run_command+0x3e>
		 * Limit the token to data between separators
		 */
		token = str;
		if (*sep) {
			str = sep + 1;	/* start of command for next pass */
			*sep = '\0';
 80010a2:	7022      	strb	r2, [r4, #0]
		/*
		 * Limit the token to data between separators
		 */
		token = str;
		if (*sep) {
			str = sep + 1;	/* start of command for next pass */
 80010a4:	3401      	adds	r4, #1
			str = sep;	/* no more commands for next pass */
		}
		debug_parser("token: \"%s\"\n", token);

		/* find macros in this token and replace them */
		cli_simple_process_macros(token, finaltoken);
 80010a6:	a913      	add	r1, sp, #76	; 0x4c
 80010a8:	f7ff ff3a 	bl	8000f20 <cli_simple_process_macros>

		/* Extract arguments */
		argc = cli_simple_parse_line(finaltoken, argv);
 80010ac:	a923      	add	r1, sp, #140	; 0x8c
 80010ae:	a813      	add	r0, sp, #76	; 0x4c
 80010b0:	f7ff ff02 	bl	8000eb8 <cli_simple_parse_line>
		if (argc == 0) {
 80010b4:	b948      	cbnz	r0, 80010ca <cli_simple_run_command+0x92>
			rc = -1;	/* no command at all */
 80010b6:	f04f 35ff 	mov.w	r5, #4294967295
 80010ba:	4620      	mov	r0, r4
	/* Process separators and check for invalid
	 * repeatable commands
	 */

	debug_parser("[PROCESS_SEPARATORS] %s\n", cmd);
	while (*str) {
 80010bc:	7803      	ldrb	r3, [r0, #0]
 80010be:	2b00      	cmp	r3, #0
 80010c0:	d1d4      	bne.n	800106c <cli_simple_run_command+0x34>
		/* Did the user stop this? */
		if (had_ctrlc())
			return -1;	/* if stopped then not repeatable */
	}

	return rc ? rc : repeatable;
 80010c2:	b995      	cbnz	r5, 80010ea <cli_simple_run_command+0xb2>
 80010c4:	9802      	ldr	r0, [sp, #8]
}
 80010c6:	b034      	add	sp, #208	; 0xd0
 80010c8:	bd70      	pop	{r4, r5, r6, pc}
		if (argc == 0) {
			rc = -1;	/* no command at all */
			continue;
		}

		if (cmd_process(flag, argc, argv, &repeatable, NULL))
 80010ca:	2300      	movs	r3, #0
 80010cc:	4601      	mov	r1, r0
 80010ce:	9300      	str	r3, [sp, #0]
 80010d0:	aa23      	add	r2, sp, #140	; 0x8c
 80010d2:	ab02      	add	r3, sp, #8
 80010d4:	4630      	mov	r0, r6
 80010d6:	f000 fa77 	bl	80015c8 <cmd_process>
			rc = -1;
 80010da:	2800      	cmp	r0, #0
 80010dc:	bf18      	it	ne
 80010de:	f04f 35ff 	movne.w	r5, #4294967295

		/* Did the user stop this? */
		if (had_ctrlc())
 80010e2:	f000 fb37 	bl	8001754 <had_ctrlc>
 80010e6:	2800      	cmp	r0, #0
 80010e8:	d0e7      	beq.n	80010ba <cli_simple_run_command+0x82>
	if (!cmd || !*cmd)
		return -1;	/* empty command */

	if (strlen(cmd) >= SHELL_SYS_CBSIZE) {
		puts("## Command too long!\n");
		return -1;
 80010ea:	f04f 30ff 	mov.w	r0, #4294967295
		if (had_ctrlc())
			return -1;	/* if stopped then not repeatable */
	}

	return rc ? rc : repeatable;
}
 80010ee:	b034      	add	sp, #208	; 0xd0
 80010f0:	bd70      	pop	{r4, r5, r6, pc}

	if (!cmd || !*cmd)
		return -1;	/* empty command */

	if (strlen(cmd) >= SHELL_SYS_CBSIZE) {
		puts("## Command too long!\n");
 80010f2:	4802      	ldr	r0, [pc, #8]	; (80010fc <cli_simple_run_command+0xc4>)
 80010f4:	f013 fef0 	bl	8014ed8 <puts>
 80010f8:	e7f7      	b.n	80010ea <cli_simple_run_command+0xb2>
 80010fa:	bf00      	nop
 80010fc:	0801628c 	.word	0x0801628c

08001100 <cli_simple_loop>:

	return rc ? rc : repeatable;
}

void cli_simple_loop(void)
{
 8001100:	b510      	push	{r4, lr}
	int flag;
	int rc = 1;

	/* assume no special flags for now */
	flag = 0;
	len = cli_readline(SHELL_SYS_PROMPT);
 8001102:	480f      	ldr	r0, [pc, #60]	; (8001140 <cli_simple_loop+0x40>)
 8001104:	f00c fd3c 	bl	800db80 <cli_readline>
	if (len > 0)
 8001108:	2800      	cmp	r0, #0
 800110a:	dd0e      	ble.n	800112a <cli_simple_loop+0x2a>
		strlcpy(lastcommand, console_buffer, SHELL_SYS_CBSIZE + 1);
 800110c:	490d      	ldr	r1, [pc, #52]	; (8001144 <cli_simple_loop+0x44>)
 800110e:	2241      	movs	r2, #65	; 0x41
 8001110:	480d      	ldr	r0, [pc, #52]	; (8001148 <cli_simple_loop+0x48>)
 8001112:	f013 fef1 	bl	8014ef8 <strlcpy>
	int len;
	int flag;
	int rc = 1;

	/* assume no special flags for now */
	flag = 0;
 8001116:	2100      	movs	r1, #0
		flag |= CMD_FLAG_REPEAT;

	if (len == -1)
		cputs("<INTERRUPT>\n");
	else
		rc = run_command_repeatable(lastcommand, flag);
 8001118:	4c0b      	ldr	r4, [pc, #44]	; (8001148 <cli_simple_loop+0x48>)
 800111a:	4620      	mov	r0, r4
 800111c:	f7ff fec6 	bl	8000eac <run_command_repeatable>

	if (rc <= 0) {
 8001120:	2800      	cmp	r0, #0
		/* invalid command or not repeatable, forget it */
		lastcommand[0] = 0;
 8001122:	bfdc      	itt	le
 8001124:	2300      	movle	r3, #0
 8001126:	7023      	strble	r3, [r4, #0]
 8001128:	bd10      	pop	{r4, pc}
	if (len > 0)
		strlcpy(lastcommand, console_buffer, SHELL_SYS_CBSIZE + 1);
	else if (len == 0)
		flag |= CMD_FLAG_REPEAT;

	if (len == -1)
 800112a:	1c43      	adds	r3, r0, #1
 800112c:	d104      	bne.n	8001138 <cli_simple_loop+0x38>

	if (rc <= 0) {
		/* invalid command or not repeatable, forget it */
		lastcommand[0] = 0;
	}
}
 800112e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		strlcpy(lastcommand, console_buffer, SHELL_SYS_CBSIZE + 1);
	else if (len == 0)
		flag |= CMD_FLAG_REPEAT;

	if (len == -1)
		cputs("<INTERRUPT>\n");
 8001132:	4806      	ldr	r0, [pc, #24]	; (800114c <cli_simple_loop+0x4c>)
 8001134:	f000 ba98 	b.w	8001668 <cputs>
	flag = 0;
	len = cli_readline(SHELL_SYS_PROMPT);
	if (len > 0)
		strlcpy(lastcommand, console_buffer, SHELL_SYS_CBSIZE + 1);
	else if (len == 0)
		flag |= CMD_FLAG_REPEAT;
 8001138:	fab0 f180 	clz	r1, r0
 800113c:	0949      	lsrs	r1, r1, #5
 800113e:	e7eb      	b.n	8001118 <cli_simple_loop+0x18>
 8001140:	080162a4 	.word	0x080162a4
 8001144:	2000f058 	.word	0x2000f058
 8001148:	20000364 	.word	0x20000364
 800114c:	080162b0 	.word	0x080162b0

08001150 <cli_simple_run_command_list>:
	 * Break into individual lines, and execute each line; terminate on
	 * error.
	 */
	next = cmd;
	line = cmd;
	while (*next) {
 8001150:	7801      	ldrb	r1, [r0, #0]
 8001152:	b301      	cbz	r1, 8001196 <cli_simple_run_command_list+0x46>
		lastcommand[0] = 0;
	}
}

int cli_simple_run_command_list(char *cmd, int flag)
{
 8001154:	b538      	push	{r3, r4, r5, lr}
 8001156:	1c44      	adds	r4, r0, #1
	 */
	next = cmd;
	line = cmd;
	while (*next) {
		if (*next == '\n') {
			*next = '\0';
 8001158:	2500      	movs	r5, #0
 800115a:	e002      	b.n	8001162 <cli_simple_run_command_list+0x12>
	 * Break into individual lines, and execute each line; terminate on
	 * error.
	 */
	next = cmd;
	line = cmd;
	while (*next) {
 800115c:	f814 1b01 	ldrb.w	r1, [r4], #1
 8001160:	b151      	cbz	r1, 8001178 <cli_simple_run_command_list+0x28>
		if (*next == '\n') {
 8001162:	290a      	cmp	r1, #10
 8001164:	d1fa      	bne.n	800115c <cli_simple_run_command_list+0xc>
			*next = '\0';
 8001166:	f804 5c01 	strb.w	r5, [r4, #-1]
			/* run only non-empty commands */
			if (*line) {
 800116a:	7803      	ldrb	r3, [r0, #0]
 800116c:	b943      	cbnz	r3, 8001180 <cli_simple_run_command_list+0x30>
		lastcommand[0] = 0;
	}
}

int cli_simple_run_command_list(char *cmd, int flag)
{
 800116e:	4620      	mov	r0, r4
	 * Break into individual lines, and execute each line; terminate on
	 * error.
	 */
	next = cmd;
	line = cmd;
	while (*next) {
 8001170:	f814 1b01 	ldrb.w	r1, [r4], #1
 8001174:	2900      	cmp	r1, #0
 8001176:	d1f4      	bne.n	8001162 <cli_simple_run_command_list+0x12>
			}
			line = next + 1;
		}
		++next;
	}
	if (rcode == 0 && *line)
 8001178:	7803      	ldrb	r3, [r0, #0]
 800117a:	b943      	cbnz	r3, 800118e <cli_simple_run_command_list+0x3e>
 800117c:	2000      	movs	r0, #0
 800117e:	bd38      	pop	{r3, r4, r5, pc}
	while (*next) {
		if (*next == '\n') {
			*next = '\0';
			/* run only non-empty commands */
			if (*line) {
				if (cli_simple_run_command(line, 0) < 0) {
 8001180:	2100      	movs	r1, #0
 8001182:	f7ff ff59 	bl	8001038 <cli_simple_run_command>
 8001186:	2800      	cmp	r0, #0
 8001188:	daf1      	bge.n	800116e <cli_simple_run_command_list+0x1e>
 800118a:	2001      	movs	r0, #1
		++next;
	}
	if (rcode == 0 && *line)
		rcode = (cli_simple_run_command(line, 0) < 0);

	return rcode;
 800118c:	bd38      	pop	{r3, r4, r5, pc}
			line = next + 1;
		}
		++next;
	}
	if (rcode == 0 && *line)
		rcode = (cli_simple_run_command(line, 0) < 0);
 800118e:	f7ff ff53 	bl	8001038 <cli_simple_run_command>
 8001192:	0fc0      	lsrs	r0, r0, #31
 8001194:	bd38      	pop	{r3, r4, r5, pc}
 8001196:	2000      	movs	r0, #0

	return rcode;
}
 8001198:	4770      	bx	lr
 800119a:	bf00      	nop

0800119c <show_memory>:
static int show_memory(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	unsigned int val;
	unsigned int *addr;
	
	if (argc != 2)
 800119c:	2a02      	cmp	r2, #2
 800119e:	d10f      	bne.n	80011c0 <show_memory+0x24>
#include "command.h"
#include "cmd_d.h"


static int show_memory(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
 80011a0:	b508      	push	{r3, lr}
	if (argc != 2)
	{
		return -1;
	}
	
	val = strtoul(argv[1], NULL, 16);
 80011a2:	6858      	ldr	r0, [r3, #4]
 80011a4:	2210      	movs	r2, #16
 80011a6:	2100      	movs	r1, #0
 80011a8:	f013 ff52 	bl	8015050 <strtoul>
 80011ac:	4601      	mov	r1, r0
	addr = (unsigned int *)val;
#if 1
	printf("0x%p 0x%08x\r\n", addr, *addr);
 80011ae:	4806      	ldr	r0, [pc, #24]	; (80011c8 <show_memory+0x2c>)
 80011b0:	680a      	ldr	r2, [r1, #0]
 80011b2:	f013 fde1 	bl	8014d78 <iprintf>
	printf("\r\n");
 80011b6:	4805      	ldr	r0, [pc, #20]	; (80011cc <show_memory+0x30>)
 80011b8:	f013 fdde 	bl	8014d78 <iprintf>
#else
	printf("0x%p 0x%08x\n", addr, *addr);
#endif
	return 0;
 80011bc:	2000      	movs	r0, #0
 80011be:	bd08      	pop	{r3, pc}
	unsigned int val;
	unsigned int *addr;
	
	if (argc != 2)
	{
		return -1;
 80011c0:	f04f 30ff 	mov.w	r0, #4294967295
 80011c4:	4770      	bx	lr
 80011c6:	bf00      	nop
 80011c8:	080162c0 	.word	0x080162c0
 80011cc:	080164ec 	.word	0x080164ec

080011d0 <cmd_d_init>:
#endif
	return 0;
}

int cmd_d_init(void)
{
 80011d0:	b500      	push	{lr}
	int ret;
	
	ret = cmd_register(
 80011d2:	4a07      	ldr	r2, [pc, #28]	; (80011f0 <cmd_d_init+0x20>)
 80011d4:	4b07      	ldr	r3, [pc, #28]	; (80011f4 <cmd_d_init+0x24>)
#endif
	return 0;
}

int cmd_d_init(void)
{
 80011d6:	b083      	sub	sp, #12
	int ret;
	
	ret = cmd_register(
 80011d8:	9201      	str	r2, [sp, #4]
 80011da:	9300      	str	r3, [sp, #0]
 80011dc:	2200      	movs	r2, #0
 80011de:	4b06      	ldr	r3, [pc, #24]	; (80011f8 <cmd_d_init+0x28>)
 80011e0:	2110      	movs	r1, #16
 80011e2:	4806      	ldr	r0, [pc, #24]	; (80011fc <cmd_d_init+0x2c>)
 80011e4:	f000 f8e0 	bl	80013a8 <cmd_register>
		"addr [arg ...]\n	 - start application at address 'addr'\n"
		"	   passing 'arg' as arguments"
	);

	return ret;
}
 80011e8:	b003      	add	sp, #12
 80011ea:	f85d fb04 	ldr.w	pc, [sp], #4
 80011ee:	bf00      	nop
 80011f0:	080162d0 	.word	0x080162d0
 80011f4:	08016328 	.word	0x08016328
 80011f8:	0800119d 	.word	0x0800119d
 80011fc:	0801783c 	.word	0x0801783c

08001200 <do_help>:
#include "command.h"
#include "cmd_help.h"


static int do_help(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
 8001200:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001204:	b082      	sub	sp, #8
 8001206:	460e      	mov	r6, r1
 8001208:	4617      	mov	r7, r2
 800120a:	4698      	mov	r8, r3
 800120c:	4605      	mov	r5, r0
	cmd_tbl_t *start = cmd_entry_start();
 800120e:	f000 f8c5 	bl	800139c <cmd_entry_start>
 8001212:	4604      	mov	r4, r0
	int len = cmd_entry_count();
 8001214:	f000 f8c6 	bl	80013a4 <cmd_entry_count>
	
	return _do_help(start, len, cmdtp, flag, argc, argv);
 8001218:	f8cd 8004 	str.w	r8, [sp, #4]
 800121c:	4601      	mov	r1, r0
 800121e:	9700      	str	r7, [sp, #0]
 8001220:	4633      	mov	r3, r6
 8001222:	462a      	mov	r2, r5
 8001224:	4620      	mov	r0, r4
 8001226:	f000 f93b 	bl	80014a0 <_do_help>
}
 800122a:	b002      	add	sp, #8
 800122c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08001230 <cmd_help_init>:

int cmd_help_init(void)
{
 8001230:	b510      	push	{r4, lr}
	int ret;
	
	ret = cmd_register(
 8001232:	490c      	ldr	r1, [pc, #48]	; (8001264 <cmd_help_init+0x34>)
 8001234:	4c0c      	ldr	r4, [pc, #48]	; (8001268 <cmd_help_init+0x38>)
 8001236:	4a0d      	ldr	r2, [pc, #52]	; (800126c <cmd_help_init+0x3c>)
	
	return _do_help(start, len, cmdtp, flag, argc, argv);
}

int cmd_help_init(void)
{
 8001238:	b082      	sub	sp, #8
	int ret;
	
	ret = cmd_register(
 800123a:	4623      	mov	r3, r4
 800123c:	9101      	str	r1, [sp, #4]
 800123e:	9200      	str	r2, [sp, #0]
 8001240:	2110      	movs	r1, #16
 8001242:	2200      	movs	r2, #0
 8001244:	480a      	ldr	r0, [pc, #40]	; (8001270 <cmd_help_init+0x40>)
 8001246:	f000 f8af 	bl	80013a8 <cmd_register>
		"	- print brief description of all commands\n"
		"help command ...\n"
		"	- print detailed usage of 'command'"
	);

	ret = cmd_register(
 800124a:	490a      	ldr	r1, [pc, #40]	; (8001274 <cmd_help_init+0x44>)
 800124c:	4a0a      	ldr	r2, [pc, #40]	; (8001278 <cmd_help_init+0x48>)
 800124e:	9101      	str	r1, [sp, #4]
 8001250:	9200      	str	r2, [sp, #0]
 8001252:	4623      	mov	r3, r4
 8001254:	2200      	movs	r2, #0
 8001256:	2110      	movs	r1, #16
 8001258:	4808      	ldr	r0, [pc, #32]	; (800127c <cmd_help_init+0x4c>)
 800125a:	f000 f8a5 	bl	80013a8 <cmd_register>
		"alias for 'help'",
		""
	);

	return ret;
 800125e:	b002      	add	sp, #8
 8001260:	bd10      	pop	{r4, pc}
 8001262:	bf00      	nop
 8001264:	08016354 	.word	0x08016354
 8001268:	08001201 	.word	0x08001201
 800126c:	080163b8 	.word	0x080163b8
 8001270:	0801634c 	.word	0x0801634c
 8001274:	08016544 	.word	0x08016544
 8001278:	080163dc 	.word	0x080163dc
 800127c:	080163d8 	.word	0x080163d8

08001280 <modify_memory>:
static int modify_memory(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	unsigned int val;
	unsigned int *addr;
	
	if (argc != 3)
 8001280:	2a03      	cmp	r2, #3
#include "command.h"
#include "cmd_m.h"


static int modify_memory(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
 8001282:	b538      	push	{r3, r4, r5, lr}
	unsigned int val;
	unsigned int *addr;
	
	if (argc != 3)
 8001284:	d10f      	bne.n	80012a6 <modify_memory+0x26>
	{
		return -1;
	}
	
	val = strtoul(argv[1], NULL, 16);
 8001286:	6858      	ldr	r0, [r3, #4]
 8001288:	2210      	movs	r2, #16
 800128a:	2100      	movs	r1, #0
 800128c:	461c      	mov	r4, r3
 800128e:	f013 fedf 	bl	8015050 <strtoul>
	addr = (unsigned int *)val;
	val = strtoul(argv[2], NULL, 16);
 8001292:	2210      	movs	r2, #16
	if (argc != 3)
	{
		return -1;
	}
	
	val = strtoul(argv[1], NULL, 16);
 8001294:	4605      	mov	r5, r0
	addr = (unsigned int *)val;
	val = strtoul(argv[2], NULL, 16);
 8001296:	2100      	movs	r1, #0
 8001298:	68a0      	ldr	r0, [r4, #8]
 800129a:	f013 fed9 	bl	8015050 <strtoul>
	*addr = val;

	return 0;
 800129e:	2300      	movs	r3, #0
	}
	
	val = strtoul(argv[1], NULL, 16);
	addr = (unsigned int *)val;
	val = strtoul(argv[2], NULL, 16);
	*addr = val;
 80012a0:	6028      	str	r0, [r5, #0]

	return 0;
}
 80012a2:	4618      	mov	r0, r3
 80012a4:	bd38      	pop	{r3, r4, r5, pc}
	unsigned int val;
	unsigned int *addr;
	
	if (argc != 3)
	{
		return -1;
 80012a6:	f04f 33ff 	mov.w	r3, #4294967295
	addr = (unsigned int *)val;
	val = strtoul(argv[2], NULL, 16);
	*addr = val;

	return 0;
}
 80012aa:	4618      	mov	r0, r3
 80012ac:	bd38      	pop	{r3, r4, r5, pc}
 80012ae:	bf00      	nop

080012b0 <cmd_m_init>:

int cmd_m_init(void)
{
 80012b0:	b500      	push	{lr}
	int ret;
	
	ret = cmd_register(
 80012b2:	4a07      	ldr	r2, [pc, #28]	; (80012d0 <cmd_m_init+0x20>)
 80012b4:	4b07      	ldr	r3, [pc, #28]	; (80012d4 <cmd_m_init+0x24>)

	return 0;
}

int cmd_m_init(void)
{
 80012b6:	b083      	sub	sp, #12
	int ret;
	
	ret = cmd_register(
 80012b8:	9201      	str	r2, [sp, #4]
 80012ba:	9300      	str	r3, [sp, #0]
 80012bc:	2200      	movs	r2, #0
 80012be:	4b06      	ldr	r3, [pc, #24]	; (80012d8 <cmd_m_init+0x28>)
 80012c0:	2110      	movs	r1, #16
 80012c2:	4806      	ldr	r0, [pc, #24]	; (80012dc <cmd_m_init+0x2c>)
 80012c4:	f000 f870 	bl	80013a8 <cmd_register>
		"addr [arg ...]\n	 - start application at address 'addr'\n"
		"	   passing 'arg' as arguments"
	);

	return ret;
}
 80012c8:	b003      	add	sp, #12
 80012ca:	f85d fb04 	ldr.w	pc, [sp], #4
 80012ce:	bf00      	nop
 80012d0:	080162d0 	.word	0x080162d0
 80012d4:	08016328 	.word	0x08016328
 80012d8:	08001281 	.word	0x08001281
 80012dc:	080163f0 	.word	0x080163f0

080012e0 <do_reset>:
#include "command.h"
#include "cmd_reset.h"


int do_reset(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
 80012e0:	b508      	push	{r3, lr}
	printf("Resetting the board...\n");
 80012e2:	4803      	ldr	r0, [pc, #12]	; (80012f0 <do_reset+0x10>)
 80012e4:	f013 fd48 	bl	8014d78 <iprintf>

	BSP_SoftReset();
 80012e8:	f7ff fc1e 	bl	8000b28 <BSP_SoftReset>

	/*NOTREACHED*/
	return 0;
}
 80012ec:	2000      	movs	r0, #0
 80012ee:	bd08      	pop	{r3, pc}
 80012f0:	080163f4 	.word	0x080163f4

080012f4 <cmd_reset_init>:

int cmd_reset_init(void)
{
 80012f4:	b500      	push	{lr}
	int ret;
	
	ret = cmd_register(
 80012f6:	4a07      	ldr	r2, [pc, #28]	; (8001314 <cmd_reset_init+0x20>)
 80012f8:	4b07      	ldr	r3, [pc, #28]	; (8001318 <cmd_reset_init+0x24>)
	/*NOTREACHED*/
	return 0;
}

int cmd_reset_init(void)
{
 80012fa:	b083      	sub	sp, #12
	int ret;
	
	ret = cmd_register(
 80012fc:	9201      	str	r2, [sp, #4]
 80012fe:	9300      	str	r3, [sp, #0]
 8001300:	2200      	movs	r2, #0
 8001302:	4b06      	ldr	r3, [pc, #24]	; (800131c <cmd_reset_init+0x28>)
 8001304:	2101      	movs	r1, #1
 8001306:	4806      	ldr	r0, [pc, #24]	; (8001320 <cmd_reset_init+0x2c>)
 8001308:	f000 f84e 	bl	80013a8 <cmd_register>
		"Perform RESET of the CPU",
		""
	);
	
	return ret;
}
 800130c:	b003      	add	sp, #12
 800130e:	f85d fb04 	ldr.w	pc, [sp], #4
 8001312:	bf00      	nop
 8001314:	08016544 	.word	0x08016544
 8001318:	08016414 	.word	0x08016414
 800131c:	080012e1 	.word	0x080012e1
 8001320:	0801640c 	.word	0x0801640c

08001324 <show_version>:
#include "command.h"
#include "cmd_ver.h"


static int show_version(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
 8001324:	b508      	push	{r3, lr}
#if 1
	printf("Hardware version:  %s\r\n", "\tVer.A");
 8001326:	4909      	ldr	r1, [pc, #36]	; (800134c <show_version+0x28>)
 8001328:	4809      	ldr	r0, [pc, #36]	; (8001350 <show_version+0x2c>)
 800132a:	f013 fd25 	bl	8014d78 <iprintf>
	printf("Software version: %s\r\n", "\t1.0.0.0");
 800132e:	4909      	ldr	r1, [pc, #36]	; (8001354 <show_version+0x30>)
 8001330:	4809      	ldr	r0, [pc, #36]	; (8001358 <show_version+0x34>)
 8001332:	f013 fd21 	bl	8014d78 <iprintf>
	printf("build time:\t\t%s %s\r\n", __DATE__, __TIME__);
 8001336:	4a09      	ldr	r2, [pc, #36]	; (800135c <show_version+0x38>)
 8001338:	4909      	ldr	r1, [pc, #36]	; (8001360 <show_version+0x3c>)
 800133a:	480a      	ldr	r0, [pc, #40]	; (8001364 <show_version+0x40>)
 800133c:	f013 fd1c 	bl	8014d78 <iprintf>
	printf("\r\n");
 8001340:	4809      	ldr	r0, [pc, #36]	; (8001368 <show_version+0x44>)
 8001342:	f013 fd19 	bl	8014d78 <iprintf>
	printf("Hardware version:  %s\n", "\tVer.A");
	printf("Software version: %s\n", "\t1.0.0.0");
	printf("build time:\t\t%s %s\n", __DATE__, __TIME__);
#endif
	return 0;
}
 8001346:	2000      	movs	r0, #0
 8001348:	bd08      	pop	{r3, pc}
 800134a:	bf00      	nop
 800134c:	08016430 	.word	0x08016430
 8001350:	08016438 	.word	0x08016438
 8001354:	08016450 	.word	0x08016450
 8001358:	0801645c 	.word	0x0801645c
 800135c:	08016474 	.word	0x08016474
 8001360:	08016480 	.word	0x08016480
 8001364:	0801648c 	.word	0x0801648c
 8001368:	080164ec 	.word	0x080164ec

0800136c <cmd_ver_init>:

int cmd_ver_init(void)
{
 800136c:	b500      	push	{lr}
	int ret;
	
	ret = cmd_register(
 800136e:	4a07      	ldr	r2, [pc, #28]	; (800138c <cmd_ver_init+0x20>)
 8001370:	4b07      	ldr	r3, [pc, #28]	; (8001390 <cmd_ver_init+0x24>)
#endif
	return 0;
}

int cmd_ver_init(void)
{
 8001372:	b083      	sub	sp, #12
	int ret;
	
	ret = cmd_register(
 8001374:	9201      	str	r2, [sp, #4]
 8001376:	9300      	str	r3, [sp, #0]
 8001378:	2200      	movs	r2, #0
 800137a:	4b06      	ldr	r3, [pc, #24]	; (8001394 <cmd_ver_init+0x28>)
 800137c:	2110      	movs	r1, #16
 800137e:	4806      	ldr	r0, [pc, #24]	; (8001398 <cmd_ver_init+0x2c>)
 8001380:	f000 f812 	bl	80013a8 <cmd_register>
		"addr [arg ...]\n	 - start application at address 'addr'\n"
		"	   passing 'arg' as arguments"
	);

	return ret;
}
 8001384:	b003      	add	sp, #12
 8001386:	f85d fb04 	ldr.w	pc, [sp], #4
 800138a:	bf00      	nop
 800138c:	080162d0 	.word	0x080162d0
 8001390:	08016328 	.word	0x08016328
 8001394:	08001325 	.word	0x08001325
 8001398:	080164a4 	.word	0x080164a4

0800139c <cmd_entry_start>:
cmd_tbl_t cmd_tbl[MAX_CMD_LINE] = {0};

cmd_tbl_t *cmd_entry_start(void)
{
	return &cmd_tbl[0];
}
 800139c:	4800      	ldr	r0, [pc, #0]	; (80013a0 <cmd_entry_start+0x4>)
 800139e:	4770      	bx	lr
 80013a0:	200003a8 	.word	0x200003a8

080013a4 <cmd_entry_count>:

int cmd_entry_count(void)
{
	return MAX_CMD_LINE;
}
 80013a4:	2020      	movs	r0, #32
 80013a6:	4770      	bx	lr

080013a8 <cmd_register>:

int cmd_register(char *name, int maxargs, int repeatable, 
	int (*cmd)(struct cmd_tbl_s *, int, int, char * const []), char *usage, char *help)
{
 80013a8:	b4f0      	push	{r4, r5, r6, r7}
	if (cmd_index >= MAX_CMD_LINE)
 80013aa:	4e0d      	ldr	r6, [pc, #52]	; (80013e0 <cmd_register+0x38>)
 80013ac:	f8b6 4380 	ldrh.w	r4, [r6, #896]	; 0x380
 80013b0:	2c1f      	cmp	r4, #31
 80013b2:	d812      	bhi.n	80013da <cmd_register+0x32>
	{
		return CMD_REGISTER_FAIL;
	}
	
	cmd_tbl[cmd_index].name = name;
 80013b4:	ebc4 07c4 	rsb	r7, r4, r4, lsl #3
 80013b8:	00bf      	lsls	r7, r7, #2
 80013ba:	19f5      	adds	r5, r6, r7
	cmd_tbl[cmd_index].maxargs = maxargs;
	cmd_tbl[cmd_index].repeatable = repeatable;
	cmd_tbl[cmd_index].cmd = cmd;
 80013bc:	60eb      	str	r3, [r5, #12]
	cmd_tbl[cmd_index].usage = usage;
 80013be:	9b04      	ldr	r3, [sp, #16]
	cmd_tbl[cmd_index].help = help;
	cmd_tbl[cmd_index].complete = NULL;

	cmd_index++;
 80013c0:	3401      	adds	r4, #1
	
	cmd_tbl[cmd_index].name = name;
	cmd_tbl[cmd_index].maxargs = maxargs;
	cmd_tbl[cmd_index].repeatable = repeatable;
	cmd_tbl[cmd_index].cmd = cmd;
	cmd_tbl[cmd_index].usage = usage;
 80013c2:	612b      	str	r3, [r5, #16]
	cmd_tbl[cmd_index].help = help;
 80013c4:	9b05      	ldr	r3, [sp, #20]
	if (cmd_index >= MAX_CMD_LINE)
	{
		return CMD_REGISTER_FAIL;
	}
	
	cmd_tbl[cmd_index].name = name;
 80013c6:	51f0      	str	r0, [r6, r7]
	cmd_tbl[cmd_index].maxargs = maxargs;
	cmd_tbl[cmd_index].repeatable = repeatable;
	cmd_tbl[cmd_index].cmd = cmd;
	cmd_tbl[cmd_index].usage = usage;
	cmd_tbl[cmd_index].help = help;
	cmd_tbl[cmd_index].complete = NULL;
 80013c8:	2000      	movs	r0, #0
	{
		return CMD_REGISTER_FAIL;
	}
	
	cmd_tbl[cmd_index].name = name;
	cmd_tbl[cmd_index].maxargs = maxargs;
 80013ca:	6069      	str	r1, [r5, #4]
	cmd_tbl[cmd_index].repeatable = repeatable;
 80013cc:	60aa      	str	r2, [r5, #8]
	cmd_tbl[cmd_index].cmd = cmd;
	cmd_tbl[cmd_index].usage = usage;
	cmd_tbl[cmd_index].help = help;
 80013ce:	616b      	str	r3, [r5, #20]
	cmd_tbl[cmd_index].complete = NULL;

	cmd_index++;
 80013d0:	f8a6 4380 	strh.w	r4, [r6, #896]	; 0x380
	cmd_tbl[cmd_index].maxargs = maxargs;
	cmd_tbl[cmd_index].repeatable = repeatable;
	cmd_tbl[cmd_index].cmd = cmd;
	cmd_tbl[cmd_index].usage = usage;
	cmd_tbl[cmd_index].help = help;
	cmd_tbl[cmd_index].complete = NULL;
 80013d4:	61a8      	str	r0, [r5, #24]

	cmd_index++;
	return CMD_REGISTER_OK;
}
 80013d6:	bcf0      	pop	{r4, r5, r6, r7}
 80013d8:	4770      	bx	lr
int cmd_register(char *name, int maxargs, int repeatable, 
	int (*cmd)(struct cmd_tbl_s *, int, int, char * const []), char *usage, char *help)
{
	if (cmd_index >= MAX_CMD_LINE)
	{
		return CMD_REGISTER_FAIL;
 80013da:	f04f 30ff 	mov.w	r0, #4294967295
 80013de:	e7fa      	b.n	80013d6 <cmd_register+0x2e>
 80013e0:	200003a8 	.word	0x200003a8

080013e4 <find_cmd_tbl>:
	cmd_tbl_t *cmdtp_temp = table;	/* Init value */
	const char *p;
	int len;
	int n_found = 0;

	if (!cmd)
 80013e4:	b390      	cbz	r0, 800144c <find_cmd_tbl+0x68>
	return rcode;
}

/* find command table entry for a command */
cmd_tbl_t *find_cmd_tbl(const char *cmd, cmd_tbl_t *table, int table_len)
{
 80013e6:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80013ea:	4615      	mov	r5, r2
 80013ec:	4688      	mov	r8, r1
 80013ee:	4607      	mov	r7, r0
	int n_found = 0;

	if (!cmd)
		return NULL;

	len = strlen (cmd);
 80013f0:	f013 fc0a 	bl	8014c08 <strlen>

	for (cmdtp = table; cmdtp != table + table_len; cmdtp++) {
 80013f4:	ebc5 05c5 	rsb	r5, r5, r5, lsl #3
 80013f8:	eb08 0585 	add.w	r5, r8, r5, lsl #2
 80013fc:	45a8      	cmp	r8, r5
	int n_found = 0;

	if (!cmd)
		return NULL;

	len = strlen (cmd);
 80013fe:	4606      	mov	r6, r0

	for (cmdtp = table; cmdtp != table + table_len; cmdtp++) {
 8001400:	d021      	beq.n	8001446 <find_cmd_tbl+0x62>
 8001402:	4644      	mov	r4, r8
 8001404:	f04f 0900 	mov.w	r9, #0
 8001408:	e002      	b.n	8001410 <find_cmd_tbl+0x2c>
 800140a:	341c      	adds	r4, #28
 800140c:	42ac      	cmp	r4, r5
 800140e:	d011      	beq.n	8001434 <find_cmd_tbl+0x50>
		if (strncmp(cmd, cmdtp->name, len) == 0) {
 8001410:	4632      	mov	r2, r6
 8001412:	6821      	ldr	r1, [r4, #0]
 8001414:	4638      	mov	r0, r7
 8001416:	f013 fd84 	bl	8014f22 <strncmp>
 800141a:	2800      	cmp	r0, #0
 800141c:	d1f5      	bne.n	800140a <find_cmd_tbl+0x26>
			if (len == strlen(cmdtp->name))
 800141e:	6820      	ldr	r0, [r4, #0]
 8001420:	f013 fbf2 	bl	8014c08 <strlen>
 8001424:	4286      	cmp	r6, r0
 8001426:	d00b      	beq.n	8001440 <find_cmd_tbl+0x5c>
				return cmdtp;	/* full match */

			cmdtp_temp = cmdtp;	/* abbreviated command ? */
			n_found++;
 8001428:	46a0      	mov	r8, r4
	if (!cmd)
		return NULL;

	len = strlen (cmd);

	for (cmdtp = table; cmdtp != table + table_len; cmdtp++) {
 800142a:	341c      	adds	r4, #28
 800142c:	42ac      	cmp	r4, r5
		if (strncmp(cmd, cmdtp->name, len) == 0) {
			if (len == strlen(cmdtp->name))
				return cmdtp;	/* full match */

			cmdtp_temp = cmdtp;	/* abbreviated command ? */
			n_found++;
 800142e:	f109 0901 	add.w	r9, r9, #1
	if (!cmd)
		return NULL;

	len = strlen (cmd);

	for (cmdtp = table; cmdtp != table + table_len; cmdtp++) {
 8001432:	d1ed      	bne.n	8001410 <find_cmd_tbl+0x2c>

			cmdtp_temp = cmdtp;	/* abbreviated command ? */
			n_found++;
		}
	}
	if (n_found == 1) {			/* exactly one match */
 8001434:	f1b9 0f01 	cmp.w	r9, #1
 8001438:	d105      	bne.n	8001446 <find_cmd_tbl+0x62>
 800143a:	4640      	mov	r0, r8
 800143c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8001440:	4620      	mov	r0, r4
		return cmdtp_temp;
	}

	return NULL;	/* not found or ambiguous command */
}
 8001442:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	const char *p;
	int len;
	int n_found = 0;

	if (!cmd)
		return NULL;
 8001446:	2000      	movs	r0, #0
 8001448:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800144c:	2000      	movs	r0, #0
	if (n_found == 1) {			/* exactly one match */
		return cmdtp_temp;
	}

	return NULL;	/* not found or ambiguous command */
}
 800144e:	4770      	bx	lr

08001450 <find_cmd>:

cmd_tbl_t *find_cmd(const char *cmd)
{
	return find_cmd_tbl(cmd, cmd_tbl, MAX_CMD_LINE);
 8001450:	2220      	movs	r2, #32
 8001452:	4901      	ldr	r1, [pc, #4]	; (8001458 <find_cmd+0x8>)
 8001454:	f7ff bfc6 	b.w	80013e4 <find_cmd_tbl>
 8001458:	200003a8 	.word	0x200003a8

0800145c <cmd_usage>:
}

int cmd_usage(const cmd_tbl_t *cmdtp)
{
 800145c:	b510      	push	{r4, lr}
 800145e:	4604      	mov	r4, r0
	printf("%s - %s\r\n", cmdtp->name, cmdtp->usage);
 8001460:	480b      	ldr	r0, [pc, #44]	; (8001490 <cmd_usage+0x34>)
 8001462:	6922      	ldr	r2, [r4, #16]
 8001464:	6821      	ldr	r1, [r4, #0]
 8001466:	f013 fc87 	bl	8014d78 <iprintf>

	printf("Usage:\r\n%s ", cmdtp->name);
 800146a:	6821      	ldr	r1, [r4, #0]
 800146c:	4809      	ldr	r0, [pc, #36]	; (8001494 <cmd_usage+0x38>)
 800146e:	f013 fc83 	bl	8014d78 <iprintf>

	if (!cmdtp->help) {
 8001472:	6960      	ldr	r0, [r4, #20]
 8001474:	b130      	cbz	r0, 8001484 <cmd_usage+0x28>
		puts ("- No additional help available.\r\n");
		return 1;
	}

	puts(cmdtp->help);
 8001476:	f013 fd2f 	bl	8014ed8 <puts>
	puts("\r\n");
 800147a:	4807      	ldr	r0, [pc, #28]	; (8001498 <cmd_usage+0x3c>)
 800147c:	f013 fd2c 	bl	8014ed8 <puts>

	return 1;
}
 8001480:	2001      	movs	r0, #1
 8001482:	bd10      	pop	{r4, pc}
	printf("%s - %s\r\n", cmdtp->name, cmdtp->usage);

	printf("Usage:\r\n%s ", cmdtp->name);

	if (!cmdtp->help) {
		puts ("- No additional help available.\r\n");
 8001484:	4805      	ldr	r0, [pc, #20]	; (800149c <cmd_usage+0x40>)
 8001486:	f013 fd27 	bl	8014ed8 <puts>

	puts(cmdtp->help);
	puts("\r\n");

	return 1;
}
 800148a:	2001      	movs	r0, #1
 800148c:	bd10      	pop	{r4, pc}
 800148e:	bf00      	nop
 8001490:	080164a8 	.word	0x080164a8
 8001494:	080164b4 	.word	0x080164b4
 8001498:	080164ec 	.word	0x080164ec
 800149c:	080164c0 	.word	0x080164c0

080014a0 <_do_help>:
 * for long help messages
 */

int _do_help(cmd_tbl_t *cmd_start, int cmd_items, cmd_tbl_t *cmdtp, int flag,
	     int argc, char * const argv[])
{
 80014a0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80014a4:	f8dd 9020 	ldr.w	r9, [sp, #32]
 80014a8:	4605      	mov	r5, r0
	int i, swaps;
	int rcode = 0;
	cmd_tbl_t *tmp = NULL;
	char *usage = NULL;

	if (argc == 1) {	/* show list of commands */
 80014aa:	f1b9 0f01 	cmp.w	r9, #1
 * for long help messages
 */

int _do_help(cmd_tbl_t *cmd_start, int cmd_items, cmd_tbl_t *cmdtp, int flag,
	     int argc, char * const argv[])
{
 80014ae:	4688      	mov	r8, r1
	int i, swaps;
	int rcode = 0;
	cmd_tbl_t *tmp = NULL;
	char *usage = NULL;

	if (argc == 1) {	/* show list of commands */
 80014b0:	d01f      	beq.n	80014f2 <_do_help+0x52>
		return 0;
	}
	/*
	 * command help (long version)
	 */
	for (i = 1; i < argc; ++i) {
 80014b2:	dd39      	ble.n	8001528 <_do_help+0x88>
 80014b4:	9e09      	ldr	r6, [sp, #36]	; 0x24
 80014b6:	2700      	movs	r7, #0
 80014b8:	2401      	movs	r4, #1
 80014ba:	e006      	b.n	80014ca <_do_help+0x2a>
		cmdtp = find_cmd_tbl(argv[i], cmd_start, cmd_items);
		if (cmdtp != NULL) {
			rcode |= cmd_usage(cmdtp);
 80014bc:	f7ff ffce 	bl	800145c <cmd_usage>
		return 0;
	}
	/*
	 * command help (long version)
	 */
	for (i = 1; i < argc; ++i) {
 80014c0:	3401      	adds	r4, #1
 80014c2:	45a1      	cmp	r9, r4
		cmdtp = find_cmd_tbl(argv[i], cmd_start, cmd_items);
		if (cmdtp != NULL) {
			rcode |= cmd_usage(cmdtp);
 80014c4:	ea47 0700 	orr.w	r7, r7, r0
		return 0;
	}
	/*
	 * command help (long version)
	 */
	for (i = 1; i < argc; ++i) {
 80014c8:	d010      	beq.n	80014ec <_do_help+0x4c>
		cmdtp = find_cmd_tbl(argv[i], cmd_start, cmd_items);
 80014ca:	4642      	mov	r2, r8
 80014cc:	4629      	mov	r1, r5
 80014ce:	f856 0f04 	ldr.w	r0, [r6, #4]!
 80014d2:	f7ff ff87 	bl	80013e4 <find_cmd_tbl>
		if (cmdtp != NULL) {
 80014d6:	2800      	cmp	r0, #0
 80014d8:	d1f0      	bne.n	80014bc <_do_help+0x1c>
			rcode |= cmd_usage(cmdtp);
		} else {
			printf("Unknown command '%s' - try 'help' without arguments for list of all known commands\n\n",
 80014da:	6831      	ldr	r1, [r6, #0]
 80014dc:	4814      	ldr	r0, [pc, #80]	; (8001530 <_do_help+0x90>)
		return 0;
	}
	/*
	 * command help (long version)
	 */
	for (i = 1; i < argc; ++i) {
 80014de:	3401      	adds	r4, #1
		cmdtp = find_cmd_tbl(argv[i], cmd_start, cmd_items);
		if (cmdtp != NULL) {
			rcode |= cmd_usage(cmdtp);
		} else {
			printf("Unknown command '%s' - try 'help' without arguments for list of all known commands\n\n",
 80014e0:	f013 fc4a 	bl	8014d78 <iprintf>
		return 0;
	}
	/*
	 * command help (long version)
	 */
	for (i = 1; i < argc; ++i) {
 80014e4:	45a1      	cmp	r9, r4
		if (cmdtp != NULL) {
			rcode |= cmd_usage(cmdtp);
		} else {
			printf("Unknown command '%s' - try 'help' without arguments for list of all known commands\n\n",
			       argv[i]);
			rcode = 1;
 80014e6:	f04f 0701 	mov.w	r7, #1
		return 0;
	}
	/*
	 * command help (long version)
	 */
	for (i = 1; i < argc; ++i) {
 80014ea:	d1ee      	bne.n	80014ca <_do_help+0x2a>
 80014ec:	4638      	mov	r0, r7
 80014ee:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	cmd_tbl_t *tmp = NULL;
	char *usage = NULL;

	if (argc == 1) {	/* show list of commands */
		/* print short help (usage) */
		for (i = 0; i < cmd_items; i++) {
 80014f2:	2900      	cmp	r1, #0
 80014f4:	dd18      	ble.n	8001528 <_do_help+0x88>
 80014f6:	f100 0410 	add.w	r4, r0, #16
 80014fa:	2500      	movs	r5, #0
 80014fc:	e00a      	b.n	8001514 <_do_help+0x74>
			/* allow user abort */
			if (ctrlc())
				return 1;
			if (usage == NULL)
				continue;
			printf("%-*s- %s\r\n", CONFIG_SYS_HELP_CMD_WIDTH,
 80014fe:	480d      	ldr	r0, [pc, #52]	; (8001534 <_do_help+0x94>)
			usage = tmp->usage;

			/* allow user abort */
			if (ctrlc())
				return 1;
			if (usage == NULL)
 8001500:	b126      	cbz	r6, 800150c <_do_help+0x6c>
				continue;
			printf("%-*s- %s\r\n", CONFIG_SYS_HELP_CMD_WIDTH,
 8001502:	4633      	mov	r3, r6
 8001504:	f854 2c10 	ldr.w	r2, [r4, #-16]
 8001508:	f013 fc36 	bl	8014d78 <iprintf>
	cmd_tbl_t *tmp = NULL;
	char *usage = NULL;

	if (argc == 1) {	/* show list of commands */
		/* print short help (usage) */
		for (i = 0; i < cmd_items; i++) {
 800150c:	45a8      	cmp	r8, r5
 800150e:	f104 041c 	add.w	r4, r4, #28
 8001512:	d009      	beq.n	8001528 <_do_help+0x88>
			tmp = &cmd_start[i];
			usage = tmp->usage;
 8001514:	6826      	ldr	r6, [r4, #0]

			/* allow user abort */
			if (ctrlc())
 8001516:	f000 f8b1 	bl	800167c <ctrlc>
	cmd_tbl_t *tmp = NULL;
	char *usage = NULL;

	if (argc == 1) {	/* show list of commands */
		/* print short help (usage) */
		for (i = 0; i < cmd_items; i++) {
 800151a:	3501      	adds	r5, #1
			/* allow user abort */
			if (ctrlc())
				return 1;
			if (usage == NULL)
				continue;
			printf("%-*s- %s\r\n", CONFIG_SYS_HELP_CMD_WIDTH,
 800151c:	2108      	movs	r1, #8
		for (i = 0; i < cmd_items; i++) {
			tmp = &cmd_start[i];
			usage = tmp->usage;

			/* allow user abort */
			if (ctrlc())
 800151e:	2800      	cmp	r0, #0
 8001520:	d0ed      	beq.n	80014fe <_do_help+0x5e>
				return 1;
 8001522:	2001      	movs	r0, #1
			       argv[i]);
			rcode = 1;
		}
	}
	return rcode;
}
 8001524:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			tmp = &cmd_start[i];
			usage = tmp->usage;

			/* allow user abort */
			if (ctrlc())
				return 1;
 8001528:	2000      	movs	r0, #0
 800152a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800152e:	bf00      	nop
 8001530:	080164f0 	.word	0x080164f0
 8001534:	080164e4 	.word	0x080164e4

08001538 <cmd_auto_complete>:
}

static char tmp_buf[SHELL_SYS_CBSIZE + 1];	/* copy of console I/O buffer */

int cmd_auto_complete(const char *const prompt, char *buf, int *np, int *colp)
{
 8001538:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800153c:	460c      	mov	r4, r1
 800153e:	b0a6      	sub	sp, #152	; 0x98
	const char *sep;
	int i, j, k, len, seplen, argc;
	int cnt;
	char last_char;

	if (strcmp(prompt, SHELL_SYS_PROMPT) != 0)
 8001540:	491f      	ldr	r1, [pc, #124]	; (80015c0 <cmd_auto_complete+0x88>)
 8001542:	f013 fb57 	bl	8014bf4 <strcmp>
 8001546:	b118      	cbz	r0, 8001550 <cmd_auto_complete+0x18>
		return 0;	/* not in normal console */
 8001548:	2000      	movs	r0, #0

		puts(prompt);
		puts(buf);
	}
	return 1;
}
 800154a:	b026      	add	sp, #152	; 0x98
 800154c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
}
#endif

static int make_argv(char *s, int argvsz, char *argv[])
{
	int argc = 0;
 8001550:	4606      	mov	r6, r0
	char last_char;

	if (strcmp(prompt, SHELL_SYS_PROMPT) != 0)
		return 0;	/* not in normal console */

	cnt = strlen(buf);
 8001552:	4620      	mov	r0, r4
 8001554:	f013 fb58 	bl	8014c08 <strlen>
		last_char = buf[cnt - 1];
	else
		last_char = '\0';

	/* copy to secondary buffer which will be affected */
	strcpy(tmp_buf, buf);
 8001558:	4621      	mov	r1, r4
 800155a:	481a      	ldr	r0, [pc, #104]	; (80015c4 <cmd_auto_complete+0x8c>)
 800155c:	f013 fcc4 	bl	8014ee8 <strcpy>
			++s;

		if (*s == '\0')		/* end of s, no more args	*/
			break;

		*s++ = '\0';		/* terminate current arg	 */
 8001560:	46b0      	mov	r8, r6
		last_char = buf[cnt - 1];
	else
		last_char = '\0';

	/* copy to secondary buffer which will be affected */
	strcpy(tmp_buf, buf);
 8001562:	4d18      	ldr	r5, [pc, #96]	; (80015c4 <cmd_auto_complete+0x8c>)
 8001564:	af01      	add	r7, sp, #4

	/* split into argv */
	while (argc < argvsz - 1) {

		/* skip any white space */
		while (isblank(*s))
 8001566:	7828      	ldrb	r0, [r5, #0]
 8001568:	462c      	mov	r4, r5
 800156a:	3501      	adds	r5, #1
 800156c:	f013 fba6 	bl	8014cbc <isblank>
 8001570:	2800      	cmp	r0, #0
 8001572:	d1f8      	bne.n	8001566 <cmd_auto_complete+0x2e>
			++s;

		if (*s == '\0')	/* end of s, no more args	*/
 8001574:	7820      	ldrb	r0, [r4, #0]
 8001576:	b1b0      	cbz	r0, 80015a6 <cmd_auto_complete+0x6e>
			break;

		argv[argc++] = s;	/* begin of argument string	*/
 8001578:	3601      	adds	r6, #1
 800157a:	f847 4b04 	str.w	r4, [r7], #4
 800157e:	e002      	b.n	8001586 <cmd_auto_complete+0x4e>

		/* find end of string */
		while (*s && !isblank(*s))
 8001580:	f814 0f01 	ldrb.w	r0, [r4, #1]!
 8001584:	b178      	cbz	r0, 80015a6 <cmd_auto_complete+0x6e>
 8001586:	f013 fb99 	bl	8014cbc <isblank>
 800158a:	2800      	cmp	r0, #0
 800158c:	d0f8      	beq.n	8001580 <cmd_auto_complete+0x48>
			++s;

		if (*s == '\0')		/* end of s, no more args	*/
 800158e:	7823      	ldrb	r3, [r4, #0]
 8001590:	b14b      	cbz	r3, 80015a6 <cmd_auto_complete+0x6e>
static int make_argv(char *s, int argvsz, char *argv[])
{
	int argc = 0;

	/* split into argv */
	while (argc < argvsz - 1) {
 8001592:	2e10      	cmp	r6, #16
			++s;

		if (*s == '\0')		/* end of s, no more args	*/
			break;

		*s++ = '\0';		/* terminate current arg	 */
 8001594:	f884 8000 	strb.w	r8, [r4]
 8001598:	f104 0501 	add.w	r5, r4, #1
 800159c:	f04f 0300 	mov.w	r3, #0
static int make_argv(char *s, int argvsz, char *argv[])
{
	int argc = 0;

	/* split into argv */
	while (argc < argvsz - 1) {
 80015a0:	d1e1      	bne.n	8001566 <cmd_auto_complete+0x2e>
		if (*s == '\0')		/* end of s, no more args	*/
			break;

		*s++ = '\0';		/* terminate current arg	 */
	}
	argv[argc] = NULL;
 80015a2:	9311      	str	r3, [sp, #68]	; 0x44
 80015a4:	e7d0      	b.n	8001548 <cmd_auto_complete+0x10>
 80015a6:	ab26      	add	r3, sp, #152	; 0x98
 80015a8:	eb03 0386 	add.w	r3, r3, r6, lsl #2
 80015ac:	2200      	movs	r2, #0
	/* do the completion and return the possible completions */
	//i = complete_cmdv(argc, argv, last_char, sizeof(cmdv) / sizeof(cmdv[0]), cmdv);

	/* no match; bell and out */
	if (i == 0) {
		if (argc > 1)	/* allow tab for non command */
 80015ae:	2e01      	cmp	r6, #1
		if (*s == '\0')		/* end of s, no more args	*/
			break;

		*s++ = '\0';		/* terminate current arg	 */
	}
	argv[argc] = NULL;
 80015b0:	f843 2c94 	str.w	r2, [r3, #-148]
	/* do the completion and return the possible completions */
	//i = complete_cmdv(argc, argv, last_char, sizeof(cmdv) / sizeof(cmdv[0]), cmdv);

	/* no match; bell and out */
	if (i == 0) {
		if (argc > 1)	/* allow tab for non command */
 80015b4:	dcc8      	bgt.n	8001548 <cmd_auto_complete+0x10>
			return 0;
		putc('\a');
 80015b6:	2007      	movs	r0, #7
 80015b8:	f013 fc2c 	bl	8014e14 <putc>
		return 1;
 80015bc:	2001      	movs	r0, #1
 80015be:	e7c4      	b.n	800154a <cmd_auto_complete+0x12>
 80015c0:	080162a4 	.word	0x080162a4
 80015c4:	2000072c 	.word	0x2000072c

080015c8 <cmd_process>:
	return result;
}

enum command_ret_t cmd_process(int flag, int argc, char * const argv[],
			       int *repeatable, unsigned int *ticks)
{
 80015c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80015cc:	4615      	mov	r5, r2
 80015ce:	4680      	mov	r8, r0
 80015d0:	460e      	mov	r6, r1
	return NULL;	/* not found or ambiguous command */
}

cmd_tbl_t *find_cmd(const char *cmd)
{
	return find_cmd_tbl(cmd, cmd_tbl, MAX_CMD_LINE);
 80015d2:	6810      	ldr	r0, [r2, #0]
 80015d4:	4912      	ldr	r1, [pc, #72]	; (8001620 <cmd_process+0x58>)
 80015d6:	2220      	movs	r2, #32
	return result;
}

enum command_ret_t cmd_process(int flag, int argc, char * const argv[],
			       int *repeatable, unsigned int *ticks)
{
 80015d8:	461f      	mov	r7, r3
	return NULL;	/* not found or ambiguous command */
}

cmd_tbl_t *find_cmd(const char *cmd)
{
	return find_cmd_tbl(cmd, cmd_tbl, MAX_CMD_LINE);
 80015da:	f7ff ff03 	bl	80013e4 <find_cmd_tbl>
	enum command_ret_t rc = CMD_RET_SUCCESS;
	cmd_tbl_t *cmdtp;

	/* Look up command in command table */
	cmdtp = find_cmd(argv[0]);
	if (cmdtp == NULL) {
 80015de:	b1b8      	cbz	r0, 8001610 <cmd_process+0x48>
		printf("Unknown command '%s' - try 'help'\n", argv[0]);
		return 1;
	}

	/* found - check max args */
	if (argc > cmdtp->maxargs)
 80015e0:	6843      	ldr	r3, [r0, #4]
 80015e2:	4604      	mov	r4, r0
 80015e4:	42b3      	cmp	r3, r6
 80015e6:	db0d      	blt.n	8001604 <cmd_process+0x3c>
 */
static int cmd_call(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	int result;

	result = (cmdtp->cmd)(cmdtp, flag, argc, argv);
 80015e8:	462b      	mov	r3, r5
 80015ea:	4632      	mov	r2, r6
 80015ec:	4641      	mov	r1, r8
 80015ee:	68c5      	ldr	r5, [r0, #12]
 80015f0:	47a8      	blx	r5
		rc = CMD_RET_USAGE;

	/* If OK so far, then do the command */
	if (!rc) {
		rc = cmd_call(cmdtp, flag, argc, argv);
		*repeatable &= cmdtp->repeatable;
 80015f2:	683a      	ldr	r2, [r7, #0]
 80015f4:	68a3      	ldr	r3, [r4, #8]
	if (argc > cmdtp->maxargs)
		rc = CMD_RET_USAGE;

	/* If OK so far, then do the command */
	if (!rc) {
		rc = cmd_call(cmdtp, flag, argc, argv);
 80015f6:	b240      	sxtb	r0, r0
		*repeatable &= cmdtp->repeatable;
 80015f8:	4013      	ands	r3, r2
 80015fa:	603b      	str	r3, [r7, #0]
	}
	if (rc == CMD_RET_USAGE)
 80015fc:	1c43      	adds	r3, r0, #1
 80015fe:	d001      	beq.n	8001604 <cmd_process+0x3c>
		rc = cmd_usage(cmdtp);
	return rc;
}
 8001600:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (!rc) {
		rc = cmd_call(cmdtp, flag, argc, argv);
		*repeatable &= cmdtp->repeatable;
	}
	if (rc == CMD_RET_USAGE)
		rc = cmd_usage(cmdtp);
 8001604:	4620      	mov	r0, r4
 8001606:	f7ff ff29 	bl	800145c <cmd_usage>
 800160a:	b240      	sxtb	r0, r0
 800160c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	cmd_tbl_t *cmdtp;

	/* Look up command in command table */
	cmdtp = find_cmd(argv[0]);
	if (cmdtp == NULL) {
		printf("Unknown command '%s' - try 'help'\n", argv[0]);
 8001610:	6829      	ldr	r1, [r5, #0]
 8001612:	4804      	ldr	r0, [pc, #16]	; (8001624 <cmd_process+0x5c>)
 8001614:	f013 fbb0 	bl	8014d78 <iprintf>
		return 1;
 8001618:	2001      	movs	r0, #1
 800161a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800161e:	bf00      	nop
 8001620:	200003a8 	.word	0x200003a8
 8001624:	0801654c 	.word	0x0801654c

08001628 <cmd_process_error>:
	return rc;
}

int cmd_process_error(cmd_tbl_t *cmdtp, int err)
{
	if (err == CMD_RET_USAGE)
 8001628:	1c4a      	adds	r2, r1, #1
 800162a:	d000      	beq.n	800162e <cmd_process_error+0x6>
		return CMD_RET_USAGE;

	if (err) {
 800162c:	b909      	cbnz	r1, 8001632 <cmd_process_error+0xa>
		printf("Command '%s' failed: Error %d\n", cmdtp->name, err);
		return CMD_RET_FAILURE;
	}

	return CMD_RET_SUCCESS;
 800162e:	4608      	mov	r0, r1
 8001630:	4770      	bx	lr
		rc = cmd_usage(cmdtp);
	return rc;
}

int cmd_process_error(cmd_tbl_t *cmdtp, int err)
{
 8001632:	b508      	push	{r3, lr}
 8001634:	460a      	mov	r2, r1
	if (err == CMD_RET_USAGE)
		return CMD_RET_USAGE;

	if (err) {
		printf("Command '%s' failed: Error %d\n", cmdtp->name, err);
 8001636:	6801      	ldr	r1, [r0, #0]
 8001638:	4802      	ldr	r0, [pc, #8]	; (8001644 <cmd_process_error+0x1c>)
 800163a:	f013 fb9d 	bl	8014d78 <iprintf>
		return CMD_RET_FAILURE;
 800163e:	2001      	movs	r0, #1
 8001640:	bd08      	pop	{r3, pc}
 8001642:	bf00      	nop
 8001644:	08016570 	.word	0x08016570

08001648 <cgetc>:
#include <console.h>
#include "hw_beacon.h"

int cgetc(void)
{
	return SWIFT_USART6_GETC();
 8001648:	f000 bcd4 	b.w	8001ff4 <SWIFT_USART6_GETC>

0800164c <ctstc>:
}

int ctstc(void)
{
	return SWIFT_USART6_TSTC();
 800164c:	f000 bce0 	b.w	8002010 <SWIFT_USART6_TSTC>

08001650 <cputc>:
}

void cputc(char c)
{
 8001650:	b500      	push	{lr}
 8001652:	b083      	sub	sp, #12
 8001654:	ab02      	add	r3, sp, #8
 8001656:	f803 0d01 	strb.w	r0, [r3, #-1]!
	SWIFT_UART6_SendBuff(&c, 1);
 800165a:	4618      	mov	r0, r3
 800165c:	2101      	movs	r1, #1
 800165e:	f000 fca5 	bl	8001fac <SWIFT_UART6_SendBuff>
}
 8001662:	b003      	add	sp, #12
 8001664:	f85d fb04 	ldr.w	pc, [sp], #4

08001668 <cputs>:

void cputs(char *s)
{
 8001668:	b510      	push	{r4, lr}
 800166a:	4604      	mov	r4, r0
	/* Send directly to the handler */
	SWIFT_UART6_SendBuff(s, strlen(s));
 800166c:	f013 facc 	bl	8014c08 <strlen>
 8001670:	4601      	mov	r1, r0
 8001672:	4620      	mov	r0, r4
}
 8001674:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
}

void cputs(char *s)
{
	/* Send directly to the handler */
	SWIFT_UART6_SendBuff(s, strlen(s));
 8001678:	f000 bc98 	b.w	8001fac <SWIFT_UART6_SendBuff>

0800167c <ctrlc>:

/* test if ctrl-c was pressed */
static int ctrlc_disabled = 0;	/* see disable_ctrl() */
static int ctrlc_was_pressed = 0;
int ctrlc(void)
{
 800167c:	b538      	push	{r3, r4, r5, lr}
	if (!ctrlc_disabled) {
 800167e:	4d09      	ldr	r5, [pc, #36]	; (80016a4 <ctrlc+0x28>)
 8001680:	682c      	ldr	r4, [r5, #0]
 8001682:	b114      	cbz	r4, 800168a <ctrlc+0xe>
				break;
			}
		}
	}

	return 0;
 8001684:	2400      	movs	r4, #0
}
 8001686:	4620      	mov	r0, r4
 8001688:	bd38      	pop	{r3, r4, r5, pc}
	return SWIFT_USART6_GETC();
}

int ctstc(void)
{
	return SWIFT_USART6_TSTC();
 800168a:	f000 fcc1 	bl	8002010 <SWIFT_USART6_TSTC>
static int ctrlc_disabled = 0;	/* see disable_ctrl() */
static int ctrlc_was_pressed = 0;
int ctrlc(void)
{
	if (!ctrlc_disabled) {
		if (ctstc()) {
 800168e:	2800      	cmp	r0, #0
 8001690:	d0f8      	beq.n	8001684 <ctrlc+0x8>
#include <console.h>
#include "hw_beacon.h"

int cgetc(void)
{
	return SWIFT_USART6_GETC();
 8001692:	f000 fcaf 	bl	8001ff4 <SWIFT_USART6_GETC>
static int ctrlc_was_pressed = 0;
int ctrlc(void)
{
	if (!ctrlc_disabled) {
		if (ctstc()) {
			switch (cgetc()) {
 8001696:	2803      	cmp	r0, #3
 8001698:	d1f5      	bne.n	8001686 <ctrlc+0xa>
			case 0x03:		/* ^C - Control C */
				ctrlc_was_pressed = 1;
 800169a:	2301      	movs	r3, #1
				return 1;
 800169c:	461c      	mov	r4, r3
{
	if (!ctrlc_disabled) {
		if (ctstc()) {
			switch (cgetc()) {
			case 0x03:		/* ^C - Control C */
				ctrlc_was_pressed = 1;
 800169e:	606b      	str	r3, [r5, #4]
				return 1;
 80016a0:	e7f1      	b.n	8001686 <ctrlc+0xa>
 80016a2:	bf00      	nop
 80016a4:	20000770 	.word	0x20000770

080016a8 <confirm_yesno>:

/* Reads user's confirmation.
   Returns 1 if user's input is "y", "Y", "yes" or "YES"
*/
int confirm_yesno(void)
{
 80016a8:	b570      	push	{r4, r5, r6, lr}
 80016aa:	b084      	sub	sp, #16
	int i;
	char str_input[5];

	/* Flush input */
	while (ctstc())
 80016ac:	e001      	b.n	80016b2 <confirm_yesno+0xa>
#include <console.h>
#include "hw_beacon.h"

int cgetc(void)
{
	return SWIFT_USART6_GETC();
 80016ae:	f000 fca1 	bl	8001ff4 <SWIFT_USART6_GETC>
}

int ctstc(void)
{
	return SWIFT_USART6_TSTC();
 80016b2:	f000 fcad 	bl	8002010 <SWIFT_USART6_TSTC>
{
	int i;
	char str_input[5];

	/* Flush input */
	while (ctstc())
 80016b6:	2800      	cmp	r0, #0
 80016b8:	d1f9      	bne.n	80016ae <confirm_yesno+0x6>
 80016ba:	ac02      	add	r4, sp, #8
 80016bc:	f10d 060d 	add.w	r6, sp, #13
#include <console.h>
#include "hw_beacon.h"

int cgetc(void)
{
	return SWIFT_USART6_GETC();
 80016c0:	f000 fc98 	bl	8001ff4 <SWIFT_USART6_GETC>
 80016c4:	4625      	mov	r5, r4
	/* Flush input */
	while (ctstc())
		cgetc();
	i = 0;
	while (i < sizeof(str_input)) {
		str_input[i] = cgetc();
 80016c6:	b2c3      	uxtb	r3, r0
	return SWIFT_USART6_TSTC();
}

void cputc(char c)
{
	SWIFT_UART6_SendBuff(&c, 1);
 80016c8:	2101      	movs	r1, #1
 80016ca:	f10d 0006 	add.w	r0, sp, #6
 80016ce:	f88d 3006 	strb.w	r3, [sp, #6]
	/* Flush input */
	while (ctstc())
		cgetc();
	i = 0;
	while (i < sizeof(str_input)) {
		str_input[i] = cgetc();
 80016d2:	f804 3b01 	strb.w	r3, [r4], #1
	return SWIFT_USART6_TSTC();
}

void cputc(char c)
{
	SWIFT_UART6_SendBuff(&c, 1);
 80016d6:	f000 fc69 	bl	8001fac <SWIFT_UART6_SendBuff>
		cgetc();
	i = 0;
	while (i < sizeof(str_input)) {
		str_input[i] = cgetc();
		cputc(str_input[i]);
		if (str_input[i] == '\r')
 80016da:	782b      	ldrb	r3, [r5, #0]
 80016dc:	2b0d      	cmp	r3, #13
 80016de:	d001      	beq.n	80016e4 <confirm_yesno+0x3c>

	/* Flush input */
	while (ctstc())
		cgetc();
	i = 0;
	while (i < sizeof(str_input)) {
 80016e0:	42b4      	cmp	r4, r6
 80016e2:	d1ed      	bne.n	80016c0 <confirm_yesno+0x18>
 80016e4:	a804      	add	r0, sp, #16
 80016e6:	230a      	movs	r3, #10
 80016e8:	f800 3d09 	strb.w	r3, [r0, #-9]!
	return SWIFT_USART6_TSTC();
}

void cputc(char c)
{
	SWIFT_UART6_SendBuff(&c, 1);
 80016ec:	2101      	movs	r1, #1
 80016ee:	f000 fc5d 	bl	8001fac <SWIFT_UART6_SendBuff>
		if (str_input[i] == '\r')
			break;
		i++;
	}
	cputc('\n');
	if (strncmp(str_input, "y\r", 2) == 0 ||
 80016f2:	2202      	movs	r2, #2
 80016f4:	490f      	ldr	r1, [pc, #60]	; (8001734 <confirm_yesno+0x8c>)
 80016f6:	a802      	add	r0, sp, #8
 80016f8:	f013 fc13 	bl	8014f22 <strncmp>
 80016fc:	b910      	cbnz	r0, 8001704 <confirm_yesno+0x5c>
	    strncmp(str_input, "Y\r", 2) == 0 ||
	    strncmp(str_input, "yes\r", 4) == 0 ||
	    strncmp(str_input, "YES\r", 4) == 0)
		return 1;
 80016fe:	2001      	movs	r0, #1
	return 0;
}
 8001700:	b004      	add	sp, #16
 8001702:	bd70      	pop	{r4, r5, r6, pc}
			break;
		i++;
	}
	cputc('\n');
	if (strncmp(str_input, "y\r", 2) == 0 ||
	    strncmp(str_input, "Y\r", 2) == 0 ||
 8001704:	2202      	movs	r2, #2
 8001706:	490c      	ldr	r1, [pc, #48]	; (8001738 <confirm_yesno+0x90>)
 8001708:	a802      	add	r0, sp, #8
 800170a:	f013 fc0a 	bl	8014f22 <strncmp>
		if (str_input[i] == '\r')
			break;
		i++;
	}
	cputc('\n');
	if (strncmp(str_input, "y\r", 2) == 0 ||
 800170e:	2800      	cmp	r0, #0
 8001710:	d0f5      	beq.n	80016fe <confirm_yesno+0x56>
	    strncmp(str_input, "Y\r", 2) == 0 ||
	    strncmp(str_input, "yes\r", 4) == 0 ||
 8001712:	2204      	movs	r2, #4
 8001714:	4909      	ldr	r1, [pc, #36]	; (800173c <confirm_yesno+0x94>)
 8001716:	a802      	add	r0, sp, #8
 8001718:	f013 fc03 	bl	8014f22 <strncmp>
			break;
		i++;
	}
	cputc('\n');
	if (strncmp(str_input, "y\r", 2) == 0 ||
	    strncmp(str_input, "Y\r", 2) == 0 ||
 800171c:	2800      	cmp	r0, #0
 800171e:	d0ee      	beq.n	80016fe <confirm_yesno+0x56>
	    strncmp(str_input, "yes\r", 4) == 0 ||
	    strncmp(str_input, "YES\r", 4) == 0)
 8001720:	a802      	add	r0, sp, #8
 8001722:	2204      	movs	r2, #4
 8001724:	4906      	ldr	r1, [pc, #24]	; (8001740 <confirm_yesno+0x98>)
 8001726:	f013 fbfc 	bl	8014f22 <strncmp>
		return 1;
 800172a:	fab0 f080 	clz	r0, r0
 800172e:	0940      	lsrs	r0, r0, #5
 8001730:	e7e6      	b.n	8001700 <confirm_yesno+0x58>
 8001732:	bf00      	nop
 8001734:	08016590 	.word	0x08016590
 8001738:	08016594 	.word	0x08016594
 800173c:	08016598 	.word	0x08016598
 8001740:	080165a0 	.word	0x080165a0

08001744 <disable_ctrlc>:
/* pass 1 to disable ctrlc() checking, 0 to enable.
 * returns previous state
 */
int disable_ctrlc(int disable)
{
	int prev = ctrlc_disabled;	/* save previous state */
 8001744:	4b02      	ldr	r3, [pc, #8]	; (8001750 <disable_ctrlc+0xc>)
 8001746:	681a      	ldr	r2, [r3, #0]

	ctrlc_disabled = disable;
 8001748:	6018      	str	r0, [r3, #0]
	return prev;
}
 800174a:	4610      	mov	r0, r2
 800174c:	4770      	bx	lr
 800174e:	bf00      	nop
 8001750:	20000770 	.word	0x20000770

08001754 <had_ctrlc>:

int had_ctrlc (void)
{
	return ctrlc_was_pressed;
 8001754:	4b01      	ldr	r3, [pc, #4]	; (800175c <had_ctrlc+0x8>)
}
 8001756:	6858      	ldr	r0, [r3, #4]
 8001758:	4770      	bx	lr
 800175a:	bf00      	nop
 800175c:	20000770 	.word	0x20000770

08001760 <clear_ctrlc>:

void clear_ctrlc(void)
{
	ctrlc_was_pressed = 0;
 8001760:	4b01      	ldr	r3, [pc, #4]	; (8001768 <clear_ctrlc+0x8>)
 8001762:	2200      	movs	r2, #0
 8001764:	605a      	str	r2, [r3, #4]
 8001766:	4770      	bx	lr
 8001768:	20000770 	.word	0x20000770

0800176c <CPU_IntDis>:
 800176c:	b672      	cpsid	i
 800176e:	4770      	bx	lr

08001770 <CPU_IntEn>:
 8001770:	b662      	cpsie	i
 8001772:	4770      	bx	lr

08001774 <CPU_SR_Save>:
 8001774:	f3ef 8010 	mrs	r0, PRIMASK
 8001778:	b672      	cpsid	i
 800177a:	4770      	bx	lr

0800177c <CPU_SR_Restore>:
 800177c:	f380 8810 	msr	PRIMASK, r0
 8001780:	4770      	bx	lr

08001782 <CPU_WaitForInt>:
 8001782:	bf30      	wfi
 8001784:	4770      	bx	lr

08001786 <CPU_WaitForExcept>:
 8001786:	bf20      	wfe
 8001788:	4770      	bx	lr

0800178a <CPU_CntLeadZeros>:
 800178a:	fab0 f080 	clz	r0, r0
 800178e:	4770      	bx	lr

08001790 <CPU_CntTrailZeros>:
 8001790:	fa90 f0a0 	rbit	r0, r0
 8001794:	fab0 f080 	clz	r0, r0
 8001798:	4770      	bx	lr

0800179a <CPU_RevBits>:
 800179a:	fa90 f0a0 	rbit	r0, r0
 800179e:	4770      	bx	lr

080017a0 <CPU_BitBandClr>:
{
    CPU_ADDR  bit_word_off;
    CPU_ADDR  bit_word_addr;


    if ((addr >= CPU_BIT_BAND_SRAM_REG_LO) &&
 80017a0:	4b0b      	ldr	r3, [pc, #44]	; (80017d0 <CPU_BitBandClr+0x30>)
 80017a2:	f100 4260 	add.w	r2, r0, #3758096384	; 0xe0000000
 80017a6:	429a      	cmp	r2, r3
 80017a8:	d90a      	bls.n	80017c0 <CPU_BitBandClr+0x20>
        bit_word_off  = ((addr - CPU_BIT_BAND_SRAM_REG_LO  ) * 32) + (bit_nbr * 4);
        bit_word_addr = CPU_BIT_BAND_SRAM_BASE   + bit_word_off;

      *(volatile CPU_INT32U *)(bit_word_addr) = 0;

    } else if ((addr >= CPU_BIT_BAND_PERIPH_REG_LO) &&
 80017aa:	f100 4240 	add.w	r2, r0, #3221225472	; 0xc0000000
 80017ae:	429a      	cmp	r2, r3
 80017b0:	d805      	bhi.n	80017be <CPU_BitBandClr+0x1e>
               (addr <= CPU_BIT_BAND_PERIPH_REG_HI)) {
        bit_word_off  = ((addr - CPU_BIT_BAND_PERIPH_REG_LO) * 32) + (bit_nbr * 4);
        bit_word_addr = CPU_BIT_BAND_PERIPH_BASE + bit_word_off;

      *(volatile CPU_INT32U *)(bit_word_addr) = 0;
 80017b2:	0140      	lsls	r0, r0, #5
 80017b4:	f100 4084 	add.w	r0, r0, #1107296256	; 0x42000000
 80017b8:	2300      	movs	r3, #0
 80017ba:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
 80017be:	4770      	bx	lr
    if ((addr >= CPU_BIT_BAND_SRAM_REG_LO) &&
        (addr <= CPU_BIT_BAND_SRAM_REG_HI)) {
        bit_word_off  = ((addr - CPU_BIT_BAND_SRAM_REG_LO  ) * 32) + (bit_nbr * 4);
        bit_word_addr = CPU_BIT_BAND_SRAM_BASE   + bit_word_off;

      *(volatile CPU_INT32U *)(bit_word_addr) = 0;
 80017c0:	0140      	lsls	r0, r0, #5
 80017c2:	f100 5008 	add.w	r0, r0, #570425344	; 0x22000000
 80017c6:	2300      	movs	r3, #0
 80017c8:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
 80017cc:	4770      	bx	lr
 80017ce:	bf00      	nop
 80017d0:	000fffff 	.word	0x000fffff

080017d4 <CPU_BitBandSet>:
{
    CPU_ADDR  bit_word_off;
    CPU_ADDR  bit_word_addr;


    if ((addr >= CPU_BIT_BAND_SRAM_REG_LO) &&
 80017d4:	4b0b      	ldr	r3, [pc, #44]	; (8001804 <CPU_BitBandSet+0x30>)
 80017d6:	f100 4260 	add.w	r2, r0, #3758096384	; 0xe0000000
 80017da:	429a      	cmp	r2, r3
 80017dc:	d90a      	bls.n	80017f4 <CPU_BitBandSet+0x20>
        bit_word_off  = ((addr - CPU_BIT_BAND_SRAM_REG_LO  ) * 32) + (bit_nbr * 4);
        bit_word_addr = CPU_BIT_BAND_SRAM_BASE   + bit_word_off;

      *(volatile CPU_INT32U *)(bit_word_addr) = 1;

    } else if ((addr >= CPU_BIT_BAND_PERIPH_REG_LO) &&
 80017de:	f100 4240 	add.w	r2, r0, #3221225472	; 0xc0000000
 80017e2:	429a      	cmp	r2, r3
 80017e4:	d805      	bhi.n	80017f2 <CPU_BitBandSet+0x1e>
               (addr <= CPU_BIT_BAND_PERIPH_REG_HI)) {
        bit_word_off  = ((addr - CPU_BIT_BAND_PERIPH_REG_LO) * 32) + (bit_nbr * 4);
        bit_word_addr = CPU_BIT_BAND_PERIPH_BASE + bit_word_off;

      *(volatile CPU_INT32U *)(bit_word_addr) = 1;
 80017e6:	0140      	lsls	r0, r0, #5
 80017e8:	f100 4084 	add.w	r0, r0, #1107296256	; 0x42000000
 80017ec:	2301      	movs	r3, #1
 80017ee:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
 80017f2:	4770      	bx	lr
    if ((addr >= CPU_BIT_BAND_SRAM_REG_LO) &&
        (addr <= CPU_BIT_BAND_SRAM_REG_HI)) {
        bit_word_off  = ((addr - CPU_BIT_BAND_SRAM_REG_LO  ) * 32) + (bit_nbr * 4);
        bit_word_addr = CPU_BIT_BAND_SRAM_BASE   + bit_word_off;

      *(volatile CPU_INT32U *)(bit_word_addr) = 1;
 80017f4:	0140      	lsls	r0, r0, #5
 80017f6:	f100 5008 	add.w	r0, r0, #570425344	; 0x22000000
 80017fa:	2301      	movs	r3, #1
 80017fc:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
 8001800:	4770      	bx	lr
 8001802:	bf00      	nop
 8001804:	000fffff 	.word	0x000fffff

08001808 <CPU_IntSrcDis>:
*                   COULD be valid.
*********************************************************************************************************
*/
/*$PAGE*/
void  CPU_IntSrcDis (CPU_INT08U  pos)
{
 8001808:	b538      	push	{r3, r4, r5, lr}
    CPU_INT08U  pos_max;
    CPU_INT08U  nbr;
    CPU_SR_ALLOC();


    switch (pos) {
 800180a:	280f      	cmp	r0, #15
 800180c:	d836      	bhi.n	800187c <CPU_IntSrcDis+0x74>
 800180e:	e8df f000 	tbb	[pc, r0]
 8001812:	0808      	.short	0x0808
 8001814:	2a1f0808 	.word	0x2a1f0808
 8001818:	08080809 	.word	0x08080809
 800181c:	08080808 	.word	0x08080808
 8001820:	1408      	.short	0x1408
 8001822:	bd38      	pop	{r3, r4, r5, pc}
             CPU_REG_NVIC_SHCSR &= ~CPU_REG_NVIC_SHCSR_BUSFAULTENA;
             CPU_CRITICAL_EXIT();
             break;

        case CPU_INT_USAGEFAULT:                                /* Usage fault.                                         */
             CPU_CRITICAL_ENTER();
 8001824:	f7ff ffa6 	bl	8001774 <CPU_SR_Save>
             CPU_REG_NVIC_SHCSR &= ~CPU_REG_NVIC_SHCSR_USGFAULTENA;
 8001828:	4a2a      	ldr	r2, [pc, #168]	; (80018d4 <CPU_IntSrcDis+0xcc>)
 800182a:	6813      	ldr	r3, [r2, #0]
 800182c:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8001830:	6013      	str	r3, [r2, #0]
                 CPU_REG_NVIC_CLREN(group) = DEF_BIT(nbr);
                 CPU_CRITICAL_EXIT();
             }
             break;
    }
}
 8001832:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
             break;

        case CPU_INT_USAGEFAULT:                                /* Usage fault.                                         */
             CPU_CRITICAL_ENTER();
             CPU_REG_NVIC_SHCSR &= ~CPU_REG_NVIC_SHCSR_USGFAULTENA;
             CPU_CRITICAL_EXIT();
 8001836:	f7ff bfa1 	b.w	800177c <CPU_SR_Restore>
             break;

        case CPU_INT_SYSTICK:                                   /* SysTick.                                             */
             CPU_CRITICAL_ENTER();
 800183a:	f7ff ff9b 	bl	8001774 <CPU_SR_Save>
             CPU_REG_NVIC_ST_CTRL &= ~CPU_REG_NVIC_ST_CTRL_ENABLE;
 800183e:	4a26      	ldr	r2, [pc, #152]	; (80018d8 <CPU_IntSrcDis+0xd0>)
 8001840:	6813      	ldr	r3, [r2, #0]
 8001842:	f023 0301 	bic.w	r3, r3, #1
 8001846:	6013      	str	r3, [r2, #0]
                 CPU_REG_NVIC_CLREN(group) = DEF_BIT(nbr);
                 CPU_CRITICAL_EXIT();
             }
             break;
    }
}
 8001848:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
             break;

        case CPU_INT_SYSTICK:                                   /* SysTick.                                             */
             CPU_CRITICAL_ENTER();
             CPU_REG_NVIC_ST_CTRL &= ~CPU_REG_NVIC_ST_CTRL_ENABLE;
             CPU_CRITICAL_EXIT();
 800184c:	f7ff bf96 	b.w	800177c <CPU_SR_Restore>
        case CPU_INT_DBGMON:                                    /* Debug monitor (see Note #2).                         */
        case CPU_INT_PENDSV:                                    /* PendSV (see Note #2).                                */
             break;

        case CPU_INT_MEM:                                       /* Memory management.                                   */
             CPU_CRITICAL_ENTER();
 8001850:	f7ff ff90 	bl	8001774 <CPU_SR_Save>
             CPU_REG_NVIC_SHCSR &= ~CPU_REG_NVIC_SHCSR_MEMFAULTENA;
 8001854:	4a1f      	ldr	r2, [pc, #124]	; (80018d4 <CPU_IntSrcDis+0xcc>)
 8001856:	6813      	ldr	r3, [r2, #0]
 8001858:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800185c:	6013      	str	r3, [r2, #0]
                 CPU_REG_NVIC_CLREN(group) = DEF_BIT(nbr);
                 CPU_CRITICAL_EXIT();
             }
             break;
    }
}
 800185e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
             break;

        case CPU_INT_MEM:                                       /* Memory management.                                   */
             CPU_CRITICAL_ENTER();
             CPU_REG_NVIC_SHCSR &= ~CPU_REG_NVIC_SHCSR_MEMFAULTENA;
             CPU_CRITICAL_EXIT();
 8001862:	f7ff bf8b 	b.w	800177c <CPU_SR_Restore>
             break;

        case CPU_INT_BUSFAULT:                                  /* Bus fault.                                           */
             CPU_CRITICAL_ENTER();
 8001866:	f7ff ff85 	bl	8001774 <CPU_SR_Save>
             CPU_REG_NVIC_SHCSR &= ~CPU_REG_NVIC_SHCSR_BUSFAULTENA;
 800186a:	4a1a      	ldr	r2, [pc, #104]	; (80018d4 <CPU_IntSrcDis+0xcc>)
 800186c:	6813      	ldr	r3, [r2, #0]
 800186e:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 8001872:	6013      	str	r3, [r2, #0]
                 CPU_REG_NVIC_CLREN(group) = DEF_BIT(nbr);
                 CPU_CRITICAL_EXIT();
             }
             break;
    }
}
 8001874:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
             break;

        case CPU_INT_BUSFAULT:                                  /* Bus fault.                                           */
             CPU_CRITICAL_ENTER();
             CPU_REG_NVIC_SHCSR &= ~CPU_REG_NVIC_SHCSR_BUSFAULTENA;
             CPU_CRITICAL_EXIT();
 8001878:	f7ff bf80 	b.w	800177c <CPU_SR_Restore>
             break;


                                                                /* ---------------- EXTERNAL INTERRUPT ---------------- */
        default:
            pos_max = CPU_INT_SRC_POS_MAX;
 800187c:	4b17      	ldr	r3, [pc, #92]	; (80018dc <CPU_IntSrcDis+0xd4>)
 800187e:	4604      	mov	r4, r0
 8001880:	681b      	ldr	r3, [r3, #0]
            if (pos < pos_max) {                                /* See Note #3.                                         */
 8001882:	3301      	adds	r3, #1
 8001884:	f003 031f 	and.w	r3, r3, #31
 8001888:	015b      	lsls	r3, r3, #5
 800188a:	3310      	adds	r3, #16
 800188c:	b2db      	uxtb	r3, r3
 800188e:	4298      	cmp	r0, r3
 8001890:	d2c7      	bcs.n	8001822 <CPU_IntSrcDis+0x1a>
                 group = (pos - 16) / 32;
 8001892:	f1a0 0510 	sub.w	r5, r0, #16
                 nbr   = (pos - 16) % 32;

                 CPU_CRITICAL_ENTER();
 8001896:	f7ff ff6d 	bl	8001774 <CPU_SR_Save>
                 CPU_REG_NVIC_CLREN(group) = DEF_BIT(nbr);
 800189a:	462b      	mov	r3, r5
 800189c:	2d00      	cmp	r5, #0
 800189e:	bfb8      	it	lt
 80018a0:	f104 030f 	addlt.w	r3, r4, #15
 80018a4:	4a0e      	ldr	r2, [pc, #56]	; (80018e0 <CPU_IntSrcDis+0xd8>)
 80018a6:	115b      	asrs	r3, r3, #5
 80018a8:	f103 2338 	add.w	r3, r3, #939538432	; 0x38003800
 80018ac:	402a      	ands	r2, r5
 80018ae:	3360      	adds	r3, #96	; 0x60
 80018b0:	2a00      	cmp	r2, #0
 80018b2:	ea4f 0383 	mov.w	r3, r3, lsl #2
 80018b6:	db08      	blt.n	80018ca <CPU_IntSrcDis+0xc2>
 80018b8:	b2d2      	uxtb	r2, r2
 80018ba:	2101      	movs	r1, #1
 80018bc:	fa01 f202 	lsl.w	r2, r1, r2
 80018c0:	601a      	str	r2, [r3, #0]
                 CPU_CRITICAL_EXIT();
             }
             break;
    }
}
 80018c2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
                 group = (pos - 16) / 32;
                 nbr   = (pos - 16) % 32;

                 CPU_CRITICAL_ENTER();
                 CPU_REG_NVIC_CLREN(group) = DEF_BIT(nbr);
                 CPU_CRITICAL_EXIT();
 80018c6:	f7ff bf59 	b.w	800177c <CPU_SR_Restore>
            if (pos < pos_max) {                                /* See Note #3.                                         */
                 group = (pos - 16) / 32;
                 nbr   = (pos - 16) % 32;

                 CPU_CRITICAL_ENTER();
                 CPU_REG_NVIC_CLREN(group) = DEF_BIT(nbr);
 80018ca:	3a01      	subs	r2, #1
 80018cc:	f062 021f 	orn	r2, r2, #31
 80018d0:	3201      	adds	r2, #1
 80018d2:	e7f1      	b.n	80018b8 <CPU_IntSrcDis+0xb0>
 80018d4:	e000ed24 	.word	0xe000ed24
 80018d8:	e000e010 	.word	0xe000e010
 80018dc:	e000e004 	.word	0xe000e004
 80018e0:	8000001f 	.word	0x8000001f

080018e4 <CPU_IntSrcEn>:
*               (3) See 'CPU_IntSrcDis()  Note #3'.
*********************************************************************************************************
*/

void  CPU_IntSrcEn (CPU_INT08U  pos)
{
 80018e4:	b538      	push	{r3, r4, r5, lr}
    CPU_INT08U  nbr;
    CPU_INT08U  pos_max;
    CPU_SR_ALLOC();


    switch (pos) {
 80018e6:	280f      	cmp	r0, #15
 80018e8:	d836      	bhi.n	8001958 <CPU_IntSrcEn+0x74>
 80018ea:	e8df f000 	tbb	[pc, r0]
 80018ee:	0808      	.short	0x0808
 80018f0:	2a1f0808 	.word	0x2a1f0808
 80018f4:	08080809 	.word	0x08080809
 80018f8:	08080808 	.word	0x08080808
 80018fc:	1408      	.short	0x1408
 80018fe:	bd38      	pop	{r3, r4, r5, pc}
             CPU_REG_NVIC_SHCSR |= CPU_REG_NVIC_SHCSR_BUSFAULTENA;
             CPU_CRITICAL_EXIT();
             break;

        case CPU_INT_USAGEFAULT:                                /* Usage fault.                                         */
             CPU_CRITICAL_ENTER();
 8001900:	f7ff ff38 	bl	8001774 <CPU_SR_Save>
             CPU_REG_NVIC_SHCSR |= CPU_REG_NVIC_SHCSR_USGFAULTENA;
 8001904:	4a2a      	ldr	r2, [pc, #168]	; (80019b0 <CPU_IntSrcEn+0xcc>)
 8001906:	6813      	ldr	r3, [r2, #0]
 8001908:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 800190c:	6013      	str	r3, [r2, #0]
                 CPU_REG_NVIC_SETEN(group) = DEF_BIT(nbr);
                 CPU_CRITICAL_EXIT();
             }
             break;
    }
}
 800190e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
             break;

        case CPU_INT_USAGEFAULT:                                /* Usage fault.                                         */
             CPU_CRITICAL_ENTER();
             CPU_REG_NVIC_SHCSR |= CPU_REG_NVIC_SHCSR_USGFAULTENA;
             CPU_CRITICAL_EXIT();
 8001912:	f7ff bf33 	b.w	800177c <CPU_SR_Restore>
             break;

        case CPU_INT_SYSTICK:                                   /* SysTick.                                             */
             CPU_CRITICAL_ENTER();
 8001916:	f7ff ff2d 	bl	8001774 <CPU_SR_Save>
             CPU_REG_NVIC_ST_CTRL |= CPU_REG_NVIC_ST_CTRL_ENABLE;
 800191a:	4a26      	ldr	r2, [pc, #152]	; (80019b4 <CPU_IntSrcEn+0xd0>)
 800191c:	6813      	ldr	r3, [r2, #0]
 800191e:	f043 0301 	orr.w	r3, r3, #1
 8001922:	6013      	str	r3, [r2, #0]
                 CPU_REG_NVIC_SETEN(group) = DEF_BIT(nbr);
                 CPU_CRITICAL_EXIT();
             }
             break;
    }
}
 8001924:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
             break;

        case CPU_INT_SYSTICK:                                   /* SysTick.                                             */
             CPU_CRITICAL_ENTER();
             CPU_REG_NVIC_ST_CTRL |= CPU_REG_NVIC_ST_CTRL_ENABLE;
             CPU_CRITICAL_EXIT();
 8001928:	f7ff bf28 	b.w	800177c <CPU_SR_Restore>
        case CPU_INT_DBGMON:                                    /* Debug monitor (see Note #2).                         */
        case CPU_INT_PENDSV:                                    /* PendSV (see Note #2).                                */
             break;

        case CPU_INT_MEM:                                       /* Memory management.                                   */
             CPU_CRITICAL_ENTER();
 800192c:	f7ff ff22 	bl	8001774 <CPU_SR_Save>
             CPU_REG_NVIC_SHCSR |= CPU_REG_NVIC_SHCSR_MEMFAULTENA;
 8001930:	4a1f      	ldr	r2, [pc, #124]	; (80019b0 <CPU_IntSrcEn+0xcc>)
 8001932:	6813      	ldr	r3, [r2, #0]
 8001934:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8001938:	6013      	str	r3, [r2, #0]
                 CPU_REG_NVIC_SETEN(group) = DEF_BIT(nbr);
                 CPU_CRITICAL_EXIT();
             }
             break;
    }
}
 800193a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
             break;

        case CPU_INT_MEM:                                       /* Memory management.                                   */
             CPU_CRITICAL_ENTER();
             CPU_REG_NVIC_SHCSR |= CPU_REG_NVIC_SHCSR_MEMFAULTENA;
             CPU_CRITICAL_EXIT();
 800193e:	f7ff bf1d 	b.w	800177c <CPU_SR_Restore>
             break;

        case CPU_INT_BUSFAULT:                                  /* Bus fault.                                           */
             CPU_CRITICAL_ENTER();
 8001942:	f7ff ff17 	bl	8001774 <CPU_SR_Save>
             CPU_REG_NVIC_SHCSR |= CPU_REG_NVIC_SHCSR_BUSFAULTENA;
 8001946:	4a1a      	ldr	r2, [pc, #104]	; (80019b0 <CPU_IntSrcEn+0xcc>)
 8001948:	6813      	ldr	r3, [r2, #0]
 800194a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800194e:	6013      	str	r3, [r2, #0]
                 CPU_REG_NVIC_SETEN(group) = DEF_BIT(nbr);
                 CPU_CRITICAL_EXIT();
             }
             break;
    }
}
 8001950:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
             break;

        case CPU_INT_BUSFAULT:                                  /* Bus fault.                                           */
             CPU_CRITICAL_ENTER();
             CPU_REG_NVIC_SHCSR |= CPU_REG_NVIC_SHCSR_BUSFAULTENA;
             CPU_CRITICAL_EXIT();
 8001954:	f7ff bf12 	b.w	800177c <CPU_SR_Restore>
             break;


                                                                /* ---------------- EXTERNAL INTERRUPT ---------------- */
        default:
            pos_max = CPU_INT_SRC_POS_MAX;
 8001958:	4b17      	ldr	r3, [pc, #92]	; (80019b8 <CPU_IntSrcEn+0xd4>)
 800195a:	4604      	mov	r4, r0
 800195c:	681b      	ldr	r3, [r3, #0]
            if (pos < pos_max) {                                /* See Note #3.                                         */
 800195e:	3301      	adds	r3, #1
 8001960:	f003 031f 	and.w	r3, r3, #31
 8001964:	015b      	lsls	r3, r3, #5
 8001966:	3310      	adds	r3, #16
 8001968:	b2db      	uxtb	r3, r3
 800196a:	4298      	cmp	r0, r3
 800196c:	d2c7      	bcs.n	80018fe <CPU_IntSrcEn+0x1a>
                 group = (pos - 16) / 32;
 800196e:	f1a0 0510 	sub.w	r5, r0, #16
                 nbr   = (pos - 16) % 32;

                 CPU_CRITICAL_ENTER();
 8001972:	f7ff feff 	bl	8001774 <CPU_SR_Save>
                 CPU_REG_NVIC_SETEN(group) = DEF_BIT(nbr);
 8001976:	462b      	mov	r3, r5
 8001978:	2d00      	cmp	r5, #0
 800197a:	bfb8      	it	lt
 800197c:	f104 030f 	addlt.w	r3, r4, #15
 8001980:	4a0e      	ldr	r2, [pc, #56]	; (80019bc <CPU_IntSrcEn+0xd8>)
 8001982:	115b      	asrs	r3, r3, #5
 8001984:	f103 2338 	add.w	r3, r3, #939538432	; 0x38003800
 8001988:	402a      	ands	r2, r5
 800198a:	3340      	adds	r3, #64	; 0x40
 800198c:	2a00      	cmp	r2, #0
 800198e:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001992:	db08      	blt.n	80019a6 <CPU_IntSrcEn+0xc2>
 8001994:	b2d2      	uxtb	r2, r2
 8001996:	2101      	movs	r1, #1
 8001998:	fa01 f202 	lsl.w	r2, r1, r2
 800199c:	601a      	str	r2, [r3, #0]
                 CPU_CRITICAL_EXIT();
             }
             break;
    }
}
 800199e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
                 group = (pos - 16) / 32;
                 nbr   = (pos - 16) % 32;

                 CPU_CRITICAL_ENTER();
                 CPU_REG_NVIC_SETEN(group) = DEF_BIT(nbr);
                 CPU_CRITICAL_EXIT();
 80019a2:	f7ff beeb 	b.w	800177c <CPU_SR_Restore>
            if (pos < pos_max) {                                /* See Note #3.                                         */
                 group = (pos - 16) / 32;
                 nbr   = (pos - 16) % 32;

                 CPU_CRITICAL_ENTER();
                 CPU_REG_NVIC_SETEN(group) = DEF_BIT(nbr);
 80019a6:	3a01      	subs	r2, #1
 80019a8:	f062 021f 	orn	r2, r2, #31
 80019ac:	3201      	adds	r2, #1
 80019ae:	e7f1      	b.n	8001994 <CPU_IntSrcEn+0xb0>
 80019b0:	e000ed24 	.word	0xe000ed24
 80019b4:	e000e010 	.word	0xe000e010
 80019b8:	e000e004 	.word	0xe000e004
 80019bc:	8000001f 	.word	0x8000001f

080019c0 <CPU_IntSrcPendClr>:
    CPU_INT08U  nbr;
    CPU_INT08U  pos_max;
    CPU_SR_ALLOC();


    switch (pos) {
 80019c0:	280f      	cmp	r0, #15
 80019c2:	d928      	bls.n	8001a16 <CPU_IntSrcPendClr+0x56>
*********************************************************************************************************
*/

void  CPU_IntSrcPendClr (CPU_INT08U  pos)

{
 80019c4:	b538      	push	{r3, r4, r5, lr}
        case CPU_INT_USAGEFAULT:                                /* Usage fault.                                         */
        case CPU_INT_SYSTICK:                                   /* SysTick.                                             */
             break;
                                                                /* ---------------- EXTERNAL INTERRUPT ---------------- */
        default:
            pos_max = CPU_INT_SRC_POS_MAX;
 80019c6:	4b17      	ldr	r3, [pc, #92]	; (8001a24 <CPU_IntSrcPendClr+0x64>)
 80019c8:	681b      	ldr	r3, [r3, #0]
            if (pos < pos_max) {                                /* See Note #3.                                         */
 80019ca:	3301      	adds	r3, #1
 80019cc:	f003 031f 	and.w	r3, r3, #31
 80019d0:	015b      	lsls	r3, r3, #5
 80019d2:	3310      	adds	r3, #16
 80019d4:	b2db      	uxtb	r3, r3
 80019d6:	4298      	cmp	r0, r3
 80019d8:	d300      	bcc.n	80019dc <CPU_IntSrcPendClr+0x1c>
 80019da:	bd38      	pop	{r3, r4, r5, pc}
                 group = (pos - 16) / 32;
 80019dc:	f1a0 0510 	sub.w	r5, r0, #16
 80019e0:	4604      	mov	r4, r0
                 nbr   = (pos - 16) % 32;

                 CPU_CRITICAL_ENTER();
 80019e2:	f7ff fec7 	bl	8001774 <CPU_SR_Save>
                 CPU_REG_NVIC_CLRPEND(group) = DEF_BIT(nbr);
 80019e6:	462b      	mov	r3, r5
 80019e8:	2d00      	cmp	r5, #0
 80019ea:	bfb8      	it	lt
 80019ec:	f104 030f 	addlt.w	r3, r4, #15
 80019f0:	4a0d      	ldr	r2, [pc, #52]	; (8001a28 <CPU_IntSrcPendClr+0x68>)
 80019f2:	115b      	asrs	r3, r3, #5
 80019f4:	f103 2338 	add.w	r3, r3, #939538432	; 0x38003800
 80019f8:	402a      	ands	r2, r5
 80019fa:	33a0      	adds	r3, #160	; 0xa0
 80019fc:	2a00      	cmp	r2, #0
 80019fe:	ea4f 0383 	mov.w	r3, r3, lsl #2
 8001a02:	db09      	blt.n	8001a18 <CPU_IntSrcPendClr+0x58>
 8001a04:	b2d2      	uxtb	r2, r2
 8001a06:	2101      	movs	r1, #1
 8001a08:	fa01 f202 	lsl.w	r2, r1, r2
 8001a0c:	601a      	str	r2, [r3, #0]
                 CPU_CRITICAL_EXIT();
             }
             break;
    }
}
 8001a0e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
                 group = (pos - 16) / 32;
                 nbr   = (pos - 16) % 32;

                 CPU_CRITICAL_ENTER();
                 CPU_REG_NVIC_CLRPEND(group) = DEF_BIT(nbr);
                 CPU_CRITICAL_EXIT();
 8001a12:	f7ff beb3 	b.w	800177c <CPU_SR_Restore>
 8001a16:	4770      	bx	lr
            if (pos < pos_max) {                                /* See Note #3.                                         */
                 group = (pos - 16) / 32;
                 nbr   = (pos - 16) % 32;

                 CPU_CRITICAL_ENTER();
                 CPU_REG_NVIC_CLRPEND(group) = DEF_BIT(nbr);
 8001a18:	3a01      	subs	r2, #1
 8001a1a:	f062 021f 	orn	r2, r2, #31
 8001a1e:	3201      	adds	r2, #1
 8001a20:	e7f0      	b.n	8001a04 <CPU_IntSrcPendClr+0x44>
 8001a22:	bf00      	nop
 8001a24:	e000e004 	.word	0xe000e004
 8001a28:	8000001f 	.word	0x8000001f

08001a2c <CPU_IntSrcPrioSet>:
*********************************************************************************************************
*/

void  CPU_IntSrcPrioSet (CPU_INT08U  pos,
                         CPU_INT08U  prio)
{
 8001a2c:	b570      	push	{r4, r5, r6, lr}
 8001a2e:	4604      	mov	r4, r0
    CPU_INT32U  prio_32;
    CPU_INT32U  temp;
    CPU_SR_ALLOC();


    prio_32 = CPU_RevBits((CPU_INT08U)prio);
 8001a30:	4608      	mov	r0, r1
 8001a32:	f7ff feb2 	bl	800179a <CPU_RevBits>
    prio    = (CPU_INT08U)(prio_32 >> (3 * DEF_OCTET_NBR_BITS));
 8001a36:	0e05      	lsrs	r5, r0, #24

    switch (pos) {
 8001a38:	2c0f      	cmp	r4, #15
 8001a3a:	d809      	bhi.n	8001a50 <CPU_IntSrcPrioSet+0x24>
 8001a3c:	e8df f004 	tbb	[pc, r4]
 8001a40:	12121212 	.word	0x12121212
 8001a44:	12392c20 	.word	0x12392c20
 8001a48:	46121212 	.word	0x46121212
 8001a4c:	134e124a 	.word	0x134e124a
             break;


                                                                /* ---------------- EXTERNAL INTERRUPT ---------------- */
        default:
            pos_max = CPU_INT_SRC_POS_MAX;
 8001a50:	4b37      	ldr	r3, [pc, #220]	; (8001b30 <CPU_IntSrcPrioSet+0x104>)
 8001a52:	681b      	ldr	r3, [r3, #0]
            if (pos < pos_max) {                                /* See Note #3.                                         */
 8001a54:	3301      	adds	r3, #1
 8001a56:	f003 031f 	and.w	r3, r3, #31
 8001a5a:	015b      	lsls	r3, r3, #5
 8001a5c:	3310      	adds	r3, #16
 8001a5e:	b2db      	uxtb	r3, r3
 8001a60:	429c      	cmp	r4, r3
 8001a62:	d33f      	bcc.n	8001ae4 <CPU_IntSrcPrioSet+0xb8>
 8001a64:	bd70      	pop	{r4, r5, r6, pc}
             CPU_REG_NVIC_SHPRI3  = temp;
             CPU_CRITICAL_EXIT();
             break;

        case CPU_INT_SYSTICK:                                   /* SysTick.                                             */
             CPU_CRITICAL_ENTER();
 8001a66:	f7ff fe85 	bl	8001774 <CPU_SR_Save>
             temp                 = CPU_REG_NVIC_SHPRI3;
 8001a6a:	4a32      	ldr	r2, [pc, #200]	; (8001b34 <CPU_IntSrcPrioSet+0x108>)
 8001a6c:	6813      	ldr	r3, [r2, #0]
             temp                &= ~((CPU_INT32U)DEF_OCTET_MASK << (3 * DEF_OCTET_NBR_BITS));
 8001a6e:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
             temp                |=  (prio                       << (3 * DEF_OCTET_NBR_BITS));
 8001a72:	ea43 6505 	orr.w	r5, r3, r5, lsl #24
             CPU_REG_NVIC_SHPRI3  = temp;
 8001a76:	6015      	str	r5, [r2, #0]
                 CPU_REG_NVIC_PRIO(group) = temp;
                 CPU_CRITICAL_EXIT();
             }
             break;
    }
}
 8001a78:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
             CPU_CRITICAL_ENTER();
             temp                 = CPU_REG_NVIC_SHPRI3;
             temp                &= ~((CPU_INT32U)DEF_OCTET_MASK << (3 * DEF_OCTET_NBR_BITS));
             temp                |=  (prio                       << (3 * DEF_OCTET_NBR_BITS));
             CPU_REG_NVIC_SHPRI3  = temp;
             CPU_CRITICAL_EXIT();
 8001a7c:	f7ff be7e 	b.w	800177c <CPU_SR_Restore>
        case CPU_INT_NMI:                                       /* Non-maskable interrupt (see Note #2).                */
        case CPU_INT_HFAULT:                                    /* Hard fault (see Note #2).                            */
             break;

        case CPU_INT_MEM:                                       /* Memory management.                                   */
             CPU_CRITICAL_ENTER();
 8001a80:	f7ff fe78 	bl	8001774 <CPU_SR_Save>
             temp                 = CPU_REG_NVIC_SHPRI1;
 8001a84:	4a2c      	ldr	r2, [pc, #176]	; (8001b38 <CPU_IntSrcPrioSet+0x10c>)
             CPU_CRITICAL_EXIT();
             break;

        case CPU_INT_DBGMON:                                    /* Debug monitor.                                       */
             CPU_CRITICAL_ENTER();
             temp                = CPU_REG_NVIC_SHPRI3;
 8001a86:	6813      	ldr	r3, [r2, #0]
             temp                &= ~(DEF_OCTET_MASK << (0 * DEF_OCTET_NBR_BITS));
 8001a88:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
             temp                |=  (prio           << (0 * DEF_OCTET_NBR_BITS));
 8001a8c:	431d      	orrs	r5, r3
             CPU_REG_NVIC_SHPRI3  = temp;
 8001a8e:	6015      	str	r5, [r2, #0]
                 CPU_REG_NVIC_PRIO(group) = temp;
                 CPU_CRITICAL_EXIT();
             }
             break;
    }
}
 8001a90:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
             CPU_CRITICAL_ENTER();
             temp                = CPU_REG_NVIC_SHPRI3;
             temp                &= ~(DEF_OCTET_MASK << (0 * DEF_OCTET_NBR_BITS));
             temp                |=  (prio           << (0 * DEF_OCTET_NBR_BITS));
             CPU_REG_NVIC_SHPRI3  = temp;
             CPU_CRITICAL_EXIT();
 8001a94:	f7ff be72 	b.w	800177c <CPU_SR_Restore>
             CPU_REG_NVIC_SHPRI1  = temp;
             CPU_CRITICAL_EXIT();
             break;

        case CPU_INT_BUSFAULT:                                  /* Bus fault.                                           */
             CPU_CRITICAL_ENTER();
 8001a98:	f7ff fe6c 	bl	8001774 <CPU_SR_Save>
             temp                 = CPU_REG_NVIC_SHPRI1;
 8001a9c:	4a26      	ldr	r2, [pc, #152]	; (8001b38 <CPU_IntSrcPrioSet+0x10c>)
 8001a9e:	6813      	ldr	r3, [r2, #0]
             temp                &= ~(DEF_OCTET_MASK << (1 * DEF_OCTET_NBR_BITS));
 8001aa0:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
             temp                |=  (prio           << (1 * DEF_OCTET_NBR_BITS));
 8001aa4:	ea43 2505 	orr.w	r5, r3, r5, lsl #8
             CPU_REG_NVIC_SHPRI1  = temp;
 8001aa8:	6015      	str	r5, [r2, #0]
                 CPU_REG_NVIC_PRIO(group) = temp;
                 CPU_CRITICAL_EXIT();
             }
             break;
    }
}
 8001aaa:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
             CPU_CRITICAL_ENTER();
             temp                 = CPU_REG_NVIC_SHPRI1;
             temp                &= ~(DEF_OCTET_MASK << (1 * DEF_OCTET_NBR_BITS));
             temp                |=  (prio           << (1 * DEF_OCTET_NBR_BITS));
             CPU_REG_NVIC_SHPRI1  = temp;
             CPU_CRITICAL_EXIT();
 8001aae:	f7ff be65 	b.w	800177c <CPU_SR_Restore>
             break;

        case CPU_INT_USAGEFAULT:                                /* Usage fault.                                         */
             CPU_CRITICAL_ENTER();
 8001ab2:	f7ff fe5f 	bl	8001774 <CPU_SR_Save>
             temp                 = CPU_REG_NVIC_SHPRI1;
 8001ab6:	4a20      	ldr	r2, [pc, #128]	; (8001b38 <CPU_IntSrcPrioSet+0x10c>)
             CPU_CRITICAL_EXIT();
             break;

        case CPU_INT_PENDSV:                                    /* PendSV.                                              */
             CPU_CRITICAL_ENTER();
             temp                 = CPU_REG_NVIC_SHPRI3;
 8001ab8:	6813      	ldr	r3, [r2, #0]
             temp                &= ~(DEF_OCTET_MASK << (2 * DEF_OCTET_NBR_BITS));
 8001aba:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
             temp                |=  (prio           << (2 * DEF_OCTET_NBR_BITS));
 8001abe:	ea43 4505 	orr.w	r5, r3, r5, lsl #16
             CPU_REG_NVIC_SHPRI3  = temp;
 8001ac2:	6015      	str	r5, [r2, #0]
                 CPU_REG_NVIC_PRIO(group) = temp;
                 CPU_CRITICAL_EXIT();
             }
             break;
    }
}
 8001ac4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
             CPU_CRITICAL_ENTER();
             temp                 = CPU_REG_NVIC_SHPRI3;
             temp                &= ~(DEF_OCTET_MASK << (2 * DEF_OCTET_NBR_BITS));
             temp                |=  (prio           << (2 * DEF_OCTET_NBR_BITS));
             CPU_REG_NVIC_SHPRI3  = temp;
             CPU_CRITICAL_EXIT();
 8001ac8:	f7ff be58 	b.w	800177c <CPU_SR_Restore>
             CPU_REG_NVIC_SHPRI1  = temp;
             CPU_CRITICAL_EXIT();
             break;

        case CPU_INT_SVCALL:                                    /* SVCall.                                              */
             CPU_CRITICAL_ENTER();
 8001acc:	f7ff fe52 	bl	8001774 <CPU_SR_Save>
             temp                 = CPU_REG_NVIC_SHPRI2;
 8001ad0:	4a1a      	ldr	r2, [pc, #104]	; (8001b3c <CPU_IntSrcPrioSet+0x110>)
 8001ad2:	e7cb      	b.n	8001a6c <CPU_IntSrcPrioSet+0x40>
             CPU_REG_NVIC_SHPRI2  = temp;
             CPU_CRITICAL_EXIT();
             break;

        case CPU_INT_DBGMON:                                    /* Debug monitor.                                       */
             CPU_CRITICAL_ENTER();
 8001ad4:	f7ff fe4e 	bl	8001774 <CPU_SR_Save>
             temp                = CPU_REG_NVIC_SHPRI3;
 8001ad8:	4a16      	ldr	r2, [pc, #88]	; (8001b34 <CPU_IntSrcPrioSet+0x108>)
 8001ada:	e7d4      	b.n	8001a86 <CPU_IntSrcPrioSet+0x5a>
             CPU_REG_NVIC_SHPRI3  = temp;
             CPU_CRITICAL_EXIT();
             break;

        case CPU_INT_PENDSV:                                    /* PendSV.                                              */
             CPU_CRITICAL_ENTER();
 8001adc:	f7ff fe4a 	bl	8001774 <CPU_SR_Save>
             temp                 = CPU_REG_NVIC_SHPRI3;
 8001ae0:	4a14      	ldr	r2, [pc, #80]	; (8001b34 <CPU_IntSrcPrioSet+0x108>)
 8001ae2:	e7e9      	b.n	8001ab8 <CPU_IntSrcPrioSet+0x8c>

                                                                /* ---------------- EXTERNAL INTERRUPT ---------------- */
        default:
            pos_max = CPU_INT_SRC_POS_MAX;
            if (pos < pos_max) {                                /* See Note #3.                                         */
                 group                    = (pos - 16) / 4;
 8001ae4:	f1a4 0610 	sub.w	r6, r4, #16
                 nbr                      = (pos - 16) % 4;

                 CPU_CRITICAL_ENTER();
 8001ae8:	f7ff fe44 	bl	8001774 <CPU_SR_Save>
                 temp                     = CPU_REG_NVIC_PRIO(group);
 8001aec:	4632      	mov	r2, r6
 8001aee:	2e00      	cmp	r6, #0
 8001af0:	bfb8      	it	lt
 8001af2:	f1a4 020d 	sublt.w	r2, r4, #13
                 temp                    &= ~(DEF_OCTET_MASK << (nbr * DEF_OCTET_NBR_BITS));
 8001af6:	4b12      	ldr	r3, [pc, #72]	; (8001b40 <CPU_IntSrcPrioSet+0x114>)
            if (pos < pos_max) {                                /* See Note #3.                                         */
                 group                    = (pos - 16) / 4;
                 nbr                      = (pos - 16) % 4;

                 CPU_CRITICAL_ENTER();
                 temp                     = CPU_REG_NVIC_PRIO(group);
 8001af8:	f402 727f 	and.w	r2, r2, #1020	; 0x3fc
 8001afc:	f102 4260 	add.w	r2, r2, #3758096384	; 0xe0000000
                 temp                    &= ~(DEF_OCTET_MASK << (nbr * DEF_OCTET_NBR_BITS));
 8001b00:	4033      	ands	r3, r6
            if (pos < pos_max) {                                /* See Note #3.                                         */
                 group                    = (pos - 16) / 4;
                 nbr                      = (pos - 16) % 4;

                 CPU_CRITICAL_ENTER();
                 temp                     = CPU_REG_NVIC_PRIO(group);
 8001b02:	f502 4264 	add.w	r2, r2, #58368	; 0xe400
                 temp                    &= ~(DEF_OCTET_MASK << (nbr * DEF_OCTET_NBR_BITS));
 8001b06:	2b00      	cmp	r3, #0
            if (pos < pos_max) {                                /* See Note #3.                                         */
                 group                    = (pos - 16) / 4;
                 nbr                      = (pos - 16) % 4;

                 CPU_CRITICAL_ENTER();
                 temp                     = CPU_REG_NVIC_PRIO(group);
 8001b08:	6811      	ldr	r1, [r2, #0]
                 temp                    &= ~(DEF_OCTET_MASK << (nbr * DEF_OCTET_NBR_BITS));
 8001b0a:	db0c      	blt.n	8001b26 <CPU_IntSrcPrioSet+0xfa>
 8001b0c:	b2db      	uxtb	r3, r3
 8001b0e:	00db      	lsls	r3, r3, #3
 8001b10:	24ff      	movs	r4, #255	; 0xff
 8001b12:	409c      	lsls	r4, r3
                 temp                    |=  (prio           << (nbr * DEF_OCTET_NBR_BITS));
 8001b14:	409d      	lsls	r5, r3
                 group                    = (pos - 16) / 4;
                 nbr                      = (pos - 16) % 4;

                 CPU_CRITICAL_ENTER();
                 temp                     = CPU_REG_NVIC_PRIO(group);
                 temp                    &= ~(DEF_OCTET_MASK << (nbr * DEF_OCTET_NBR_BITS));
 8001b16:	ea21 0304 	bic.w	r3, r1, r4
                 temp                    |=  (prio           << (nbr * DEF_OCTET_NBR_BITS));
 8001b1a:	431d      	orrs	r5, r3
                 CPU_REG_NVIC_PRIO(group) = temp;
 8001b1c:	6015      	str	r5, [r2, #0]
                 CPU_CRITICAL_EXIT();
             }
             break;
    }
}
 8001b1e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
                 CPU_CRITICAL_ENTER();
                 temp                     = CPU_REG_NVIC_PRIO(group);
                 temp                    &= ~(DEF_OCTET_MASK << (nbr * DEF_OCTET_NBR_BITS));
                 temp                    |=  (prio           << (nbr * DEF_OCTET_NBR_BITS));
                 CPU_REG_NVIC_PRIO(group) = temp;
                 CPU_CRITICAL_EXIT();
 8001b22:	f7ff be2b 	b.w	800177c <CPU_SR_Restore>
                 group                    = (pos - 16) / 4;
                 nbr                      = (pos - 16) % 4;

                 CPU_CRITICAL_ENTER();
                 temp                     = CPU_REG_NVIC_PRIO(group);
                 temp                    &= ~(DEF_OCTET_MASK << (nbr * DEF_OCTET_NBR_BITS));
 8001b26:	3b01      	subs	r3, #1
 8001b28:	f063 0303 	orn	r3, r3, #3
 8001b2c:	3301      	adds	r3, #1
 8001b2e:	e7ed      	b.n	8001b0c <CPU_IntSrcPrioSet+0xe0>
 8001b30:	e000e004 	.word	0xe000e004
 8001b34:	e000ed20 	.word	0xe000ed20
 8001b38:	e000ed18 	.word	0xe000ed18
 8001b3c:	e000ed1c 	.word	0xe000ed1c
 8001b40:	80000003 	.word	0x80000003

08001b44 <CPU_IntSrcPrioGet>:
*               (3) See 'CPU_IntSrcDis()      Note #3'.
*********************************************************************************************************
*/

CPU_INT16S  CPU_IntSrcPrioGet (CPU_INT08U  pos)
{
 8001b44:	b538      	push	{r3, r4, r5, lr}
    CPU_INT32U  prio_32;
    CPU_INT32U  temp;
    CPU_SR_ALLOC();


    switch (pos) {
 8001b46:	280f      	cmp	r0, #15
 8001b48:	d809      	bhi.n	8001b5e <CPU_IntSrcPrioGet+0x1a>
 8001b4a:	e8df f000 	tbb	[pc, r0]
 8001b4e:	3413      	.short	0x3413
 8001b50:	18535015 	.word	0x18535015
 8001b54:	13131325 	.word	0x13131325
 8001b58:	13484013 	.word	0x13484013
 8001b5c:	2c37      	.short	0x2c37
             break;


                                                                /* ---------------- EXTERNAL INTERRUPT ---------------- */
        default:
            pos_max = CPU_INT_SRC_POS_MAX;
 8001b5e:	4b39      	ldr	r3, [pc, #228]	; (8001c44 <CPU_IntSrcPrioGet+0x100>)
 8001b60:	4604      	mov	r4, r0
 8001b62:	681b      	ldr	r3, [r3, #0]
            if (pos < pos_max) {                                /* See Note #3.                                         */
 8001b64:	3301      	adds	r3, #1
 8001b66:	f003 031f 	and.w	r3, r3, #31
 8001b6a:	015b      	lsls	r3, r3, #5
 8001b6c:	3310      	adds	r3, #16
 8001b6e:	b2db      	uxtb	r3, r3
 8001b70:	4298      	cmp	r0, r3
 8001b72:	d347      	bcc.n	8001c04 <CPU_IntSrcPrioGet+0xc0>
                 temp  = CPU_REG_NVIC_PRIO(group);
                 CPU_CRITICAL_EXIT();

                 prio  = (temp >> (nbr * DEF_OCTET_NBR_BITS)) & DEF_OCTET_MASK;
             } else {
                 prio  = DEF_INT_16S_MIN_VAL;
 8001b74:	4834      	ldr	r0, [pc, #208]	; (8001c48 <CPU_IntSrcPrioGet+0x104>)
        prio_32 = CPU_RevBits((CPU_INT32U)prio);
        prio    = (CPU_INT16S)(prio_32 >> (3 * DEF_OCTET_NBR_BITS));
    }

    return (prio);
}
 8001b76:	bd38      	pop	{r3, r4, r5, pc}
        case CPU_INT_RESET:                                     /* Reset (see Note #2).                                 */
             prio = -3;
             break;

        case CPU_INT_NMI:                                       /* Non-maskable interrupt (see Note #2).                */
             prio = -2;
 8001b78:	f06f 0001 	mvn.w	r0, #1
 8001b7c:	bd38      	pop	{r3, r4, r5, pc}
             CPU_CRITICAL_EXIT();
             break;


        case CPU_INT_BUSFAULT:                                  /* Bus fault.                                           */
             CPU_CRITICAL_ENTER();
 8001b7e:	f7ff fdf9 	bl	8001774 <CPU_SR_Save>
             temp = CPU_REG_NVIC_SHPRI1;
 8001b82:	4b32      	ldr	r3, [pc, #200]	; (8001c4c <CPU_IntSrcPrioGet+0x108>)
 8001b84:	681c      	ldr	r4, [r3, #0]
             prio = (temp >> (1 * DEF_OCTET_NBR_BITS)) & DEF_OCTET_MASK;
 8001b86:	f3c4 2407 	ubfx	r4, r4, #8, #8
             CPU_CRITICAL_EXIT();
 8001b8a:	f7ff fdf7 	bl	800177c <CPU_SR_Restore>
             }
             break;
    }

    if (prio >= 0) {
        prio_32 = CPU_RevBits((CPU_INT32U)prio);
 8001b8e:	4620      	mov	r0, r4
 8001b90:	f7ff fe03 	bl	800179a <CPU_RevBits>
        prio    = (CPU_INT16S)(prio_32 >> (3 * DEF_OCTET_NBR_BITS));
 8001b94:	0e00      	lsrs	r0, r0, #24
 8001b96:	bd38      	pop	{r3, r4, r5, pc}
             CPU_CRITICAL_EXIT();
             break;


        case CPU_INT_USAGEFAULT:                                /* Usage fault.                                         */
             CPU_CRITICAL_ENTER();
 8001b98:	f7ff fdec 	bl	8001774 <CPU_SR_Save>
             temp = CPU_REG_NVIC_SHPRI1;
 8001b9c:	4b2b      	ldr	r3, [pc, #172]	; (8001c4c <CPU_IntSrcPrioGet+0x108>)
 8001b9e:	681c      	ldr	r4, [r3, #0]
             prio = (temp >> (2 * DEF_OCTET_NBR_BITS)) & DEF_OCTET_MASK;
 8001ba0:	f3c4 4407 	ubfx	r4, r4, #16, #8
             break;
 8001ba4:	e7f3      	b.n	8001b8e <CPU_IntSrcPrioGet+0x4a>
             prio = (temp >> (2 * DEF_OCTET_NBR_BITS)) & DEF_OCTET_MASK;
             CPU_CRITICAL_EXIT();
             break;

        case CPU_INT_SYSTICK:                                   /* SysTick.                                             */
             CPU_CRITICAL_ENTER();
 8001ba6:	f7ff fde5 	bl	8001774 <CPU_SR_Save>
             temp = CPU_REG_NVIC_SHPRI3;
 8001baa:	4b29      	ldr	r3, [pc, #164]	; (8001c50 <CPU_IntSrcPrioGet+0x10c>)
 8001bac:	681c      	ldr	r4, [r3, #0]
             prio = (temp >> (3 * DEF_OCTET_NBR_BITS)) & DEF_OCTET_MASK;
 8001bae:	0e24      	lsrs	r4, r4, #24
             CPU_CRITICAL_EXIT();
 8001bb0:	f7ff fde4 	bl	800177c <CPU_SR_Restore>
             break;
 8001bb4:	e7eb      	b.n	8001b8e <CPU_IntSrcPrioGet+0x4a>
             break;


                                                                /* ----------------- SYSTEM EXCEPTIONS ---------------- */
        case CPU_INT_RESET:                                     /* Reset (see Note #2).                                 */
             prio = -3;
 8001bb6:	f06f 0002 	mvn.w	r0, #2
 8001bba:	bd38      	pop	{r3, r4, r5, pc}
             prio = (temp >> (0 * DEF_OCTET_NBR_BITS)) & DEF_OCTET_MASK;
             CPU_CRITICAL_EXIT();
             break;

        case CPU_INT_PENDSV:                                    /* PendSV.                                              */
             CPU_CRITICAL_ENTER();
 8001bbc:	f7ff fdda 	bl	8001774 <CPU_SR_Save>
             temp = CPU_REG_NVIC_SHPRI3;
 8001bc0:	4b23      	ldr	r3, [pc, #140]	; (8001c50 <CPU_IntSrcPrioGet+0x10c>)
 8001bc2:	681c      	ldr	r4, [r3, #0]
             prio = (temp >> (2 * DEF_OCTET_NBR_BITS)) & DEF_OCTET_MASK;
 8001bc4:	f3c4 4407 	ubfx	r4, r4, #16, #8
             CPU_CRITICAL_EXIT();
 8001bc8:	f7ff fdd8 	bl	800177c <CPU_SR_Restore>
             break;
 8001bcc:	e7df      	b.n	8001b8e <CPU_IntSrcPrioGet+0x4a>
             temp = CPU_REG_NVIC_SHPRI1;
             prio = (temp >> (2 * DEF_OCTET_NBR_BITS)) & DEF_OCTET_MASK;
             break;

        case CPU_INT_SVCALL:                                    /* SVCall.                                              */
             CPU_CRITICAL_ENTER();
 8001bce:	f7ff fdd1 	bl	8001774 <CPU_SR_Save>
             temp = CPU_REG_NVIC_SHPRI2;
 8001bd2:	4b20      	ldr	r3, [pc, #128]	; (8001c54 <CPU_IntSrcPrioGet+0x110>)
 8001bd4:	681c      	ldr	r4, [r3, #0]
             prio = (temp >> (3 * DEF_OCTET_NBR_BITS)) & DEF_OCTET_MASK;
 8001bd6:	0e24      	lsrs	r4, r4, #24
             CPU_CRITICAL_EXIT();
 8001bd8:	f7ff fdd0 	bl	800177c <CPU_SR_Restore>
             break;
 8001bdc:	e7d7      	b.n	8001b8e <CPU_IntSrcPrioGet+0x4a>

        case CPU_INT_DBGMON:                                    /* Debug monitor.                                       */
             CPU_CRITICAL_ENTER();
 8001bde:	f7ff fdc9 	bl	8001774 <CPU_SR_Save>
             temp = CPU_REG_NVIC_SHPRI3;
 8001be2:	4b1b      	ldr	r3, [pc, #108]	; (8001c50 <CPU_IntSrcPrioGet+0x10c>)
 8001be4:	681c      	ldr	r4, [r3, #0]
             prio = (temp >> (0 * DEF_OCTET_NBR_BITS)) & DEF_OCTET_MASK;
 8001be6:	b2e4      	uxtb	r4, r4
             CPU_CRITICAL_EXIT();
 8001be8:	f7ff fdc8 	bl	800177c <CPU_SR_Restore>
             break;
 8001bec:	e7cf      	b.n	8001b8e <CPU_IntSrcPrioGet+0x4a>
        case CPU_INT_NMI:                                       /* Non-maskable interrupt (see Note #2).                */
             prio = -2;
             break;

        case CPU_INT_HFAULT:                                    /* Hard fault (see Note #2).                            */
             prio = -1;
 8001bee:	f04f 30ff 	mov.w	r0, #4294967295
             break;
 8001bf2:	bd38      	pop	{r3, r4, r5, pc}


        case CPU_INT_MEM:                                       /* Memory management.                                   */
             CPU_CRITICAL_ENTER();
 8001bf4:	f7ff fdbe 	bl	8001774 <CPU_SR_Save>
             temp = CPU_REG_NVIC_SHPRI1;
 8001bf8:	4b14      	ldr	r3, [pc, #80]	; (8001c4c <CPU_IntSrcPrioGet+0x108>)
 8001bfa:	681c      	ldr	r4, [r3, #0]
             prio = (temp >> (0 * DEF_OCTET_NBR_BITS)) & DEF_OCTET_MASK;
 8001bfc:	b2e4      	uxtb	r4, r4
             CPU_CRITICAL_EXIT();
 8001bfe:	f7ff fdbd 	bl	800177c <CPU_SR_Restore>
             break;
 8001c02:	e7c4      	b.n	8001b8e <CPU_IntSrcPrioGet+0x4a>

                                                                /* ---------------- EXTERNAL INTERRUPT ---------------- */
        default:
            pos_max = CPU_INT_SRC_POS_MAX;
            if (pos < pos_max) {                                /* See Note #3.                                         */
                 group = (pos - 16) / 4;
 8001c04:	f1a0 0510 	sub.w	r5, r0, #16
                 nbr   = (pos - 16) % 4;

                 CPU_CRITICAL_ENTER();
 8001c08:	f7ff fdb4 	bl	8001774 <CPU_SR_Save>
                 temp  = CPU_REG_NVIC_PRIO(group);
 8001c0c:	462b      	mov	r3, r5
 8001c0e:	2d00      	cmp	r5, #0
 8001c10:	bfb8      	it	lt
 8001c12:	f1a4 030d 	sublt.w	r3, r4, #13
 8001c16:	f403 737f 	and.w	r3, r3, #1020	; 0x3fc
 8001c1a:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
 8001c1e:	f503 4364 	add.w	r3, r3, #58368	; 0xe400
 8001c22:	681c      	ldr	r4, [r3, #0]
                 CPU_CRITICAL_EXIT();
 8001c24:	f7ff fdaa 	bl	800177c <CPU_SR_Restore>

                 prio  = (temp >> (nbr * DEF_OCTET_NBR_BITS)) & DEF_OCTET_MASK;
 8001c28:	4b0b      	ldr	r3, [pc, #44]	; (8001c58 <CPU_IntSrcPrioGet+0x114>)
 8001c2a:	402b      	ands	r3, r5
 8001c2c:	2b00      	cmp	r3, #0
 8001c2e:	db04      	blt.n	8001c3a <CPU_IntSrcPrioGet+0xf6>
 8001c30:	b2db      	uxtb	r3, r3
 8001c32:	00db      	lsls	r3, r3, #3
 8001c34:	40dc      	lsrs	r4, r3
 8001c36:	b2e4      	uxtb	r4, r4
 8001c38:	e7a9      	b.n	8001b8e <CPU_IntSrcPrioGet+0x4a>
 8001c3a:	3b01      	subs	r3, #1
 8001c3c:	f063 0303 	orn	r3, r3, #3
 8001c40:	3301      	adds	r3, #1
 8001c42:	e7f5      	b.n	8001c30 <CPU_IntSrcPrioGet+0xec>
 8001c44:	e000e004 	.word	0xe000e004
 8001c48:	ffff8000 	.word	0xffff8000
 8001c4c:	e000ed18 	.word	0xe000ed18
 8001c50:	e000ed20 	.word	0xe000ed20
 8001c54:	e000ed1c 	.word	0xe000ed1c
 8001c58:	80000003 	.word	0x80000003

08001c5c <CPU_SW_Exception>:
*                   See also 'cpu_core.h  CPU_SW_EXCEPTION()  Note #1'.
*********************************************************************************************************
*/

void  CPU_SW_Exception (void)
{
 8001c5c:	e7fe      	b.n	8001c5c <CPU_SW_Exception>
 8001c5e:	bf00      	nop

08001c60 <CPU_NameClr>:
*********************************************************************************************************
*/

#if (CPU_CFG_NAME_EN == DEF_ENABLED)
void  CPU_NameClr (void)
{
 8001c60:	b510      	push	{r4, lr}
    CPU_SR_ALLOC();


    CPU_CRITICAL_ENTER();
 8001c62:	f7ff fd87 	bl	8001774 <CPU_SR_Save>
 8001c66:	4604      	mov	r4, r0
    Mem_Clr((void     *)&CPU_Name[0],
 8001c68:	2110      	movs	r1, #16
 8001c6a:	4804      	ldr	r0, [pc, #16]	; (8001c7c <CPU_NameClr+0x1c>)
 8001c6c:	f000 fad6 	bl	800221c <Mem_Clr>
            (CPU_SIZE_T) CPU_CFG_NAME_SIZE);
    CPU_CRITICAL_EXIT();
 8001c70:	4620      	mov	r0, r4
}
 8001c72:	e8bd 4010 	ldmia.w	sp!, {r4, lr}


    CPU_CRITICAL_ENTER();
    Mem_Clr((void     *)&CPU_Name[0],
            (CPU_SIZE_T) CPU_CFG_NAME_SIZE);
    CPU_CRITICAL_EXIT();
 8001c76:	f7ff bd81 	b.w	800177c <CPU_SR_Restore>
 8001c7a:	bf00      	nop
 8001c7c:	2000b2c8 	.word	0x2000b2c8

08001c80 <CPU_Init>:
*                                                   & other CPU interrupts disabled time measurement functions
*********************************************************************************************************
*/

void  CPU_Init (void)
{
 8001c80:	b508      	push	{r3, lr}
#endif


                                                                /* ----------------- INIT CPU TS TMR ------------------ */
#if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)
    CPU_TS_TmrFreq_Hz   = 0u;                                   /* Init/clr     ts tmr freq (see Note #1a).             */
 8001c82:	4b04      	ldr	r3, [pc, #16]	; (8001c94 <CPU_Init+0x14>)
 8001c84:	2200      	movs	r2, #0
 8001c86:	601a      	str	r2, [r3, #0]
    CPU_TS_TmrInit();                                           /* Init & start ts tmr      (see Note #1b).             */
 8001c88:	f7fe ff62 	bl	8000b50 <CPU_TS_TmrInit>

                                                                /* ------------------ INIT CPU NAME ------------------- */
#if (CPU_CFG_NAME_EN == DEF_ENABLED)
     CPU_NameInit();
#endif
}
 8001c8c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
*/

#if (CPU_CFG_NAME_EN == DEF_ENABLED)
static  void  CPU_NameInit (void)
{
    CPU_NameClr();
 8001c90:	f7ff bfe6 	b.w	8001c60 <CPU_NameClr>
 8001c94:	2000b2c4 	.word	0x2000b2c4

08001c98 <CPU_NameGet>:
                   CPU_ERR   *p_err)
{
    CPU_SR_ALLOC();


    if (p_err == (CPU_ERR *)0) {
 8001c98:	b189      	cbz	r1, 8001cbe <CPU_NameGet+0x26>
        CPU_SW_EXCEPTION(;);
    }

    if (p_name == (CPU_CHAR *)0) {
 8001c9a:	b188      	cbz	r0, 8001cc0 <CPU_NameGet+0x28>
*/

#if (CPU_CFG_NAME_EN == DEF_ENABLED)
void  CPU_NameGet (CPU_CHAR  *p_name,
                   CPU_ERR   *p_err)
{
 8001c9c:	b570      	push	{r4, r5, r6, lr}
 8001c9e:	460c      	mov	r4, r1
 8001ca0:	4605      	mov	r5, r0
    if (p_name == (CPU_CHAR *)0) {
       *p_err = CPU_ERR_NULL_PTR;
        return;
    }

    CPU_CRITICAL_ENTER();
 8001ca2:	f7ff fd67 	bl	8001774 <CPU_SR_Save>
 8001ca6:	4606      	mov	r6, r0
   (void)Str_Copy_N(p_name,
 8001ca8:	2210      	movs	r2, #16
 8001caa:	4907      	ldr	r1, [pc, #28]	; (8001cc8 <CPU_NameGet+0x30>)
 8001cac:	4628      	mov	r0, r5
 8001cae:	f001 fb1b 	bl	80032e8 <Str_Copy_N>
                   &CPU_Name[0],
                    CPU_CFG_NAME_SIZE);
    CPU_CRITICAL_EXIT();
 8001cb2:	4630      	mov	r0, r6
 8001cb4:	f7ff fd62 	bl	800177c <CPU_SR_Restore>

   *p_err = CPU_ERR_NONE;
 8001cb8:	2300      	movs	r3, #0
 8001cba:	8023      	strh	r3, [r4, #0]
 8001cbc:	bd70      	pop	{r4, r5, r6, pc}
 8001cbe:	e7fe      	b.n	8001cbe <CPU_NameGet+0x26>
    if (p_err == (CPU_ERR *)0) {
        CPU_SW_EXCEPTION(;);
    }

    if (p_name == (CPU_CHAR *)0) {
       *p_err = CPU_ERR_NULL_PTR;
 8001cc0:	230a      	movs	r3, #10
 8001cc2:	800b      	strh	r3, [r1, #0]
 8001cc4:	4770      	bx	lr
 8001cc6:	bf00      	nop
 8001cc8:	2000b2c8 	.word	0x2000b2c8

08001ccc <CPU_NameSet>:
{
    CPU_SIZE_T  len;
    CPU_SR_ALLOC();


    if (p_err == (CPU_ERR *)0) {
 8001ccc:	b161      	cbz	r1, 8001ce8 <CPU_NameSet+0x1c>
        CPU_SW_EXCEPTION(;);
    }

    if (p_name == (const CPU_CHAR *)0) {
 8001cce:	b160      	cbz	r0, 8001cea <CPU_NameSet+0x1e>
*/

#if (CPU_CFG_NAME_EN == DEF_ENABLED)
void  CPU_NameSet (const  CPU_CHAR  *p_name,
                          CPU_ERR   *p_err)
{
 8001cd0:	b570      	push	{r4, r5, r6, lr}
 8001cd2:	460c      	mov	r4, r1
    if (p_name == (const CPU_CHAR *)0) {
       *p_err = CPU_ERR_NULL_PTR;
        return;
    }

    len = Str_Len_N(p_name,
 8001cd4:	2110      	movs	r1, #16
 8001cd6:	4605      	mov	r5, r0
 8001cd8:	f001 faee 	bl	80032b8 <Str_Len_N>
                    CPU_CFG_NAME_SIZE);
    if (len < CPU_CFG_NAME_SIZE) {                              /* If       cfg name len < max name size, ...           */
 8001cdc:	280f      	cmp	r0, #15
 8001cde:	d907      	bls.n	8001cf0 <CPU_NameSet+0x24>
                         CPU_CFG_NAME_SIZE);
        CPU_CRITICAL_EXIT();
       *p_err = CPU_ERR_NONE;

    } else {
       *p_err = CPU_ERR_NAME_SIZE;
 8001ce0:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8001ce4:	8023      	strh	r3, [r4, #0]
 8001ce6:	bd70      	pop	{r4, r5, r6, pc}
 8001ce8:	e7fe      	b.n	8001ce8 <CPU_NameSet+0x1c>
    if (p_err == (CPU_ERR *)0) {
        CPU_SW_EXCEPTION(;);
    }

    if (p_name == (const CPU_CHAR *)0) {
       *p_err = CPU_ERR_NULL_PTR;
 8001cea:	230a      	movs	r3, #10
 8001cec:	800b      	strh	r3, [r1, #0]
 8001cee:	4770      	bx	lr
    }

    len = Str_Len_N(p_name,
                    CPU_CFG_NAME_SIZE);
    if (len < CPU_CFG_NAME_SIZE) {                              /* If       cfg name len < max name size, ...           */
        CPU_CRITICAL_ENTER();
 8001cf0:	f7ff fd40 	bl	8001774 <CPU_SR_Save>
 8001cf4:	4606      	mov	r6, r0
       (void)Str_Copy_N(&CPU_Name[0],                           /* ... copy cfg name to CPU host name.                  */
 8001cf6:	4629      	mov	r1, r5
 8001cf8:	2210      	movs	r2, #16
 8001cfa:	4804      	ldr	r0, [pc, #16]	; (8001d0c <CPU_NameSet+0x40>)
 8001cfc:	f001 faf4 	bl	80032e8 <Str_Copy_N>
                         p_name,
                         CPU_CFG_NAME_SIZE);
        CPU_CRITICAL_EXIT();
 8001d00:	4630      	mov	r0, r6
 8001d02:	f7ff fd3b 	bl	800177c <CPU_SR_Restore>
       *p_err = CPU_ERR_NONE;
 8001d06:	2300      	movs	r3, #0
 8001d08:	8023      	strh	r3, [r4, #0]
 8001d0a:	bd70      	pop	{r4, r5, r6, pc}
 8001d0c:	2000b2c8 	.word	0x2000b2c8

08001d10 <CPU_TS_Get32>:
    CPU_SR_ALLOC();
#endif


#if (CPU_CFG_TS_TMR_SIZE >= CPU_WORD_SIZE_32)
    ts = (CPU_TS32)CPU_TS_TmrRd();                                  /* Get cur ts tmr val (in 32-bit ts cnts).          */
 8001d10:	f7fe bf3c 	b.w	8000b8c <CPU_TS_TmrRd>

08001d14 <CPU_TS_Update>:
*********************************************************************************************************
*/

#if (CPU_CFG_TS_EN == DEF_ENABLED)
void  CPU_TS_Update (void)
{
 8001d14:	4770      	bx	lr
 8001d16:	bf00      	nop

08001d18 <CPU_TS_TmrFreqGet>:
CPU_TS_TMR_FREQ  CPU_TS_TmrFreqGet (CPU_ERR  *p_err)
{
    CPU_TS_TMR_FREQ  freq_hz;


    if (p_err == (CPU_ERR *)0) {
 8001d18:	4603      	mov	r3, r0
 8001d1a:	b140      	cbz	r0, 8001d2e <CPU_TS_TmrFreqGet+0x16>
        CPU_SW_EXCEPTION(;);
    }

    freq_hz =  CPU_TS_TmrFreq_Hz;
 8001d1c:	4a04      	ldr	r2, [pc, #16]	; (8001d30 <CPU_TS_TmrFreqGet+0x18>)
 8001d1e:	6810      	ldr	r0, [r2, #0]
   *p_err   = (freq_hz != 0u) ? CPU_ERR_NONE : CPU_ERR_TS_FREQ_INVALID;
 8001d20:	2800      	cmp	r0, #0
 8001d22:	bf14      	ite	ne
 8001d24:	2200      	movne	r2, #0
 8001d26:	f44f 62fa 	moveq.w	r2, #2000	; 0x7d0
 8001d2a:	801a      	strh	r2, [r3, #0]

    return (freq_hz);
}
 8001d2c:	4770      	bx	lr
 8001d2e:	e7fe      	b.n	8001d2e <CPU_TS_TmrFreqGet+0x16>
 8001d30:	2000b2c4 	.word	0x2000b2c4

08001d34 <CPU_TS_TmrFreqSet>:
*/

#if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)
void  CPU_TS_TmrFreqSet (CPU_TS_TMR_FREQ  freq_hz)
{
    CPU_TS_TmrFreq_Hz = freq_hz;
 8001d34:	4b01      	ldr	r3, [pc, #4]	; (8001d3c <CPU_TS_TmrFreqSet+0x8>)
 8001d36:	6018      	str	r0, [r3, #0]
 8001d38:	4770      	bx	lr
 8001d3a:	bf00      	nop
 8001d3c:	2000b2c4 	.word	0x2000b2c4

08001d40 <CPU_CntLeadZeros08>:
*********************************************************************************************************
*/

#if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_08)
CPU_DATA  CPU_CntLeadZeros08 (CPU_INT08U  val)
{
 8001d40:	b508      	push	{r3, lr}
    CPU_DATA  nbr_lead_zeros;

                                                                                /* ---------- ASM-OPTIMIZED ----------- */
#if ((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
     (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_08))
    nbr_lead_zeros  =  CPU_CntLeadZeros((CPU_DATA)val);
 8001d42:	f7ff fd22 	bl	800178a <CPU_CntLeadZeros>
    nbr_lead_zeros  = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] +  0u);                /* .. plus nbr msb lead zeros =  0 bits.*/
#endif


    return (nbr_lead_zeros);
}
 8001d46:	3818      	subs	r0, #24
 8001d48:	bd08      	pop	{r3, pc}
 8001d4a:	bf00      	nop

08001d4c <CPU_CntLeadZeros16>:
*********************************************************************************************************
*/

#if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_16)
CPU_DATA  CPU_CntLeadZeros16 (CPU_INT16U  val)
{
 8001d4c:	b508      	push	{r3, lr}
    CPU_DATA  nbr_lead_zeros;

                                                                                /* ---------- ASM-OPTIMIZED ----------- */
#if ((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
     (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_16))
    nbr_lead_zeros  =  CPU_CntLeadZeros((CPU_DATA)val);
 8001d4e:	f7ff fd1c 	bl	800178a <CPU_CntLeadZeros>
    }
#endif


    return (nbr_lead_zeros);
}
 8001d52:	3810      	subs	r0, #16
 8001d54:	bd08      	pop	{r3, pc}
 8001d56:	bf00      	nop

08001d58 <CPU_CntLeadZeros32>:
    CPU_DATA  nbr_lead_zeros;

                                                                                /* ---------- ASM-OPTIMIZED ----------- */
#if ((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
     (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_32))
    nbr_lead_zeros  =  CPU_CntLeadZeros((CPU_DATA)val);
 8001d58:	f7ff bd17 	b.w	800178a <CPU_CntLeadZeros>

08001d5c <CPU_CntLeadZeros64>:
    nbr_lead_zeros  =  CPU_CntLeadZeros((CPU_DATA)val);
    nbr_lead_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_64) * DEF_OCTET_NBR_BITS;


#else                                                                           /* ----------- C-OPTIMIZED ------------ */
    if (val > 0x00000000FFFFFFFFu) {
 8001d5c:	2901      	cmp	r1, #1
 8001d5e:	bf08      	it	eq
 8001d60:	2800      	cmpeq	r0, #0
 8001d62:	d30d      	bcc.n	8001d80 <CPU_CntLeadZeros64+0x24>
        if (val > 0x0000FFFFFFFFFFFFu) {
 8001d64:	f5b1 3f80 	cmp.w	r1, #65536	; 0x10000
 8001d68:	bf08      	it	eq
 8001d6a:	2800      	cmpeq	r0, #0
 8001d6c:	d323      	bcc.n	8001db6 <CPU_CntLeadZeros64+0x5a>
            if (val > 0x00FFFFFFFFFFFFFFu) {                                    /* Chk bits [63:56] :                   */
 8001d6e:	f1b1 7f80 	cmp.w	r1, #16777216	; 0x1000000
 8001d72:	bf08      	it	eq
 8001d74:	2800      	cmpeq	r0, #0
                                                                                /* .. Nbr lead zeros =               .. */
                ix             = (CPU_DATA)(val >> 56u);                        /* .. lookup tbl ix  = 'val' >> 56 bits */
                nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] +  0u);     /* .. plus nbr msb lead zeros =  0 bits.*/
 8001d76:	4a20      	ldr	r2, [pc, #128]	; (8001df8 <CPU_CntLeadZeros64+0x9c>)


#else                                                                           /* ----------- C-OPTIMIZED ------------ */
    if (val > 0x00000000FFFFFFFFu) {
        if (val > 0x0000FFFFFFFFFFFFu) {
            if (val > 0x00FFFFFFFFFFFFFFu) {                                    /* Chk bits [63:56] :                   */
 8001d78:	d327      	bcc.n	8001dca <CPU_CntLeadZeros64+0x6e>
                                                                                /* .. Nbr lead zeros =               .. */
                ix             = (CPU_DATA)(val >> 56u);                        /* .. lookup tbl ix  = 'val' >> 56 bits */
                nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] +  0u);     /* .. plus nbr msb lead zeros =  0 bits.*/
 8001d7a:	0e0b      	lsrs	r3, r1, #24
 8001d7c:	5cd0      	ldrb	r0, [r2, r3]
 8001d7e:	4770      	bx	lr
                nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] + 24u);     /* .. plus nbr msb lead zeros = 24 bits.*/
            }
        }

    } else {
        if (val > 0x000000000000FFFFu) {
 8001d80:	2900      	cmp	r1, #0
 8001d82:	bf08      	it	eq
 8001d84:	f5b0 3f80 	cmpeq.w	r0, #65536	; 0x10000
 8001d88:	d30b      	bcc.n	8001da2 <CPU_CntLeadZeros64+0x46>
            if (val > 0x0000000000FFFFFFu) {                                    /* Chk bits [31:24] :                   */
 8001d8a:	2900      	cmp	r1, #0
 8001d8c:	bf08      	it	eq
 8001d8e:	f1b0 7f80 	cmpeq.w	r0, #16777216	; 0x1000000
 8001d92:	d323      	bcc.n	8001ddc <CPU_CntLeadZeros64+0x80>
                                                                                /* .. Nbr lead zeros =               .. */
                ix             = (CPU_DATA)(val >> 24u);                        /* .. lookup tbl ix  = 'val' >> 24 bits */
                nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] + 32u);     /* .. plus nbr msb lead zeros = 32 bits.*/
 8001d94:	0e03      	lsrs	r3, r0, #24
 8001d96:	4a18      	ldr	r2, [pc, #96]	; (8001df8 <CPU_CntLeadZeros64+0x9c>)
 8001d98:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8001d9c:	5cd0      	ldrb	r0, [r2, r3]
 8001d9e:	3020      	adds	r0, #32
 8001da0:	4770      	bx	lr
                ix             = (CPU_DATA)(val >> 16u);                        /* .. lookup tbl ix  = 'val' >> 16 bits */
                nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] + 40u);     /* .. plus nbr msb lead zeros = 40 bits.*/
            }

        } else {
            if (val > 0x00000000000000FFu) {                                    /* Chk bits [15:08] :                   */
 8001da2:	2900      	cmp	r1, #0
 8001da4:	bf08      	it	eq
 8001da6:	f5b0 7f80 	cmpeq.w	r0, #256	; 0x100
 8001daa:	d21e      	bcs.n	8001dea <CPU_CntLeadZeros64+0x8e>
                nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] + 48u);     /* .. plus nbr msb lead zeros = 48 bits.*/

            } else {                                                            /* Chk bits [07:00] :                   */
                                                                                /* .. Nbr lead zeros =               .. */
                ix             = (CPU_DATA)(val >>  0u);                        /* .. lookup tbl ix  = 'val' >>  0 bits */
                nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] + 56u);     /* .. plus nbr msb lead zeros = 56 bits.*/
 8001dac:	4b12      	ldr	r3, [pc, #72]	; (8001df8 <CPU_CntLeadZeros64+0x9c>)
 8001dae:	4418      	add	r0, r3
 8001db0:	7800      	ldrb	r0, [r0, #0]
 8001db2:	3038      	adds	r0, #56	; 0x38
    }
#endif


    return (nbr_lead_zeros);
}
 8001db4:	4770      	bx	lr
                ix             = (CPU_DATA)(val >> 48u);                        /* .. lookup tbl ix  = 'val' >> 48 bits */
                nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] +  8u);     /* .. plus nbr msb lead zeros =  8 bits.*/
            }

        } else {
            if (val > 0x000000FFFFFFFFFFu) {                                    /* Chk bits [47:40] :                   */
 8001db6:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 8001dba:	bf08      	it	eq
 8001dbc:	2800      	cmpeq	r0, #0
 8001dbe:	d308      	bcc.n	8001dd2 <CPU_CntLeadZeros64+0x76>
                                                                                /* .. Nbr lead zeros =               .. */
                ix             = (CPU_DATA)(val >> 40u);                        /* .. lookup tbl ix  = 'val' >> 40 bits */
                nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] + 16u);     /* .. plus nbr msb lead zeros = 16 bits.*/
 8001dc0:	4a0d      	ldr	r2, [pc, #52]	; (8001df8 <CPU_CntLeadZeros64+0x9c>)
 8001dc2:	0a0b      	lsrs	r3, r1, #8
 8001dc4:	5cd0      	ldrb	r0, [r2, r3]
 8001dc6:	3010      	adds	r0, #16
 8001dc8:	4770      	bx	lr
                nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] +  0u);     /* .. plus nbr msb lead zeros =  0 bits.*/

            } else {                                                            /* Chk bits [55:48] :                   */
                                                                                /* .. Nbr lead zeros =               .. */
                ix             = (CPU_DATA)(val >> 48u);                        /* .. lookup tbl ix  = 'val' >> 48 bits */
                nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] +  8u);     /* .. plus nbr msb lead zeros =  8 bits.*/
 8001dca:	0c0b      	lsrs	r3, r1, #16
 8001dcc:	5cd0      	ldrb	r0, [r2, r3]
 8001dce:	3008      	adds	r0, #8
 8001dd0:	4770      	bx	lr
                nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] + 16u);     /* .. plus nbr msb lead zeros = 16 bits.*/

            } else {                                                            /* Chk bits [39:32] :                   */
                                                                                /* .. Nbr lead zeros =               .. */
                ix             = (CPU_DATA)(val >> 32u);                        /* .. lookup tbl ix  = 'val' >> 32 bits */
                nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] + 24u);     /* .. plus nbr msb lead zeros = 24 bits.*/
 8001dd2:	4b09      	ldr	r3, [pc, #36]	; (8001df8 <CPU_CntLeadZeros64+0x9c>)
 8001dd4:	440b      	add	r3, r1
 8001dd6:	7818      	ldrb	r0, [r3, #0]
 8001dd8:	3018      	adds	r0, #24
 8001dda:	4770      	bx	lr
                nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] + 32u);     /* .. plus nbr msb lead zeros = 32 bits.*/

            } else {                                                            /* Chk bits [23:16] :                   */
                                                                                /* .. Nbr lead zeros =               .. */
                ix             = (CPU_DATA)(val >> 16u);                        /* .. lookup tbl ix  = 'val' >> 16 bits */
                nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] + 40u);     /* .. plus nbr msb lead zeros = 40 bits.*/
 8001ddc:	0c03      	lsrs	r3, r0, #16
 8001dde:	4a06      	ldr	r2, [pc, #24]	; (8001df8 <CPU_CntLeadZeros64+0x9c>)
 8001de0:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8001de4:	5cd0      	ldrb	r0, [r2, r3]
 8001de6:	3028      	adds	r0, #40	; 0x28
 8001de8:	4770      	bx	lr

        } else {
            if (val > 0x00000000000000FFu) {                                    /* Chk bits [15:08] :                   */
                                                                                /* .. Nbr lead zeros =               .. */
                ix             = (CPU_DATA)(val >>  8u);                        /* .. lookup tbl ix  = 'val' >>  8 bits */
                nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] + 48u);     /* .. plus nbr msb lead zeros = 48 bits.*/
 8001dea:	0a03      	lsrs	r3, r0, #8
 8001dec:	4a02      	ldr	r2, [pc, #8]	; (8001df8 <CPU_CntLeadZeros64+0x9c>)
 8001dee:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 8001df2:	5cd0      	ldrb	r0, [r2, r3]
 8001df4:	3030      	adds	r0, #48	; 0x30
 8001df6:	4770      	bx	lr
 8001df8:	08015ef8 	.word	0x08015ef8

08001dfc <CPU_CntTrailZeros08>:
    CPU_DATA    nbr_lead_zeros;
#endif
    CPU_DATA    nbr_trail_zeros;


    if (val == 0u) {                                            /* Rtn ALL val bits as zero'd (see Note #3).            */
 8001dfc:	b908      	cbnz	r0, 8001e02 <CPU_CntTrailZeros08+0x6>
    nbr_trail_zeros = ((CPU_WORD_SIZE_08 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
#endif


    return (nbr_trail_zeros);
}
 8001dfe:	2008      	movs	r0, #8
 8001e00:	4770      	bx	lr
    }

                                                                /* ------------------ ASM-OPTIMIZED ------------------- */
#if ((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
     (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_08))
    nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
 8001e02:	f7ff bcc5 	b.w	8001790 <CPU_CntTrailZeros>
 8001e06:	bf00      	nop

08001e08 <CPU_CntTrailZeros16>:
    CPU_DATA    nbr_lead_zeros;
#endif
    CPU_DATA    nbr_trail_zeros;


    if (val == 0u) {                                            /* Rtn ALL val bits as zero'd (see Note #3).            */
 8001e08:	b908      	cbnz	r0, 8001e0e <CPU_CntTrailZeros16+0x6>
    nbr_trail_zeros = ((CPU_WORD_SIZE_16 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
#endif


    return (nbr_trail_zeros);
}
 8001e0a:	2010      	movs	r0, #16
 8001e0c:	4770      	bx	lr
    }

                                                                /* ------------------ ASM-OPTIMIZED ------------------- */
#if ((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
     (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_16))
    nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
 8001e0e:	f7ff bcbf 	b.w	8001790 <CPU_CntTrailZeros>
 8001e12:	bf00      	nop

08001e14 <CPU_CntTrailZeros32>:
    CPU_DATA    nbr_lead_zeros;
#endif
    CPU_DATA    nbr_trail_zeros;


    if (val == 0u) {                                            /* Rtn ALL val bits as zero'd (see Note #3).            */
 8001e14:	b908      	cbnz	r0, 8001e1a <CPU_CntTrailZeros32+0x6>
    nbr_trail_zeros = ((CPU_WORD_SIZE_32 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
#endif


    return (nbr_trail_zeros);
}
 8001e16:	2020      	movs	r0, #32
 8001e18:	4770      	bx	lr
    }

                                                                /* ------------------ ASM-OPTIMIZED ------------------- */
#if ((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
     (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_32))
    nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
 8001e1a:	f7ff bcb9 	b.w	8001790 <CPU_CntTrailZeros>
 8001e1e:	bf00      	nop

08001e20 <CPU_CntTrailZeros64>:
*********************************************************************************************************
*/
/*$PAGE*/
#if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_64)
CPU_DATA  CPU_CntTrailZeros64 (CPU_INT64U  val)
{
 8001e20:	b508      	push	{r3, lr}
    CPU_DATA    nbr_lead_zeros;
#endif
    CPU_DATA    nbr_trail_zeros;


    if (val == 0u) {                                            /* Rtn ALL val bits as zero'd (see Note #3).            */
 8001e22:	ea50 0301 	orrs.w	r3, r0, r1
 8001e26:	d101      	bne.n	8001e2c <CPU_CntTrailZeros64+0xc>
        return (CPU_WORD_SIZE_64 * DEF_OCTET_NBR_BITS);
 8001e28:	2040      	movs	r0, #64	; 0x40
    nbr_trail_zeros = ((CPU_WORD_SIZE_64 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
#endif


    return (nbr_trail_zeros);
}
 8001e2a:	bd08      	pop	{r3, pc}
     (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_64))
    nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);

#else                                                           /* ------------------- C-OPTIMIZED -------------------- */
    val_bit_mask    = val & ((CPU_INT64U)~val + 1u);            /* Zero/clr all bits EXCEPT least-sig set bit.          */
    nbr_lead_zeros  = CPU_CntLeadZeros64(val_bit_mask);         /* Cnt  nbr lead  0s.                                   */
 8001e2c:	4242      	negs	r2, r0
 8001e2e:	eb61 0341 	sbc.w	r3, r1, r1, lsl #1
 8001e32:	4010      	ands	r0, r2
 8001e34:	4019      	ands	r1, r3
 8001e36:	f7ff ff91 	bl	8001d5c <CPU_CntLeadZeros64>
                                                                /* Calc nbr trail 0s = (nbr val bits - 1) - nbr lead 0s.*/
    nbr_trail_zeros = ((CPU_WORD_SIZE_64 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
 8001e3a:	f1c0 003f 	rsb	r0, r0, #63	; 0x3f
#endif


    return (nbr_trail_zeros);
 8001e3e:	bd08      	pop	{r3, pc}

08001e40 <SWIFT_UART6_IntHandler>:
**return:
**autor:  andiman
**date:
************************************************************/
void SWIFT_UART6_IntHandler(void)
{
 8001e40:	b510      	push	{r4, lr}
	INT8U Res;

	if (USART_GetITStatus(SWIFT_UART6_GPIO.USARTx, USART_IT_RXNE) != RESET)
 8001e42:	4c09      	ldr	r4, [pc, #36]	; (8001e68 <SWIFT_UART6_IntHandler+0x28>)
 8001e44:	f240 5125 	movw	r1, #1317	; 0x525
 8001e48:	69a0      	ldr	r0, [r4, #24]
 8001e4a:	f007 fadb 	bl	8009404 <USART_GetITStatus>
 8001e4e:	b900      	cbnz	r0, 8001e52 <SWIFT_UART6_IntHandler+0x12>
 8001e50:	bd10      	pop	{r4, pc}
	{
		USART_ClearITPendingBit(SWIFT_UART6_GPIO.USARTx, USART_IT_RXNE);
 8001e52:	69a0      	ldr	r0, [r4, #24]
 8001e54:	f240 5125 	movw	r1, #1317	; 0x525
 8001e58:	f007 faf8 	bl	800944c <USART_ClearITPendingBit>
				USART_RX_STA = 0;
			}
		}
#endif
	}
}
 8001e5c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

	if (USART_GetITStatus(SWIFT_UART6_GPIO.USARTx, USART_IT_RXNE) != RESET)
	{
		USART_ClearITPendingBit(SWIFT_UART6_GPIO.USARTx, USART_IT_RXNE);
		//Res = USART_ReceiveData(SWIFT_UART6_GPIO.USARTx);
		BSP_OS_Sem_Post(&SWIFT_UART6_Rev_Sem);
 8001e60:	4802      	ldr	r0, [pc, #8]	; (8001e6c <SWIFT_UART6_IntHandler+0x2c>)
 8001e62:	f00b bcad 	b.w	800d7c0 <BSP_OS_Sem_Post>
 8001e66:	bf00      	nop
 8001e68:	20000778 	.word	0x20000778
 8001e6c:	2000b2d8 	.word	0x2000b2d8

08001e70 <SWIFT_UART6_INT_Switch.part.1>:
**output:	none
**return:
**autor:  andiman
**date:
************************************************************/
void SWIFT_UART6_INT_Switch(INT8U switch_set)
 8001e70:	b508      	push	{r3, lr}
{
	if( switch_set == ENABLE)
	{
		USART_ITConfig(SWIFT_UART6_GPIO.USARTx, USART_IT_RXNE, ENABLE);
 8001e72:	4b08      	ldr	r3, [pc, #32]	; (8001e94 <SWIFT_UART6_INT_Switch.part.1+0x24>)
 8001e74:	2201      	movs	r2, #1
 8001e76:	6998      	ldr	r0, [r3, #24]
 8001e78:	f240 5125 	movw	r1, #1317	; 0x525
 8001e7c:	f007 fa9c 	bl	80093b8 <USART_ITConfig>
		BSP_IntVectSet(SWIFT_UART6_INT_ID, SWIFT_UART6_IntHandler);
 8001e80:	2047      	movs	r0, #71	; 0x47
 8001e82:	4905      	ldr	r1, [pc, #20]	; (8001e98 <SWIFT_UART6_INT_Switch.part.1+0x28>)
 8001e84:	f7fe fef0 	bl	8000c68 <BSP_IntVectSet>
	}
	else
	{
		BSP_IntDis(SWIFT_UART6_INT_ID);
	}
}
 8001e88:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
{
	if( switch_set == ENABLE)
	{
		USART_ITConfig(SWIFT_UART6_GPIO.USARTx, USART_IT_RXNE, ENABLE);
		BSP_IntVectSet(SWIFT_UART6_INT_ID, SWIFT_UART6_IntHandler);
		BSP_IntEn(SWIFT_UART6_INT_ID);
 8001e8c:	2047      	movs	r0, #71	; 0x47
 8001e8e:	f7fe bee3 	b.w	8000c58 <BSP_IntEn>
 8001e92:	bf00      	nop
 8001e94:	20000778 	.word	0x20000778
 8001e98:	08001e41 	.word	0x08001e41

08001e9c <_sys_exit>:
FILE __stdout;
//定义_sys_exit()以避免使用半主机模式    
_sys_exit(int x) 
{ 
	x = x; 
}
 8001e9c:	4770      	bx	lr
 8001e9e:	bf00      	nop

08001ea0 <fputc>:

//重定义fputc函数 
int fputc(int ch, FILE *f)
{
	//循环发送,直到发送完毕   
	while((USART6->SR & 0X40) == 0)
 8001ea0:	4903      	ldr	r1, [pc, #12]	; (8001eb0 <fputc+0x10>)
 8001ea2:	880b      	ldrh	r3, [r1, #0]
 8001ea4:	4a02      	ldr	r2, [pc, #8]	; (8001eb0 <fputc+0x10>)
 8001ea6:	065b      	lsls	r3, r3, #25
 8001ea8:	d5fb      	bpl.n	8001ea2 <fputc+0x2>
	{
		;
	}

	USART6->DR = (u8) ch;
 8001eaa:	b2c3      	uxtb	r3, r0
 8001eac:	8093      	strh	r3, [r2, #4]

	return ch;
}
 8001eae:	4770      	bx	lr
 8001eb0:	40011400 	.word	0x40011400

08001eb4 <fgetc>:

int fgetc(FILE *f)
{
 8001eb4:	b508      	push	{r3, lr}
	int ch;
	while (USART_GetFlagStatus(USART6, USART_FLAG_RXNE) == RESET) 
 8001eb6:	2120      	movs	r1, #32
 8001eb8:	4804      	ldr	r0, [pc, #16]	; (8001ecc <fgetc+0x18>)
 8001eba:	f007 fa99 	bl	80093f0 <USART_GetFlagStatus>
 8001ebe:	2800      	cmp	r0, #0
 8001ec0:	d0f9      	beq.n	8001eb6 <fgetc+0x2>
	{
		;
	}

	ch = USART_ReceiveData(USART6);
 8001ec2:	4802      	ldr	r0, [pc, #8]	; (8001ecc <fgetc+0x18>)
 8001ec4:	f007 f9d6 	bl	8009274 <USART_ReceiveData>

	return ch;
}
 8001ec8:	bd08      	pop	{r3, pc}
 8001eca:	bf00      	nop
 8001ecc:	40011400 	.word	0x40011400

08001ed0 <SWIFT_UART6_Init>:
**return:
**autor:  andiman
**date:
************************************************************/
void SWIFT_UART6_Init(INT32U	BaudRate)
{
 8001ed0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001ed4:	b088      	sub	sp, #32
	SWIFT_UART6_GPIO.USART_InitStruct.USART_Parity = USART_Parity_No;
	SWIFT_UART6_GPIO.USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	SWIFT_UART6_GPIO.USART_InitStruct.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;

	
	BSP_UART_Init(SWIFT_UART6_GPIO);
 8001ed6:	466e      	mov	r6, sp
************************************************************/
void SWIFT_UART6_Init(INT32U	BaudRate)
{
	INT8U test_buff[10]={0};

	SWIFT_UART6_GPIO.GPIOx[UART_GPIO_TX_INDEX] = HW_BEACON_UART_TX_PIN_PORT;
 8001ed8:	4c26      	ldr	r4, [pc, #152]	; (8001f74 <SWIFT_UART6_Init+0xa4>)
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_RX_INDEX].GPIO_PuPd = GPIO_PuPd_UP;
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_RX_INDEX].GPIO_Mode = GPIO_Mode_AF;
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_RX_INDEX].GPIO_Pin = HW_BEACON_UART_RX_PIN;
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_RX_INDEX].GPIO_Speed = GPIO_Speed_50MHz;

	SWIFT_UART6_GPIO.USARTx = HW_BEACON_UARTX;
 8001eda:	4b27      	ldr	r3, [pc, #156]	; (8001f78 <SWIFT_UART6_Init+0xa8>)
void SWIFT_UART6_Init(INT32U	BaudRate)
{
	INT8U test_buff[10]={0};

	SWIFT_UART6_GPIO.GPIOx[UART_GPIO_TX_INDEX] = HW_BEACON_UART_TX_PIN_PORT;
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_TX_INDEX].GPIO_OType = GPIO_OType_PP;
 8001edc:	2500      	movs	r5, #0
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_TX_INDEX].GPIO_PuPd = GPIO_PuPd_UP;
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_TX_INDEX].GPIO_Mode = GPIO_Mode_AF;
 8001ede:	f04f 0e02 	mov.w	lr, #2
{
	INT8U test_buff[10]={0};

	SWIFT_UART6_GPIO.GPIOx[UART_GPIO_TX_INDEX] = HW_BEACON_UART_TX_PIN_PORT;
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_TX_INDEX].GPIO_OType = GPIO_OType_PP;
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_TX_INDEX].GPIO_PuPd = GPIO_PuPd_UP;
 8001ee2:	f04f 0801 	mov.w	r8, #1

	SWIFT_UART6_GPIO.GPIOx[UART_GPIO_RX_INDEX] = HW_BEACON_UART_RX_PIN_PORT;
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_RX_INDEX].GPIO_OType = GPIO_OType_PP;
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_RX_INDEX].GPIO_PuPd = GPIO_PuPd_UP;
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_RX_INDEX].GPIO_Mode = GPIO_Mode_AF;
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_RX_INDEX].GPIO_Pin = HW_BEACON_UART_RX_PIN;
 8001ee6:	2280      	movs	r2, #128	; 0x80
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_TX_INDEX].GPIO_Speed = GPIO_Speed_50MHz;

	SWIFT_UART6_GPIO.GPIOx[UART_GPIO_RX_INDEX] = HW_BEACON_UART_RX_PIN_PORT;
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_RX_INDEX].GPIO_OType = GPIO_OType_PP;
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_RX_INDEX].GPIO_PuPd = GPIO_PuPd_UP;
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_RX_INDEX].GPIO_Mode = GPIO_Mode_AF;
 8001ee8:	f884 e014 	strb.w	lr, [r4, #20]
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_RX_INDEX].GPIO_Pin = HW_BEACON_UART_RX_PIN;
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_RX_INDEX].GPIO_Speed = GPIO_Speed_50MHz;
 8001eec:	f884 e015 	strb.w	lr, [r4, #21]
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_TX_INDEX].GPIO_Mode = GPIO_Mode_AF;
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_TX_INDEX].GPIO_Pin = HW_BEACON_UART_TX_PIN;
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_TX_INDEX].GPIO_Speed = GPIO_Speed_50MHz;

	SWIFT_UART6_GPIO.GPIOx[UART_GPIO_RX_INDEX] = HW_BEACON_UART_RX_PIN_PORT;
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_RX_INDEX].GPIO_OType = GPIO_OType_PP;
 8001ef0:	75a5      	strb	r5, [r4, #22]
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_RX_INDEX].GPIO_PuPd = GPIO_PuPd_UP;
 8001ef2:	f884 8017 	strb.w	r8, [r4, #23]
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_RX_INDEX].GPIO_Mode = GPIO_Mode_AF;
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_RX_INDEX].GPIO_Pin = HW_BEACON_UART_RX_PIN;
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_RX_INDEX].GPIO_Speed = GPIO_Speed_50MHz;

	SWIFT_UART6_GPIO.USARTx = HW_BEACON_UARTX;
	SWIFT_UART6_GPIO.USART_InitStruct.USART_BaudRate = BaudRate;
 8001ef6:	61e0      	str	r0, [r4, #28]

	SWIFT_UART6_GPIO.GPIOx[UART_GPIO_RX_INDEX] = HW_BEACON_UART_RX_PIN_PORT;
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_RX_INDEX].GPIO_OType = GPIO_OType_PP;
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_RX_INDEX].GPIO_PuPd = GPIO_PuPd_UP;
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_RX_INDEX].GPIO_Mode = GPIO_Mode_AF;
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_RX_INDEX].GPIO_Pin = HW_BEACON_UART_RX_PIN;
 8001ef8:	6122      	str	r2, [r4, #16]
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_RX_INDEX].GPIO_Speed = GPIO_Speed_50MHz;

	SWIFT_UART6_GPIO.USARTx = HW_BEACON_UARTX;
 8001efa:	61a3      	str	r3, [r4, #24]
	SWIFT_UART6_GPIO.USART_InitStruct.USART_Parity = USART_Parity_No;
	SWIFT_UART6_GPIO.USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	SWIFT_UART6_GPIO.USART_InitStruct.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;

	
	BSP_UART_Init(SWIFT_UART6_GPIO);
 8001efc:	f104 0710 	add.w	r7, r4, #16
 8001f00:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 8001f02:	c60f      	stmia	r6!, {r0, r1, r2, r3}
************************************************************/
void SWIFT_UART6_Init(INT32U	BaudRate)
{
	INT8U test_buff[10]={0};

	SWIFT_UART6_GPIO.GPIOx[UART_GPIO_TX_INDEX] = HW_BEACON_UART_TX_PIN_PORT;
 8001f04:	4b1d      	ldr	r3, [pc, #116]	; (8001f7c <SWIFT_UART6_Init+0xac>)
	SWIFT_UART6_GPIO.USART_InitStruct.USART_BaudRate = BaudRate;
	SWIFT_UART6_GPIO.USART_InitStruct.USART_WordLength = USART_WordLength_8b;
	SWIFT_UART6_GPIO.USART_InitStruct.USART_StopBits = USART_StopBits_1;
	SWIFT_UART6_GPIO.USART_InitStruct.USART_Parity = USART_Parity_No;
	SWIFT_UART6_GPIO.USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	SWIFT_UART6_GPIO.USART_InitStruct.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 8001f06:	220c      	movs	r2, #12
 8001f08:	84e2      	strh	r2, [r4, #38]	; 0x26
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_RX_INDEX].GPIO_Pin = HW_BEACON_UART_RX_PIN;
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_RX_INDEX].GPIO_Speed = GPIO_Speed_50MHz;

	SWIFT_UART6_GPIO.USARTx = HW_BEACON_UARTX;
	SWIFT_UART6_GPIO.USART_InitStruct.USART_BaudRate = BaudRate;
	SWIFT_UART6_GPIO.USART_InitStruct.USART_WordLength = USART_WordLength_8b;
 8001f0a:	8425      	strh	r5, [r4, #32]
	SWIFT_UART6_GPIO.USART_InitStruct.USART_StopBits = USART_StopBits_1;
 8001f0c:	8465      	strh	r5, [r4, #34]	; 0x22
	SWIFT_UART6_GPIO.USART_InitStruct.USART_Parity = USART_Parity_No;
 8001f0e:	84a5      	strh	r5, [r4, #36]	; 0x24
	SWIFT_UART6_GPIO.USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 8001f10:	8525      	strh	r5, [r4, #40]	; 0x28

	SWIFT_UART6_GPIO.GPIOx[UART_GPIO_TX_INDEX] = HW_BEACON_UART_TX_PIN_PORT;
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_TX_INDEX].GPIO_OType = GPIO_OType_PP;
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_TX_INDEX].GPIO_PuPd = GPIO_PuPd_UP;
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_TX_INDEX].GPIO_Mode = GPIO_Mode_AF;
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_TX_INDEX].GPIO_Pin = HW_BEACON_UART_TX_PIN;
 8001f12:	2240      	movs	r2, #64	; 0x40
	INT8U test_buff[10]={0};

	SWIFT_UART6_GPIO.GPIOx[UART_GPIO_TX_INDEX] = HW_BEACON_UART_TX_PIN_PORT;
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_TX_INDEX].GPIO_OType = GPIO_OType_PP;
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_TX_INDEX].GPIO_PuPd = GPIO_PuPd_UP;
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_TX_INDEX].GPIO_Mode = GPIO_Mode_AF;
 8001f14:	f884 e00c 	strb.w	lr, [r4, #12]
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_TX_INDEX].GPIO_Pin = HW_BEACON_UART_TX_PIN;
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_TX_INDEX].GPIO_Speed = GPIO_Speed_50MHz;
 8001f18:	f884 e00d 	strb.w	lr, [r4, #13]

	SWIFT_UART6_GPIO.GPIOx[UART_GPIO_TX_INDEX] = HW_BEACON_UART_TX_PIN_PORT;
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_TX_INDEX].GPIO_OType = GPIO_OType_PP;
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_TX_INDEX].GPIO_PuPd = GPIO_PuPd_UP;
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_TX_INDEX].GPIO_Mode = GPIO_Mode_AF;
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_TX_INDEX].GPIO_Pin = HW_BEACON_UART_TX_PIN;
 8001f1c:	60a2      	str	r2, [r4, #8]
void SWIFT_UART6_Init(INT32U	BaudRate)
{
	INT8U test_buff[10]={0};

	SWIFT_UART6_GPIO.GPIOx[UART_GPIO_TX_INDEX] = HW_BEACON_UART_TX_PIN_PORT;
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_TX_INDEX].GPIO_OType = GPIO_OType_PP;
 8001f1e:	73a5      	strb	r5, [r4, #14]
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_TX_INDEX].GPIO_PuPd = GPIO_PuPd_UP;
 8001f20:	f884 800f 	strb.w	r8, [r4, #15]
	SWIFT_UART6_GPIO.USART_InitStruct.USART_Parity = USART_Parity_No;
	SWIFT_UART6_GPIO.USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	SWIFT_UART6_GPIO.USART_InitStruct.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;

	
	BSP_UART_Init(SWIFT_UART6_GPIO);
 8001f24:	e897 0007 	ldmia.w	r7, {r0, r1, r2}
************************************************************/
void SWIFT_UART6_Init(INT32U	BaudRate)
{
	INT8U test_buff[10]={0};

	SWIFT_UART6_GPIO.GPIOx[UART_GPIO_TX_INDEX] = HW_BEACON_UART_TX_PIN_PORT;
 8001f28:	6023      	str	r3, [r4, #0]
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_TX_INDEX].GPIO_PuPd = GPIO_PuPd_UP;
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_TX_INDEX].GPIO_Mode = GPIO_Mode_AF;
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_TX_INDEX].GPIO_Pin = HW_BEACON_UART_TX_PIN;
	SWIFT_UART6_GPIO.GPIO_InitStruct[UART_GPIO_TX_INDEX].GPIO_Speed = GPIO_Speed_50MHz;

	SWIFT_UART6_GPIO.GPIOx[UART_GPIO_RX_INDEX] = HW_BEACON_UART_RX_PIN_PORT;
 8001f2a:	6063      	str	r3, [r4, #4]
	SWIFT_UART6_GPIO.USART_InitStruct.USART_Parity = USART_Parity_No;
	SWIFT_UART6_GPIO.USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	SWIFT_UART6_GPIO.USART_InitStruct.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;

	
	BSP_UART_Init(SWIFT_UART6_GPIO);
 8001f2c:	e886 0007 	stmia.w	r6, {r0, r1, r2}
 8001f30:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 8001f34:	f00b fcac 	bl	800d890 <BSP_UART_Init>
 8001f38:	f7ff ff9a 	bl	8001e70 <SWIFT_UART6_INT_Switch.part.1>
	SWIFT_UART6_INT_Switch(ENABLE);

	SWIFT_UART6_Buff.pbuff = SWIFTUART6Buff;
 8001f3c:	4b10      	ldr	r3, [pc, #64]	; (8001f80 <SWIFT_UART6_Init+0xb0>)
 8001f3e:	4c11      	ldr	r4, [pc, #68]	; (8001f84 <SWIFT_UART6_Init+0xb4>)
	memset(SWIFT_UART6_Buff.pbuff,0,32);
 8001f40:	4618      	mov	r0, r3
 8001f42:	4629      	mov	r1, r5
 8001f44:	2220      	movs	r2, #32

	
	BSP_UART_Init(SWIFT_UART6_GPIO);
	SWIFT_UART6_INT_Switch(ENABLE);

	SWIFT_UART6_Buff.pbuff = SWIFTUART6Buff;
 8001f46:	6023      	str	r3, [r4, #0]
	memset(SWIFT_UART6_Buff.pbuff,0,32);
 8001f48:	f012 ff0e 	bl	8014d68 <memset>
	SWIFT_UART6_Buff.write_p = 0;
	SWIFT_UART6_Buff.read_p  = 0;

	BSP_OS_Sem_Creat(&Beacon2MCU_Sem,"Beacon2MCU Sem",0);
 8001f4c:	462a      	mov	r2, r5
 8001f4e:	490e      	ldr	r1, [pc, #56]	; (8001f88 <SWIFT_UART6_Init+0xb8>)
 8001f50:	480e      	ldr	r0, [pc, #56]	; (8001f8c <SWIFT_UART6_Init+0xbc>)
	BSP_UART_Init(SWIFT_UART6_GPIO);
	SWIFT_UART6_INT_Switch(ENABLE);

	SWIFT_UART6_Buff.pbuff = SWIFTUART6Buff;
	memset(SWIFT_UART6_Buff.pbuff,0,32);
	SWIFT_UART6_Buff.write_p = 0;
 8001f52:	6065      	str	r5, [r4, #4]
	SWIFT_UART6_Buff.read_p  = 0;
 8001f54:	60a5      	str	r5, [r4, #8]

	BSP_OS_Sem_Creat(&Beacon2MCU_Sem,"Beacon2MCU Sem",0);
 8001f56:	f00b fc23 	bl	800d7a0 <BSP_OS_Sem_Creat>

	BSP_OS_Sem_Creat(&SWIFT_UART6_Send_Sem,"SWIFT_UART6_Send_Sem",1);
 8001f5a:	4642      	mov	r2, r8
 8001f5c:	490c      	ldr	r1, [pc, #48]	; (8001f90 <SWIFT_UART6_Init+0xc0>)
 8001f5e:	480d      	ldr	r0, [pc, #52]	; (8001f94 <SWIFT_UART6_Init+0xc4>)
 8001f60:	f00b fc1e 	bl	800d7a0 <BSP_OS_Sem_Creat>

    BSP_OS_Sem_Creat(&SWIFT_UART6_Rev_Sem, "SWIFT_SHELL_SEM", 0);
 8001f64:	462a      	mov	r2, r5
 8001f66:	490c      	ldr	r1, [pc, #48]	; (8001f98 <SWIFT_UART6_Init+0xc8>)
 8001f68:	480c      	ldr	r0, [pc, #48]	; (8001f9c <SWIFT_UART6_Init+0xcc>)
	
}
 8001f6a:	b008      	add	sp, #32
 8001f6c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}

	BSP_OS_Sem_Creat(&Beacon2MCU_Sem,"Beacon2MCU Sem",0);

	BSP_OS_Sem_Creat(&SWIFT_UART6_Send_Sem,"SWIFT_UART6_Send_Sem",1);

    BSP_OS_Sem_Creat(&SWIFT_UART6_Rev_Sem, "SWIFT_SHELL_SEM", 0);
 8001f70:	f00b bc16 	b.w	800d7a0 <BSP_OS_Sem_Creat>
 8001f74:	20000778 	.word	0x20000778
 8001f78:	40011400 	.word	0x40011400
 8001f7c:	40020800 	.word	0x40020800
 8001f80:	2000b30c 	.word	0x2000b30c
 8001f84:	2000b300 	.word	0x2000b300
 8001f88:	080165a8 	.word	0x080165a8
 8001f8c:	2000b38c 	.word	0x2000b38c
 8001f90:	080165b8 	.word	0x080165b8
 8001f94:	2000b49c 	.word	0x2000b49c
 8001f98:	080165d0 	.word	0x080165d0
 8001f9c:	2000b2d8 	.word	0x2000b2d8

08001fa0 <SWIFT_UART6_INT_Switch>:
**autor:  andiman
**date:
************************************************************/
void SWIFT_UART6_INT_Switch(INT8U switch_set)
{
	if( switch_set == ENABLE)
 8001fa0:	2801      	cmp	r0, #1
 8001fa2:	d002      	beq.n	8001faa <SWIFT_UART6_INT_Switch+0xa>
		BSP_IntVectSet(SWIFT_UART6_INT_ID, SWIFT_UART6_IntHandler);
		BSP_IntEn(SWIFT_UART6_INT_ID);
	}
	else
	{
		BSP_IntDis(SWIFT_UART6_INT_ID);
 8001fa4:	2047      	movs	r0, #71	; 0x47
 8001fa6:	f7fe be4d 	b.w	8000c44 <BSP_IntDis>
 8001faa:	e761      	b.n	8001e70 <SWIFT_UART6_INT_Switch.part.1>

08001fac <SWIFT_UART6_SendBuff>:
**return:
**autor:  andiman
**date:
************************************************************/
void SWIFT_UART6_SendBuff(INT8S *buff, INT32U bufflen)
{
 8001fac:	b570      	push	{r4, r5, r6, lr}
 8001fae:	4605      	mov	r5, r0
 8001fb0:	460e      	mov	r6, r1
	BSP_OS_Sem_Pend(&SWIFT_UART6_Send_Sem, 0);
 8001fb2:	4c08      	ldr	r4, [pc, #32]	; (8001fd4 <SWIFT_UART6_SendBuff+0x28>)
 8001fb4:	2100      	movs	r1, #0
 8001fb6:	4620      	mov	r0, r4
 8001fb8:	f00b fc14 	bl	800d7e4 <BSP_OS_Sem_Pend>
	BSP_UART_Send(SWIFT_UART6_GPIO.USARTx, buff,bufflen);
 8001fbc:	4b06      	ldr	r3, [pc, #24]	; (8001fd8 <SWIFT_UART6_SendBuff+0x2c>)
 8001fbe:	4632      	mov	r2, r6
 8001fc0:	4629      	mov	r1, r5
 8001fc2:	6998      	ldr	r0, [r3, #24]
 8001fc4:	f00b fcc8 	bl	800d958 <BSP_UART_Send>
	BSP_OS_Sem_Post(&SWIFT_UART6_Send_Sem);
 8001fc8:	4620      	mov	r0, r4
	
}
 8001fca:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
************************************************************/
void SWIFT_UART6_SendBuff(INT8S *buff, INT32U bufflen)
{
	BSP_OS_Sem_Pend(&SWIFT_UART6_Send_Sem, 0);
	BSP_UART_Send(SWIFT_UART6_GPIO.USARTx, buff,bufflen);
	BSP_OS_Sem_Post(&SWIFT_UART6_Send_Sem);
 8001fce:	f00b bbf7 	b.w	800d7c0 <BSP_OS_Sem_Post>
 8001fd2:	bf00      	nop
 8001fd4:	2000b49c 	.word	0x2000b49c
 8001fd8:	20000778 	.word	0x20000778

08001fdc <SWIFT_UART6_RecvBuff>:
**return:
**autor:  andiman
**date:
************************************************************/
void SWIFT_UART6_RecvBuff(INT8S *buff, INT32U *bufflen)
{
 8001fdc:	b510      	push	{r4, lr}
	*bufflen = SWIFT_UART6_Buff.write_p;
 8001fde:	4c04      	ldr	r4, [pc, #16]	; (8001ff0 <SWIFT_UART6_RecvBuff+0x14>)
 8001fe0:	6862      	ldr	r2, [r4, #4]
 8001fe2:	600a      	str	r2, [r1, #0]
	memcpy(buff,SWIFT_UART6_Buff.pbuff,*bufflen);
 8001fe4:	6821      	ldr	r1, [r4, #0]
 8001fe6:	f012 feb4 	bl	8014d52 <memcpy>
	SWIFT_UART6_Buff.write_p = 0;
 8001fea:	2300      	movs	r3, #0
 8001fec:	6063      	str	r3, [r4, #4]
 8001fee:	bd10      	pop	{r4, pc}
 8001ff0:	2000b300 	.word	0x2000b300

08001ff4 <SWIFT_USART6_GETC>:
}

INT32S SWIFT_USART6_GETC(void)
{
 8001ff4:	b508      	push	{r3, lr}
	BSP_OS_Sem_Pend(&SWIFT_UART6_Rev_Sem, 0);
 8001ff6:	2100      	movs	r1, #0
 8001ff8:	4803      	ldr	r0, [pc, #12]	; (8002008 <SWIFT_USART6_GETC+0x14>)
 8001ffa:	f00b fbf3 	bl	800d7e4 <BSP_OS_Sem_Pend>
	return BSP_UART_RCV(SWIFT_UART6_GPIO.USARTx);
 8001ffe:	4b03      	ldr	r3, [pc, #12]	; (800200c <SWIFT_USART6_GETC+0x18>)
 8002000:	6998      	ldr	r0, [r3, #24]
 8002002:	f00b fcbd 	bl	800d980 <BSP_UART_RCV>
}
 8002006:	bd08      	pop	{r3, pc}
 8002008:	2000b2d8 	.word	0x2000b2d8
 800200c:	20000778 	.word	0x20000778

08002010 <SWIFT_USART6_TSTC>:

INT32S SWIFT_USART6_TSTC(void)
{
 8002010:	b508      	push	{r3, lr}
	return BSP_UART_TST(SWIFT_UART6_GPIO.USARTx);
 8002012:	4b02      	ldr	r3, [pc, #8]	; (800201c <SWIFT_USART6_TSTC+0xc>)
 8002014:	6998      	ldr	r0, [r3, #24]
 8002016:	f00b fcb5 	bl	800d984 <BSP_UART_TST>
}
 800201a:	bd08      	pop	{r3, pc}
 800201c:	20000778 	.word	0x20000778

08002020 <HW_LED_Init>:
**return:
**autor:  duwu
**date:
************************************************************/
void HW_LED_Init(void)
{
 8002020:	b530      	push	{r4, r5, lr}
	BSP_GPIO_Init(HW_LED1_PIN_PORT,							HW_LED1_PIN,							GPIO_Mode_OUT,	GPIO_OType_PP,GPIO_PuPd_NOPULL);
 8002022:	4d09      	ldr	r5, [pc, #36]	; (8002048 <HW_LED_Init+0x28>)
**return:
**autor:  duwu
**date:
************************************************************/
void HW_LED_Init(void)
{
 8002024:	b083      	sub	sp, #12
	BSP_GPIO_Init(HW_LED1_PIN_PORT,							HW_LED1_PIN,							GPIO_Mode_OUT,	GPIO_OType_PP,GPIO_PuPd_NOPULL);
 8002026:	2400      	movs	r4, #0
 8002028:	4623      	mov	r3, r4
 800202a:	4628      	mov	r0, r5
 800202c:	9400      	str	r4, [sp, #0]
 800202e:	2201      	movs	r2, #1
 8002030:	2110      	movs	r1, #16
 8002032:	f00b faa7 	bl	800d584 <BSP_GPIO_Init>
	BSP_GPIO_Init(HW_LED2_PIN_PORT,							HW_LED2_PIN,							GPIO_Mode_OUT,	GPIO_OType_PP,GPIO_PuPd_NOPULL);
 8002036:	9400      	str	r4, [sp, #0]
 8002038:	4623      	mov	r3, r4
 800203a:	4628      	mov	r0, r5
 800203c:	2201      	movs	r2, #1
 800203e:	2120      	movs	r1, #32
 8002040:	f00b faa0 	bl	800d584 <BSP_GPIO_Init>
	
}
 8002044:	b003      	add	sp, #12
 8002046:	bd30      	pop	{r4, r5, pc}
 8002048:	40021400 	.word	0x40021400

0800204c <HW_LED1_OFF>:
**autor:  duwu
**date:
************************************************************/
void HW_LED1_OFF(void)
{
	BSP_GPIO_PinWriteLow(HW_LED1_PIN_PORT,HW_LED1_PIN);
 800204c:	2110      	movs	r1, #16
 800204e:	4801      	ldr	r0, [pc, #4]	; (8002054 <HW_LED1_OFF+0x8>)
 8002050:	f00b bad0 	b.w	800d5f4 <BSP_GPIO_PinWriteLow>
 8002054:	40021400 	.word	0x40021400

08002058 <HW_LED2_OFF>:
**autor:  duwu
**date:
************************************************************/
void HW_LED2_OFF(void)
{
	BSP_GPIO_PinWriteLow(HW_LED2_PIN_PORT,HW_LED2_PIN);
 8002058:	2120      	movs	r1, #32
 800205a:	4801      	ldr	r0, [pc, #4]	; (8002060 <HW_LED2_OFF+0x8>)
 800205c:	f00b baca 	b.w	800d5f4 <BSP_GPIO_PinWriteLow>
 8002060:	40021400 	.word	0x40021400

08002064 <HW_LED1_ON>:
**autor:  duwu
**date:
************************************************************/
void HW_LED1_ON(void)
{
	BSP_GPIO_PinWriteHigh(HW_LED1_PIN_PORT,HW_LED1_PIN);
 8002064:	2110      	movs	r1, #16
 8002066:	4801      	ldr	r0, [pc, #4]	; (800206c <HW_LED1_ON+0x8>)
 8002068:	f00b bac2 	b.w	800d5f0 <BSP_GPIO_PinWriteHigh>
 800206c:	40021400 	.word	0x40021400

08002070 <HW_LED2_ON>:
**autor:  duwu
**date:
************************************************************/
void HW_LED2_ON(void)
{
	BSP_GPIO_PinWriteHigh(HW_LED2_PIN_PORT,HW_LED2_PIN);
 8002070:	2120      	movs	r1, #32
 8002072:	4801      	ldr	r0, [pc, #4]	; (8002078 <HW_LED2_ON+0x8>)
 8002074:	f00b babc 	b.w	800d5f0 <BSP_GPIO_PinWriteHigh>
 8002078:	40021400 	.word	0x40021400

0800207c <HW_LED1_Flick>:
**autor:  duwu
**date:
************************************************************/
void HW_LED1_Flick(void)
{
	GPIO_ToggleBits(HW_LED1_PIN_PORT,HW_LED1_PIN);
 800207c:	2110      	movs	r1, #16
 800207e:	4801      	ldr	r0, [pc, #4]	; (8002084 <HW_LED1_Flick+0x8>)
 8002080:	f006 bd58 	b.w	8008b34 <GPIO_ToggleBits>
 8002084:	40021400 	.word	0x40021400

08002088 <HW_LED2_Flick>:
**autor:  duwu
**date:
************************************************************/
void HW_LED2_Flick(void)
{
	GPIO_ToggleBits(HW_LED2_PIN_PORT,HW_LED2_PIN);
 8002088:	2120      	movs	r1, #32
 800208a:	4801      	ldr	r0, [pc, #4]	; (8002090 <HW_LED2_Flick+0x8>)
 800208c:	f006 bd52 	b.w	8008b34 <GPIO_ToggleBits>
 8002090:	40021400 	.word	0x40021400

08002094 <Mem_PoolBlkIsValidAddr>:
    CPU_SIZE_T    mem_align_offset;
    CPU_SIZE_T    mem_diff;
    CPU_BOOLEAN   addr_valid;


    ppool_addr_start = pmem_pool->PoolAddrStart;
 8002094:	6982      	ldr	r2, [r0, #24]
    ppool_addr_end   = pmem_pool->PoolAddrEnd;

    if ((pmem_blk < ppool_addr_start) ||
 8002096:	428a      	cmp	r2, r1
 8002098:	d81d      	bhi.n	80020d6 <Mem_PoolBlkIsValidAddr+0x42>
 800209a:	69c3      	ldr	r3, [r0, #28]
 800209c:	428b      	cmp	r3, r1
 800209e:	d31a      	bcc.n	80020d6 <Mem_PoolBlkIsValidAddr+0x42>

#if ((LIB_MEM_CFG_ALLOC_EN       == DEF_ENABLED) && \
     (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED))
static  CPU_BOOLEAN  Mem_PoolBlkIsValidAddr (MEM_POOL  *pmem_pool,
                                             void      *pmem_blk)
{
 80020a0:	b470      	push	{r4, r5, r6}
    if ((pmem_blk < ppool_addr_start) ||
        (pmem_blk > ppool_addr_end)) {
        return (DEF_NO);
    }

    blk_align      = (CPU_SIZE_T)pmem_pool->BlkAlign;
 80020a2:	6b45      	ldr	r5, [r0, #52]	; 0x34
    align_offset   = (CPU_SIZE_T)((CPU_ADDR)ppool_addr_start % blk_align);
 80020a4:	fbb2 f3f5 	udiv	r3, r2, r5
 80020a8:	fb05 2313 	mls	r3, r5, r3, r2
    if (align_offset != 0u) {
 80020ac:	b103      	cbz	r3, 80020b0 <Mem_PoolBlkIsValidAddr+0x1c>
        mem_align_offset = blk_align - align_offset;
 80020ae:	1aeb      	subs	r3, r5, r3
    } else {
        mem_align_offset = 0u;
    }

    blk_size     = pmem_pool->BlkSize;
 80020b0:	6b04      	ldr	r4, [r0, #48]	; 0x30
    align_offset = blk_size % blk_align;
 80020b2:	fbb4 f6f5 	udiv	r6, r4, r5
 80020b6:	fb05 4016 	mls	r0, r5, r6, r4
    if (align_offset != 0u) {
 80020ba:	b970      	cbnz	r0, 80020da <Mem_PoolBlkIsValidAddr+0x46>
        blk_align_offset = blk_align - align_offset;
    } else {
        blk_align_offset = 0u;
 80020bc:	4605      	mov	r5, r0
    ppool_addr_start = pmem_pool->PoolAddrStart;
    ppool_addr_end   = pmem_pool->PoolAddrEnd;

    if ((pmem_blk < ppool_addr_start) ||
        (pmem_blk > ppool_addr_end)) {
        return (DEF_NO);
 80020be:	18d0      	adds	r0, r2, r3
 80020c0:	1a09      	subs	r1, r1, r0
 80020c2:	1928      	adds	r0, r5, r4
 80020c4:	fbb1 f3f0 	udiv	r3, r1, r0
    mem_align        = (CPU_SIZE_T  )(              blk_size         + blk_align_offset);

    addr_valid       = ((mem_diff % mem_align) == 0u) ? DEF_YES : DEF_NO;

    return (addr_valid);
}
 80020c8:	bc70      	pop	{r4, r5, r6}
    ppool_addr_start = pmem_pool->PoolAddrStart;
    ppool_addr_end   = pmem_pool->PoolAddrEnd;

    if ((pmem_blk < ppool_addr_start) ||
        (pmem_blk > ppool_addr_end)) {
        return (DEF_NO);
 80020ca:	fb00 1013 	mls	r0, r0, r3, r1
 80020ce:	fab0 f080 	clz	r0, r0
 80020d2:	0940      	lsrs	r0, r0, #5
    mem_align        = (CPU_SIZE_T  )(              blk_size         + blk_align_offset);

    addr_valid       = ((mem_diff % mem_align) == 0u) ? DEF_YES : DEF_NO;

    return (addr_valid);
}
 80020d4:	4770      	bx	lr
    ppool_addr_start = pmem_pool->PoolAddrStart;
    ppool_addr_end   = pmem_pool->PoolAddrEnd;

    if ((pmem_blk < ppool_addr_start) ||
        (pmem_blk > ppool_addr_end)) {
        return (DEF_NO);
 80020d6:	2000      	movs	r0, #0
 80020d8:	4770      	bx	lr
    }

    blk_size     = pmem_pool->BlkSize;
    align_offset = blk_size % blk_align;
    if (align_offset != 0u) {
        blk_align_offset = blk_align - align_offset;
 80020da:	1a2d      	subs	r5, r5, r0
 80020dc:	e7ef      	b.n	80020be <Mem_PoolBlkIsValidAddr+0x2a>
 80020de:	bf00      	nop

080020e0 <Mem_SegCalcTotSize>:
#if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
static  CPU_SIZE_T  Mem_SegCalcTotSize (void              *pmem_addr,
                                        MEM_POOL_BLK_QTY   blk_nbr,
                                        CPU_SIZE_T         blk_size,
                                        CPU_SIZE_T         blk_align)
{
 80020e0:	b470      	push	{r4, r5, r6}
    CPU_SIZE_T  mem_align_offset;
    CPU_SIZE_T  blk_align_offset;
    CPU_SIZE_T  size_tot;

                                                                    /* Calc mem align (see Note #2a).                   */
    align_offset = (CPU_ADDR)pmem_addr % blk_align;
 80020e2:	fbb0 f4f3 	udiv	r4, r0, r3
 80020e6:	fb04 0013 	mls	r0, r4, r3, r0
        mem_align_offset = blk_align - align_offset;
    } else {
        mem_align_offset = 0u;
    }
                                                                    /* Calc blk align (see Note #2b).                   */
    align_offset = blk_size % blk_align;
 80020ea:	fbb2 f4f3 	udiv	r4, r2, r3
 80020ee:	fb03 2414 	mls	r4, r3, r4, r2
    CPU_SIZE_T  blk_align_offset;
    CPU_SIZE_T  size_tot;

                                                                    /* Calc mem align (see Note #2a).                   */
    align_offset = (CPU_ADDR)pmem_addr % blk_align;
    if (align_offset != 0u) {
 80020f2:	b138      	cbz	r0, 8002104 <Mem_SegCalcTotSize+0x24>
        mem_align_offset = blk_align - align_offset;
 80020f4:	1a18      	subs	r0, r3, r0
    } else {
        mem_align_offset = 0u;
    }
                                                                    /* Calc blk align (see Note #2b).                   */
    align_offset = blk_size % blk_align;
    if (align_offset != 0u) {
 80020f6:	b104      	cbz	r4, 80020fa <Mem_SegCalcTotSize+0x1a>
        blk_align_offset = blk_align - align_offset;
 80020f8:	1b1c      	subs	r4, r3, r4
                                                                    /* Calc tot size  (see Note #2c).                   */
    size_tot = mem_align_offset + ((blk_size + blk_align_offset) * ((CPU_SIZE_T)blk_nbr - 1)) + blk_size;

#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* Chk ovf of tot size = A + [(B + C) * D] + E      */
    blk_size_mem_aligned = mem_align_offset + blk_size;             /* Chk ovf of A + E :                               */
    if ((blk_size_mem_aligned < mem_align_offset) ||
 80020fa:	1810      	adds	r0, r2, r0
 80020fc:	d30e      	bcc.n	800211c <Mem_SegCalcTotSize+0x3c>
        (blk_size_mem_aligned < blk_size)) {
        return (0u);
 80020fe:	2000      	movs	r0, #0
        }
    }
#endif

    return (size_tot);
}
 8002100:	bc70      	pop	{r4, r5, r6}
 8002102:	4770      	bx	lr
    } else {
        mem_align_offset = 0u;
    }
                                                                    /* Calc blk align (see Note #2b).                   */
    align_offset = blk_size % blk_align;
    if (align_offset != 0u) {
 8002104:	2c00      	cmp	r4, #0
 8002106:	d1f7      	bne.n	80020f8 <Mem_SegCalcTotSize+0x18>
        blk_align_offset = blk_align - align_offset;
    } else {
        blk_align_offset = 0u;
    }
                                                                    /* Calc tot size  (see Note #2c).                   */
    size_tot = mem_align_offset + ((blk_size + blk_align_offset) * ((CPU_SIZE_T)blk_nbr - 1)) + blk_size;
 8002108:	1e4d      	subs	r5, r1, #1
 800210a:	fb02 f505 	mul.w	r5, r2, r5
    if ((blk_size_mem_aligned < mem_align_offset) ||
        (blk_size_mem_aligned < blk_size)) {
        return (0u);
    }

    if (blk_nbr > 1) {
 800210e:	2901      	cmp	r1, #1
        blk_align_offset = blk_align - align_offset;
    } else {
        blk_align_offset = 0u;
    }
                                                                    /* Calc tot size  (see Note #2c).                   */
    size_tot = mem_align_offset + ((blk_size + blk_align_offset) * ((CPU_SIZE_T)blk_nbr - 1)) + blk_size;
 8002110:	eb02 0305 	add.w	r3, r2, r5
    if ((blk_size_mem_aligned < mem_align_offset) ||
        (blk_size_mem_aligned < blk_size)) {
        return (0u);
    }

    if (blk_nbr > 1) {
 8002114:	d815      	bhi.n	8002142 <Mem_SegCalcTotSize+0x62>
        }
    }
#endif

    return (size_tot);
}
 8002116:	bc70      	pop	{r4, r5, r6}
        blk_align_offset = blk_align - align_offset;
    } else {
        blk_align_offset = 0u;
    }
                                                                    /* Calc tot size  (see Note #2c).                   */
    size_tot = mem_align_offset + ((blk_size + blk_align_offset) * ((CPU_SIZE_T)blk_nbr - 1)) + blk_size;
 8002118:	4618      	mov	r0, r3
        }
    }
#endif

    return (size_tot);
}
 800211a:	4770      	bx	lr
                                                                    /* Calc tot size  (see Note #2c).                   */
    size_tot = mem_align_offset + ((blk_size + blk_align_offset) * ((CPU_SIZE_T)blk_nbr - 1)) + blk_size;

#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* Chk ovf of tot size = A + [(B + C) * D] + E      */
    blk_size_mem_aligned = mem_align_offset + blk_size;             /* Chk ovf of A + E :                               */
    if ((blk_size_mem_aligned < mem_align_offset) ||
 800211c:	4282      	cmp	r2, r0
 800211e:	d8ee      	bhi.n	80020fe <Mem_SegCalcTotSize+0x1e>
        blk_align_offset = blk_align - align_offset;
    } else {
        blk_align_offset = 0u;
    }
                                                                    /* Calc tot size  (see Note #2c).                   */
    size_tot = mem_align_offset + ((blk_size + blk_align_offset) * ((CPU_SIZE_T)blk_nbr - 1)) + blk_size;
 8002120:	18a6      	adds	r6, r4, r2
 8002122:	1e4d      	subs	r5, r1, #1
 8002124:	fb06 f505 	mul.w	r5, r6, r5
    if ((blk_size_mem_aligned < mem_align_offset) ||
        (blk_size_mem_aligned < blk_size)) {
        return (0u);
    }

    if (blk_nbr > 1) {
 8002128:	2901      	cmp	r1, #1
        blk_align_offset = blk_align - align_offset;
    } else {
        blk_align_offset = 0u;
    }
                                                                    /* Calc tot size  (see Note #2c).                   */
    size_tot = mem_align_offset + ((blk_size + blk_align_offset) * ((CPU_SIZE_T)blk_nbr - 1)) + blk_size;
 800212a:	eb05 0300 	add.w	r3, r5, r0
    if ((blk_size_mem_aligned < mem_align_offset) ||
        (blk_size_mem_aligned < blk_size)) {
        return (0u);
    }

    if (blk_nbr > 1) {
 800212e:	d9f2      	bls.n	8002116 <Mem_SegCalcTotSize+0x36>
        blk_size_aligned = blk_size + blk_align_offset;
        if ((blk_size_aligned < blk_align_offset) ||                /* Chk ovf of      (B + C) :                        */
 8002130:	42b4      	cmp	r4, r6
 8002132:	d8e4      	bhi.n	80020fe <Mem_SegCalcTotSize+0x1e>
 8002134:	42b2      	cmp	r2, r6
 8002136:	d8e2      	bhi.n	80020fe <Mem_SegCalcTotSize+0x1e>
            (blk_size_aligned < blk_size)) {
            return (0u);
        }

        blk_size_aligned_nbr = blk_size_aligned * ((CPU_SIZE_T)blk_nbr - 1);
        if ((blk_size_aligned_nbr < blk_size_aligned) ||            /* Chk ovf of     [(B + C) * D] :                   */
 8002138:	42ae      	cmp	r6, r5
 800213a:	d8e0      	bhi.n	80020fe <Mem_SegCalcTotSize+0x1e>
 800213c:	42ac      	cmp	r4, r5
 800213e:	d8de      	bhi.n	80020fe <Mem_SegCalcTotSize+0x1e>
 8002140:	e004      	b.n	800214c <Mem_SegCalcTotSize+0x6c>
 8002142:	42aa      	cmp	r2, r5
 8002144:	d901      	bls.n	800214a <Mem_SegCalcTotSize+0x6a>

#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* Chk ovf of tot size = A + [(B + C) * D] + E      */
    blk_size_mem_aligned = mem_align_offset + blk_size;             /* Chk ovf of A + E :                               */
    if ((blk_size_mem_aligned < mem_align_offset) ||
        (blk_size_mem_aligned < blk_size)) {
        return (0u);
 8002146:	4620      	mov	r0, r4
 8002148:	e7da      	b.n	8002100 <Mem_SegCalcTotSize+0x20>
    }
                                                                    /* Calc tot size  (see Note #2c).                   */
    size_tot = mem_align_offset + ((blk_size + blk_align_offset) * ((CPU_SIZE_T)blk_nbr - 1)) + blk_size;

#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* Chk ovf of tot size = A + [(B + C) * D] + E      */
    blk_size_mem_aligned = mem_align_offset + blk_size;             /* Chk ovf of A + E :                               */
 800214a:	4610      	mov	r0, r2
            return (0u);
        }

        blk_size_aligned_nbr = blk_size_aligned * ((CPU_SIZE_T)blk_nbr - 1);
        if ((blk_size_aligned_nbr < blk_size_aligned) ||            /* Chk ovf of     [(B + C) * D] :                   */
            (blk_size_aligned_nbr < blk_align_offset) ||
 800214c:	42aa      	cmp	r2, r5
 800214e:	d8d6      	bhi.n	80020fe <Mem_SegCalcTotSize+0x1e>
            (blk_size_aligned_nbr < blk_size)) {
            return (0u);
        }

        blk_size_tot = blk_size_aligned_nbr + blk_size;
        if ((blk_size_tot < blk_size_aligned_nbr) ||                /* Chk ovf of     [(B + C) * D] + E :               */
 8002150:	1954      	adds	r4, r2, r5
 8002152:	d2d4      	bcs.n	80020fe <Mem_SegCalcTotSize+0x1e>
 8002154:	42a2      	cmp	r2, r4
 8002156:	d8d2      	bhi.n	80020fe <Mem_SegCalcTotSize+0x1e>
            (blk_size_tot < blk_size)) {
            return (0u);
        }

        if ((size_tot < blk_size_mem_aligned) ||                    /* Chk ovf of A + [(B + C) * D] + E :               */
 8002158:	4298      	cmp	r0, r3
 800215a:	d8d0      	bhi.n	80020fe <Mem_SegCalcTotSize+0x1e>
 800215c:	429d      	cmp	r5, r3
 800215e:	d8ce      	bhi.n	80020fe <Mem_SegCalcTotSize+0x1e>
            (size_tot < blk_size_aligned_nbr) ||
 8002160:	429c      	cmp	r4, r3
 8002162:	bf94      	ite	ls
 8002164:	4618      	movls	r0, r3
 8002166:	2000      	movhi	r0, #0
 8002168:	e7ca      	b.n	8002100 <Mem_SegCalcTotSize+0x20>
 800216a:	bf00      	nop

0800216c <Mem_Set.part.1>:
*                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
*                  'mem_align_mod' arithmetic operation.
*********************************************************************************************************
*/

void  Mem_Set (void        *pmem,
 800216c:	b430      	push	{r4, r5}


    data_align = 0u;
    for (i = 0u; i < sizeof(CPU_ALIGN); i++) {                  /* Fill each data_align octet with data val.            */
        data_align <<=  DEF_OCTET_NBR_BITS;
        data_align  |= (CPU_ALIGN)data_val;
 800216e:	ea41 2501 	orr.w	r5, r1, r1, lsl #8
 8002172:	ea41 2505 	orr.w	r5, r1, r5, lsl #8

    size_rem      =  size;
    mem_align_mod = (CPU_INT08U)((CPU_ADDR)pmem % sizeof(CPU_ALIGN));   /* See Note #3.                                 */

    pmem_08 = (CPU_INT08U *)pmem;
    if (mem_align_mod != 0u) {                                  /* If leading octets avail,                   ...       */
 8002176:	f010 0303 	ands.w	r3, r0, #3


    data_align = 0u;
    for (i = 0u; i < sizeof(CPU_ALIGN); i++) {                  /* Fill each data_align octet with data val.            */
        data_align <<=  DEF_OCTET_NBR_BITS;
        data_align  |= (CPU_ALIGN)data_val;
 800217a:	ea41 2505 	orr.w	r5, r1, r5, lsl #8

    size_rem      =  size;
    mem_align_mod = (CPU_INT08U)((CPU_ADDR)pmem % sizeof(CPU_ALIGN));   /* See Note #3.                                 */

    pmem_08 = (CPU_INT08U *)pmem;
    if (mem_align_mod != 0u) {                                  /* If leading octets avail,                   ...       */
 800217e:	d00c      	beq.n	800219a <Mem_Set.part.1+0x2e>
        i = mem_align_mod;
        while ((size_rem > 0) &&                                /* ... start mem buf fill with leading octets ...       */
 8002180:	b14a      	cbz	r2, 8002196 <Mem_Set.part.1+0x2a>
 8002182:	f1c3 0304 	rsb	r3, r3, #4
 8002186:	4403      	add	r3, r0
 8002188:	e001      	b.n	800218e <Mem_Set.part.1+0x22>
 800218a:	4298      	cmp	r0, r3
 800218c:	d01e      	beq.n	80021cc <Mem_Set.part.1+0x60>
 800218e:	3a01      	subs	r2, #1
               (i        < sizeof(CPU_ALIGN ))) {               /* ... until next CPU_ALIGN word boundary.              */
           *pmem_08++ = data_val;
 8002190:	f800 1b01 	strb.w	r1, [r0], #1
    mem_align_mod = (CPU_INT08U)((CPU_ADDR)pmem % sizeof(CPU_ALIGN));   /* See Note #3.                                 */

    pmem_08 = (CPU_INT08U *)pmem;
    if (mem_align_mod != 0u) {                                  /* If leading octets avail,                   ...       */
        i = mem_align_mod;
        while ((size_rem > 0) &&                                /* ... start mem buf fill with leading octets ...       */
 8002194:	d1f9      	bne.n	800218a <Mem_Set.part.1+0x1e>
    pmem_08 = (CPU_INT08U *)pmem_align;
    while (size_rem > 0) {                                      /* Finish mem buf fill with trailing octets.            */
       *pmem_08++   = data_val;
        size_rem   -= sizeof(CPU_INT08U);
    }
}
 8002196:	bc30      	pop	{r4, r5}
 8002198:	4770      	bx	lr
            i++;
        }
    }

    pmem_align = (CPU_ALIGN *)pmem_08;                          /* See Note #2a.                                        */
    while (size_rem >= sizeof(CPU_ALIGN)) {                     /* While mem buf aligned on CPU_ALIGN word boundaries,  */
 800219a:	2a03      	cmp	r2, #3
 800219c:	d90d      	bls.n	80021ba <Mem_Set.part.1+0x4e>
 800219e:	4613      	mov	r3, r2
 80021a0:	4604      	mov	r4, r0
       *pmem_align++ = data_align;                              /* ... fill mem buf with    CPU_ALIGN-sized data.       */
        size_rem    -= sizeof(CPU_ALIGN);
 80021a2:	3b04      	subs	r3, #4
            i++;
        }
    }

    pmem_align = (CPU_ALIGN *)pmem_08;                          /* See Note #2a.                                        */
    while (size_rem >= sizeof(CPU_ALIGN)) {                     /* While mem buf aligned on CPU_ALIGN word boundaries,  */
 80021a4:	2b03      	cmp	r3, #3
       *pmem_align++ = data_align;                              /* ... fill mem buf with    CPU_ALIGN-sized data.       */
 80021a6:	f844 5b04 	str.w	r5, [r4], #4
            i++;
        }
    }

    pmem_align = (CPU_ALIGN *)pmem_08;                          /* See Note #2a.                                        */
    while (size_rem >= sizeof(CPU_ALIGN)) {                     /* While mem buf aligned on CPU_ALIGN word boundaries,  */
 80021aa:	d8fa      	bhi.n	80021a2 <Mem_Set.part.1+0x36>
 80021ac:	1f13      	subs	r3, r2, #4
 80021ae:	f023 0303 	bic.w	r3, r3, #3
 80021b2:	3304      	adds	r3, #4
 80021b4:	4418      	add	r0, r3
 80021b6:	f002 0203 	and.w	r2, r2, #3
       *pmem_align++ = data_align;                              /* ... fill mem buf with    CPU_ALIGN-sized data.       */
        size_rem    -= sizeof(CPU_ALIGN);
    }

    pmem_08 = (CPU_INT08U *)pmem_align;
    while (size_rem > 0) {                                      /* Finish mem buf fill with trailing octets.            */
 80021ba:	2a00      	cmp	r2, #0
 80021bc:	d0eb      	beq.n	8002196 <Mem_Set.part.1+0x2a>
 80021be:	4402      	add	r2, r0
       *pmem_08++   = data_val;
 80021c0:	f800 1b01 	strb.w	r1, [r0], #1
       *pmem_align++ = data_align;                              /* ... fill mem buf with    CPU_ALIGN-sized data.       */
        size_rem    -= sizeof(CPU_ALIGN);
    }

    pmem_08 = (CPU_INT08U *)pmem_align;
    while (size_rem > 0) {                                      /* Finish mem buf fill with trailing octets.            */
 80021c4:	4282      	cmp	r2, r0
 80021c6:	d1fb      	bne.n	80021c0 <Mem_Set.part.1+0x54>
       *pmem_08++   = data_val;
        size_rem   -= sizeof(CPU_INT08U);
    }
}
 80021c8:	bc30      	pop	{r4, r5}
 80021ca:	4770      	bx	lr
            i++;
        }
    }

    pmem_align = (CPU_ALIGN *)pmem_08;                          /* See Note #2a.                                        */
    while (size_rem >= sizeof(CPU_ALIGN)) {                     /* While mem buf aligned on CPU_ALIGN word boundaries,  */
 80021cc:	2a03      	cmp	r2, #3
 80021ce:	d8e6      	bhi.n	800219e <Mem_Set.part.1+0x32>
 80021d0:	e7f5      	b.n	80021be <Mem_Set.part.1+0x52>
 80021d2:	bf00      	nop

080021d4 <Mem_Init>:
*                   (b) BEFORE product's application calls any memory library module function(s)
*********************************************************************************************************
*/

void  Mem_Init (void)
{
 80021d4:	b430      	push	{r4, r5}
#if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
    MEM_POOL  *pmem_pool;

                                                                        /* --------- INIT MEM HEAP SEG / POOL --------- */
    pmem_pool                   = (MEM_POOL   *)&Mem_PoolHeap;
    pmem_pool->Type             = (LIB_MEM_TYPE) LIB_MEM_TYPE_HEAP;
 80021d6:	4b0d      	ldr	r3, [pc, #52]	; (800220c <Mem_Init+0x38>)
 80021d8:	4d0d      	ldr	r5, [pc, #52]	; (8002210 <Mem_Init+0x3c>)

    pmem_pool->SegSizeTot       = (CPU_SIZE_T  ) LIB_MEM_CFG_HEAP_SIZE;
    pmem_pool->SegSizeRem       = (CPU_SIZE_T  ) LIB_MEM_CFG_HEAP_SIZE;

                                                                        /* ------------ INIT MEM POOL TBL ------------- */
    Mem_PoolTbl = &Mem_PoolHeap;
 80021da:	4c0e      	ldr	r4, [pc, #56]	; (8002214 <Mem_Init+0x40>)

#ifdef  LIB_MEM_CFG_HEAP_BASE_ADDR
    pmem_pool->SegAddr          = (void       *) LIB_MEM_CFG_HEAP_BASE_ADDR;
    pmem_pool->SegAddrNextAvail = (void       *) LIB_MEM_CFG_HEAP_BASE_ADDR;
#else
    pmem_pool->SegAddr          = (void       *)&Mem_Heap[0];
 80021dc:	480e      	ldr	r0, [pc, #56]	; (8002218 <Mem_Init+0x44>)

                                                                        /* --------- INIT MEM HEAP SEG / POOL --------- */
    pmem_pool                   = (MEM_POOL   *)&Mem_PoolHeap;
    pmem_pool->Type             = (LIB_MEM_TYPE) LIB_MEM_TYPE_HEAP;
    pmem_pool->SegHeadPtr       = (MEM_POOL   *)&Mem_PoolHeap;          /* Heap seg head = heap seg.                    */
    pmem_pool->SegPrevPtr       = (MEM_POOL   *) 0;
 80021de:	2200      	movs	r2, #0
#else
    pmem_pool->SegAddr          = (void       *)&Mem_Heap[0];
    pmem_pool->SegAddrNextAvail = (void       *)&Mem_Heap[0];
#endif

    pmem_pool->SegSizeTot       = (CPU_SIZE_T  ) LIB_MEM_CFG_HEAP_SIZE;
 80021e0:	f44f 5110 	mov.w	r1, #9216	; 0x2400
#if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
    MEM_POOL  *pmem_pool;

                                                                        /* --------- INIT MEM HEAP SEG / POOL --------- */
    pmem_pool                   = (MEM_POOL   *)&Mem_PoolHeap;
    pmem_pool->Type             = (LIB_MEM_TYPE) LIB_MEM_TYPE_HEAP;
 80021e4:	601d      	str	r5, [r3, #0]

    pmem_pool->SegSizeTot       = (CPU_SIZE_T  ) LIB_MEM_CFG_HEAP_SIZE;
    pmem_pool->SegSizeRem       = (CPU_SIZE_T  ) LIB_MEM_CFG_HEAP_SIZE;

                                                                        /* ------------ INIT MEM POOL TBL ------------- */
    Mem_PoolTbl = &Mem_PoolHeap;
 80021e6:	6023      	str	r3, [r4, #0]
    MEM_POOL  *pmem_pool;

                                                                        /* --------- INIT MEM HEAP SEG / POOL --------- */
    pmem_pool                   = (MEM_POOL   *)&Mem_PoolHeap;
    pmem_pool->Type             = (LIB_MEM_TYPE) LIB_MEM_TYPE_HEAP;
    pmem_pool->SegHeadPtr       = (MEM_POOL   *)&Mem_PoolHeap;          /* Heap seg head = heap seg.                    */
 80021e8:	605b      	str	r3, [r3, #4]
    pmem_pool->SegPrevPtr       = (MEM_POOL   *) 0;
 80021ea:	609a      	str	r2, [r3, #8]
    pmem_pool->SegNextPtr       = (MEM_POOL   *) 0;
 80021ec:	60da      	str	r2, [r3, #12]
    pmem_pool->PoolPrevPtr      = (MEM_POOL   *) 0;
 80021ee:	611a      	str	r2, [r3, #16]
    pmem_pool->PoolNextPtr      = (MEM_POOL   *) 0;
 80021f0:	615a      	str	r2, [r3, #20]
    pmem_pool->PoolAddrStart    = (void       *) 0;
 80021f2:	619a      	str	r2, [r3, #24]
    pmem_pool->PoolAddrEnd      = (void       *) 0;
 80021f4:	61da      	str	r2, [r3, #28]
    pmem_pool->PoolPtrs         = (void      **) 0;
 80021f6:	621a      	str	r2, [r3, #32]
    pmem_pool->BlkSize          = (CPU_SIZE_T  ) 0u;
 80021f8:	631a      	str	r2, [r3, #48]	; 0x30
    pmem_pool->BlkNbr           = (CPU_SIZE_T  ) 0u;
 80021fa:	62da      	str	r2, [r3, #44]	; 0x2c
    pmem_pool->BlkIx            = (MEM_POOL_IX ) 0u;
 80021fc:	625a      	str	r2, [r3, #36]	; 0x24

#ifdef  LIB_MEM_CFG_HEAP_BASE_ADDR
    pmem_pool->SegAddr          = (void       *) LIB_MEM_CFG_HEAP_BASE_ADDR;
    pmem_pool->SegAddrNextAvail = (void       *) LIB_MEM_CFG_HEAP_BASE_ADDR;
#else
    pmem_pool->SegAddr          = (void       *)&Mem_Heap[0];
 80021fe:	6398      	str	r0, [r3, #56]	; 0x38
    pmem_pool->SegAddrNextAvail = (void       *)&Mem_Heap[0];
 8002200:	63d8      	str	r0, [r3, #60]	; 0x3c
#endif

    pmem_pool->SegSizeTot       = (CPU_SIZE_T  ) LIB_MEM_CFG_HEAP_SIZE;
 8002202:	6419      	str	r1, [r3, #64]	; 0x40
    pmem_pool->SegSizeRem       = (CPU_SIZE_T  ) LIB_MEM_CFG_HEAP_SIZE;
 8002204:	6459      	str	r1, [r3, #68]	; 0x44

                                                                        /* ------------ INIT MEM POOL TBL ------------- */
    Mem_PoolTbl = &Mem_PoolHeap;
#endif
}
 8002206:	bc30      	pop	{r4, r5}
 8002208:	4770      	bx	lr
 800220a:	bf00      	nop
 800220c:	2000b4c4 	.word	0x2000b4c4
 8002210:	50414548 	.word	0x50414548
 8002214:	2000d90c 	.word	0x2000d90c
 8002218:	2000b50c 	.word	0x2000b50c

0800221c <Mem_Clr>:
    CPU_DATA     mem_align_mod;
    CPU_DATA     i;


#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    if (size < 1) {                                             /* See Note #1.                                         */
 800221c:	b119      	cbz	r1, 8002226 <Mem_Clr+0xa>
        return;
    }
    if (pmem == (void *)0) {
 800221e:	b110      	cbz	r0, 8002226 <Mem_Clr+0xa>
 8002220:	460a      	mov	r2, r1
 8002222:	2100      	movs	r1, #0
 8002224:	e7a2      	b.n	800216c <Mem_Set.part.1>
 8002226:	4770      	bx	lr

08002228 <Mem_Set>:
    CPU_DATA     mem_align_mod;
    CPU_DATA     i;


#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    if (size < 1) {                                             /* See Note #1.                                         */
 8002228:	b10a      	cbz	r2, 800222e <Mem_Set+0x6>
        return;
    }
    if (pmem == (void *)0) {
 800222a:	b100      	cbz	r0, 800222e <Mem_Set+0x6>
 800222c:	e79e      	b.n	800216c <Mem_Set.part.1>
 800222e:	4770      	bx	lr

08002230 <Mem_Move>:
           CPU_DATA      mem_align_mod_src;
           CPU_BOOLEAN   mem_aligned;


#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    if (size < 1) {
 8002230:	2a00      	cmp	r2, #0
 8002232:	d050      	beq.n	80022d6 <Mem_Move+0xa6>
/*$PAGE*/

void  Mem_Move (       void        *pdest,
                const  void        *psrc,
                       CPU_SIZE_T   size)
{
 8002234:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002236:	4605      	mov	r5, r0

#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    if (size < 1) {
        return;
    }
    if (pdest == (void *)0) {
 8002238:	b300      	cbz	r0, 800227c <Mem_Move+0x4c>
        return;
    }
    if (psrc  == (void *)0) {
 800223a:	b1f9      	cbz	r1, 800227c <Mem_Move+0x4c>
    }
#endif

    pmem_08_src  = (const CPU_INT08U *)psrc;
    pmem_08_dest = (      CPU_INT08U *)pdest;
    if (pmem_08_src > pmem_08_dest) {
 800223c:	4288      	cmp	r0, r1
 800223e:	d34b      	bcc.n	80022d8 <Mem_Move+0xa8>
        return;
    }

    size_rem           =  size;

    pmem_08_dest       = (      CPU_INT08U *)pdest + size - 1;
 8002240:	1e50      	subs	r0, r2, #1
 8002242:	4405      	add	r5, r0
    pmem_08_src        = (const CPU_INT08U *)psrc  + size - 1;
 8002244:	4401      	add	r1, r0
    
    mem_gap_octets     = pmem_08_dest - pmem_08_src;
    

    if (mem_gap_octets >= sizeof(CPU_ALIGN)) {                  /* Avoid bufs overlap.                                  */
 8002246:	1a6b      	subs	r3, r5, r1
 8002248:	2b03      	cmp	r3, #3
 800224a:	4614      	mov	r4, r2
 800224c:	d93a      	bls.n	80022c4 <Mem_Move+0x94>
    
                                                                /* See Note #4.                                         */
        mem_align_mod_dest = (CPU_INT08U)((CPU_ADDR)pmem_08_dest % sizeof(CPU_ALIGN));
 800224e:	f005 0203 	and.w	r2, r5, #3
        mem_align_mod_src  = (CPU_INT08U)((CPU_ADDR)pmem_08_src  % sizeof(CPU_ALIGN));

        mem_aligned        = (mem_align_mod_dest == mem_align_mod_src) ? DEF_YES : DEF_NO;
 8002252:	f001 0303 	and.w	r3, r1, #3
 8002256:	429a      	cmp	r2, r3
 8002258:	d134      	bne.n	80022c4 <Mem_Move+0x94>

        if (mem_aligned == DEF_YES) {                           /* If mem bufs' alignment offset equal, ...             */
                                                                /* ... optimize copy for mem buf alignment.             */
            if (mem_align_mod_dest != (sizeof(CPU_ALIGN) - 1)) {/* If leading octets avail,                   ...       */
 800225a:	2a03      	cmp	r2, #3
 800225c:	d00f      	beq.n	800227e <Mem_Move+0x4e>
                i = mem_align_mod_dest;
                while ((size_rem   >  0) &&                     /* ... start mem buf copy with leading octets ...       */
                       (i          >= 0)) {                     /* ... until next CPU_ALIGN word boundary.              */
                   *pmem_08_dest-- = *pmem_08_src--;
 800225e:	780b      	ldrb	r3, [r1, #0]
 8002260:	3901      	subs	r1, #1
 8002262:	702b      	strb	r3, [r5, #0]
 8002264:	1e6b      	subs	r3, r5, #1

        if (mem_aligned == DEF_YES) {                           /* If mem bufs' alignment offset equal, ...             */
                                                                /* ... optimize copy for mem buf alignment.             */
            if (mem_align_mod_dest != (sizeof(CPU_ALIGN) - 1)) {/* If leading octets avail,                   ...       */
                i = mem_align_mod_dest;
                while ((size_rem   >  0) &&                     /* ... start mem buf copy with leading octets ...       */
 8002266:	b148      	cbz	r0, 800227c <Mem_Move+0x4c>
 8002268:	43d2      	mvns	r2, r2
 800226a:	4415      	add	r5, r2
 800226c:	429d      	cmp	r5, r3
 800226e:	d007      	beq.n	8002280 <Mem_Move+0x50>
                       (i          >= 0)) {                     /* ... until next CPU_ALIGN word boundary.              */
                   *pmem_08_dest-- = *pmem_08_src--;
 8002270:	f811 2901 	ldrb.w	r2, [r1], #-1

        if (mem_aligned == DEF_YES) {                           /* If mem bufs' alignment offset equal, ...             */
                                                                /* ... optimize copy for mem buf alignment.             */
            if (mem_align_mod_dest != (sizeof(CPU_ALIGN) - 1)) {/* If leading octets avail,                   ...       */
                i = mem_align_mod_dest;
                while ((size_rem   >  0) &&                     /* ... start mem buf copy with leading octets ...       */
 8002274:	3801      	subs	r0, #1
                       (i          >= 0)) {                     /* ... until next CPU_ALIGN word boundary.              */
                   *pmem_08_dest-- = *pmem_08_src--;
 8002276:	f803 2901 	strb.w	r2, [r3], #-1

        if (mem_aligned == DEF_YES) {                           /* If mem bufs' alignment offset equal, ...             */
                                                                /* ... optimize copy for mem buf alignment.             */
            if (mem_align_mod_dest != (sizeof(CPU_ALIGN) - 1)) {/* If leading octets avail,                   ...       */
                i = mem_align_mod_dest;
                while ((size_rem   >  0) &&                     /* ... start mem buf copy with leading octets ...       */
 800227a:	d1f7      	bne.n	800226c <Mem_Move+0x3c>
 800227c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800227e:	4620      	mov	r0, r4
            }

                                                                /* See Note #3a.                                        */
            pmem_align_dest = (      CPU_ALIGN *)((CPU_INT08U *)pmem_08_dest - sizeof(CPU_ALIGN) + 1);
            pmem_align_src  = (const CPU_ALIGN *)((CPU_INT08U *)pmem_08_src  - sizeof(CPU_ALIGN) + 1);
            while (size_rem      >=  sizeof(CPU_ALIGN)) {       /* While mem bufs aligned on CPU_ALIGN word boundaries, */
 8002280:	2803      	cmp	r0, #3
                    i--;
                }
            }

                                                                /* See Note #3a.                                        */
            pmem_align_dest = (      CPU_ALIGN *)((CPU_INT08U *)pmem_08_dest - sizeof(CPU_ALIGN) + 1);
 8002282:	f1a5 0703 	sub.w	r7, r5, #3
            pmem_align_src  = (const CPU_ALIGN *)((CPU_INT08U *)pmem_08_src  - sizeof(CPU_ALIGN) + 1);
 8002286:	f1a1 0303 	sub.w	r3, r1, #3
            while (size_rem      >=  sizeof(CPU_ALIGN)) {       /* While mem bufs aligned on CPU_ALIGN word boundaries, */
 800228a:	d92a      	bls.n	80022e2 <Mem_Move+0xb2>
                }
            }

                                                                /* See Note #3a.                                        */
            pmem_align_dest = (      CPU_ALIGN *)((CPU_INT08U *)pmem_08_dest - sizeof(CPU_ALIGN) + 1);
            pmem_align_src  = (const CPU_ALIGN *)((CPU_INT08U *)pmem_08_src  - sizeof(CPU_ALIGN) + 1);
 800228c:	461a      	mov	r2, r3
 800228e:	1f06      	subs	r6, r0, #4
 8002290:	08b6      	lsrs	r6, r6, #2
 8002292:	ea4f 0e86 	mov.w	lr, r6, lsl #2
 8002296:	f06f 0406 	mvn.w	r4, #6
 800229a:	ebce 0404 	rsb	r4, lr, r4
 800229e:	3501      	adds	r5, #1
 80022a0:	440c      	add	r4, r1
            while (size_rem      >=  sizeof(CPU_ALIGN)) {       /* While mem bufs aligned on CPU_ALIGN word boundaries, */
               *pmem_align_dest-- = *pmem_align_src--;          /* ... copy psrc to pdest with CPU_ALIGN-sized words.   */
 80022a2:	f852 1904 	ldr.w	r1, [r2], #-4
            }

                                                                /* See Note #3a.                                        */
            pmem_align_dest = (      CPU_ALIGN *)((CPU_INT08U *)pmem_08_dest - sizeof(CPU_ALIGN) + 1);
            pmem_align_src  = (const CPU_ALIGN *)((CPU_INT08U *)pmem_08_src  - sizeof(CPU_ALIGN) + 1);
            while (size_rem      >=  sizeof(CPU_ALIGN)) {       /* While mem bufs aligned on CPU_ALIGN word boundaries, */
 80022a6:	42a2      	cmp	r2, r4
               *pmem_align_dest-- = *pmem_align_src--;          /* ... copy psrc to pdest with CPU_ALIGN-sized words.   */
 80022a8:	f845 1d04 	str.w	r1, [r5, #-4]!
            }

                                                                /* See Note #3a.                                        */
            pmem_align_dest = (      CPU_ALIGN *)((CPU_INT08U *)pmem_08_dest - sizeof(CPU_ALIGN) + 1);
            pmem_align_src  = (const CPU_ALIGN *)((CPU_INT08U *)pmem_08_src  - sizeof(CPU_ALIGN) + 1);
            while (size_rem      >=  sizeof(CPU_ALIGN)) {       /* While mem bufs aligned on CPU_ALIGN word boundaries, */
 80022ac:	d1f9      	bne.n	80022a2 <Mem_Move+0x72>
 80022ae:	00b2      	lsls	r2, r6, #2
 80022b0:	f082 0203 	eor.w	r2, r2, #3
 80022b4:	43d2      	mvns	r2, r2
            pmem_08_src  = (const CPU_INT08U *)pmem_align_src  + sizeof(CPU_ALIGN) - 1;

        }
    }

    while (size_rem > 0) {                                      /* For unaligned mem bufs or trailing octets, ...       */
 80022b6:	f010 0403 	ands.w	r4, r0, #3
 80022ba:	4417      	add	r7, r2
 80022bc:	4413      	add	r3, r2
 80022be:	d00f      	beq.n	80022e0 <Mem_Move+0xb0>
            while (size_rem      >=  sizeof(CPU_ALIGN)) {       /* While mem bufs aligned on CPU_ALIGN word boundaries, */
               *pmem_align_dest-- = *pmem_align_src--;          /* ... copy psrc to pdest with CPU_ALIGN-sized words.   */
                size_rem         -=  sizeof(CPU_ALIGN);
            }

            pmem_08_dest = (      CPU_INT08U *)pmem_align_dest + sizeof(CPU_ALIGN) - 1;
 80022c0:	1cfd      	adds	r5, r7, #3
            pmem_08_src  = (const CPU_INT08U *)pmem_align_src  + sizeof(CPU_ALIGN) - 1;
 80022c2:	1cd9      	adds	r1, r3, #3
 80022c4:	1c6b      	adds	r3, r5, #1
 80022c6:	1b0a      	subs	r2, r1, r4

        }
    }

    while (size_rem > 0) {                                      /* For unaligned mem bufs or trailing octets, ...       */
       *pmem_08_dest-- = *pmem_08_src--;                        /* ... copy psrc to pdest by octets.                    */
 80022c8:	f811 0901 	ldrb.w	r0, [r1], #-1
            pmem_08_src  = (const CPU_INT08U *)pmem_align_src  + sizeof(CPU_ALIGN) - 1;

        }
    }

    while (size_rem > 0) {                                      /* For unaligned mem bufs or trailing octets, ...       */
 80022cc:	4291      	cmp	r1, r2
       *pmem_08_dest-- = *pmem_08_src--;                        /* ... copy psrc to pdest by octets.                    */
 80022ce:	f803 0d01 	strb.w	r0, [r3, #-1]!
            pmem_08_src  = (const CPU_INT08U *)pmem_align_src  + sizeof(CPU_ALIGN) - 1;

        }
    }

    while (size_rem > 0) {                                      /* For unaligned mem bufs or trailing octets, ...       */
 80022d2:	d1f9      	bne.n	80022c8 <Mem_Move+0x98>
 80022d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80022d6:	4770      	bx	lr
       *pmem_08_dest-- = *pmem_08_src--;                        /* ... copy psrc to pdest by octets.                    */
        size_rem      -=  sizeof(CPU_INT08U);
    }
}
 80022d8:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
#endif

    pmem_08_src  = (const CPU_INT08U *)psrc;
    pmem_08_dest = (      CPU_INT08U *)pdest;
    if (pmem_08_src > pmem_08_dest) {
        Mem_Copy(pdest, psrc, size);
 80022dc:	f000 bce2 	b.w	8002ca4 <Mem_Copy>
 80022e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
            }

                                                                /* See Note #3a.                                        */
            pmem_align_dest = (      CPU_ALIGN *)((CPU_INT08U *)pmem_08_dest - sizeof(CPU_ALIGN) + 1);
            pmem_align_src  = (const CPU_ALIGN *)((CPU_INT08U *)pmem_08_src  - sizeof(CPU_ALIGN) + 1);
            while (size_rem      >=  sizeof(CPU_ALIGN)) {       /* While mem bufs aligned on CPU_ALIGN word boundaries, */
 80022e2:	4604      	mov	r4, r0
 80022e4:	e7ec      	b.n	80022c0 <Mem_Move+0x90>
 80022e6:	bf00      	nop

080022e8 <Mem_Cmp>:
           CPU_DATA      mem_align_mod_2;
           CPU_BOOLEAN   mem_aligned;
           CPU_BOOLEAN   mem_cmp;


    if (size < 1) {                                             /* See Note #1.                                         */
 80022e8:	b1b2      	cbz	r2, 8002318 <Mem_Cmp+0x30>
        return (DEF_YES);
    }
    if (p1_mem == (void *)0) {
 80022ea:	b1a0      	cbz	r0, 8002316 <Mem_Cmp+0x2e>
        return (DEF_NO);
    }
    if (p2_mem == (void *)0) {
 80022ec:	b1b1      	cbz	r1, 800231c <Mem_Cmp+0x34>


    mem_cmp         =  DEF_YES;                                 /* Assume mem bufs are identical until cmp fails.       */
    size_rem        =  size;
                                                                /* Start @ end of mem bufs (see Note #2).               */
    p1_mem_08       = (const CPU_INT08U *)p1_mem + size;
 80022ee:	4410      	add	r0, r2
    p2_mem_08       = (const CPU_INT08U *)p2_mem + size;
 80022f0:	4411      	add	r1, r2
*/
/*$PAGE*/
CPU_BOOLEAN  Mem_Cmp (const  void        *p1_mem,
                      const  void        *p2_mem,
                             CPU_SIZE_T   size)
{
 80022f2:	b4f0      	push	{r4, r5, r6, r7}
    p2_mem_08       = (const CPU_INT08U *)p2_mem + size;
                                                                /* See Note #4.                                         */
    mem_align_mod_1 = (CPU_INT08U)((CPU_ADDR)p1_mem_08 % sizeof(CPU_ALIGN));
    mem_align_mod_2 = (CPU_INT08U)((CPU_ADDR)p2_mem_08 % sizeof(CPU_ALIGN));

    mem_aligned     = (mem_align_mod_1 == mem_align_mod_2) ? DEF_YES : DEF_NO;
 80022f4:	f001 0303 	and.w	r3, r1, #3
    size_rem        =  size;
                                                                /* Start @ end of mem bufs (see Note #2).               */
    p1_mem_08       = (const CPU_INT08U *)p1_mem + size;
    p2_mem_08       = (const CPU_INT08U *)p2_mem + size;
                                                                /* See Note #4.                                         */
    mem_align_mod_1 = (CPU_INT08U)((CPU_ADDR)p1_mem_08 % sizeof(CPU_ALIGN));
 80022f8:	f000 0503 	and.w	r5, r0, #3
    mem_align_mod_2 = (CPU_INT08U)((CPU_ADDR)p2_mem_08 % sizeof(CPU_ALIGN));

    mem_aligned     = (mem_align_mod_1 == mem_align_mod_2) ? DEF_YES : DEF_NO;
 80022fc:	429d      	cmp	r5, r3
 80022fe:	d028      	beq.n	8002352 <Mem_Cmp+0x6a>
 8002300:	1a12      	subs	r2, r2, r0
            p1_mem_08 = (CPU_INT08U *)p1_mem_align;
            p2_mem_08 = (CPU_INT08U *)p2_mem_align;
        }
    }

    while ((mem_cmp == DEF_YES) &&                              /* Cmp mem bufs while identical ...                     */
 8002302:	f810 4d01 	ldrb.w	r4, [r0, #-1]!
 8002306:	f811 3d01 	ldrb.w	r3, [r1, #-1]!
 800230a:	429c      	cmp	r4, r3
 800230c:	d11f      	bne.n	800234e <Mem_Cmp+0x66>
 800230e:	42d0      	cmn	r0, r2
 8002310:	d1f7      	bne.n	8002302 <Mem_Cmp+0x1a>
           CPU_BOOLEAN   mem_aligned;
           CPU_BOOLEAN   mem_cmp;


    if (size < 1) {                                             /* See Note #1.                                         */
        return (DEF_YES);
 8002312:	2001      	movs	r0, #1
        }
        size_rem -= sizeof(CPU_INT08U);
    }

    return (mem_cmp);
}
 8002314:	bcf0      	pop	{r4, r5, r6, r7}
 8002316:	4770      	bx	lr
           CPU_BOOLEAN   mem_aligned;
           CPU_BOOLEAN   mem_cmp;


    if (size < 1) {                                             /* See Note #1.                                         */
        return (DEF_YES);
 8002318:	2001      	movs	r0, #1
        }
        size_rem -= sizeof(CPU_INT08U);
    }

    return (mem_cmp);
}
 800231a:	4770      	bx	lr

    if (size < 1) {                                             /* See Note #1.                                         */
        return (DEF_YES);
    }
    if (p1_mem == (void *)0) {
        return (DEF_NO);
 800231c:	4608      	mov	r0, r1
 800231e:	4770      	bx	lr

        if (mem_cmp == DEF_YES) {                               /* If cmp still identical, cmp aligned mem bufs.        */
            p1_mem_align = (CPU_ALIGN *)p1_mem_08;              /* See Note #3a.                                        */
            p2_mem_align = (CPU_ALIGN *)p2_mem_08;

            while ((mem_cmp  == DEF_YES) &&                     /* Cmp mem bufs while identical & ...                   */
 8002320:	2a03      	cmp	r2, #3
 8002322:	d9ed      	bls.n	8002300 <Mem_Cmp+0x18>
 8002324:	f850 5c04 	ldr.w	r5, [r0, #-4]
 8002328:	f851 4c04 	ldr.w	r4, [r1, #-4]
                p1_mem_align--;
                p2_mem_align--;
                if (*p1_mem_align != *p2_mem_align) {           /* If ANY data octet(s) NOT identical, cmp fails.       */
                     mem_cmp = DEF_NO;
                }
                size_rem -= sizeof(CPU_ALIGN);
 800232c:	3a04      	subs	r2, #4

        if (mem_cmp == DEF_YES) {                               /* If cmp still identical, cmp aligned mem bufs.        */
            p1_mem_align = (CPU_ALIGN *)p1_mem_08;              /* See Note #3a.                                        */
            p2_mem_align = (CPU_ALIGN *)p2_mem_08;

            while ((mem_cmp  == DEF_YES) &&                     /* Cmp mem bufs while identical & ...                   */
 800232e:	42a5      	cmp	r5, r4
                   (size_rem >= sizeof(CPU_ALIGN))) {           /* ... mem bufs aligned on CPU_ALIGN word boundaries.   */
                p1_mem_align--;
 8002330:	f1a0 0004 	sub.w	r0, r0, #4
                p2_mem_align--;
 8002334:	f1a1 0304 	sub.w	r3, r1, #4

        if (mem_cmp == DEF_YES) {                               /* If cmp still identical, cmp aligned mem bufs.        */
            p1_mem_align = (CPU_ALIGN *)p1_mem_08;              /* See Note #3a.                                        */
            p2_mem_align = (CPU_ALIGN *)p2_mem_08;

            while ((mem_cmp  == DEF_YES) &&                     /* Cmp mem bufs while identical & ...                   */
 8002338:	d109      	bne.n	800234e <Mem_Cmp+0x66>
 800233a:	2a03      	cmp	r2, #3
 800233c:	4619      	mov	r1, r3
 800233e:	d924      	bls.n	800238a <Mem_Cmp+0xa2>
 8002340:	f850 4d04 	ldr.w	r4, [r0, #-4]!
 8002344:	f853 1d04 	ldr.w	r1, [r3, #-4]!
                p1_mem_align--;
                p2_mem_align--;
                if (*p1_mem_align != *p2_mem_align) {           /* If ANY data octet(s) NOT identical, cmp fails.       */
                     mem_cmp = DEF_NO;
                }
                size_rem -= sizeof(CPU_ALIGN);
 8002348:	3a04      	subs	r2, #4

        if (mem_cmp == DEF_YES) {                               /* If cmp still identical, cmp aligned mem bufs.        */
            p1_mem_align = (CPU_ALIGN *)p1_mem_08;              /* See Note #3a.                                        */
            p2_mem_align = (CPU_ALIGN *)p2_mem_08;

            while ((mem_cmp  == DEF_YES) &&                     /* Cmp mem bufs while identical & ...                   */
 800234a:	428c      	cmp	r4, r1
 800234c:	d0f5      	beq.n	800233a <Mem_Cmp+0x52>

    if (size < 1) {                                             /* See Note #1.                                         */
        return (DEF_YES);
    }
    if (p1_mem == (void *)0) {
        return (DEF_NO);
 800234e:	2000      	movs	r0, #0
 8002350:	e7e0      	b.n	8002314 <Mem_Cmp+0x2c>

    mem_aligned     = (mem_align_mod_1 == mem_align_mod_2) ? DEF_YES : DEF_NO;

    if (mem_aligned == DEF_YES) {                               /* If mem bufs' alignment offset equal, ...             */
                                                                /* ... optimize cmp for mem buf alignment.              */
        if (mem_align_mod_1 != 0u) {                            /* If trailing octets avail,                  ...       */
 8002352:	2d00      	cmp	r5, #0
 8002354:	d0e4      	beq.n	8002320 <Mem_Cmp+0x38>
            i = mem_align_mod_1;
            while ((mem_cmp == DEF_YES) &&                      /* ... cmp mem bufs while identical &         ...       */
 8002356:	f810 7c01 	ldrb.w	r7, [r0, #-1]
 800235a:	f811 6c01 	ldrb.w	r6, [r1, #-1]
                   (size_rem > 0)       &&                      /* ... start mem buf cmp with trailing octets ...       */
                   (i        > 0)) {                            /* ... until next CPU_ALIGN word boundary.              */
                p1_mem_08--;
 800235e:	3801      	subs	r0, #1

    if (mem_aligned == DEF_YES) {                               /* If mem bufs' alignment offset equal, ...             */
                                                                /* ... optimize cmp for mem buf alignment.              */
        if (mem_align_mod_1 != 0u) {                            /* If trailing octets avail,                  ...       */
            i = mem_align_mod_1;
            while ((mem_cmp == DEF_YES) &&                      /* ... cmp mem bufs while identical &         ...       */
 8002360:	42b7      	cmp	r7, r6
                   (size_rem > 0)       &&                      /* ... start mem buf cmp with trailing octets ...       */
                   (i        > 0)) {                            /* ... until next CPU_ALIGN word boundary.              */
                p1_mem_08--;
                p2_mem_08--;
 8002362:	f101 34ff 	add.w	r4, r1, #4294967295
                if (*p1_mem_08 != *p2_mem_08) {                 /* If ANY data octet(s) NOT identical, cmp fails.       */
                     mem_cmp = DEF_NO;
                }
                size_rem -= sizeof(CPU_INT08U);
 8002366:	f102 33ff 	add.w	r3, r2, #4294967295

    if (mem_aligned == DEF_YES) {                               /* If mem bufs' alignment offset equal, ...             */
                                                                /* ... optimize cmp for mem buf alignment.              */
        if (mem_align_mod_1 != 0u) {                            /* If trailing octets avail,                  ...       */
            i = mem_align_mod_1;
            while ((mem_cmp == DEF_YES) &&                      /* ... cmp mem bufs while identical &         ...       */
 800236a:	d1f0      	bne.n	800234e <Mem_Cmp+0x66>
 800236c:	1b52      	subs	r2, r2, r5
 800236e:	4621      	mov	r1, r4
 8002370:	2b00      	cmp	r3, #0
 8002372:	d0ce      	beq.n	8002312 <Mem_Cmp+0x2a>
                   (size_rem > 0)       &&                      /* ... start mem buf cmp with trailing octets ...       */
 8002374:	429a      	cmp	r2, r3
                p1_mem_08--;
                p2_mem_08--;
                if (*p1_mem_08 != *p2_mem_08) {                 /* If ANY data octet(s) NOT identical, cmp fails.       */
                     mem_cmp = DEF_NO;
                }
                size_rem -= sizeof(CPU_INT08U);
 8002376:	f103 33ff 	add.w	r3, r3, #4294967295
    if (mem_aligned == DEF_YES) {                               /* If mem bufs' alignment offset equal, ...             */
                                                                /* ... optimize cmp for mem buf alignment.              */
        if (mem_align_mod_1 != 0u) {                            /* If trailing octets avail,                  ...       */
            i = mem_align_mod_1;
            while ((mem_cmp == DEF_YES) &&                      /* ... cmp mem bufs while identical &         ...       */
                   (size_rem > 0)       &&                      /* ... start mem buf cmp with trailing octets ...       */
 800237a:	d0d1      	beq.n	8002320 <Mem_Cmp+0x38>

    if (mem_aligned == DEF_YES) {                               /* If mem bufs' alignment offset equal, ...             */
                                                                /* ... optimize cmp for mem buf alignment.              */
        if (mem_align_mod_1 != 0u) {                            /* If trailing octets avail,                  ...       */
            i = mem_align_mod_1;
            while ((mem_cmp == DEF_YES) &&                      /* ... cmp mem bufs while identical &         ...       */
 800237c:	f810 5d01 	ldrb.w	r5, [r0, #-1]!
 8002380:	f814 1d01 	ldrb.w	r1, [r4, #-1]!
 8002384:	428d      	cmp	r5, r1
 8002386:	d0f2      	beq.n	800236e <Mem_Cmp+0x86>
 8002388:	e7e1      	b.n	800234e <Mem_Cmp+0x66>
            p1_mem_08 = (CPU_INT08U *)p1_mem_align;
            p2_mem_08 = (CPU_INT08U *)p2_mem_align;
        }
    }

    while ((mem_cmp == DEF_YES) &&                              /* Cmp mem bufs while identical ...                     */
 800238a:	2a00      	cmp	r2, #0
 800238c:	d1b8      	bne.n	8002300 <Mem_Cmp+0x18>
 800238e:	e7c0      	b.n	8002312 <Mem_Cmp+0x2a>

08002390 <Mem_HeapAlloc>:
#if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
void  *Mem_HeapAlloc (CPU_SIZE_T   size,
                      CPU_SIZE_T   align,
                      CPU_SIZE_T  *poctets_reqd,
                      LIB_ERR     *perr)
{
 8002390:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002392:	4605      	mov	r5, r0
 8002394:	b085      	sub	sp, #20
 8002396:	460c      	mov	r4, r1
 8002398:	4617      	mov	r7, r2
    CPU_SIZE_T   size_req;
    CPU_SR_ALLOC();


#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
    if (perr == (LIB_ERR *)0) {
 800239a:	461e      	mov	r6, r3
 800239c:	2b00      	cmp	r3, #0
 800239e:	d036      	beq.n	800240e <Mem_HeapAlloc+0x7e>
        CPU_SW_EXCEPTION((void *)0);
    }
#endif

                                                                    /* ------------ VALIDATE RTN OCTETS PTR ----------- */
    if (poctets_reqd == (CPU_SIZE_T *) 0) {                         /* If NOT avail, ...                                */
 80023a0:	2f00      	cmp	r7, #0
 80023a2:	d038      	beq.n	8002416 <Mem_HeapAlloc+0x86>
        poctets_reqd  = (CPU_SIZE_T *)&octets_reqd_unused;          /* ... re-cfg NULL rtn ptr to unused local var.     */
       (void)&octets_reqd_unused;                                   /* Prevent possible 'variable unused' warning.      */
    }
   *poctets_reqd = 0u;                                              /* Init octets req'd for err (see Note #1).         */
 80023a4:	2300      	movs	r3, #0
 80023a6:	603b      	str	r3, [r7, #0]


#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------ VALIDATE HEAP MEM ALLOC ----------- */
    if (size < 1) {
 80023a8:	2d00      	cmp	r5, #0
 80023aa:	d039      	beq.n	8002420 <Mem_HeapAlloc+0x90>
       *perr = LIB_MEM_ERR_INVALID_MEM_SIZE;
        return ((void *)0);
    }

    if (align < 1) {
 80023ac:	2c00      	cmp	r4, #0
 80023ae:	d046      	beq.n	800243e <Mem_HeapAlloc+0xae>
#endif

                                                                    /* -------------- ALLOC HEAP MEM BLK -------------- */
    pmem_pool_heap = &Mem_PoolHeap;

    CPU_CRITICAL_ENTER();
 80023b0:	f7ff f9e0 	bl	8001774 <CPU_SR_Save>

    pmem_addr = pmem_pool_heap->SegAddrNextAvail;
 80023b4:	f8df e0bc 	ldr.w	lr, [pc, #188]	; 8002474 <Mem_HeapAlloc+0xe4>
 80023b8:	f8de 303c 	ldr.w	r3, [lr, #60]	; 0x3c
    size_rem  = pmem_pool_heap->SegSizeRem;
 80023bc:	f8de 2044 	ldr.w	r2, [lr, #68]	; 0x44
    CPU_SIZE_T  mem_align_offset;
    CPU_SIZE_T  blk_align_offset;
    CPU_SIZE_T  size_tot;

                                                                    /* Calc mem align (see Note #2a).                   */
    align_offset = (CPU_ADDR)pmem_addr % blk_align;
 80023c0:	fbb3 f1f4 	udiv	r1, r3, r4
 80023c4:	fb04 3111 	mls	r1, r4, r1, r3
    if (align_offset != 0u) {
 80023c8:	b159      	cbz	r1, 80023e2 <Mem_HeapAlloc+0x52>
        mem_align_offset = blk_align - align_offset;
 80023ca:	1a64      	subs	r4, r4, r1
                                                                    /* Calc tot size  (see Note #2c).                   */
    size_tot = mem_align_offset + ((blk_size + blk_align_offset) * ((CPU_SIZE_T)blk_nbr - 1)) + blk_size;

#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* Chk ovf of tot size = A + [(B + C) * D] + E      */
    blk_size_mem_aligned = mem_align_offset + blk_size;             /* Chk ovf of A + E :                               */
    if ((blk_size_mem_aligned < mem_align_offset) ||
 80023cc:	1929      	adds	r1, r5, r4
 80023ce:	d347      	bcc.n	8002460 <Mem_HeapAlloc+0xd0>
                                   1u,                              /* Calc alloc for single mem blk from heap.         */
                                   size,
                                   align);
#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    if (size_req < 1) {                                             /* If req'd size ovf, ...                           */
        CPU_CRITICAL_EXIT();
 80023d0:	f7ff f9d4 	bl	800177c <CPU_SR_Restore>
       *poctets_reqd = size;                                        /* ... rtn add'l heap size needed.                  */
       *perr         = LIB_MEM_ERR_HEAP_OVF;
 80023d4:	f242 73e3 	movw	r3, #10211	; 0x27e3
                                   size,
                                   align);
#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    if (size_req < 1) {                                             /* If req'd size ovf, ...                           */
        CPU_CRITICAL_EXIT();
       *poctets_reqd = size;                                        /* ... rtn add'l heap size needed.                  */
 80023d8:	603d      	str	r5, [r7, #0]
       *perr         = LIB_MEM_ERR_HEAP_OVF;
        return ((void *)0);
 80023da:	2000      	movs	r0, #0
                                   align);
#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    if (size_req < 1) {                                             /* If req'd size ovf, ...                           */
        CPU_CRITICAL_EXIT();
       *poctets_reqd = size;                                        /* ... rtn add'l heap size needed.                  */
       *perr         = LIB_MEM_ERR_HEAP_OVF;
 80023dc:	8033      	strh	r3, [r6, #0]
    CPU_CRITICAL_EXIT();

   *perr =  LIB_MEM_ERR_NONE;

    return (pmem_blk);
}
 80023de:	b005      	add	sp, #20
 80023e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
       *perr         = LIB_MEM_ERR_HEAP_OVF;
        return ((void *)0);
    }
#endif

    if (size_req > size_rem) {                                      /* If req'd size > rem heap size, ...               */
 80023e2:	4295      	cmp	r5, r2
 80023e4:	d831      	bhi.n	800244a <Mem_HeapAlloc+0xba>
    mem_align = (CPU_SIZE_T)((CPU_ADDR)pmem_addr % align);          /* Calc mem align.                                  */

    if (mem_align != 0u) {
        align_offset = align - mem_align;
    } else {
        align_offset = 0u;
 80023e6:	460c      	mov	r4, r1
    }

    size_tot = align_offset + size;
    if (size_tot > pmem_pool->SegSizeRem) {                         /* If insufficient mem seg size rem, ...            */
 80023e8:	4629      	mov	r1, r5
#endif

    pmem_addr_next = pmem_addr + size_tot;

#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    if (pmem_addr_next < pmem_addr) {                               /* If addr ovf, ...                                 */
 80023ea:	eb13 0c01 	adds.w	ip, r3, r1
 80023ee:	d21d      	bcs.n	800242c <Mem_HeapAlloc+0x9c>
#endif

    pmem_addr += align_offset;                                      /* Align mem addr.                                  */

    pmem_pool->SegAddrNextAvail  = (void     *)pmem_addr_next;      /* Adv next avail addr.                             */
    pmem_pool->SegSizeRem       -= (CPU_SIZE_T)size_tot;            /* Adj rem mem seg size.                            */
 80023f0:	1a52      	subs	r2, r2, r1
       *perr         = LIB_MEM_ERR_HEAP_EMPTY;
        return ((void *)0);
    }

    pmem_blk = Mem_SegAlloc(pmem_pool_heap, size, align);
    if (pmem_blk == (void *)0) {                                    /* If mem blk NOT avail from heap, ...              */
 80023f2:	191c      	adds	r4, r3, r4
#endif

    pmem_addr += align_offset;                                      /* Align mem addr.                                  */

    pmem_pool->SegAddrNextAvail  = (void     *)pmem_addr_next;      /* Adv next avail addr.                             */
    pmem_pool->SegSizeRem       -= (CPU_SIZE_T)size_tot;            /* Adj rem mem seg size.                            */
 80023f4:	f8ce 2044 	str.w	r2, [lr, #68]	; 0x44
    }
#endif

    pmem_addr += align_offset;                                      /* Align mem addr.                                  */

    pmem_pool->SegAddrNextAvail  = (void     *)pmem_addr_next;      /* Adv next avail addr.                             */
 80023f8:	f8ce c03c 	str.w	ip, [lr, #60]	; 0x3c
       *perr         = LIB_MEM_ERR_HEAP_EMPTY;
        return ((void *)0);
    }

    pmem_blk = Mem_SegAlloc(pmem_pool_heap, size, align);
    if (pmem_blk == (void *)0) {                                    /* If mem blk NOT avail from heap, ...              */
 80023fc:	d016      	beq.n	800242c <Mem_HeapAlloc+0x9c>
       *poctets_reqd = size_req;                                    /* ... rtn add'l heap size needed.                  */
       *perr         = LIB_MEM_ERR_HEAP_EMPTY;
        return ((void *)0);
    }

    CPU_CRITICAL_EXIT();
 80023fe:	f7ff f9bd 	bl	800177c <CPU_SR_Restore>

   *perr =  LIB_MEM_ERR_NONE;
 8002402:	f242 7310 	movw	r3, #10000	; 0x2710

    return (pmem_blk);
 8002406:	4620      	mov	r0, r4
        return ((void *)0);
    }

    CPU_CRITICAL_EXIT();

   *perr =  LIB_MEM_ERR_NONE;
 8002408:	8033      	strh	r3, [r6, #0]

    return (pmem_blk);
}
 800240a:	b005      	add	sp, #20
 800240c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    CPU_SR_ALLOC();


#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
    if (perr == (LIB_ERR *)0) {
        CPU_SW_EXCEPTION((void *)0);
 800240e:	f7ff fc25 	bl	8001c5c <CPU_SW_Exception>
    }
#endif

                                                                    /* ------------ VALIDATE RTN OCTETS PTR ----------- */
    if (poctets_reqd == (CPU_SIZE_T *) 0) {                         /* If NOT avail, ...                                */
 8002412:	2f00      	cmp	r7, #0
 8002414:	d1c6      	bne.n	80023a4 <Mem_HeapAlloc+0x14>
        poctets_reqd  = (CPU_SIZE_T *)&octets_reqd_unused;          /* ... re-cfg NULL rtn ptr to unused local var.     */
 8002416:	af03      	add	r7, sp, #12
       (void)&octets_reqd_unused;                                   /* Prevent possible 'variable unused' warning.      */
    }
   *poctets_reqd = 0u;                                              /* Init octets req'd for err (see Note #1).         */
 8002418:	2300      	movs	r3, #0
 800241a:	603b      	str	r3, [r7, #0]


#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------ VALIDATE HEAP MEM ALLOC ----------- */
    if (size < 1) {
 800241c:	2d00      	cmp	r5, #0
 800241e:	d1c5      	bne.n	80023ac <Mem_HeapAlloc+0x1c>
       *perr = LIB_MEM_ERR_INVALID_MEM_SIZE;
 8002420:	f242 7374 	movw	r3, #10100	; 0x2774
        return ((void *)0);
 8002424:	4628      	mov	r0, r5
   *poctets_reqd = 0u;                                              /* Init octets req'd for err (see Note #1).         */


#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------ VALIDATE HEAP MEM ALLOC ----------- */
    if (size < 1) {
       *perr = LIB_MEM_ERR_INVALID_MEM_SIZE;
 8002426:	8033      	strh	r3, [r6, #0]
    CPU_CRITICAL_EXIT();

   *perr =  LIB_MEM_ERR_NONE;

    return (pmem_blk);
}
 8002428:	b005      	add	sp, #20
 800242a:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return ((void *)0);
    }

    pmem_blk = Mem_SegAlloc(pmem_pool_heap, size, align);
    if (pmem_blk == (void *)0) {                                    /* If mem blk NOT avail from heap, ...              */
        CPU_CRITICAL_EXIT();
 800242c:	f7ff f9a6 	bl	800177c <CPU_SR_Restore>
       *poctets_reqd = size_req;                                    /* ... rtn add'l heap size needed.                  */
       *perr         = LIB_MEM_ERR_HEAP_EMPTY;
 8002430:	f242 73e2 	movw	r3, #10210	; 0x27e2
        return ((void *)0);
 8002434:	2000      	movs	r0, #0
    }

    pmem_blk = Mem_SegAlloc(pmem_pool_heap, size, align);
    if (pmem_blk == (void *)0) {                                    /* If mem blk NOT avail from heap, ...              */
        CPU_CRITICAL_EXIT();
       *poctets_reqd = size_req;                                    /* ... rtn add'l heap size needed.                  */
 8002436:	603d      	str	r5, [r7, #0]
       *perr         = LIB_MEM_ERR_HEAP_EMPTY;
 8002438:	8033      	strh	r3, [r6, #0]
    CPU_CRITICAL_EXIT();

   *perr =  LIB_MEM_ERR_NONE;

    return (pmem_blk);
}
 800243a:	b005      	add	sp, #20
 800243c:	bdf0      	pop	{r4, r5, r6, r7, pc}
       *perr = LIB_MEM_ERR_INVALID_MEM_SIZE;
        return ((void *)0);
    }

    if (align < 1) {
       *perr = LIB_MEM_ERR_INVALID_MEM_ALIGN;
 800243e:	f242 7375 	movw	r3, #10101	; 0x2775
        return ((void *)0);
 8002442:	4620      	mov	r0, r4
       *perr = LIB_MEM_ERR_INVALID_MEM_SIZE;
        return ((void *)0);
    }

    if (align < 1) {
       *perr = LIB_MEM_ERR_INVALID_MEM_ALIGN;
 8002444:	8033      	strh	r3, [r6, #0]
        return ((void *)0);
 8002446:	e7ca      	b.n	80023de <Mem_HeapAlloc+0x4e>
       *perr         = LIB_MEM_ERR_HEAP_OVF;
        return ((void *)0);
    }
#endif

    if (size_req > size_rem) {                                      /* If req'd size > rem heap size, ...               */
 8002448:	460d      	mov	r5, r1
 800244a:	9201      	str	r2, [sp, #4]
        CPU_CRITICAL_EXIT();
 800244c:	f7ff f996 	bl	800177c <CPU_SR_Restore>
       *poctets_reqd = size_req - size_rem;                         /* ... rtn add'l heap size needed.                  */
       *perr         = LIB_MEM_ERR_HEAP_EMPTY;
 8002450:	f242 73e2 	movw	r3, #10210	; 0x27e2
    }
#endif

    if (size_req > size_rem) {                                      /* If req'd size > rem heap size, ...               */
        CPU_CRITICAL_EXIT();
       *poctets_reqd = size_req - size_rem;                         /* ... rtn add'l heap size needed.                  */
 8002454:	9a01      	ldr	r2, [sp, #4]
 8002456:	1aa8      	subs	r0, r5, r2
 8002458:	6038      	str	r0, [r7, #0]
       *perr         = LIB_MEM_ERR_HEAP_EMPTY;
        return ((void *)0);
 800245a:	2000      	movs	r0, #0
#endif

    if (size_req > size_rem) {                                      /* If req'd size > rem heap size, ...               */
        CPU_CRITICAL_EXIT();
       *poctets_reqd = size_req - size_rem;                         /* ... rtn add'l heap size needed.                  */
       *perr         = LIB_MEM_ERR_HEAP_EMPTY;
 800245c:	8033      	strh	r3, [r6, #0]
        return ((void *)0);
 800245e:	e7be      	b.n	80023de <Mem_HeapAlloc+0x4e>
                                                                    /* Calc tot size  (see Note #2c).                   */
    size_tot = mem_align_offset + ((blk_size + blk_align_offset) * ((CPU_SIZE_T)blk_nbr - 1)) + blk_size;

#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* Chk ovf of tot size = A + [(B + C) * D] + E      */
    blk_size_mem_aligned = mem_align_offset + blk_size;             /* Chk ovf of A + E :                               */
    if ((blk_size_mem_aligned < mem_align_offset) ||
 8002460:	428d      	cmp	r5, r1
 8002462:	d8b5      	bhi.n	80023d0 <Mem_HeapAlloc+0x40>
       *perr         = LIB_MEM_ERR_HEAP_OVF;
        return ((void *)0);
    }
#endif

    if (size_req > size_rem) {                                      /* If req'd size > rem heap size, ...               */
 8002464:	428a      	cmp	r2, r1
 8002466:	d3ef      	bcc.n	8002448 <Mem_HeapAlloc+0xb8>
#endif

    pmem_addr_next = pmem_addr + size_tot;

#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    if (pmem_addr_next < pmem_addr) {                               /* If addr ovf, ...                                 */
 8002468:	eb13 0c01 	adds.w	ip, r3, r1
        align_offset = align - mem_align;
    } else {
        align_offset = 0u;
    }

    size_tot = align_offset + size;
 800246c:	460d      	mov	r5, r1
#endif

    pmem_addr_next = pmem_addr + size_tot;

#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    if (pmem_addr_next < pmem_addr) {                               /* If addr ovf, ...                                 */
 800246e:	d2dd      	bcs.n	800242c <Mem_HeapAlloc+0x9c>
 8002470:	e7be      	b.n	80023f0 <Mem_HeapAlloc+0x60>
 8002472:	bf00      	nop
 8002474:	2000b4c4 	.word	0x2000b4c4

08002478 <Mem_SegGetSizeRem>:
/*$PAGE*/
#if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
CPU_SIZE_T  Mem_SegGetSizeRem (MEM_POOL    *pmem_pool,
                               CPU_SIZE_T   align,
                               LIB_ERR     *perr)
{
 8002478:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800247a:	4604      	mov	r4, r0
 800247c:	460e      	mov	r6, r1
    CPU_SR_ALLOC();


#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
                                                                /* --------------- VALIDATE RTN ERR PTR --------------- */
    if (perr == (LIB_ERR *)0) {
 800247e:	4615      	mov	r5, r2
 8002480:	2a00      	cmp	r2, #0
 8002482:	d03d      	beq.n	8002500 <Mem_SegGetSizeRem+0x88>
        CPU_SW_EXCEPTION(0u);
    }
                                                                /* ---------------- VALIDATE MEM ALIGN ---------------- */
    if (align < 1) {
 8002484:	1e73      	subs	r3, r6, #1
 8002486:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800248a:	d304      	bcc.n	8002496 <Mem_SegGetSizeRem+0x1e>
       *perr =  LIB_MEM_ERR_INVALID_MEM_ALIGN;
 800248c:	f242 7375 	movw	r3, #10101	; 0x2775
        return (0u);
 8002490:	2000      	movs	r0, #0
    if (perr == (LIB_ERR *)0) {
        CPU_SW_EXCEPTION(0u);
    }
                                                                /* ---------------- VALIDATE MEM ALIGN ---------------- */
    if (align < 1) {
       *perr =  LIB_MEM_ERR_INVALID_MEM_ALIGN;
 8002492:	802b      	strh	r3, [r5, #0]
        return (0u);
 8002494:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (align > DEF_ALIGN_MAX_NBR_OCTETS) {
	   *perr =  LIB_MEM_ERR_INVALID_MEM_ALIGN;
        return (0u);
    }
                                                                /* ---------------- VALIDATE MEM POOL ----------------- */
    if (pmem_pool == (MEM_POOL *)0) {                           /* Validate mem ptr.                                    */
 8002496:	b374      	cbz	r4, 80024f6 <Mem_SegGetSizeRem+0x7e>
       *perr =  LIB_MEM_ERR_NULL_PTR;
        return (0u);
    }
#endif

    CPU_CRITICAL_ENTER();
 8002498:	f7ff f96c 	bl	8001774 <CPU_SR_Save>

#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    switch (pmem_pool->Type) {                                  /* Validate mem pool type.                              */
 800249c:	6823      	ldr	r3, [r4, #0]
 800249e:	4a1a      	ldr	r2, [pc, #104]	; (8002508 <Mem_SegGetSizeRem+0x90>)
       *perr =  LIB_MEM_ERR_NULL_PTR;
        return (0u);
    }
#endif

    CPU_CRITICAL_ENTER();
 80024a0:	4601      	mov	r1, r0

#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    switch (pmem_pool->Type) {                                  /* Validate mem pool type.                              */
 80024a2:	4293      	cmp	r3, r2
 80024a4:	d00e      	beq.n	80024c4 <Mem_SegGetSizeRem+0x4c>
 80024a6:	f102 727c 	add.w	r2, r2, #66060288	; 0x3f00000
 80024aa:	f502 32fa 	add.w	r2, r2, #128000	; 0x1f400
 80024ae:	f502 72fc 	add.w	r2, r2, #504	; 0x1f8
 80024b2:	4293      	cmp	r3, r2
 80024b4:	d006      	beq.n	80024c4 <Mem_SegGetSizeRem+0x4c>
             break;


        case LIB_MEM_TYPE_NONE:
        default:
             CPU_CRITICAL_EXIT();
 80024b6:	f7ff f961 	bl	800177c <CPU_SR_Restore>
            *perr =  LIB_MEM_ERR_INVALID_POOL;
 80024ba:	f242 7388 	movw	r3, #10120	; 0x2788
             return (0u);                                       /* Prevent 'break NOT reachable' compiler warning.      */
 80024be:	2000      	movs	r0, #0


        case LIB_MEM_TYPE_NONE:
        default:
             CPU_CRITICAL_EXIT();
            *perr =  LIB_MEM_ERR_INVALID_POOL;
 80024c0:	802b      	strh	r3, [r5, #0]
 80024c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
             return (0u);                                       /* Prevent 'break NOT reachable' compiler warning.      */
    }
#endif

                                                                /* ------------- GET REM'ING MEM SEG SIZE ------------- */
    pmem_seg      =  pmem_pool->SegHeadPtr;                     /* Get mem pool's head seg.                             */
 80024c4:	6863      	ldr	r3, [r4, #4]
    pmem_seg_size = (pmem_seg->SegAddr != (void *)0)
                  ?  pmem_seg : &Mem_PoolHeap;                  /* See Note #1.                                         */
 80024c6:	4a11      	ldr	r2, [pc, #68]	; (800250c <Mem_SegGetSizeRem+0x94>)
 80024c8:	6b9c      	ldr	r4, [r3, #56]	; 0x38
    size_rem      =  pmem_seg_size->SegSizeRem;                 /* Get mem seg's rem'ing mem size.                      */
    seg_addr      = (CPU_ADDR)pmem_seg_size->SegAddrNextAvail;

    CPU_CRITICAL_EXIT();
 80024ca:	4608      	mov	r0, r1
#endif

                                                                /* ------------- GET REM'ING MEM SEG SIZE ------------- */
    pmem_seg      =  pmem_pool->SegHeadPtr;                     /* Get mem pool's head seg.                             */
    pmem_seg_size = (pmem_seg->SegAddr != (void *)0)
                  ?  pmem_seg : &Mem_PoolHeap;                  /* See Note #1.                                         */
 80024cc:	2c00      	cmp	r4, #0
 80024ce:	bf08      	it	eq
 80024d0:	4613      	moveq	r3, r2
    size_rem      =  pmem_seg_size->SegSizeRem;                 /* Get mem seg's rem'ing mem size.                      */
 80024d2:	6c5c      	ldr	r4, [r3, #68]	; 0x44
    seg_addr      = (CPU_ADDR)pmem_seg_size->SegAddrNextAvail;
 80024d4:	6bdf      	ldr	r7, [r3, #60]	; 0x3c

    CPU_CRITICAL_EXIT();
 80024d6:	f7ff f951 	bl	800177c <CPU_SR_Restore>

    if (align > 1) {                                            /* If align > 1 octet, ...                              */
 80024da:	2e01      	cmp	r6, #1
 80024dc:	d006      	beq.n	80024ec <Mem_SegGetSizeRem+0x74>
        seg_addr_mod  =  seg_addr % align;
 80024de:	fbb7 f3f6 	udiv	r3, r7, r6
 80024e2:	fb06 7113 	mls	r1, r6, r3, r7
        size_rem_mod  = (seg_addr_mod > 0u) ? (align - seg_addr_mod) : 0u;
 80024e6:	b101      	cbz	r1, 80024ea <Mem_SegGetSizeRem+0x72>
 80024e8:	1a71      	subs	r1, r6, r1
        size_rem     -=  size_rem_mod;                          /* ... adj rem'ing size by offset to align'd seg addr.  */
 80024ea:	1a64      	subs	r4, r4, r1
    }


   *perr =  LIB_MEM_ERR_NONE;
 80024ec:	f242 7310 	movw	r3, #10000	; 0x2710

    return (size_rem);
 80024f0:	4620      	mov	r0, r4
        size_rem_mod  = (seg_addr_mod > 0u) ? (align - seg_addr_mod) : 0u;
        size_rem     -=  size_rem_mod;                          /* ... adj rem'ing size by offset to align'd seg addr.  */
    }


   *perr =  LIB_MEM_ERR_NONE;
 80024f2:	802b      	strh	r3, [r5, #0]
 80024f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	   *perr =  LIB_MEM_ERR_INVALID_MEM_ALIGN;
        return (0u);
    }
                                                                /* ---------------- VALIDATE MEM POOL ----------------- */
    if (pmem_pool == (MEM_POOL *)0) {                           /* Validate mem ptr.                                    */
       *perr =  LIB_MEM_ERR_NULL_PTR;
 80024f6:	f242 7311 	movw	r3, #10001	; 0x2711
        return (0u);
 80024fa:	4620      	mov	r0, r4
	   *perr =  LIB_MEM_ERR_INVALID_MEM_ALIGN;
        return (0u);
    }
                                                                /* ---------------- VALIDATE MEM POOL ----------------- */
    if (pmem_pool == (MEM_POOL *)0) {                           /* Validate mem ptr.                                    */
       *perr =  LIB_MEM_ERR_NULL_PTR;
 80024fc:	802b      	strh	r3, [r5, #0]
        return (0u);
 80024fe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}


#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
                                                                /* --------------- VALIDATE RTN ERR PTR --------------- */
    if (perr == (LIB_ERR *)0) {
        CPU_SW_EXCEPTION(0u);
 8002500:	f7ff fbac 	bl	8001c5c <CPU_SW_Exception>
 8002504:	e7be      	b.n	8002484 <Mem_SegGetSizeRem+0xc>
 8002506:	bf00      	nop
 8002508:	4c4f4f50 	.word	0x4c4f4f50
 800250c:	2000b4c4 	.word	0x2000b4c4

08002510 <Mem_HeapGetSizeRem>:
                                LIB_ERR     *perr)
{
    CPU_SIZE_T  size_rem;


    size_rem = Mem_SegGetSizeRem(&Mem_PoolHeap, align, perr);
 8002510:	460a      	mov	r2, r1
 8002512:	4601      	mov	r1, r0
 8002514:	4801      	ldr	r0, [pc, #4]	; (800251c <Mem_HeapGetSizeRem+0xc>)
 8002516:	f7ff bfaf 	b.w	8002478 <Mem_SegGetSizeRem>
 800251a:	bf00      	nop
 800251c:	2000b4c4 	.word	0x2000b4c4

08002520 <Mem_PoolClr>:
*/

#if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
void  Mem_PoolClr (MEM_POOL  *pmem_pool,
                   LIB_ERR   *perr)
{
 8002520:	b510      	push	{r4, lr}
 8002522:	b082      	sub	sp, #8

#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE RTN ERR  PTR --------------- */
    if (perr == (LIB_ERR *)0) {
 8002524:	b1c9      	cbz	r1, 800255a <Mem_PoolClr+0x3a>
        CPU_SW_EXCEPTION(;);
    }
#endif

                                                                /* -------------- VALIDATE MEM POOL PTR --------------- */
    if (pmem_pool == (MEM_POOL *)0) {
 8002526:	b300      	cbz	r0, 800256a <Mem_PoolClr+0x4a>
    pmem_pool->SegAddrNextAvail = (void       *)0;
    pmem_pool->SegSizeTot       = (CPU_SIZE_T  )0u;
    pmem_pool->SegSizeRem       = (CPU_SIZE_T  )0u;


   *perr = LIB_MEM_ERR_NONE;
 8002528:	f242 7210 	movw	r2, #10000	; 0x2710
       *perr = LIB_MEM_ERR_NULL_PTR;
        return;
    }


    pmem_pool->Type             = (LIB_MEM_TYPE)LIB_MEM_TYPE_NONE;
 800252c:	4c11      	ldr	r4, [pc, #68]	; (8002574 <Mem_PoolClr+0x54>)
    pmem_pool->SegHeadPtr       = (MEM_POOL   *)0;
 800252e:	2300      	movs	r3, #0
       *perr = LIB_MEM_ERR_NULL_PTR;
        return;
    }


    pmem_pool->Type             = (LIB_MEM_TYPE)LIB_MEM_TYPE_NONE;
 8002530:	6004      	str	r4, [r0, #0]
    pmem_pool->SegHeadPtr       = (MEM_POOL   *)0;
 8002532:	6043      	str	r3, [r0, #4]
    pmem_pool->SegPrevPtr       = (MEM_POOL   *)0;
 8002534:	6083      	str	r3, [r0, #8]
    pmem_pool->SegNextPtr       = (MEM_POOL   *)0;
 8002536:	60c3      	str	r3, [r0, #12]
    pmem_pool->PoolPrevPtr      = (MEM_POOL   *)0;
 8002538:	6103      	str	r3, [r0, #16]
    pmem_pool->PoolNextPtr      = (MEM_POOL   *)0;
 800253a:	6143      	str	r3, [r0, #20]
    pmem_pool->PoolAddrStart    = (void       *)0;
 800253c:	6183      	str	r3, [r0, #24]
    pmem_pool->PoolAddrEnd      = (void       *)0;
 800253e:	61c3      	str	r3, [r0, #28]
    pmem_pool->PoolPtrs         = (void      **)0;
 8002540:	6203      	str	r3, [r0, #32]
    pmem_pool->PoolSize         = (CPU_SIZE_T  )0u;
 8002542:	6283      	str	r3, [r0, #40]	; 0x28
    pmem_pool->BlkAlign         = (CPU_SIZE_T  )0u;
 8002544:	6343      	str	r3, [r0, #52]	; 0x34
    pmem_pool->BlkSize          = (CPU_SIZE_T  )0u;
 8002546:	6303      	str	r3, [r0, #48]	; 0x30
    pmem_pool->BlkNbr           = (CPU_SIZE_T  )0u;
 8002548:	62c3      	str	r3, [r0, #44]	; 0x2c
    pmem_pool->BlkIx            = (MEM_POOL_IX )0u;
 800254a:	6243      	str	r3, [r0, #36]	; 0x24
    pmem_pool->SegAddr          = (void       *)0;
 800254c:	6383      	str	r3, [r0, #56]	; 0x38
    pmem_pool->SegAddrNextAvail = (void       *)0;
 800254e:	63c3      	str	r3, [r0, #60]	; 0x3c
    pmem_pool->SegSizeTot       = (CPU_SIZE_T  )0u;
 8002550:	6403      	str	r3, [r0, #64]	; 0x40
    pmem_pool->SegSizeRem       = (CPU_SIZE_T  )0u;
 8002552:	6443      	str	r3, [r0, #68]	; 0x44


   *perr = LIB_MEM_ERR_NONE;
 8002554:	800a      	strh	r2, [r1, #0]
}
 8002556:	b002      	add	sp, #8
 8002558:	bd10      	pop	{r4, pc}
 800255a:	e88d 0003 	stmia.w	sp, {r0, r1}
                   LIB_ERR   *perr)
{

#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE RTN ERR  PTR --------------- */
    if (perr == (LIB_ERR *)0) {
        CPU_SW_EXCEPTION(;);
 800255e:	f7ff fb7d 	bl	8001c5c <CPU_SW_Exception>
 8002562:	e89d 0003 	ldmia.w	sp, {r0, r1}
    }
#endif

                                                                /* -------------- VALIDATE MEM POOL PTR --------------- */
    if (pmem_pool == (MEM_POOL *)0) {
 8002566:	2800      	cmp	r0, #0
 8002568:	d1de      	bne.n	8002528 <Mem_PoolClr+0x8>
       *perr = LIB_MEM_ERR_NULL_PTR;
 800256a:	f242 7311 	movw	r3, #10001	; 0x2711
 800256e:	800b      	strh	r3, [r1, #0]
    pmem_pool->SegSizeTot       = (CPU_SIZE_T  )0u;
    pmem_pool->SegSizeRem       = (CPU_SIZE_T  )0u;


   *perr = LIB_MEM_ERR_NONE;
}
 8002570:	b002      	add	sp, #8
 8002572:	bd10      	pop	{r4, pc}
 8002574:	454e4f4e 	.word	0x454e4f4e

08002578 <Mem_PoolCreate>:
                      MEM_POOL_BLK_QTY   blk_nbr,
                      CPU_SIZE_T         blk_size,
                      CPU_SIZE_T         blk_align,
                      CPU_SIZE_T        *poctets_reqd,
                      LIB_ERR           *perr)
{
 8002578:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800257c:	b089      	sub	sp, #36	; 0x24
 800257e:	9c15      	ldr	r4, [sp, #84]	; 0x54
 8002580:	4606      	mov	r6, r0
 8002582:	460f      	mov	r7, r1
 8002584:	4690      	mov	r8, r2
 8002586:	4699      	mov	r9, r3
 8002588:	9d14      	ldr	r5, [sp, #80]	; 0x50
    CPU_SIZE_T          i;
    CPU_SR_ALLOC();


#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
    if (perr == (LIB_ERR *)0) {
 800258a:	b1fc      	cbz	r4, 80025cc <Mem_PoolCreate+0x54>
        CPU_SW_EXCEPTION(;);
    }
#endif

                                                                    /* ------------ VALIDATE RTN OCTETS PTR ----------- */
    if (poctets_reqd == (CPU_SIZE_T *) 0) {                         /* If NOT avail, ...                                */
 800258c:	b315      	cbz	r5, 80025d4 <Mem_PoolCreate+0x5c>
        poctets_reqd  = (CPU_SIZE_T *)&octets_reqd_unused;          /* ... re-cfg NULL rtn ptr to unused local var.     */
       (void)&octets_reqd_unused;                                   /* Prevent possible 'variable unused' warning.      */
    }
   *poctets_reqd = 0u;                                              /* Init octets req'd for err (see Note #4).         */
 800258e:	2300      	movs	r3, #0
 8002590:	602b      	str	r3, [r5, #0]



    Mem_PoolClr(pmem_pool, perr);                                   /* Init mem pool     for err (see Note #4).         */
 8002592:	4621      	mov	r1, r4
 8002594:	4630      	mov	r0, r6
 8002596:	f7ff ffc3 	bl	8002520 <Mem_PoolClr>
    if (*perr != LIB_MEM_ERR_NONE) {
 800259a:	f242 7310 	movw	r3, #10000	; 0x2710
 800259e:	8822      	ldrh	r2, [r4, #0]
 80025a0:	429a      	cmp	r2, r3
 80025a2:	d002      	beq.n	80025aa <Mem_PoolCreate+0x32>


    CPU_CRITICAL_EXIT();

   *perr = LIB_MEM_ERR_NONE;
}
 80025a4:	b009      	add	sp, #36	; 0x24
 80025a6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    }


                                                                    /* ----------- VALIDATE MEM POOL CREATE ----------- */
#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    if (pmem_base_addr != (void *)0) {
 80025aa:	b117      	cbz	r7, 80025b2 <Mem_PoolCreate+0x3a>
        if (mem_size < 1) {
 80025ac:	f1b8 0f00 	cmp.w	r8, #0
 80025b0:	d006      	beq.n	80025c0 <Mem_PoolCreate+0x48>
           *perr = LIB_MEM_ERR_INVALID_SEG_SIZE;
            return;
        }
    }

    if (blk_nbr < 1) {
 80025b2:	f1b9 0f00 	cmp.w	r9, #0
 80025b6:	d10f      	bne.n	80025d8 <Mem_PoolCreate+0x60>
       *perr = LIB_MEM_ERR_INVALID_BLK_NBR;
 80025b8:	f242 7392 	movw	r3, #10130	; 0x2792
 80025bc:	8023      	strh	r3, [r4, #0]
        return;
 80025be:	e7f1      	b.n	80025a4 <Mem_PoolCreate+0x2c>

                                                                    /* ----------- VALIDATE MEM POOL CREATE ----------- */
#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    if (pmem_base_addr != (void *)0) {
        if (mem_size < 1) {
           *perr = LIB_MEM_ERR_INVALID_SEG_SIZE;
 80025c0:	f242 737e 	movw	r3, #10110	; 0x277e
 80025c4:	8023      	strh	r3, [r4, #0]


    CPU_CRITICAL_EXIT();

   *perr = LIB_MEM_ERR_NONE;
}
 80025c6:	b009      	add	sp, #36	; 0x24
 80025c8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    CPU_SR_ALLOC();


#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
    if (perr == (LIB_ERR *)0) {
        CPU_SW_EXCEPTION(;);
 80025cc:	f7ff fb46 	bl	8001c5c <CPU_SW_Exception>
    }
#endif

                                                                    /* ------------ VALIDATE RTN OCTETS PTR ----------- */
    if (poctets_reqd == (CPU_SIZE_T *) 0) {                         /* If NOT avail, ...                                */
 80025d0:	2d00      	cmp	r5, #0
 80025d2:	d1dc      	bne.n	800258e <Mem_PoolCreate+0x16>
        poctets_reqd  = (CPU_SIZE_T *)&octets_reqd_unused;          /* ... re-cfg NULL rtn ptr to unused local var.     */
 80025d4:	ad07      	add	r5, sp, #28
 80025d6:	e7da      	b.n	800258e <Mem_PoolCreate+0x16>
    if (blk_nbr < 1) {
       *perr = LIB_MEM_ERR_INVALID_BLK_NBR;
        return;
    }

    if (blk_size < 1) {
 80025d8:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80025da:	b12b      	cbz	r3, 80025e8 <Mem_PoolCreate+0x70>
       *perr = LIB_MEM_ERR_INVALID_BLK_SIZE;
        return;
    }

    if (blk_align < 1) {
 80025dc:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80025de:	b93b      	cbnz	r3, 80025f0 <Mem_PoolCreate+0x78>
       *perr = LIB_MEM_ERR_INVALID_BLK_ALIGN;
 80025e0:	f242 7394 	movw	r3, #10132	; 0x2794
 80025e4:	8023      	strh	r3, [r4, #0]
        return;
 80025e6:	e7dd      	b.n	80025a4 <Mem_PoolCreate+0x2c>
       *perr = LIB_MEM_ERR_INVALID_BLK_NBR;
        return;
    }

    if (blk_size < 1) {
       *perr = LIB_MEM_ERR_INVALID_BLK_SIZE;
 80025e8:	f242 7393 	movw	r3, #10131	; 0x2793
 80025ec:	8023      	strh	r3, [r4, #0]
        return;
 80025ee:	e7d9      	b.n	80025a4 <Mem_PoolCreate+0x2c>
    }
#endif


                                                                    /* ------------ VALIDATE MEM POOL TBL ------------- */
    if (Mem_PoolTbl == (MEM_POOL *)0) {
 80025f0:	4bb5      	ldr	r3, [pc, #724]	; (80028c8 <Mem_PoolCreate+0x350>)
 80025f2:	681b      	ldr	r3, [r3, #0]
 80025f4:	2b00      	cmp	r3, #0
 80025f6:	f000 8086 	beq.w	8002706 <Mem_PoolCreate+0x18e>
/*$PAGE*/
                                                                    /* ---------------- CREATE MEM POOL --------------- */
    pmem_pool_heap = (MEM_POOL *)&Mem_PoolHeap;
    size_tot       = (CPU_SIZE_T) 0u;

    CPU_CRITICAL_ENTER();
 80025fa:	f7ff f8bb 	bl	8001774 <CPU_SR_Save>
 80025fe:	9000      	str	r0, [sp, #0]

    if (pmem_base_addr == (void *)0) {                              /* If no base addr, cfg mem pool from heap.         */
 8002600:	2f00      	cmp	r7, #0
 8002602:	f000 809a 	beq.w	800273a <Mem_PoolCreate+0x1c2>

/*$PAGE*/
    } else {                                                        /* Else cfg mem pool from dedicated mem.            */
                                                                    /* -------- SRCH ALL MEM SEGS FOR MEM POOL -------- */
        pmem_base_addr_start = (CPU_INT08U *)pmem_base_addr;
        pmem_base_addr_end   = (CPU_INT08U *)pmem_base_addr + mem_size - 1;
 8002606:	f108 31ff 	add.w	r1, r8, #4294967295

#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
        if (pmem_base_addr_end < pmem_base_addr_start) {            /* Chk ovf of end addr.                             */
 800260a:	1879      	adds	r1, r7, r1
 800260c:	d27f      	bcs.n	800270e <Mem_PoolCreate+0x196>
        }
#endif

        pmem_seg      = (MEM_POOL *)0;
        pmem_seg_prev = (MEM_POOL *)0;
        pmem_seg_next =  Mem_PoolTbl;
 800260e:	4bae      	ldr	r3, [pc, #696]	; (80028c8 <Mem_PoolCreate+0x350>)
 8002610:	f8d3 a000 	ldr.w	sl, [r3]

        while (pmem_seg_next != (MEM_POOL *)0) {                    /* Srch tbl for mem seg with same base addr/size.   */
 8002614:	f1ba 0f00 	cmp.w	sl, #0
 8002618:	f000 8168 	beq.w	80028ec <Mem_PoolCreate+0x374>
 800261c:	2200      	movs	r2, #0

            if ((pmem_base_addr == pmem_seg_next->SegAddr) &&       /* If same base addr/size found, ...                */
 800261e:	f8da 3038 	ldr.w	r3, [sl, #56]	; 0x38
 8002622:	429f      	cmp	r7, r3
 8002624:	d01a      	beq.n	800265c <Mem_PoolCreate+0xe4>
            } else {
                pmem_seg_addr_start = (CPU_INT08U *)pmem_seg_next->SegAddr;
                pmem_seg_addr_end   = (CPU_INT08U *)pmem_seg_next->SegAddr + pmem_seg_next->SegSizeTot - 1;


                if (pmem_base_addr_end < pmem_seg_addr_start) {     /* If mem seg addr/size prior to next mem seg, ...  */
 8002626:	4299      	cmp	r1, r3
 8002628:	f0c0 80b4 	bcc.w	8002794 <Mem_PoolCreate+0x21c>
                    break;                                          /* ... new mem seg NOT avail in tbl.                */

                                                                    /* If mem seg overlaps prev mem seg(s) in tbl, ...  */
                } else if (((pmem_base_addr_start <= pmem_seg_addr_start)  &&
 800262c:	429f      	cmp	r7, r3
 800262e:	d806      	bhi.n	800263e <Mem_PoolCreate+0xc6>
                            (pmem_base_addr_end   >= pmem_seg_addr_start)) ||
                           ((pmem_base_addr_start >= pmem_seg_addr_start)  &&
                            (pmem_base_addr_end   <= pmem_seg_addr_end  )) ||
                           ((pmem_base_addr_start <= pmem_seg_addr_end  )  &&
                            (pmem_base_addr_end   >= pmem_seg_addr_end  ))) {
                    CPU_CRITICAL_EXIT();
 8002630:	9800      	ldr	r0, [sp, #0]
 8002632:	f7ff f8a3 	bl	800177c <CPU_SR_Restore>
                   *perr = LIB_MEM_ERR_INVALID_SEG_OVERLAP;         /* ... rtn err.                                     */
 8002636:	f242 737f 	movw	r3, #10111	; 0x277f
 800263a:	8023      	strh	r3, [r4, #0]
                    return;
 800263c:	e7b2      	b.n	80025a4 <Mem_PoolCreate+0x2c>
                 pmem_seg        = pmem_seg_next;                   /* ... mem seg already avail in tbl.                */
                 break;

            } else {
                pmem_seg_addr_start = (CPU_INT08U *)pmem_seg_next->SegAddr;
                pmem_seg_addr_end   = (CPU_INT08U *)pmem_seg_next->SegAddr + pmem_seg_next->SegSizeTot - 1;
 800263e:	f8da 2040 	ldr.w	r2, [sl, #64]	; 0x40
 8002642:	3a01      	subs	r2, #1
 8002644:	4413      	add	r3, r2
                    break;                                          /* ... new mem seg NOT avail in tbl.                */

                                                                    /* If mem seg overlaps prev mem seg(s) in tbl, ...  */
                } else if (((pmem_base_addr_start <= pmem_seg_addr_start)  &&
                            (pmem_base_addr_end   >= pmem_seg_addr_start)) ||
                           ((pmem_base_addr_start >= pmem_seg_addr_start)  &&
 8002646:	4299      	cmp	r1, r3
 8002648:	d9f2      	bls.n	8002630 <Mem_PoolCreate+0xb8>
                            (pmem_base_addr_end   <= pmem_seg_addr_end  )) ||
 800264a:	429f      	cmp	r7, r3
 800264c:	d9f0      	bls.n	8002630 <Mem_PoolCreate+0xb8>
                    return;
                }
            }
                                                                    /* If mem seg NOT found, adv to next mem seg.       */
            pmem_seg_prev = pmem_seg_next;
            pmem_seg_next = pmem_seg_next->SegNextPtr;
 800264e:	f8da 300c 	ldr.w	r3, [sl, #12]
 8002652:	4652      	mov	r2, sl

        pmem_seg      = (MEM_POOL *)0;
        pmem_seg_prev = (MEM_POOL *)0;
        pmem_seg_next =  Mem_PoolTbl;

        while (pmem_seg_next != (MEM_POOL *)0) {                    /* Srch tbl for mem seg with same base addr/size.   */
 8002654:	2b00      	cmp	r3, #0
 8002656:	d067      	beq.n	8002728 <Mem_PoolCreate+0x1b0>
 8002658:	469a      	mov	sl, r3
 800265a:	e7e0      	b.n	800261e <Mem_PoolCreate+0xa6>

            if ((pmem_base_addr == pmem_seg_next->SegAddr) &&       /* If same base addr/size found, ...                */
 800265c:	f8da 3040 	ldr.w	r3, [sl, #64]	; 0x40
 8002660:	4598      	cmp	r8, r3
 8002662:	d1e5      	bne.n	8002630 <Mem_PoolCreate+0xb8>
 8002664:	46d3      	mov	fp, sl
 8002666:	46d0      	mov	r8, sl
 8002668:	4692      	mov	sl, r2
        }

/*$PAGE*/
                                                                    /* --------------- VALIDATE MEM SEG --------------- */
                                                                    /* Calc tot mem size for mem pool ptrs.             */
        pmem_addr_ptrs = (CPU_INT08U *)pmem_pool_heap->SegAddrNextAvail;
 800266a:	4b98      	ldr	r3, [pc, #608]	; (80028cc <Mem_PoolCreate+0x354>)
        size_tot_ptrs  =  Mem_SegCalcTotSize((void     *)pmem_addr_ptrs,
 800266c:	4649      	mov	r1, r9
        }

/*$PAGE*/
                                                                    /* --------------- VALIDATE MEM SEG --------------- */
                                                                    /* Calc tot mem size for mem pool ptrs.             */
        pmem_addr_ptrs = (CPU_INT08U *)pmem_pool_heap->SegAddrNextAvail;
 800266e:	461a      	mov	r2, r3
 8002670:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
 8002672:	9301      	str	r3, [sp, #4]
        size_tot_ptrs  =  Mem_SegCalcTotSize((void     *)pmem_addr_ptrs,
 8002674:	2304      	movs	r3, #4
        }

/*$PAGE*/
                                                                    /* --------------- VALIDATE MEM SEG --------------- */
                                                                    /* Calc tot mem size for mem pool ptrs.             */
        pmem_addr_ptrs = (CPU_INT08U *)pmem_pool_heap->SegAddrNextAvail;
 8002676:	4610      	mov	r0, r2
 8002678:	9203      	str	r2, [sp, #12]
        size_tot_ptrs  =  Mem_SegCalcTotSize((void     *)pmem_addr_ptrs,
 800267a:	461a      	mov	r2, r3
 800267c:	f7ff fd30 	bl	80020e0 <Mem_SegCalcTotSize>
                                             (CPU_SIZE_T)blk_nbr,
                                             (CPU_SIZE_T)sizeof(void *),
                                             (CPU_SIZE_T)sizeof(void *));
#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
        if (size_tot_ptrs < 1) {                                    /* If heap ovf, ...                                 */
 8002680:	2800      	cmp	r0, #0
 8002682:	d04a      	beq.n	800271a <Mem_PoolCreate+0x1a2>
           *perr = LIB_MEM_ERR_HEAP_OVF;                            /* ... rtn err but add'l heap size NOT avail.       */
            return;
        }
#endif

        size_rem = pmem_pool_heap->SegSizeRem;
 8002684:	9a01      	ldr	r2, [sp, #4]
 8002686:	6c52      	ldr	r2, [r2, #68]	; 0x44
        if (size_tot_ptrs > size_rem) {                             /* If ptr size > rem  size, ...                     */
 8002688:	4290      	cmp	r0, r2
           *perr = LIB_MEM_ERR_HEAP_OVF;                            /* ... rtn err but add'l heap size NOT avail.       */
            return;
        }
#endif

        size_rem = pmem_pool_heap->SegSizeRem;
 800268a:	9204      	str	r2, [sp, #16]
        if (size_tot_ptrs > size_rem) {                             /* If ptr size > rem  size, ...                     */
 800268c:	f200 8085 	bhi.w	800279a <Mem_PoolCreate+0x222>
           *perr         = LIB_MEM_ERR_HEAP_EMPTY;
            return;
        }

                                                                    /* Calc tot mem size for mem blks.                  */
        pmem_addr_pool = (CPU_INT08U *)pmem_seg->SegAddrNextAvail;
 8002690:	f8d8 303c 	ldr.w	r3, [r8, #60]	; 0x3c
        size_tot_pool  =  Mem_SegCalcTotSize((void     *)pmem_addr_pool,
 8002694:	9a12      	ldr	r2, [sp, #72]	; 0x48
           *perr         = LIB_MEM_ERR_HEAP_EMPTY;
            return;
        }

                                                                    /* Calc tot mem size for mem blks.                  */
        pmem_addr_pool = (CPU_INT08U *)pmem_seg->SegAddrNextAvail;
 8002696:	4618      	mov	r0, r3
 8002698:	9305      	str	r3, [sp, #20]
        size_tot_pool  =  Mem_SegCalcTotSize((void     *)pmem_addr_pool,
 800269a:	4649      	mov	r1, r9
 800269c:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800269e:	f7ff fd1f 	bl	80020e0 <Mem_SegCalcTotSize>
                                             (CPU_SIZE_T)blk_nbr,
                                             (CPU_SIZE_T)blk_size,
                                             (CPU_SIZE_T)blk_align);
#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
        if (size_tot_pool < 1) {                                    /* If seg  ovf, ...                                 */
 80026a2:	9002      	str	r0, [sp, #8]
 80026a4:	2800      	cmp	r0, #0
 80026a6:	f000 8107 	beq.w	80028b8 <Mem_PoolCreate+0x340>
           *perr = LIB_MEM_ERR_SEG_OVF;                             /* ... rtn err but add'l seg  size NOT avail.       */
            return;
        }
#endif

        size_rem = pmem_seg->SegSizeRem;
 80026aa:	f8d8 3044 	ldr.w	r3, [r8, #68]	; 0x44
        if (size_tot_pool > size_rem) {                             /* If tot size > rem  size, ...                     */
 80026ae:	9a02      	ldr	r2, [sp, #8]
 80026b0:	429a      	cmp	r2, r3
 80026b2:	f200 810f 	bhi.w	80028d4 <Mem_PoolCreate+0x35c>
 80026b6:	f8dd c010 	ldr.w	ip, [sp, #16]
 80026ba:	f8dd e00c 	ldr.w	lr, [sp, #12]


/*$PAGE*/
                                                                    /* ---------------- CREATE MEM POOL --------------- */
    pmem_pool_heap = (MEM_POOL *)&Mem_PoolHeap;
    size_tot       = (CPU_SIZE_T) 0u;
 80026be:	2200      	movs	r2, #0

    pmem_addr = (CPU_INT08U *)pmem_pool->SegAddrNextAvail;

    mem_align = (CPU_SIZE_T)((CPU_ADDR)pmem_addr % align);          /* Calc mem align.                                  */

    if (mem_align != 0u) {
 80026c0:	f01e 0103 	ands.w	r1, lr, #3
    }


/*$PAGE*/
                                                                    /* ---------------- ALLOC MEM BLKs ---------------- */
    size_pool_ptrs = (CPU_SIZE_T)(blk_nbr * sizeof(void *));
 80026c4:	ea4f 0389 	mov.w	r3, r9, lsl #2

    pmem_addr = (CPU_INT08U *)pmem_pool->SegAddrNextAvail;

    mem_align = (CPU_SIZE_T)((CPU_ADDR)pmem_addr % align);          /* Calc mem align.                                  */

    if (mem_align != 0u) {
 80026c8:	d073      	beq.n	80027b2 <Mem_PoolCreate+0x23a>
        align_offset = align - mem_align;
 80026ca:	f1c1 0104 	rsb	r1, r1, #4
    } else {
        align_offset = 0u;
    }

    size_tot = align_offset + size;
 80026ce:	18c8      	adds	r0, r1, r3
    if (size_tot > pmem_pool->SegSizeRem) {                         /* If insufficient mem seg size rem, ...            */
 80026d0:	4560      	cmp	r0, ip
    pmem_addr = (CPU_INT08U *)pmem_pool->SegAddrNextAvail;

    mem_align = (CPU_SIZE_T)((CPU_ADDR)pmem_addr % align);          /* Calc mem align.                                  */

    if (mem_align != 0u) {
        align_offset = align - mem_align;
 80026d2:	9103      	str	r1, [sp, #12]
    } else {
        align_offset = 0u;
    }

    size_tot = align_offset + size;
    if (size_tot > pmem_pool->SegSizeRem) {                         /* If insufficient mem seg size rem, ...            */
 80026d4:	d803      	bhi.n	80026de <Mem_PoolCreate+0x166>
        return ((void *)0);                                         /* ... rtn NULL.                                    */
    }

#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    if ((size_tot < align_offset) ||                                /* If size ovf, ...                                 */
 80026d6:	9903      	ldr	r1, [sp, #12]
 80026d8:	4281      	cmp	r1, r0
 80026da:	f240 8109 	bls.w	80028f0 <Mem_PoolCreate+0x378>
 80026de:	9303      	str	r3, [sp, #12]
                                                                    /* Alloc stk of ptrs for mem blks from heap.        */
    ppool_ptr      = (void **)Mem_SegAlloc((MEM_POOL *)pmem_pool_heap,
                                           (CPU_SIZE_T)size_pool_ptrs,
                                           (CPU_SIZE_T)sizeof(void *));
    if (ppool_ptr == (void **)0) {                                  /* If mem pool ptrs alloc failed, ...               */
        size_rem = pmem_pool_heap->SegSizeRem;
 80026e0:	e89d 0009 	ldmia.w	sp, {r0, r3}
 80026e4:	9202      	str	r2, [sp, #8]
 80026e6:	6c5e      	ldr	r6, [r3, #68]	; 0x44
        CPU_CRITICAL_EXIT();
 80026e8:	f7ff f848 	bl	800177c <CPU_SR_Restore>
                                                                    /* ... rtn add'l heap size needed.                  */
        if (pmem_base_addr == (void *)0) {
 80026ec:	9a02      	ldr	r2, [sp, #8]
 80026ee:	9b03      	ldr	r3, [sp, #12]
 80026f0:	2f00      	cmp	r7, #0
 80026f2:	f000 811c 	beq.w	800292e <Mem_PoolCreate+0x3b6>
               *poctets_reqd = size_tot - size_rem;
            } else {
               *poctets_reqd = size_tot;
            }
        } else {
            if (size_pool_ptrs > size_rem) {
 80026f6:	42b3      	cmp	r3, r6
               *poctets_reqd = size_pool_ptrs - size_rem;
 80026f8:	bf88      	it	hi
 80026fa:	1b9b      	subhi	r3, r3, r6
            } else {
               *poctets_reqd = size_pool_ptrs;
 80026fc:	602b      	str	r3, [r5, #0]
            }
        }
       *perr = LIB_MEM_ERR_HEAP_EMPTY;
 80026fe:	f242 73e2 	movw	r3, #10210	; 0x27e2
 8002702:	8023      	strh	r3, [r4, #0]
        return;
 8002704:	e74e      	b.n	80025a4 <Mem_PoolCreate+0x2c>
#endif


                                                                    /* ------------ VALIDATE MEM POOL TBL ------------- */
    if (Mem_PoolTbl == (MEM_POOL *)0) {
       *perr = LIB_MEM_ERR_HEAP_NOT_FOUND;
 8002706:	f242 73e7 	movw	r3, #10215	; 0x27e7
 800270a:	8023      	strh	r3, [r4, #0]
        return;
 800270c:	e74a      	b.n	80025a4 <Mem_PoolCreate+0x2c>
        pmem_base_addr_start = (CPU_INT08U *)pmem_base_addr;
        pmem_base_addr_end   = (CPU_INT08U *)pmem_base_addr + mem_size - 1;

#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
        if (pmem_base_addr_end < pmem_base_addr_start) {            /* Chk ovf of end addr.                             */
            CPU_CRITICAL_EXIT();
 800270e:	f7ff f835 	bl	800177c <CPU_SR_Restore>
           *perr = LIB_MEM_ERR_INVALID_BLK_ADDR;
 8002712:	f242 7397 	movw	r3, #10135	; 0x2797
 8002716:	8023      	strh	r3, [r4, #0]
            return;
 8002718:	e744      	b.n	80025a4 <Mem_PoolCreate+0x2c>
                                             (CPU_SIZE_T)blk_nbr,
                                             (CPU_SIZE_T)sizeof(void *),
                                             (CPU_SIZE_T)sizeof(void *));
#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
        if (size_tot_ptrs < 1) {                                    /* If heap ovf, ...                                 */
            CPU_CRITICAL_EXIT();
 800271a:	9800      	ldr	r0, [sp, #0]
 800271c:	f7ff f82e 	bl	800177c <CPU_SR_Restore>
           *perr = LIB_MEM_ERR_HEAP_OVF;                            /* ... rtn err but add'l heap size NOT avail.       */
 8002720:	f242 73e3 	movw	r3, #10211	; 0x27e3
 8002724:	8023      	strh	r3, [r4, #0]
            return;
 8002726:	e73d      	b.n	80025a4 <Mem_PoolCreate+0x2c>
 8002728:	469b      	mov	fp, r3

        if (pmem_seg == (MEM_POOL *)0) {                            /* If mem seg NOT found, add    new  mem seg.       */
            pmem_seg                    = pmem_pool;
            pmem_pool->SegAddr          = pmem_base_addr;
            pmem_pool->SegAddrNextAvail = pmem_base_addr;
            pmem_pool->SegSizeTot       = mem_size;
 800272a:	f8c6 8040 	str.w	r8, [r6, #64]	; 0x40
            pmem_pool->SegSizeRem       = mem_size;
 800272e:	f8c6 8044 	str.w	r8, [r6, #68]	; 0x44
            pmem_seg_next = pmem_seg_next->SegNextPtr;
        }

        if (pmem_seg == (MEM_POOL *)0) {                            /* If mem seg NOT found, add    new  mem seg.       */
            pmem_seg                    = pmem_pool;
            pmem_pool->SegAddr          = pmem_base_addr;
 8002732:	63b7      	str	r7, [r6, #56]	; 0x38
            pmem_pool->SegAddrNextAvail = pmem_base_addr;
 8002734:	63f7      	str	r7, [r6, #60]	; 0x3c
            pmem_pool->SegSizeTot       = mem_size;
            pmem_pool->SegSizeRem       = mem_size;
 8002736:	46b0      	mov	r8, r6
 8002738:	e797      	b.n	800266a <Mem_PoolCreate+0xf2>
        pmem_seg_prev   =  pmem_pool_heap;
        pmem_seg_next   =  pmem_pool_heap;

                                                                    /* --------------- VALIDATE MEM SEG --------------- */
                                                                    /* Calc tot mem   size for mem pool ptrs.           */
        pmem_addr_ptrs  = (CPU_INT08U *)pmem_pool_heap->SegAddrNextAvail;
 800273a:	f8df b190 	ldr.w	fp, [pc, #400]	; 80028cc <Mem_PoolCreate+0x354>
        size_tot_ptrs   =  Mem_SegCalcTotSize((void     *)pmem_addr_ptrs,
 800273e:	2304      	movs	r3, #4
        pmem_seg_prev   =  pmem_pool_heap;
        pmem_seg_next   =  pmem_pool_heap;

                                                                    /* --------------- VALIDATE MEM SEG --------------- */
                                                                    /* Calc tot mem   size for mem pool ptrs.           */
        pmem_addr_ptrs  = (CPU_INT08U *)pmem_pool_heap->SegAddrNextAvail;
 8002740:	f8db a03c 	ldr.w	sl, [fp, #60]	; 0x3c
        size_tot_ptrs   =  Mem_SegCalcTotSize((void     *)pmem_addr_ptrs,
 8002744:	461a      	mov	r2, r3
 8002746:	4650      	mov	r0, sl
 8002748:	4649      	mov	r1, r9
 800274a:	f7ff fcc9 	bl	80020e0 <Mem_SegCalcTotSize>
                                              (CPU_SIZE_T)blk_nbr,
                                              (CPU_SIZE_T)sizeof(void *),
                                              (CPU_SIZE_T)sizeof(void *));
#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
        if (size_tot_ptrs < 1) {                                    /* If heap ovf, ...                                 */
 800274e:	4680      	mov	r8, r0
 8002750:	2800      	cmp	r0, #0
 8002752:	d0e2      	beq.n	800271a <Mem_PoolCreate+0x1a2>
           *perr = LIB_MEM_ERR_HEAP_OVF;                            /* ... rtn err but add'l heap size NOT avail.       */
            return;
        }
#endif
                                                                    /* Calc tot mem   size for mem blks.                */
        pmem_addr_pool  =  pmem_addr_ptrs + size_tot_ptrs;          /* Adj next avail addr for mem pool blks.           */
 8002754:	eb0a 0300 	add.w	r3, sl, r0
 8002758:	9305      	str	r3, [sp, #20]
        size_tot_pool   =  Mem_SegCalcTotSize((void     *)pmem_addr_pool,
 800275a:	4618      	mov	r0, r3
 800275c:	9a12      	ldr	r2, [sp, #72]	; 0x48
 800275e:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8002760:	4649      	mov	r1, r9
 8002762:	f7ff fcbd 	bl	80020e0 <Mem_SegCalcTotSize>
                                              (CPU_SIZE_T)blk_nbr,
                                              (CPU_SIZE_T)blk_size,
                                              (CPU_SIZE_T)blk_align);
#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
        if (size_tot_pool < 1) {                                    /* If heap ovf, ...                                 */
 8002766:	9002      	str	r0, [sp, #8]
 8002768:	2800      	cmp	r0, #0
 800276a:	d0d6      	beq.n	800271a <Mem_PoolCreate+0x1a2>
#endif

        size_tot = size_tot_ptrs + size_tot_pool;

#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
        if ((size_tot < size_tot_ptrs) ||                           /* If heap ovf, ...                                 */
 800276c:	9902      	ldr	r1, [sp, #8]
 800276e:	eb18 0201 	adds.w	r2, r8, r1
 8002772:	d2d2      	bcs.n	800271a <Mem_PoolCreate+0x1a2>
 8002774:	4291      	cmp	r1, r2
 8002776:	d8d0      	bhi.n	800271a <Mem_PoolCreate+0x1a2>
           *perr = LIB_MEM_ERR_HEAP_OVF;                            /* ... rtn err but add'l heap size NOT avail.       */
            return;
        }
#endif

        size_rem = pmem_pool_heap->SegSizeRem;
 8002778:	f8db 8044 	ldr.w	r8, [fp, #68]	; 0x44
        if (size_tot > size_rem) {                                  /* If tot size > rem  size, ...                     */
 800277c:	4542      	cmp	r2, r8
 800277e:	f200 80ca 	bhi.w	8002916 <Mem_PoolCreate+0x39e>
    CPU_CRITICAL_ENTER();

    if (pmem_base_addr == (void *)0) {                              /* If no base addr, cfg mem pool from heap.         */
        pmem_seg        =  pmem_pool_heap;
        pmem_seg_prev   =  pmem_pool_heap;
        pmem_seg_next   =  pmem_pool_heap;
 8002782:	f8df b148 	ldr.w	fp, [pc, #328]	; 80028cc <Mem_PoolCreate+0x354>
 8002786:	46c4      	mov	ip, r8
 8002788:	46d6      	mov	lr, sl
    size_tot       = (CPU_SIZE_T) 0u;

    CPU_CRITICAL_ENTER();

    if (pmem_base_addr == (void *)0) {                              /* If no base addr, cfg mem pool from heap.         */
        pmem_seg        =  pmem_pool_heap;
 800278a:	f8cd b004 	str.w	fp, [sp, #4]
        pmem_seg_prev   =  pmem_pool_heap;
 800278e:	46da      	mov	sl, fp
    size_tot       = (CPU_SIZE_T) 0u;

    CPU_CRITICAL_ENTER();

    if (pmem_base_addr == (void *)0) {                              /* If no base addr, cfg mem pool from heap.         */
        pmem_seg        =  pmem_pool_heap;
 8002790:	46d8      	mov	r8, fp
 8002792:	e795      	b.n	80026c0 <Mem_PoolCreate+0x148>
 8002794:	46d3      	mov	fp, sl
 8002796:	4692      	mov	sl, r2
 8002798:	e7c7      	b.n	800272a <Mem_PoolCreate+0x1b2>
 800279a:	9001      	str	r0, [sp, #4]
        }
#endif

        size_rem = pmem_pool_heap->SegSizeRem;
        if (size_tot_ptrs > size_rem) {                             /* If ptr size > rem  size, ...                     */
            CPU_CRITICAL_EXIT();
 800279c:	9800      	ldr	r0, [sp, #0]
 800279e:	f7fe ffed 	bl	800177c <CPU_SR_Restore>
           *poctets_reqd = size_tot_ptrs - size_rem;                /* ... rtn add'l heap size needed.                  */
           *perr         = LIB_MEM_ERR_HEAP_EMPTY;
 80027a2:	f242 72e2 	movw	r2, #10210	; 0x27e2
#endif

        size_rem = pmem_pool_heap->SegSizeRem;
        if (size_tot_ptrs > size_rem) {                             /* If ptr size > rem  size, ...                     */
            CPU_CRITICAL_EXIT();
           *poctets_reqd = size_tot_ptrs - size_rem;                /* ... rtn add'l heap size needed.                  */
 80027a6:	9904      	ldr	r1, [sp, #16]
 80027a8:	9b01      	ldr	r3, [sp, #4]
 80027aa:	1a5b      	subs	r3, r3, r1
 80027ac:	602b      	str	r3, [r5, #0]
           *perr         = LIB_MEM_ERR_HEAP_EMPTY;
 80027ae:	8022      	strh	r2, [r4, #0]
            return;
 80027b0:	e6f8      	b.n	80025a4 <Mem_PoolCreate+0x2c>
    } else {
        align_offset = 0u;
    }

    size_tot = align_offset + size;
    if (size_tot > pmem_pool->SegSizeRem) {                         /* If insufficient mem seg size rem, ...            */
 80027b2:	4563      	cmp	r3, ip
 80027b4:	d893      	bhi.n	80026de <Mem_PoolCreate+0x166>
 80027b6:	4618      	mov	r0, r3
    mem_align = (CPU_SIZE_T)((CPU_ADDR)pmem_addr % align);          /* Calc mem align.                                  */

    if (mem_align != 0u) {
        align_offset = align - mem_align;
    } else {
        align_offset = 0u;
 80027b8:	9103      	str	r1, [sp, #12]
#endif

    pmem_addr_next = pmem_addr + size_tot;

#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    if (pmem_addr_next < pmem_addr) {                               /* If addr ovf, ...                                 */
 80027ba:	eb1e 0100 	adds.w	r1, lr, r0
 80027be:	9104      	str	r1, [sp, #16]
 80027c0:	d28d      	bcs.n	80026de <Mem_PoolCreate+0x166>
#endif

    pmem_addr += align_offset;                                      /* Align mem addr.                                  */

    pmem_pool->SegAddrNextAvail  = (void     *)pmem_addr_next;      /* Adv next avail addr.                             */
    pmem_pool->SegSizeRem       -= (CPU_SIZE_T)size_tot;            /* Adj rem mem seg size.                            */
 80027c2:	9901      	ldr	r1, [sp, #4]
 80027c4:	ebc0 000c 	rsb	r0, r0, ip
 80027c8:	6448      	str	r0, [r1, #68]	; 0x44
    }
#endif

    pmem_addr += align_offset;                                      /* Align mem addr.                                  */

    pmem_pool->SegAddrNextAvail  = (void     *)pmem_addr_next;      /* Adv next avail addr.                             */
 80027ca:	9804      	ldr	r0, [sp, #16]
 80027cc:	63c8      	str	r0, [r1, #60]	; 0x3c
    size_pool_ptrs = (CPU_SIZE_T)(blk_nbr * sizeof(void *));
                                                                    /* Alloc stk of ptrs for mem blks from heap.        */
    ppool_ptr      = (void **)Mem_SegAlloc((MEM_POOL *)pmem_pool_heap,
                                           (CPU_SIZE_T)size_pool_ptrs,
                                           (CPU_SIZE_T)sizeof(void *));
    if (ppool_ptr == (void **)0) {                                  /* If mem pool ptrs alloc failed, ...               */
 80027ce:	9903      	ldr	r1, [sp, #12]
 80027d0:	eb1e 0101 	adds.w	r1, lr, r1
 80027d4:	9103      	str	r1, [sp, #12]
 80027d6:	d082      	beq.n	80026de <Mem_PoolCreate+0x166>
 80027d8:	9b03      	ldr	r3, [sp, #12]
 80027da:	f8d8 7044 	ldr.w	r7, [r8, #68]	; 0x44
 80027de:	f1a3 0c04 	sub.w	ip, r3, #4
 80027e2:	2100      	movs	r1, #0
 80027e4:	9601      	str	r6, [sp, #4]
 80027e6:	e016      	b.n	8002816 <Mem_PoolCreate+0x29e>
    } else {
        align_offset = 0u;
    }

    size_tot = align_offset + size;
    if (size_tot > pmem_pool->SegSizeRem) {                         /* If insufficient mem seg size rem, ...            */
 80027e8:	4577      	cmp	r7, lr
 80027ea:	d328      	bcc.n	800283e <Mem_PoolCreate+0x2c6>
        return ((void *)0);                                         /* ... rtn NULL.                                    */
    }

#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    if ((size_tot < align_offset) ||                                /* If size ovf, ...                                 */
 80027ec:	4572      	cmp	r2, lr
 80027ee:	d826      	bhi.n	800283e <Mem_PoolCreate+0x2c6>
 80027f0:	4576      	cmp	r6, lr
 80027f2:	d824      	bhi.n	800283e <Mem_PoolCreate+0x2c6>
#endif

    pmem_addr_next = pmem_addr + size_tot;

#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    if (pmem_addr_next < pmem_addr) {                               /* If addr ovf, ...                                 */
 80027f4:	eb13 000e 	adds.w	r0, r3, lr
 80027f8:	d221      	bcs.n	800283e <Mem_PoolCreate+0x2c6>
#endif

    pmem_addr += align_offset;                                      /* Align mem addr.                                  */

    pmem_pool->SegAddrNextAvail  = (void     *)pmem_addr_next;      /* Adv next avail addr.                             */
    pmem_pool->SegSizeRem       -= (CPU_SIZE_T)size_tot;            /* Adj rem mem seg size.                            */
 80027fa:	ebce 0707 	rsb	r7, lr, r7
        return;
    }

    for (i = 0u; i < (CPU_SIZE_T)blk_nbr; i++) {                    /* Alloc mem blks from mem seg.                     */
        pmem_blk = (void *)Mem_SegAlloc(pmem_seg, blk_size, blk_align);
        if (pmem_blk == (void *)0) {                                /* If    mem blks alloc failed, ...                 */
 80027fe:	189b      	adds	r3, r3, r2
#endif

    pmem_addr += align_offset;                                      /* Align mem addr.                                  */

    pmem_pool->SegAddrNextAvail  = (void     *)pmem_addr_next;      /* Adv next avail addr.                             */
    pmem_pool->SegSizeRem       -= (CPU_SIZE_T)size_tot;            /* Adj rem mem seg size.                            */
 8002800:	f8c8 7044 	str.w	r7, [r8, #68]	; 0x44
    }
#endif

    pmem_addr += align_offset;                                      /* Align mem addr.                                  */

    pmem_pool->SegAddrNextAvail  = (void     *)pmem_addr_next;      /* Adv next avail addr.                             */
 8002804:	f8c8 003c 	str.w	r0, [r8, #60]	; 0x3c
        return;
    }

    for (i = 0u; i < (CPU_SIZE_T)blk_nbr; i++) {                    /* Alloc mem blks from mem seg.                     */
        pmem_blk = (void *)Mem_SegAlloc(pmem_seg, blk_size, blk_align);
        if (pmem_blk == (void *)0) {                                /* If    mem blks alloc failed, ...                 */
 8002808:	f000 809a 	beq.w	8002940 <Mem_PoolCreate+0x3c8>
        }
       *perr = LIB_MEM_ERR_HEAP_EMPTY;
        return;
    }

    for (i = 0u; i < (CPU_SIZE_T)blk_nbr; i++) {                    /* Alloc mem blks from mem seg.                     */
 800280c:	3101      	adds	r1, #1
 800280e:	4589      	cmp	r9, r1
               *poctets_reqd = size_tot;
            }
           *perr = LIB_MEM_ERR_SEG_EMPTY;
            return;
        }
        ppool_ptr[i] = pmem_blk;
 8002810:	f84c 3f04 	str.w	r3, [ip, #4]!
        }
       *perr = LIB_MEM_ERR_HEAP_EMPTY;
        return;
    }

    for (i = 0u; i < (CPU_SIZE_T)blk_nbr; i++) {                    /* Alloc mem blks from mem seg.                     */
 8002814:	d028      	beq.n	8002868 <Mem_PoolCreate+0x2f0>
    CPU_SIZE_T   size_tot;


    pmem_addr = (CPU_INT08U *)pmem_pool->SegAddrNextAvail;

    mem_align = (CPU_SIZE_T)((CPU_ADDR)pmem_addr % align);          /* Calc mem align.                                  */
 8002816:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    CPU_SIZE_T   mem_align;
    CPU_SIZE_T   align_offset;
    CPU_SIZE_T   size_tot;


    pmem_addr = (CPU_INT08U *)pmem_pool->SegAddrNextAvail;
 8002818:	f8d8 303c 	ldr.w	r3, [r8, #60]	; 0x3c
        align_offset = align - mem_align;
    } else {
        align_offset = 0u;
    }

    size_tot = align_offset + size;
 800281c:	9e12      	ldr	r6, [sp, #72]	; 0x48
    CPU_SIZE_T   size_tot;


    pmem_addr = (CPU_INT08U *)pmem_pool->SegAddrNextAvail;

    mem_align = (CPU_SIZE_T)((CPU_ADDR)pmem_addr % align);          /* Calc mem align.                                  */
 800281e:	fbb3 f0f2 	udiv	r0, r3, r2
 8002822:	fb02 3010 	mls	r0, r2, r0, r3

    if (mem_align != 0u) {
        align_offset = align - mem_align;
 8002826:	1a12      	subs	r2, r2, r0
    } else {
        align_offset = 0u;
    }

    size_tot = align_offset + size;
 8002828:	eb06 0e02 	add.w	lr, r6, r2

    pmem_addr = (CPU_INT08U *)pmem_pool->SegAddrNextAvail;

    mem_align = (CPU_SIZE_T)((CPU_ADDR)pmem_addr % align);          /* Calc mem align.                                  */

    if (mem_align != 0u) {
 800282c:	2800      	cmp	r0, #0
 800282e:	d1db      	bne.n	80027e8 <Mem_PoolCreate+0x270>
    } else {
        align_offset = 0u;
    }

    size_tot = align_offset + size;
    if (size_tot > pmem_pool->SegSizeRem) {                         /* If insufficient mem seg size rem, ...            */
 8002830:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8002832:	42ba      	cmp	r2, r7
 8002834:	d803      	bhi.n	800283e <Mem_PoolCreate+0x2c6>
    mem_align = (CPU_SIZE_T)((CPU_ADDR)pmem_addr % align);          /* Calc mem align.                                  */

    if (mem_align != 0u) {
        align_offset = align - mem_align;
    } else {
        align_offset = 0u;
 8002836:	4602      	mov	r2, r0
    }

    size_tot = align_offset + size;
    if (size_tot > pmem_pool->SegSizeRem) {                         /* If insufficient mem seg size rem, ...            */
 8002838:	f8dd e048 	ldr.w	lr, [sp, #72]	; 0x48
 800283c:	e7da      	b.n	80027f4 <Mem_PoolCreate+0x27c>
    CPU_SIZE_T   mem_align;
    CPU_SIZE_T   align_offset;
    CPU_SIZE_T   size_tot;


    pmem_addr = (CPU_INT08U *)pmem_pool->SegAddrNextAvail;
 800283e:	461e      	mov	r6, r3
    for (i = 0u; i < (CPU_SIZE_T)blk_nbr; i++) {                    /* Alloc mem blks from mem seg.                     */
        pmem_blk = (void *)Mem_SegAlloc(pmem_seg, blk_size, blk_align);
        if (pmem_blk == (void *)0) {                                /* If    mem blks alloc failed, ...                 */
            pmem_addr_pool = (CPU_INT08U *)pmem_seg->SegAddrNextAvail;
            size_rem       = (CPU_SIZE_T  )pmem_seg->SegSizeRem;
            CPU_CRITICAL_EXIT();
 8002840:	9800      	ldr	r0, [sp, #0]
 8002842:	9101      	str	r1, [sp, #4]
 8002844:	f7fe ff9a 	bl	800177c <CPU_SR_Restore>
            blk_rem        =  blk_nbr - (MEM_POOL_BLK_QTY)i;
            size_tot       =  Mem_SegCalcTotSize((void           *)pmem_addr_pool,
 8002848:	9901      	ldr	r1, [sp, #4]
 800284a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 800284c:	9a12      	ldr	r2, [sp, #72]	; 0x48
 800284e:	ebc1 0109 	rsb	r1, r1, r9
 8002852:	4630      	mov	r0, r6
 8002854:	f7ff fc44 	bl	80020e0 <Mem_SegCalcTotSize>
            if (size_tot > size_rem) {
               *poctets_reqd = size_tot - size_rem;
            } else {
               *poctets_reqd = size_tot;
            }
           *perr = LIB_MEM_ERR_SEG_EMPTY;
 8002858:	f242 73d8 	movw	r3, #10200	; 0x27d8
            size_tot       =  Mem_SegCalcTotSize((void           *)pmem_addr_pool,
                                                 (MEM_POOL_BLK_QTY)blk_rem,
                                                 (CPU_SIZE_T      )blk_size,
                                                 (CPU_SIZE_T      )blk_align);
                                                                    /* ... rtn add'l seg  size needed.                  */
            if (size_tot > size_rem) {
 800285c:	42b8      	cmp	r0, r7
               *poctets_reqd = size_tot - size_rem;
 800285e:	bf88      	it	hi
 8002860:	1bc0      	subhi	r0, r0, r7
            } else {
               *poctets_reqd = size_tot;
 8002862:	6028      	str	r0, [r5, #0]
            }
           *perr = LIB_MEM_ERR_SEG_EMPTY;
 8002864:	8023      	strh	r3, [r4, #0]
            return;
 8002866:	e69d      	b.n	80025a4 <Mem_PoolCreate+0x2c>
 8002868:	9e01      	ldr	r6, [sp, #4]
    }


/*$PAGE*/
                                                                    /* ------------- UPDATE MEM POOL TBL -------------- */
    if (pmem_seg == pmem_pool) {                                    /* Add mem pool as new  mem pool tbl seg.           */
 800286a:	45b0      	cmp	r8, r6
 800286c:	d044      	beq.n	80028f8 <Mem_PoolCreate+0x380>
            pmem_seg_next->SegPrevPtr = pmem_pool;
        }

    } else {                                                        /* Add mem pool into mem seg.                       */
                                                                    /* Update cur  mem pool links.                      */
        pmem_pool_next         = pmem_seg->PoolNextPtr;
 800286e:	f8d8 3014 	ldr.w	r3, [r8, #20]
        pmem_pool->PoolPrevPtr = pmem_seg;
 8002872:	f8c6 8010 	str.w	r8, [r6, #16]
        pmem_pool->PoolNextPtr = pmem_pool_next;
 8002876:	6173      	str	r3, [r6, #20]

        pmem_seg->PoolNextPtr  = pmem_pool;                         /* Update prev mem pool link.                       */
 8002878:	f8c8 6014 	str.w	r6, [r8, #20]

        if (pmem_pool_next != (MEM_POOL *)0) {                      /* Update next mem pool link.                       */
 800287c:	b103      	cbz	r3, 8002880 <Mem_PoolCreate+0x308>
            pmem_pool_next->PoolPrevPtr = pmem_pool;
 800287e:	611e      	str	r6, [r3, #16]

                                                                    /* ----------------- CFG MEM POOL ----------------- */
    pmem_pool->Type          = (LIB_MEM_TYPE    ) LIB_MEM_TYPE_POOL;
    pmem_pool->SegHeadPtr    = (MEM_POOL       *) pmem_seg;
    pmem_pool->PoolAddrStart = (void           *) pmem_addr_pool;
    pmem_pool->PoolAddrEnd   = (void           *)(pmem_addr_pool + size_tot_pool - 1);
 8002880:	9902      	ldr	r1, [sp, #8]
 8002882:	9805      	ldr	r0, [sp, #20]
 8002884:	1e4b      	subs	r3, r1, #1
 8002886:	4403      	add	r3, r0
 8002888:	61f3      	str	r3, [r6, #28]
    pmem_pool->PoolPtrs      = (void          **) ppool_ptr;
    pmem_pool->PoolSize      = (CPU_SIZE_T      ) size_tot_pool;
    pmem_pool->BlkAlign      = (CPU_SIZE_T      ) blk_align;
 800288a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    }



                                                                    /* ----------------- CFG MEM POOL ----------------- */
    pmem_pool->Type          = (LIB_MEM_TYPE    ) LIB_MEM_TYPE_POOL;
 800288c:	4a10      	ldr	r2, [pc, #64]	; (80028d0 <Mem_PoolCreate+0x358>)
    pmem_pool->SegHeadPtr    = (MEM_POOL       *) pmem_seg;
    pmem_pool->PoolAddrStart = (void           *) pmem_addr_pool;
 800288e:	61b0      	str	r0, [r6, #24]
    pmem_pool->PoolAddrEnd   = (void           *)(pmem_addr_pool + size_tot_pool - 1);
    pmem_pool->PoolPtrs      = (void          **) ppool_ptr;
    pmem_pool->PoolSize      = (CPU_SIZE_T      ) size_tot_pool;
    pmem_pool->BlkAlign      = (CPU_SIZE_T      ) blk_align;
 8002890:	6373      	str	r3, [r6, #52]	; 0x34
                                                                    /* ----------------- CFG MEM POOL ----------------- */
    pmem_pool->Type          = (LIB_MEM_TYPE    ) LIB_MEM_TYPE_POOL;
    pmem_pool->SegHeadPtr    = (MEM_POOL       *) pmem_seg;
    pmem_pool->PoolAddrStart = (void           *) pmem_addr_pool;
    pmem_pool->PoolAddrEnd   = (void           *)(pmem_addr_pool + size_tot_pool - 1);
    pmem_pool->PoolPtrs      = (void          **) ppool_ptr;
 8002892:	9803      	ldr	r0, [sp, #12]
    pmem_pool->PoolSize      = (CPU_SIZE_T      ) size_tot_pool;
    pmem_pool->BlkAlign      = (CPU_SIZE_T      ) blk_align;
    pmem_pool->BlkSize       = (CPU_SIZE_T      ) blk_size;
 8002894:	9b12      	ldr	r3, [sp, #72]	; 0x48
                                                                    /* ----------------- CFG MEM POOL ----------------- */
    pmem_pool->Type          = (LIB_MEM_TYPE    ) LIB_MEM_TYPE_POOL;
    pmem_pool->SegHeadPtr    = (MEM_POOL       *) pmem_seg;
    pmem_pool->PoolAddrStart = (void           *) pmem_addr_pool;
    pmem_pool->PoolAddrEnd   = (void           *)(pmem_addr_pool + size_tot_pool - 1);
    pmem_pool->PoolPtrs      = (void          **) ppool_ptr;
 8002896:	6230      	str	r0, [r6, #32]
    pmem_pool->PoolSize      = (CPU_SIZE_T      ) size_tot_pool;
    pmem_pool->BlkAlign      = (CPU_SIZE_T      ) blk_align;
    pmem_pool->BlkSize       = (CPU_SIZE_T      ) blk_size;
 8002898:	6333      	str	r3, [r6, #48]	; 0x30



                                                                    /* ----------------- CFG MEM POOL ----------------- */
    pmem_pool->Type          = (LIB_MEM_TYPE    ) LIB_MEM_TYPE_POOL;
    pmem_pool->SegHeadPtr    = (MEM_POOL       *) pmem_seg;
 800289a:	f8c6 8004 	str.w	r8, [r6, #4]
    pmem_pool->PoolAddrStart = (void           *) pmem_addr_pool;
    pmem_pool->PoolAddrEnd   = (void           *)(pmem_addr_pool + size_tot_pool - 1);
    pmem_pool->PoolPtrs      = (void          **) ppool_ptr;
    pmem_pool->PoolSize      = (CPU_SIZE_T      ) size_tot_pool;
 800289e:	62b1      	str	r1, [r6, #40]	; 0x28
    pmem_pool->BlkAlign      = (CPU_SIZE_T      ) blk_align;
    pmem_pool->BlkSize       = (CPU_SIZE_T      ) blk_size;
    pmem_pool->BlkNbr        = (MEM_POOL_BLK_QTY) blk_nbr;
 80028a0:	f8c6 902c 	str.w	r9, [r6, #44]	; 0x2c
    pmem_pool->BlkIx         = (MEM_POOL_IX     ) blk_nbr;
 80028a4:	f8c6 9024 	str.w	r9, [r6, #36]	; 0x24


    CPU_CRITICAL_EXIT();
 80028a8:	9800      	ldr	r0, [sp, #0]
    }



                                                                    /* ----------------- CFG MEM POOL ----------------- */
    pmem_pool->Type          = (LIB_MEM_TYPE    ) LIB_MEM_TYPE_POOL;
 80028aa:	6032      	str	r2, [r6, #0]
    pmem_pool->BlkSize       = (CPU_SIZE_T      ) blk_size;
    pmem_pool->BlkNbr        = (MEM_POOL_BLK_QTY) blk_nbr;
    pmem_pool->BlkIx         = (MEM_POOL_IX     ) blk_nbr;


    CPU_CRITICAL_EXIT();
 80028ac:	f7fe ff66 	bl	800177c <CPU_SR_Restore>

   *perr = LIB_MEM_ERR_NONE;
 80028b0:	f242 7310 	movw	r3, #10000	; 0x2710
 80028b4:	8023      	strh	r3, [r4, #0]
 80028b6:	e675      	b.n	80025a4 <Mem_PoolCreate+0x2c>
                                             (CPU_SIZE_T)blk_nbr,
                                             (CPU_SIZE_T)blk_size,
                                             (CPU_SIZE_T)blk_align);
#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
        if (size_tot_pool < 1) {                                    /* If seg  ovf, ...                                 */
            CPU_CRITICAL_EXIT();
 80028b8:	9800      	ldr	r0, [sp, #0]
 80028ba:	f7fe ff5f 	bl	800177c <CPU_SR_Restore>
           *perr = LIB_MEM_ERR_SEG_OVF;                             /* ... rtn err but add'l seg  size NOT avail.       */
 80028be:	f242 73d9 	movw	r3, #10201	; 0x27d9
 80028c2:	8023      	strh	r3, [r4, #0]
            return;
 80028c4:	e66e      	b.n	80025a4 <Mem_PoolCreate+0x2c>
 80028c6:	bf00      	nop
 80028c8:	2000d90c 	.word	0x2000d90c
 80028cc:	2000b4c4 	.word	0x2000b4c4
 80028d0:	4c4f4f50 	.word	0x4c4f4f50
        }
#endif

        size_rem = pmem_seg->SegSizeRem;
        if (size_tot_pool > size_rem) {                             /* If tot size > rem  size, ...                     */
            CPU_CRITICAL_EXIT();
 80028d4:	9800      	ldr	r0, [sp, #0]
 80028d6:	9301      	str	r3, [sp, #4]
 80028d8:	f7fe ff50 	bl	800177c <CPU_SR_Restore>
           *poctets_reqd = size_tot_pool - size_rem;                /* ... rtn add'l seg  size needed.                  */
           *perr         = LIB_MEM_ERR_SEG_EMPTY;
 80028dc:	f242 72d8 	movw	r2, #10200	; 0x27d8
#endif

        size_rem = pmem_seg->SegSizeRem;
        if (size_tot_pool > size_rem) {                             /* If tot size > rem  size, ...                     */
            CPU_CRITICAL_EXIT();
           *poctets_reqd = size_tot_pool - size_rem;                /* ... rtn add'l seg  size needed.                  */
 80028e0:	9902      	ldr	r1, [sp, #8]
 80028e2:	9b01      	ldr	r3, [sp, #4]
 80028e4:	1acb      	subs	r3, r1, r3
 80028e6:	602b      	str	r3, [r5, #0]
           *perr         = LIB_MEM_ERR_SEG_EMPTY;
 80028e8:	8022      	strh	r2, [r4, #0]
            return;
 80028ea:	e65b      	b.n	80025a4 <Mem_PoolCreate+0x2c>

        pmem_seg      = (MEM_POOL *)0;
        pmem_seg_prev = (MEM_POOL *)0;
        pmem_seg_next =  Mem_PoolTbl;

        while (pmem_seg_next != (MEM_POOL *)0) {                    /* Srch tbl for mem seg with same base addr/size.   */
 80028ec:	46d3      	mov	fp, sl
 80028ee:	e71c      	b.n	800272a <Mem_PoolCreate+0x1b2>
    if (size_tot > pmem_pool->SegSizeRem) {                         /* If insufficient mem seg size rem, ...            */
        return ((void *)0);                                         /* ... rtn NULL.                                    */
    }

#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    if ((size_tot < align_offset) ||                                /* If size ovf, ...                                 */
 80028f0:	4283      	cmp	r3, r0
 80028f2:	f63f aef4 	bhi.w	80026de <Mem_PoolCreate+0x166>
 80028f6:	e760      	b.n	80027ba <Mem_PoolCreate+0x242>

/*$PAGE*/
                                                                    /* ------------- UPDATE MEM POOL TBL -------------- */
    if (pmem_seg == pmem_pool) {                                    /* Add mem pool as new  mem pool tbl seg.           */
                                                                    /* Update cur  mem seg  links.                      */
        pmem_pool->SegPrevPtr = pmem_seg_prev;
 80028f8:	f8c8 a008 	str.w	sl, [r8, #8]
        pmem_pool->SegNextPtr = pmem_seg_next;
 80028fc:	f8c8 b00c 	str.w	fp, [r8, #12]

        if (pmem_seg_prev != (MEM_POOL *)0) {                       /* Update prev mem seg  link.                       */
 8002900:	f1ba 0f00 	cmp.w	sl, #0
 8002904:	d018      	beq.n	8002938 <Mem_PoolCreate+0x3c0>
            pmem_seg_prev->SegNextPtr = pmem_pool;
 8002906:	f8ca 800c 	str.w	r8, [sl, #12]
        } else {
            Mem_PoolTbl               = pmem_pool;                  /* Update      mem tbl.                             */
        }

        if (pmem_seg_next != (MEM_POOL *)0) {                       /* Update next mem seg  link.                       */
 800290a:	f1bb 0f00 	cmp.w	fp, #0
 800290e:	d0b7      	beq.n	8002880 <Mem_PoolCreate+0x308>
            pmem_seg_next->SegPrevPtr = pmem_pool;
 8002910:	f8cb 8008 	str.w	r8, [fp, #8]
 8002914:	e7b4      	b.n	8002880 <Mem_PoolCreate+0x308>
        }
#endif

        size_rem = pmem_pool_heap->SegSizeRem;
        if (size_tot > size_rem) {                                  /* If tot size > rem  size, ...                     */
            CPU_CRITICAL_EXIT();
 8002916:	9800      	ldr	r0, [sp, #0]
 8002918:	9201      	str	r2, [sp, #4]
 800291a:	f7fe ff2f 	bl	800177c <CPU_SR_Restore>
           *poctets_reqd = size_tot - size_rem;                     /* ... rtn add'l heap size needed.                  */
           *perr         = LIB_MEM_ERR_HEAP_EMPTY;
 800291e:	f242 73e2 	movw	r3, #10210	; 0x27e2
#endif

        size_rem = pmem_pool_heap->SegSizeRem;
        if (size_tot > size_rem) {                                  /* If tot size > rem  size, ...                     */
            CPU_CRITICAL_EXIT();
           *poctets_reqd = size_tot - size_rem;                     /* ... rtn add'l heap size needed.                  */
 8002922:	9a01      	ldr	r2, [sp, #4]
 8002924:	ebc8 0202 	rsb	r2, r8, r2
 8002928:	602a      	str	r2, [r5, #0]
           *perr         = LIB_MEM_ERR_HEAP_EMPTY;
 800292a:	8023      	strh	r3, [r4, #0]
            return;
 800292c:	e63a      	b.n	80025a4 <Mem_PoolCreate+0x2c>
    if (ppool_ptr == (void **)0) {                                  /* If mem pool ptrs alloc failed, ...               */
        size_rem = pmem_pool_heap->SegSizeRem;
        CPU_CRITICAL_EXIT();
                                                                    /* ... rtn add'l heap size needed.                  */
        if (pmem_base_addr == (void *)0) {
            if (size_tot > size_rem) {
 800292e:	42b2      	cmp	r2, r6
               *poctets_reqd = size_tot - size_rem;
 8002930:	bf88      	it	hi
 8002932:	1b92      	subhi	r2, r2, r6
            } else {
               *poctets_reqd = size_tot;
 8002934:	602a      	str	r2, [r5, #0]
 8002936:	e6e2      	b.n	80026fe <Mem_PoolCreate+0x186>
        pmem_pool->SegNextPtr = pmem_seg_next;

        if (pmem_seg_prev != (MEM_POOL *)0) {                       /* Update prev mem seg  link.                       */
            pmem_seg_prev->SegNextPtr = pmem_pool;
        } else {
            Mem_PoolTbl               = pmem_pool;                  /* Update      mem tbl.                             */
 8002938:	4b02      	ldr	r3, [pc, #8]	; (8002944 <Mem_PoolCreate+0x3cc>)
 800293a:	f8c3 8000 	str.w	r8, [r3]
 800293e:	e7e4      	b.n	800290a <Mem_PoolCreate+0x392>
        (size_tot < size)) {
        return ((void *)0);                                         /* ... rtn NULL.                                    */
    }
#endif

    pmem_addr_next = pmem_addr + size_tot;
 8002940:	4606      	mov	r6, r0
 8002942:	e77d      	b.n	8002840 <Mem_PoolCreate+0x2c8>
 8002944:	2000d90c 	.word	0x2000d90c

08002948 <Mem_PoolBlkGetNbrAvail>:
*/
/*$PAGE*/
#if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
MEM_POOL_BLK_QTY  Mem_PoolBlkGetNbrAvail (MEM_POOL  *pmem_pool,
                                          LIB_ERR   *perr)
{
 8002948:	b538      	push	{r3, r4, r5, lr}
 800294a:	4604      	mov	r4, r0
    CPU_SR_ALLOC();


#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
                                                                /* --------------- VALIDATE RTN ERR PTR --------------- */
    if (perr == (LIB_ERR *)0) {
 800294c:	460d      	mov	r5, r1
 800294e:	b1d1      	cbz	r1, 8002986 <Mem_PoolBlkGetNbrAvail+0x3e>
        CPU_SW_EXCEPTION(0u);
    }
                                                                /* ---------------- VALIDATE MEM POOL ----------------- */
    if (pmem_pool == (MEM_POOL *)0) {                           /* Validate mem ptr.                                    */
 8002950:	b1a4      	cbz	r4, 800297c <Mem_PoolBlkGetNbrAvail+0x34>
       *perr =  LIB_MEM_ERR_NULL_PTR;
        return (0u);
    }
#endif

    CPU_CRITICAL_ENTER();
 8002952:	f7fe ff0f 	bl	8001774 <CPU_SR_Save>

#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    switch (pmem_pool->Type) {                                  /* Validate mem pool type.                              */
 8002956:	6822      	ldr	r2, [r4, #0]
 8002958:	4b0c      	ldr	r3, [pc, #48]	; (800298c <Mem_PoolBlkGetNbrAvail+0x44>)
 800295a:	429a      	cmp	r2, r3
 800295c:	d107      	bne.n	800296e <Mem_PoolBlkGetNbrAvail+0x26>
             return (0u);                                       /* Prevent 'break NOT reachable' compiler warning.      */
    }
#endif

                                                                /* --------- GET REM'ING MEM POOL NBR BLK(S) ---------- */
    nbr_blk_rem = pmem_pool->BlkIx;
 800295e:	6a64      	ldr	r4, [r4, #36]	; 0x24

    CPU_CRITICAL_EXIT();
 8002960:	f7fe ff0c 	bl	800177c <CPU_SR_Restore>


   *perr =  LIB_MEM_ERR_NONE;
 8002964:	f242 7310 	movw	r3, #10000	; 0x2710

    return (nbr_blk_rem);
 8002968:	4620      	mov	r0, r4
    nbr_blk_rem = pmem_pool->BlkIx;

    CPU_CRITICAL_EXIT();


   *perr =  LIB_MEM_ERR_NONE;
 800296a:	802b      	strh	r3, [r5, #0]

    return (nbr_blk_rem);
}
 800296c:	bd38      	pop	{r3, r4, r5, pc}


        case LIB_MEM_TYPE_NONE:
        case LIB_MEM_TYPE_HEAP:
        default:
             CPU_CRITICAL_EXIT();
 800296e:	f7fe ff05 	bl	800177c <CPU_SR_Restore>
            *perr =  LIB_MEM_ERR_INVALID_POOL;
 8002972:	f242 7388 	movw	r3, #10120	; 0x2788
             return (0u);                                       /* Prevent 'break NOT reachable' compiler warning.      */
 8002976:	2000      	movs	r0, #0

        case LIB_MEM_TYPE_NONE:
        case LIB_MEM_TYPE_HEAP:
        default:
             CPU_CRITICAL_EXIT();
            *perr =  LIB_MEM_ERR_INVALID_POOL;
 8002978:	802b      	strh	r3, [r5, #0]
             return (0u);                                       /* Prevent 'break NOT reachable' compiler warning.      */
 800297a:	bd38      	pop	{r3, r4, r5, pc}
    if (perr == (LIB_ERR *)0) {
        CPU_SW_EXCEPTION(0u);
    }
                                                                /* ---------------- VALIDATE MEM POOL ----------------- */
    if (pmem_pool == (MEM_POOL *)0) {                           /* Validate mem ptr.                                    */
       *perr =  LIB_MEM_ERR_NULL_PTR;
 800297c:	f242 7311 	movw	r3, #10001	; 0x2711
        return (0u);
 8002980:	4620      	mov	r0, r4
    if (perr == (LIB_ERR *)0) {
        CPU_SW_EXCEPTION(0u);
    }
                                                                /* ---------------- VALIDATE MEM POOL ----------------- */
    if (pmem_pool == (MEM_POOL *)0) {                           /* Validate mem ptr.                                    */
       *perr =  LIB_MEM_ERR_NULL_PTR;
 8002982:	802b      	strh	r3, [r5, #0]
        return (0u);
 8002984:	bd38      	pop	{r3, r4, r5, pc}


#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
                                                                /* --------------- VALIDATE RTN ERR PTR --------------- */
    if (perr == (LIB_ERR *)0) {
        CPU_SW_EXCEPTION(0u);
 8002986:	f7ff f969 	bl	8001c5c <CPU_SW_Exception>
 800298a:	e7e1      	b.n	8002950 <Mem_PoolBlkGetNbrAvail+0x8>
 800298c:	4c4f4f50 	.word	0x4c4f4f50

08002990 <Mem_PoolBlkGet>:
/*$PAGE*/
#if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
void  *Mem_PoolBlkGet (MEM_POOL    *pmem_pool,
                       CPU_SIZE_T   size,
                       LIB_ERR     *perr)
{
 8002990:	b570      	push	{r4, r5, r6, lr}
 8002992:	4605      	mov	r5, r0
 8002994:	460c      	mov	r4, r1
    void  *pmem_blk;
    CPU_SR_ALLOC();


#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
    if (perr == (LIB_ERR *)0) {
 8002996:	4616      	mov	r6, r2
 8002998:	b30a      	cbz	r2, 80029de <Mem_PoolBlkGet+0x4e>
    }
#endif

                                                                    /* ------------ VALIDATE MEM POOL GET ------------- */
#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    if (pmem_pool == (MEM_POOL *)0) {                               /* Validate mem ptr.                                */
 800299a:	2d00      	cmp	r5, #0
 800299c:	d03e      	beq.n	8002a1c <Mem_PoolBlkGet+0x8c>
       *perr = LIB_MEM_ERR_NULL_PTR;
        return ((void *)0);
    }

    if (size < 1) {                                                 /* Validate req'd size as non-NULL.                 */
 800299e:	b1cc      	cbz	r4, 80029d4 <Mem_PoolBlkGet+0x44>
       *perr = LIB_MEM_ERR_INVALID_BLK_SIZE;
        return ((void *)0);
    }
#endif

    CPU_CRITICAL_ENTER();
 80029a0:	f7fe fee8 	bl	8001774 <CPU_SR_Save>

#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    if (pmem_pool->Type != LIB_MEM_TYPE_POOL) {                     /* Validate mem pool type.                          */
 80029a4:	4b20      	ldr	r3, [pc, #128]	; (8002a28 <Mem_PoolBlkGet+0x98>)
 80029a6:	682a      	ldr	r2, [r5, #0]
 80029a8:	429a      	cmp	r2, r3
 80029aa:	d11b      	bne.n	80029e4 <Mem_PoolBlkGet+0x54>
        CPU_CRITICAL_EXIT();
       *perr = LIB_MEM_ERR_INVALID_POOL;
        return ((void *)0);
    }

    if (size > pmem_pool->BlkSize) {                                /* Validate req'd size <= mem pool blk size.        */
 80029ac:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 80029ae:	429c      	cmp	r4, r3
 80029b0:	d826      	bhi.n	8002a00 <Mem_PoolBlkGet+0x70>
    }
#endif

   (void)&size;                                                     /* Prevent possible 'variable unused' warning.      */

    if (pmem_pool->BlkIx < 1) {                                     /* Validate mem pool as NOT empty.                  */
 80029b2:	6a6c      	ldr	r4, [r5, #36]	; 0x24
 80029b4:	b35c      	cbz	r4, 8002a0e <Mem_PoolBlkGet+0x7e>
        CPU_CRITICAL_EXIT();
       *perr = LIB_MEM_ERR_POOL_EMPTY;
        return ((void *)0);
    }

    if (pmem_pool->BlkIx > pmem_pool->BlkNbr) {                     /* Validate mem pool ix NOT corrupt.                */
 80029b6:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 80029b8:	429c      	cmp	r4, r3
 80029ba:	d81a      	bhi.n	80029f2 <Mem_PoolBlkGet+0x62>
        return ((void *)0);
    }

                                                                    /* ------------ GET MEM BLK FROM POOL ------------- */
    pmem_pool->BlkIx--;
    pmem_blk = pmem_pool->PoolPtrs[pmem_pool->BlkIx];
 80029bc:	6a2b      	ldr	r3, [r5, #32]
       *perr = LIB_MEM_ERR_INVALID_BLK_IX;
        return ((void *)0);
    }

                                                                    /* ------------ GET MEM BLK FROM POOL ------------- */
    pmem_pool->BlkIx--;
 80029be:	3c01      	subs	r4, #1
 80029c0:	626c      	str	r4, [r5, #36]	; 0x24
    pmem_blk = pmem_pool->PoolPtrs[pmem_pool->BlkIx];
 80029c2:	f853 4024 	ldr.w	r4, [r3, r4, lsl #2]

    CPU_CRITICAL_EXIT();
 80029c6:	f7fe fed9 	bl	800177c <CPU_SR_Restore>

   *perr =  LIB_MEM_ERR_NONE;
 80029ca:	f242 7310 	movw	r3, #10000	; 0x2710

    return (pmem_blk);
 80029ce:	4620      	mov	r0, r4
    pmem_pool->BlkIx--;
    pmem_blk = pmem_pool->PoolPtrs[pmem_pool->BlkIx];

    CPU_CRITICAL_EXIT();

   *perr =  LIB_MEM_ERR_NONE;
 80029d0:	8033      	strh	r3, [r6, #0]

    return (pmem_blk);
}
 80029d2:	bd70      	pop	{r4, r5, r6, pc}
       *perr = LIB_MEM_ERR_NULL_PTR;
        return ((void *)0);
    }

    if (size < 1) {                                                 /* Validate req'd size as non-NULL.                 */
       *perr = LIB_MEM_ERR_INVALID_BLK_SIZE;
 80029d4:	f242 7393 	movw	r3, #10131	; 0x2793
        return ((void *)0);
 80029d8:	4620      	mov	r0, r4
       *perr = LIB_MEM_ERR_NULL_PTR;
        return ((void *)0);
    }

    if (size < 1) {                                                 /* Validate req'd size as non-NULL.                 */
       *perr = LIB_MEM_ERR_INVALID_BLK_SIZE;
 80029da:	8033      	strh	r3, [r6, #0]
        return ((void *)0);
 80029dc:	bd70      	pop	{r4, r5, r6, pc}
    CPU_SR_ALLOC();


#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
    if (perr == (LIB_ERR *)0) {
        CPU_SW_EXCEPTION((void *)0);
 80029de:	f7ff f93d 	bl	8001c5c <CPU_SW_Exception>
 80029e2:	e7da      	b.n	800299a <Mem_PoolBlkGet+0xa>

    CPU_CRITICAL_ENTER();

#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    if (pmem_pool->Type != LIB_MEM_TYPE_POOL) {                     /* Validate mem pool type.                          */
        CPU_CRITICAL_EXIT();
 80029e4:	f7fe feca 	bl	800177c <CPU_SR_Restore>
       *perr = LIB_MEM_ERR_INVALID_POOL;
 80029e8:	f242 7388 	movw	r3, #10120	; 0x2788
        return ((void *)0);
 80029ec:	2000      	movs	r0, #0
    CPU_CRITICAL_ENTER();

#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    if (pmem_pool->Type != LIB_MEM_TYPE_POOL) {                     /* Validate mem pool type.                          */
        CPU_CRITICAL_EXIT();
       *perr = LIB_MEM_ERR_INVALID_POOL;
 80029ee:	8033      	strh	r3, [r6, #0]
        return ((void *)0);
 80029f0:	bd70      	pop	{r4, r5, r6, pc}
       *perr = LIB_MEM_ERR_POOL_EMPTY;
        return ((void *)0);
    }

    if (pmem_pool->BlkIx > pmem_pool->BlkNbr) {                     /* Validate mem pool ix NOT corrupt.                */
        CPU_CRITICAL_EXIT();
 80029f2:	f7fe fec3 	bl	800177c <CPU_SR_Restore>
       *perr = LIB_MEM_ERR_INVALID_BLK_IX;
 80029f6:	f242 7395 	movw	r3, #10133	; 0x2795
        return ((void *)0);
 80029fa:	2000      	movs	r0, #0
        return ((void *)0);
    }

    if (pmem_pool->BlkIx > pmem_pool->BlkNbr) {                     /* Validate mem pool ix NOT corrupt.                */
        CPU_CRITICAL_EXIT();
       *perr = LIB_MEM_ERR_INVALID_BLK_IX;
 80029fc:	8033      	strh	r3, [r6, #0]
        return ((void *)0);
 80029fe:	bd70      	pop	{r4, r5, r6, pc}
       *perr = LIB_MEM_ERR_INVALID_POOL;
        return ((void *)0);
    }

    if (size > pmem_pool->BlkSize) {                                /* Validate req'd size <= mem pool blk size.        */
        CPU_CRITICAL_EXIT();
 8002a00:	f7fe febc 	bl	800177c <CPU_SR_Restore>
       *perr = LIB_MEM_ERR_INVALID_BLK_SIZE;
 8002a04:	f242 7393 	movw	r3, #10131	; 0x2793
        return ((void *)0);
 8002a08:	2000      	movs	r0, #0
        return ((void *)0);
    }

    if (size > pmem_pool->BlkSize) {                                /* Validate req'd size <= mem pool blk size.        */
        CPU_CRITICAL_EXIT();
       *perr = LIB_MEM_ERR_INVALID_BLK_SIZE;
 8002a0a:	8033      	strh	r3, [r6, #0]
        return ((void *)0);
 8002a0c:	bd70      	pop	{r4, r5, r6, pc}
#endif

   (void)&size;                                                     /* Prevent possible 'variable unused' warning.      */

    if (pmem_pool->BlkIx < 1) {                                     /* Validate mem pool as NOT empty.                  */
        CPU_CRITICAL_EXIT();
 8002a0e:	f7fe feb5 	bl	800177c <CPU_SR_Restore>
       *perr = LIB_MEM_ERR_POOL_EMPTY;
 8002a12:	f242 73de 	movw	r3, #10206	; 0x27de
        return ((void *)0);
 8002a16:	4620      	mov	r0, r4

   (void)&size;                                                     /* Prevent possible 'variable unused' warning.      */

    if (pmem_pool->BlkIx < 1) {                                     /* Validate mem pool as NOT empty.                  */
        CPU_CRITICAL_EXIT();
       *perr = LIB_MEM_ERR_POOL_EMPTY;
 8002a18:	8033      	strh	r3, [r6, #0]
        return ((void *)0);
 8002a1a:	bd70      	pop	{r4, r5, r6, pc}
#endif

                                                                    /* ------------ VALIDATE MEM POOL GET ------------- */
#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    if (pmem_pool == (MEM_POOL *)0) {                               /* Validate mem ptr.                                */
       *perr = LIB_MEM_ERR_NULL_PTR;
 8002a1c:	f242 7311 	movw	r3, #10001	; 0x2711
        return ((void *)0);
 8002a20:	4628      	mov	r0, r5
#endif

                                                                    /* ------------ VALIDATE MEM POOL GET ------------- */
#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    if (pmem_pool == (MEM_POOL *)0) {                               /* Validate mem ptr.                                */
       *perr = LIB_MEM_ERR_NULL_PTR;
 8002a22:	8033      	strh	r3, [r6, #0]
        return ((void *)0);
 8002a24:	bd70      	pop	{r4, r5, r6, pc}
 8002a26:	bf00      	nop
 8002a28:	4c4f4f50 	.word	0x4c4f4f50

08002a2c <Mem_PoolBlkGetUsedAtIx>:
/*$PAGE*/
#if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
void  *Mem_PoolBlkGetUsedAtIx (MEM_POOL          *pmem_pool,
                               MEM_POOL_IX        used_ix,
                               LIB_ERR           *perr)
{
 8002a2c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002a2e:	4604      	mov	r4, r0
 8002a30:	460f      	mov	r7, r1
    void         *pmem_blk;
    CPU_SR_ALLOC();


#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
    if (perr == (LIB_ERR *)0) {
 8002a32:	4615      	mov	r5, r2
 8002a34:	b1d2      	cbz	r2, 8002a6c <Mem_PoolBlkGetUsedAtIx+0x40>
    }
#endif

                                                                    /* ------------ VALIDATE MEM POOL GET ------------- */
#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    if (pmem_pool == (MEM_POOL *)0) {                               /* Validate mem ptr.                                */
 8002a36:	b354      	cbz	r4, 8002a8e <Mem_PoolBlkGetUsedAtIx+0x62>
       *perr = LIB_MEM_ERR_NULL_PTR;
        return ((void *)0);
    }
#endif

    CPU_CRITICAL_ENTER();
 8002a38:	f7fe fe9c 	bl	8001774 <CPU_SR_Save>

#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    if (pmem_pool->Type != LIB_MEM_TYPE_POOL) {                     /* Validate mem pool type.                          */
 8002a3c:	4b16      	ldr	r3, [pc, #88]	; (8002a98 <Mem_PoolBlkGetUsedAtIx+0x6c>)
 8002a3e:	6822      	ldr	r2, [r4, #0]
 8002a40:	429a      	cmp	r2, r3
 8002a42:	d11d      	bne.n	8002a80 <Mem_PoolBlkGetUsedAtIx+0x54>
        CPU_CRITICAL_EXIT();
       *perr = LIB_MEM_ERR_INVALID_POOL;
        return ((void *)0);
    }

    if (pmem_pool->BlkIx >= pmem_pool->BlkNbr) {                    /* Validate mem pool as NOT full.                   */
 8002a44:	6a66      	ldr	r6, [r4, #36]	; 0x24
 8002a46:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8002a48:	4296      	cmp	r6, r2
 8002a4a:	d212      	bcs.n	8002a72 <Mem_PoolBlkGetUsedAtIx+0x46>
       *perr = LIB_MEM_ERR_INVALID_BLK_IX;
        return ((void *)0);
    }
#endif

    blk_ix = pmem_pool->BlkNbr - used_ix - 1u;
 8002a4c:	1e53      	subs	r3, r2, #1
 8002a4e:	1bd9      	subs	r1, r3, r7

    if (blk_ix >= pmem_pool->BlkNbr) {                              /* Validate ix range.                               */
 8002a50:	428a      	cmp	r2, r1
 8002a52:	d90e      	bls.n	8002a72 <Mem_PoolBlkGetUsedAtIx+0x46>
        CPU_CRITICAL_EXIT();
       *perr = LIB_MEM_ERR_INVALID_BLK_IX;
        return ((void *)0);
    }

    if (blk_ix < pmem_pool->BlkIx) {
 8002a54:	428e      	cmp	r6, r1
 8002a56:	d80c      	bhi.n	8002a72 <Mem_PoolBlkGetUsedAtIx+0x46>
        CPU_CRITICAL_EXIT();
       *perr = LIB_MEM_ERR_INVALID_BLK_IX;
        return ((void *)0);
    }
                                                                    /* ------------ GET MEM BLK FROM POOL ------------- */
    pmem_blk = pmem_pool->PoolPtrs[blk_ix];
 8002a58:	6a23      	ldr	r3, [r4, #32]
 8002a5a:	f853 4021 	ldr.w	r4, [r3, r1, lsl #2]

    CPU_CRITICAL_EXIT();
 8002a5e:	f7fe fe8d 	bl	800177c <CPU_SR_Restore>

   *perr =  LIB_MEM_ERR_NONE;
 8002a62:	f242 7310 	movw	r3, #10000	; 0x2710

    return (pmem_blk);
 8002a66:	4620      	mov	r0, r4
                                                                    /* ------------ GET MEM BLK FROM POOL ------------- */
    pmem_blk = pmem_pool->PoolPtrs[blk_ix];

    CPU_CRITICAL_EXIT();

   *perr =  LIB_MEM_ERR_NONE;
 8002a68:	802b      	strh	r3, [r5, #0]

    return (pmem_blk);
}
 8002a6a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    CPU_SR_ALLOC();


#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
    if (perr == (LIB_ERR *)0) {
        CPU_SW_EXCEPTION((void *)0);
 8002a6c:	f7ff f8f6 	bl	8001c5c <CPU_SW_Exception>
 8002a70:	e7e1      	b.n	8002a36 <Mem_PoolBlkGetUsedAtIx+0xa>
       *perr = LIB_MEM_ERR_INVALID_BLK_IX;
        return ((void *)0);
    }

    if (blk_ix < pmem_pool->BlkIx) {
        CPU_CRITICAL_EXIT();
 8002a72:	f7fe fe83 	bl	800177c <CPU_SR_Restore>
       *perr = LIB_MEM_ERR_INVALID_BLK_IX;
 8002a76:	f242 7395 	movw	r3, #10133	; 0x2795
        return ((void *)0);
 8002a7a:	2000      	movs	r0, #0
        return ((void *)0);
    }

    if (blk_ix < pmem_pool->BlkIx) {
        CPU_CRITICAL_EXIT();
       *perr = LIB_MEM_ERR_INVALID_BLK_IX;
 8002a7c:	802b      	strh	r3, [r5, #0]
        return ((void *)0);
 8002a7e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

    CPU_CRITICAL_ENTER();

#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    if (pmem_pool->Type != LIB_MEM_TYPE_POOL) {                     /* Validate mem pool type.                          */
        CPU_CRITICAL_EXIT();
 8002a80:	f7fe fe7c 	bl	800177c <CPU_SR_Restore>
       *perr = LIB_MEM_ERR_INVALID_POOL;
 8002a84:	f242 7388 	movw	r3, #10120	; 0x2788
        return ((void *)0);
 8002a88:	2000      	movs	r0, #0
    CPU_CRITICAL_ENTER();

#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    if (pmem_pool->Type != LIB_MEM_TYPE_POOL) {                     /* Validate mem pool type.                          */
        CPU_CRITICAL_EXIT();
       *perr = LIB_MEM_ERR_INVALID_POOL;
 8002a8a:	802b      	strh	r3, [r5, #0]
        return ((void *)0);
 8002a8c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
#endif

                                                                    /* ------------ VALIDATE MEM POOL GET ------------- */
#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    if (pmem_pool == (MEM_POOL *)0) {                               /* Validate mem ptr.                                */
       *perr = LIB_MEM_ERR_NULL_PTR;
 8002a8e:	f242 7311 	movw	r3, #10001	; 0x2711
        return ((void *)0);
 8002a92:	4620      	mov	r0, r4
#endif

                                                                    /* ------------ VALIDATE MEM POOL GET ------------- */
#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    if (pmem_pool == (MEM_POOL *)0) {                               /* Validate mem ptr.                                */
       *perr = LIB_MEM_ERR_NULL_PTR;
 8002a94:	802b      	strh	r3, [r5, #0]
        return ((void *)0);
 8002a96:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002a98:	4c4f4f50 	.word	0x4c4f4f50

08002a9c <Mem_PoolBlkFree>:
/*$PAGE*/
#if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
void  Mem_PoolBlkFree (MEM_POOL  *pmem_pool,
                       void      *pmem_blk,
                       LIB_ERR   *perr)
{
 8002a9c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8002aa0:	4606      	mov	r6, r0
 8002aa2:	460c      	mov	r4, r1
    MEM_POOL_IX   i;
    CPU_SR_ALLOC();


#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
    if (perr == (LIB_ERR *)0) {
 8002aa4:	4615      	mov	r5, r2
 8002aa6:	2a00      	cmp	r2, #0
 8002aa8:	d04a      	beq.n	8002b40 <Mem_PoolBlkFree+0xa4>
    }
#endif

                                                                    /* ------------ VALIDATE MEM POOL FREE ------------ */
#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* Validate mem ptrs.                               */
    if (pmem_pool == (MEM_POOL *)0) {
 8002aaa:	2e00      	cmp	r6, #0
 8002aac:	d043      	beq.n	8002b36 <Mem_PoolBlkFree+0x9a>
       *perr = LIB_MEM_ERR_NULL_PTR;
        return;
    }

    if (pmem_blk == (void *)0) {
 8002aae:	2c00      	cmp	r4, #0
 8002ab0:	d041      	beq.n	8002b36 <Mem_PoolBlkFree+0x9a>
       *perr = LIB_MEM_ERR_NULL_PTR;
        return;
    }
#endif

    CPU_CRITICAL_ENTER();
 8002ab2:	f7fe fe5f 	bl	8001774 <CPU_SR_Save>

#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    if (pmem_pool->Type != LIB_MEM_TYPE_POOL) {                     /* Validate mem pool type.                          */
 8002ab6:	4b3c      	ldr	r3, [pc, #240]	; (8002ba8 <Mem_PoolBlkFree+0x10c>)
 8002ab8:	6832      	ldr	r2, [r6, #0]
       *perr = LIB_MEM_ERR_NULL_PTR;
        return;
    }
#endif

    CPU_CRITICAL_ENTER();
 8002aba:	4607      	mov	r7, r0

#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    if (pmem_pool->Type != LIB_MEM_TYPE_POOL) {                     /* Validate mem pool type.                          */
 8002abc:	429a      	cmp	r2, r3
 8002abe:	d133      	bne.n	8002b28 <Mem_PoolBlkFree+0x8c>
        CPU_CRITICAL_EXIT();
       *perr = LIB_MEM_ERR_INVALID_POOL;
        return;
    }

    addr_valid = Mem_PoolBlkIsValidAddr(pmem_pool, pmem_blk);       /* Validate mem blk as valid pool blk addr.         */
 8002ac0:	4621      	mov	r1, r4
 8002ac2:	4630      	mov	r0, r6
 8002ac4:	f7ff fae6 	bl	8002094 <Mem_PoolBlkIsValidAddr>
    if (addr_valid != DEF_OK) {
 8002ac8:	2801      	cmp	r0, #1
 8002aca:	d13c      	bne.n	8002b46 <Mem_PoolBlkFree+0xaa>
        CPU_CRITICAL_EXIT();
       *perr = LIB_MEM_ERR_INVALID_BLK_ADDR;
        return;
    }

    for (i = 0u; i < pmem_pool->BlkIx; i++) {                       /* Validate mem blk  NOT already in pool.           */
 8002acc:	6a72      	ldr	r2, [r6, #36]	; 0x24
 8002ace:	2a00      	cmp	r2, #0
 8002ad0:	d060      	beq.n	8002b94 <Mem_PoolBlkFree+0xf8>
        if (pmem_blk == pmem_pool->PoolPtrs[i]) {
 8002ad2:	f8d6 e020 	ldr.w	lr, [r6, #32]
 8002ad6:	f8de 3000 	ldr.w	r3, [lr]
 8002ada:	429c      	cmp	r4, r3
 8002adc:	d03b      	beq.n	8002b56 <Mem_PoolBlkFree+0xba>
 8002ade:	4671      	mov	r1, lr
 8002ae0:	2300      	movs	r3, #0
 8002ae2:	e003      	b.n	8002aec <Mem_PoolBlkFree+0x50>
 8002ae4:	f851 0f04 	ldr.w	r0, [r1, #4]!
 8002ae8:	4284      	cmp	r4, r0
 8002aea:	d034      	beq.n	8002b56 <Mem_PoolBlkFree+0xba>
        CPU_CRITICAL_EXIT();
       *perr = LIB_MEM_ERR_INVALID_BLK_ADDR;
        return;
    }

    for (i = 0u; i < pmem_pool->BlkIx; i++) {                       /* Validate mem blk  NOT already in pool.           */
 8002aec:	3301      	adds	r3, #1
 8002aee:	429a      	cmp	r2, r3
 8002af0:	d1f8      	bne.n	8002ae4 <Mem_PoolBlkFree+0x48>
            return;
        }
    }
#endif

    if (pmem_pool->BlkIx >= pmem_pool->BlkNbr) {                    /* Validate mem pool NOT already full.              */
 8002af2:	f8d6 c02c 	ldr.w	ip, [r6, #44]	; 0x2c
 8002af6:	4562      	cmp	r2, ip
 8002af8:	d244      	bcs.n	8002b84 <Mem_PoolBlkFree+0xe8>
 8002afa:	f102 0801 	add.w	r8, r2, #1
 8002afe:	ea4f 0982 	mov.w	r9, r2, lsl #2
    }

                                                                    /* ------------- FREE MEM BLK TO POOL ------------- */
    addr_valid = DEF_NO;
    for (i = pmem_pool->BlkIx; i < pmem_pool->BlkNbr; i++) {        /* Find ix of mem blk to free.                      */
        p_addr = pmem_pool->PoolPtrs[i];
 8002b02:	f85e a009 	ldr.w	sl, [lr, r9]
 8002b06:	eb0e 0109 	add.w	r1, lr, r9
        if (p_addr == pmem_blk) {
 8002b0a:	4554      	cmp	r4, sl
 8002b0c:	d02b      	beq.n	8002b66 <Mem_PoolBlkFree+0xca>
 8002b0e:	3201      	adds	r2, #1
 8002b10:	eb0e 0382 	add.w	r3, lr, r2, lsl #2
 8002b14:	e005      	b.n	8002b22 <Mem_PoolBlkFree+0x86>
    }

                                                                    /* ------------- FREE MEM BLK TO POOL ------------- */
    addr_valid = DEF_NO;
    for (i = pmem_pool->BlkIx; i < pmem_pool->BlkNbr; i++) {        /* Find ix of mem blk to free.                      */
        p_addr = pmem_pool->PoolPtrs[i];
 8002b16:	4619      	mov	r1, r3
        if (p_addr == pmem_blk) {
 8002b18:	6808      	ldr	r0, [r1, #0]
 8002b1a:	3304      	adds	r3, #4
 8002b1c:	4284      	cmp	r4, r0
 8002b1e:	d022      	beq.n	8002b66 <Mem_PoolBlkFree+0xca>
 8002b20:	3201      	adds	r2, #1
        return;
    }

                                                                    /* ------------- FREE MEM BLK TO POOL ------------- */
    addr_valid = DEF_NO;
    for (i = pmem_pool->BlkIx; i < pmem_pool->BlkNbr; i++) {        /* Find ix of mem blk to free.                      */
 8002b22:	4562      	cmp	r2, ip
 8002b24:	d3f7      	bcc.n	8002b16 <Mem_PoolBlkFree+0x7a>
                                                                    /* Swap addr of mem blk to free in tbl.             */
    if (addr_valid == DEF_YES) {
        pmem_pool->PoolPtrs[i] = pmem_pool->PoolPtrs[pmem_pool->BlkIx];
    } else {
#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
        CPU_CRITICAL_EXIT();
 8002b26:	4638      	mov	r0, r7
 8002b28:	f7fe fe28 	bl	800177c <CPU_SR_Restore>
       *perr = LIB_MEM_ERR_INVALID_POOL;
 8002b2c:	f242 7388 	movw	r3, #10120	; 0x2788
 8002b30:	802b      	strh	r3, [r5, #0]
        return;
 8002b32:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
#endif

                                                                    /* ------------ VALIDATE MEM POOL FREE ------------ */
#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* Validate mem ptrs.                               */
    if (pmem_pool == (MEM_POOL *)0) {
       *perr = LIB_MEM_ERR_NULL_PTR;
 8002b36:	f242 7311 	movw	r3, #10001	; 0x2711
 8002b3a:	802b      	strh	r3, [r5, #0]
        return;
 8002b3c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    CPU_SR_ALLOC();


#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
    if (perr == (LIB_ERR *)0) {
        CPU_SW_EXCEPTION(;);
 8002b40:	f7ff f88c 	bl	8001c5c <CPU_SW_Exception>
 8002b44:	e7b1      	b.n	8002aaa <Mem_PoolBlkFree+0xe>
        return;
    }

    addr_valid = Mem_PoolBlkIsValidAddr(pmem_pool, pmem_blk);       /* Validate mem blk as valid pool blk addr.         */
    if (addr_valid != DEF_OK) {
        CPU_CRITICAL_EXIT();
 8002b46:	4638      	mov	r0, r7
 8002b48:	f7fe fe18 	bl	800177c <CPU_SR_Restore>
       *perr = LIB_MEM_ERR_INVALID_BLK_ADDR;
 8002b4c:	f242 7397 	movw	r3, #10135	; 0x2797
 8002b50:	802b      	strh	r3, [r5, #0]
        return;
 8002b52:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    }

    for (i = 0u; i < pmem_pool->BlkIx; i++) {                       /* Validate mem blk  NOT already in pool.           */
        if (pmem_blk == pmem_pool->PoolPtrs[i]) {
            CPU_CRITICAL_EXIT();
 8002b56:	4638      	mov	r0, r7
 8002b58:	f7fe fe10 	bl	800177c <CPU_SR_Restore>
           *perr = LIB_MEM_ERR_INVALID_BLK_ADDR_IN_POOL;
 8002b5c:	f242 7398 	movw	r3, #10136	; 0x2798
 8002b60:	802b      	strh	r3, [r5, #0]
            return;
 8002b62:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            break;
        }
    }
                                                                    /* Swap addr of mem blk to free in tbl.             */
    if (addr_valid == DEF_YES) {
        pmem_pool->PoolPtrs[i] = pmem_pool->PoolPtrs[pmem_pool->BlkIx];
 8002b66:	f8c1 a000 	str.w	sl, [r1]
        return;
#endif
    }

                                                                    /* Free mem blk.                                    */
    pmem_pool->PoolPtrs[pmem_pool->BlkIx] = pmem_blk;
 8002b6a:	6a33      	ldr	r3, [r6, #32]
    pmem_pool->BlkIx++;

    CPU_CRITICAL_EXIT();
 8002b6c:	4638      	mov	r0, r7
        return;
#endif
    }

                                                                    /* Free mem blk.                                    */
    pmem_pool->PoolPtrs[pmem_pool->BlkIx] = pmem_blk;
 8002b6e:	f843 4009 	str.w	r4, [r3, r9]
    pmem_pool->BlkIx++;
 8002b72:	f8c6 8024 	str.w	r8, [r6, #36]	; 0x24

    CPU_CRITICAL_EXIT();
 8002b76:	f7fe fe01 	bl	800177c <CPU_SR_Restore>

   *perr = LIB_MEM_ERR_NONE;
 8002b7a:	f242 7310 	movw	r3, #10000	; 0x2710
 8002b7e:	802b      	strh	r3, [r5, #0]
 8002b80:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        }
    }
#endif

    if (pmem_pool->BlkIx >= pmem_pool->BlkNbr) {                    /* Validate mem pool NOT already full.              */
        CPU_CRITICAL_EXIT();
 8002b84:	4638      	mov	r0, r7
 8002b86:	f7fe fdf9 	bl	800177c <CPU_SR_Restore>
       *perr = LIB_MEM_ERR_POOL_FULL;
 8002b8a:	f242 73dd 	movw	r3, #10205	; 0x27dd
 8002b8e:	802b      	strh	r3, [r5, #0]
        return;
 8002b90:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            return;
        }
    }
#endif

    if (pmem_pool->BlkIx >= pmem_pool->BlkNbr) {                    /* Validate mem pool NOT already full.              */
 8002b94:	f8d6 c02c 	ldr.w	ip, [r6, #44]	; 0x2c
 8002b98:	f1bc 0f00 	cmp.w	ip, #0
 8002b9c:	d0f2      	beq.n	8002b84 <Mem_PoolBlkFree+0xe8>
 8002b9e:	4680      	mov	r8, r0
 8002ba0:	f8d6 e020 	ldr.w	lr, [r6, #32]
 8002ba4:	4691      	mov	r9, r2
 8002ba6:	e7ac      	b.n	8002b02 <Mem_PoolBlkFree+0x66>
 8002ba8:	4c4f4f50 	.word	0x4c4f4f50

08002bac <Mem_PoolBlkIxGet>:
/*$PAGE*/
#if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
MEM_POOL_IX  Mem_PoolBlkIxGet (MEM_POOL  *pmem_pool,
                               void      *pmem_blk,
                               LIB_ERR   *perr)
{
 8002bac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002bae:	4605      	mov	r5, r0
 8002bb0:	460e      	mov	r6, r1
    CPU_SR_ALLOC();


    invalid_ix = DEF_GET_U_MAX_VAL(MEM_POOL_IX);
#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
    if (perr == (LIB_ERR *)0) {
 8002bb2:	4614      	mov	r4, r2
 8002bb4:	b1b2      	cbz	r2, 8002be4 <Mem_PoolBlkIxGet+0x38>
    }
#endif

                                                                    /* ------------ VALIDATE MEM POOL FREE ------------ */
#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* Validate mem ptrs.                               */
    if (pmem_pool == (MEM_POOL *)0) {
 8002bb6:	b17d      	cbz	r5, 8002bd8 <Mem_PoolBlkIxGet+0x2c>
       *perr = LIB_MEM_ERR_NULL_PTR;
        return (invalid_ix);
    }

    if (pmem_blk == (void *)0) {
 8002bb8:	b176      	cbz	r6, 8002bd8 <Mem_PoolBlkIxGet+0x2c>
       *perr = LIB_MEM_ERR_NULL_PTR;
        return (invalid_ix);
    }
#endif

    CPU_CRITICAL_ENTER();
 8002bba:	f7fe fddb 	bl	8001774 <CPU_SR_Save>

#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    if (pmem_pool->Type != LIB_MEM_TYPE_POOL) {                     /* Validate mem pool type.                          */
 8002bbe:	4b38      	ldr	r3, [pc, #224]	; (8002ca0 <Mem_PoolBlkIxGet+0xf4>)
 8002bc0:	682a      	ldr	r2, [r5, #0]
       *perr = LIB_MEM_ERR_NULL_PTR;
        return (invalid_ix);
    }
#endif

    CPU_CRITICAL_ENTER();
 8002bc2:	4607      	mov	r7, r0

#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
    if (pmem_pool->Type != LIB_MEM_TYPE_POOL) {                     /* Validate mem pool type.                          */
 8002bc4:	429a      	cmp	r2, r3
 8002bc6:	d010      	beq.n	8002bea <Mem_PoolBlkIxGet+0x3e>
        pool_ix = pmem_pool->BlkNbr - 1 - i;
        CPU_CRITICAL_EXIT();
       *perr = LIB_MEM_ERR_NONE;
        return (pool_ix);
    } else {
        CPU_CRITICAL_EXIT();
 8002bc8:	f7fe fdd8 	bl	800177c <CPU_SR_Restore>
       *perr = LIB_MEM_ERR_INVALID_POOL;
 8002bcc:	f242 7388 	movw	r3, #10120	; 0x2788
        return (invalid_ix);
 8002bd0:	f04f 30ff 	mov.w	r0, #4294967295
        CPU_CRITICAL_EXIT();
       *perr = LIB_MEM_ERR_NONE;
        return (pool_ix);
    } else {
        CPU_CRITICAL_EXIT();
       *perr = LIB_MEM_ERR_INVALID_POOL;
 8002bd4:	8023      	strh	r3, [r4, #0]
        return (invalid_ix);
 8002bd6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
#endif

                                                                    /* ------------ VALIDATE MEM POOL FREE ------------ */
#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* Validate mem ptrs.                               */
    if (pmem_pool == (MEM_POOL *)0) {
       *perr = LIB_MEM_ERR_NULL_PTR;
 8002bd8:	f242 7311 	movw	r3, #10001	; 0x2711
        return (invalid_ix);
 8002bdc:	f04f 30ff 	mov.w	r0, #4294967295
#endif

                                                                    /* ------------ VALIDATE MEM POOL FREE ------------ */
#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* Validate mem ptrs.                               */
    if (pmem_pool == (MEM_POOL *)0) {
       *perr = LIB_MEM_ERR_NULL_PTR;
 8002be0:	8023      	strh	r3, [r4, #0]
        return (invalid_ix);
 8002be2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}


    invalid_ix = DEF_GET_U_MAX_VAL(MEM_POOL_IX);
#if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
    if (perr == (LIB_ERR *)0) {
        CPU_SW_EXCEPTION(invalid_ix);
 8002be4:	f7ff f83a 	bl	8001c5c <CPU_SW_Exception>
 8002be8:	e7e5      	b.n	8002bb6 <Mem_PoolBlkIxGet+0xa>
        CPU_CRITICAL_EXIT();
       *perr = LIB_MEM_ERR_INVALID_POOL;
        return(invalid_ix);
    }

    addr_valid = Mem_PoolBlkIsValidAddr(pmem_pool, pmem_blk);       /* Validate mem blk as valid pool blk addr.         */
 8002bea:	4631      	mov	r1, r6
 8002bec:	4628      	mov	r0, r5
 8002bee:	f7ff fa51 	bl	8002094 <Mem_PoolBlkIsValidAddr>
    if (addr_valid != DEF_OK) {
 8002bf2:	2801      	cmp	r0, #1
 8002bf4:	d008      	beq.n	8002c08 <Mem_PoolBlkIxGet+0x5c>
        CPU_CRITICAL_EXIT();
 8002bf6:	4638      	mov	r0, r7
 8002bf8:	f7fe fdc0 	bl	800177c <CPU_SR_Restore>
       *perr = LIB_MEM_ERR_INVALID_BLK_ADDR;
 8002bfc:	f242 7397 	movw	r3, #10135	; 0x2797
        return (invalid_ix);
 8002c00:	f04f 30ff 	mov.w	r0, #4294967295
    }

    addr_valid = Mem_PoolBlkIsValidAddr(pmem_pool, pmem_blk);       /* Validate mem blk as valid pool blk addr.         */
    if (addr_valid != DEF_OK) {
        CPU_CRITICAL_EXIT();
       *perr = LIB_MEM_ERR_INVALID_BLK_ADDR;
 8002c04:	8023      	strh	r3, [r4, #0]
        return (invalid_ix);
 8002c06:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    }

    for (i = 0u; i < pmem_pool->BlkIx; i++) {                       /* Validate mem blk  NOT already in pool.           */
 8002c08:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8002c0a:	2a00      	cmp	r2, #0
 8002c0c:	d040      	beq.n	8002c90 <Mem_PoolBlkIxGet+0xe4>
        if (pmem_blk == pmem_pool->PoolPtrs[i]) {
 8002c0e:	f8d5 e020 	ldr.w	lr, [r5, #32]
 8002c12:	f8de 3000 	ldr.w	r3, [lr]
 8002c16:	429e      	cmp	r6, r3
 8002c18:	d01e      	beq.n	8002c58 <Mem_PoolBlkIxGet+0xac>
 8002c1a:	4671      	mov	r1, lr
 8002c1c:	2300      	movs	r3, #0
 8002c1e:	e003      	b.n	8002c28 <Mem_PoolBlkIxGet+0x7c>
 8002c20:	f851 0f04 	ldr.w	r0, [r1, #4]!
 8002c24:	4286      	cmp	r6, r0
 8002c26:	d017      	beq.n	8002c58 <Mem_PoolBlkIxGet+0xac>
        CPU_CRITICAL_EXIT();
       *perr = LIB_MEM_ERR_INVALID_BLK_ADDR;
        return (invalid_ix);
    }

    for (i = 0u; i < pmem_pool->BlkIx; i++) {                       /* Validate mem blk  NOT already in pool.           */
 8002c28:	3301      	adds	r3, #1
 8002c2a:	429a      	cmp	r2, r3
 8002c2c:	d1f8      	bne.n	8002c20 <Mem_PoolBlkIxGet+0x74>
            return (invalid_ix);
        }
    }
#endif

    if (pmem_pool->BlkIx >= pmem_pool->BlkNbr) {                    /* Validate mem pool NOT full.                      */
 8002c2e:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8002c30:	429a      	cmp	r2, r3
 8002c32:	d21a      	bcs.n	8002c6a <Mem_PoolBlkIxGet+0xbe>
 8002c34:	0091      	lsls	r1, r2, #2
    }

    addr_valid = DEF_NO;
    for (i = pmem_pool->BlkIx; i < pmem_pool->BlkNbr; i++) {        /* Find ix of mem blk.                              */
        p_addr = pmem_pool->PoolPtrs[i];
        if (p_addr == pmem_blk) {
 8002c36:	f85e 1001 	ldr.w	r1, [lr, r1]
 8002c3a:	428e      	cmp	r6, r1
 8002c3c:	bf18      	it	ne
 8002c3e:	eb0e 0182 	addne.w	r1, lr, r2, lsl #2
 8002c42:	d104      	bne.n	8002c4e <Mem_PoolBlkIxGet+0xa2>
 8002c44:	e01a      	b.n	8002c7c <Mem_PoolBlkIxGet+0xd0>
 8002c46:	f851 0f04 	ldr.w	r0, [r1, #4]!
 8002c4a:	4286      	cmp	r6, r0
 8002c4c:	d016      	beq.n	8002c7c <Mem_PoolBlkIxGet+0xd0>
       *perr = LIB_MEM_ERR_POOL_FULL;
        return (invalid_ix);
    }

    addr_valid = DEF_NO;
    for (i = pmem_pool->BlkIx; i < pmem_pool->BlkNbr; i++) {        /* Find ix of mem blk.                              */
 8002c4e:	3201      	adds	r2, #1
 8002c50:	429a      	cmp	r2, r3
 8002c52:	d3f8      	bcc.n	8002c46 <Mem_PoolBlkIxGet+0x9a>
        pool_ix = pmem_pool->BlkNbr - 1 - i;
        CPU_CRITICAL_EXIT();
       *perr = LIB_MEM_ERR_NONE;
        return (pool_ix);
    } else {
        CPU_CRITICAL_EXIT();
 8002c54:	4638      	mov	r0, r7
 8002c56:	e7b7      	b.n	8002bc8 <Mem_PoolBlkIxGet+0x1c>
        return (invalid_ix);
    }

    for (i = 0u; i < pmem_pool->BlkIx; i++) {                       /* Validate mem blk  NOT already in pool.           */
        if (pmem_blk == pmem_pool->PoolPtrs[i]) {
            CPU_CRITICAL_EXIT();
 8002c58:	4638      	mov	r0, r7
 8002c5a:	f7fe fd8f 	bl	800177c <CPU_SR_Restore>
           *perr = LIB_MEM_ERR_INVALID_BLK_ADDR_IN_POOL;
 8002c5e:	f242 7398 	movw	r3, #10136	; 0x2798
            return (invalid_ix);
 8002c62:	f04f 30ff 	mov.w	r0, #4294967295
    }

    for (i = 0u; i < pmem_pool->BlkIx; i++) {                       /* Validate mem blk  NOT already in pool.           */
        if (pmem_blk == pmem_pool->PoolPtrs[i]) {
            CPU_CRITICAL_EXIT();
           *perr = LIB_MEM_ERR_INVALID_BLK_ADDR_IN_POOL;
 8002c66:	8023      	strh	r3, [r4, #0]
            return (invalid_ix);
 8002c68:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        }
    }
#endif

    if (pmem_pool->BlkIx >= pmem_pool->BlkNbr) {                    /* Validate mem pool NOT full.                      */
        CPU_CRITICAL_EXIT();
 8002c6a:	4638      	mov	r0, r7
 8002c6c:	f7fe fd86 	bl	800177c <CPU_SR_Restore>
       *perr = LIB_MEM_ERR_POOL_FULL;
 8002c70:	f242 73dd 	movw	r3, #10205	; 0x27dd
        return (invalid_ix);
 8002c74:	f04f 30ff 	mov.w	r0, #4294967295
    }
#endif

    if (pmem_pool->BlkIx >= pmem_pool->BlkNbr) {                    /* Validate mem pool NOT full.                      */
        CPU_CRITICAL_EXIT();
       *perr = LIB_MEM_ERR_POOL_FULL;
 8002c78:	8023      	strh	r3, [r4, #0]
        return (invalid_ix);
 8002c7a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            break;
        }
    }
                                                                    /* Return ix of mem blk in tbl.                     */
    if (addr_valid == DEF_YES) {
        pool_ix = pmem_pool->BlkNbr - 1 - i;
 8002c7c:	3b01      	subs	r3, #1
        CPU_CRITICAL_EXIT();
 8002c7e:	4638      	mov	r0, r7
            break;
        }
    }
                                                                    /* Return ix of mem blk in tbl.                     */
    if (addr_valid == DEF_YES) {
        pool_ix = pmem_pool->BlkNbr - 1 - i;
 8002c80:	1a9d      	subs	r5, r3, r2
        CPU_CRITICAL_EXIT();
 8002c82:	f7fe fd7b 	bl	800177c <CPU_SR_Restore>
       *perr = LIB_MEM_ERR_NONE;
 8002c86:	f242 7310 	movw	r3, #10000	; 0x2710
        return (pool_ix);
 8002c8a:	4628      	mov	r0, r5
    }
                                                                    /* Return ix of mem blk in tbl.                     */
    if (addr_valid == DEF_YES) {
        pool_ix = pmem_pool->BlkNbr - 1 - i;
        CPU_CRITICAL_EXIT();
       *perr = LIB_MEM_ERR_NONE;
 8002c8c:	8023      	strh	r3, [r4, #0]
        return (pool_ix);
 8002c8e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            return (invalid_ix);
        }
    }
#endif

    if (pmem_pool->BlkIx >= pmem_pool->BlkNbr) {                    /* Validate mem pool NOT full.                      */
 8002c90:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8002c92:	2b00      	cmp	r3, #0
 8002c94:	d0e9      	beq.n	8002c6a <Mem_PoolBlkIxGet+0xbe>
 8002c96:	f8d5 e020 	ldr.w	lr, [r5, #32]
 8002c9a:	4611      	mov	r1, r2
 8002c9c:	e7cb      	b.n	8002c36 <Mem_PoolBlkIxGet+0x8a>
 8002c9e:	bf00      	nop
 8002ca0:	4c4f4f50 	.word	0x4c4f4f50

08002ca4 <Mem_Copy>:
 8002ca4:	2800      	cmp	r0, #0
 8002ca6:	d100      	bne.n	8002caa <Mem_Copy_1>
 8002ca8:	4770      	bx	lr

08002caa <Mem_Copy_1>:
 8002caa:	2900      	cmp	r1, #0
 8002cac:	d100      	bne.n	8002cb0 <Mem_Copy_2>
 8002cae:	4770      	bx	lr

08002cb0 <Mem_Copy_2>:
 8002cb0:	2a00      	cmp	r2, #0
 8002cb2:	d100      	bne.n	8002cb6 <Mem_Copy_3>
 8002cb4:	4770      	bx	lr

08002cb6 <Mem_Copy_3>:
 8002cb6:	e92d 1ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}

08002cba <Chk_Align_32>:
 8002cba:	f000 0303 	and.w	r3, r0, #3
 8002cbe:	f001 0403 	and.w	r4, r1, #3
 8002cc2:	42a3      	cmp	r3, r4
 8002cc4:	d111      	bne.n	8002cea <Chk_Align_16>
 8002cc6:	f1c3 0304 	rsb	r3, r3, #4
 8002cca:	f003 0303 	and.w	r3, r3, #3

08002cce <Pre_Copy_1>:
 8002cce:	2b01      	cmp	r3, #1
 8002cd0:	d31d      	bcc.n	8002d0e <Copy_32_1>
 8002cd2:	2a01      	cmp	r2, #1
 8002cd4:	d200      	bcs.n	8002cd8 <Pre_Copy_1_Cont>
 8002cd6:	e0f2      	b.n	8002ebe <Mem_Copy_END>

08002cd8 <Pre_Copy_1_Cont>:
 8002cd8:	f811 4b01 	ldrb.w	r4, [r1], #1
 8002cdc:	f800 4b01 	strb.w	r4, [r0], #1
 8002ce0:	f1a3 0301 	sub.w	r3, r3, #1
 8002ce4:	f1a2 0201 	sub.w	r2, r2, #1
 8002ce8:	e7f1      	b.n	8002cce <Pre_Copy_1>

08002cea <Chk_Align_16>:
 8002cea:	f000 0301 	and.w	r3, r0, #1
 8002cee:	f001 0401 	and.w	r4, r1, #1
 8002cf2:	42a3      	cmp	r3, r4
 8002cf4:	d000      	beq.n	8002cf8 <Pre_Copy_2>
 8002cf6:	e094      	b.n	8002e22 <Copy_08_1>

08002cf8 <Pre_Copy_2>:
 8002cf8:	2b01      	cmp	r3, #1
 8002cfa:	d344      	bcc.n	8002d86 <Copy_16_1>
 8002cfc:	f811 4b01 	ldrb.w	r4, [r1], #1
 8002d00:	f800 4b01 	strb.w	r4, [r0], #1
 8002d04:	f1a3 0301 	sub.w	r3, r3, #1
 8002d08:	f1a2 0201 	sub.w	r2, r2, #1
 8002d0c:	e7f4      	b.n	8002cf8 <Pre_Copy_2>

08002d0e <Copy_32_1>:
 8002d0e:	f5b2 7fb4 	cmp.w	r2, #360	; 0x168
 8002d12:	d326      	bcc.n	8002d62 <Copy_32_2>
 8002d14:	e8b1 1ff8 	ldmia.w	r1!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 8002d18:	e8a0 1ff8 	stmia.w	r0!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 8002d1c:	e8b1 1ff8 	ldmia.w	r1!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 8002d20:	e8a0 1ff8 	stmia.w	r0!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 8002d24:	e8b1 1ff8 	ldmia.w	r1!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 8002d28:	e8a0 1ff8 	stmia.w	r0!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 8002d2c:	e8b1 1ff8 	ldmia.w	r1!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 8002d30:	e8a0 1ff8 	stmia.w	r0!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 8002d34:	e8b1 1ff8 	ldmia.w	r1!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 8002d38:	e8a0 1ff8 	stmia.w	r0!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 8002d3c:	e8b1 1ff8 	ldmia.w	r1!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 8002d40:	e8a0 1ff8 	stmia.w	r0!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 8002d44:	e8b1 1ff8 	ldmia.w	r1!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 8002d48:	e8a0 1ff8 	stmia.w	r0!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 8002d4c:	e8b1 1ff8 	ldmia.w	r1!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 8002d50:	e8a0 1ff8 	stmia.w	r0!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 8002d54:	e8b1 1ff8 	ldmia.w	r1!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 8002d58:	e8a0 1ff8 	stmia.w	r0!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 8002d5c:	f5a2 72b4 	sub.w	r2, r2, #360	; 0x168
 8002d60:	e7d5      	b.n	8002d0e <Copy_32_1>

08002d62 <Copy_32_2>:
 8002d62:	2a28      	cmp	r2, #40	; 0x28
 8002d64:	d306      	bcc.n	8002d74 <Copy_32_3>
 8002d66:	e8b1 1ff8 	ldmia.w	r1!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 8002d6a:	e8a0 1ff8 	stmia.w	r0!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 8002d6e:	f1a2 0228 	sub.w	r2, r2, #40	; 0x28
 8002d72:	e7f6      	b.n	8002d62 <Copy_32_2>

08002d74 <Copy_32_3>:
 8002d74:	2a04      	cmp	r2, #4
 8002d76:	d306      	bcc.n	8002d86 <Copy_16_1>
 8002d78:	f851 3b04 	ldr.w	r3, [r1], #4
 8002d7c:	f840 3b04 	str.w	r3, [r0], #4
 8002d80:	f1a2 0204 	sub.w	r2, r2, #4
 8002d84:	e7f6      	b.n	8002d74 <Copy_32_3>

08002d86 <Copy_16_1>:
 8002d86:	2a20      	cmp	r2, #32
 8002d88:	d342      	bcc.n	8002e10 <Copy_16_2>
 8002d8a:	f831 3b02 	ldrh.w	r3, [r1], #2
 8002d8e:	f820 3b02 	strh.w	r3, [r0], #2
 8002d92:	f831 3b02 	ldrh.w	r3, [r1], #2
 8002d96:	f820 3b02 	strh.w	r3, [r0], #2
 8002d9a:	f831 3b02 	ldrh.w	r3, [r1], #2
 8002d9e:	f820 3b02 	strh.w	r3, [r0], #2
 8002da2:	f831 3b02 	ldrh.w	r3, [r1], #2
 8002da6:	f820 3b02 	strh.w	r3, [r0], #2
 8002daa:	f831 3b02 	ldrh.w	r3, [r1], #2
 8002dae:	f820 3b02 	strh.w	r3, [r0], #2
 8002db2:	f831 3b02 	ldrh.w	r3, [r1], #2
 8002db6:	f820 3b02 	strh.w	r3, [r0], #2
 8002dba:	f831 3b02 	ldrh.w	r3, [r1], #2
 8002dbe:	f820 3b02 	strh.w	r3, [r0], #2
 8002dc2:	f831 3b02 	ldrh.w	r3, [r1], #2
 8002dc6:	f820 3b02 	strh.w	r3, [r0], #2
 8002dca:	f831 3b02 	ldrh.w	r3, [r1], #2
 8002dce:	f820 3b02 	strh.w	r3, [r0], #2
 8002dd2:	f831 3b02 	ldrh.w	r3, [r1], #2
 8002dd6:	f820 3b02 	strh.w	r3, [r0], #2
 8002dda:	f831 3b02 	ldrh.w	r3, [r1], #2
 8002dde:	f820 3b02 	strh.w	r3, [r0], #2
 8002de2:	f831 3b02 	ldrh.w	r3, [r1], #2
 8002de6:	f820 3b02 	strh.w	r3, [r0], #2
 8002dea:	f831 3b02 	ldrh.w	r3, [r1], #2
 8002dee:	f820 3b02 	strh.w	r3, [r0], #2
 8002df2:	f831 3b02 	ldrh.w	r3, [r1], #2
 8002df6:	f820 3b02 	strh.w	r3, [r0], #2
 8002dfa:	f831 3b02 	ldrh.w	r3, [r1], #2
 8002dfe:	f820 3b02 	strh.w	r3, [r0], #2
 8002e02:	f831 3b02 	ldrh.w	r3, [r1], #2
 8002e06:	f820 3b02 	strh.w	r3, [r0], #2
 8002e0a:	f1a2 0220 	sub.w	r2, r2, #32
 8002e0e:	e7ba      	b.n	8002d86 <Copy_16_1>

08002e10 <Copy_16_2>:
 8002e10:	2a02      	cmp	r2, #2
 8002e12:	d306      	bcc.n	8002e22 <Copy_08_1>
 8002e14:	f831 3b02 	ldrh.w	r3, [r1], #2
 8002e18:	f820 3b02 	strh.w	r3, [r0], #2
 8002e1c:	f1a2 0202 	sub.w	r2, r2, #2
 8002e20:	e7f6      	b.n	8002e10 <Copy_16_2>

08002e22 <Copy_08_1>:
 8002e22:	2a10      	cmp	r2, #16
 8002e24:	d342      	bcc.n	8002eac <Copy_08_2>
 8002e26:	f811 3b01 	ldrb.w	r3, [r1], #1
 8002e2a:	f800 3b01 	strb.w	r3, [r0], #1
 8002e2e:	f811 3b01 	ldrb.w	r3, [r1], #1
 8002e32:	f800 3b01 	strb.w	r3, [r0], #1
 8002e36:	f811 3b01 	ldrb.w	r3, [r1], #1
 8002e3a:	f800 3b01 	strb.w	r3, [r0], #1
 8002e3e:	f811 3b01 	ldrb.w	r3, [r1], #1
 8002e42:	f800 3b01 	strb.w	r3, [r0], #1
 8002e46:	f811 3b01 	ldrb.w	r3, [r1], #1
 8002e4a:	f800 3b01 	strb.w	r3, [r0], #1
 8002e4e:	f811 3b01 	ldrb.w	r3, [r1], #1
 8002e52:	f800 3b01 	strb.w	r3, [r0], #1
 8002e56:	f811 3b01 	ldrb.w	r3, [r1], #1
 8002e5a:	f800 3b01 	strb.w	r3, [r0], #1
 8002e5e:	f811 3b01 	ldrb.w	r3, [r1], #1
 8002e62:	f800 3b01 	strb.w	r3, [r0], #1
 8002e66:	f811 3b01 	ldrb.w	r3, [r1], #1
 8002e6a:	f800 3b01 	strb.w	r3, [r0], #1
 8002e6e:	f811 3b01 	ldrb.w	r3, [r1], #1
 8002e72:	f800 3b01 	strb.w	r3, [r0], #1
 8002e76:	f811 3b01 	ldrb.w	r3, [r1], #1
 8002e7a:	f800 3b01 	strb.w	r3, [r0], #1
 8002e7e:	f811 3b01 	ldrb.w	r3, [r1], #1
 8002e82:	f800 3b01 	strb.w	r3, [r0], #1
 8002e86:	f811 3b01 	ldrb.w	r3, [r1], #1
 8002e8a:	f800 3b01 	strb.w	r3, [r0], #1
 8002e8e:	f811 3b01 	ldrb.w	r3, [r1], #1
 8002e92:	f800 3b01 	strb.w	r3, [r0], #1
 8002e96:	f811 3b01 	ldrb.w	r3, [r1], #1
 8002e9a:	f800 3b01 	strb.w	r3, [r0], #1
 8002e9e:	f811 3b01 	ldrb.w	r3, [r1], #1
 8002ea2:	f800 3b01 	strb.w	r3, [r0], #1
 8002ea6:	f1a2 0210 	sub.w	r2, r2, #16
 8002eaa:	e7ba      	b.n	8002e22 <Copy_08_1>

08002eac <Copy_08_2>:
 8002eac:	2a01      	cmp	r2, #1
 8002eae:	d306      	bcc.n	8002ebe <Mem_Copy_END>
 8002eb0:	f811 3b01 	ldrb.w	r3, [r1], #1
 8002eb4:	f800 3b01 	strb.w	r3, [r0], #1
 8002eb8:	f1a2 0201 	sub.w	r2, r2, #1
 8002ebc:	e7f6      	b.n	8002eac <Copy_08_2>

08002ebe <Mem_Copy_END>:
 8002ebe:	e8bd 1ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
 8002ec2:	4770      	bx	lr

08002ec4 <Str_FmtNbr_Int32>:
                                     CPU_BOOLEAN   nbr_neg,
                                     CPU_CHAR      lead_char,
                                     CPU_BOOLEAN   lower_case,
                                     CPU_BOOLEAN   nul,
                                     CPU_CHAR     *pstr)
{
 8002ec4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002ec8:	b085      	sub	sp, #20
 8002eca:	f8dd 8044 	ldr.w	r8, [sp, #68]	; 0x44
 8002ece:	f89d 9038 	ldrb.w	r9, [sp, #56]	; 0x38
 8002ed2:	f89d b03c 	ldrb.w	fp, [sp, #60]	; 0x3c
 8002ed6:	f89d 6040 	ldrb.w	r6, [sp, #64]	; 0x40
    CPU_BOOLEAN   nbr_neg_fmtd;


/*$PAGE*/
                                                                /* ---------------- VALIDATE FMT ARGS ----------------- */
    if (pstr == (CPU_CHAR *)0) {                                /* Rtn NULL if str ptr NULL (see Note #6a).             */
 8002eda:	f1b8 0f00 	cmp.w	r8, #0
 8002ede:	f000 80b8 	beq.w	8003052 <Str_FmtNbr_Int32+0x18e>
 8002ee2:	469a      	mov	sl, r3

    if (nbr_dig < 1) {                                          /* If nbr digs = 0, ...                                 */
        fmt_invalid = DEF_YES;                                  /* ... fmt invalid str (see Note #6b).                  */
    }
                                                                /* If invalid base, ...                                 */
    if ((nbr_base <  2u) ||
 8002ee4:	1e93      	subs	r3, r2, #2
 8002ee6:	2b22      	cmp	r3, #34	; 0x22
 8002ee8:	4617      	mov	r7, r2
 8002eea:	4604      	mov	r4, r0
 8002eec:	d92c      	bls.n	8002f48 <Str_FmtNbr_Int32+0x84>
        (nbr_base > 36u)) {
        fmt_invalid = DEF_YES;                                  /* ... fmt invalid str (see Note #6d).                  */
    }

    if (lead_char != (CPU_CHAR)'\0') {
 8002eee:	f1b9 0f00 	cmp.w	r9, #0
 8002ef2:	d157      	bne.n	8002fa4 <Str_FmtNbr_Int32+0xe0>

            if (nbr_lead_char > 0) {                            /* If lead chars to fmt, ...                            */
                lead_char_0 = (lead_char == '0')                /* ... chk if lead char a '0' dig (see Note #3a2B).     */
                            ?  DEF_YES : DEF_NO;
            } else {
                lead_char_0 =  DEF_NO;
 8002ef4:	2201      	movs	r2, #1
    }


/*$PAGE*/
                                                                /* ------------------- FMT NBR STR -------------------- */
    pstr_fmt += nbr_dig_fmtd;                                   /* Start fmt @ least-sig dig.                           */
 8002ef6:	eb08 0301 	add.w	r3, r8, r1

    if (nul != DEF_NO) {                                        /* If NOT DISABLED, append NULL char (see Note #4).     */
 8002efa:	b116      	cbz	r6, 8002f02 <Str_FmtNbr_Int32+0x3e>
       *pstr_fmt = (CPU_CHAR)'\0';
 8002efc:	2000      	movs	r0, #0
 8002efe:	f808 0001 	strb.w	r0, [r8, r1]
    }
    pstr_fmt--;
 8002f02:	1e5e      	subs	r6, r3, #1


    for (i = 0u; i < nbr_dig_fmtd; i++) {                       /* Fmt str for desired nbr digs :                       */
 8002f04:	b1c9      	cbz	r1, 8002f3a <Str_FmtNbr_Int32+0x76>
 8002f06:	2000      	movs	r0, #0
                nbr_fmt /= nbr_base;                            /* Shift to next more-sig dig.                          */

            } else if ((nbr_neg      == DEF_YES)  &&            /* ... else if nbr neg             AND          ...     */
                     (((lead_char_0  == DEF_NO )  &&            /* ... lead char NOT a '0' dig                  ...     */
                       (nbr_neg_fmtd == DEF_NO )) ||            /* ... but neg sign NOT yet fmt'd  OR           ...     */
                      ((lead_char_0  != DEF_NO )  &&            /* ... lead char is  a '0' dig                  ...     */
 8002f08:	46ce      	mov	lr, r9
       *pstr_fmt = (CPU_CHAR)'\0';
    }
    pstr_fmt--;


    for (i = 0u; i < nbr_dig_fmtd; i++) {                       /* Fmt str for desired nbr digs :                       */
 8002f0a:	4604      	mov	r4, r0
                nbr_fmt /= nbr_base;                            /* Shift to next more-sig dig.                          */

            } else if ((nbr_neg      == DEF_YES)  &&            /* ... else if nbr neg             AND          ...     */
                     (((lead_char_0  == DEF_NO )  &&            /* ... lead char NOT a '0' dig                  ...     */
                       (nbr_neg_fmtd == DEF_NO )) ||            /* ... but neg sign NOT yet fmt'd  OR           ...     */
                      ((lead_char_0  != DEF_NO )  &&            /* ... lead char is  a '0' dig                  ...     */
 8002f0c:	4681      	mov	r9, r0
            } else if (lead_char != (CPU_CHAR)'\0') {           /* ... else if avail,                           ...     */
               *pstr_fmt-- = lead_char;                         /* ... fmt lead char.                                   */
            }

        } else {                                                /* Else fmt '?' for invalid str (see Note #7).          */
           *pstr_fmt-- = '?';
 8002f0e:	233f      	movs	r3, #63	; 0x3f
                nbr_fmt /= nbr_base;                            /* Shift to next more-sig dig.                          */

            } else if ((nbr_neg      == DEF_YES)  &&            /* ... else if nbr neg             AND          ...     */
                     (((lead_char_0  == DEF_NO )  &&            /* ... lead char NOT a '0' dig                  ...     */
                       (nbr_neg_fmtd == DEF_NO )) ||            /* ... but neg sign NOT yet fmt'd  OR           ...     */
                      ((lead_char_0  != DEF_NO )  &&            /* ... lead char is  a '0' dig                  ...     */
 8002f10:	f101 3cff 	add.w	ip, r1, #4294967295
 8002f14:	f8cd e004 	str.w	lr, [sp, #4]
    }
    pstr_fmt--;


    for (i = 0u; i < nbr_dig_fmtd; i++) {                       /* Fmt str for desired nbr digs :                       */
        if (fmt_invalid == DEF_NO) {
 8002f18:	2a00      	cmp	r2, #0
 8002f1a:	d164      	bne.n	8002fe6 <Str_FmtNbr_Int32+0x122>
            if ((nbr_fmt > 0) ||                                /* If fmt nbr > 0                               ...     */
 8002f1c:	2d00      	cmp	r5, #0
 8002f1e:	d165      	bne.n	8002fec <Str_FmtNbr_Int32+0x128>
 8002f20:	2c00      	cmp	r4, #0
 8002f22:	f000 80a1 	beq.w	8003068 <Str_FmtNbr_Int32+0x1a4>
                    }
                }

                nbr_fmt /= nbr_base;                            /* Shift to next more-sig dig.                          */

            } else if ((nbr_neg      == DEF_YES)  &&            /* ... else if nbr neg             AND          ...     */
 8002f26:	f1ba 0f01 	cmp.w	sl, #1
 8002f2a:	d074      	beq.n	8003016 <Str_FmtNbr_Int32+0x152>
                       (i == (nbr_dig_fmtd - 1u))))) {          /* ... & on most-sig dig to fmt,                ...     */

               *pstr_fmt--   = '-';                             /* ... prepend neg sign (see Note #3b);         ...     */
                nbr_neg_fmtd = DEF_YES;

            } else if (lead_char != (CPU_CHAR)'\0') {           /* ... else if avail,                           ...     */
 8002f2c:	9801      	ldr	r0, [sp, #4]
 8002f2e:	b108      	cbz	r0, 8002f34 <Str_FmtNbr_Int32+0x70>
               *pstr_fmt-- = lead_char;                         /* ... fmt lead char.                                   */
 8002f30:	7030      	strb	r0, [r6, #0]
 8002f32:	3e01      	subs	r6, #1
       *pstr_fmt = (CPU_CHAR)'\0';
    }
    pstr_fmt--;


    for (i = 0u; i < nbr_dig_fmtd; i++) {                       /* Fmt str for desired nbr digs :                       */
 8002f34:	3401      	adds	r4, #1
 8002f36:	42a1      	cmp	r1, r4
 8002f38:	d1ee      	bne.n	8002f18 <Str_FmtNbr_Int32+0x54>
           *pstr_fmt-- = '?';
        }
    }


    if (fmt_invalid != DEF_NO) {                                /* Rtn NULL for invalid str fmt (see Notes #6a - #6e).  */
 8002f3a:	2a00      	cmp	r2, #0
 8002f3c:	f040 8089 	bne.w	8003052 <Str_FmtNbr_Int32+0x18e>
 8002f40:	4640      	mov	r0, r8
        return ((CPU_CHAR *)0);
    }


    return (pstr);                                              /* Rtn ptr to fmt'd str (see Note #6f).                 */
}
 8002f42:	b005      	add	sp, #20
 8002f44:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                                                                /* ---------------- VALIDATE FMT ARGS ----------------- */
    if (pstr == (CPU_CHAR *)0) {                                /* Rtn NULL if str ptr NULL (see Note #6a).             */
        return ((CPU_CHAR *)0);
    }

    fmt_invalid = DEF_NO;
 8002f48:	fab1 f281 	clz	r2, r1
 8002f4c:	0952      	lsrs	r2, r2, #5
    if ((nbr_base <  2u) ||
        (nbr_base > 36u)) {
        fmt_invalid = DEF_YES;                                  /* ... fmt invalid str (see Note #6d).                  */
    }

    if (lead_char != (CPU_CHAR)'\0') {
 8002f4e:	f1b9 0f00 	cmp.w	r9, #0
 8002f52:	d128      	bne.n	8002fa6 <Str_FmtNbr_Int32+0xe2>


                                                                /* ----------------- PREPARE NBR FMT ------------------ */
    pstr_fmt = pstr;

    if (fmt_invalid == DEF_NO) {
 8002f54:	2a00      	cmp	r2, #0
 8002f56:	d1cd      	bne.n	8002ef4 <Str_FmtNbr_Int32+0x30>
        nbr_fmt     = nbr;
        nbr_log     = nbr;
        nbr_dig_max = 1u;
        while (nbr_log >= nbr_base) {                           /* While nbr base digs avail, ...                       */
 8002f58:	42bc      	cmp	r4, r7
 8002f5a:	f0c0 8082 	bcc.w	8003062 <Str_FmtNbr_Int32+0x19e>
 8002f5e:	4620      	mov	r0, r4
 8002f60:	2301      	movs	r3, #1
            nbr_dig_max++;                                      /* ... calc max nbr digs.                               */
            nbr_log /= nbr_base;
 8002f62:	fbb0 f0f7 	udiv	r0, r0, r7
    if (fmt_invalid == DEF_NO) {
        nbr_fmt     = nbr;
        nbr_log     = nbr;
        nbr_dig_max = 1u;
        while (nbr_log >= nbr_base) {                           /* While nbr base digs avail, ...                       */
            nbr_dig_max++;                                      /* ... calc max nbr digs.                               */
 8002f66:	3301      	adds	r3, #1

    if (fmt_invalid == DEF_NO) {
        nbr_fmt     = nbr;
        nbr_log     = nbr;
        nbr_dig_max = 1u;
        while (nbr_log >= nbr_base) {                           /* While nbr base digs avail, ...                       */
 8002f68:	42b8      	cmp	r0, r7
            nbr_dig_max++;                                      /* ... calc max nbr digs.                               */
 8002f6a:	b2db      	uxtb	r3, r3

    if (fmt_invalid == DEF_NO) {
        nbr_fmt     = nbr;
        nbr_log     = nbr;
        nbr_dig_max = 1u;
        while (nbr_log >= nbr_base) {                           /* While nbr base digs avail, ...                       */
 8002f6c:	d2f9      	bcs.n	8002f62 <Str_FmtNbr_Int32+0x9e>
 8002f6e:	461d      	mov	r5, r3
            nbr_dig_max++;                                      /* ... calc max nbr digs.                               */
            nbr_log /= nbr_base;
        }

        nbr_neg_sign = (nbr_neg == DEF_YES) ? 1u : 0u;
 8002f70:	f1aa 0001 	sub.w	r0, sl, #1
 8002f74:	fab0 f080 	clz	r0, r0
 8002f78:	0940      	lsrs	r0, r0, #5
        if (nbr_dig >= (nbr_dig_max + nbr_neg_sign)) {          /* If req'd nbr digs >= (max nbr digs + neg sign), ...  */
 8002f7a:	4405      	add	r5, r0
 8002f7c:	42a9      	cmp	r1, r5
 8002f7e:	db60      	blt.n	8003042 <Str_FmtNbr_Int32+0x17e>
            nbr_neg_fmtd = DEF_NO;
            nbr_dig_min  = DEF_MIN(nbr_dig_max, nbr_dig);
 8002f80:	428b      	cmp	r3, r1
 8002f82:	bf28      	it	cs
 8002f84:	460b      	movcs	r3, r1
                                                                /* ... calc nbr digs to fmt & nbr lead chars.           */
            if (lead_char != (CPU_CHAR)'\0') {
 8002f86:	f1b9 0f00 	cmp.w	r9, #0
 8002f8a:	d05c      	beq.n	8003046 <Str_FmtNbr_Int32+0x182>
            } else {
                nbr_dig_fmtd  = nbr_dig_min + nbr_neg_sign;
                nbr_lead_char = 0u;
            }

            if (nbr_lead_char > 0) {                            /* If lead chars to fmt, ...                            */
 8002f8c:	1acb      	subs	r3, r1, r3
 8002f8e:	b2db      	uxtb	r3, r3
 8002f90:	4283      	cmp	r3, r0
 8002f92:	d06c      	beq.n	800306e <Str_FmtNbr_Int32+0x1aa>
                lead_char_0 = (lead_char == '0')                /* ... chk if lead char a '0' dig (see Note #3a2B).     */
 8002f94:	f1a9 0330 	sub.w	r3, r9, #48	; 0x30
 8002f98:	fab3 f383 	clz	r3, r3
 8002f9c:	095b      	lsrs	r3, r3, #5
 8002f9e:	9302      	str	r3, [sp, #8]
                            ?  DEF_YES : DEF_NO;
            } else {
                lead_char_0 =  DEF_NO;
 8002fa0:	4625      	mov	r5, r4
 8002fa2:	e7a8      	b.n	8002ef6 <Str_FmtNbr_Int32+0x32>
        fmt_invalid = DEF_YES;                                  /* ... fmt invalid str (see Note #6b).                  */
    }
                                                                /* If invalid base, ...                                 */
    if ((nbr_base <  2u) ||
        (nbr_base > 36u)) {
        fmt_invalid = DEF_YES;                                  /* ... fmt invalid str (see Note #6d).                  */
 8002fa4:	2201      	movs	r2, #1
    }

    if (lead_char != (CPU_CHAR)'\0') {
        print_char =  ASCII_IsPrint(lead_char);
 8002fa6:	4648      	mov	r0, r9
 8002fa8:	9103      	str	r1, [sp, #12]
 8002faa:	9201      	str	r2, [sp, #4]
 8002fac:	f00c fbb4 	bl	800f718 <ASCII_IsPrint>
        if (print_char != DEF_YES) {                            /* If lead char non-printable (see Note #3a1), ...      */
 8002fb0:	2801      	cmp	r0, #1
 8002fb2:	9a01      	ldr	r2, [sp, #4]
 8002fb4:	9903      	ldr	r1, [sp, #12]
 8002fb6:	d19d      	bne.n	8002ef4 <Str_FmtNbr_Int32+0x30>
            fmt_invalid = DEF_YES;                              /* ... fmt invalid str        (see Note #6e).           */

        } else if (lead_char != '0') {                          /* Chk lead char for non-0 nbr base dig.                */
 8002fb8:	f1b9 0f30 	cmp.w	r9, #48	; 0x30
 8002fbc:	d0ca      	beq.n	8002f54 <Str_FmtNbr_Int32+0x90>
            lead_char_delta_0 = (CPU_INT08U)(lead_char - '0');
            if (lower_case != DEF_YES) {
 8002fbe:	f1bb 0f01 	cmp.w	fp, #1
                lead_char_delta_a = (CPU_INT08U)(lead_char - 'A');
 8002fc2:	bf14      	ite	ne
 8002fc4:	f1a9 0041 	subne.w	r0, r9, #65	; 0x41
            } else {
                lead_char_delta_a = (CPU_INT08U)(lead_char - 'a');
 8002fc8:	f1a9 0061 	subeq.w	r0, r9, #97	; 0x61
        print_char =  ASCII_IsPrint(lead_char);
        if (print_char != DEF_YES) {                            /* If lead char non-printable (see Note #3a1), ...      */
            fmt_invalid = DEF_YES;                              /* ... fmt invalid str        (see Note #6e).           */

        } else if (lead_char != '0') {                          /* Chk lead char for non-0 nbr base dig.                */
            lead_char_delta_0 = (CPU_INT08U)(lead_char - '0');
 8002fcc:	f1a9 0330 	sub.w	r3, r9, #48	; 0x30
                lead_char_delta_a = (CPU_INT08U)(lead_char - 'A');
            } else {
                lead_char_delta_a = (CPU_INT08U)(lead_char - 'a');
            }

            lead_char_dig = (((nbr_base <= 10u) &&  (lead_char_delta_0 <  nbr_base))      ||
 8002fd0:	2f0a      	cmp	r7, #10
        print_char =  ASCII_IsPrint(lead_char);
        if (print_char != DEF_YES) {                            /* If lead char non-printable (see Note #3a1), ...      */
            fmt_invalid = DEF_YES;                              /* ... fmt invalid str        (see Note #6e).           */

        } else if (lead_char != '0') {                          /* Chk lead char for non-0 nbr base dig.                */
            lead_char_delta_0 = (CPU_INT08U)(lead_char - '0');
 8002fd2:	b2db      	uxtb	r3, r3
            if (lower_case != DEF_YES) {
                lead_char_delta_a = (CPU_INT08U)(lead_char - 'A');
            } else {
                lead_char_delta_a = (CPU_INT08U)(lead_char - 'a');
 8002fd4:	b2c0      	uxtb	r0, r0
            }

            lead_char_dig = (((nbr_base <= 10u) &&  (lead_char_delta_0 <  nbr_base))      ||
 8002fd6:	d940      	bls.n	800305a <Str_FmtNbr_Int32+0x196>
                             ((nbr_base >  10u) && ((lead_char_delta_0 <             10u) ||
 8002fd8:	2b09      	cmp	r3, #9
 8002fda:	d98b      	bls.n	8002ef4 <Str_FmtNbr_Int32+0x30>
 8002fdc:	f1a7 030a 	sub.w	r3, r7, #10
 8002fe0:	4298      	cmp	r0, r3
 8002fe2:	d387      	bcc.n	8002ef4 <Str_FmtNbr_Int32+0x30>
 8002fe4:	e7b6      	b.n	8002f54 <Str_FmtNbr_Int32+0x90>
            } else if (lead_char != (CPU_CHAR)'\0') {           /* ... else if avail,                           ...     */
               *pstr_fmt-- = lead_char;                         /* ... fmt lead char.                                   */
            }

        } else {                                                /* Else fmt '?' for invalid str (see Note #7).          */
           *pstr_fmt-- = '?';
 8002fe6:	7033      	strb	r3, [r6, #0]
 8002fe8:	3e01      	subs	r6, #1
 8002fea:	e7a3      	b.n	8002f34 <Str_FmtNbr_Int32+0x70>
    for (i = 0u; i < nbr_dig_fmtd; i++) {                       /* Fmt str for desired nbr digs :                       */
        if (fmt_invalid == DEF_NO) {
            if ((nbr_fmt > 0) ||                                /* If fmt nbr > 0                               ...     */
                (i == 0u)) {                                    /* ... OR on one's  dig to fmt (see Note #3c1), ...     */
                                                                /* ... calc & fmt dig val;                      ...     */
                dig_val = (CPU_INT08U)(nbr_fmt % nbr_base);
 8002fec:	fbb5 fef7 	udiv	lr, r5, r7
 8002ff0:	fb07 551e 	mls	r5, r7, lr, r5
 8002ff4:	b2ed      	uxtb	r5, r5
                if (dig_val < 10u) {
 8002ff6:	2d09      	cmp	r5, #9
 8002ff8:	d804      	bhi.n	8003004 <Str_FmtNbr_Int32+0x140>
                   *pstr_fmt-- = (CPU_CHAR)(dig_val + '0');
 8002ffa:	3530      	adds	r5, #48	; 0x30
 8002ffc:	7035      	strb	r5, [r6, #0]
 8002ffe:	3e01      	subs	r6, #1
                    } else {
                       *pstr_fmt--  = (CPU_CHAR)((dig_val - 10u) + 'a');
                    }
                }

                nbr_fmt /= nbr_base;                            /* Shift to next more-sig dig.                          */
 8003000:	4675      	mov	r5, lr
 8003002:	e797      	b.n	8002f34 <Str_FmtNbr_Int32+0x70>
                                                                /* ... calc & fmt dig val;                      ...     */
                dig_val = (CPU_INT08U)(nbr_fmt % nbr_base);
                if (dig_val < 10u) {
                   *pstr_fmt-- = (CPU_CHAR)(dig_val + '0');
                } else {
                    if (lower_case !=  DEF_YES) {
 8003004:	f1bb 0f01 	cmp.w	fp, #1
                       *pstr_fmt--  = (CPU_CHAR)((dig_val - 10u) + 'A');
 8003008:	bf14      	ite	ne
 800300a:	3537      	addne	r5, #55	; 0x37
                    } else {
                       *pstr_fmt--  = (CPU_CHAR)((dig_val - 10u) + 'a');
 800300c:	3557      	addeq	r5, #87	; 0x57
 800300e:	7035      	strb	r5, [r6, #0]
 8003010:	3e01      	subs	r6, #1
                    }
                }

                nbr_fmt /= nbr_base;                            /* Shift to next more-sig dig.                          */
 8003012:	4675      	mov	r5, lr
 8003014:	e78e      	b.n	8002f34 <Str_FmtNbr_Int32+0x70>

            } else if ((nbr_neg      == DEF_YES)  &&            /* ... else if nbr neg             AND          ...     */
 8003016:	9802      	ldr	r0, [sp, #8]
 8003018:	b140      	cbz	r0, 800302c <Str_FmtNbr_Int32+0x168>
                     (((lead_char_0  == DEF_NO )  &&            /* ... lead char NOT a '0' dig                  ...     */
                       (nbr_neg_fmtd == DEF_NO )) ||            /* ... but neg sign NOT yet fmt'd  OR           ...     */
                      ((lead_char_0  != DEF_NO )  &&            /* ... lead char is  a '0' dig                  ...     */
 800301a:	4564      	cmp	r4, ip
 800301c:	d186      	bne.n	8002f2c <Str_FmtNbr_Int32+0x68>
                       (i == (nbr_dig_fmtd - 1u))))) {          /* ... & on most-sig dig to fmt,                ...     */

               *pstr_fmt--   = '-';                             /* ... prepend neg sign (see Note #3b);         ...     */
 800301e:	f04f 002d 	mov.w	r0, #45	; 0x2d
                nbr_neg_fmtd = DEF_YES;
 8003022:	f04f 0901 	mov.w	r9, #1
                     (((lead_char_0  == DEF_NO )  &&            /* ... lead char NOT a '0' dig                  ...     */
                       (nbr_neg_fmtd == DEF_NO )) ||            /* ... but neg sign NOT yet fmt'd  OR           ...     */
                      ((lead_char_0  != DEF_NO )  &&            /* ... lead char is  a '0' dig                  ...     */
                       (i == (nbr_dig_fmtd - 1u))))) {          /* ... & on most-sig dig to fmt,                ...     */

               *pstr_fmt--   = '-';                             /* ... prepend neg sign (see Note #3b);         ...     */
 8003026:	7030      	strb	r0, [r6, #0]
 8003028:	3e01      	subs	r6, #1
                nbr_neg_fmtd = DEF_YES;
 800302a:	e783      	b.n	8002f34 <Str_FmtNbr_Int32+0x70>
                }

                nbr_fmt /= nbr_base;                            /* Shift to next more-sig dig.                          */

            } else if ((nbr_neg      == DEF_YES)  &&            /* ... else if nbr neg             AND          ...     */
                     (((lead_char_0  == DEF_NO )  &&            /* ... lead char NOT a '0' dig                  ...     */
 800302c:	f1b9 0f00 	cmp.w	r9, #0
 8003030:	f47f af7c 	bne.w	8002f2c <Str_FmtNbr_Int32+0x68>
                       (nbr_neg_fmtd == DEF_NO )) ||            /* ... but neg sign NOT yet fmt'd  OR           ...     */
                      ((lead_char_0  != DEF_NO )  &&            /* ... lead char is  a '0' dig                  ...     */
                       (i == (nbr_dig_fmtd - 1u))))) {          /* ... & on most-sig dig to fmt,                ...     */

               *pstr_fmt--   = '-';                             /* ... prepend neg sign (see Note #3b);         ...     */
 8003034:	f04f 002d 	mov.w	r0, #45	; 0x2d
                nbr_neg_fmtd = DEF_YES;
 8003038:	f04f 0901 	mov.w	r9, #1
                     (((lead_char_0  == DEF_NO )  &&            /* ... lead char NOT a '0' dig                  ...     */
                       (nbr_neg_fmtd == DEF_NO )) ||            /* ... but neg sign NOT yet fmt'd  OR           ...     */
                      ((lead_char_0  != DEF_NO )  &&            /* ... lead char is  a '0' dig                  ...     */
                       (i == (nbr_dig_fmtd - 1u))))) {          /* ... & on most-sig dig to fmt,                ...     */

               *pstr_fmt--   = '-';                             /* ... prepend neg sign (see Note #3b);         ...     */
 800303c:	7030      	strb	r0, [r6, #0]
 800303e:	3e01      	subs	r6, #1
 8003040:	e778      	b.n	8002f34 <Str_FmtNbr_Int32+0x70>
 8003042:	4625      	mov	r5, r4
 8003044:	e756      	b.n	8002ef4 <Str_FmtNbr_Int32+0x30>
            if (lead_char != (CPU_CHAR)'\0') {
                nbr_dig_fmtd  = nbr_dig;
                nbr_lead_char = nbr_dig     -
                                nbr_dig_min - nbr_neg_sign;
            } else {
                nbr_dig_fmtd  = nbr_dig_min + nbr_neg_sign;
 8003046:	4403      	add	r3, r0
 8003048:	b2d9      	uxtb	r1, r3

            if (nbr_lead_char > 0) {                            /* If lead chars to fmt, ...                            */
                lead_char_0 = (lead_char == '0')                /* ... chk if lead char a '0' dig (see Note #3a2B).     */
                            ?  DEF_YES : DEF_NO;
            } else {
                lead_char_0 =  DEF_NO;
 800304a:	f8cd 9008 	str.w	r9, [sp, #8]
 800304e:	4625      	mov	r5, r4
 8003050:	e751      	b.n	8002ef6 <Str_FmtNbr_Int32+0x32>


/*$PAGE*/
                                                                /* ---------------- VALIDATE FMT ARGS ----------------- */
    if (pstr == (CPU_CHAR *)0) {                                /* Rtn NULL if str ptr NULL (see Note #6a).             */
        return ((CPU_CHAR *)0);
 8003052:	2000      	movs	r0, #0
        return ((CPU_CHAR *)0);
    }


    return (pstr);                                              /* Rtn ptr to fmt'd str (see Note #6f).                 */
}
 8003054:	b005      	add	sp, #20
 8003056:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                lead_char_delta_a = (CPU_INT08U)(lead_char - 'A');
            } else {
                lead_char_delta_a = (CPU_INT08U)(lead_char - 'a');
            }

            lead_char_dig = (((nbr_base <= 10u) &&  (lead_char_delta_0 <  nbr_base))      ||
 800305a:	429f      	cmp	r7, r3
 800305c:	f63f af4a 	bhi.w	8002ef4 <Str_FmtNbr_Int32+0x30>
 8003060:	e778      	b.n	8002f54 <Str_FmtNbr_Int32+0x90>

    if (fmt_invalid == DEF_NO) {
        nbr_fmt     = nbr;
        nbr_log     = nbr;
        nbr_dig_max = 1u;
        while (nbr_log >= nbr_base) {                           /* While nbr base digs avail, ...                       */
 8003062:	2501      	movs	r5, #1
 8003064:	462b      	mov	r3, r5
 8003066:	e783      	b.n	8002f70 <Str_FmtNbr_Int32+0xac>
    for (i = 0u; i < nbr_dig_fmtd; i++) {                       /* Fmt str for desired nbr digs :                       */
        if (fmt_invalid == DEF_NO) {
            if ((nbr_fmt > 0) ||                                /* If fmt nbr > 0                               ...     */
                (i == 0u)) {                                    /* ... OR on one's  dig to fmt (see Note #3c1), ...     */
                                                                /* ... calc & fmt dig val;                      ...     */
                dig_val = (CPU_INT08U)(nbr_fmt % nbr_base);
 8003068:	4625      	mov	r5, r4
 800306a:	46a6      	mov	lr, r4
 800306c:	e7c5      	b.n	8002ffa <Str_FmtNbr_Int32+0x136>

            if (nbr_lead_char > 0) {                            /* If lead chars to fmt, ...                            */
                lead_char_0 = (lead_char == '0')                /* ... chk if lead char a '0' dig (see Note #3a2B).     */
                            ?  DEF_YES : DEF_NO;
            } else {
                lead_char_0 =  DEF_NO;
 800306e:	2300      	movs	r3, #0
 8003070:	9302      	str	r3, [sp, #8]
 8003072:	4625      	mov	r5, r4
 8003074:	e73f      	b.n	8002ef6 <Str_FmtNbr_Int32+0x32>
 8003076:	bf00      	nop

08003078 <Str_ParseNbr_Int32>:
static  CPU_INT32U  Str_ParseNbr_Int32 (const  CPU_CHAR      *pstr,
                                               CPU_CHAR     **pstr_next,
                                               CPU_INT08U     nbr_base,
                                               CPU_BOOLEAN    nbr_signed,
                                               CPU_BOOLEAN   *pnbr_neg)
{
 8003078:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800307c:	4681      	mov	r9, r0
 800307e:	b085      	sub	sp, #20
 8003080:	4617      	mov	r7, r2
 8003082:	461d      	mov	r5, r3
           CPU_BOOLEAN   neg;
           CPU_BOOLEAN   ovf;
           CPU_BOOLEAN   done;

                                                                /* --------------- VALIDATE PARSE ARGS ---------------- */
    if (pstr_next == (CPU_CHAR **) 0) {                         /* If NOT avail, ...                                    */
 8003084:	2900      	cmp	r1, #0
 8003086:	f000 8085 	beq.w	8003194 <Str_ParseNbr_Int32+0x11c>
 800308a:	468a      	mov	sl, r1
        pstr_next  = (CPU_CHAR **)&pstr_parse_unused;           /* ... re-cfg NULL rtn ptr to unused local var.         */
       (void)&pstr_parse_unused;                                /* Prevent possible 'variable unused' warning.          */
    }
   *pstr_next = (CPU_CHAR *)pstr;                               /* Init rtn str for err (see Note #5).                  */

    if (pnbr_neg == (CPU_BOOLEAN *) 0) {                        /* If NOT avail, ...                                    */
 800308c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
                                                                /* --------------- VALIDATE PARSE ARGS ---------------- */
    if (pstr_next == (CPU_CHAR **) 0) {                         /* If NOT avail, ...                                    */
        pstr_next  = (CPU_CHAR **)&pstr_parse_unused;           /* ... re-cfg NULL rtn ptr to unused local var.         */
       (void)&pstr_parse_unused;                                /* Prevent possible 'variable unused' warning.          */
    }
   *pstr_next = (CPU_CHAR *)pstr;                               /* Init rtn str for err (see Note #5).                  */
 800308e:	f8ca 9000 	str.w	r9, [sl]

    if (pnbr_neg == (CPU_BOOLEAN *) 0) {                        /* If NOT avail, ...                                    */
 8003092:	2b00      	cmp	r3, #0
 8003094:	f000 8086 	beq.w	80031a4 <Str_ParseNbr_Int32+0x12c>
        pnbr_neg  = (CPU_BOOLEAN *)&nbr_neg_unused;             /* ... re-cfg NULL rtn ptr to unused local var.         */
       (void)&nbr_neg_unused;                                   /* Prevent possible 'variable unused' warning.          */
    }
   *pnbr_neg = DEF_NO;                                          /* Init nbr neg for err (see Note #5).                  */
 8003098:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800309a:	2000      	movs	r0, #0
 800309c:	7018      	strb	r0, [r3, #0]


    if (pstr == (CPU_CHAR *)0) {                                /* Rtn zero if str ptr NULL (see Note #4b1).            */
 800309e:	f1b9 0f00 	cmp.w	r9, #0
 80030a2:	f000 8089 	beq.w	80031b8 <Str_ParseNbr_Int32+0x140>
        return (0u);
    }
                                                                /* Rtn zero if invalid base (see Note #4a).             */
    if ((nbr_base == 1u) ||
 80030a6:	2f01      	cmp	r7, #1
 80030a8:	d001      	beq.n	80030ae <Str_ParseNbr_Int32+0x36>
 80030aa:	2f24      	cmp	r7, #36	; 0x24
 80030ac:	d902      	bls.n	80030b4 <Str_ParseNbr_Int32+0x3c>

   *pnbr_neg = neg;                                             /* Rtn neg nbr status.                                  */


    return (nbr);
}
 80030ae:	b005      	add	sp, #20
 80030b0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}


                                                                /* ------------- IGNORE PRECEDING CHAR(S) ------------- */
    pstr_parse = pstr;                                          /* Save ptr to init'l str for err (see Note #2a2A2).    */

    whitespace = ASCII_IsSpace(*pstr_parse);
 80030b4:	f899 0000 	ldrb.w	r0, [r9]
 80030b8:	f00c fb24 	bl	800f704 <ASCII_IsSpace>
    while (whitespace == DEF_YES) {                             /* Ignore initial white-space char(s) [see Note #2a1A]. */
 80030bc:	2801      	cmp	r0, #1
 80030be:	464e      	mov	r6, r9
 80030c0:	d105      	bne.n	80030ce <Str_ParseNbr_Int32+0x56>
        pstr_parse++;
        whitespace = ASCII_IsSpace(*pstr_parse);
 80030c2:	f816 0f01 	ldrb.w	r0, [r6, #1]!
 80030c6:	f00c fb1d 	bl	800f704 <ASCII_IsSpace>

                                                                /* ------------- IGNORE PRECEDING CHAR(S) ------------- */
    pstr_parse = pstr;                                          /* Save ptr to init'l str for err (see Note #2a2A2).    */

    whitespace = ASCII_IsSpace(*pstr_parse);
    while (whitespace == DEF_YES) {                             /* Ignore initial white-space char(s) [see Note #2a1A]. */
 80030ca:	2801      	cmp	r0, #1
 80030cc:	d0f9      	beq.n	80030c2 <Str_ParseNbr_Int32+0x4a>
        pstr_parse++;
        whitespace = ASCII_IsSpace(*pstr_parse);
    }

    switch (*pstr_parse) {
 80030ce:	7834      	ldrb	r4, [r6, #0]
 80030d0:	2c2b      	cmp	r4, #43	; 0x2b
 80030d2:	d010      	beq.n	80030f6 <Str_ParseNbr_Int32+0x7e>
 80030d4:	2c2d      	cmp	r4, #45	; 0x2d
 80030d6:	d173      	bne.n	80031c0 <Str_ParseNbr_Int32+0x148>
             neg = DEF_NO;
             break;


        case '-':                                               /* Validate neg sign (see Note #2a1B2a).                */
             if (nbr_signed == DEF_YES) {
 80030d8:	2d01      	cmp	r5, #1
 80030da:	f000 809c 	beq.w	8003216 <Str_ParseNbr_Int32+0x19e>

/*$PAGE*/
                                                                /* --------- IGNORE NBR BASE PRECEDING CHAR(S) -------- */
    pstr_parse_nbr = pstr_parse;                                /* Save ptr to str's nbr (see Note #2a1A1).             */

    switch (nbr_base) {
 80030de:	2f08      	cmp	r7, #8
 80030e0:	f000 80a6 	beq.w	8003230 <Str_ParseNbr_Int32+0x1b8>
 80030e4:	2f10      	cmp	r7, #16
 80030e6:	f000 8093 	beq.w	8003210 <Str_ParseNbr_Int32+0x198>

        case '-':                                               /* Validate neg sign (see Note #2a1B2a).                */
             if (nbr_signed == DEF_YES) {
                 pstr_parse++;
             }
             neg = DEF_YES;
 80030ea:	2301      	movs	r3, #1

/*$PAGE*/
                                                                /* --------- IGNORE NBR BASE PRECEDING CHAR(S) -------- */
    pstr_parse_nbr = pstr_parse;                                /* Save ptr to str's nbr (see Note #2a1A1).             */

    switch (nbr_base) {
 80030ec:	46b0      	mov	r8, r6

        case '-':                                               /* Validate neg sign (see Note #2a1B2a).                */
             if (nbr_signed == DEF_YES) {
                 pstr_parse++;
             }
             neg = DEF_YES;
 80030ee:	9301      	str	r3, [sp, #4]

/*$PAGE*/
                                                                /* --------- IGNORE NBR BASE PRECEDING CHAR(S) -------- */
    pstr_parse_nbr = pstr_parse;                                /* Save ptr to str's nbr (see Note #2a1A1).             */

    switch (nbr_base) {
 80030f0:	b967      	cbnz	r7, 800310c <Str_ParseNbr_Int32+0x94>
                           nbr_base =  8u;                      /* ... set nbr base =  8    (see Note #2a1B1a2).        */
                           break;
                  }

             } else {                                           /* For non-'0' prefix, ...                              */
                 nbr_base = 10u;                                /* ... set nbr base = 10    (see Note #2a1B1a1).        */
 80030f2:	270a      	movs	r7, #10
 80030f4:	e00a      	b.n	800310c <Str_ParseNbr_Int32+0x94>
    }

    switch (*pstr_parse) {
        case '+':                                               /* Ignore   pos sign (see Note #2a1B2).                 */
             pstr_parse++;
             neg = DEF_NO;
 80030f6:	2300      	movs	r3, #0
 80030f8:	7874      	ldrb	r4, [r6, #1]
 80030fa:	9301      	str	r3, [sp, #4]
        whitespace = ASCII_IsSpace(*pstr_parse);
    }

    switch (*pstr_parse) {
        case '+':                                               /* Ignore   pos sign (see Note #2a1B2).                 */
             pstr_parse++;
 80030fc:	3601      	adds	r6, #1

/*$PAGE*/
                                                                /* --------- IGNORE NBR BASE PRECEDING CHAR(S) -------- */
    pstr_parse_nbr = pstr_parse;                                /* Save ptr to str's nbr (see Note #2a1A1).             */

    switch (nbr_base) {
 80030fe:	2f08      	cmp	r7, #8
 8003100:	d066      	beq.n	80031d0 <Str_ParseNbr_Int32+0x158>
 8003102:	2f10      	cmp	r7, #16
 8003104:	d05f      	beq.n	80031c6 <Str_ParseNbr_Int32+0x14e>
 8003106:	2f00      	cmp	r7, #0
 8003108:	d067      	beq.n	80031da <Str_ParseNbr_Int32+0x162>
 800310a:	46b0      	mov	r8, r6


/*$PAGE*/
                                                                /* ------------------ PARSE INT STR ------------------- */
    nbr  = 0u;
    ovf  = DEF_NO;
 800310c:	f04f 0b00 	mov.w	fp, #0
    }


/*$PAGE*/
                                                                /* ------------------ PARSE INT STR ------------------- */
    nbr  = 0u;
 8003110:	465d      	mov	r5, fp
    ovf  = DEF_NO;
    done = DEF_NO;

    while (done == DEF_NO) {                                    /* Parse str for desired nbr base digs (see Note #2a2). */
        parse_char = (CPU_CHAR)*pstr_parse;
        nbr_alpha  =  ASCII_IsAlphaNum(parse_char);
 8003112:	4620      	mov	r0, r4
 8003114:	f00c faba 	bl	800f68c <ASCII_IsAlphaNum>
        if (nbr_alpha == DEF_YES) {                             /* If valid alpha num nbr dig avail, ...                */
 8003118:	2801      	cmp	r0, #1
 800311a:	d013      	beq.n	8003144 <Str_ParseNbr_Int32+0xcc>
            done = DEF_YES;
        }
    }

    if (ovf == DEF_YES) {                                       /* If nbr ovf'd, ...                                    */
        nbr  = DEF_INT_32U_MAX_VAL;                             /* ... rtn max int val (see Note #2a3A1).               */
 800311c:	f1bb 0f01 	cmp.w	fp, #1
       *pstr_next   = (CPU_CHAR *)pstr_parse;                   /* .. rtn   parse str's next char (see Note #2a2B2); .. */
    } else {
       *pstr_next   = (CPU_CHAR *)pstr;                         /* .. else rtn initial parse str  (see Note #2a2A2).    */
    }

   *pnbr_neg = neg;                                             /* Rtn neg nbr status.                                  */
 8003120:	9b0e      	ldr	r3, [sp, #56]	; 0x38
            done = DEF_YES;
        }
    }

    if (ovf == DEF_YES) {                                       /* If nbr ovf'd, ...                                    */
        nbr  = DEF_INT_32U_MAX_VAL;                             /* ... rtn max int val (see Note #2a3A1).               */
 8003122:	bf08      	it	eq
 8003124:	f04f 35ff 	moveq.w	r5, #4294967295
       *pstr_next   = (CPU_CHAR *)pstr_parse;                   /* .. rtn   parse str's next char (see Note #2a2B2); .. */
    } else {
       *pstr_next   = (CPU_CHAR *)pstr;                         /* .. else rtn initial parse str  (see Note #2a2A2).    */
    }

   *pnbr_neg = neg;                                             /* Rtn neg nbr status.                                  */
 8003128:	461a      	mov	r2, r3
        nbr  = DEF_INT_32U_MAX_VAL;                             /* ... rtn max int val (see Note #2a3A1).               */
    }


    if (pstr_parse !=             pstr_parse_nbr) {             /* If final parse str != init'l parse nbr str,       .. */
       *pstr_next   = (CPU_CHAR *)pstr_parse;                   /* .. rtn   parse str's next char (see Note #2a2B2); .. */
 800312a:	4546      	cmp	r6, r8
 800312c:	bf0c      	ite	eq
 800312e:	464e      	moveq	r6, r9
 8003130:	4646      	movne	r6, r8
    }

   *pnbr_neg = neg;                                             /* Rtn neg nbr status.                                  */


    return (nbr);
 8003132:	4628      	mov	r0, r5
       *pstr_next   = (CPU_CHAR *)pstr_parse;                   /* .. rtn   parse str's next char (see Note #2a2B2); .. */
    } else {
       *pstr_next   = (CPU_CHAR *)pstr;                         /* .. else rtn initial parse str  (see Note #2a2A2).    */
    }

   *pnbr_neg = neg;                                             /* Rtn neg nbr status.                                  */
 8003134:	f89d 3004 	ldrb.w	r3, [sp, #4]
        nbr  = DEF_INT_32U_MAX_VAL;                             /* ... rtn max int val (see Note #2a3A1).               */
    }


    if (pstr_parse !=             pstr_parse_nbr) {             /* If final parse str != init'l parse nbr str,       .. */
       *pstr_next   = (CPU_CHAR *)pstr_parse;                   /* .. rtn   parse str's next char (see Note #2a2B2); .. */
 8003138:	f8ca 6000 	str.w	r6, [sl]
    } else {
       *pstr_next   = (CPU_CHAR *)pstr;                         /* .. else rtn initial parse str  (see Note #2a2A2).    */
    }

   *pnbr_neg = neg;                                             /* Rtn neg nbr status.                                  */
 800313c:	7013      	strb	r3, [r2, #0]


    return (nbr);
}
 800313e:	b005      	add	sp, #20
 8003140:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    while (done == DEF_NO) {                                    /* Parse str for desired nbr base digs (see Note #2a2). */
        parse_char = (CPU_CHAR)*pstr_parse;
        nbr_alpha  =  ASCII_IsAlphaNum(parse_char);
        if (nbr_alpha == DEF_YES) {                             /* If valid alpha num nbr dig avail, ...                */
                                                                /* ... convert parse char into nbr dig.                 */
            nbr_dig = ASCII_IsDig(parse_char);
 8003144:	4620      	mov	r0, r4
 8003146:	f00c fabb 	bl	800f6c0 <ASCII_IsDig>
            if (nbr_dig == DEF_YES) {
 800314a:	2801      	cmp	r0, #1
 800314c:	d116      	bne.n	800317c <Str_ParseNbr_Int32+0x104>
                parse_dig = (CPU_INT08U)(parse_char - '0');
 800314e:	3c30      	subs	r4, #48	; 0x30
 8003150:	b2e4      	uxtb	r4, r4
                } else {
                    parse_dig = (CPU_INT08U)((parse_char - 'A') + 10u);
                }
            }

            if (parse_dig < nbr_base) {                         /* If parse char valid for nbr base ...                 */
 8003152:	42a7      	cmp	r7, r4
 8003154:	d9e2      	bls.n	800311c <Str_ParseNbr_Int32+0xa4>
                if (ovf == DEF_NO) {                            /* ... & nbr NOT yet ovf'd,         ...                 */
 8003156:	f1bb 0f00 	cmp.w	fp, #0
 800315a:	d118      	bne.n	800318e <Str_ParseNbr_Int32+0x116>
                    if (nbr <= Str_MultOvfThTbl_Int32U[nbr_base]) {
 800315c:	4b36      	ldr	r3, [pc, #216]	; (8003238 <Str_ParseNbr_Int32+0x1c0>)
 800315e:	f853 3027 	ldr.w	r3, [r3, r7, lsl #2]
 8003162:	42ab      	cmp	r3, r5
 8003164:	d313      	bcc.n	800318e <Str_ParseNbr_Int32+0x116>
                                                                /* ... merge parse char dig into nbr.                   */
                        nbr *= nbr_base;
                        nbr += parse_dig;
 8003166:	fb05 4507 	mla	r5, r5, r7, r4
                        if (nbr < parse_dig) {
                            ovf = DEF_YES;
 800316a:	42ac      	cmp	r4, r5
 800316c:	bf94      	ite	ls
 800316e:	f04f 0b00 	movls.w	fp, #0
 8003172:	f04f 0b01 	movhi.w	fp, #1
 8003176:	f818 4f01 	ldrb.w	r4, [r8, #1]!
 800317a:	e7ca      	b.n	8003112 <Str_ParseNbr_Int32+0x9a>
                                                                /* ... convert parse char into nbr dig.                 */
            nbr_dig = ASCII_IsDig(parse_char);
            if (nbr_dig == DEF_YES) {
                parse_dig = (CPU_INT08U)(parse_char - '0');
            } else {
                nbr_hex_lower = ASCII_IsLower(parse_char);
 800317c:	4620      	mov	r0, r4
 800317e:	f00c fa93 	bl	800f6a8 <ASCII_IsLower>
                if (nbr_hex_lower == DEF_YES) {
 8003182:	2801      	cmp	r0, #1
                    parse_dig = (CPU_INT08U)((parse_char - 'a') + 10u);
 8003184:	bf0c      	ite	eq
 8003186:	3c57      	subeq	r4, #87	; 0x57
                } else {
                    parse_dig = (CPU_INT08U)((parse_char - 'A') + 10u);
 8003188:	3c37      	subne	r4, #55	; 0x37
 800318a:	b2e4      	uxtb	r4, r4
 800318c:	e7e1      	b.n	8003152 <Str_ParseNbr_Int32+0xda>
                        nbr += parse_dig;
                        if (nbr < parse_dig) {
                            ovf = DEF_YES;
                        }
                    } else {
                        ovf = DEF_YES;
 800318e:	f04f 0b01 	mov.w	fp, #1
 8003192:	e7f0      	b.n	8003176 <Str_ParseNbr_Int32+0xfe>
        pstr_next  = (CPU_CHAR **)&pstr_parse_unused;           /* ... re-cfg NULL rtn ptr to unused local var.         */
       (void)&pstr_parse_unused;                                /* Prevent possible 'variable unused' warning.          */
    }
   *pstr_next = (CPU_CHAR *)pstr;                               /* Init rtn str for err (see Note #5).                  */

    if (pnbr_neg == (CPU_BOOLEAN *) 0) {                        /* If NOT avail, ...                                    */
 8003194:	9b0e      	ldr	r3, [sp, #56]	; 0x38
           CPU_BOOLEAN   ovf;
           CPU_BOOLEAN   done;

                                                                /* --------------- VALIDATE PARSE ARGS ---------------- */
    if (pstr_next == (CPU_CHAR **) 0) {                         /* If NOT avail, ...                                    */
        pstr_next  = (CPU_CHAR **)&pstr_parse_unused;           /* ... re-cfg NULL rtn ptr to unused local var.         */
 8003196:	f10d 0a0c 	add.w	sl, sp, #12
       (void)&pstr_parse_unused;                                /* Prevent possible 'variable unused' warning.          */
    }
   *pstr_next = (CPU_CHAR *)pstr;                               /* Init rtn str for err (see Note #5).                  */
 800319a:	f8ca 9000 	str.w	r9, [sl]

    if (pnbr_neg == (CPU_BOOLEAN *) 0) {                        /* If NOT avail, ...                                    */
 800319e:	2b00      	cmp	r3, #0
 80031a0:	f47f af7a 	bne.w	8003098 <Str_ParseNbr_Int32+0x20>
        pnbr_neg  = (CPU_BOOLEAN *)&nbr_neg_unused;             /* ... re-cfg NULL rtn ptr to unused local var.         */
 80031a4:	f10d 030b 	add.w	r3, sp, #11
 80031a8:	930e      	str	r3, [sp, #56]	; 0x38
       (void)&nbr_neg_unused;                                   /* Prevent possible 'variable unused' warning.          */
    }
   *pnbr_neg = DEF_NO;                                          /* Init nbr neg for err (see Note #5).                  */
 80031aa:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80031ac:	2000      	movs	r0, #0
 80031ae:	7018      	strb	r0, [r3, #0]


    if (pstr == (CPU_CHAR *)0) {                                /* Rtn zero if str ptr NULL (see Note #4b1).            */
 80031b0:	f1b9 0f00 	cmp.w	r9, #0
 80031b4:	f47f af77 	bne.w	80030a6 <Str_ParseNbr_Int32+0x2e>
        return (0u);
 80031b8:	4648      	mov	r0, r9

   *pnbr_neg = neg;                                             /* Rtn neg nbr status.                                  */


    return (nbr);
}
 80031ba:	b005      	add	sp, #20
 80031bc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
             neg = DEF_YES;
             break;


        default:
             neg = DEF_NO;
 80031c0:	2300      	movs	r3, #0
 80031c2:	9301      	str	r3, [sp, #4]
 80031c4:	e79b      	b.n	80030fe <Str_ParseNbr_Int32+0x86>
             }
             break;


        case 16u:                                               /* See Note #2a1B1a3.                                   */
             if (*pstr_parse == '0') {                          /* If avail, ...                                        */
 80031c6:	2c30      	cmp	r4, #48	; 0x30
 80031c8:	d029      	beq.n	800321e <Str_ParseNbr_Int32+0x1a6>
 80031ca:	46b0      	mov	r8, r6
 80031cc:	2710      	movs	r7, #16
 80031ce:	e79d      	b.n	800310c <Str_ParseNbr_Int32+0x94>
             }
             break;


        case  8u:                                               /* See Note #2a1B1a2.                                   */
             if (*pstr_parse == '0') {                          /* If avail, ...                                        */
 80031d0:	2c30      	cmp	r4, #48	; 0x30
 80031d2:	d007      	beq.n	80031e4 <Str_ParseNbr_Int32+0x16c>
 80031d4:	46b0      	mov	r8, r6
 80031d6:	2708      	movs	r7, #8
 80031d8:	e798      	b.n	800310c <Str_ParseNbr_Int32+0x94>
                                                                /* --------- IGNORE NBR BASE PRECEDING CHAR(S) -------- */
    pstr_parse_nbr = pstr_parse;                                /* Save ptr to str's nbr (see Note #2a1A1).             */

    switch (nbr_base) {
        case  0u:                                               /* Determine unspecified nbr base (see Notes #2a1B1a).  */
             if (*pstr_parse == '0') {                          /* If avail, ...                                        */
 80031da:	2c30      	cmp	r4, #48	; 0x30
 80031dc:	d006      	beq.n	80031ec <Str_ParseNbr_Int32+0x174>
 80031de:	46b0      	mov	r8, r6
                           nbr_base =  8u;                      /* ... set nbr base =  8    (see Note #2a1B1a2).        */
                           break;
                  }

             } else {                                           /* For non-'0' prefix, ...                              */
                 nbr_base = 10u;                                /* ... set nbr base = 10    (see Note #2a1B1a1).        */
 80031e0:	270a      	movs	r7, #10
 80031e2:	e793      	b.n	800310c <Str_ParseNbr_Int32+0x94>
             break;


        case  8u:                                               /* See Note #2a1B1a2.                                   */
             if (*pstr_parse == '0') {                          /* If avail, ...                                        */
                  pstr_parse++;                                 /* ... adv past '0'  prefix (see Note #2a1B1b2B).       */
 80031e4:	f106 0801 	add.w	r8, r6, #1
 80031e8:	7874      	ldrb	r4, [r6, #1]
 80031ea:	e78f      	b.n	800310c <Str_ParseNbr_Int32+0x94>

    switch (nbr_base) {
        case  0u:                                               /* Determine unspecified nbr base (see Notes #2a1B1a).  */
             if (*pstr_parse == '0') {                          /* If avail, ...                                        */
                  pstr_parse++;                                 /* ... adv past '0'  prefix (see Note #2a1B1b2).        */
                  switch (*pstr_parse) {
 80031ec:	7874      	ldrb	r4, [r6, #1]
    pstr_parse_nbr = pstr_parse;                                /* Save ptr to str's nbr (see Note #2a1A1).             */

    switch (nbr_base) {
        case  0u:                                               /* Determine unspecified nbr base (see Notes #2a1B1a).  */
             if (*pstr_parse == '0') {                          /* If avail, ...                                        */
                  pstr_parse++;                                 /* ... adv past '0'  prefix (see Note #2a1B1b2).        */
 80031ee:	f106 0801 	add.w	r8, r6, #1
                  switch (*pstr_parse) {
 80031f2:	2c58      	cmp	r4, #88	; 0x58
 80031f4:	d001      	beq.n	80031fa <Str_ParseNbr_Int32+0x182>
 80031f6:	2c78      	cmp	r4, #120	; 0x78
 80031f8:	d1ed      	bne.n	80031d6 <Str_ParseNbr_Int32+0x15e>
                  pstr_parse++;                                 /* ... adv past '0'  prefix (see Note #2a1B1b2).        */
                  switch (*pstr_parse) {
                      case 'x':
                      case 'X':
                           parse_char = (CPU_CHAR)(*(pstr_parse + 1));
                           nbr_hex    =  ASCII_IsDigHex(parse_char);
 80031fa:	78b0      	ldrb	r0, [r6, #2]
 80031fc:	f00c fa6c 	bl	800f6d8 <ASCII_IsDigHex>
                           if (nbr_hex == DEF_YES) {            /* If next char is valid hex dig, ...                   */
 8003200:	2801      	cmp	r0, #1
 8003202:	bf12      	itee	ne
 8003204:	7874      	ldrbne	r4, [r6, #1]
                               pstr_parse++;                    /* ... adv past '0x' prefix (see Note #2a1B1b2A).       */
 8003206:	f106 0802 	addeq.w	r8, r6, #2
 800320a:	78b4      	ldrbeq	r4, [r6, #2]
 800320c:	2710      	movs	r7, #16
 800320e:	e77d      	b.n	800310c <Str_ParseNbr_Int32+0x94>

        case '-':                                               /* Validate neg sign (see Note #2a1B2a).                */
             if (nbr_signed == DEF_YES) {
                 pstr_parse++;
             }
             neg = DEF_YES;
 8003210:	2301      	movs	r3, #1
 8003212:	9301      	str	r3, [sp, #4]
 8003214:	e7d9      	b.n	80031ca <Str_ParseNbr_Int32+0x152>
 8003216:	7874      	ldrb	r4, [r6, #1]
 8003218:	9501      	str	r5, [sp, #4]
             break;


        case '-':                                               /* Validate neg sign (see Note #2a1B2a).                */
             if (nbr_signed == DEF_YES) {
                 pstr_parse++;
 800321a:	3601      	adds	r6, #1
 800321c:	e76f      	b.n	80030fe <Str_ParseNbr_Int32+0x86>


        case 16u:                                               /* See Note #2a1B1a3.                                   */
             if (*pstr_parse == '0') {                          /* If avail, ...                                        */
                  pstr_parse++;                                 /* ... adv past '0'  prefix (see Note #2a1B1b2).        */
                  switch (*pstr_parse) {
 800321e:	7874      	ldrb	r4, [r6, #1]
             break;


        case 16u:                                               /* See Note #2a1B1a3.                                   */
             if (*pstr_parse == '0') {                          /* If avail, ...                                        */
                  pstr_parse++;                                 /* ... adv past '0'  prefix (see Note #2a1B1b2).        */
 8003220:	f106 0801 	add.w	r8, r6, #1
                  switch (*pstr_parse) {
 8003224:	2c58      	cmp	r4, #88	; 0x58
 8003226:	d0e8      	beq.n	80031fa <Str_ParseNbr_Int32+0x182>
 8003228:	2c78      	cmp	r4, #120	; 0x78
 800322a:	f47f af6f 	bne.w	800310c <Str_ParseNbr_Int32+0x94>
 800322e:	e7e4      	b.n	80031fa <Str_ParseNbr_Int32+0x182>

        case '-':                                               /* Validate neg sign (see Note #2a1B2a).                */
             if (nbr_signed == DEF_YES) {
                 pstr_parse++;
             }
             neg = DEF_YES;
 8003230:	2301      	movs	r3, #1
 8003232:	9301      	str	r3, [sp, #4]
 8003234:	e7ce      	b.n	80031d4 <Str_ParseNbr_Int32+0x15c>
 8003236:	bf00      	nop
 8003238:	08015ff8 	.word	0x08015ff8

0800323c <Str_Cat_N.part.0>:
        return ((CPU_CHAR *)pstr_dest);
    }


    pstr_cat_dest = pstr_dest;
    while (( pstr_cat_dest != (CPU_CHAR *)  0 ) &&              /* Adv to end of cur dest str until NULL ptr ...        */
 800323c:	b340      	cbz	r0, 8003290 <Str_Cat_N.part.0+0x54>
*                           (A) No string concatenation performed; destination string returned 
*                               (see Note #2b1).
*********************************************************************************************************
*/
/*$PAGE*/
CPU_CHAR  *Str_Cat_N (       CPU_CHAR    *pstr_dest,
 800323e:	b430      	push	{r4, r5}
        return ((CPU_CHAR *)pstr_dest);
    }


    pstr_cat_dest = pstr_dest;
    while (( pstr_cat_dest != (CPU_CHAR *)  0 ) &&              /* Adv to end of cur dest str until NULL ptr ...        */
 8003240:	7803      	ldrb	r3, [r0, #0]
 8003242:	b153      	cbz	r3, 800325a <Str_Cat_N.part.0+0x1e>
 8003244:	1c44      	adds	r4, r0, #1
 8003246:	e002      	b.n	800324e <Str_Cat_N.part.0+0x12>
 8003248:	7825      	ldrb	r5, [r4, #0]
 800324a:	3401      	adds	r4, #1
 800324c:	b135      	cbz	r5, 800325c <Str_Cat_N.part.0+0x20>
           (*pstr_cat_dest != (CPU_CHAR  )'\0')) {              /* ... or NULL char found..                             */
        pstr_cat_dest++;
 800324e:	4623      	mov	r3, r4
        return ((CPU_CHAR *)pstr_dest);
    }


    pstr_cat_dest = pstr_dest;
    while (( pstr_cat_dest != (CPU_CHAR *)  0 ) &&              /* Adv to end of cur dest str until NULL ptr ...        */
 8003250:	2c00      	cmp	r4, #0
 8003252:	d1f9      	bne.n	8003248 <Str_Cat_N.part.0+0xc>
        len_cat++;
    }
                                                                /* Rtn NULL if NULL ptr(s) found (see Note #3b1).       */
    if ((pstr_cat_dest == (      CPU_CHAR *)0) ||
        (pstr_cat_src  == (const CPU_CHAR *)0)) {
         return ((CPU_CHAR *)0);
 8003254:	2000      	movs	r0, #0

   *pstr_cat_dest = (CPU_CHAR)'\0';                             /* Append NULL char    (see Note #2a2C).                */


    return (pstr_dest);                                         /* Rtn ptr to dest str (see Note #2b1).                 */
}
 8003256:	bc30      	pop	{r4, r5}
 8003258:	4770      	bx	lr
        return ((CPU_CHAR *)pstr_dest);
    }


    pstr_cat_dest = pstr_dest;
    while (( pstr_cat_dest != (CPU_CHAR *)  0 ) &&              /* Adv to end of cur dest str until NULL ptr ...        */
 800325a:	4603      	mov	r3, r0
    }

    pstr_cat_src = pstr_cat;
    len_cat      = 0u;

    while (( pstr_cat_dest != (      CPU_CHAR *)  0 ) &&        /* Cat str until NULL ptr(s)  [see Note #3b]  ...       */
 800325c:	2900      	cmp	r1, #0
 800325e:	d0f9      	beq.n	8003254 <Str_Cat_N.part.0+0x18>
           ( pstr_cat_src  != (const CPU_CHAR *)  0 ) &&
           (*pstr_cat_src  != (      CPU_CHAR  )'\0') &&        /* ... or NULL char found     (see Note #3c); ...       */
 8003260:	780c      	ldrb	r4, [r1, #0]

    pstr_cat_src = pstr_cat;
    len_cat      = 0u;

    while (( pstr_cat_dest != (      CPU_CHAR *)  0 ) &&        /* Cat str until NULL ptr(s)  [see Note #3b]  ...       */
           ( pstr_cat_src  != (const CPU_CHAR *)  0 ) &&
 8003262:	b18c      	cbz	r4, 8003288 <Str_Cat_N.part.0+0x4c>
           (*pstr_cat_src  != (      CPU_CHAR  )'\0') &&        /* ... or NULL char found     (see Note #3c); ...       */
 8003264:	b182      	cbz	r2, 8003288 <Str_Cat_N.part.0+0x4c>
           ( len_cat       <  (      CPU_SIZE_T)len_max)) {     /* ... or max nbr chars cat'd (see Note #3d).           */
       *pstr_cat_dest = *pstr_cat_src;
 8003266:	f803 4b01 	strb.w	r4, [r3], #1
    }

    pstr_cat_src = pstr_cat;
    len_cat      = 0u;

    while (( pstr_cat_dest != (      CPU_CHAR *)  0 ) &&        /* Cat str until NULL ptr(s)  [see Note #3b]  ...       */
 800326a:	2b00      	cmp	r3, #0
 800326c:	d0f2      	beq.n	8003254 <Str_Cat_N.part.0+0x18>
 800326e:	440a      	add	r2, r1
 8003270:	1c4c      	adds	r4, r1, #1
 8003272:	d0ef      	beq.n	8003254 <Str_Cat_N.part.0+0x18>
           ( pstr_cat_src  != (const CPU_CHAR *)  0 ) &&
           (*pstr_cat_src  != (      CPU_CHAR  )'\0') &&        /* ... or NULL char found     (see Note #3c); ...       */
 8003274:	f811 4f01 	ldrb.w	r4, [r1, #1]!

    pstr_cat_src = pstr_cat;
    len_cat      = 0u;

    while (( pstr_cat_dest != (      CPU_CHAR *)  0 ) &&        /* Cat str until NULL ptr(s)  [see Note #3b]  ...       */
           ( pstr_cat_src  != (const CPU_CHAR *)  0 ) &&
 8003278:	b134      	cbz	r4, 8003288 <Str_Cat_N.part.0+0x4c>
           (*pstr_cat_src  != (      CPU_CHAR  )'\0') &&        /* ... or NULL char found     (see Note #3c); ...       */
 800327a:	428a      	cmp	r2, r1
 800327c:	d004      	beq.n	8003288 <Str_Cat_N.part.0+0x4c>
           ( len_cat       <  (      CPU_SIZE_T)len_max)) {     /* ... or max nbr chars cat'd (see Note #3d).           */
       *pstr_cat_dest = *pstr_cat_src;
 800327e:	f803 4b01 	strb.w	r4, [r3], #1
    }

    pstr_cat_src = pstr_cat;
    len_cat      = 0u;

    while (( pstr_cat_dest != (      CPU_CHAR *)  0 ) &&        /* Cat str until NULL ptr(s)  [see Note #3b]  ...       */
 8003282:	2b00      	cmp	r3, #0
 8003284:	d1f4      	bne.n	8003270 <Str_Cat_N.part.0+0x34>
 8003286:	e7e5      	b.n	8003254 <Str_Cat_N.part.0+0x18>
    if ((pstr_cat_dest == (      CPU_CHAR *)0) ||
        (pstr_cat_src  == (const CPU_CHAR *)0)) {
         return ((CPU_CHAR *)0);
    }

   *pstr_cat_dest = (CPU_CHAR)'\0';                             /* Append NULL char    (see Note #2a2C).                */
 8003288:	2200      	movs	r2, #0
 800328a:	701a      	strb	r2, [r3, #0]


    return (pstr_dest);                                         /* Rtn ptr to dest str (see Note #2b1).                 */
}
 800328c:	bc30      	pop	{r4, r5}
 800328e:	4770      	bx	lr
        len_cat++;
    }
                                                                /* Rtn NULL if NULL ptr(s) found (see Note #3b1).       */
    if ((pstr_cat_dest == (      CPU_CHAR *)0) ||
        (pstr_cat_src  == (const CPU_CHAR *)0)) {
         return ((CPU_CHAR *)0);
 8003290:	2000      	movs	r0, #0

   *pstr_cat_dest = (CPU_CHAR)'\0';                             /* Append NULL char    (see Note #2a2C).                */


    return (pstr_dest);                                         /* Rtn ptr to dest str (see Note #2b1).                 */
}
 8003292:	4770      	bx	lr

08003294 <Str_Len>:
           CPU_SIZE_T   len;


    pstr_len = pstr;
    len      = 0u;
    while (( pstr_len != (const CPU_CHAR *)  0 ) &&             /* Calc str len until NULL ptr (see Note #3a) ...       */
 8003294:	b160      	cbz	r0, 80032b0 <Str_Len+0x1c>
 8003296:	7803      	ldrb	r3, [r0, #0]
 8003298:	b163      	cbz	r3, 80032b4 <Str_Len+0x20>
 800329a:	1c43      	adds	r3, r0, #1
 800329c:	2000      	movs	r0, #0
 800329e:	e004      	b.n	80032aa <Str_Len+0x16>
           (*pstr_len != (      CPU_CHAR  )'\0') &&             /* ... or NULL char found      (see Note #3b) ...       */
 80032a0:	f813 2b01 	ldrb.w	r2, [r3], #1
           CPU_SIZE_T   len;


    pstr_len = pstr;
    len      = 0u;
    while (( pstr_len != (const CPU_CHAR *)  0 ) &&             /* Calc str len until NULL ptr (see Note #3a) ...       */
 80032a4:	b122      	cbz	r2, 80032b0 <Str_Len+0x1c>
           (*pstr_len != (      CPU_CHAR  )'\0') &&             /* ... or NULL char found      (see Note #3b) ...       */
 80032a6:	1c42      	adds	r2, r0, #1
 80032a8:	d003      	beq.n	80032b2 <Str_Len+0x1e>
           ( len      <  (      CPU_SIZE_T)len_max)) {          /* ... or max nbr chars srch'd (see Note #3c).          */
        pstr_len++;
        len++;
 80032aa:	3001      	adds	r0, #1
           CPU_SIZE_T   len;


    pstr_len = pstr;
    len      = 0u;
    while (( pstr_len != (const CPU_CHAR *)  0 ) &&             /* Calc str len until NULL ptr (see Note #3a) ...       */
 80032ac:	2b00      	cmp	r3, #0
 80032ae:	d1f7      	bne.n	80032a0 <Str_Len+0xc>

    len = Str_Len_N(pstr,
                    DEF_INT_CPU_U_MAX_VAL);

    return (len);
}
 80032b0:	4770      	bx	lr
 80032b2:	4770      	bx	lr
    const  CPU_CHAR    *pstr_len;
           CPU_SIZE_T   len;


    pstr_len = pstr;
    len      = 0u;
 80032b4:	4618      	mov	r0, r3
 80032b6:	e7fb      	b.n	80032b0 <Str_Len+0x1c>

080032b8 <Str_Len_N>:
    while (( pstr_len != (const CPU_CHAR *)  0 ) &&             /* Calc str len until NULL ptr (see Note #3a) ...       */
 80032b8:	b178      	cbz	r0, 80032da <Str_Len_N+0x22>
 80032ba:	7803      	ldrb	r3, [r0, #0]
 80032bc:	b18b      	cbz	r3, 80032e2 <Str_Len_N+0x2a>
           (*pstr_len != (      CPU_CHAR  )'\0') &&             /* ... or NULL char found      (see Note #3b) ...       */
 80032be:	b171      	cbz	r1, 80032de <Str_Len_N+0x26>
 80032c0:	4603      	mov	r3, r0
 80032c2:	2000      	movs	r0, #0
 80032c4:	4419      	add	r1, r3
 80032c6:	e004      	b.n	80032d2 <Str_Len_N+0x1a>
           CPU_SIZE_T   len;


    pstr_len = pstr;
    len      = 0u;
    while (( pstr_len != (const CPU_CHAR *)  0 ) &&             /* Calc str len until NULL ptr (see Note #3a) ...       */
 80032c8:	f813 2f01 	ldrb.w	r2, [r3, #1]!
 80032cc:	b12a      	cbz	r2, 80032da <Str_Len_N+0x22>
           (*pstr_len != (      CPU_CHAR  )'\0') &&             /* ... or NULL char found      (see Note #3b) ...       */
 80032ce:	428b      	cmp	r3, r1
 80032d0:	d004      	beq.n	80032dc <Str_Len_N+0x24>
           CPU_SIZE_T   len;


    pstr_len = pstr;
    len      = 0u;
    while (( pstr_len != (const CPU_CHAR *)  0 ) &&             /* Calc str len until NULL ptr (see Note #3a) ...       */
 80032d2:	1c5a      	adds	r2, r3, #1
           (*pstr_len != (      CPU_CHAR  )'\0') &&             /* ... or NULL char found      (see Note #3b) ...       */
           ( len      <  (      CPU_SIZE_T)len_max)) {          /* ... or max nbr chars srch'd (see Note #3c).          */
        pstr_len++;
        len++;
 80032d4:	f100 0001 	add.w	r0, r0, #1
           CPU_SIZE_T   len;


    pstr_len = pstr;
    len      = 0u;
    while (( pstr_len != (const CPU_CHAR *)  0 ) &&             /* Calc str len until NULL ptr (see Note #3a) ...       */
 80032d8:	d1f6      	bne.n	80032c8 <Str_Len_N+0x10>
        pstr_len++;
        len++;
    }

    return (len);                                               /* Rtn str len (see Note #3b1).                         */
}
 80032da:	4770      	bx	lr
 80032dc:	4770      	bx	lr
    const  CPU_CHAR    *pstr_len;
           CPU_SIZE_T   len;


    pstr_len = pstr;
    len      = 0u;
 80032de:	4608      	mov	r0, r1
 80032e0:	e7fb      	b.n	80032da <Str_Len_N+0x22>
 80032e2:	4618      	mov	r0, r3
 80032e4:	4770      	bx	lr
 80032e6:	bf00      	nop

080032e8 <Str_Copy_N>:
*/
/*$PAGE*/
CPU_CHAR  *Str_Copy_N (       CPU_CHAR    *pstr_dest,
                       const  CPU_CHAR    *pstr_src,
                              CPU_SIZE_T   len_max)
{
 80032e8:	b470      	push	{r4, r5, r6}
           CPU_CHAR    *pstr_copy_dest;
    const  CPU_CHAR    *pstr_copy_src;
           CPU_SIZE_T   len_copy;

                                                                /* Rtn NULL if str ptr(s) NULL (see Note #3a1).         */
    if (pstr_dest == (CPU_CHAR *)0) {
 80032ea:	b1a8      	cbz	r0, 8003318 <Str_Copy_N+0x30>
        return ((CPU_CHAR *)0);
    }
    if (pstr_src  == (const CPU_CHAR *)0) {
 80032ec:	b1a1      	cbz	r1, 8003318 <Str_Copy_N+0x30>
    pstr_copy_src  = pstr_src;
    len_copy       = 0u;

    while (( pstr_copy_dest != (      CPU_CHAR *)  0 ) &&       /* Copy str until NULL ptr(s)  [see Note #3b]  ...      */
           ( pstr_copy_src  != (const CPU_CHAR *)  0 ) &&
           (*pstr_copy_src  != (      CPU_CHAR  )'\0') &&       /* ... or NULL char found      (see Note #3c); ...      */
 80032ee:	780b      	ldrb	r3, [r1, #0]
    pstr_copy_dest = pstr_dest;
    pstr_copy_src  = pstr_src;
    len_copy       = 0u;

    while (( pstr_copy_dest != (      CPU_CHAR *)  0 ) &&       /* Copy str until NULL ptr(s)  [see Note #3b]  ...      */
           ( pstr_copy_src  != (const CPU_CHAR *)  0 ) &&
 80032f0:	b1ab      	cbz	r3, 800331e <Str_Copy_N+0x36>
           (*pstr_copy_src  != (      CPU_CHAR  )'\0') &&       /* ... or NULL char found      (see Note #3c); ...      */
 80032f2:	b192      	cbz	r2, 800331a <Str_Copy_N+0x32>
           ( len_copy       <  (      CPU_SIZE_T)len_max)) {    /* ... or max nbr chars copied (see Note #3d).          */
       *pstr_copy_dest = *pstr_copy_src;
 80032f4:	4604      	mov	r4, r0
 80032f6:	f804 3b01 	strb.w	r3, [r4], #1

    pstr_copy_dest = pstr_dest;
    pstr_copy_src  = pstr_src;
    len_copy       = 0u;

    while (( pstr_copy_dest != (      CPU_CHAR *)  0 ) &&       /* Copy str until NULL ptr(s)  [see Note #3b]  ...      */
 80032fa:	b16c      	cbz	r4, 8003318 <Str_Copy_N+0x30>
 80032fc:	2301      	movs	r3, #1
 80032fe:	424e      	negs	r6, r1
 8003300:	42b3      	cmp	r3, r6
 8003302:	d009      	beq.n	8003318 <Str_Copy_N+0x30>
           ( pstr_copy_src  != (const CPU_CHAR *)  0 ) &&
           (*pstr_copy_src  != (      CPU_CHAR  )'\0') &&       /* ... or NULL char found      (see Note #3c); ...      */
 8003304:	f811 5f01 	ldrb.w	r5, [r1, #1]!
    pstr_copy_dest = pstr_dest;
    pstr_copy_src  = pstr_src;
    len_copy       = 0u;

    while (( pstr_copy_dest != (      CPU_CHAR *)  0 ) &&       /* Copy str until NULL ptr(s)  [see Note #3b]  ...      */
           ( pstr_copy_src  != (const CPU_CHAR *)  0 ) &&
 8003308:	b155      	cbz	r5, 8003320 <Str_Copy_N+0x38>
           (*pstr_copy_src  != (      CPU_CHAR  )'\0') &&       /* ... or NULL char found      (see Note #3c); ...      */
 800330a:	4293      	cmp	r3, r2
 800330c:	d005      	beq.n	800331a <Str_Copy_N+0x32>
           ( len_copy       <  (      CPU_SIZE_T)len_max)) {    /* ... or max nbr chars copied (see Note #3d).          */
       *pstr_copy_dest = *pstr_copy_src;
 800330e:	f804 5b01 	strb.w	r5, [r4], #1
        pstr_copy_dest++;
        pstr_copy_src++;
        len_copy++;
 8003312:	3301      	adds	r3, #1

    pstr_copy_dest = pstr_dest;
    pstr_copy_src  = pstr_src;
    len_copy       = 0u;

    while (( pstr_copy_dest != (      CPU_CHAR *)  0 ) &&       /* Copy str until NULL ptr(s)  [see Note #3b]  ...      */
 8003314:	2c00      	cmp	r4, #0
 8003316:	d1f3      	bne.n	8003300 <Str_Copy_N+0x18>
    const  CPU_CHAR    *pstr_copy_src;
           CPU_SIZE_T   len_copy;

                                                                /* Rtn NULL if str ptr(s) NULL (see Note #3a1).         */
    if (pstr_dest == (CPU_CHAR *)0) {
        return ((CPU_CHAR *)0);
 8003318:	2000      	movs	r0, #0
       *pstr_copy_dest = (CPU_CHAR)'\0';                        /* ... copy NULL char  (see Note #3c1).                 */
    }


    return (pstr_dest);                                         /* Rtn ptr to dest str (see Note #2b1).                 */
}
 800331a:	bc70      	pop	{r4, r5, r6}
 800331c:	4770      	bx	lr
    pstr_copy_dest = pstr_dest;
    pstr_copy_src  = pstr_src;
    len_copy       = 0u;

    while (( pstr_copy_dest != (      CPU_CHAR *)  0 ) &&       /* Copy str until NULL ptr(s)  [see Note #3b]  ...      */
           ( pstr_copy_src  != (const CPU_CHAR *)  0 ) &&
 800331e:	4604      	mov	r4, r0
    if ((pstr_copy_dest == (      CPU_CHAR *)0) ||
        (pstr_copy_src  == (const CPU_CHAR *)0)) {
         return ((CPU_CHAR *)0);
    }

    if (len_copy < len_max) {                                   /* If  copy str len < max buf len (see Note #2a2A), ... */
 8003320:	429a      	cmp	r2, r3
 8003322:	d9fa      	bls.n	800331a <Str_Copy_N+0x32>
       *pstr_copy_dest = (CPU_CHAR)'\0';                        /* ... copy NULL char  (see Note #3c1).                 */
 8003324:	2300      	movs	r3, #0
 8003326:	7023      	strb	r3, [r4, #0]
    }


    return (pstr_dest);                                         /* Rtn ptr to dest str (see Note #2b1).                 */
}
 8003328:	bc70      	pop	{r4, r5, r6}
 800332a:	4770      	bx	lr

0800332c <Str_Copy>:
                     const  CPU_CHAR  *pstr_src)
{
    CPU_CHAR  *pstr_rtn;


    pstr_rtn = Str_Copy_N(pstr_dest,
 800332c:	f04f 32ff 	mov.w	r2, #4294967295
 8003330:	f7ff bfda 	b.w	80032e8 <Str_Copy_N>

08003334 <Str_Cat>:
           CPU_CHAR    *pstr_cat_dest;
    const  CPU_CHAR    *pstr_cat_src;
           CPU_SIZE_T   len_cat;

                                                                /* Rtn NULL if str ptr(s) NULL (see Note #3a1).         */
    if (pstr_dest == (CPU_CHAR *)0) {
 8003334:	b118      	cbz	r0, 800333e <Str_Cat+0xa>
        return ((CPU_CHAR *)0);
    }
    if (pstr_cat  == (const CPU_CHAR *)0) {
 8003336:	b111      	cbz	r1, 800333e <Str_Cat+0xa>
 8003338:	f04f 32ff 	mov.w	r2, #4294967295
 800333c:	e77e      	b.n	800323c <Str_Cat_N.part.0>
    pstr_rtn = Str_Cat_N(pstr_dest,
                         pstr_cat,
                         DEF_INT_CPU_U_MAX_VAL);

    return (pstr_rtn);
}
 800333e:	2000      	movs	r0, #0
 8003340:	4770      	bx	lr
 8003342:	bf00      	nop

08003344 <Str_Cat_N>:
           CPU_CHAR    *pstr_cat_dest;
    const  CPU_CHAR    *pstr_cat_src;
           CPU_SIZE_T   len_cat;

                                                                /* Rtn NULL if str ptr(s) NULL (see Note #3a1).         */
    if (pstr_dest == (CPU_CHAR *)0) {
 8003344:	b138      	cbz	r0, 8003356 <Str_Cat_N+0x12>
*/
/*$PAGE*/
CPU_CHAR  *Str_Cat_N (       CPU_CHAR    *pstr_dest,
                      const  CPU_CHAR    *pstr_cat,
                             CPU_SIZE_T   len_max)
{
 8003346:	b430      	push	{r4, r5}

                                                                /* Rtn NULL if str ptr(s) NULL (see Note #3a1).         */
    if (pstr_dest == (CPU_CHAR *)0) {
        return ((CPU_CHAR *)0);
    }
    if (pstr_cat  == (const CPU_CHAR *)0) {
 8003348:	b111      	cbz	r1, 8003350 <Str_Cat_N+0xc>
        return ((CPU_CHAR *)0);
    }

    if (len_max < 1) {                                          /* Rtn dest str if cat len = 0 (see Note #3d2A).        */
 800334a:	b112      	cbz	r2, 8003352 <Str_Cat_N+0xe>

   *pstr_cat_dest = (CPU_CHAR)'\0';                             /* Append NULL char    (see Note #2a2C).                */


    return (pstr_dest);                                         /* Rtn ptr to dest str (see Note #2b1).                 */
}
 800334c:	bc30      	pop	{r4, r5}
 800334e:	e775      	b.n	800323c <Str_Cat_N.part.0>
    const  CPU_CHAR    *pstr_cat_src;
           CPU_SIZE_T   len_cat;

                                                                /* Rtn NULL if str ptr(s) NULL (see Note #3a1).         */
    if (pstr_dest == (CPU_CHAR *)0) {
        return ((CPU_CHAR *)0);
 8003350:	4608      	mov	r0, r1

   *pstr_cat_dest = (CPU_CHAR)'\0';                             /* Append NULL char    (see Note #2a2C).                */


    return (pstr_dest);                                         /* Rtn ptr to dest str (see Note #2b1).                 */
}
 8003352:	bc30      	pop	{r4, r5}
 8003354:	4770      	bx	lr
 8003356:	4770      	bx	lr

08003358 <Str_Cmp_N>:
    const  CPU_CHAR    *p2_str_cmp_next;
           CPU_INT16S   cmp_val;
           CPU_SIZE_T   cmp_len;


    if (len_max < 1) {                                          /* If cmp len = 0,        rtn 0       (see Note #3d1A). */
 8003358:	b1f2      	cbz	r2, 8003398 <Str_Cmp_N+0x40>
        return (0);
    }

    if (p1_str == (const CPU_CHAR *)0) {
 800335a:	b318      	cbz	r0, 80033a4 <Str_Cmp_N+0x4c>
            return (0);                                         /* If BOTH str ptrs NULL, rtn 0       (see Note #3a1A). */
        }
        cmp_val = (CPU_INT16S)0 - (CPU_INT16S)(*p2_str);
        return (cmp_val);                                       /* If p1_str NULL, rtn neg p2_str val (see Note #3a1B1).*/
    }
    if (p2_str == (const CPU_CHAR *)0) {
 800335c:	b1f1      	cbz	r1, 800339c <Str_Cmp_N+0x44>
*/
/*$PAGE*/
CPU_INT16S  Str_Cmp_N (const  CPU_CHAR    *p1_str,
                       const  CPU_CHAR    *p2_str,
                              CPU_SIZE_T   len_max)
{
 800335e:	b4f0      	push	{r4, r5, r6, r7}
    p2_str_cmp_next = p2_str_cmp;
    p1_str_cmp_next++;
    p2_str_cmp_next++;
    cmp_len         = 0u;

    while ((*p1_str_cmp      == *p2_str_cmp)            &&      /* Cmp strs until non-matching chars (see Note #3c) ... */
 8003360:	780d      	ldrb	r5, [r1, #0]
 8003362:	7804      	ldrb	r4, [r0, #0]

    p1_str_cmp      = p1_str;
    p2_str_cmp      = p2_str;
    p1_str_cmp_next = p1_str_cmp;
    p2_str_cmp_next = p2_str_cmp;
    p1_str_cmp_next++;
 8003364:	1c47      	adds	r7, r0, #1
    p2_str_cmp_next++;
    cmp_len         = 0u;

    while ((*p1_str_cmp      == *p2_str_cmp)            &&      /* Cmp strs until non-matching chars (see Note #3c) ... */
 8003366:	42ac      	cmp	r4, r5
    p1_str_cmp      = p1_str;
    p2_str_cmp      = p2_str;
    p1_str_cmp_next = p1_str_cmp;
    p2_str_cmp_next = p2_str_cmp;
    p1_str_cmp_next++;
    p2_str_cmp_next++;
 8003368:	f101 0601 	add.w	r6, r1, #1
    cmp_len         = 0u;

    while ((*p1_str_cmp      == *p2_str_cmp)            &&      /* Cmp strs until non-matching chars (see Note #3c) ... */
 800336c:	d110      	bne.n	8003390 <Str_Cmp_N+0x38>
 800336e:	b1bc      	cbz	r4, 80033a0 <Str_Cmp_N+0x48>
           (*p1_str_cmp      != (      CPU_CHAR  )'\0') &&      /* ... or NULL chars                 (see Note #3b) ... */
 8003370:	b31f      	cbz	r7, 80033ba <Str_Cmp_N+0x62>
           ( p1_str_cmp_next != (const CPU_CHAR *)  0 ) &&      /* ... or NULL ptr(s) found          (see Note #3a2).   */
 8003372:	b1f6      	cbz	r6, 80033b2 <Str_Cmp_N+0x5a>
 8003374:	2300      	movs	r3, #0
 8003376:	e002      	b.n	800337e <Str_Cmp_N+0x26>
    p2_str_cmp_next = p2_str_cmp;
    p1_str_cmp_next++;
    p2_str_cmp_next++;
    cmp_len         = 0u;

    while ((*p1_str_cmp      == *p2_str_cmp)            &&      /* Cmp strs until non-matching chars (see Note #3c) ... */
 8003378:	b194      	cbz	r4, 80033a0 <Str_Cmp_N+0x48>
           (*p1_str_cmp      != (      CPU_CHAR  )'\0') &&      /* ... or NULL chars                 (see Note #3b) ... */
           ( p1_str_cmp_next != (const CPU_CHAR *)  0 ) &&      /* ... or NULL ptr(s) found          (see Note #3a2).   */
           ( p2_str_cmp_next != (const CPU_CHAR *)  0 ) &&
 800337a:	429a      	cmp	r2, r3
 800337c:	d017      	beq.n	80033ae <Str_Cmp_N+0x56>
    p2_str_cmp_next = p2_str_cmp;
    p1_str_cmp_next++;
    p2_str_cmp_next++;
    cmp_len         = 0u;

    while ((*p1_str_cmp      == *p2_str_cmp)            &&      /* Cmp strs until non-matching chars (see Note #3c) ... */
 800337e:	f817 4b01 	ldrb.w	r4, [r7], #1
 8003382:	f816 5b01 	ldrb.w	r5, [r6], #1
           ( cmp_len         <  (      CPU_SIZE_T)len_max)) {   /* ... or max nbr chars cmp'd        (see Note #3d2).   */
        p1_str_cmp++;
        p2_str_cmp++;
        p1_str_cmp_next++;
        p2_str_cmp_next++;
        cmp_len++;
 8003386:	3301      	adds	r3, #1
    p2_str_cmp_next = p2_str_cmp;
    p1_str_cmp_next++;
    p2_str_cmp_next++;
    cmp_len         = 0u;

    while ((*p1_str_cmp      == *p2_str_cmp)            &&      /* Cmp strs until non-matching chars (see Note #3c) ... */
 8003388:	42ac      	cmp	r4, r5
 800338a:	d0f5      	beq.n	8003378 <Str_Cmp_N+0x20>
        p2_str_cmp_next++;
        cmp_len++;
    }


    if (cmp_len == len_max) {                                   /* If strs     identical for max len nbr of chars, ...  */
 800338c:	429a      	cmp	r2, r3
 800338e:	d00e      	beq.n	80033ae <Str_Cmp_N+0x56>
 8003390:	b2a4      	uxth	r4, r4
        return (0);                                             /* ... rtn 0                 (see Note #3d2A).          */
    }

    if (*p1_str_cmp != *p2_str_cmp) {                           /* If strs NOT identical, ...                           */
                                                                /* ... calc & rtn char diff  (see Note #3c1).           */
         cmp_val = (CPU_INT16S)(*p1_str_cmp) - (CPU_INT16S)(*p2_str_cmp);
 8003392:	1b60      	subs	r0, r4, r5
        }
    }


    return (cmp_val);
}
 8003394:	bcf0      	pop	{r4, r5, r6, r7}
 8003396:	4770      	bx	lr
           CPU_INT16S   cmp_val;
           CPU_SIZE_T   cmp_len;


    if (len_max < 1) {                                          /* If cmp len = 0,        rtn 0       (see Note #3d1A). */
        return (0);
 8003398:	4610      	mov	r0, r2
 800339a:	4770      	bx	lr
        }
        cmp_val = (CPU_INT16S)0 - (CPU_INT16S)(*p2_str);
        return (cmp_val);                                       /* If p1_str NULL, rtn neg p2_str val (see Note #3a1B1).*/
    }
    if (p2_str == (const CPU_CHAR *)0) {
        cmp_val = (CPU_INT16S)(*p1_str);
 800339c:	7800      	ldrb	r0, [r0, #0]
        return (cmp_val);                                       /* If p2_str NULL, rtn pos p1_str val (see Note #3a1B2).*/
 800339e:	4770      	bx	lr
           CPU_INT16S   cmp_val;
           CPU_SIZE_T   cmp_len;


    if (len_max < 1) {                                          /* If cmp len = 0,        rtn 0       (see Note #3d1A). */
        return (0);
 80033a0:	4620      	mov	r0, r4
 80033a2:	e7f7      	b.n	8003394 <Str_Cmp_N+0x3c>
    }

    if (p1_str == (const CPU_CHAR *)0) {
        if (p2_str == (const CPU_CHAR *)0) {
 80033a4:	b139      	cbz	r1, 80033b6 <Str_Cmp_N+0x5e>
            return (0);                                         /* If BOTH str ptrs NULL, rtn 0       (see Note #3a1A). */
        }
        cmp_val = (CPU_INT16S)0 - (CPU_INT16S)(*p2_str);
 80033a6:	780a      	ldrb	r2, [r1, #0]
 80033a8:	4252      	negs	r2, r2
 80033aa:	b210      	sxth	r0, r2
        }
    }


    return (cmp_val);
}
 80033ac:	4770      	bx	lr
           CPU_INT16S   cmp_val;
           CPU_SIZE_T   cmp_len;


    if (len_max < 1) {                                          /* If cmp len = 0,        rtn 0       (see Note #3d1A). */
        return (0);
 80033ae:	2000      	movs	r0, #0
 80033b0:	e7f0      	b.n	8003394 <Str_Cmp_N+0x3c>
            } else {                                            /* If p1_str_cmp_next NULL, ...                         */
                                                                /* ... rtn neg p2_str_cmp_next val (see Note #3a2B1).   */
                cmp_val = (CPU_INT16S)0 - (CPU_INT16S)(*p2_str_cmp_next);
            }
        } else {                                                /* If p2_str_cmp_next NULL, ...                         */
            cmp_val = (CPU_INT16S)(*p1_str_cmp_next);           /* ... rtn pos p1_str_cmp_next val (see Note #3a2B2).   */
 80033b2:	7840      	ldrb	r0, [r0, #1]
 80033b4:	e7ee      	b.n	8003394 <Str_Cmp_N+0x3c>
           CPU_INT16S   cmp_val;
           CPU_SIZE_T   cmp_len;


    if (len_max < 1) {                                          /* If cmp len = 0,        rtn 0       (see Note #3d1A). */
        return (0);
 80033b6:	4608      	mov	r0, r1
 80033b8:	4770      	bx	lr
    } else if (*p1_str_cmp  == (CPU_CHAR)'\0') {                /* If NULL char(s) found, ...                           */
         cmp_val = (CPU_INT16S)0;                               /* ... strs identical; rtn 0 (see Note #3b).            */

    } else {
        if (p1_str_cmp_next == (const CPU_CHAR *)0) {
            if (p2_str_cmp_next == (const CPU_CHAR *)0) {       /* If BOTH next str ptrs NULL, ...                      */
 80033ba:	b11e      	cbz	r6, 80033c4 <Str_Cmp_N+0x6c>
                cmp_val = (CPU_INT16S)0;                        /* ... rtn 0                       (see Note #3a2A).    */
            } else {                                            /* If p1_str_cmp_next NULL, ...                         */
                                                                /* ... rtn neg p2_str_cmp_next val (see Note #3a2B1).   */
                cmp_val = (CPU_INT16S)0 - (CPU_INT16S)(*p2_str_cmp_next);
 80033bc:	784a      	ldrb	r2, [r1, #1]
 80033be:	4252      	negs	r2, r2
 80033c0:	b210      	sxth	r0, r2
 80033c2:	e7e7      	b.n	8003394 <Str_Cmp_N+0x3c>
           CPU_INT16S   cmp_val;
           CPU_SIZE_T   cmp_len;


    if (len_max < 1) {                                          /* If cmp len = 0,        rtn 0       (see Note #3d1A). */
        return (0);
 80033c4:	4630      	mov	r0, r6
 80033c6:	e7e5      	b.n	8003394 <Str_Cmp_N+0x3c>

080033c8 <Str_Cmp>:
                     const  CPU_CHAR  *p2_str)
{
    CPU_INT16S  cmp_val;


    cmp_val = Str_Cmp_N(p1_str,
 80033c8:	f04f 32ff 	mov.w	r2, #4294967295
 80033cc:	f7ff bfc4 	b.w	8003358 <Str_Cmp_N>

080033d0 <Str_CmpIgnoreCase_N>:
           CPU_CHAR     char_2;
           CPU_INT16S   cmp_val;
           CPU_SIZE_T   cmp_len;


    if (len_max < 1) {                                          /* If cmp len = 0,        rtn 0       (see Note #3d1A). */
 80033d0:	b3a2      	cbz	r2, 800343c <Str_CmpIgnoreCase_N+0x6c>
*/

CPU_INT16S  Str_CmpIgnoreCase_N (const  CPU_CHAR    *p1_str,
                                 const  CPU_CHAR    *p2_str,
                                        CPU_SIZE_T   len_max)
{
 80033d2:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80033d6:	4690      	mov	r8, r2
 80033d8:	4689      	mov	r9, r1
 80033da:	4605      	mov	r5, r0

    if (len_max < 1) {                                          /* If cmp len = 0,        rtn 0       (see Note #3d1A). */
        return (0);
    }

    if (p1_str == (const CPU_CHAR *)0) {
 80033dc:	2800      	cmp	r0, #0
 80033de:	d03c      	beq.n	800345a <Str_CmpIgnoreCase_N+0x8a>
        char_2  =  ASCII_ToLower(*p2_str);
        cmp_val = (CPU_INT16S)0 - (CPU_INT16S)char_2;
        return (cmp_val);                                       /* If p1_str NULL, rtn neg p2_str val (see Note #3a1B1).*/
    }
    if (p2_str == (const CPU_CHAR *)0) {
        char_1  =  ASCII_ToLower(*p1_str);
 80033e0:	7800      	ldrb	r0, [r0, #0]
        }
        char_2  =  ASCII_ToLower(*p2_str);
        cmp_val = (CPU_INT16S)0 - (CPU_INT16S)char_2;
        return (cmp_val);                                       /* If p1_str NULL, rtn neg p2_str val (see Note #3a1B1).*/
    }
    if (p2_str == (const CPU_CHAR *)0) {
 80033e2:	b3a9      	cbz	r1, 8003450 <Str_CmpIgnoreCase_N+0x80>
    p2_str_cmp      = p2_str;
    p1_str_cmp_next = p1_str_cmp;
    p2_str_cmp_next = p2_str_cmp;
    p1_str_cmp_next++;
    p2_str_cmp_next++;
    char_1          = ASCII_ToLower(*p1_str_cmp);
 80033e4:	f00c f9be 	bl	800f764 <ASCII_ToLower>
 80033e8:	4682      	mov	sl, r0
    char_2          = ASCII_ToLower(*p2_str_cmp);
 80033ea:	f899 0000 	ldrb.w	r0, [r9]
 80033ee:	f00c f9b9 	bl	800f764 <ASCII_ToLower>
    cmp_len         = 0u;

    while (( char_1          ==  char_2)                &&      /* Cmp strs until non-matching chars (see Note #3c) ... */
 80033f2:	4582      	cmp	sl, r0
    p2_str_cmp      = p2_str;
    p1_str_cmp_next = p1_str_cmp;
    p2_str_cmp_next = p2_str_cmp;
    p1_str_cmp_next++;
    p2_str_cmp_next++;
    char_1          = ASCII_ToLower(*p1_str_cmp);
 80033f4:	4656      	mov	r6, sl

    p1_str_cmp      = p1_str;
    p2_str_cmp      = p2_str;
    p1_str_cmp_next = p1_str_cmp;
    p2_str_cmp_next = p2_str_cmp;
    p1_str_cmp_next++;
 80033f6:	f105 0401 	add.w	r4, r5, #1
    p2_str_cmp_next++;
 80033fa:	f109 0701 	add.w	r7, r9, #1
    char_1          = ASCII_ToLower(*p1_str_cmp);
    char_2          = ASCII_ToLower(*p2_str_cmp);
    cmp_len         = 0u;

    while (( char_1          ==  char_2)                &&      /* Cmp strs until non-matching chars (see Note #3c) ... */
 80033fe:	d119      	bne.n	8003434 <Str_CmpIgnoreCase_N+0x64>
 8003400:	782b      	ldrb	r3, [r5, #0]
 8003402:	b39b      	cbz	r3, 800346c <Str_CmpIgnoreCase_N+0x9c>
           (*p1_str_cmp      != (      CPU_CHAR  )'\0') &&      /* ... or NULL chars                 (see Note #3b) ... */
 8003404:	b394      	cbz	r4, 800346c <Str_CmpIgnoreCase_N+0x9c>
           ( p1_str_cmp_next != (const CPU_CHAR *)  0 ) &&      /* ... or NULL ptr(s) found          (see Note #3a2).   */
 8003406:	b38f      	cbz	r7, 800346c <Str_CmpIgnoreCase_N+0x9c>
 8003408:	2500      	movs	r5, #0
 800340a:	e004      	b.n	8003416 <Str_CmpIgnoreCase_N+0x46>
    p2_str_cmp_next++;
    char_1          = ASCII_ToLower(*p1_str_cmp);
    char_2          = ASCII_ToLower(*p2_str_cmp);
    cmp_len         = 0u;

    while (( char_1          ==  char_2)                &&      /* Cmp strs until non-matching chars (see Note #3c) ... */
 800340c:	f814 3c01 	ldrb.w	r3, [r4, #-1]
 8003410:	b1b3      	cbz	r3, 8003440 <Str_CmpIgnoreCase_N+0x70>
           (*p1_str_cmp      != (      CPU_CHAR  )'\0') &&      /* ... or NULL chars                 (see Note #3b) ... */
           ( p1_str_cmp_next != (const CPU_CHAR *)  0 ) &&      /* ... or NULL ptr(s) found          (see Note #3a2).   */
           ( p2_str_cmp_next != (const CPU_CHAR *)  0 ) &&
 8003412:	45a8      	cmp	r8, r5
 8003414:	d016      	beq.n	8003444 <Str_CmpIgnoreCase_N+0x74>
        p1_str_cmp++;
        p2_str_cmp++;
        p1_str_cmp_next++;
        p2_str_cmp_next++;
        cmp_len++;
        char_1 = ASCII_ToLower(*p1_str_cmp);
 8003416:	f814 0b01 	ldrb.w	r0, [r4], #1
 800341a:	f00c f9a3 	bl	800f764 <ASCII_ToLower>
 800341e:	4606      	mov	r6, r0
        char_2 = ASCII_ToLower(*p2_str_cmp);
 8003420:	f817 0b01 	ldrb.w	r0, [r7], #1
 8003424:	f00c f99e 	bl	800f764 <ASCII_ToLower>
    p2_str_cmp_next++;
    char_1          = ASCII_ToLower(*p1_str_cmp);
    char_2          = ASCII_ToLower(*p2_str_cmp);
    cmp_len         = 0u;

    while (( char_1          ==  char_2)                &&      /* Cmp strs until non-matching chars (see Note #3c) ... */
 8003428:	4286      	cmp	r6, r0
           ( cmp_len         <  (      CPU_SIZE_T)len_max)) {   /* ... or max nbr chars cmp'd        (see Note #3d2).   */
        p1_str_cmp++;
        p2_str_cmp++;
        p1_str_cmp_next++;
        p2_str_cmp_next++;
        cmp_len++;
 800342a:	f105 0501 	add.w	r5, r5, #1
    p2_str_cmp_next++;
    char_1          = ASCII_ToLower(*p1_str_cmp);
    char_2          = ASCII_ToLower(*p2_str_cmp);
    cmp_len         = 0u;

    while (( char_1          ==  char_2)                &&      /* Cmp strs until non-matching chars (see Note #3c) ... */
 800342e:	d0ed      	beq.n	800340c <Str_CmpIgnoreCase_N+0x3c>
        char_1 = ASCII_ToLower(*p1_str_cmp);
        char_2 = ASCII_ToLower(*p2_str_cmp);
    }


    if (cmp_len == len_max) {                                   /* If strs     identical for max len nbr of chars, ...  */
 8003430:	45a8      	cmp	r8, r5
 8003432:	d007      	beq.n	8003444 <Str_CmpIgnoreCase_N+0x74>
        return (0);                                             /* ... rtn 0                 (see Note #3d2A).          */
    }

    if (char_1 != char_2) {                                     /* If strs NOT identical, ...                           */
         cmp_val = (CPU_INT16S)char_1 - (CPU_INT16S)char_2;     /* ... calc & rtn char diff  (see Note #3c1).           */
 8003434:	1a30      	subs	r0, r6, r0
 8003436:	b200      	sxth	r0, r0
 8003438:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
           CPU_INT16S   cmp_val;
           CPU_SIZE_T   cmp_len;


    if (len_max < 1) {                                          /* If cmp len = 0,        rtn 0       (see Note #3d1A). */
        return (0);
 800343c:	2000      	movs	r0, #0
        }
    }


    return (cmp_val);
}
 800343e:	4770      	bx	lr
        char_1 = ASCII_ToLower(*p1_str_cmp);
        char_2 = ASCII_ToLower(*p2_str_cmp);
    }


    if (cmp_len == len_max) {                                   /* If strs     identical for max len nbr of chars, ...  */
 8003440:	45a8      	cmp	r8, r5
 8003442:	d102      	bne.n	800344a <Str_CmpIgnoreCase_N+0x7a>
           CPU_INT16S   cmp_val;
           CPU_SIZE_T   cmp_len;


    if (len_max < 1) {                                          /* If cmp len = 0,        rtn 0       (see Note #3d1A). */
        return (0);
 8003444:	2000      	movs	r0, #0
 8003446:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    }

    if (char_1 != char_2) {                                     /* If strs NOT identical, ...                           */
         cmp_val = (CPU_INT16S)char_1 - (CPU_INT16S)char_2;     /* ... calc & rtn char diff  (see Note #3c1).           */

    } else if (char_1 == (CPU_CHAR)'\0') {                      /* If NULL char(s) found, ...                           */
 800344a:	2e00      	cmp	r6, #0
 800344c:	d0fa      	beq.n	8003444 <Str_CmpIgnoreCase_N+0x74>
            } else {                                            /* If p1_str_cmp_next NULL, ...                         */
                char_2  =  ASCII_ToLower(*p2_str_cmp_next);
                cmp_val = (CPU_INT16S)0 - (CPU_INT16S)char_2;   /* ... rtn neg p2_str_cmp_next val (see Note #3a2B1).   */
            }
        } else {                                                /* If p2_str_cmp_next NULL, ...                         */
            char_1  =  ASCII_ToLower(*p1_str_cmp_next);
 800344e:	7820      	ldrb	r0, [r4, #0]
 8003450:	f00c f988 	bl	800f764 <ASCII_ToLower>
            cmp_val = (CPU_INT16S)char_1;                       /* ... rtn pos p1_str_cmp_next val (see Note #3a2B2).   */
 8003454:	b200      	sxth	r0, r0
 8003456:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (len_max < 1) {                                          /* If cmp len = 0,        rtn 0       (see Note #3d1A). */
        return (0);
    }

    if (p1_str == (const CPU_CHAR *)0) {
        if (p2_str == (const CPU_CHAR *)0) {
 800345a:	2900      	cmp	r1, #0
 800345c:	d0f2      	beq.n	8003444 <Str_CmpIgnoreCase_N+0x74>
            return (0);                                         /* If BOTH str ptrs NULL, rtn 0       (see Note #3a1A). */
        }
        char_2  =  ASCII_ToLower(*p2_str);
 800345e:	7808      	ldrb	r0, [r1, #0]
 8003460:	f00c f980 	bl	800f764 <ASCII_ToLower>
        cmp_val = (CPU_INT16S)0 - (CPU_INT16S)char_2;
 8003464:	4240      	negs	r0, r0
 8003466:	b200      	sxth	r0, r0
        return (cmp_val);                                       /* If p1_str NULL, rtn neg p2_str val (see Note #3a1B1).*/
 8003468:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    }

    if (char_1 != char_2) {                                     /* If strs NOT identical, ...                           */
         cmp_val = (CPU_INT16S)char_1 - (CPU_INT16S)char_2;     /* ... calc & rtn char diff  (see Note #3c1).           */

    } else if (char_1 == (CPU_CHAR)'\0') {                      /* If NULL char(s) found, ...                           */
 800346c:	f1ba 0f00 	cmp.w	sl, #0
 8003470:	d0e8      	beq.n	8003444 <Str_CmpIgnoreCase_N+0x74>
         cmp_val = (CPU_INT16S)0;                               /* ... strs identical; rtn 0 (see Note #3b).            */

    } else {
        if (p1_str_cmp_next == (const CPU_CHAR *)0) {
 8003472:	2c00      	cmp	r4, #0
 8003474:	d1eb      	bne.n	800344e <Str_CmpIgnoreCase_N+0x7e>
            if (p2_str_cmp_next == (const CPU_CHAR *)0) {       /* If BOTH next str ptrs NULL, ...                      */
 8003476:	2f00      	cmp	r7, #0
 8003478:	d0e4      	beq.n	8003444 <Str_CmpIgnoreCase_N+0x74>
                cmp_val = (CPU_INT16S)0;                        /* ... rtn 0                       (see Note #3a2A).    */
            } else {                                            /* If p1_str_cmp_next NULL, ...                         */
                char_2  =  ASCII_ToLower(*p2_str_cmp_next);
 800347a:	f899 0001 	ldrb.w	r0, [r9, #1]
 800347e:	f00c f971 	bl	800f764 <ASCII_ToLower>
                cmp_val = (CPU_INT16S)0 - (CPU_INT16S)char_2;   /* ... rtn neg p2_str_cmp_next val (see Note #3a2B1).   */
 8003482:	4240      	negs	r0, r0
 8003484:	b200      	sxth	r0, r0
 8003486:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800348a:	bf00      	nop

0800348c <Str_CmpIgnoreCase>:
                               const  CPU_CHAR  *p2_str)
{
    CPU_INT16S  cmp_val;


    cmp_val = Str_CmpIgnoreCase_N(p1_str,
 800348c:	f04f 32ff 	mov.w	r2, #4294967295
 8003490:	f7ff bf9e 	b.w	80033d0 <Str_CmpIgnoreCase_N>

08003494 <Str_Char_N>:
{
    const  CPU_CHAR    *pstr_char;
           CPU_SIZE_T   len_srch;


    if (pstr == (const CPU_CHAR *)0) {                          /* Rtn NULL if srch str ptr NULL (see Note #3a1).       */
 8003494:	b170      	cbz	r0, 80034b4 <Str_Char_N+0x20>
        return ((CPU_CHAR *)0);
    }

    if (len_max < 1) {                                          /* Rtn NULL if srch len = 0      (see Note #3e1).       */
 8003496:	b1b9      	cbz	r1, 80034c8 <Str_Char_N+0x34>
*/
/*$PAGE*/
CPU_CHAR  *Str_Char_N (const  CPU_CHAR    *pstr,
                              CPU_SIZE_T   len_max,
                              CPU_CHAR     srch_char)
{
 8003498:	b430      	push	{r4, r5}

    if (pstr == (const CPU_CHAR *)0) {                          /* Rtn NULL if srch str ptr NULL (see Note #3a1).       */
        return ((CPU_CHAR *)0);
    }

    if (len_max < 1) {                                          /* Rtn NULL if srch len = 0      (see Note #3e1).       */
 800349a:	2400      	movs	r4, #0
 800349c:	4605      	mov	r5, r0

    pstr_char = pstr;
    len_srch  = 0u;

    while (( pstr_char != (const CPU_CHAR *)  0 )      &&       /* Srch str until NULL ptr     [see Note #3b]  ...      */
           (*pstr_char != (      CPU_CHAR  )'\0')      &&       /* ... or NULL char            (see Note #3c)  ...      */
 800349e:	f810 3b01 	ldrb.w	r3, [r0], #1


    pstr_char = pstr;
    len_srch  = 0u;

    while (( pstr_char != (const CPU_CHAR *)  0 )      &&       /* Srch str until NULL ptr     [see Note #3b]  ...      */
 80034a2:	b143      	cbz	r3, 80034b6 <Str_Char_N+0x22>
           (*pstr_char != (      CPU_CHAR  )'\0')      &&       /* ... or NULL char            (see Note #3c)  ...      */
 80034a4:	4293      	cmp	r3, r2
 80034a6:	d006      	beq.n	80034b6 <Str_Char_N+0x22>
           (*pstr_char != (      CPU_CHAR  )srch_char) &&       /* ... or srch char found      (see Note #3d); ...      */
 80034a8:	42a1      	cmp	r1, r4
 80034aa:	d00b      	beq.n	80034c4 <Str_Char_N+0x30>
           ( len_srch  <  (      CPU_SIZE_T)len_max)) {         /* ... or max nbr chars srch'd (see Note #3e).          */
        pstr_char++;
        len_srch++;
 80034ac:	3401      	adds	r4, #1


    pstr_char = pstr;
    len_srch  = 0u;

    while (( pstr_char != (const CPU_CHAR *)  0 )      &&       /* Srch str until NULL ptr     [see Note #3b]  ...      */
 80034ae:	2800      	cmp	r0, #0
 80034b0:	d1f4      	bne.n	800349c <Str_Char_N+0x8>
         return ((CPU_CHAR *)0);
    }


    return ((CPU_CHAR *)pstr_char);                             /* Else rtn ptr to found srch char (see Note #3d1).     */
}
 80034b2:	bc30      	pop	{r4, r5}
 80034b4:	4770      	bx	lr

    if (pstr_char == (const CPU_CHAR *)0) {                     /* Rtn NULL if NULL ptr found      (see Note #3b1).     */
        return ((CPU_CHAR *)0);
    }

    if (len_srch >= len_max) {                                  /* Rtn NULL if srch char NOT found ...                  */
 80034b6:	42a1      	cmp	r1, r4
 80034b8:	d904      	bls.n	80034c4 <Str_Char_N+0x30>
        return ((CPU_CHAR *)0);                                 /* ... within max nbr of chars     (see Note #3e1).     */
    }

    if (*pstr_char != srch_char) {                              /* Rtn NULL if srch char NOT found (see Note #3c1).     */
 80034ba:	429a      	cmp	r2, r3
 80034bc:	bf0c      	ite	eq
 80034be:	4628      	moveq	r0, r5
 80034c0:	2000      	movne	r0, #0
 80034c2:	e7f6      	b.n	80034b2 <Str_Char_N+0x1e>
    const  CPU_CHAR    *pstr_char;
           CPU_SIZE_T   len_srch;


    if (pstr == (const CPU_CHAR *)0) {                          /* Rtn NULL if srch str ptr NULL (see Note #3a1).       */
        return ((CPU_CHAR *)0);
 80034c4:	2000      	movs	r0, #0
 80034c6:	e7f4      	b.n	80034b2 <Str_Char_N+0x1e>
 80034c8:	4608      	mov	r0, r1
         return ((CPU_CHAR *)0);
    }


    return ((CPU_CHAR *)pstr_char);                             /* Else rtn ptr to found srch char (see Note #3d1).     */
}
 80034ca:	4770      	bx	lr

080034cc <Str_Char>:
                            CPU_CHAR   srch_char)
{
    CPU_CHAR  *pstr_rtn;


    pstr_rtn = Str_Char_N(pstr,
 80034cc:	460a      	mov	r2, r1
 80034ce:	f04f 31ff 	mov.w	r1, #4294967295
 80034d2:	f7ff bfdf 	b.w	8003494 <Str_Char_N>
 80034d6:	bf00      	nop

080034d8 <Str_Char_Last_N>:
    const  CPU_CHAR    *pstr_char;
           CPU_SIZE_T   str_len_max;
           CPU_SIZE_T   str_len;


    if (pstr == (const CPU_CHAR *)0) {                          /* Rtn NULL if srch str ptr NULL (see Note #3a1).       */
 80034d8:	b318      	cbz	r0, 8003522 <Str_Char_Last_N+0x4a>
        return ((CPU_CHAR *)0);
    }

    if (len_max < 1) {                                          /* Rtn NULL if srch len = 0      (see Note #3e1).       */
 80034da:	b329      	cbz	r1, 8003528 <Str_Char_Last_N+0x50>
*/
/*$PAGE*/
CPU_CHAR  *Str_Char_Last_N (const  CPU_CHAR    *pstr,
                                   CPU_SIZE_T   len_max,
                                   CPU_CHAR     srch_char)
{
 80034dc:	b430      	push	{r4, r5}
        return ((CPU_CHAR *)0);
    }


    pstr_char    = pstr;
     str_len_max = len_max - sizeof((CPU_CHAR)'\0');            /* Str len adj'd for NULL char len.                     */
 80034de:	4604      	mov	r4, r0
 80034e0:	3901      	subs	r1, #1
    const  CPU_CHAR    *pstr_len;
           CPU_SIZE_T   len;


    pstr_len = pstr;
    len      = 0u;
 80034e2:	2300      	movs	r3, #0
    while (( pstr_len != (const CPU_CHAR *)  0 ) &&             /* Calc str len until NULL ptr (see Note #3a) ...       */
           (*pstr_len != (      CPU_CHAR  )'\0') &&             /* ... or NULL char found      (see Note #3b) ...       */
 80034e4:	f814 5b01 	ldrb.w	r5, [r4], #1
           CPU_SIZE_T   len;


    pstr_len = pstr;
    len      = 0u;
    while (( pstr_len != (const CPU_CHAR *)  0 ) &&             /* Calc str len until NULL ptr (see Note #3a) ...       */
 80034e8:	b125      	cbz	r5, 80034f4 <Str_Char_Last_N+0x1c>
           (*pstr_len != (      CPU_CHAR  )'\0') &&             /* ... or NULL char found      (see Note #3b) ...       */
 80034ea:	4299      	cmp	r1, r3
 80034ec:	d002      	beq.n	80034f4 <Str_Char_Last_N+0x1c>
           ( len      <  (      CPU_SIZE_T)len_max)) {          /* ... or max nbr chars srch'd (see Note #3c).          */
        pstr_len++;
        len++;
 80034ee:	3301      	adds	r3, #1
           CPU_SIZE_T   len;


    pstr_len = pstr;
    len      = 0u;
    while (( pstr_len != (const CPU_CHAR *)  0 ) &&             /* Calc str len until NULL ptr (see Note #3a) ...       */
 80034f0:	2c00      	cmp	r4, #0
 80034f2:	d1f7      	bne.n	80034e4 <Str_Char_Last_N+0xc>
    pstr_char    = pstr;
     str_len_max = len_max - sizeof((CPU_CHAR)'\0');            /* Str len adj'd for NULL char len.                     */
     str_len     = Str_Len_N(pstr_char, str_len_max);
    pstr_char   += str_len;

    if (pstr_char == (const CPU_CHAR *)0) {                     /* Rtn NULL if NULL ptr found        (see Note #3b1).   */
 80034f4:	18c3      	adds	r3, r0, r3
 80034f6:	d015      	beq.n	8003524 <Str_Char_Last_N+0x4c>
        return ((CPU_CHAR *)0);
    }

    while (( pstr_char != pstr) &&                              /* Srch str from end until beginning (see Note #3c) ... */
 80034f8:	4298      	cmp	r0, r3
 80034fa:	d00c      	beq.n	8003516 <Str_Char_Last_N+0x3e>
 80034fc:	7819      	ldrb	r1, [r3, #0]
 80034fe:	4291      	cmp	r1, r2
 8003500:	d010      	beq.n	8003524 <Str_Char_Last_N+0x4c>
 8003502:	1e5c      	subs	r4, r3, #1
 8003504:	e002      	b.n	800350c <Str_Char_Last_N+0x34>
 8003506:	781d      	ldrb	r5, [r3, #0]
 8003508:	4295      	cmp	r5, r2
 800350a:	d00b      	beq.n	8003524 <Str_Char_Last_N+0x4c>
 800350c:	4284      	cmp	r4, r0
           (*pstr_char != srch_char)) {                         /* ... until srch char found         (see Note #3d).    */
        pstr_char--;
 800350e:	4623      	mov	r3, r4
 8003510:	f104 34ff 	add.w	r4, r4, #4294967295

    if (pstr_char == (const CPU_CHAR *)0) {                     /* Rtn NULL if NULL ptr found        (see Note #3b1).   */
        return ((CPU_CHAR *)0);
    }

    while (( pstr_char != pstr) &&                              /* Srch str from end until beginning (see Note #3c) ... */
 8003514:	d1f7      	bne.n	8003506 <Str_Char_Last_N+0x2e>
           (*pstr_char != srch_char)) {                         /* ... until srch char found         (see Note #3d).    */
        pstr_char--;
    }


    if (*pstr_char != srch_char) {                              /* Rtn NULL if srch char NOT found   (see Note #3c1).   */
 8003516:	7818      	ldrb	r0, [r3, #0]
 8003518:	4290      	cmp	r0, r2
 800351a:	bf0c      	ite	eq
 800351c:	4618      	moveq	r0, r3
 800351e:	2000      	movne	r0, #0
         return ((CPU_CHAR *)0);
    }


    return ((CPU_CHAR *)pstr_char);                             /* Else rtn ptr to found srch char   (see Note #3d1).   */
}
 8003520:	bc30      	pop	{r4, r5}
 8003522:	4770      	bx	lr
           CPU_SIZE_T   str_len_max;
           CPU_SIZE_T   str_len;


    if (pstr == (const CPU_CHAR *)0) {                          /* Rtn NULL if srch str ptr NULL (see Note #3a1).       */
        return ((CPU_CHAR *)0);
 8003524:	4618      	mov	r0, r3
 8003526:	e7fb      	b.n	8003520 <Str_Char_Last_N+0x48>
 8003528:	4608      	mov	r0, r1
         return ((CPU_CHAR *)0);
    }


    return ((CPU_CHAR *)pstr_char);                             /* Else rtn ptr to found srch char   (see Note #3d1).   */
}
 800352a:	4770      	bx	lr

0800352c <Str_Char_Last>:
                                 CPU_CHAR   srch_char)
{
    CPU_CHAR  *pstr_rtn;


    pstr_rtn = Str_Char_Last_N(pstr,
 800352c:	460a      	mov	r2, r1
 800352e:	f04f 31ff 	mov.w	r1, #4294967295
 8003532:	f7ff bfd1 	b.w	80034d8 <Str_Char_Last_N>
 8003536:	bf00      	nop

08003538 <Str_Char_Replace>:
{
    CPU_CHAR    *pstr_char;
    CPU_SIZE_T   len;


    if (pstr == (const CPU_CHAR *)0) {                          /* Rtn NULL if srch str ptr NULL (see Note #2a1).       */
 8003538:	b160      	cbz	r0, 8003554 <Str_Char_Replace+0x1c>
 800353a:	4603      	mov	r3, r0
*/

CPU_CHAR  *Str_Char_Replace (CPU_CHAR  *pstr,
                             CPU_CHAR   char_srch,
                             CPU_CHAR   char_replace)
{
 800353c:	b430      	push	{r4, r5}
 800353e:	1e45      	subs	r5, r0, #1

    pstr_char = pstr;
    len       = len_max;

    while (( pstr_char != (const CPU_CHAR *)0) &&               /* Srch str until NULL ptr     [see Note #2b]  ...      */
           (*pstr_char !=  ASCII_CHAR_NULL   ) &&               /* ... or NULL char            (see Note #2c)  ...      */
 8003540:	781c      	ldrb	r4, [r3, #0]
    }

    pstr_char = pstr;
    len       = len_max;

    while (( pstr_char != (const CPU_CHAR *)0) &&               /* Srch str until NULL ptr     [see Note #2b]  ...      */
 8003542:	b134      	cbz	r4, 8003552 <Str_Char_Replace+0x1a>
           (*pstr_char !=  ASCII_CHAR_NULL   ) &&               /* ... or NULL char            (see Note #2c)  ...      */
 8003544:	42ab      	cmp	r3, r5
 8003546:	d004      	beq.n	8003552 <Str_Char_Replace+0x1a>
           ( len        >                   0)) {               /* ... or max nbr chars srch'd (see Note #2e).          */

        if (*pstr_char == char_srch) {
 8003548:	42a1      	cmp	r1, r4
            *pstr_char  = char_replace;                         /* Replace char if srch char is found.                  */
 800354a:	bf08      	it	eq
 800354c:	701a      	strbeq	r2, [r3, #0]
    }

    pstr_char = pstr;
    len       = len_max;

    while (( pstr_char != (const CPU_CHAR *)0) &&               /* Srch str until NULL ptr     [see Note #2b]  ...      */
 800354e:	3301      	adds	r3, #1
 8003550:	d1f6      	bne.n	8003540 <Str_Char_Replace+0x8>
                                  char_srch,
                                  char_replace,
                                  DEF_INT_CPU_U_MAX_VAL);

    return (pstr_rtn);
}
 8003552:	bc30      	pop	{r4, r5}
 8003554:	4770      	bx	lr
 8003556:	bf00      	nop

08003558 <Str_Char_Replace_N>:
{
    CPU_CHAR    *pstr_char;
    CPU_SIZE_T   len;


    if (pstr == (const CPU_CHAR *)0) {                          /* Rtn NULL if srch str ptr NULL (see Note #2a1).       */
 8003558:	b168      	cbz	r0, 8003576 <Str_Char_Replace_N+0x1e>
        return ((CPU_CHAR *)0);
    }

    if (len_max < 1) {                                          /* Rtn NULL if srch len = 0      (see Note #2e1).       */
 800355a:	b16b      	cbz	r3, 8003578 <Str_Char_Replace_N+0x20>

CPU_CHAR  *Str_Char_Replace_N (CPU_CHAR    *pstr,
                               CPU_CHAR     char_srch,
                               CPU_CHAR     char_replace,
                               CPU_SIZE_T   len_max)
{
 800355c:	b470      	push	{r4, r5, r6}

    if (pstr == (const CPU_CHAR *)0) {                          /* Rtn NULL if srch str ptr NULL (see Note #2a1).       */
        return ((CPU_CHAR *)0);
    }

    if (len_max < 1) {                                          /* Rtn NULL if srch len = 0      (see Note #2e1).       */
 800355e:	4604      	mov	r4, r0
 8003560:	18c6      	adds	r6, r0, r3

    pstr_char = pstr;
    len       = len_max;

    while (( pstr_char != (const CPU_CHAR *)0) &&               /* Srch str until NULL ptr     [see Note #2b]  ...      */
           (*pstr_char !=  ASCII_CHAR_NULL   ) &&               /* ... or NULL char            (see Note #2c)  ...      */
 8003562:	7825      	ldrb	r5, [r4, #0]
    }

    pstr_char = pstr;
    len       = len_max;

    while (( pstr_char != (const CPU_CHAR *)0) &&               /* Srch str until NULL ptr     [see Note #2b]  ...      */
 8003564:	b135      	cbz	r5, 8003574 <Str_Char_Replace_N+0x1c>
           (*pstr_char !=  ASCII_CHAR_NULL   ) &&               /* ... or NULL char            (see Note #2c)  ...      */
 8003566:	42a6      	cmp	r6, r4
 8003568:	d004      	beq.n	8003574 <Str_Char_Replace_N+0x1c>
           ( len        >                   0)) {               /* ... or max nbr chars srch'd (see Note #2e).          */

        if (*pstr_char == char_srch) {
 800356a:	428d      	cmp	r5, r1
            *pstr_char  = char_replace;                         /* Replace char if srch char is found.                  */
 800356c:	bf08      	it	eq
 800356e:	7022      	strbeq	r2, [r4, #0]
    }

    pstr_char = pstr;
    len       = len_max;

    while (( pstr_char != (const CPU_CHAR *)0) &&               /* Srch str until NULL ptr     [see Note #2b]  ...      */
 8003570:	3401      	adds	r4, #1
 8003572:	d1f6      	bne.n	8003562 <Str_Char_Replace_N+0xa>
        pstr_char++;
        len--;
    }

    return (pstr);
}
 8003574:	bc70      	pop	{r4, r5, r6}
 8003576:	4770      	bx	lr
    CPU_CHAR    *pstr_char;
    CPU_SIZE_T   len;


    if (pstr == (const CPU_CHAR *)0) {                          /* Rtn NULL if srch str ptr NULL (see Note #2a1).       */
        return ((CPU_CHAR *)0);
 8003578:	4618      	mov	r0, r3
 800357a:	4770      	bx	lr

0800357c <Str_Str_N>:
           CPU_INT16S    srch_cmp;
    const  CPU_CHAR     *pstr_str;
    const  CPU_CHAR     *pstr_srch_ix;

                                                                /* Rtn NULL if str ptr(s) NULL (see Note #3a).          */
    if (pstr == (const CPU_CHAR *)0) {
 800357c:	2800      	cmp	r0, #0
 800357e:	d040      	beq.n	8003602 <Str_Str_N+0x86>
        return ((CPU_CHAR *)0);
    }
    if (pstr_srch == (const CPU_CHAR *)0) {
 8003580:	2900      	cmp	r1, #0
 8003582:	d03d      	beq.n	8003600 <Str_Str_N+0x84>
        return ((CPU_CHAR *)0);
    }

    if (len_max < 1) {                                          /* Rtn NULL if srch len = 0    (see Note #3g).          */
 8003584:	2a00      	cmp	r2, #0
 8003586:	d03d      	beq.n	8003604 <Str_Str_N+0x88>
*/
/*$PAGE*/
CPU_CHAR  *Str_Str_N (const  CPU_CHAR    *pstr,
                      const  CPU_CHAR    *pstr_srch,
                             CPU_SIZE_T   len_max)
{
 8003588:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
        return ((CPU_CHAR *)0);
    }

                                                                /* Lim max srch str len (to chk > str len).             */
    len_max_srch = (len_max <       DEF_INT_CPU_U_MAX_VAL)
                 ? (len_max + 1u) : DEF_INT_CPU_U_MAX_VAL;
 800358c:	1c53      	adds	r3, r2, #1
 800358e:	bf08      	it	eq
 8003590:	4616      	moveq	r6, r2
 8003592:	4604      	mov	r4, r0
 8003594:	bf18      	it	ne
 8003596:	1c56      	addne	r6, r2, #1
    const  CPU_CHAR    *pstr_len;
           CPU_SIZE_T   len;


    pstr_len = pstr;
    len      = 0u;
 8003598:	2300      	movs	r3, #0
    while (( pstr_len != (const CPU_CHAR *)  0 ) &&             /* Calc str len until NULL ptr (see Note #3a) ...       */
           (*pstr_len != (      CPU_CHAR  )'\0') &&             /* ... or NULL char found      (see Note #3b) ...       */
 800359a:	f814 5b01 	ldrb.w	r5, [r4], #1
           CPU_SIZE_T   len;


    pstr_len = pstr;
    len      = 0u;
    while (( pstr_len != (const CPU_CHAR *)  0 ) &&             /* Calc str len until NULL ptr (see Note #3a) ...       */
 800359e:	b125      	cbz	r5, 80035aa <Str_Str_N+0x2e>
           (*pstr_len != (      CPU_CHAR  )'\0') &&             /* ... or NULL char found      (see Note #3b) ...       */
 80035a0:	429a      	cmp	r2, r3
 80035a2:	d002      	beq.n	80035aa <Str_Str_N+0x2e>
           ( len      <  (      CPU_SIZE_T)len_max)) {          /* ... or max nbr chars srch'd (see Note #3c).          */
        pstr_len++;
        len++;
 80035a4:	3301      	adds	r3, #1
           CPU_SIZE_T   len;


    pstr_len = pstr;
    len      = 0u;
    while (( pstr_len != (const CPU_CHAR *)  0 ) &&             /* Calc str len until NULL ptr (see Note #3a) ...       */
 80035a6:	2c00      	cmp	r4, #0
 80035a8:	d1f7      	bne.n	800359a <Str_Str_N+0x1e>
 80035aa:	460d      	mov	r5, r1
    const  CPU_CHAR    *pstr_len;
           CPU_SIZE_T   len;


    pstr_len = pstr;
    len      = 0u;
 80035ac:	2400      	movs	r4, #0
    while (( pstr_len != (const CPU_CHAR *)  0 ) &&             /* Calc str len until NULL ptr (see Note #3a) ...       */
           (*pstr_len != (      CPU_CHAR  )'\0') &&             /* ... or NULL char found      (see Note #3b) ...       */
 80035ae:	f815 7b01 	ldrb.w	r7, [r5], #1
           CPU_SIZE_T   len;


    pstr_len = pstr;
    len      = 0u;
    while (( pstr_len != (const CPU_CHAR *)  0 ) &&             /* Calc str len until NULL ptr (see Note #3a) ...       */
 80035b2:	b30f      	cbz	r7, 80035f8 <Str_Str_N+0x7c>
           (*pstr_len != (      CPU_CHAR  )'\0') &&             /* ... or NULL char found      (see Note #3b) ...       */
 80035b4:	42a6      	cmp	r6, r4
 80035b6:	d002      	beq.n	80035be <Str_Str_N+0x42>
           ( len      <  (      CPU_SIZE_T)len_max)) {          /* ... or max nbr chars srch'd (see Note #3c).          */
        pstr_len++;
        len++;
 80035b8:	3401      	adds	r4, #1
           CPU_SIZE_T   len;


    pstr_len = pstr;
    len      = 0u;
    while (( pstr_len != (const CPU_CHAR *)  0 ) &&             /* Calc str len until NULL ptr (see Note #3a) ...       */
 80035ba:	2d00      	cmp	r5, #0
 80035bc:	d1f7      	bne.n	80035ae <Str_Str_N+0x32>
    str_len      = Str_Len_N(pstr,      len_max);
    str_len_srch = Str_Len_N(pstr_srch, len_max_srch);
    if (str_len_srch < 1) {                                     /* Rtn ptr to str if srch str len = 0 (see Note #2b2).  */
        return ((CPU_CHAR *)pstr);
    }
    if (str_len_srch > str_len) {                               /* Rtn NULL if srch str len > str len (see Note #3d).   */
 80035be:	42a3      	cmp	r3, r4
 80035c0:	d317      	bcc.n	80035f2 <Str_Str_N+0x76>
        return ((CPU_CHAR *)0);
    }
                                                                /* Rtn NULL if NULL ptr found         (see Note #3b1).  */
    pstr_str = pstr      + str_len;
    if (pstr_str == (const CPU_CHAR *)0) {
 80035c2:	18c5      	adds	r5, r0, r3
 80035c4:	d020      	beq.n	8003608 <Str_Str_N+0x8c>
        return ((CPU_CHAR *)0);
    }
    pstr_str = pstr_srch + str_len_srch;
    if (pstr_str == (const CPU_CHAR *)0) {
 80035c6:	190d      	adds	r5, r1, r4
 80035c8:	d01e      	beq.n	8003608 <Str_Str_N+0x8c>
 80035ca:	4680      	mov	r8, r0
 80035cc:	4689      	mov	r9, r1
        return ((CPU_CHAR *)0);
    }


    srch_len  = str_len - str_len_srch;                         /* Calc srch len (see Note #3e2).                       */
 80035ce:	1b1d      	subs	r5, r3, r4
    srch_ix   = 0u;
 80035d0:	2700      	movs	r7, #0
 80035d2:	e001      	b.n	80035d8 <Str_Str_N+0x5c>
    do {
        pstr_srch_ix = (const CPU_CHAR *)(pstr + srch_ix);
        srch_cmp     =  Str_Cmp_N(pstr_srch_ix, pstr_srch, str_len_srch);
        srch_done    = (srch_cmp == 0) ? DEF_YES : DEF_NO;
        srch_ix++;
    } while ((srch_done == DEF_NO) && (srch_ix <= srch_len));
 80035d4:	42bd      	cmp	r5, r7
 80035d6:	d30c      	bcc.n	80035f2 <Str_Str_N+0x76>
 80035d8:	eb08 0607 	add.w	r6, r8, r7
    srch_ix   = 0u;
    srch_done = DEF_NO;

    do {
        pstr_srch_ix = (const CPU_CHAR *)(pstr + srch_ix);
        srch_cmp     =  Str_Cmp_N(pstr_srch_ix, pstr_srch, str_len_srch);
 80035dc:	4630      	mov	r0, r6
 80035de:	4622      	mov	r2, r4
 80035e0:	4649      	mov	r1, r9
 80035e2:	f7ff feb9 	bl	8003358 <Str_Cmp_N>
        srch_done    = (srch_cmp == 0) ? DEF_YES : DEF_NO;
        srch_ix++;
 80035e6:	3701      	adds	r7, #1
    srch_done = DEF_NO;

    do {
        pstr_srch_ix = (const CPU_CHAR *)(pstr + srch_ix);
        srch_cmp     =  Str_Cmp_N(pstr_srch_ix, pstr_srch, str_len_srch);
        srch_done    = (srch_cmp == 0) ? DEF_YES : DEF_NO;
 80035e8:	2800      	cmp	r0, #0
 80035ea:	d1f3      	bne.n	80035d4 <Str_Str_N+0x58>
 80035ec:	4630      	mov	r0, r6
 80035ee:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    const  CPU_CHAR     *pstr_str;
    const  CPU_CHAR     *pstr_srch_ix;

                                                                /* Rtn NULL if str ptr(s) NULL (see Note #3a).          */
    if (pstr == (const CPU_CHAR *)0) {
        return ((CPU_CHAR *)0);
 80035f2:	2000      	movs	r0, #0
    if (srch_cmp != 0) {                                        /* Rtn NULL if srch str NOT found (see Note #3e2).      */
        return ((CPU_CHAR *)0);
    }

    return ((CPU_CHAR *)pstr_srch_ix);                          /* Else rtn ptr to found srch str (see Note #3f1).      */
}
 80035f4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    len_max_srch = (len_max <       DEF_INT_CPU_U_MAX_VAL)
                 ? (len_max + 1u) : DEF_INT_CPU_U_MAX_VAL;

    str_len      = Str_Len_N(pstr,      len_max);
    str_len_srch = Str_Len_N(pstr_srch, len_max_srch);
    if (str_len_srch < 1) {                                     /* Rtn ptr to str if srch str len = 0 (see Note #2b2).  */
 80035f8:	2c00      	cmp	r4, #0
 80035fa:	d1e0      	bne.n	80035be <Str_Str_N+0x42>
    if (srch_cmp != 0) {                                        /* Rtn NULL if srch str NOT found (see Note #3e2).      */
        return ((CPU_CHAR *)0);
    }

    return ((CPU_CHAR *)pstr_srch_ix);                          /* Else rtn ptr to found srch str (see Note #3f1).      */
}
 80035fc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    const  CPU_CHAR     *pstr_str;
    const  CPU_CHAR     *pstr_srch_ix;

                                                                /* Rtn NULL if str ptr(s) NULL (see Note #3a).          */
    if (pstr == (const CPU_CHAR *)0) {
        return ((CPU_CHAR *)0);
 8003600:	4608      	mov	r0, r1
    if (srch_cmp != 0) {                                        /* Rtn NULL if srch str NOT found (see Note #3e2).      */
        return ((CPU_CHAR *)0);
    }

    return ((CPU_CHAR *)pstr_srch_ix);                          /* Else rtn ptr to found srch str (see Note #3f1).      */
}
 8003602:	4770      	bx	lr
    const  CPU_CHAR     *pstr_str;
    const  CPU_CHAR     *pstr_srch_ix;

                                                                /* Rtn NULL if str ptr(s) NULL (see Note #3a).          */
    if (pstr == (const CPU_CHAR *)0) {
        return ((CPU_CHAR *)0);
 8003604:	4610      	mov	r0, r2
 8003606:	4770      	bx	lr
 8003608:	4628      	mov	r0, r5
 800360a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800360e:	bf00      	nop

08003610 <Str_Str>:
                    const  CPU_CHAR  *pstr_srch)
{
    CPU_CHAR  *pstr_rtn;


    pstr_rtn = Str_Str_N(pstr,
 8003610:	f04f 32ff 	mov.w	r2, #4294967295
 8003614:	f7ff bfb2 	b.w	800357c <Str_Str_N>

08003618 <Str_FmtNbr_Int32U>:
                              CPU_INT08U    nbr_base,
                              CPU_CHAR      lead_char,
                              CPU_BOOLEAN   lower_case,
                              CPU_BOOLEAN   nul,
                              CPU_CHAR     *pstr)
{
 8003618:	b570      	push	{r4, r5, r6, lr}
 800361a:	b084      	sub	sp, #16
 800361c:	f89d 6020 	ldrb.w	r6, [sp, #32]
 8003620:	f89d 5024 	ldrb.w	r5, [sp, #36]	; 0x24
 8003624:	9c0a      	ldr	r4, [sp, #40]	; 0x28
    CPU_CHAR  *pstr_fmt;


    pstr_fmt = Str_FmtNbr_Int32(nbr,                            /* Fmt unsigned int into str.                           */
 8003626:	e88d 0048 	stmia.w	sp, {r3, r6}
 800362a:	9502      	str	r5, [sp, #8]
 800362c:	9403      	str	r4, [sp, #12]
 800362e:	2300      	movs	r3, #0
 8003630:	f7ff fc48 	bl	8002ec4 <Str_FmtNbr_Int32>
                                lower_case,
                                nul,
                                pstr);

    return (pstr_fmt);
}
 8003634:	b004      	add	sp, #16
 8003636:	bd70      	pop	{r4, r5, r6, pc}

08003638 <Str_FmtNbr_Int32S>:
                              CPU_INT08U    nbr_base,
                              CPU_CHAR      lead_char,
                              CPU_BOOLEAN   lower_case,
                              CPU_BOOLEAN   nul,
                              CPU_CHAR     *pstr)
{
 8003638:	b5f0      	push	{r4, r5, r6, r7, lr}
 800363a:	b085      	sub	sp, #20
    CPU_CHAR     *pstr_fmt;
    CPU_INT32S    nbr_fmt;
    CPU_BOOLEAN   nbr_neg;


    if (nbr < 0) {                                              /* If nbr neg, ...                                      */
 800363c:	2800      	cmp	r0, #0
                              CPU_INT08U    nbr_base,
                              CPU_CHAR      lead_char,
                              CPU_BOOLEAN   lower_case,
                              CPU_BOOLEAN   nul,
                              CPU_CHAR     *pstr)
{
 800363e:	f89d 4028 	ldrb.w	r4, [sp, #40]	; 0x28
 8003642:	f89d 502c 	ldrb.w	r5, [sp, #44]	; 0x2c
 8003646:	9e0c      	ldr	r6, [sp, #48]	; 0x30
    CPU_BOOLEAN   nbr_neg;


    if (nbr < 0) {                                              /* If nbr neg, ...                                      */
        nbr_fmt = -nbr;                                         /* ... negate nbr.                                      */
        nbr_neg =  DEF_YES;
 8003648:	bfb4      	ite	lt
 800364a:	2701      	movlt	r7, #1
    } else {
        nbr_fmt =  nbr;
        nbr_neg =  DEF_NO;
 800364c:	2700      	movge	r7, #0
    }

    pstr_fmt = Str_FmtNbr_Int32((CPU_INT32U)nbr_fmt,            /* Fmt signed int into str.                             */
 800364e:	e88d 0078 	stmia.w	sp, {r3, r4, r5, r6}
    CPU_INT32S    nbr_fmt;
    CPU_BOOLEAN   nbr_neg;


    if (nbr < 0) {                                              /* If nbr neg, ...                                      */
        nbr_fmt = -nbr;                                         /* ... negate nbr.                                      */
 8003652:	bfb8      	it	lt
 8003654:	4240      	neglt	r0, r0
    } else {
        nbr_fmt =  nbr;
        nbr_neg =  DEF_NO;
    }

    pstr_fmt = Str_FmtNbr_Int32((CPU_INT32U)nbr_fmt,            /* Fmt signed int into str.                             */
 8003656:	463b      	mov	r3, r7
 8003658:	f7ff fc34 	bl	8002ec4 <Str_FmtNbr_Int32>
                                            lower_case,
                                            nul,
                                            pstr);

    return (pstr_fmt);
}
 800365c:	b005      	add	sp, #20
 800365e:	bdf0      	pop	{r4, r5, r6, r7, pc}

08003660 <Str_ParseNbr_Int32U>:
*/

CPU_INT32U  Str_ParseNbr_Int32U (const  CPU_CHAR     *pstr,
                                        CPU_CHAR    **pstr_next,
                                        CPU_INT08U    nbr_base)
{
 8003660:	b500      	push	{lr}
    CPU_INT32U  nbr;


    nbr = Str_ParseNbr_Int32(               pstr,               /* Parse/convert str ...                                */
 8003662:	2300      	movs	r3, #0
*/

CPU_INT32U  Str_ParseNbr_Int32U (const  CPU_CHAR     *pstr,
                                        CPU_CHAR    **pstr_next,
                                        CPU_INT08U    nbr_base)
{
 8003664:	b083      	sub	sp, #12
    CPU_INT32U  nbr;


    nbr = Str_ParseNbr_Int32(               pstr,               /* Parse/convert str ...                                */
 8003666:	9300      	str	r3, [sp, #0]
 8003668:	f7ff fd06 	bl	8003078 <Str_ParseNbr_Int32>
                                            nbr_base,
                                            DEF_NO,             /* ... as unsigned int (see Note #2a2).                 */
                             (CPU_BOOLEAN *)0);

    return (nbr);
}
 800366c:	b003      	add	sp, #12
 800366e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003672:	bf00      	nop

08003674 <Str_ParseNbr_Int32S>:
*/

CPU_INT32S  Str_ParseNbr_Int32S (const  CPU_CHAR     *pstr,
                                        CPU_CHAR    **pstr_next,
                                        CPU_INT08U    nbr_base)
{
 8003674:	b500      	push	{lr}
 8003676:	b085      	sub	sp, #20
    CPU_INT32S   nbr;
    CPU_INT32U   nbr_abs;
    CPU_BOOLEAN  nbr_neg;


    nbr_abs = Str_ParseNbr_Int32(pstr,                          /* Parse/convert str ...                                */
 8003678:	f10d 030f 	add.w	r3, sp, #15
 800367c:	9300      	str	r3, [sp, #0]
 800367e:	2301      	movs	r3, #1
 8003680:	f7ff fcfa 	bl	8003078 <Str_ParseNbr_Int32>
                                 pstr_next,
                                 nbr_base,
                                 DEF_YES,                       /* ... as signed int (see Note #2a2).                   */
                                &nbr_neg);

    if (nbr_neg == DEF_NO) {                                    /* Chk for neg nbr & ovf/undf (see Note #2a3A1).        */
 8003684:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8003688:	b933      	cbnz	r3, 8003698 <Str_ParseNbr_Int32S+0x24>
        nbr = (nbr_abs > (CPU_INT32U) DEF_INT_32S_MAX_VAL)          ?  (CPU_INT32S)DEF_INT_32S_MAX_VAL
                                                                    :  (CPU_INT32S)nbr_abs;
 800368a:	2800      	cmp	r0, #0
 800368c:	bfb8      	it	lt
 800368e:	f06f 4000 	mvnlt.w	r0, #2147483648	; 0x80000000
        nbr = (nbr_abs > (CPU_INT32U)-DEF_INT_32S_MIN_VAL_ONES_CPL) ?  (CPU_INT32S)DEF_INT_32S_MIN_VAL
                                                                    : -(CPU_INT32S)nbr_abs;
    }

    return (nbr);
}
 8003692:	b005      	add	sp, #20
 8003694:	f85d fb04 	ldr.w	pc, [sp], #4
    if (nbr_neg == DEF_NO) {                                    /* Chk for neg nbr & ovf/undf (see Note #2a3A1).        */
        nbr = (nbr_abs > (CPU_INT32U) DEF_INT_32S_MAX_VAL)          ?  (CPU_INT32S)DEF_INT_32S_MAX_VAL
                                                                    :  (CPU_INT32S)nbr_abs;
    } else {
        nbr = (nbr_abs > (CPU_INT32U)-DEF_INT_32S_MIN_VAL_ONES_CPL) ?  (CPU_INT32S)DEF_INT_32S_MIN_VAL
                                                                    : -(CPU_INT32S)nbr_abs;
 8003698:	2800      	cmp	r0, #0
 800369a:	bfac      	ite	ge
 800369c:	4240      	negge	r0, r0
 800369e:	f04f 4000 	movlt.w	r0, #2147483648	; 0x80000000
    }

    return (nbr);
}
 80036a2:	b005      	add	sp, #20
 80036a4:	f85d fb04 	ldr.w	pc, [sp], #4

080036a8 <LwIP_SendSem>:

//extern void  (*BSP_ETH_IRQHandler)(void);   


void LwIP_SendSem(void)
{
 80036a8:	b508      	push	{r3, lr}
    // sys_sem_signal(&lwip_eth_sem);
    while(BSP_ETH_IsRxPktValid()) 
 80036aa:	e002      	b.n	80036b2 <LwIP_SendSem+0xa>
        ethernetif_input(&xnetif);
 80036ac:	4803      	ldr	r0, [pc, #12]	; (80036bc <LwIP_SendSem+0x14>)
 80036ae:	f00a ffbf 	bl	800e630 <ethernetif_input>


void LwIP_SendSem(void)
{
    // sys_sem_signal(&lwip_eth_sem);
    while(BSP_ETH_IsRxPktValid()) 
 80036b2:	f009 fdcd 	bl	800d250 <BSP_ETH_IsRxPktValid>
 80036b6:	2800      	cmp	r0, #0
 80036b8:	d1f8      	bne.n	80036ac <LwIP_SendSem+0x4>
        ethernetif_input(&xnetif);
}
 80036ba:	bd08      	pop	{r3, pc}
 80036bc:	2000d910 	.word	0x2000d910

080036c0 <LWIP_Init>:
**return:
**autor:  andiman
**date:
************************************************************/
void LWIP_Init(void)
{
 80036c0:	b570      	push	{r4, r5, r6, lr}
 80036c2:	b088      	sub	sp, #32
    struct ip_addr ipaddr;
    struct ip_addr netmask;
    struct ip_addr gw;

    ETH_BSP_Config();
 80036c4:	f009 ff0a 	bl	800d4dc <ETH_BSP_Config>
//      return;

    //Eth_Link_PHYITConfig(DP83848_PHY_ADDRESS);
    //Eth_Link_EXTIConfig();

     tcpip_init(NULL, NULL);
 80036c8:	2100      	movs	r1, #0
 80036ca:	4608      	mov	r0, r1
 80036cc:	f007 ff2c 	bl	800b528 <tcpip_init>
        netmask.addr = 0;
        gw.addr = 0;

        IP4_ADDR(&ipaddr, DEFAULT_IP_ADDR0, DEFAULT_IP_ADDR1, DEFAULT_IP_ADDR2, DEFAULT_IP_ADDR3);
        IP4_ADDR(&netmask, DEFAULT_NETMASK_ADDR0, DEFAULT_NETMASK_ADDR1 , DEFAULT_NETMASK_ADDR2, DEFAULT_NETMASK_ADDR3);
        IP4_ADDR(&gw, DEFAULT_GW_ADDR0, DEFAULT_GW_ADDR1, DEFAULT_GW_ADDR2, DEFAULT_GW_ADDR3);
 80036d0:	4a0e      	ldr	r2, [pc, #56]	; (800370c <LWIP_Init+0x4c>)
 80036d2:	ab08      	add	r3, sp, #32
            IP4_ADDR(&gw,           (ACUDevInfo.DeviceInfo.NetWork.gate & 0x000000FF),          (ACUDevInfo.DeviceInfo.NetWork.gate & 0x0000FF00)>>8,
                                    (ACUDevInfo.DeviceInfo.NetWork.gate & 0x00FF0000)>>16,      (ACUDevInfo.DeviceInfo.NetWork.gate & 0xFF000000)>>24 );
        }
    }

    netif_add(&xnetif, &ipaddr, &netmask, &gw, NULL, &ethernetif_init, &tcpip_input);
 80036d4:	4c0e      	ldr	r4, [pc, #56]	; (8003710 <LWIP_Init+0x50>)
 80036d6:	4d0f      	ldr	r5, [pc, #60]	; (8003714 <LWIP_Init+0x54>)
 80036d8:	490f      	ldr	r1, [pc, #60]	; (8003718 <LWIP_Init+0x58>)
        netmask.addr = 0;
        gw.addr = 0;

        IP4_ADDR(&ipaddr, DEFAULT_IP_ADDR0, DEFAULT_IP_ADDR1, DEFAULT_IP_ADDR2, DEFAULT_IP_ADDR3);
        IP4_ADDR(&netmask, DEFAULT_NETMASK_ADDR0, DEFAULT_NETMASK_ADDR1 , DEFAULT_NETMASK_ADDR2, DEFAULT_NETMASK_ADDR3);
        IP4_ADDR(&gw, DEFAULT_GW_ADDR0, DEFAULT_GW_ADDR1, DEFAULT_GW_ADDR2, DEFAULT_GW_ADDR3);
 80036da:	f843 2d04 	str.w	r2, [r3, #-4]!
    {
        ipaddr.addr = 0;
        netmask.addr = 0;
        gw.addr = 0;

        IP4_ADDR(&ipaddr, DEFAULT_IP_ADDR0, DEFAULT_IP_ADDR1, DEFAULT_IP_ADDR2, DEFAULT_IP_ADDR3);
 80036de:	4e0f      	ldr	r6, [pc, #60]	; (800371c <LWIP_Init+0x5c>)
            IP4_ADDR(&gw,           (ACUDevInfo.DeviceInfo.NetWork.gate & 0x000000FF),          (ACUDevInfo.DeviceInfo.NetWork.gate & 0x0000FF00)>>8,
                                    (ACUDevInfo.DeviceInfo.NetWork.gate & 0x00FF0000)>>16,      (ACUDevInfo.DeviceInfo.NetWork.gate & 0xFF000000)>>24 );
        }
    }

    netif_add(&xnetif, &ipaddr, &netmask, &gw, NULL, &ethernetif_init, &tcpip_input);
 80036e0:	2200      	movs	r2, #0
 80036e2:	9502      	str	r5, [sp, #8]
 80036e4:	9101      	str	r1, [sp, #4]
 80036e6:	9200      	str	r2, [sp, #0]
 80036e8:	a905      	add	r1, sp, #20
 80036ea:	aa06      	add	r2, sp, #24
 80036ec:	4620      	mov	r0, r4
        ipaddr.addr = 0;
        netmask.addr = 0;
        gw.addr = 0;

        IP4_ADDR(&ipaddr, DEFAULT_IP_ADDR0, DEFAULT_IP_ADDR1, DEFAULT_IP_ADDR2, DEFAULT_IP_ADDR3);
        IP4_ADDR(&netmask, DEFAULT_NETMASK_ADDR0, DEFAULT_NETMASK_ADDR1 , DEFAULT_NETMASK_ADDR2, DEFAULT_NETMASK_ADDR3);
 80036ee:	f06f 457f 	mvn.w	r5, #4278190080	; 0xff000000
    {
        ipaddr.addr = 0;
        netmask.addr = 0;
        gw.addr = 0;

        IP4_ADDR(&ipaddr, DEFAULT_IP_ADDR0, DEFAULT_IP_ADDR1, DEFAULT_IP_ADDR2, DEFAULT_IP_ADDR3);
 80036f2:	9605      	str	r6, [sp, #20]
        IP4_ADDR(&netmask, DEFAULT_NETMASK_ADDR0, DEFAULT_NETMASK_ADDR1 , DEFAULT_NETMASK_ADDR2, DEFAULT_NETMASK_ADDR3);
 80036f4:	9506      	str	r5, [sp, #24]
            IP4_ADDR(&gw,           (ACUDevInfo.DeviceInfo.NetWork.gate & 0x000000FF),          (ACUDevInfo.DeviceInfo.NetWork.gate & 0x0000FF00)>>8,
                                    (ACUDevInfo.DeviceInfo.NetWork.gate & 0x00FF0000)>>16,      (ACUDevInfo.DeviceInfo.NetWork.gate & 0xFF000000)>>24 );
        }
    }

    netif_add(&xnetif, &ipaddr, &netmask, &gw, NULL, &ethernetif_init, &tcpip_input);
 80036f6:	f000 f89d 	bl	8003834 <netif_add>
    //Registers the default network interface. 
    netif_set_default(&xnetif);
 80036fa:	4620      	mov	r0, r4
 80036fc:	f000 f8e8 	bl	80038d0 <netif_set_default>
    //BSP_ETH_IRQHandler = LwIP_SendSem;

    

    //When the netif is fully configured this function must be called
    netif_set_up(&xnetif); 
 8003700:	4620      	mov	r0, r4
 8003702:	f000 f8eb 	bl	80038dc <netif_set_up>

}
 8003706:	b008      	add	sp, #32
 8003708:	bd70      	pop	{r4, r5, r6, pc}
 800370a:	bf00      	nop
 800370c:	010301c6 	.word	0x010301c6
 8003710:	2000d910 	.word	0x2000d910
 8003714:	0800b389 	.word	0x0800b389
 8003718:	0800e6c9 	.word	0x0800e6c9
 800371c:	910301c6 	.word	0x910301c6

08003720 <LWIP_NetworkConfigChange>:
**return:
**autor:  andiman
**date:
************************************************************/
void LWIP_NetworkConfigChange(void)
{
 8003720:	b530      	push	{r4, r5, lr}
    struct ip_addr ipaddr;
    struct ip_addr netmask;
    struct ip_addr gw;
    INT8U IPbuff[4],Maskbuff[4],Gatebuff[4];

    IP4_ADDR(&ipaddr,       (ACUDevInfo.DeviceInfo.NetWork.ip_addr & 0x000000FF),       (ACUDevInfo.DeviceInfo.NetWork.ip_addr & 0x0000FF00)>>8,
 8003722:	4908      	ldr	r1, [pc, #32]	; (8003744 <LWIP_NetworkConfigChange+0x24>)
**return:
**autor:  andiman
**date:
************************************************************/
void LWIP_NetworkConfigChange(void)
{
 8003724:	b085      	sub	sp, #20

    IP4_ADDR(&ipaddr,       (ACUDevInfo.DeviceInfo.NetWork.ip_addr & 0x000000FF),       (ACUDevInfo.DeviceInfo.NetWork.ip_addr & 0x0000FF00)>>8,
                            (ACUDevInfo.DeviceInfo.NetWork.ip_addr & 0x00FF0000)>>16,   (ACUDevInfo.DeviceInfo.NetWork.ip_addr & 0xFF000000)>>24);
    IP4_ADDR(&netmask,      (ACUDevInfo.DeviceInfo.NetWork.mask & 0x000000FF),          (ACUDevInfo.DeviceInfo.NetWork.mask & 0x0000FF00)>>8,
                            (ACUDevInfo.DeviceInfo.NetWork.mask & 0x00FF0000)>>16,      (ACUDevInfo.DeviceInfo.NetWork.mask & 0xFF000000)>>24 );
    IP4_ADDR(&gw,           (ACUDevInfo.DeviceInfo.NetWork.gate & 0x000000FF),          (ACUDevInfo.DeviceInfo.NetWork.gate & 0x0000FF00)>>8,
 8003726:	69c8      	ldr	r0, [r1, #28]
    struct ip_addr ipaddr;
    struct ip_addr netmask;
    struct ip_addr gw;
    INT8U IPbuff[4],Maskbuff[4],Gatebuff[4];

    IP4_ADDR(&ipaddr,       (ACUDevInfo.DeviceInfo.NetWork.ip_addr & 0x000000FF),       (ACUDevInfo.DeviceInfo.NetWork.ip_addr & 0x0000FF00)>>8,
 8003728:	694d      	ldr	r5, [r1, #20]
                            (ACUDevInfo.DeviceInfo.NetWork.ip_addr & 0x00FF0000)>>16,   (ACUDevInfo.DeviceInfo.NetWork.ip_addr & 0xFF000000)>>24);
    IP4_ADDR(&netmask,      (ACUDevInfo.DeviceInfo.NetWork.mask & 0x000000FF),          (ACUDevInfo.DeviceInfo.NetWork.mask & 0x0000FF00)>>8,
 800372a:	698c      	ldr	r4, [r1, #24]
                            (ACUDevInfo.DeviceInfo.NetWork.mask & 0x00FF0000)>>16,      (ACUDevInfo.DeviceInfo.NetWork.mask & 0xFF000000)>>24 );
    IP4_ADDR(&gw,           (ACUDevInfo.DeviceInfo.NetWork.gate & 0x000000FF),          (ACUDevInfo.DeviceInfo.NetWork.gate & 0x0000FF00)>>8,
 800372c:	ab04      	add	r3, sp, #16
 800372e:	f843 0d04 	str.w	r0, [r3, #-4]!
                            (ACUDevInfo.DeviceInfo.NetWork.gate & 0x00FF0000)>>16,      (ACUDevInfo.DeviceInfo.NetWork.gate & 0xFF000000)>>24 );
    netif_set_addr(&xnetif, &ipaddr,&netmask,&gw);
 8003732:	aa02      	add	r2, sp, #8
 8003734:	a901      	add	r1, sp, #4
 8003736:	4804      	ldr	r0, [pc, #16]	; (8003748 <LWIP_NetworkConfigChange+0x28>)
    struct ip_addr ipaddr;
    struct ip_addr netmask;
    struct ip_addr gw;
    INT8U IPbuff[4],Maskbuff[4],Gatebuff[4];

    IP4_ADDR(&ipaddr,       (ACUDevInfo.DeviceInfo.NetWork.ip_addr & 0x000000FF),       (ACUDevInfo.DeviceInfo.NetWork.ip_addr & 0x0000FF00)>>8,
 8003738:	9501      	str	r5, [sp, #4]
                            (ACUDevInfo.DeviceInfo.NetWork.ip_addr & 0x00FF0000)>>16,   (ACUDevInfo.DeviceInfo.NetWork.ip_addr & 0xFF000000)>>24);
    IP4_ADDR(&netmask,      (ACUDevInfo.DeviceInfo.NetWork.mask & 0x000000FF),          (ACUDevInfo.DeviceInfo.NetWork.mask & 0x0000FF00)>>8,
 800373a:	9402      	str	r4, [sp, #8]
                            (ACUDevInfo.DeviceInfo.NetWork.mask & 0x00FF0000)>>16,      (ACUDevInfo.DeviceInfo.NetWork.mask & 0xFF000000)>>24 );
    IP4_ADDR(&gw,           (ACUDevInfo.DeviceInfo.NetWork.gate & 0x000000FF),          (ACUDevInfo.DeviceInfo.NetWork.gate & 0x0000FF00)>>8,
                            (ACUDevInfo.DeviceInfo.NetWork.gate & 0x00FF0000)>>16,      (ACUDevInfo.DeviceInfo.NetWork.gate & 0xFF000000)>>24 );
    netif_set_addr(&xnetif, &ipaddr,&netmask,&gw);
 800373c:	f000 f86c 	bl	8003818 <netif_set_addr>
    
}
 8003740:	b005      	add	sp, #20
 8003742:	bd30      	pop	{r4, r5, pc}
 8003744:	20004d00 	.word	0x20004d00
 8003748:	2000d910 	.word	0x2000d910

0800374c <LWIP_MACConfigChange>:
**return:
**autor:  andiman
**date:
************************************************************/
void LWIP_MACConfigChange(void)
{
 800374c:	b510      	push	{r4, lr}
    memcpy(xnetif.hwaddr,ACUDevInfo.DeviceInfo.NetWork.mac,6);
 800374e:	4c05      	ldr	r4, [pc, #20]	; (8003764 <LWIP_MACConfigChange+0x18>)
 8003750:	2206      	movs	r2, #6
 8003752:	4621      	mov	r1, r4
 8003754:	4804      	ldr	r0, [pc, #16]	; (8003768 <LWIP_MACConfigChange+0x1c>)
 8003756:	f011 fafc 	bl	8014d52 <memcpy>
    ETH_MACaddr_Config(ACUDevInfo.DeviceInfo.NetWork.mac);
 800375a:	4620      	mov	r0, r4
}
 800375c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
**date:
************************************************************/
void LWIP_MACConfigChange(void)
{
    memcpy(xnetif.hwaddr,ACUDevInfo.DeviceInfo.NetWork.mac,6);
    ETH_MACaddr_Config(ACUDevInfo.DeviceInfo.NetWork.mac);
 8003760:	f009 bed4 	b.w	800d50c <ETH_MACaddr_Config>
 8003764:	20004d20 	.word	0x20004d20
 8003768:	2000d933 	.word	0x2000d933

0800376c <netif_init>:
}
#endif /* LWIP_HAVE_LOOPIF */

void
netif_init(void)
{
 800376c:	4770      	bx	lr
 800376e:	bf00      	nop

08003770 <netif_find>:
netif_find(char *name)
{
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
 8003770:	b1c8      	cbz	r0, 80037a6 <netif_find+0x36>
    return NULL;
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
 8003772:	4b0e      	ldr	r3, [pc, #56]	; (80037ac <netif_find+0x3c>)

  if (name == NULL) {
    return NULL;
  }

  num = name[2] - '0';
 8003774:	7881      	ldrb	r1, [r0, #2]

  for(netif = netif_list; netif != NULL; netif = netif->next) {
 8003776:	681b      	ldr	r3, [r3, #0]

  if (name == NULL) {
    return NULL;
  }

  num = name[2] - '0';
 8003778:	3930      	subs	r1, #48	; 0x30
 800377a:	b2c9      	uxtb	r1, r1

  for(netif = netif_list; netif != NULL; netif = netif->next) {
 800377c:	b1a3      	cbz	r3, 80037a8 <netif_find+0x38>
 * @param name the name of the netif (like netif->name) plus concatenated number
 * in ascii representation (e.g. 'en0')
 */
struct netif *
netif_find(char *name)
{
 800377e:	b410      	push	{r4}
 8003780:	e001      	b.n	8003786 <netif_find+0x16>
    return NULL;
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
 8003782:	681b      	ldr	r3, [r3, #0]
 8003784:	b16b      	cbz	r3, 80037a2 <netif_find+0x32>
    if (num == netif->num &&
 8003786:	f893 202c 	ldrb.w	r2, [r3, #44]	; 0x2c
 800378a:	428a      	cmp	r2, r1
 800378c:	d1f9      	bne.n	8003782 <netif_find+0x12>
 800378e:	7804      	ldrb	r4, [r0, #0]
 8003790:	f893 202a 	ldrb.w	r2, [r3, #42]	; 0x2a
 8003794:	4294      	cmp	r4, r2
 8003796:	d1f4      	bne.n	8003782 <netif_find+0x12>
       name[0] == netif->name[0] &&
 8003798:	7844      	ldrb	r4, [r0, #1]
 800379a:	f893 202b 	ldrb.w	r2, [r3, #43]	; 0x2b
 800379e:	4294      	cmp	r4, r2
 80037a0:	d1ef      	bne.n	8003782 <netif_find+0x12>
      return netif;
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
}
 80037a2:	bc10      	pop	{r4}
 80037a4:	4618      	mov	r0, r3
 80037a6:	4770      	bx	lr
{
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
    return NULL;
 80037a8:	4618      	mov	r0, r3
      return netif;
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
}
 80037aa:	4770      	bx	lr
 80037ac:	2000d940 	.word	0x2000d940

080037b0 <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, ip_addr_t *ipaddr)
{
 80037b0:	b570      	push	{r4, r5, r6, lr}
 80037b2:	4604      	mov	r4, r0
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
 80037b4:	460e      	mov	r6, r1
 80037b6:	b329      	cbz	r1, 8003804 <netif_set_ipaddr+0x54>
 80037b8:	680b      	ldr	r3, [r1, #0]
 80037ba:	6842      	ldr	r2, [r0, #4]
 80037bc:	4293      	cmp	r3, r2
 80037be:	d01f      	beq.n	8003800 <netif_set_ipaddr+0x50>
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
 80037c0:	4913      	ldr	r1, [pc, #76]	; (8003810 <netif_set_ipaddr+0x60>)
 80037c2:	6808      	ldr	r0, [r1, #0]
    while (pcb != NULL) {
 80037c4:	b308      	cbz	r0, 800380a <netif_set_ipaddr+0x5a>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))
 80037c6:	6803      	ldr	r3, [r0, #0]
 80037c8:	4293      	cmp	r3, r2
 80037ca:	d005      	beq.n	80037d8 <netif_set_ipaddr+0x28>
        struct tcp_pcb *next = pcb->next;
        LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
        pcb = next;
      } else {
        pcb = pcb->next;
 80037cc:	68c0      	ldr	r0, [r0, #12]
  /* address is actually being changed? */
  if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
 80037ce:	b148      	cbz	r0, 80037e4 <netif_set_ipaddr+0x34>
 80037d0:	6862      	ldr	r2, [r4, #4]
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))
 80037d2:	6803      	ldr	r3, [r0, #0]
 80037d4:	4293      	cmp	r3, r2
 80037d6:	d1f9      	bne.n	80037cc <netif_set_ipaddr+0x1c>
        /* connections to link-local addresses must persist (RFC3927 ch. 1.9) */
        && !ip_addr_islinklocal(&(pcb->local_ip))
#endif /* LWIP_AUTOIP */
        ) {
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
 80037d8:	68c5      	ldr	r5, [r0, #12]
        LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
 80037da:	f006 fd75 	bl	800a2c8 <tcp_abort>
        pcb = next;
 80037de:	4628      	mov	r0, r5
  /* address is actually being changed? */
  if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
 80037e0:	2800      	cmp	r0, #0
 80037e2:	d1f5      	bne.n	80037d0 <netif_set_ipaddr+0x20>
 80037e4:	6832      	ldr	r2, [r6, #0]
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 80037e6:	4b0b      	ldr	r3, [pc, #44]	; (8003814 <netif_set_ipaddr+0x64>)
 80037e8:	681b      	ldr	r3, [r3, #0]
 80037ea:	b14b      	cbz	r3, 8003800 <netif_set_ipaddr+0x50>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
 80037ec:	6818      	ldr	r0, [r3, #0]
 80037ee:	b120      	cbz	r0, 80037fa <netif_set_ipaddr+0x4a>
 80037f0:	6865      	ldr	r5, [r4, #4]
 80037f2:	42a8      	cmp	r0, r5
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
 80037f4:	bf04      	itt	eq
 80037f6:	601a      	streq	r2, [r3, #0]
 80037f8:	6832      	ldreq	r2, [r6, #0]
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 80037fa:	68db      	ldr	r3, [r3, #12]
 80037fc:	2b00      	cmp	r3, #0
 80037fe:	d1f5      	bne.n	80037ec <netif_set_ipaddr+0x3c>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
 8003800:	6062      	str	r2, [r4, #4]
 8003802:	bd70      	pop	{r4, r5, r6, pc}
 8003804:	460a      	mov	r2, r1
 8003806:	6062      	str	r2, [r4, #4]
 8003808:	bd70      	pop	{r4, r5, r6, pc}
  /* address is actually being changed? */
  if (ipaddr && (ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0) {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
 800380a:	461a      	mov	r2, r3
 800380c:	e7eb      	b.n	80037e6 <netif_set_ipaddr+0x36>
 800380e:	bf00      	nop
 8003810:	2000f040 	.word	0x2000f040
 8003814:	2000f048 	.word	0x2000f048

08003818 <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
    ip_addr_t *gw)
{
 8003818:	b570      	push	{r4, r5, r6, lr}
 800381a:	4614      	mov	r4, r2
 800381c:	461d      	mov	r5, r3
 800381e:	4606      	mov	r6, r0
  netif_set_ipaddr(netif, ipaddr);
 8003820:	f7ff ffc6 	bl	80037b0 <netif_set_ipaddr>
void
netif_set_netmask(struct netif *netif, ip_addr_t *netmask)
{
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
 8003824:	b104      	cbz	r4, 8003828 <netif_set_addr+0x10>
 8003826:	6824      	ldr	r4, [r4, #0]
 8003828:	60b4      	str	r4, [r6, #8]
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, ip_addr_t *gw)
{
  ip_addr_set(&(netif->gw), gw);
 800382a:	b105      	cbz	r5, 800382e <netif_set_addr+0x16>
 800382c:	682d      	ldr	r5, [r5, #0]
 800382e:	60f5      	str	r5, [r6, #12]
 8003830:	bd70      	pop	{r4, r5, r6, pc}
 8003832:	bf00      	nop

08003834 <netif_add>:
 * @return netif, or NULL if failed.
 */
struct netif *
netif_add(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
  ip_addr_t *gw, void *state, netif_init_fn init, netif_input_fn input)
{
 8003834:	e92d 44f0 	stmdb	sp!, {r4, r5, r6, r7, sl, lr}
 8003838:	9e07      	ldr	r6, [sp, #28]
 800383a:	4604      	mov	r4, r0
 800383c:	468a      	mov	sl, r1
 800383e:	4617      	mov	r7, r2
 8003840:	461d      	mov	r5, r3

  LWIP_ASSERT("No init function given", init != NULL);
 8003842:	b35e      	cbz	r6, 800389c <netif_add+0x68>
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  netif->num = netif_num++;
 8003844:	f8df e074 	ldr.w	lr, [pc, #116]	; 80038bc <netif_add+0x88>
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
 8003848:	9b06      	ldr	r3, [sp, #24]
  netif->num = netif_num++;
  netif->input = input;
 800384a:	9a08      	ldr	r2, [sp, #32]
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
 800384c:	61e3      	str	r3, [r4, #28]
  netif->num = netif_num++;
 800384e:	f89e 3000 	ldrb.w	r3, [lr]
  netif->input = input;
 8003852:	6122      	str	r2, [r4, #16]
{

  LWIP_ASSERT("No init function given", init != NULL);

  /* reset new interface configuration state */
  ip_addr_set_zero(&netif->ip_addr);
 8003854:	2200      	movs	r2, #0
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  netif->num = netif_num++;
 8003856:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
 */
void
netif_set_addr(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
    ip_addr_t *gw)
{
  netif_set_ipaddr(netif, ipaddr);
 800385a:	4651      	mov	r1, sl
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  netif->num = netif_num++;
 800385c:	3301      	adds	r3, #1
{

  LWIP_ASSERT("No init function given", init != NULL);

  /* reset new interface configuration state */
  ip_addr_set_zero(&netif->ip_addr);
 800385e:	6062      	str	r2, [r4, #4]
  ip_addr_set_zero(&netif->netmask);
 8003860:	60a2      	str	r2, [r4, #8]
  ip_addr_set_zero(&netif->gw);
 8003862:	60e2      	str	r2, [r4, #12]
  netif->flags = 0;
 8003864:	f884 2029 	strb.w	r2, [r4, #41]	; 0x29
 */
void
netif_set_addr(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
    ip_addr_t *gw)
{
  netif_set_ipaddr(netif, ipaddr);
 8003868:	4620      	mov	r0, r4
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  netif->num = netif_num++;
 800386a:	f88e 3000 	strb.w	r3, [lr]
 */
void
netif_set_addr(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
    ip_addr_t *gw)
{
  netif_set_ipaddr(netif, ipaddr);
 800386e:	f7ff ff9f 	bl	80037b0 <netif_set_ipaddr>
void
netif_set_netmask(struct netif *netif, ip_addr_t *netmask)
{
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
 8003872:	b177      	cbz	r7, 8003892 <netif_add+0x5e>
 8003874:	683b      	ldr	r3, [r7, #0]
 8003876:	60a3      	str	r3, [r4, #8]
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, ip_addr_t *gw)
{
  ip_addr_set(&(netif->gw), gw);
 8003878:	b105      	cbz	r5, 800387c <netif_add+0x48>
 800387a:	682d      	ldr	r5, [r5, #0]
 800387c:	60e5      	str	r5, [r4, #12]
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
 800387e:	4620      	mov	r0, r4
 8003880:	47b0      	blx	r6
 8003882:	b940      	cbnz	r0, 8003896 <netif_add+0x62>
    return NULL;
  }

  /* add this netif to the list */
  netif->next = netif_list;
 8003884:	4b09      	ldr	r3, [pc, #36]	; (80038ac <netif_add+0x78>)
  LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
 8003886:	4620      	mov	r0, r4
  if (init(netif) != ERR_OK) {
    return NULL;
  }

  /* add this netif to the list */
  netif->next = netif_list;
 8003888:	681a      	ldr	r2, [r3, #0]
 800388a:	6022      	str	r2, [r4, #0]
  netif_list = netif;
 800388c:	601c      	str	r4, [r3, #0]
  LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
 800388e:	e8bd 84f0 	ldmia.w	sp!, {r4, r5, r6, r7, sl, pc}
void
netif_set_netmask(struct netif *netif, ip_addr_t *netmask)
{
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
 8003892:	463b      	mov	r3, r7
 8003894:	e7ef      	b.n	8003876 <netif_add+0x42>

  netif_set_addr(netif, ipaddr, netmask, gw);

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
    return NULL;
 8003896:	2000      	movs	r0, #0
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
}
 8003898:	e8bd 84f0 	ldmia.w	sp!, {r4, r5, r6, r7, sl, pc}
struct netif *
netif_add(struct netif *netif, ip_addr_t *ipaddr, ip_addr_t *netmask,
  ip_addr_t *gw, void *state, netif_init_fn init, netif_input_fn input)
{

  LWIP_ASSERT("No init function given", init != NULL);
 800389c:	4b04      	ldr	r3, [pc, #16]	; (80038b0 <netif_add+0x7c>)
 800389e:	228f      	movs	r2, #143	; 0x8f
 80038a0:	4904      	ldr	r1, [pc, #16]	; (80038b4 <netif_add+0x80>)
 80038a2:	4805      	ldr	r0, [pc, #20]	; (80038b8 <netif_add+0x84>)
 80038a4:	f011 fa68 	bl	8014d78 <iprintf>
 80038a8:	e7cc      	b.n	8003844 <netif_add+0x10>
 80038aa:	bf00      	nop
 80038ac:	2000d940 	.word	0x2000d940
 80038b0:	080165e0 	.word	0x080165e0
 80038b4:	080165f4 	.word	0x080165f4
 80038b8:	0801660c 	.word	0x0801660c
 80038bc:	200007a6 	.word	0x200007a6

080038c0 <netif_set_gw>:
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, ip_addr_t *gw)
{
  ip_addr_set(&(netif->gw), gw);
 80038c0:	b101      	cbz	r1, 80038c4 <netif_set_gw+0x4>
 80038c2:	6809      	ldr	r1, [r1, #0]
 80038c4:	60c1      	str	r1, [r0, #12]
 80038c6:	4770      	bx	lr

080038c8 <netif_set_netmask>:
void
netif_set_netmask(struct netif *netif, ip_addr_t *netmask)
{
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
 80038c8:	b101      	cbz	r1, 80038cc <netif_set_netmask+0x4>
 80038ca:	6809      	ldr	r1, [r1, #0]
 80038cc:	6081      	str	r1, [r0, #8]
 80038ce:	4770      	bx	lr

080038d0 <netif_set_default>:
    snmp_delete_iprteidx_tree(1, netif);
  } else {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
 80038d0:	4b01      	ldr	r3, [pc, #4]	; (80038d8 <netif_set_default+0x8>)
 80038d2:	6018      	str	r0, [r3, #0]
 80038d4:	4770      	bx	lr
 80038d6:	bf00      	nop
 80038d8:	2000d944 	.word	0x2000d944

080038dc <netif_set_up>:
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  if (!(netif->flags & NETIF_FLAG_UP)) {
 80038dc:	f890 3029 	ldrb.w	r3, [r0, #41]	; 0x29
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
 80038e0:	4601      	mov	r1, r0
  if (!(netif->flags & NETIF_FLAG_UP)) {
 80038e2:	07da      	lsls	r2, r3, #31
 80038e4:	d407      	bmi.n	80038f6 <netif_set_up+0x1a>
    netif->flags |= NETIF_FLAG_UP;
 80038e6:	f043 0201 	orr.w	r2, r3, #1
    NETIF_STATUS_CALLBACK(netif);

    if (netif->flags & NETIF_FLAG_LINK_UP) {
#if LWIP_ARP
      /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */ 
      if (netif->flags & (NETIF_FLAG_ETHARP)) {
 80038ea:	f003 0330 	and.w	r3, r3, #48	; 0x30
 80038ee:	2b30      	cmp	r3, #48	; 0x30
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  if (!(netif->flags & NETIF_FLAG_UP)) {
    netif->flags |= NETIF_FLAG_UP;
 80038f0:	f880 2029 	strb.w	r2, [r0, #41]	; 0x29
    NETIF_STATUS_CALLBACK(netif);

    if (netif->flags & NETIF_FLAG_LINK_UP) {
#if LWIP_ARP
      /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */ 
      if (netif->flags & (NETIF_FLAG_ETHARP)) {
 80038f4:	d000      	beq.n	80038f8 <netif_set_up+0x1c>
 80038f6:	4770      	bx	lr
        etharp_gratuitous(netif);
 80038f8:	3104      	adds	r1, #4
 80038fa:	f00a bd97 	b.w	800e42c <etharp_request>
 80038fe:	bf00      	nop

08003900 <netif_set_down>:
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  if (netif->flags & NETIF_FLAG_UP) {
 8003900:	f890 3029 	ldrb.w	r3, [r0, #41]	; 0x29
 8003904:	07d9      	lsls	r1, r3, #31
 8003906:	d505      	bpl.n	8003914 <netif_set_down+0x14>
    netif->flags &= ~NETIF_FLAG_UP;
 8003908:	f023 0101 	bic.w	r1, r3, #1
#if LWIP_SNMP
    snmp_get_sysuptime(&netif->ts);
#endif

#if LWIP_ARP
    if (netif->flags & NETIF_FLAG_ETHARP) {
 800390c:	069b      	lsls	r3, r3, #26
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  if (netif->flags & NETIF_FLAG_UP) {
    netif->flags &= ~NETIF_FLAG_UP;
 800390e:	f880 1029 	strb.w	r1, [r0, #41]	; 0x29
#if LWIP_SNMP
    snmp_get_sysuptime(&netif->ts);
#endif

#if LWIP_ARP
    if (netif->flags & NETIF_FLAG_ETHARP) {
 8003912:	d400      	bmi.n	8003916 <netif_set_down+0x16>
 8003914:	4770      	bx	lr
      etharp_cleanup_netif(netif);
 8003916:	f00a bbe3 	b.w	800e0e0 <etharp_cleanup_netif>
 800391a:	bf00      	nop

0800391c <netif_remove>:
 * @param netif the network interface to remove
 */
void
netif_remove(struct netif *netif)
{
  if (netif == NULL) {
 800391c:	b310      	cbz	r0, 8003964 <netif_remove+0x48>
  /* stop IGMP processing */
  if (netif->flags & NETIF_FLAG_IGMP) {
    igmp_stop(netif);
  }
#endif /* LWIP_IGMP */
  if (netif_is_up(netif)) {
 800391e:	f890 3029 	ldrb.w	r3, [r0, #41]	; 0x29
 *
 * @param netif the network interface to remove
 */
void
netif_remove(struct netif *netif)
{
 8003922:	b510      	push	{r4, lr}
  /* stop IGMP processing */
  if (netif->flags & NETIF_FLAG_IGMP) {
    igmp_stop(netif);
  }
#endif /* LWIP_IGMP */
  if (netif_is_up(netif)) {
 8003924:	07db      	lsls	r3, r3, #31
 8003926:	4604      	mov	r4, r0
 8003928:	d419      	bmi.n	800395e <netif_remove+0x42>
  }

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
 800392a:	4b0f      	ldr	r3, [pc, #60]	; (8003968 <netif_remove+0x4c>)
 800392c:	681a      	ldr	r2, [r3, #0]
 800392e:	4294      	cmp	r4, r2
 8003930:	d00c      	beq.n	800394c <netif_remove+0x30>
    netif_list = netif->next;
  } else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
 8003932:	b19a      	cbz	r2, 800395c <netif_remove+0x40>
      if (tmpNetif->next == netif) {
 8003934:	6813      	ldr	r3, [r2, #0]
 8003936:	429c      	cmp	r4, r3
 8003938:	d007      	beq.n	800394a <netif_remove+0x2e>
  if (netif_list == netif) {
    netif_list = netif->next;
  } else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
 800393a:	b12b      	cbz	r3, 8003948 <netif_remove+0x2c>
      if (tmpNetif->next == netif) {
 800393c:	681a      	ldr	r2, [r3, #0]
 800393e:	4294      	cmp	r4, r2
 8003940:	d004      	beq.n	800394c <netif_remove+0x30>
 8003942:	4613      	mov	r3, r2
  if (netif_list == netif) {
    netif_list = netif->next;
  } else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
 8003944:	2b00      	cmp	r3, #0
 8003946:	d1f9      	bne.n	800393c <netif_remove+0x20>
 8003948:	bd10      	pop	{r4, pc}
      if (tmpNetif->next == netif) {
 800394a:	4613      	mov	r3, r2
        tmpNetif->next = netif->next;
 800394c:	6822      	ldr	r2, [r4, #0]
 800394e:	601a      	str	r2, [r3, #0]
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
  }
  snmp_dec_iflist();
  /* this netif is default? */
  if (netif_default == netif) {
 8003950:	4b06      	ldr	r3, [pc, #24]	; (800396c <netif_remove+0x50>)
 8003952:	681a      	ldr	r2, [r3, #0]
 8003954:	4294      	cmp	r4, r2
 8003956:	d101      	bne.n	800395c <netif_remove+0x40>
    snmp_delete_iprteidx_tree(1, netif);
  } else {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
 8003958:	2200      	movs	r2, #0
 800395a:	601a      	str	r2, [r3, #0]
 800395c:	bd10      	pop	{r4, pc}
    igmp_stop(netif);
  }
#endif /* LWIP_IGMP */
  if (netif_is_up(netif)) {
    /* set netif down before removing (call callback function) */
    netif_set_down(netif);
 800395e:	f7ff ffcf 	bl	8003900 <netif_set_down>
 8003962:	e7e2      	b.n	800392a <netif_remove+0xe>
 8003964:	4770      	bx	lr
 8003966:	bf00      	nop
 8003968:	2000d940 	.word	0x2000d940
 800396c:	2000d944 	.word	0x2000d944

08003970 <netif_set_link_up>:
/**
 * Called by a driver when its link goes up
 */
void netif_set_link_up(struct netif *netif )
{
  if (!(netif->flags & NETIF_FLAG_LINK_UP)) {
 8003970:	f890 3029 	ldrb.w	r3, [r0, #41]	; 0x29

/**
 * Called by a driver when its link goes up
 */
void netif_set_link_up(struct netif *netif )
{
 8003974:	4601      	mov	r1, r0
  if (!(netif->flags & NETIF_FLAG_LINK_UP)) {
 8003976:	06da      	lsls	r2, r3, #27
 8003978:	d407      	bmi.n	800398a <netif_set_link_up+0x1a>
    netif->flags |= NETIF_FLAG_LINK_UP;
 800397a:	f043 0210 	orr.w	r2, r3, #16
#endif /* LWIP_AUTOIP */

    if (netif->flags & NETIF_FLAG_UP) {
#if LWIP_ARP
      /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */ 
      if (netif->flags & NETIF_FLAG_ETHARP) {
 800397e:	f003 0321 	and.w	r3, r3, #33	; 0x21
 8003982:	2b21      	cmp	r3, #33	; 0x21
 * Called by a driver when its link goes up
 */
void netif_set_link_up(struct netif *netif )
{
  if (!(netif->flags & NETIF_FLAG_LINK_UP)) {
    netif->flags |= NETIF_FLAG_LINK_UP;
 8003984:	f880 2029 	strb.w	r2, [r0, #41]	; 0x29
#endif /* LWIP_AUTOIP */

    if (netif->flags & NETIF_FLAG_UP) {
#if LWIP_ARP
      /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */ 
      if (netif->flags & NETIF_FLAG_ETHARP) {
 8003988:	d000      	beq.n	800398c <netif_set_link_up+0x1c>
 800398a:	4770      	bx	lr
        etharp_gratuitous(netif);
 800398c:	3104      	adds	r1, #4
 800398e:	f00a bd4d 	b.w	800e42c <etharp_request>
 8003992:	bf00      	nop

08003994 <netif_set_link_down>:
/**
 * Called by a driver when its link goes down
 */
void netif_set_link_down(struct netif *netif )
{
  if (netif->flags & NETIF_FLAG_LINK_UP) {
 8003994:	f890 3029 	ldrb.w	r3, [r0, #41]	; 0x29
 8003998:	06da      	lsls	r2, r3, #27
    netif->flags &= ~NETIF_FLAG_LINK_UP;
 800399a:	bf44      	itt	mi
 800399c:	f023 0310 	bicmi.w	r3, r3, #16
 80039a0:	f880 3029 	strbmi.w	r3, [r0, #41]	; 0x29
 80039a4:	4770      	bx	lr
 80039a6:	bf00      	nop

080039a8 <OSCfg_Init>:
*                  DOES NOT optimize out the 'const' variables above.
************************************************************************************************************************
*/

void  OSCfg_Init (void)
{
 80039a8:	4770      	bx	lr
 80039aa:	bf00      	nop

080039ac <OS_IdleTask>:
*              3) This hook has been added to allow you to do such things as STOP the CPU to conserve power.
************************************************************************************************************************
*/

void  OS_IdleTask (void  *p_arg)
{
 80039ac:	b538      	push	{r3, r4, r5, lr}
 80039ae:	4d07      	ldr	r5, [pc, #28]	; (80039cc <OS_IdleTask+0x20>)
 80039b0:	4c07      	ldr	r4, [pc, #28]	; (80039d0 <OS_IdleTask+0x24>)


    p_arg = p_arg;                                          /* Prevent compiler warning for not using 'p_arg'         */

    while (DEF_ON) {
        CPU_CRITICAL_ENTER();
 80039b2:	f7fd fedf 	bl	8001774 <CPU_SR_Save>
        OSIdleTaskCtr++;
 80039b6:	682a      	ldr	r2, [r5, #0]
#if OS_CFG_STAT_TASK_EN > 0u
        OSStatTaskCtr++;
 80039b8:	6823      	ldr	r3, [r4, #0]

    p_arg = p_arg;                                          /* Prevent compiler warning for not using 'p_arg'         */

    while (DEF_ON) {
        CPU_CRITICAL_ENTER();
        OSIdleTaskCtr++;
 80039ba:	3201      	adds	r2, #1
#if OS_CFG_STAT_TASK_EN > 0u
        OSStatTaskCtr++;
 80039bc:	3301      	adds	r3, #1

    p_arg = p_arg;                                          /* Prevent compiler warning for not using 'p_arg'         */

    while (DEF_ON) {
        CPU_CRITICAL_ENTER();
        OSIdleTaskCtr++;
 80039be:	602a      	str	r2, [r5, #0]
#if OS_CFG_STAT_TASK_EN > 0u
        OSStatTaskCtr++;
 80039c0:	6023      	str	r3, [r4, #0]
#endif
        CPU_CRITICAL_EXIT();
 80039c2:	f7fd fedb 	bl	800177c <CPU_SR_Restore>

        OSIdleTaskHook();                                   /* Call user definable HOOK                               */
 80039c6:	f000 ff55 	bl	8004874 <OSIdleTaskHook>
 80039ca:	e7f2      	b.n	80039b2 <OS_IdleTask+0x6>
 80039cc:	2000ef40 	.word	0x2000ef40
 80039d0:	2000e980 	.word	0x2000e980

080039d4 <OSSched.part.0>:
*
* Note(s)    : 1) Rescheduling is prevented when the scheduler is locked (see OSSchedLock())
************************************************************************************************************************
*/

void  OSSched (void)
 80039d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

    if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {        /* Scheduler locked?                                      */
        return;                                             /* Yes                                                    */
    }

    CPU_INT_DIS();
 80039d6:	f7fd fecd 	bl	8001774 <CPU_SR_Save>
 80039da:	4605      	mov	r5, r0
    OSPrioHighRdy   = OS_PrioGetHighest();                  /* Find the highest priority ready                        */
 80039dc:	f001 fed8 	bl	8005790 <OS_PrioGetHighest>
    OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;
 80039e0:	4b11      	ldr	r3, [pc, #68]	; (8003a28 <OSSched.part.0+0x54>)
    if (OSTCBHighRdyPtr == OSTCBCurPtr) {                   /* Current task is still highest priority task?           */
 80039e2:	4a12      	ldr	r2, [pc, #72]	; (8003a2c <OSSched.part.0+0x58>)
        return;                                             /* Yes                                                    */
    }

    CPU_INT_DIS();
    OSPrioHighRdy   = OS_PrioGetHighest();                  /* Find the highest priority ready                        */
    OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;
 80039e4:	eb00 0140 	add.w	r1, r0, r0, lsl #1
 80039e8:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    if (OSTCBHighRdyPtr == OSTCBCurPtr) {                   /* Current task is still highest priority task?           */
 80039ec:	6812      	ldr	r2, [r2, #0]
    if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {        /* Scheduler locked?                                      */
        return;                                             /* Yes                                                    */
    }

    CPU_INT_DIS();
    OSPrioHighRdy   = OS_PrioGetHighest();                  /* Find the highest priority ready                        */
 80039ee:	4c10      	ldr	r4, [pc, #64]	; (8003a30 <OSSched.part.0+0x5c>)
    OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;
 80039f0:	4910      	ldr	r1, [pc, #64]	; (8003a34 <OSSched.part.0+0x60>)
    if (OSTCBHighRdyPtr == OSTCBCurPtr) {                   /* Current task is still highest priority task?           */
 80039f2:	4293      	cmp	r3, r2
    if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {        /* Scheduler locked?                                      */
        return;                                             /* Yes                                                    */
    }

    CPU_INT_DIS();
    OSPrioHighRdy   = OS_PrioGetHighest();                  /* Find the highest priority ready                        */
 80039f4:	7020      	strb	r0, [r4, #0]
    OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;
 80039f6:	600b      	str	r3, [r1, #0]
    if (OSTCBHighRdyPtr == OSTCBCurPtr) {                   /* Current task is still highest priority task?           */
 80039f8:	d011      	beq.n	8003a1e <OSSched.part.0+0x4a>
    }

#if OS_CFG_TASK_PROFILE_EN > 0u
    OSTCBHighRdyPtr->CtxSwCtr++;                            /* Inc. # of context switches to this task                */
#endif
    OSTaskCtxSwCtr++;                                       /* Increment context switch counter                       */
 80039fa:	4c0f      	ldr	r4, [pc, #60]	; (8003a38 <OSSched.part.0+0x64>)
        CPU_INT_EN();                                       /* Yes ... no need to context switch                      */
        return;
    }

#if OS_CFG_TASK_PROFILE_EN > 0u
    OSTCBHighRdyPtr->CtxSwCtr++;                            /* Inc. # of context switches to this task                */
 80039fc:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
#endif
    OSTaskCtxSwCtr++;                                       /* Increment context switch counter                       */
 8003a00:	6821      	ldr	r1, [r4, #0]

#if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
    OS_TLS_TaskSw();
#endif

    OS_TASK_SW();                                           /* Perform a task level context switch                    */
 8003a02:	4e0e      	ldr	r6, [pc, #56]	; (8003a3c <OSSched.part.0+0x68>)
 8003a04:	f04f 5780 	mov.w	r7, #268435456	; 0x10000000
    }

#if OS_CFG_TASK_PROFILE_EN > 0u
    OSTCBHighRdyPtr->CtxSwCtr++;                            /* Inc. # of context switches to this task                */
#endif
    OSTaskCtxSwCtr++;                                       /* Increment context switch counter                       */
 8003a08:	3101      	adds	r1, #1
        CPU_INT_EN();                                       /* Yes ... no need to context switch                      */
        return;
    }

#if OS_CFG_TASK_PROFILE_EN > 0u
    OSTCBHighRdyPtr->CtxSwCtr++;                            /* Inc. # of context switches to this task                */
 8003a0a:	3201      	adds	r2, #1
#endif
    OSTaskCtxSwCtr++;                                       /* Increment context switch counter                       */
 8003a0c:	6021      	str	r1, [r4, #0]
        CPU_INT_EN();                                       /* Yes ... no need to context switch                      */
        return;
    }

#if OS_CFG_TASK_PROFILE_EN > 0u
    OSTCBHighRdyPtr->CtxSwCtr++;                            /* Inc. # of context switches to this task                */
 8003a0e:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
#if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
    OS_TLS_TaskSw();
#endif

    OS_TASK_SW();                                           /* Perform a task level context switch                    */
    CPU_INT_EN();
 8003a12:	4628      	mov	r0, r5

#if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
    OS_TLS_TaskSw();
#endif

    OS_TASK_SW();                                           /* Perform a task level context switch                    */
 8003a14:	6037      	str	r7, [r6, #0]
    CPU_INT_EN();
}
 8003a16:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
#if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
    OS_TLS_TaskSw();
#endif

    OS_TASK_SW();                                           /* Perform a task level context switch                    */
    CPU_INT_EN();
 8003a1a:	f7fd beaf 	b.w	800177c <CPU_SR_Restore>

    CPU_INT_DIS();
    OSPrioHighRdy   = OS_PrioGetHighest();                  /* Find the highest priority ready                        */
    OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;
    if (OSTCBHighRdyPtr == OSTCBCurPtr) {                   /* Current task is still highest priority task?           */
        CPU_INT_EN();                                       /* Yes ... no need to context switch                      */
 8003a1e:	4628      	mov	r0, r5
    OS_TLS_TaskSw();
#endif

    OS_TASK_SW();                                           /* Perform a task level context switch                    */
    CPU_INT_EN();
}
 8003a20:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}

    CPU_INT_DIS();
    OSPrioHighRdy   = OS_PrioGetHighest();                  /* Find the highest priority ready                        */
    OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;
    if (OSTCBHighRdyPtr == OSTCBCurPtr) {                   /* Current task is still highest priority task?           */
        CPU_INT_EN();                                       /* Yes ... no need to context switch                      */
 8003a24:	f7fd beaa 	b.w	800177c <CPU_SR_Restore>
 8003a28:	2000e988 	.word	0x2000e988
 8003a2c:	2000ed58 	.word	0x2000ed58
 8003a30:	2000ec7c 	.word	0x2000ec7c
 8003a34:	2000ed64 	.word	0x2000ed64
 8003a38:	2000ed80 	.word	0x2000ed80
 8003a3c:	e000ed04 	.word	0xe000ed04

08003a40 <OS_SchedLockTimeMeasStop.part.5>:
}




void  OS_SchedLockTimeMeasStop (void)
 8003a40:	b508      	push	{r3, lr}
{
    CPU_TS_TMR  delta;


    if (OSSchedLockNestingCtr == (OS_NESTING_CTR)0) {       /* Make sure we fully un-nested scheduler lock            */
        delta = CPU_TS_TmrRd()                              /* Compute the delta time between begin and end           */
 8003a42:	f7fd f8a3 	bl	8000b8c <CPU_TS_TmrRd>
              - OSSchedLockTimeBegin;
 8003a46:	4b07      	ldr	r3, [pc, #28]	; (8003a64 <OS_SchedLockTimeMeasStop.part.5+0x24>)
        if (OSSchedLockTimeMax    < delta) {                /* Detect peak value                                      */
 8003a48:	4a07      	ldr	r2, [pc, #28]	; (8003a68 <OS_SchedLockTimeMeasStop.part.5+0x28>)
{
    CPU_TS_TMR  delta;


    if (OSSchedLockNestingCtr == (OS_NESTING_CTR)0) {       /* Make sure we fully un-nested scheduler lock            */
        delta = CPU_TS_TmrRd()                              /* Compute the delta time between begin and end           */
 8003a4a:	681b      	ldr	r3, [r3, #0]
              - OSSchedLockTimeBegin;
        if (OSSchedLockTimeMax    < delta) {                /* Detect peak value                                      */
 8003a4c:	6811      	ldr	r1, [r2, #0]
{
    CPU_TS_TMR  delta;


    if (OSSchedLockNestingCtr == (OS_NESTING_CTR)0) {       /* Make sure we fully un-nested scheduler lock            */
        delta = CPU_TS_TmrRd()                              /* Compute the delta time between begin and end           */
 8003a4e:	1ac0      	subs	r0, r0, r3
              - OSSchedLockTimeBegin;
        if (OSSchedLockTimeMax    < delta) {                /* Detect peak value                                      */
            OSSchedLockTimeMax    = delta;
        }
        if (OSSchedLockTimeMaxCur < delta) {                /* Detect peak value (for resettable value)               */
 8003a50:	4b06      	ldr	r3, [pc, #24]	; (8003a6c <OS_SchedLockTimeMeasStop.part.5+0x2c>)


    if (OSSchedLockNestingCtr == (OS_NESTING_CTR)0) {       /* Make sure we fully un-nested scheduler lock            */
        delta = CPU_TS_TmrRd()                              /* Compute the delta time between begin and end           */
              - OSSchedLockTimeBegin;
        if (OSSchedLockTimeMax    < delta) {                /* Detect peak value                                      */
 8003a52:	4288      	cmp	r0, r1
            OSSchedLockTimeMax    = delta;
 8003a54:	bf88      	it	hi
 8003a56:	6010      	strhi	r0, [r2, #0]
        }
        if (OSSchedLockTimeMaxCur < delta) {                /* Detect peak value (for resettable value)               */
 8003a58:	681a      	ldr	r2, [r3, #0]
 8003a5a:	4290      	cmp	r0, r2
            OSSchedLockTimeMaxCur = delta;
 8003a5c:	bf88      	it	hi
 8003a5e:	6018      	strhi	r0, [r3, #0]
 8003a60:	bd08      	pop	{r3, pc}
 8003a62:	bf00      	nop
 8003a64:	2000ed54 	.word	0x2000ed54
 8003a68:	2000ef54 	.word	0x2000ef54
 8003a6c:	2000ed68 	.word	0x2000ed68

08003a70 <OSIntEnter>:
************************************************************************************************************************
*/

void  OSIntEnter (void)
{
    if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Is OS running?                                         */
 8003a70:	4b05      	ldr	r3, [pc, #20]	; (8003a88 <OSIntEnter+0x18>)
 8003a72:	781b      	ldrb	r3, [r3, #0]
 8003a74:	2b01      	cmp	r3, #1
 8003a76:	d105      	bne.n	8003a84 <OSIntEnter+0x14>
        return;                                             /* No                                                     */
    }

    if (OSIntNestingCtr >= (OS_NESTING_CTR)250u) {          /* Have we nested past 250 levels?                        */
 8003a78:	4a04      	ldr	r2, [pc, #16]	; (8003a8c <OSIntEnter+0x1c>)
 8003a7a:	7813      	ldrb	r3, [r2, #0]
 8003a7c:	2bf9      	cmp	r3, #249	; 0xf9
        return;                                             /* Yes                                                    */
    }

    OSIntNestingCtr++;                                      /* Increment ISR nesting level                            */
 8003a7e:	bf9c      	itt	ls
 8003a80:	3301      	addls	r3, #1
 8003a82:	7013      	strbls	r3, [r2, #0]
 8003a84:	4770      	bx	lr
 8003a86:	bf00      	nop
 8003a88:	2000e985 	.word	0x2000e985
 8003a8c:	2000ed84 	.word	0x2000ed84

08003a90 <OSIntExit>:
*              2) Rescheduling is prevented when the scheduler is locked (see OSSchedLock())
************************************************************************************************************************
*/

void  OSIntExit (void)
{
 8003a90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    CPU_SR_ALLOC();



    if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Has the OS started?                                    */
 8003a92:	4b1c      	ldr	r3, [pc, #112]	; (8003b04 <OSIntExit+0x74>)
 8003a94:	781b      	ldrb	r3, [r3, #0]
 8003a96:	2b01      	cmp	r3, #1
 8003a98:	d000      	beq.n	8003a9c <OSIntExit+0xc>
 8003a9a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return;                                             /* No                                                     */
    }

    CPU_INT_DIS();
 8003a9c:	f7fd fe6a 	bl	8001774 <CPU_SR_Save>
    if (OSIntNestingCtr == (OS_NESTING_CTR)0) {             /* Prevent OSIntNestingCtr from wrapping                  */
 8003aa0:	4a19      	ldr	r2, [pc, #100]	; (8003b08 <OSIntExit+0x78>)

    if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Has the OS started?                                    */
        return;                                             /* No                                                     */
    }

    CPU_INT_DIS();
 8003aa2:	4604      	mov	r4, r0
    if (OSIntNestingCtr == (OS_NESTING_CTR)0) {             /* Prevent OSIntNestingCtr from wrapping                  */
 8003aa4:	7813      	ldrb	r3, [r2, #0]
 8003aa6:	b31b      	cbz	r3, 8003af0 <OSIntExit+0x60>
        CPU_INT_EN();
        return;
    }
    OSIntNestingCtr--;
 8003aa8:	3b01      	subs	r3, #1
 8003aaa:	b2db      	uxtb	r3, r3
 8003aac:	7013      	strb	r3, [r2, #0]
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* ISRs still nested?                                     */
 8003aae:	b9fb      	cbnz	r3, 8003af0 <OSIntExit+0x60>
        CPU_INT_EN();                                       /* Yes                                                    */
        return;
    }

    if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {        /* Scheduler still locked?                                */
 8003ab0:	4b16      	ldr	r3, [pc, #88]	; (8003b0c <OSIntExit+0x7c>)
 8003ab2:	781b      	ldrb	r3, [r3, #0]
 8003ab4:	b9e3      	cbnz	r3, 8003af0 <OSIntExit+0x60>
        CPU_INT_EN();                                       /* Yes                                                    */
        return;
    }

    OSPrioHighRdy   = OS_PrioGetHighest();                  /* Find highest priority                                  */
 8003ab6:	f001 fe6b 	bl	8005790 <OS_PrioGetHighest>
    OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;     /* Get highest priority task ready-to-run                 */
 8003aba:	4b15      	ldr	r3, [pc, #84]	; (8003b10 <OSIntExit+0x80>)
    if (OSTCBHighRdyPtr == OSTCBCurPtr) {                   /* Current task still the highest priority?               */
 8003abc:	4a15      	ldr	r2, [pc, #84]	; (8003b14 <OSIntExit+0x84>)
        CPU_INT_EN();                                       /* Yes                                                    */
        return;
    }

    OSPrioHighRdy   = OS_PrioGetHighest();                  /* Find highest priority                                  */
    OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;     /* Get highest priority task ready-to-run                 */
 8003abe:	eb00 0140 	add.w	r1, r0, r0, lsl #1
 8003ac2:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    if (OSTCBHighRdyPtr == OSTCBCurPtr) {                   /* Current task still the highest priority?               */
 8003ac6:	6812      	ldr	r2, [r2, #0]
    if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {        /* Scheduler still locked?                                */
        CPU_INT_EN();                                       /* Yes                                                    */
        return;
    }

    OSPrioHighRdy   = OS_PrioGetHighest();                  /* Find highest priority                                  */
 8003ac8:	4d13      	ldr	r5, [pc, #76]	; (8003b18 <OSIntExit+0x88>)
    OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;     /* Get highest priority task ready-to-run                 */
 8003aca:	4914      	ldr	r1, [pc, #80]	; (8003b1c <OSIntExit+0x8c>)
    if (OSTCBHighRdyPtr == OSTCBCurPtr) {                   /* Current task still the highest priority?               */
 8003acc:	4293      	cmp	r3, r2
    if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {        /* Scheduler still locked?                                */
        CPU_INT_EN();                                       /* Yes                                                    */
        return;
    }

    OSPrioHighRdy   = OS_PrioGetHighest();                  /* Find highest priority                                  */
 8003ace:	7028      	strb	r0, [r5, #0]
    OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;     /* Get highest priority task ready-to-run                 */
 8003ad0:	600b      	str	r3, [r1, #0]
    if (OSTCBHighRdyPtr == OSTCBCurPtr) {                   /* Current task still the highest priority?               */
 8003ad2:	d011      	beq.n	8003af8 <OSIntExit+0x68>
#if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
    OS_TLS_TaskSw();
#endif

    OSIntCtxSw();                                           /* Perform interrupt level ctx switch                     */
    CPU_INT_EN();
 8003ad4:	4620      	mov	r0, r4
    }

#if OS_CFG_TASK_PROFILE_EN > 0u
    OSTCBHighRdyPtr->CtxSwCtr++;                            /* Inc. # of context switches for this new task           */
#endif
    OSTaskCtxSwCtr++;                                       /* Keep track of the total number of ctx switches         */
 8003ad6:	4d12      	ldr	r5, [pc, #72]	; (8003b20 <OSIntExit+0x90>)
        CPU_INT_EN();                                       /* Yes                                                    */
        return;
    }

#if OS_CFG_TASK_PROFILE_EN > 0u
    OSTCBHighRdyPtr->CtxSwCtr++;                            /* Inc. # of context switches for this new task           */
 8003ad8:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
#endif
    OSTaskCtxSwCtr++;                                       /* Keep track of the total number of ctx switches         */
 8003adc:	6829      	ldr	r1, [r5, #0]

#if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
    OS_TLS_TaskSw();
#endif

    OSIntCtxSw();                                           /* Perform interrupt level ctx switch                     */
 8003ade:	4e11      	ldr	r6, [pc, #68]	; (8003b24 <OSIntExit+0x94>)
    }

#if OS_CFG_TASK_PROFILE_EN > 0u
    OSTCBHighRdyPtr->CtxSwCtr++;                            /* Inc. # of context switches for this new task           */
#endif
    OSTaskCtxSwCtr++;                                       /* Keep track of the total number of ctx switches         */
 8003ae0:	3101      	adds	r1, #1
        CPU_INT_EN();                                       /* Yes                                                    */
        return;
    }

#if OS_CFG_TASK_PROFILE_EN > 0u
    OSTCBHighRdyPtr->CtxSwCtr++;                            /* Inc. # of context switches for this new task           */
 8003ae2:	3201      	adds	r2, #1

#if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
    OS_TLS_TaskSw();
#endif

    OSIntCtxSw();                                           /* Perform interrupt level ctx switch                     */
 8003ae4:	f04f 5780 	mov.w	r7, #268435456	; 0x10000000
    }

#if OS_CFG_TASK_PROFILE_EN > 0u
    OSTCBHighRdyPtr->CtxSwCtr++;                            /* Inc. # of context switches for this new task           */
#endif
    OSTaskCtxSwCtr++;                                       /* Keep track of the total number of ctx switches         */
 8003ae8:	6029      	str	r1, [r5, #0]
        CPU_INT_EN();                                       /* Yes                                                    */
        return;
    }

#if OS_CFG_TASK_PROFILE_EN > 0u
    OSTCBHighRdyPtr->CtxSwCtr++;                            /* Inc. # of context switches for this new task           */
 8003aea:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90

#if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
    OS_TLS_TaskSw();
#endif

    OSIntCtxSw();                                           /* Perform interrupt level ctx switch                     */
 8003aee:	6037      	str	r7, [r6, #0]
    CPU_INT_EN();
}
 8003af0:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
#if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
    OS_TLS_TaskSw();
#endif

    OSIntCtxSw();                                           /* Perform interrupt level ctx switch                     */
    CPU_INT_EN();
 8003af4:	f7fd be42 	b.w	800177c <CPU_SR_Restore>
    }

    OSPrioHighRdy   = OS_PrioGetHighest();                  /* Find highest priority                                  */
    OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;     /* Get highest priority task ready-to-run                 */
    if (OSTCBHighRdyPtr == OSTCBCurPtr) {                   /* Current task still the highest priority?               */
        CPU_INT_EN();                                       /* Yes                                                    */
 8003af8:	4620      	mov	r0, r4
    OS_TLS_TaskSw();
#endif

    OSIntCtxSw();                                           /* Perform interrupt level ctx switch                     */
    CPU_INT_EN();
}
 8003afa:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    }

    OSPrioHighRdy   = OS_PrioGetHighest();                  /* Find highest priority                                  */
    OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;     /* Get highest priority task ready-to-run                 */
    if (OSTCBHighRdyPtr == OSTCBCurPtr) {                   /* Current task still the highest priority?               */
        CPU_INT_EN();                                       /* Yes                                                    */
 8003afe:	f7fd be3d 	b.w	800177c <CPU_SR_Restore>
 8003b02:	bf00      	nop
 8003b04:	2000e985 	.word	0x2000e985
 8003b08:	2000ed84 	.word	0x2000ed84
 8003b0c:	2000e974 	.word	0x2000e974
 8003b10:	2000e988 	.word	0x2000e988
 8003b14:	2000ed58 	.word	0x2000ed58
 8003b18:	2000ec7c 	.word	0x2000ec7c
 8003b1c:	2000ed64 	.word	0x2000ed64
 8003b20:	2000ed80 	.word	0x2000ed80
 8003b24:	e000ed04 	.word	0xe000ed04

08003b28 <OSSched>:
{
    CPU_SR_ALLOC();



    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* ISRs still nested?                                     */
 8003b28:	4b03      	ldr	r3, [pc, #12]	; (8003b38 <OSSched+0x10>)
 8003b2a:	781b      	ldrb	r3, [r3, #0]
 8003b2c:	b913      	cbnz	r3, 8003b34 <OSSched+0xc>
        return;                                             /* Yes ... only schedule when no nested ISRs              */
    }

    if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {        /* Scheduler locked?                                      */
 8003b2e:	4b03      	ldr	r3, [pc, #12]	; (8003b3c <OSSched+0x14>)
 8003b30:	781b      	ldrb	r3, [r3, #0]
 8003b32:	b103      	cbz	r3, 8003b36 <OSSched+0xe>
 8003b34:	4770      	bx	lr
 8003b36:	e74d      	b.n	80039d4 <OSSched.part.0>
 8003b38:	2000ed84 	.word	0x2000ed84
 8003b3c:	2000e974 	.word	0x2000e974

08003b40 <OSSchedLock>:
        return;
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
 8003b40:	4b16      	ldr	r3, [pc, #88]	; (8003b9c <OSSchedLock+0x5c>)
 8003b42:	781b      	ldrb	r3, [r3, #0]
 8003b44:	b983      	cbnz	r3, 8003b68 <OSSchedLock+0x28>
       *p_err = OS_ERR_SCHED_LOCK_ISR;
        return;
    }
#endif

    if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Make sure multitasking is running                      */
 8003b46:	4b16      	ldr	r3, [pc, #88]	; (8003ba0 <OSSchedLock+0x60>)
 8003b48:	781b      	ldrb	r3, [r3, #0]
 8003b4a:	2b01      	cmp	r3, #1
 8003b4c:	d003      	beq.n	8003b56 <OSSchedLock+0x16>
       *p_err = OS_ERR_OS_NOT_RUNNING;
 8003b4e:	f645 6389 	movw	r3, #24201	; 0x5e89
 8003b52:	8003      	strh	r3, [r0, #0]
 8003b54:	4770      	bx	lr
*                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
************************************************************************************************************************
*/

void  OSSchedLock (OS_ERR  *p_err)
{
 8003b56:	b570      	push	{r4, r5, r6, lr}
    if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Make sure multitasking is running                      */
       *p_err = OS_ERR_OS_NOT_RUNNING;
        return;
    }

    if (OSSchedLockNestingCtr >= (OS_NESTING_CTR)250u) {    /* Prevent OSSchedLockNestingCtr overflowing              */
 8003b58:	4d12      	ldr	r5, [pc, #72]	; (8003ba4 <OSSchedLock+0x64>)
 8003b5a:	782b      	ldrb	r3, [r5, #0]
 8003b5c:	2bf9      	cmp	r3, #249	; 0xf9
 8003b5e:	d907      	bls.n	8003b70 <OSSchedLock+0x30>
       *p_err = OS_ERR_LOCK_NESTING_OVF;
 8003b60:	f245 2309 	movw	r3, #21001	; 0x5209
 8003b64:	8003      	strh	r3, [r0, #0]
        return;
 8003b66:	bd70      	pop	{r4, r5, r6, pc}
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
       *p_err = OS_ERR_SCHED_LOCK_ISR;
 8003b68:	f646 5362 	movw	r3, #28002	; 0x6d62
 8003b6c:	8003      	strh	r3, [r0, #0]
        return;
 8003b6e:	4770      	bx	lr
 8003b70:	4604      	mov	r4, r0
    if (OSSchedLockNestingCtr >= (OS_NESTING_CTR)250u) {    /* Prevent OSSchedLockNestingCtr overflowing              */
       *p_err = OS_ERR_LOCK_NESTING_OVF;
        return;
    }

    CPU_CRITICAL_ENTER();
 8003b72:	f7fd fdff 	bl	8001774 <CPU_SR_Save>
    OSSchedLockNestingCtr++;                                /* Increment lock nesting level                           */
 8003b76:	782b      	ldrb	r3, [r5, #0]
    if (OSSchedLockNestingCtr >= (OS_NESTING_CTR)250u) {    /* Prevent OSSchedLockNestingCtr overflowing              */
       *p_err = OS_ERR_LOCK_NESTING_OVF;
        return;
    }

    CPU_CRITICAL_ENTER();
 8003b78:	4606      	mov	r6, r0
    OSSchedLockNestingCtr++;                                /* Increment lock nesting level                           */
 8003b7a:	3301      	adds	r3, #1
 8003b7c:	b2db      	uxtb	r3, r3
*/

#if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
void  OS_SchedLockTimeMeasStart (void)
{
    if (OSSchedLockNestingCtr == 1u) {
 8003b7e:	2b01      	cmp	r3, #1
       *p_err = OS_ERR_LOCK_NESTING_OVF;
        return;
    }

    CPU_CRITICAL_ENTER();
    OSSchedLockNestingCtr++;                                /* Increment lock nesting level                           */
 8003b80:	702b      	strb	r3, [r5, #0]
*/

#if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
void  OS_SchedLockTimeMeasStart (void)
{
    if (OSSchedLockNestingCtr == 1u) {
 8003b82:	d005      	beq.n	8003b90 <OSSchedLock+0x50>
    CPU_CRITICAL_ENTER();
    OSSchedLockNestingCtr++;                                /* Increment lock nesting level                           */
#if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
    OS_SchedLockTimeMeasStart();
#endif
    CPU_CRITICAL_EXIT();
 8003b84:	4630      	mov	r0, r6
 8003b86:	f7fd fdf9 	bl	800177c <CPU_SR_Restore>
   *p_err = OS_ERR_NONE;
 8003b8a:	2300      	movs	r3, #0
 8003b8c:	8023      	strh	r3, [r4, #0]
 8003b8e:	bd70      	pop	{r4, r5, r6, pc}

#if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
void  OS_SchedLockTimeMeasStart (void)
{
    if (OSSchedLockNestingCtr == 1u) {
        OSSchedLockTimeBegin = CPU_TS_TmrRd();
 8003b90:	f7fc fffc 	bl	8000b8c <CPU_TS_TmrRd>
 8003b94:	4b04      	ldr	r3, [pc, #16]	; (8003ba8 <OSSchedLock+0x68>)
 8003b96:	6018      	str	r0, [r3, #0]
 8003b98:	e7f4      	b.n	8003b84 <OSSchedLock+0x44>
 8003b9a:	bf00      	nop
 8003b9c:	2000ed84 	.word	0x2000ed84
 8003ba0:	2000e985 	.word	0x2000e985
 8003ba4:	2000e974 	.word	0x2000e974
 8003ba8:	2000ed54 	.word	0x2000ed54

08003bac <OSSchedUnlock>:
*                 OSSchedLock() you MUST have a call to OSSchedUnlock().
************************************************************************************************************************
*/

void  OSSchedUnlock (OS_ERR  *p_err)
{
 8003bac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        return;
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
 8003bae:	4d19      	ldr	r5, [pc, #100]	; (8003c14 <OSSchedUnlock+0x68>)
 8003bb0:	782b      	ldrb	r3, [r5, #0]
 8003bb2:	b973      	cbnz	r3, 8003bd2 <OSSchedUnlock+0x26>
       *p_err = OS_ERR_SCHED_UNLOCK_ISR;
        return;
    }
#endif

    if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Make sure multitasking is running                      */
 8003bb4:	4b18      	ldr	r3, [pc, #96]	; (8003c18 <OSSchedUnlock+0x6c>)
 8003bb6:	781b      	ldrb	r3, [r3, #0]
 8003bb8:	2b01      	cmp	r3, #1
 8003bba:	d003      	beq.n	8003bc4 <OSSchedUnlock+0x18>
       *p_err = OS_ERR_OS_NOT_RUNNING;
 8003bbc:	f645 6389 	movw	r3, #24201	; 0x5e89
 8003bc0:	8003      	strh	r3, [r0, #0]
        return;
 8003bc2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    }

    if (OSSchedLockNestingCtr == (OS_NESTING_CTR)0) {       /* See if the scheduler is locked                         */
 8003bc4:	4e15      	ldr	r6, [pc, #84]	; (8003c1c <OSSchedUnlock+0x70>)
 8003bc6:	7833      	ldrb	r3, [r6, #0]
 8003bc8:	b93b      	cbnz	r3, 8003bda <OSSchedUnlock+0x2e>
       *p_err = OS_ERR_SCHED_NOT_LOCKED;
 8003bca:	f646 5364 	movw	r3, #28004	; 0x6d64
 8003bce:	8003      	strh	r3, [r0, #0]
        return;
 8003bd0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
       *p_err = OS_ERR_SCHED_UNLOCK_ISR;
 8003bd2:	f646 5365 	movw	r3, #28005	; 0x6d65
 8003bd6:	8003      	strh	r3, [r0, #0]
        return;
 8003bd8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8003bda:	4604      	mov	r4, r0
    if (OSSchedLockNestingCtr == (OS_NESTING_CTR)0) {       /* See if the scheduler is locked                         */
       *p_err = OS_ERR_SCHED_NOT_LOCKED;
        return;
    }

    CPU_CRITICAL_ENTER();
 8003bdc:	f7fd fdca 	bl	8001774 <CPU_SR_Save>
    OSSchedLockNestingCtr--;                                /* Decrement lock nesting level                           */
 8003be0:	7833      	ldrb	r3, [r6, #0]
    if (OSSchedLockNestingCtr == (OS_NESTING_CTR)0) {       /* See if the scheduler is locked                         */
       *p_err = OS_ERR_SCHED_NOT_LOCKED;
        return;
    }

    CPU_CRITICAL_ENTER();
 8003be2:	4607      	mov	r7, r0
    OSSchedLockNestingCtr--;                                /* Decrement lock nesting level                           */
 8003be4:	3b01      	subs	r3, #1
 8003be6:	b2db      	uxtb	r3, r3
 8003be8:	7033      	strb	r3, [r6, #0]
    if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {
 8003bea:	b96b      	cbnz	r3, 8003c08 <OSSchedUnlock+0x5c>
 8003bec:	f7ff ff28 	bl	8003a40 <OS_SchedLockTimeMeasStop.part.5>

#if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
    OS_SchedLockTimeMeasStop();
#endif

    CPU_CRITICAL_EXIT();                                    /* Scheduler should be re-enabled                         */
 8003bf0:	4638      	mov	r0, r7
 8003bf2:	f7fd fdc3 	bl	800177c <CPU_SR_Restore>
{
    CPU_SR_ALLOC();



    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* ISRs still nested?                                     */
 8003bf6:	782b      	ldrb	r3, [r5, #0]
 8003bf8:	b91b      	cbnz	r3, 8003c02 <OSSchedUnlock+0x56>
        return;                                             /* Yes ... only schedule when no nested ISRs              */
    }

    if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {        /* Scheduler locked?                                      */
 8003bfa:	7833      	ldrb	r3, [r6, #0]
 8003bfc:	b90b      	cbnz	r3, 8003c02 <OSSchedUnlock+0x56>
 8003bfe:	f7ff fee9 	bl	80039d4 <OSSched.part.0>
    OS_SchedLockTimeMeasStop();
#endif

    CPU_CRITICAL_EXIT();                                    /* Scheduler should be re-enabled                         */
    OSSched();                                              /* Run the scheduler                                      */
   *p_err = OS_ERR_NONE;
 8003c02:	2300      	movs	r3, #0
 8003c04:	8023      	strh	r3, [r4, #0]
 8003c06:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    }

    CPU_CRITICAL_ENTER();
    OSSchedLockNestingCtr--;                                /* Decrement lock nesting level                           */
    if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {
        CPU_CRITICAL_EXIT();                                /* Scheduler is still locked                              */
 8003c08:	f7fd fdb8 	bl	800177c <CPU_SR_Restore>
       *p_err = OS_ERR_SCHED_LOCKED;
 8003c0c:	f646 5363 	movw	r3, #28003	; 0x6d63
 8003c10:	8023      	strh	r3, [r4, #0]
        return;
 8003c12:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8003c14:	2000ed84 	.word	0x2000ed84
 8003c18:	2000e985 	.word	0x2000e985
 8003c1c:	2000e974 	.word	0x2000e974

08003c20 <OSSchedRoundRobinCfg>:

#if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
void  OSSchedRoundRobinCfg (CPU_BOOLEAN   en,
                            OS_TICK       dflt_time_quanta,
                            OS_ERR       *p_err)
{
 8003c20:	b570      	push	{r4, r5, r6, lr}
 8003c22:	4605      	mov	r5, r0
 8003c24:	4616      	mov	r6, r2
 8003c26:	460c      	mov	r4, r1
        OS_SAFETY_CRITICAL_EXCEPTION();
        return;
    }
#endif

    CPU_CRITICAL_ENTER();
 8003c28:	f7fd fda4 	bl	8001774 <CPU_SR_Save>
    if (en != DEF_ENABLED) {
 8003c2c:	2d01      	cmp	r5, #1
        OSSchedRoundRobinEn = DEF_DISABLED;
 8003c2e:	4b0d      	ldr	r3, [pc, #52]	; (8003c64 <OSSchedRoundRobinCfg+0x44>)
 8003c30:	bf1a      	itte	ne
 8003c32:	2200      	movne	r2, #0
 8003c34:	701a      	strbne	r2, [r3, #0]
    } else {
        OSSchedRoundRobinEn = DEF_ENABLED;
 8003c36:	701d      	strbeq	r5, [r3, #0]
    }

    if (dflt_time_quanta > (OS_TICK)0) {
 8003c38:	b964      	cbnz	r4, 8003c54 <OSSchedRoundRobinCfg+0x34>
        OSSchedRoundRobinDfltTimeQuanta = dflt_time_quanta;
    } else {
        OSSchedRoundRobinDfltTimeQuanta = (OS_TICK)(OSCfg_TickRate_Hz / (OS_RATE_HZ)10);
 8003c3a:	4b0b      	ldr	r3, [pc, #44]	; (8003c68 <OSSchedRoundRobinCfg+0x48>)
 8003c3c:	490b      	ldr	r1, [pc, #44]	; (8003c6c <OSSchedRoundRobinCfg+0x4c>)
 8003c3e:	681b      	ldr	r3, [r3, #0]
 8003c40:	4a0b      	ldr	r2, [pc, #44]	; (8003c70 <OSSchedRoundRobinCfg+0x50>)
 8003c42:	fba1 1303 	umull	r1, r3, r1, r3
 8003c46:	08db      	lsrs	r3, r3, #3
 8003c48:	6013      	str	r3, [r2, #0]
    }
    CPU_CRITICAL_EXIT();
 8003c4a:	f7fd fd97 	bl	800177c <CPU_SR_Restore>
   *p_err = OS_ERR_NONE;
 8003c4e:	2300      	movs	r3, #0
 8003c50:	8033      	strh	r3, [r6, #0]
 8003c52:	bd70      	pop	{r4, r5, r6, pc}
    } else {
        OSSchedRoundRobinEn = DEF_ENABLED;
    }

    if (dflt_time_quanta > (OS_TICK)0) {
        OSSchedRoundRobinDfltTimeQuanta = dflt_time_quanta;
 8003c54:	4b06      	ldr	r3, [pc, #24]	; (8003c70 <OSSchedRoundRobinCfg+0x50>)
 8003c56:	601c      	str	r4, [r3, #0]
    } else {
        OSSchedRoundRobinDfltTimeQuanta = (OS_TICK)(OSCfg_TickRate_Hz / (OS_RATE_HZ)10);
    }
    CPU_CRITICAL_EXIT();
 8003c58:	f7fd fd90 	bl	800177c <CPU_SR_Restore>
   *p_err = OS_ERR_NONE;
 8003c5c:	2300      	movs	r3, #0
 8003c5e:	8033      	strh	r3, [r6, #0]
 8003c60:	bd70      	pop	{r4, r5, r6, pc}
 8003c62:	bf00      	nop
 8003c64:	2000f030 	.word	0x2000f030
 8003c68:	080160cc 	.word	0x080160cc
 8003c6c:	cccccccd 	.word	0xcccccccd
 8003c70:	2000ef28 	.word	0x2000ef28

08003c74 <OSStart>:
*              2) OSStart() is not supposed to return.  If it does, that would be considered a fatal error.
************************************************************************************************************************
*/

void  OSStart (OS_ERR  *p_err)
{
 8003c74:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if (p_err == (OS_ERR *)0) {
        OS_SAFETY_CRITICAL_EXCEPTION();
        return;
    }
#endif
    if (OSRunning == OS_STATE_OS_STOPPED) {
 8003c76:	4d0f      	ldr	r5, [pc, #60]	; (8003cb4 <OSStart+0x40>)
 8003c78:	782b      	ldrb	r3, [r5, #0]
 8003c7a:	b11b      	cbz	r3, 8003c84 <OSStart+0x10>
        OSTCBCurPtr     = OSTCBHighRdyPtr;
        OSRunning       = OS_STATE_OS_RUNNING;
        OSStartHighRdy();                                   /* Execute target specific code to start task             */
       *p_err           = OS_ERR_FATAL_RETURN;              /* OSStart() is not supposed to return                    */
    } else {
       *p_err           = OS_ERR_OS_RUNNING;                /* OS is already running                                  */
 8003c7c:	f645 638a 	movw	r3, #24202	; 0x5e8a
 8003c80:	8003      	strh	r3, [r0, #0]
 8003c82:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8003c84:	4604      	mov	r4, r0
        OS_SAFETY_CRITICAL_EXCEPTION();
        return;
    }
#endif
    if (OSRunning == OS_STATE_OS_STOPPED) {
        OSPrioHighRdy   = OS_PrioGetHighest();              /* Find the highest priority                              */
 8003c86:	f001 fd83 	bl	8005790 <OS_PrioGetHighest>
        OSPrioCur       = OSPrioHighRdy;
        OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;
 8003c8a:	4b0b      	ldr	r3, [pc, #44]	; (8003cb8 <OSStart+0x44>)
 8003c8c:	eb00 0140 	add.w	r1, r0, r0, lsl #1
        OS_SAFETY_CRITICAL_EXCEPTION();
        return;
    }
#endif
    if (OSRunning == OS_STATE_OS_STOPPED) {
        OSPrioHighRdy   = OS_PrioGetHighest();              /* Find the highest priority                              */
 8003c90:	4a0a      	ldr	r2, [pc, #40]	; (8003cbc <OSStart+0x48>)
        OSPrioCur       = OSPrioHighRdy;
        OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;
 8003c92:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
        return;
    }
#endif
    if (OSRunning == OS_STATE_OS_STOPPED) {
        OSPrioHighRdy   = OS_PrioGetHighest();              /* Find the highest priority                              */
        OSPrioCur       = OSPrioHighRdy;
 8003c96:	4f0a      	ldr	r7, [pc, #40]	; (8003cc0 <OSStart+0x4c>)
        OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;
        OSTCBCurPtr     = OSTCBHighRdyPtr;
 8003c98:	490a      	ldr	r1, [pc, #40]	; (8003cc4 <OSStart+0x50>)
    }
#endif
    if (OSRunning == OS_STATE_OS_STOPPED) {
        OSPrioHighRdy   = OS_PrioGetHighest();              /* Find the highest priority                              */
        OSPrioCur       = OSPrioHighRdy;
        OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;
 8003c9a:	4e0b      	ldr	r6, [pc, #44]	; (8003cc8 <OSStart+0x54>)
        OS_SAFETY_CRITICAL_EXCEPTION();
        return;
    }
#endif
    if (OSRunning == OS_STATE_OS_STOPPED) {
        OSPrioHighRdy   = OS_PrioGetHighest();              /* Find the highest priority                              */
 8003c9c:	7010      	strb	r0, [r2, #0]
        OSPrioCur       = OSPrioHighRdy;
        OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;
        OSTCBCurPtr     = OSTCBHighRdyPtr;
        OSRunning       = OS_STATE_OS_RUNNING;
 8003c9e:	2201      	movs	r2, #1
    }
#endif
    if (OSRunning == OS_STATE_OS_STOPPED) {
        OSPrioHighRdy   = OS_PrioGetHighest();              /* Find the highest priority                              */
        OSPrioCur       = OSPrioHighRdy;
        OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;
 8003ca0:	6033      	str	r3, [r6, #0]
        OSTCBCurPtr     = OSTCBHighRdyPtr;
 8003ca2:	600b      	str	r3, [r1, #0]
        return;
    }
#endif
    if (OSRunning == OS_STATE_OS_STOPPED) {
        OSPrioHighRdy   = OS_PrioGetHighest();              /* Find the highest priority                              */
        OSPrioCur       = OSPrioHighRdy;
 8003ca4:	7038      	strb	r0, [r7, #0]
        OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;
        OSTCBCurPtr     = OSTCBHighRdyPtr;
        OSRunning       = OS_STATE_OS_RUNNING;
 8003ca6:	702a      	strb	r2, [r5, #0]
        OSStartHighRdy();                                   /* Execute target specific code to start task             */
 8003ca8:	f000 fda2 	bl	80047f0 <OSStartHighRdy>
       *p_err           = OS_ERR_FATAL_RETURN;              /* OSStart() is not supposed to return                    */
 8003cac:	f643 2399 	movw	r3, #15001	; 0x3a99
 8003cb0:	8023      	strh	r3, [r4, #0]
 8003cb2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8003cb4:	2000e985 	.word	0x2000e985
 8003cb8:	2000e988 	.word	0x2000e988
 8003cbc:	2000ec7c 	.word	0x2000ec7c
 8003cc0:	2000ec88 	.word	0x2000ec88
 8003cc4:	2000ed58 	.word	0x2000ed58
 8003cc8:	2000ed64 	.word	0x2000ed64

08003ccc <OSVersion>:
        OS_SAFETY_CRITICAL_EXCEPTION();
        return ((CPU_INT16U)0u);
    }
#endif

   *p_err = OS_ERR_NONE;
 8003ccc:	2300      	movs	r3, #0
 8003cce:	8003      	strh	r3, [r0, #0]
    return (OS_VERSION);
}
 8003cd0:	f247 605d 	movw	r0, #30301	; 0x765d
 8003cd4:	4770      	bx	lr
 8003cd6:	bf00      	nop

08003cd8 <OS_IdleTaskInit>:
* Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
************************************************************************************************************************
*/

void  OS_IdleTaskInit (OS_ERR  *p_err)
{
 8003cd8:	b5f0      	push	{r4, r5, r6, r7, lr}
    }
#endif

    OSIdleTaskCtr = (OS_IDLE_CTR)0;
                                                            /* ---------------- CREATE THE IDLE TASK ---------------- */
    OSTaskCreate((OS_TCB     *)&OSIdleTaskTCB,
 8003cda:	490e      	ldr	r1, [pc, #56]	; (8003d14 <OS_IdleTaskInit+0x3c>)
 8003cdc:	4a0e      	ldr	r2, [pc, #56]	; (8003d18 <OS_IdleTaskInit+0x40>)
 8003cde:	4b0f      	ldr	r3, [pc, #60]	; (8003d1c <OS_IdleTaskInit+0x44>)
 8003ce0:	680f      	ldr	r7, [r1, #0]
 8003ce2:	6816      	ldr	r6, [r2, #0]
 8003ce4:	681b      	ldr	r3, [r3, #0]
* Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
************************************************************************************************************************
*/

void  OS_IdleTaskInit (OS_ERR  *p_err)
{
 8003ce6:	b08b      	sub	sp, #44	; 0x2c
        OS_SAFETY_CRITICAL_EXCEPTION();
        return;
    }
#endif

    OSIdleTaskCtr = (OS_IDLE_CTR)0;
 8003ce8:	2400      	movs	r4, #0
 8003cea:	4d0d      	ldr	r5, [pc, #52]	; (8003d20 <OS_IdleTaskInit+0x48>)
                                                            /* ---------------- CREATE THE IDLE TASK ---------------- */
    OSTaskCreate((OS_TCB     *)&OSIdleTaskTCB,
 8003cec:	210b      	movs	r1, #11
 8003cee:	223e      	movs	r2, #62	; 0x3e
 8003cf0:	9008      	str	r0, [sp, #32]
 8003cf2:	9301      	str	r3, [sp, #4]
 8003cf4:	9107      	str	r1, [sp, #28]
 8003cf6:	9200      	str	r2, [sp, #0]
 8003cf8:	9703      	str	r7, [sp, #12]
 8003cfa:	9602      	str	r6, [sp, #8]
 8003cfc:	9406      	str	r4, [sp, #24]
 8003cfe:	9405      	str	r4, [sp, #20]
 8003d00:	9404      	str	r4, [sp, #16]
 8003d02:	4623      	mov	r3, r4
 8003d04:	4a07      	ldr	r2, [pc, #28]	; (8003d24 <OS_IdleTaskInit+0x4c>)
 8003d06:	4908      	ldr	r1, [pc, #32]	; (8003d28 <OS_IdleTaskInit+0x50>)
 8003d08:	4808      	ldr	r0, [pc, #32]	; (8003d2c <OS_IdleTaskInit+0x54>)
        OS_SAFETY_CRITICAL_EXCEPTION();
        return;
    }
#endif

    OSIdleTaskCtr = (OS_IDLE_CTR)0;
 8003d0a:	602c      	str	r4, [r5, #0]
                                                            /* ---------------- CREATE THE IDLE TASK ---------------- */
    OSTaskCreate((OS_TCB     *)&OSIdleTaskTCB,
 8003d0c:	f003 f97e 	bl	800700c <OSTaskCreate>
                 (OS_MSG_QTY  )0u,
                 (OS_TICK     )0u,
                 (void       *)0,
                 (OS_OPT      )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR | OS_OPT_TASK_NO_TLS),
                 (OS_ERR     *)p_err);
}
 8003d10:	b00b      	add	sp, #44	; 0x2c
 8003d12:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003d14:	08016124 	.word	0x08016124
 8003d18:	08016128 	.word	0x08016128
 8003d1c:	0801612c 	.word	0x0801612c
 8003d20:	2000ef40 	.word	0x2000ef40
 8003d24:	080039ad 	.word	0x080039ad
 8003d28:	08016634 	.word	0x08016634
 8003d2c:	2000ee58 	.word	0x2000ee58

08003d30 <OSInit>:
* Returns    : none
************************************************************************************************************************
*/

void  OSInit (OS_ERR  *p_err)
{
 8003d30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003d32:	4605      	mov	r5, r0
        OS_SAFETY_CRITICAL_EXCEPTION();
        return;
    }
#endif

    OSInitHook();                                           /* Call port specific initialization code                 */
 8003d34:	f000 fda6 	bl	8004884 <OSInitHook>
    OSSafetyCriticalStartFlag       =  DEF_FALSE;
#endif

#if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
    OSSchedRoundRobinEn             = DEF_FALSE;
    OSSchedRoundRobinDfltTimeQuanta = OSCfg_TickRate_Hz / 10u;
 8003d38:	4b48      	ldr	r3, [pc, #288]	; (8003e5c <OSInit+0x12c>)
 8003d3a:	4949      	ldr	r1, [pc, #292]	; (8003e60 <OSInit+0x130>)
 8003d3c:	681b      	ldr	r3, [r3, #0]
 8003d3e:	4c49      	ldr	r4, [pc, #292]	; (8003e64 <OSInit+0x134>)
 8003d40:	fba1 1303 	umull	r1, r3, r1, r3
    }
#endif

    OSInitHook();                                           /* Call port specific initialization code                 */

    OSIntNestingCtr                 = (OS_NESTING_CTR)0;    /* Clear the interrupt nesting counter                    */
 8003d44:	4848      	ldr	r0, [pc, #288]	; (8003e68 <OSInit+0x138>)

    OSRunning                       =  OS_STATE_OS_STOPPED; /* Indicate that multitasking not started                 */
 8003d46:	4949      	ldr	r1, [pc, #292]	; (8003e6c <OSInit+0x13c>)
    OSSafetyCriticalStartFlag       =  DEF_FALSE;
#endif

#if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
    OSSchedRoundRobinEn             = DEF_FALSE;
    OSSchedRoundRobinDfltTimeQuanta = OSCfg_TickRate_Hz / 10u;
 8003d48:	08db      	lsrs	r3, r3, #3
 8003d4a:	6023      	str	r3, [r4, #0]
    }
#endif

    OSInitHook();                                           /* Call port specific initialization code                 */

    OSIntNestingCtr                 = (OS_NESTING_CTR)0;    /* Clear the interrupt nesting counter                    */
 8003d4c:	2300      	movs	r3, #0
 8003d4e:	7003      	strb	r3, [r0, #0]

    OSRunning                       =  OS_STATE_OS_STOPPED; /* Indicate that multitasking not started                 */
 8003d50:	700b      	strb	r3, [r1, #0]

    OSSchedLockNestingCtr           = (OS_NESTING_CTR)0;    /* Clear the scheduling lock counter                      */
 8003d52:	4f47      	ldr	r7, [pc, #284]	; (8003e70 <OSInit+0x140>)

    OSTCBCurPtr                     = (OS_TCB *)0;          /* Initialize OS_TCB pointers to a known state            */
 8003d54:	4e47      	ldr	r6, [pc, #284]	; (8003e74 <OSInit+0x144>)
    OSTCBHighRdyPtr                 = (OS_TCB *)0;
 8003d56:	4c48      	ldr	r4, [pc, #288]	; (8003e78 <OSInit+0x148>)

    OSPrioCur                       = (OS_PRIO)0;           /* Initialize priority variables to a known state         */
 8003d58:	4848      	ldr	r0, [pc, #288]	; (8003e7c <OSInit+0x14c>)
    OSPrioHighRdy                   = (OS_PRIO)0;
 8003d5a:	4949      	ldr	r1, [pc, #292]	; (8003e80 <OSInit+0x150>)
#if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
    OSSchedRoundRobinEn             = DEF_FALSE;
    OSSchedRoundRobinDfltTimeQuanta = OSCfg_TickRate_Hz / 10u;
#endif

    if (OSCfg_ISRStkSize > (CPU_STK_SIZE)0) {
 8003d5c:	4a49      	ldr	r2, [pc, #292]	; (8003e84 <OSInit+0x154>)

    OSIntNestingCtr                 = (OS_NESTING_CTR)0;    /* Clear the interrupt nesting counter                    */

    OSRunning                       =  OS_STATE_OS_STOPPED; /* Indicate that multitasking not started                 */

    OSSchedLockNestingCtr           = (OS_NESTING_CTR)0;    /* Clear the scheduling lock counter                      */
 8003d5e:	703b      	strb	r3, [r7, #0]

    OSTCBCurPtr                     = (OS_TCB *)0;          /* Initialize OS_TCB pointers to a known state            */
 8003d60:	6033      	str	r3, [r6, #0]
    OSTCBHighRdyPtr                 = (OS_TCB *)0;
 8003d62:	6023      	str	r3, [r4, #0]

    OSPrioCur                       = (OS_PRIO)0;           /* Initialize priority variables to a known state         */
 8003d64:	7003      	strb	r3, [r0, #0]
    OSPrioHighRdy                   = (OS_PRIO)0;
 8003d66:	700b      	strb	r3, [r1, #0]
    OSPrioSaved                     = (OS_PRIO)0;
 8003d68:	4f47      	ldr	r7, [pc, #284]	; (8003e88 <OSInit+0x158>)

#if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
    OSSchedLockTimeBegin            = (CPU_TS)0;
 8003d6a:	4e48      	ldr	r6, [pc, #288]	; (8003e8c <OSInit+0x15c>)
    OSSchedLockTimeMax              = (CPU_TS)0;
 8003d6c:	4c48      	ldr	r4, [pc, #288]	; (8003e90 <OSInit+0x160>)
    OSSchedLockTimeMaxCur           = (CPU_TS)0;
 8003d6e:	4849      	ldr	r0, [pc, #292]	; (8003e94 <OSInit+0x164>)
#ifdef OS_SAFETY_CRITICAL_IEC61508
    OSSafetyCriticalStartFlag       =  DEF_FALSE;
#endif

#if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
    OSSchedRoundRobinEn             = DEF_FALSE;
 8003d70:	4949      	ldr	r1, [pc, #292]	; (8003e98 <OSInit+0x168>)
    OSSchedRoundRobinDfltTimeQuanta = OSCfg_TickRate_Hz / 10u;
#endif

    if (OSCfg_ISRStkSize > (CPU_STK_SIZE)0) {
 8003d72:	6812      	ldr	r2, [r2, #0]
    OSTCBCurPtr                     = (OS_TCB *)0;          /* Initialize OS_TCB pointers to a known state            */
    OSTCBHighRdyPtr                 = (OS_TCB *)0;

    OSPrioCur                       = (OS_PRIO)0;           /* Initialize priority variables to a known state         */
    OSPrioHighRdy                   = (OS_PRIO)0;
    OSPrioSaved                     = (OS_PRIO)0;
 8003d74:	703b      	strb	r3, [r7, #0]

#if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
    OSSchedLockTimeBegin            = (CPU_TS)0;
 8003d76:	6033      	str	r3, [r6, #0]
    OSSchedLockTimeMax              = (CPU_TS)0;
 8003d78:	6023      	str	r3, [r4, #0]
    OSSchedLockTimeMaxCur           = (CPU_TS)0;
 8003d7a:	6003      	str	r3, [r0, #0]
#ifdef OS_SAFETY_CRITICAL_IEC61508
    OSSafetyCriticalStartFlag       =  DEF_FALSE;
#endif

#if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
    OSSchedRoundRobinEn             = DEF_FALSE;
 8003d7c:	700b      	strb	r3, [r1, #0]
    OSSchedRoundRobinDfltTimeQuanta = OSCfg_TickRate_Hz / 10u;
#endif

    if (OSCfg_ISRStkSize > (CPU_STK_SIZE)0) {
 8003d7e:	b132      	cbz	r2, 8003d8e <OSInit+0x5e>
        p_stk = OSCfg_ISRStkBasePtr;                        /* Clear exception stack for stack checking.              */
 8003d80:	4946      	ldr	r1, [pc, #280]	; (8003e9c <OSInit+0x16c>)
 8003d82:	6809      	ldr	r1, [r1, #0]
        if (p_stk != (CPU_STK *)0) {
 8003d84:	b119      	cbz	r1, 8003d8e <OSInit+0x5e>
            size  = OSCfg_ISRStkSize;
            while (size > (CPU_STK_SIZE)0) {
 8003d86:	3a01      	subs	r2, #1
                size--;
               *p_stk = (CPU_STK)0;
 8003d88:	f841 3b04 	str.w	r3, [r1], #4

    if (OSCfg_ISRStkSize > (CPU_STK_SIZE)0) {
        p_stk = OSCfg_ISRStkBasePtr;                        /* Clear exception stack for stack checking.              */
        if (p_stk != (CPU_STK *)0) {
            size  = OSCfg_ISRStkSize;
            while (size > (CPU_STK_SIZE)0) {
 8003d8c:	d1fb      	bne.n	8003d86 <OSInit+0x56>
            }
        }
    }

#if OS_CFG_APP_HOOKS_EN > 0u
    OS_AppTaskCreateHookPtr = (OS_APP_HOOK_TCB )0;          /* Clear application hook pointers                        */
 8003d8e:	4a44      	ldr	r2, [pc, #272]	; (8003ea0 <OSInit+0x170>)
    OS_AppTaskDelHookPtr    = (OS_APP_HOOK_TCB )0;
 8003d90:	4b44      	ldr	r3, [pc, #272]	; (8003ea4 <OSInit+0x174>)
            }
        }
    }

#if OS_CFG_APP_HOOKS_EN > 0u
    OS_AppTaskCreateHookPtr = (OS_APP_HOOK_TCB )0;          /* Clear application hook pointers                        */
 8003d92:	2400      	movs	r4, #0
    OS_AppTaskDelHookPtr    = (OS_APP_HOOK_TCB )0;
    OS_AppTaskReturnHookPtr = (OS_APP_HOOK_TCB )0;

    OS_AppIdleTaskHookPtr   = (OS_APP_HOOK_VOID)0;
    OS_AppStatTaskHookPtr   = (OS_APP_HOOK_VOID)0;
    OS_AppTaskSwHookPtr     = (OS_APP_HOOK_VOID)0;
 8003d94:	4944      	ldr	r1, [pc, #272]	; (8003ea8 <OSInit+0x178>)
            }
        }
    }

#if OS_CFG_APP_HOOKS_EN > 0u
    OS_AppTaskCreateHookPtr = (OS_APP_HOOK_TCB )0;          /* Clear application hook pointers                        */
 8003d96:	6014      	str	r4, [r2, #0]
    OS_AppTaskDelHookPtr    = (OS_APP_HOOK_TCB )0;
 8003d98:	601c      	str	r4, [r3, #0]
    OS_AppTaskReturnHookPtr = (OS_APP_HOOK_TCB )0;

    OS_AppIdleTaskHookPtr   = (OS_APP_HOOK_VOID)0;
    OS_AppStatTaskHookPtr   = (OS_APP_HOOK_VOID)0;
    OS_AppTaskSwHookPtr     = (OS_APP_HOOK_VOID)0;
    OS_AppTimeTickHookPtr   = (OS_APP_HOOK_VOID)0;
 8003d9a:	4a44      	ldr	r2, [pc, #272]	; (8003eac <OSInit+0x17c>)
#endif

#if OS_CFG_TASK_REG_TBL_SIZE > 0u
    OSTaskRegNextAvailID    = (OS_REG_ID)0;
 8003d9c:	4b44      	ldr	r3, [pc, #272]	; (8003eb0 <OSInit+0x180>)
    OS_AppTaskCreateHookPtr = (OS_APP_HOOK_TCB )0;          /* Clear application hook pointers                        */
    OS_AppTaskDelHookPtr    = (OS_APP_HOOK_TCB )0;
    OS_AppTaskReturnHookPtr = (OS_APP_HOOK_TCB )0;

    OS_AppIdleTaskHookPtr   = (OS_APP_HOOK_VOID)0;
    OS_AppStatTaskHookPtr   = (OS_APP_HOOK_VOID)0;
 8003d9e:	4845      	ldr	r0, [pc, #276]	; (8003eb4 <OSInit+0x184>)
    }

#if OS_CFG_APP_HOOKS_EN > 0u
    OS_AppTaskCreateHookPtr = (OS_APP_HOOK_TCB )0;          /* Clear application hook pointers                        */
    OS_AppTaskDelHookPtr    = (OS_APP_HOOK_TCB )0;
    OS_AppTaskReturnHookPtr = (OS_APP_HOOK_TCB )0;
 8003da0:	4f45      	ldr	r7, [pc, #276]	; (8003eb8 <OSInit+0x188>)

    OS_AppIdleTaskHookPtr   = (OS_APP_HOOK_VOID)0;
 8003da2:	4e46      	ldr	r6, [pc, #280]	; (8003ebc <OSInit+0x18c>)
    OS_AppStatTaskHookPtr   = (OS_APP_HOOK_VOID)0;
    OS_AppTaskSwHookPtr     = (OS_APP_HOOK_VOID)0;
 8003da4:	600c      	str	r4, [r1, #0]
    OS_AppTimeTickHookPtr   = (OS_APP_HOOK_VOID)0;
 8003da6:	6014      	str	r4, [r2, #0]
#endif

#if OS_CFG_TASK_REG_TBL_SIZE > 0u
    OSTaskRegNextAvailID    = (OS_REG_ID)0;
 8003da8:	701c      	strb	r4, [r3, #0]
    }

#if OS_CFG_APP_HOOKS_EN > 0u
    OS_AppTaskCreateHookPtr = (OS_APP_HOOK_TCB )0;          /* Clear application hook pointers                        */
    OS_AppTaskDelHookPtr    = (OS_APP_HOOK_TCB )0;
    OS_AppTaskReturnHookPtr = (OS_APP_HOOK_TCB )0;
 8003daa:	603c      	str	r4, [r7, #0]

    OS_AppIdleTaskHookPtr   = (OS_APP_HOOK_VOID)0;
 8003dac:	6034      	str	r4, [r6, #0]
    OS_AppStatTaskHookPtr   = (OS_APP_HOOK_VOID)0;
 8003dae:	6004      	str	r4, [r0, #0]

#if OS_CFG_TASK_REG_TBL_SIZE > 0u
    OSTaskRegNextAvailID    = (OS_REG_ID)0;
#endif

    OS_PrioInit();                                          /* Initialize the priority bitmap table                   */
 8003db0:	f001 fce6 	bl	8005780 <OS_PrioInit>



    for (i = 0u; i < OS_CFG_PRIO_MAX; i++) {                /* Initialize the array of OS_RDY_LIST at each priority   */
        p_rdy_list = &OSRdyList[i];
        p_rdy_list->NbrEntries = (OS_OBJ_QTY)0;
 8003db4:	4622      	mov	r2, r4
 8003db6:	4b42      	ldr	r3, [pc, #264]	; (8003ec0 <OSInit+0x190>)
 8003db8:	f503 713d 	add.w	r1, r3, #756	; 0x2f4
 8003dbc:	801a      	strh	r2, [r3, #0]
        p_rdy_list->HeadPtr    = (OS_TCB   *)0;
 8003dbe:	f843 2c08 	str.w	r2, [r3, #-8]
        p_rdy_list->TailPtr    = (OS_TCB   *)0;
 8003dc2:	f843 2c04 	str.w	r2, [r3, #-4]
 8003dc6:	330c      	adds	r3, #12
    OS_PRIO       i;
    OS_RDY_LIST  *p_rdy_list;



    for (i = 0u; i < OS_CFG_PRIO_MAX; i++) {                /* Initialize the array of OS_RDY_LIST at each priority   */
 8003dc8:	428b      	cmp	r3, r1
 8003dca:	d1f7      	bne.n	8003dbc <OSInit+0x8c>

    OS_RdyListInit();                                       /* Initialize the Ready List                              */

    
#if OS_CFG_FLAG_EN > 0u                                     /* Initialize the Event Flag module                       */
    OS_FlagInit(p_err);
 8003dcc:	4628      	mov	r0, r5
 8003dce:	f001 f80f 	bl	8004df0 <OS_FlagInit>
    if (*p_err != OS_ERR_NONE) {
 8003dd2:	882b      	ldrh	r3, [r5, #0]
 8003dd4:	b103      	cbz	r3, 8003dd8 <OSInit+0xa8>
 8003dd6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    }
#endif


#if OS_CFG_MEM_EN > 0u                                      /* Initialize the Memory Manager module                   */
    OS_MemInit(p_err);
 8003dd8:	4628      	mov	r0, r5
 8003dda:	f001 f9bb 	bl	8005154 <OS_MemInit>
    if (*p_err != OS_ERR_NONE) {
 8003dde:	882b      	ldrh	r3, [r5, #0]
 8003de0:	2b00      	cmp	r3, #0
 8003de2:	d1f8      	bne.n	8003dd6 <OSInit+0xa6>
    }
#endif


#if (OS_MSG_EN) > 0u                                        /* Initialize the free list of OS_MSGs                    */
    OS_MsgPoolInit(p_err);
 8003de4:	4628      	mov	r0, r5
 8003de6:	f001 f9c1 	bl	800516c <OS_MsgPoolInit>
    if (*p_err != OS_ERR_NONE) {
 8003dea:	882b      	ldrh	r3, [r5, #0]
 8003dec:	2b00      	cmp	r3, #0
 8003dee:	d1f2      	bne.n	8003dd6 <OSInit+0xa6>
    }
#endif


#if OS_CFG_MUTEX_EN > 0u                                    /* Initialize the Mutex Manager module                    */
    OS_MutexInit(p_err);
 8003df0:	4628      	mov	r0, r5
 8003df2:	f001 fcb9 	bl	8005768 <OS_MutexInit>
    if (*p_err != OS_ERR_NONE) {
 8003df6:	882b      	ldrh	r3, [r5, #0]
 8003df8:	2b00      	cmp	r3, #0
 8003dfa:	d1ec      	bne.n	8003dd6 <OSInit+0xa6>
    }
#endif


#if OS_CFG_Q_EN > 0u
    OS_QInit(p_err);                                        /* Initialize the Message Queue Manager module            */
 8003dfc:	4628      	mov	r0, r5
 8003dfe:	f001 ff6f 	bl	8005ce0 <OS_QInit>
    if (*p_err != OS_ERR_NONE) {
 8003e02:	882b      	ldrh	r3, [r5, #0]
 8003e04:	2b00      	cmp	r3, #0
 8003e06:	d1e6      	bne.n	8003dd6 <OSInit+0xa6>
    }
#endif


#if OS_CFG_SEM_EN > 0u                                      /* Initialize the Semaphore Manager module                */
    OS_SemInit(p_err);
 8003e08:	4628      	mov	r0, r5
 8003e0a:	f002 fa6f 	bl	80062ec <OS_SemInit>
    if (*p_err != OS_ERR_NONE) {
 8003e0e:	882b      	ldrh	r3, [r5, #0]
 8003e10:	2b00      	cmp	r3, #0
 8003e12:	d1e0      	bne.n	8003dd6 <OSInit+0xa6>
        return;
    }
#endif


    OS_TaskInit(p_err);                                     /* Initialize the task manager                            */
 8003e14:	4628      	mov	r0, r5
 8003e16:	f003 f88b 	bl	8006f30 <OS_TaskInit>
    if (*p_err != OS_ERR_NONE) {
 8003e1a:	882b      	ldrh	r3, [r5, #0]
 8003e1c:	2b00      	cmp	r3, #0
 8003e1e:	d1da      	bne.n	8003dd6 <OSInit+0xa6>
        return;
    }
#endif

    
    OS_IdleTaskInit(p_err);                                 /* Initialize the Idle Task                               */
 8003e20:	4628      	mov	r0, r5
 8003e22:	f7ff ff59 	bl	8003cd8 <OS_IdleTaskInit>
    if (*p_err != OS_ERR_NONE) {
 8003e26:	882b      	ldrh	r3, [r5, #0]
 8003e28:	2b00      	cmp	r3, #0
 8003e2a:	d1d4      	bne.n	8003dd6 <OSInit+0xa6>
        return;
    }


    OS_TickTaskInit(p_err);                                 /* Initialize the Tick Task                               */
 8003e2c:	4628      	mov	r0, r5
 8003e2e:	f003 fc43 	bl	80076b8 <OS_TickTaskInit>
    if (*p_err != OS_ERR_NONE) {
 8003e32:	882b      	ldrh	r3, [r5, #0]
 8003e34:	2b00      	cmp	r3, #0
 8003e36:	d1ce      	bne.n	8003dd6 <OSInit+0xa6>
        return;
    }


#if OS_CFG_STAT_TASK_EN > 0u                                /* Initialize the Statistic Task                          */
    OS_StatTaskInit(p_err);
 8003e38:	4628      	mov	r0, r5
 8003e3a:	f002 fcb5 	bl	80067a8 <OS_StatTaskInit>
    if (*p_err != OS_ERR_NONE) {
 8003e3e:	882b      	ldrh	r3, [r5, #0]
 8003e40:	2b00      	cmp	r3, #0
 8003e42:	d1c8      	bne.n	8003dd6 <OSInit+0xa6>
    }
#endif


#if OS_CFG_TMR_EN > 0u                                      /* Initialize the Timer Manager module                    */
    OS_TmrInit(p_err);
 8003e44:	4628      	mov	r0, r5
 8003e46:	f004 f871 	bl	8007f2c <OS_TmrInit>
    if (*p_err != OS_ERR_NONE) {
 8003e4a:	882b      	ldrh	r3, [r5, #0]
 8003e4c:	2b00      	cmp	r3, #0
 8003e4e:	d1c2      	bne.n	8003dd6 <OSInit+0xa6>
    }
#endif


#if OS_CFG_DBG_EN > 0u
    OS_Dbg_Init();
 8003e50:	f000 fdfa 	bl	8004a48 <OS_Dbg_Init>
#endif


    OSCfg_Init();
}
 8003e54:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
#if OS_CFG_DBG_EN > 0u
    OS_Dbg_Init();
#endif


    OSCfg_Init();
 8003e58:	f7ff bda6 	b.w	80039a8 <OSCfg_Init>
 8003e5c:	080160cc 	.word	0x080160cc
 8003e60:	cccccccd 	.word	0xcccccccd
 8003e64:	2000ef28 	.word	0x2000ef28
 8003e68:	2000ed84 	.word	0x2000ed84
 8003e6c:	2000e985 	.word	0x2000e985
 8003e70:	2000e974 	.word	0x2000e974
 8003e74:	2000ed58 	.word	0x2000ed58
 8003e78:	2000ed64 	.word	0x2000ed64
 8003e7c:	2000ec88 	.word	0x2000ec88
 8003e80:	2000ec7c 	.word	0x2000ec7c
 8003e84:	080160fc 	.word	0x080160fc
 8003e88:	2000ed60 	.word	0x2000ed60
 8003e8c:	2000ed54 	.word	0x2000ed54
 8003e90:	2000ef54 	.word	0x2000ef54
 8003e94:	2000ed68 	.word	0x2000ed68
 8003e98:	2000f030 	.word	0x2000f030
 8003e9c:	08016100 	.word	0x08016100
 8003ea0:	2000ec84 	.word	0x2000ec84
 8003ea4:	2000ed74 	.word	0x2000ed74
 8003ea8:	2000ef38 	.word	0x2000ef38
 8003eac:	2000ed78 	.word	0x2000ed78
 8003eb0:	2000e984 	.word	0x2000e984
 8003eb4:	2000ef48 	.word	0x2000ef48
 8003eb8:	2000e978 	.word	0x2000e978
 8003ebc:	2000ef2c 	.word	0x2000ef2c
 8003ec0:	2000e990 	.word	0x2000e990

08003ec4 <OS_PendDataInit>:
    OS_OBJ_QTY  i;



    p_tcb->PendDataTblEntries = tbl_size;                   /* Link the TCB to the beginning of the table             */
    p_tcb->PendDataTblPtr     = p_pend_data_tbl;
 8003ec4:	6301      	str	r1, [r0, #48]	; 0x30
{
    OS_OBJ_QTY  i;



    p_tcb->PendDataTblEntries = tbl_size;                   /* Link the TCB to the beginning of the table             */
 8003ec6:	87c2      	strh	r2, [r0, #62]	; 0x3e
    p_tcb->PendDataTblPtr     = p_pend_data_tbl;

    for (i = 0u; i < tbl_size; i++) {
 8003ec8:	b1ba      	cbz	r2, 8003efa <OS_PendDataInit+0x36>
 8003eca:	3a01      	subs	r2, #1
 8003ecc:	b292      	uxth	r2, r2
 8003ece:	3202      	adds	r2, #2
 8003ed0:	eb01 1242 	add.w	r2, r1, r2, lsl #5
        p_pend_data_tbl->NextPtr    = (OS_PEND_DATA *)0;    /* Initialize all the fields                              */
 8003ed4:	2300      	movs	r3, #0
 8003ed6:	3120      	adds	r1, #32
 8003ed8:	f841 3c1c 	str.w	r3, [r1, #-28]
        p_pend_data_tbl->PrevPtr    = (OS_PEND_DATA *)0;
 8003edc:	f841 3c20 	str.w	r3, [r1, #-32]
        p_pend_data_tbl->RdyObjPtr  = (OS_PEND_OBJ  *)0;
 8003ee0:	f841 3c10 	str.w	r3, [r1, #-16]
        p_pend_data_tbl->RdyMsgPtr  = (void         *)0;
 8003ee4:	f841 3c0c 	str.w	r3, [r1, #-12]
        p_pend_data_tbl->RdyMsgSize = (OS_MSG_SIZE   )0;
 8003ee8:	f821 3c08 	strh.w	r3, [r1, #-8]
        p_pend_data_tbl->RdyTS      = (CPU_TS        )0;
 8003eec:	f841 3c04 	str.w	r3, [r1, #-4]
        p_pend_data_tbl->TCBPtr     = p_tcb;                /* Every entry points back to the TCB of the task         */
 8003ef0:	f841 0c18 	str.w	r0, [r1, #-24]
 8003ef4:	3120      	adds	r1, #32


    p_tcb->PendDataTblEntries = tbl_size;                   /* Link the TCB to the beginning of the table             */
    p_tcb->PendDataTblPtr     = p_pend_data_tbl;

    for (i = 0u; i < tbl_size; i++) {
 8003ef6:	4291      	cmp	r1, r2
 8003ef8:	d1ee      	bne.n	8003ed8 <OS_PendDataInit+0x14>
 8003efa:	4770      	bx	lr

08003efc <OS_PendDbgNameAdd>:
    OS_PEND_LIST  *p_pend_list;
    OS_PEND_DATA  *p_pend_data;
    OS_TCB        *p_tcb1;


    if (p_obj != (OS_PEND_OBJ *)0) {
 8003efc:	b138      	cbz	r0, 8003f0e <OS_PendDbgNameAdd+0x12>
        p_tcb->DbgNamePtr =  p_obj->NamePtr;                /* Task pending on this object ... save name in TCB       */
        p_pend_list       = &p_obj->PendList;               /* Find name of HP task pending on this object ...        */
        p_pend_data       =  p_pend_list->HeadPtr;
        p_tcb1            =  p_pend_data->TCBPtr;
 8003efe:	6883      	ldr	r3, [r0, #8]
    OS_PEND_DATA  *p_pend_data;
    OS_TCB        *p_tcb1;


    if (p_obj != (OS_PEND_OBJ *)0) {
        p_tcb->DbgNamePtr =  p_obj->NamePtr;                /* Task pending on this object ... save name in TCB       */
 8003f00:	6842      	ldr	r2, [r0, #4]
        p_pend_list       = &p_obj->PendList;               /* Find name of HP task pending on this object ...        */
        p_pend_data       =  p_pend_list->HeadPtr;
        p_tcb1            =  p_pend_data->TCBPtr;
        p_obj->DbgNamePtr = p_tcb1->NamePtr;                /* ... Save in object                                     */
 8003f02:	689b      	ldr	r3, [r3, #8]
    OS_PEND_DATA  *p_pend_data;
    OS_TCB        *p_tcb1;


    if (p_obj != (OS_PEND_OBJ *)0) {
        p_tcb->DbgNamePtr =  p_obj->NamePtr;                /* Task pending on this object ... save name in TCB       */
 8003f04:	f8c1 20c0 	str.w	r2, [r1, #192]	; 0xc0
        p_pend_list       = &p_obj->PendList;               /* Find name of HP task pending on this object ...        */
        p_pend_data       =  p_pend_list->HeadPtr;
        p_tcb1            =  p_pend_data->TCBPtr;
        p_obj->DbgNamePtr = p_tcb1->NamePtr;                /* ... Save in object                                     */
 8003f08:	6a1b      	ldr	r3, [r3, #32]
 8003f0a:	61c3      	str	r3, [r0, #28]
 8003f0c:	4770      	bx	lr
    } else {
        switch (p_tcb->PendOn) {
 8003f0e:	f891 3034 	ldrb.w	r3, [r1, #52]	; 0x34
 8003f12:	2b02      	cmp	r3, #2
 8003f14:	d005      	beq.n	8003f22 <OS_PendDbgNameAdd+0x26>
 8003f16:	2b07      	cmp	r3, #7
 8003f18:	d107      	bne.n	8003f2a <OS_PendDbgNameAdd+0x2e>
            case OS_TASK_PEND_ON_TASK_Q:
                 p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)"Task Q");
                 break;

            case OS_TASK_PEND_ON_TASK_SEM:
                 p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)"Task Sem");
 8003f1a:	4b06      	ldr	r3, [pc, #24]	; (8003f34 <OS_PendDbgNameAdd+0x38>)
 8003f1c:	f8c1 30c0 	str.w	r3, [r1, #192]	; 0xc0
 8003f20:	4770      	bx	lr
        p_tcb1            =  p_pend_data->TCBPtr;
        p_obj->DbgNamePtr = p_tcb1->NamePtr;                /* ... Save in object                                     */
    } else {
        switch (p_tcb->PendOn) {
            case OS_TASK_PEND_ON_TASK_Q:
                 p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)"Task Q");
 8003f22:	4b05      	ldr	r3, [pc, #20]	; (8003f38 <OS_PendDbgNameAdd+0x3c>)
 8003f24:	f8c1 30c0 	str.w	r3, [r1, #192]	; 0xc0
 8003f28:	4770      	bx	lr
            case OS_TASK_PEND_ON_TASK_SEM:
                 p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)"Task Sem");
                 break;

            default:
                 p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)" ");
 8003f2a:	4b04      	ldr	r3, [pc, #16]	; (8003f3c <OS_PendDbgNameAdd+0x40>)
 8003f2c:	f8c1 30c0 	str.w	r3, [r1, #192]	; 0xc0
 8003f30:	4770      	bx	lr
 8003f32:	bf00      	nop
 8003f34:	08016650 	.word	0x08016650
 8003f38:	08016648 	.word	0x08016648
 8003f3c:	080182f0 	.word	0x080182f0

08003f40 <OS_PendDbgNameRemove>:
    OS_PEND_LIST  *p_pend_list;
    OS_PEND_DATA  *p_pend_data;
    OS_TCB        *p_tcb1;


    p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)" ");          /* Remove name of object pended on for readied task       */
 8003f40:	4a05      	ldr	r2, [pc, #20]	; (8003f58 <OS_PendDbgNameRemove+0x18>)
    p_pend_list       = &p_obj->PendList;
    p_pend_data       =  p_pend_list->HeadPtr;
 8003f42:	6883      	ldr	r3, [r0, #8]
    OS_PEND_LIST  *p_pend_list;
    OS_PEND_DATA  *p_pend_data;
    OS_TCB        *p_tcb1;


    p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)" ");          /* Remove name of object pended on for readied task       */
 8003f44:	f8c1 20c0 	str.w	r2, [r1, #192]	; 0xc0
    p_pend_list       = &p_obj->PendList;
    p_pend_data       =  p_pend_list->HeadPtr;
    if (p_pend_data  != (OS_PEND_DATA *)0) {
 8003f48:	b11b      	cbz	r3, 8003f52 <OS_PendDbgNameRemove+0x12>
        p_tcb1            = p_pend_data->TCBPtr;
        p_obj->DbgNamePtr = p_tcb1->NamePtr;
 8003f4a:	689b      	ldr	r3, [r3, #8]
 8003f4c:	6a1b      	ldr	r3, [r3, #32]
 8003f4e:	61c3      	str	r3, [r0, #28]
 8003f50:	4770      	bx	lr
    } else {
        p_obj->DbgNamePtr = (CPU_CHAR *)((void *)" ");      /* No other task pending on object                        */
 8003f52:	61c2      	str	r2, [r0, #28]
 8003f54:	4770      	bx	lr
 8003f56:	bf00      	nop
 8003f58:	080182f0 	.word	0x080182f0

08003f5c <OS_PendListInit>:
************************************************************************************************************************
*/

void  OS_PendListInit (OS_PEND_LIST  *p_pend_list)
{
    p_pend_list->HeadPtr    = (OS_PEND_DATA *)0;
 8003f5c:	2300      	movs	r3, #0
 8003f5e:	6003      	str	r3, [r0, #0]
    p_pend_list->TailPtr    = (OS_PEND_DATA *)0;
 8003f60:	6043      	str	r3, [r0, #4]
    p_pend_list->NbrEntries = (OS_OBJ_QTY    )0;
 8003f62:	8103      	strh	r3, [r0, #8]
 8003f64:	4770      	bx	lr
 8003f66:	bf00      	nop

08003f68 <OS_PendListInsertHead>:
{
    OS_PEND_DATA  *p_pend_data_next;



    p_pend_list->NbrEntries++;                              /* One more entry in the list                             */
 8003f68:	8903      	ldrh	r3, [r0, #8]
    p_pend_data->NextPtr  = p_pend_list->HeadPtr;           /* Adjust new entry's links                               */
 8003f6a:	6802      	ldr	r2, [r0, #0]
{
    OS_PEND_DATA  *p_pend_data_next;



    p_pend_list->NbrEntries++;                              /* One more entry in the list                             */
 8003f6c:	3301      	adds	r3, #1
************************************************************************************************************************
*/

void  OS_PendListInsertHead (OS_PEND_LIST  *p_pend_list,
                             OS_PEND_DATA  *p_pend_data)
{
 8003f6e:	b410      	push	{r4}
    OS_PEND_DATA  *p_pend_data_next;



    p_pend_list->NbrEntries++;                              /* One more entry in the list                             */
 8003f70:	b29b      	uxth	r3, r3
    p_pend_data->NextPtr  = p_pend_list->HeadPtr;           /* Adjust new entry's links                               */
    p_pend_data->PrevPtr  = (OS_PEND_DATA  *)0;
 8003f72:	2400      	movs	r4, #0
{
    OS_PEND_DATA  *p_pend_data_next;



    p_pend_list->NbrEntries++;                              /* One more entry in the list                             */
 8003f74:	8103      	strh	r3, [r0, #8]
    p_pend_data->NextPtr  = p_pend_list->HeadPtr;           /* Adjust new entry's links                               */
 8003f76:	604a      	str	r2, [r1, #4]
    p_pend_data->PrevPtr  = (OS_PEND_DATA  *)0;
 8003f78:	600c      	str	r4, [r1, #0]
    p_pend_data_next      = p_pend_list->HeadPtr;           /* Adjust old head of list's links                        */
    if (p_pend_data_next != (OS_PEND_DATA *)0) {            /* See if we already have a head to replace               */
 8003f7a:	b102      	cbz	r2, 8003f7e <OS_PendListInsertHead+0x16>
        p_pend_data_next->PrevPtr = p_pend_data;            /* Yes, point to new entry                                */
 8003f7c:	6011      	str	r1, [r2, #0]
    }
    p_pend_list->HeadPtr = p_pend_data;                     /* We have a new list head                                */
    if (p_pend_list->NbrEntries == 1u) {
 8003f7e:	2b01      	cmp	r3, #1
    p_pend_data->PrevPtr  = (OS_PEND_DATA  *)0;
    p_pend_data_next      = p_pend_list->HeadPtr;           /* Adjust old head of list's links                        */
    if (p_pend_data_next != (OS_PEND_DATA *)0) {            /* See if we already have a head to replace               */
        p_pend_data_next->PrevPtr = p_pend_data;            /* Yes, point to new entry                                */
    }
    p_pend_list->HeadPtr = p_pend_data;                     /* We have a new list head                                */
 8003f80:	6001      	str	r1, [r0, #0]
    if (p_pend_list->NbrEntries == 1u) {
        p_pend_list->TailPtr = p_pend_data;
 8003f82:	bf08      	it	eq
 8003f84:	6041      	streq	r1, [r0, #4]
    }
}
 8003f86:	bc10      	pop	{r4}
 8003f88:	4770      	bx	lr
 8003f8a:	bf00      	nop

08003f8c <OS_PendListInsertPrio>:



    p_tcb = p_pend_data->TCBPtr;                                      /* Obtain the priority of the task to insert    */
    prio  = p_tcb->Prio;
    if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0) {                   /* CASE 0: Insert when there are no entries     */
 8003f8c:	8902      	ldrh	r2, [r0, #8]
 8003f8e:	b1ba      	cbz	r2, 8003fc0 <OS_PendListInsertPrio+0x34>
************************************************************************************************************************
*/

void  OS_PendListInsertPrio (OS_PEND_LIST  *p_pend_list,
                             OS_PEND_DATA  *p_pend_data)
{
 8003f90:	b410      	push	{r4}
        p_pend_data->PrevPtr    = (OS_PEND_DATA *)0;
        p_pend_list->HeadPtr    = p_pend_data;                        /*                                              */
        p_pend_list->TailPtr    = p_pend_data;
    } else {
        p_pend_list->NbrEntries++;                                    /* CASE 1: One more OS_PEND_DATA in the list    */
        p_pend_data_next = p_pend_list->HeadPtr;
 8003f92:	6803      	ldr	r3, [r0, #0]
    OS_PEND_DATA  *p_pend_data_next;



    p_tcb = p_pend_data->TCBPtr;                                      /* Obtain the priority of the task to insert    */
    prio  = p_tcb->Prio;
 8003f94:	688c      	ldr	r4, [r1, #8]
        p_pend_data->NextPtr    = (OS_PEND_DATA *)0;                  /*         No other OS_PEND_DATAs in the list   */
        p_pend_data->PrevPtr    = (OS_PEND_DATA *)0;
        p_pend_list->HeadPtr    = p_pend_data;                        /*                                              */
        p_pend_list->TailPtr    = p_pend_data;
    } else {
        p_pend_list->NbrEntries++;                                    /* CASE 1: One more OS_PEND_DATA in the list    */
 8003f96:	3201      	adds	r2, #1
    OS_PEND_DATA  *p_pend_data_next;



    p_tcb = p_pend_data->TCBPtr;                                      /* Obtain the priority of the task to insert    */
    prio  = p_tcb->Prio;
 8003f98:	f894 4037 	ldrb.w	r4, [r4, #55]	; 0x37
        p_pend_data->NextPtr    = (OS_PEND_DATA *)0;                  /*         No other OS_PEND_DATAs in the list   */
        p_pend_data->PrevPtr    = (OS_PEND_DATA *)0;
        p_pend_list->HeadPtr    = p_pend_data;                        /*                                              */
        p_pend_list->TailPtr    = p_pend_data;
    } else {
        p_pend_list->NbrEntries++;                                    /* CASE 1: One more OS_PEND_DATA in the list    */
 8003f9c:	8102      	strh	r2, [r0, #8]
        p_pend_data_next = p_pend_list->HeadPtr;
        while (p_pend_data_next != (OS_PEND_DATA *)0) {               /*         Find the position where to insert    */
 8003f9e:	b913      	cbnz	r3, 8003fa6 <OS_PendListInsertPrio+0x1a>
 8003fa0:	e015      	b.n	8003fce <OS_PendListInsertPrio+0x42>
            p_tcb_next   = p_pend_data_next->TCBPtr;
            if (prio < p_tcb_next->Prio) {
                break;                                                /*         Found! ... insert BEFORE current     */
            } else {
                p_pend_data_next = p_pend_data_next->NextPtr;         /*         Not Found, follow the list           */
 8003fa2:	685b      	ldr	r3, [r3, #4]
        p_pend_list->HeadPtr    = p_pend_data;                        /*                                              */
        p_pend_list->TailPtr    = p_pend_data;
    } else {
        p_pend_list->NbrEntries++;                                    /* CASE 1: One more OS_PEND_DATA in the list    */
        p_pend_data_next = p_pend_list->HeadPtr;
        while (p_pend_data_next != (OS_PEND_DATA *)0) {               /*         Find the position where to insert    */
 8003fa4:	b19b      	cbz	r3, 8003fce <OS_PendListInsertPrio+0x42>
            p_tcb_next   = p_pend_data_next->TCBPtr;
            if (prio < p_tcb_next->Prio) {
 8003fa6:	689a      	ldr	r2, [r3, #8]
 8003fa8:	f892 2037 	ldrb.w	r2, [r2, #55]	; 0x37
 8003fac:	42a2      	cmp	r2, r4
 8003fae:	d9f8      	bls.n	8003fa2 <OS_PendListInsertPrio+0x16>
            p_pend_data_prev          = p_pend_list->TailPtr;
            p_pend_data->PrevPtr      = p_pend_data_prev;
            p_pend_data_prev->NextPtr = p_pend_data;
            p_pend_list->TailPtr      = p_pend_data;
        } else {
            if (p_pend_data_next->PrevPtr == (OS_PEND_DATA *)0) {     /*         Is new TCB highest priority?         */
 8003fb0:	681a      	ldr	r2, [r3, #0]
 8003fb2:	b1a2      	cbz	r2, 8003fde <OS_PendListInsertPrio+0x52>
                p_pend_data->NextPtr       = p_pend_data_next;
                p_pend_list->HeadPtr       = p_pend_data;
            } else {
                p_pend_data_prev           = p_pend_data_next->PrevPtr;/*        No,  insert in between two entries   */
                p_pend_data->PrevPtr       = p_pend_data_prev;
                p_pend_data->NextPtr       = p_pend_data_next;
 8003fb4:	e881 000c 	stmia.w	r1, {r2, r3}
                p_pend_data_prev->NextPtr  = p_pend_data;
 8003fb8:	6051      	str	r1, [r2, #4]
                p_pend_data_next->PrevPtr  = p_pend_data;
 8003fba:	6019      	str	r1, [r3, #0]
            }
        }
    }
}
 8003fbc:	bc10      	pop	{r4}
 8003fbe:	4770      	bx	lr


    p_tcb = p_pend_data->TCBPtr;                                      /* Obtain the priority of the task to insert    */
    prio  = p_tcb->Prio;
    if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0) {                   /* CASE 0: Insert when there are no entries     */
        p_pend_list->NbrEntries = (OS_OBJ_QTY)1;                      /*         This is the first entry              */
 8003fc0:	2301      	movs	r3, #1
 8003fc2:	8103      	strh	r3, [r0, #8]
        p_pend_data->NextPtr    = (OS_PEND_DATA *)0;                  /*         No other OS_PEND_DATAs in the list   */
 8003fc4:	604a      	str	r2, [r1, #4]
        p_pend_data->PrevPtr    = (OS_PEND_DATA *)0;
 8003fc6:	600a      	str	r2, [r1, #0]
        p_pend_list->HeadPtr    = p_pend_data;                        /*                                              */
 8003fc8:	6001      	str	r1, [r0, #0]
        p_pend_list->TailPtr    = p_pend_data;
 8003fca:	6041      	str	r1, [r0, #4]
 8003fcc:	4770      	bx	lr
                p_pend_data_next = p_pend_data_next->NextPtr;         /*         Not Found, follow the list           */
            }
        }
        if (p_pend_data_next == (OS_PEND_DATA *)0) {                  /*         TCB to insert is lower in prio       */
            p_pend_data->NextPtr      = (OS_PEND_DATA *)0;            /*         ... insert at the tail.              */
            p_pend_data_prev          = p_pend_list->TailPtr;
 8003fce:	6843      	ldr	r3, [r0, #4]
            } else {
                p_pend_data_next = p_pend_data_next->NextPtr;         /*         Not Found, follow the list           */
            }
        }
        if (p_pend_data_next == (OS_PEND_DATA *)0) {                  /*         TCB to insert is lower in prio       */
            p_pend_data->NextPtr      = (OS_PEND_DATA *)0;            /*         ... insert at the tail.              */
 8003fd0:	2200      	movs	r2, #0
            p_pend_data_prev          = p_pend_list->TailPtr;
            p_pend_data->PrevPtr      = p_pend_data_prev;
 8003fd2:	600b      	str	r3, [r1, #0]
            } else {
                p_pend_data_next = p_pend_data_next->NextPtr;         /*         Not Found, follow the list           */
            }
        }
        if (p_pend_data_next == (OS_PEND_DATA *)0) {                  /*         TCB to insert is lower in prio       */
            p_pend_data->NextPtr      = (OS_PEND_DATA *)0;            /*         ... insert at the tail.              */
 8003fd4:	604a      	str	r2, [r1, #4]
                p_pend_data_prev->NextPtr  = p_pend_data;
                p_pend_data_next->PrevPtr  = p_pend_data;
            }
        }
    }
}
 8003fd6:	bc10      	pop	{r4}
        }
        if (p_pend_data_next == (OS_PEND_DATA *)0) {                  /*         TCB to insert is lower in prio       */
            p_pend_data->NextPtr      = (OS_PEND_DATA *)0;            /*         ... insert at the tail.              */
            p_pend_data_prev          = p_pend_list->TailPtr;
            p_pend_data->PrevPtr      = p_pend_data_prev;
            p_pend_data_prev->NextPtr = p_pend_data;
 8003fd8:	6059      	str	r1, [r3, #4]
            p_pend_list->TailPtr      = p_pend_data;
 8003fda:	6041      	str	r1, [r0, #4]
                p_pend_data_prev->NextPtr  = p_pend_data;
                p_pend_data_next->PrevPtr  = p_pend_data;
            }
        }
    }
}
 8003fdc:	4770      	bx	lr
            p_pend_data->PrevPtr      = p_pend_data_prev;
            p_pend_data_prev->NextPtr = p_pend_data;
            p_pend_list->TailPtr      = p_pend_data;
        } else {
            if (p_pend_data_next->PrevPtr == (OS_PEND_DATA *)0) {     /*         Is new TCB highest priority?         */
                p_pend_data_next->PrevPtr  = p_pend_data;             /*         Yes, insert as new Head of list      */
 8003fde:	6019      	str	r1, [r3, #0]
                p_pend_data->PrevPtr       = (OS_PEND_DATA *)0;
                p_pend_data->NextPtr       = p_pend_data_next;
 8003fe0:	e881 000c 	stmia.w	r1, {r2, r3}
                p_pend_list->HeadPtr       = p_pend_data;
 8003fe4:	6001      	str	r1, [r0, #0]
 8003fe6:	e7e9      	b.n	8003fbc <OS_PendListInsertPrio+0x30>

08003fe8 <OS_PendListChangePrio>:
************************************************************************************************************************
*/

void  OS_PendListChangePrio (OS_TCB   *p_tcb,
                             OS_PRIO   prio_new)
{
 8003fe8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    OS_PEND_OBJ    *p_obj;


    p_tcb->Prio = prio_new;
    p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to first wait list entry                 */
    n_pend_list = p_tcb->PendDataTblEntries;                        /* Get the number of pend list task is in         */
 8003fea:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
    OS_PEND_DATA   *p_pend_data;
    OS_PEND_LIST   *p_pend_list;
    OS_PEND_OBJ    *p_obj;


    p_tcb->Prio = prio_new;
 8003fec:	f880 1037 	strb.w	r1, [r0, #55]	; 0x37
    p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to first wait list entry                 */
 8003ff0:	6b04      	ldr	r4, [r0, #48]	; 0x30
    n_pend_list = p_tcb->PendDataTblEntries;                        /* Get the number of pend list task is in         */

    while (n_pend_list > 0u) {
 8003ff2:	b30b      	cbz	r3, 8004038 <OS_PendListChangePrio+0x50>
 8003ff4:	1e5d      	subs	r5, r3, #1
 8003ff6:	b2ad      	uxth	r5, r5
 8003ff8:	3502      	adds	r5, #2
 8003ffa:	eb04 1545 	add.w	r5, r4, r5, lsl #5
        p_next               = p_pend_data->NextPtr;
        p_prev->NextPtr      = p_next;
        p_next->PrevPtr      = p_prev;
    }
    p_pend_list->NbrEntries--;                              /* One less entry in the list                             */
    p_pend_data->NextPtr = (OS_PEND_DATA *)0;
 8003ffe:	2700      	movs	r7, #0
 8004000:	3420      	adds	r4, #32
    p_tcb->Prio = prio_new;
    p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to first wait list entry                 */
    n_pend_list = p_tcb->PendDataTblEntries;                        /* Get the number of pend list task is in         */

    while (n_pend_list > 0u) {
        p_obj       =  p_pend_data->PendObjPtr;                     /* Get pointer to pend list                       */
 8004002:	f854 0c14 	ldr.w	r0, [r4, #-20]
 8004006:	f1a4 0120 	sub.w	r1, r4, #32
        p_pend_list = &p_obj->PendList;
        if (p_pend_list->NbrEntries > 1u) {                         /* Only move if multiple entries in the list      */
 800400a:	8a03      	ldrh	r3, [r0, #16]
 800400c:	2b01      	cmp	r3, #1
 800400e:	d910      	bls.n	8004032 <OS_PendListChangePrio+0x4a>

    if (p_pend_list->NbrEntries == 1u) {
        p_pend_list->HeadPtr = (OS_PEND_DATA *)0;           /* Only one entry in the pend list                        */
        p_pend_list->TailPtr = (OS_PEND_DATA *)0;

    } else if (p_pend_data->PrevPtr == (OS_PEND_DATA *)0) { /* See if entry is at the head of the list                */
 8004010:	f854 2c20 	ldr.w	r2, [r4, #-32]
        p_next               = p_pend_data->NextPtr;        /* Yes                                                    */
 8004014:	f854 6c1c 	ldr.w	r6, [r4, #-28]

    if (p_pend_list->NbrEntries == 1u) {
        p_pend_list->HeadPtr = (OS_PEND_DATA *)0;           /* Only one entry in the pend list                        */
        p_pend_list->TailPtr = (OS_PEND_DATA *)0;

    } else if (p_pend_data->PrevPtr == (OS_PEND_DATA *)0) { /* See if entry is at the head of the list                */
 8004018:	b17a      	cbz	r2, 800403a <OS_PendListChangePrio+0x52>
        p_next->PrevPtr      = (OS_PEND_DATA *)0;
        p_pend_list->HeadPtr = p_next;

    } else if (p_pend_data->NextPtr == (OS_PEND_DATA *)0) { /* See if entry is at the tail of the list                */
        p_prev               = p_pend_data->PrevPtr;        /* Yes                                                    */
        p_prev->NextPtr      = (OS_PEND_DATA *)0;
 800401a:	6056      	str	r6, [r2, #4]
    } else if (p_pend_data->PrevPtr == (OS_PEND_DATA *)0) { /* See if entry is at the head of the list                */
        p_next               = p_pend_data->NextPtr;        /* Yes                                                    */
        p_next->PrevPtr      = (OS_PEND_DATA *)0;
        p_pend_list->HeadPtr = p_next;

    } else if (p_pend_data->NextPtr == (OS_PEND_DATA *)0) { /* See if entry is at the tail of the list                */
 800401c:	b186      	cbz	r6, 8004040 <OS_PendListChangePrio+0x58>

    } else {
        p_prev               = p_pend_data->PrevPtr;        /* Remove from inside the list                            */
        p_next               = p_pend_data->NextPtr;
        p_prev->NextPtr      = p_next;
        p_next->PrevPtr      = p_prev;
 800401e:	6032      	str	r2, [r6, #0]
    }
    p_pend_list->NbrEntries--;                              /* One less entry in the list                             */
 8004020:	3b01      	subs	r3, #1
 8004022:	8203      	strh	r3, [r0, #16]
    p_pend_data->NextPtr = (OS_PEND_DATA *)0;
 8004024:	f844 7c1c 	str.w	r7, [r4, #-28]
    p_pend_data->PrevPtr = (OS_PEND_DATA *)0;
 8004028:	f844 7c20 	str.w	r7, [r4, #-32]
        p_obj       =  p_pend_data->PendObjPtr;                     /* Get pointer to pend list                       */
        p_pend_list = &p_obj->PendList;
        if (p_pend_list->NbrEntries > 1u) {                         /* Only move if multiple entries in the list      */
            OS_PendListRemove1(p_pend_list,                         /* Remove entry from current position             */
                               p_pend_data);
            OS_PendListInsertPrio(p_pend_list,                      /* INSERT it back in the list                     */
 800402c:	3008      	adds	r0, #8
 800402e:	f7ff ffad 	bl	8003f8c <OS_PendListInsertPrio>
 8004032:	3420      	adds	r4, #32

    p_tcb->Prio = prio_new;
    p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to first wait list entry                 */
    n_pend_list = p_tcb->PendDataTblEntries;                        /* Get the number of pend list task is in         */

    while (n_pend_list > 0u) {
 8004034:	42ac      	cmp	r4, r5
 8004036:	d1e4      	bne.n	8004002 <OS_PendListChangePrio+0x1a>
 8004038:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        p_pend_list->HeadPtr = (OS_PEND_DATA *)0;           /* Only one entry in the pend list                        */
        p_pend_list->TailPtr = (OS_PEND_DATA *)0;

    } else if (p_pend_data->PrevPtr == (OS_PEND_DATA *)0) { /* See if entry is at the head of the list                */
        p_next               = p_pend_data->NextPtr;        /* Yes                                                    */
        p_next->PrevPtr      = (OS_PEND_DATA *)0;
 800403a:	6032      	str	r2, [r6, #0]
        p_pend_list->HeadPtr = p_next;
 800403c:	6086      	str	r6, [r0, #8]
 800403e:	e7ef      	b.n	8004020 <OS_PendListChangePrio+0x38>

    } else if (p_pend_data->NextPtr == (OS_PEND_DATA *)0) { /* See if entry is at the tail of the list                */
        p_prev               = p_pend_data->PrevPtr;        /* Yes                                                    */
        p_prev->NextPtr      = (OS_PEND_DATA *)0;
        p_pend_list->TailPtr = p_prev;
 8004040:	60c2      	str	r2, [r0, #12]
 8004042:	e7ed      	b.n	8004020 <OS_PendListChangePrio+0x38>

08004044 <OS_PendListRemove>:
    OS_PEND_OBJ    *p_obj;



    p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
    n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */
 8004044:	8fc2      	ldrh	r2, [r0, #62]	; 0x3e
    OS_PEND_LIST   *p_pend_list;
    OS_PEND_OBJ    *p_obj;



    p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
 8004046:	6b03      	ldr	r3, [r0, #48]	; 0x30
    n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */

    while (n_pend_list > (OS_OBJ_QTY)0) {
 8004048:	b35a      	cbz	r2, 80040a2 <OS_PendListRemove+0x5e>
* Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
************************************************************************************************************************
*/

void  OS_PendListRemove (OS_TCB  *p_tcb)
{
 800404a:	b4f0      	push	{r4, r5, r6, r7}
 800404c:	1e57      	subs	r7, r2, #1
 800404e:	b2bf      	uxth	r7, r7
 8004050:	3702      	adds	r7, #2
 8004052:	eb03 1747 	add.w	r7, r3, r7, lsl #5
    OS_PEND_DATA  *p_next;



    if (p_pend_list->NbrEntries == 1u) {
        p_pend_list->HeadPtr = (OS_PEND_DATA *)0;           /* Only one entry in the pend list                        */
 8004056:	2500      	movs	r5, #0
 8004058:	3320      	adds	r3, #32
 800405a:	e010      	b.n	800407e <OS_PendListRemove+0x3a>
        p_pend_list->TailPtr = (OS_PEND_DATA *)0;

    } else if (p_pend_data->PrevPtr == (OS_PEND_DATA *)0) { /* See if entry is at the head of the list                */
 800405c:	f853 4c20 	ldr.w	r4, [r3, #-32]
        p_next               = p_pend_data->NextPtr;        /* Yes                                                    */
 8004060:	f853 6c1c 	ldr.w	r6, [r3, #-28]

    if (p_pend_list->NbrEntries == 1u) {
        p_pend_list->HeadPtr = (OS_PEND_DATA *)0;           /* Only one entry in the pend list                        */
        p_pend_list->TailPtr = (OS_PEND_DATA *)0;

    } else if (p_pend_data->PrevPtr == (OS_PEND_DATA *)0) { /* See if entry is at the head of the list                */
 8004064:	b19c      	cbz	r4, 800408e <OS_PendListRemove+0x4a>
        p_next->PrevPtr      = (OS_PEND_DATA *)0;
        p_pend_list->HeadPtr = p_next;

    } else if (p_pend_data->NextPtr == (OS_PEND_DATA *)0) { /* See if entry is at the tail of the list                */
        p_prev               = p_pend_data->PrevPtr;        /* Yes                                                    */
        p_prev->NextPtr      = (OS_PEND_DATA *)0;
 8004066:	6066      	str	r6, [r4, #4]
    } else if (p_pend_data->PrevPtr == (OS_PEND_DATA *)0) { /* See if entry is at the head of the list                */
        p_next               = p_pend_data->NextPtr;        /* Yes                                                    */
        p_next->PrevPtr      = (OS_PEND_DATA *)0;
        p_pend_list->HeadPtr = p_next;

    } else if (p_pend_data->NextPtr == (OS_PEND_DATA *)0) { /* See if entry is at the tail of the list                */
 8004068:	b1a6      	cbz	r6, 8004094 <OS_PendListRemove+0x50>

    } else {
        p_prev               = p_pend_data->PrevPtr;        /* Remove from inside the list                            */
        p_next               = p_pend_data->NextPtr;
        p_prev->NextPtr      = p_next;
        p_next->PrevPtr      = p_prev;
 800406a:	6034      	str	r4, [r6, #0]
    }
    p_pend_list->NbrEntries--;                              /* One less entry in the list                             */
 800406c:	3a01      	subs	r2, #1
 800406e:	820a      	strh	r2, [r1, #16]
 8004070:	3320      	adds	r3, #32
    p_pend_data->NextPtr = (OS_PEND_DATA *)0;
 8004072:	f843 5c3c 	str.w	r5, [r3, #-60]
    p_pend_data->PrevPtr = (OS_PEND_DATA *)0;
 8004076:	f843 5c40 	str.w	r5, [r3, #-64]


    p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
    n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */

    while (n_pend_list > (OS_OBJ_QTY)0) {
 800407a:	42bb      	cmp	r3, r7
 800407c:	d00c      	beq.n	8004098 <OS_PendListRemove+0x54>
        p_obj       =  p_pend_data->PendObjPtr;                     /* Get pointer to pend list                       */
 800407e:	f853 1c14 	ldr.w	r1, [r3, #-20]
    OS_PEND_DATA  *p_prev;
    OS_PEND_DATA  *p_next;



    if (p_pend_list->NbrEntries == 1u) {
 8004082:	8a0a      	ldrh	r2, [r1, #16]
 8004084:	2a01      	cmp	r2, #1
 8004086:	d1e9      	bne.n	800405c <OS_PendListRemove+0x18>
        p_pend_list->HeadPtr = (OS_PEND_DATA *)0;           /* Only one entry in the pend list                        */
 8004088:	608d      	str	r5, [r1, #8]
        p_pend_list->TailPtr = (OS_PEND_DATA *)0;
 800408a:	60cd      	str	r5, [r1, #12]
 800408c:	e7ee      	b.n	800406c <OS_PendListRemove+0x28>

    } else if (p_pend_data->PrevPtr == (OS_PEND_DATA *)0) { /* See if entry is at the head of the list                */
        p_next               = p_pend_data->NextPtr;        /* Yes                                                    */
        p_next->PrevPtr      = (OS_PEND_DATA *)0;
 800408e:	6034      	str	r4, [r6, #0]
        p_pend_list->HeadPtr = p_next;
 8004090:	608e      	str	r6, [r1, #8]
 8004092:	e7eb      	b.n	800406c <OS_PendListRemove+0x28>

    } else if (p_pend_data->NextPtr == (OS_PEND_DATA *)0) { /* See if entry is at the tail of the list                */
        p_prev               = p_pend_data->PrevPtr;        /* Yes                                                    */
        p_prev->NextPtr      = (OS_PEND_DATA *)0;
        p_pend_list->TailPtr = p_prev;
 8004094:	60cc      	str	r4, [r1, #12]
 8004096:	e7e9      	b.n	800406c <OS_PendListRemove+0x28>
        OS_PendListRemove1(p_pend_list,
                           p_pend_data);
        p_pend_data++;
        n_pend_list--;
    }
    p_tcb->PendDataTblEntries = (OS_OBJ_QTY    )0;
 8004098:	2300      	movs	r3, #0
 800409a:	87c3      	strh	r3, [r0, #62]	; 0x3e
    p_tcb->PendDataTblPtr     = (OS_PEND_DATA *)0;
 800409c:	6303      	str	r3, [r0, #48]	; 0x30
}
 800409e:	bcf0      	pop	{r4, r5, r6, r7}
 80040a0:	4770      	bx	lr
        OS_PendListRemove1(p_pend_list,
                           p_pend_data);
        p_pend_data++;
        n_pend_list--;
    }
    p_tcb->PendDataTblEntries = (OS_OBJ_QTY    )0;
 80040a2:	2300      	movs	r3, #0
 80040a4:	87c3      	strh	r3, [r0, #62]	; 0x3e
    p_tcb->PendDataTblPtr     = (OS_PEND_DATA *)0;
 80040a6:	6303      	str	r3, [r0, #48]	; 0x30
 80040a8:	4770      	bx	lr
 80040aa:	bf00      	nop

080040ac <OS_PendListRemove1>:
    OS_PEND_DATA  *p_prev;
    OS_PEND_DATA  *p_next;



    if (p_pend_list->NbrEntries == 1u) {
 80040ac:	8903      	ldrh	r3, [r0, #8]
************************************************************************************************************************
*/

void  OS_PendListRemove1 (OS_PEND_LIST  *p_pend_list,
                          OS_PEND_DATA  *p_pend_data)
{
 80040ae:	b410      	push	{r4}
    OS_PEND_DATA  *p_prev;
    OS_PEND_DATA  *p_next;



    if (p_pend_list->NbrEntries == 1u) {
 80040b0:	2b01      	cmp	r3, #1
 80040b2:	d00c      	beq.n	80040ce <OS_PendListRemove1+0x22>
        p_pend_list->HeadPtr = (OS_PEND_DATA *)0;           /* Only one entry in the pend list                        */
        p_pend_list->TailPtr = (OS_PEND_DATA *)0;

    } else if (p_pend_data->PrevPtr == (OS_PEND_DATA *)0) { /* See if entry is at the head of the list                */
        p_next               = p_pend_data->NextPtr;        /* Yes                                                    */
 80040b4:	e891 0014 	ldmia.w	r1, {r2, r4}

    if (p_pend_list->NbrEntries == 1u) {
        p_pend_list->HeadPtr = (OS_PEND_DATA *)0;           /* Only one entry in the pend list                        */
        p_pend_list->TailPtr = (OS_PEND_DATA *)0;

    } else if (p_pend_data->PrevPtr == (OS_PEND_DATA *)0) { /* See if entry is at the head of the list                */
 80040b8:	b16a      	cbz	r2, 80040d6 <OS_PendListRemove1+0x2a>
        p_next->PrevPtr      = (OS_PEND_DATA *)0;
        p_pend_list->HeadPtr = p_next;

    } else if (p_pend_data->NextPtr == (OS_PEND_DATA *)0) { /* See if entry is at the tail of the list                */
        p_prev               = p_pend_data->PrevPtr;        /* Yes                                                    */
        p_prev->NextPtr      = (OS_PEND_DATA *)0;
 80040ba:	6054      	str	r4, [r2, #4]
    } else if (p_pend_data->PrevPtr == (OS_PEND_DATA *)0) { /* See if entry is at the head of the list                */
        p_next               = p_pend_data->NextPtr;        /* Yes                                                    */
        p_next->PrevPtr      = (OS_PEND_DATA *)0;
        p_pend_list->HeadPtr = p_next;

    } else if (p_pend_data->NextPtr == (OS_PEND_DATA *)0) { /* See if entry is at the tail of the list                */
 80040bc:	b174      	cbz	r4, 80040dc <OS_PendListRemove1+0x30>

    } else {
        p_prev               = p_pend_data->PrevPtr;        /* Remove from inside the list                            */
        p_next               = p_pend_data->NextPtr;
        p_prev->NextPtr      = p_next;
        p_next->PrevPtr      = p_prev;
 80040be:	6022      	str	r2, [r4, #0]
    }
    p_pend_list->NbrEntries--;                              /* One less entry in the list                             */
    p_pend_data->NextPtr = (OS_PEND_DATA *)0;
 80040c0:	2200      	movs	r2, #0
        p_prev               = p_pend_data->PrevPtr;        /* Remove from inside the list                            */
        p_next               = p_pend_data->NextPtr;
        p_prev->NextPtr      = p_next;
        p_next->PrevPtr      = p_prev;
    }
    p_pend_list->NbrEntries--;                              /* One less entry in the list                             */
 80040c2:	3b01      	subs	r3, #1
 80040c4:	8103      	strh	r3, [r0, #8]
    p_pend_data->NextPtr = (OS_PEND_DATA *)0;
    p_pend_data->PrevPtr = (OS_PEND_DATA *)0;
}
 80040c6:	bc10      	pop	{r4}
        p_next               = p_pend_data->NextPtr;
        p_prev->NextPtr      = p_next;
        p_next->PrevPtr      = p_prev;
    }
    p_pend_list->NbrEntries--;                              /* One less entry in the list                             */
    p_pend_data->NextPtr = (OS_PEND_DATA *)0;
 80040c8:	604a      	str	r2, [r1, #4]
    p_pend_data->PrevPtr = (OS_PEND_DATA *)0;
 80040ca:	600a      	str	r2, [r1, #0]
}
 80040cc:	4770      	bx	lr
    OS_PEND_DATA  *p_next;



    if (p_pend_list->NbrEntries == 1u) {
        p_pend_list->HeadPtr = (OS_PEND_DATA *)0;           /* Only one entry in the pend list                        */
 80040ce:	2200      	movs	r2, #0
 80040d0:	6002      	str	r2, [r0, #0]
        p_pend_list->TailPtr = (OS_PEND_DATA *)0;
 80040d2:	6042      	str	r2, [r0, #4]
 80040d4:	e7f4      	b.n	80040c0 <OS_PendListRemove1+0x14>

    } else if (p_pend_data->PrevPtr == (OS_PEND_DATA *)0) { /* See if entry is at the head of the list                */
        p_next               = p_pend_data->NextPtr;        /* Yes                                                    */
        p_next->PrevPtr      = (OS_PEND_DATA *)0;
 80040d6:	6022      	str	r2, [r4, #0]
        p_pend_list->HeadPtr = p_next;
 80040d8:	6004      	str	r4, [r0, #0]
 80040da:	e7f1      	b.n	80040c0 <OS_PendListRemove1+0x14>

    } else if (p_pend_data->NextPtr == (OS_PEND_DATA *)0) { /* See if entry is at the tail of the list                */
        p_prev               = p_pend_data->PrevPtr;        /* Yes                                                    */
        p_prev->NextPtr      = (OS_PEND_DATA *)0;
        p_pend_list->TailPtr = p_prev;
 80040dc:	6042      	str	r2, [r0, #4]
 80040de:	e7ef      	b.n	80040c0 <OS_PendListRemove1+0x14>

080040e0 <OS_PendObjDel1>:
*/

void  OS_PendObjDel1 (OS_PEND_OBJ  *p_obj,
                      OS_TCB       *p_tcb,
                      CPU_TS        ts)
{
 80040e0:	b410      	push	{r4}
    OS_PEND_DATA   *p_pend_data;



    p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
    n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */
 80040e2:	8fcc      	ldrh	r4, [r1, #62]	; 0x3e
    OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
    OS_PEND_DATA   *p_pend_data;



    p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
 80040e4:	6b0b      	ldr	r3, [r1, #48]	; 0x30
    n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */

    while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
 80040e6:	b174      	cbz	r4, 8004106 <OS_PendObjDel1+0x26>
        if (p_obj == p_pend_data->PendObjPtr) {                     /* Did we find the object deleted?                */
 80040e8:	68d9      	ldr	r1, [r3, #12]
 80040ea:	4288      	cmp	r0, r1
 80040ec:	d00d      	beq.n	800410a <OS_PendObjDel1+0x2a>
 80040ee:	3c01      	subs	r4, #1
 80040f0:	b2a4      	uxth	r4, r4
 80040f2:	3401      	adds	r4, #1
 80040f4:	eb03 1444 	add.w	r4, r3, r4, lsl #5
 80040f8:	e002      	b.n	8004100 <OS_PendObjDel1+0x20>
 80040fa:	68d9      	ldr	r1, [r3, #12]
 80040fc:	4281      	cmp	r1, r0
 80040fe:	d004      	beq.n	800410a <OS_PendObjDel1+0x2a>
            p_pend_data->RdyObjPtr = p_obj;                         /* Yes, indicate the object in the .RdyObjPtr     */
            p_pend_data->RdyTS     = ts;                            /*      save the timestamp                        */
            break;
        }
        p_pend_data++;
 8004100:	3320      	adds	r3, #32


    p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
    n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */

    while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
 8004102:	42a3      	cmp	r3, r4
 8004104:	d1f9      	bne.n	80040fa <OS_PendObjDel1+0x1a>
            break;
        }
        p_pend_data++;
        n_pend_list--;
    }
}
 8004106:	bc10      	pop	{r4}
 8004108:	4770      	bx	lr
    p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
    n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */

    while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
        if (p_obj == p_pend_data->PendObjPtr) {                     /* Did we find the object deleted?                */
            p_pend_data->RdyObjPtr = p_obj;                         /* Yes, indicate the object in the .RdyObjPtr     */
 800410a:	6118      	str	r0, [r3, #16]
            p_pend_data->RdyTS     = ts;                            /*      save the timestamp                        */
 800410c:	61da      	str	r2, [r3, #28]
            break;
        }
        p_pend_data++;
        n_pend_list--;
    }
}
 800410e:	bc10      	pop	{r4}
 8004110:	4770      	bx	lr
 8004112:	bf00      	nop

08004114 <OS_PendAbort1>:
 8004114:	f7ff bfe4 	b.w	80040e0 <OS_PendObjDel1>

08004118 <OS_Post1>:
void  OS_Post1 (OS_PEND_OBJ  *p_obj,
                OS_TCB       *p_tcb,
                void         *p_void,
                OS_MSG_SIZE   msg_size,
                CPU_TS        ts)
{
 8004118:	b430      	push	{r4, r5}
    OS_PEND_DATA   *p_pend_data;



    p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
    n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */
 800411a:	8fcc      	ldrh	r4, [r1, #62]	; 0x3e
    OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
    OS_PEND_DATA   *p_pend_data;



    p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
 800411c:	6b09      	ldr	r1, [r1, #48]	; 0x30
    n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */

    while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
 800411e:	b174      	cbz	r4, 800413e <OS_Post1+0x26>
        if (p_obj == p_pend_data->PendObjPtr) {                     /* Did we find the object posted to?              */
 8004120:	68cd      	ldr	r5, [r1, #12]
 8004122:	42a8      	cmp	r0, r5
 8004124:	d00d      	beq.n	8004142 <OS_Post1+0x2a>
 8004126:	1e65      	subs	r5, r4, #1
 8004128:	b2ad      	uxth	r5, r5
 800412a:	3501      	adds	r5, #1
 800412c:	eb01 1545 	add.w	r5, r1, r5, lsl #5
 8004130:	e002      	b.n	8004138 <OS_Post1+0x20>
 8004132:	68cc      	ldr	r4, [r1, #12]
 8004134:	4284      	cmp	r4, r0
 8004136:	d004      	beq.n	8004142 <OS_Post1+0x2a>
            p_pend_data->RdyMsgPtr  = p_void;                       /*      store the message posted                  */
            p_pend_data->RdyMsgSize = msg_size;                     /*      store the size of the message posted      */
            p_pend_data->RdyTS      = ts;                           /*      save the timestamp of the post            */
            break;
        }
        p_pend_data++;
 8004138:	3120      	adds	r1, #32


    p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
    n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */

    while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
 800413a:	42a9      	cmp	r1, r5
 800413c:	d1f9      	bne.n	8004132 <OS_Post1+0x1a>
            break;
        }
        p_pend_data++;
        n_pend_list--;
    }
}
 800413e:	bc30      	pop	{r4, r5}
 8004140:	4770      	bx	lr

    while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
        if (p_obj == p_pend_data->PendObjPtr) {                     /* Did we find the object posted to?              */
            p_pend_data->RdyObjPtr  = p_obj;                        /* Yes, indicate the object in the .RdyObjPtr     */
            p_pend_data->RdyMsgPtr  = p_void;                       /*      store the message posted                  */
            p_pend_data->RdyMsgSize = msg_size;                     /*      store the size of the message posted      */
 8004142:	830b      	strh	r3, [r1, #24]
            p_pend_data->RdyTS      = ts;                           /*      save the timestamp of the post            */
 8004144:	9b02      	ldr	r3, [sp, #8]
    p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
    n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */

    while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
        if (p_obj == p_pend_data->PendObjPtr) {                     /* Did we find the object posted to?              */
            p_pend_data->RdyObjPtr  = p_obj;                        /* Yes, indicate the object in the .RdyObjPtr     */
 8004146:	6108      	str	r0, [r1, #16]
            p_pend_data->RdyMsgPtr  = p_void;                       /*      store the message posted                  */
 8004148:	614a      	str	r2, [r1, #20]
            p_pend_data->RdyMsgSize = msg_size;                     /*      store the size of the message posted      */
            p_pend_data->RdyTS      = ts;                           /*      save the timestamp of the post            */
 800414a:	61cb      	str	r3, [r1, #28]
            break;
        }
        p_pend_data++;
        n_pend_list--;
    }
}
 800414c:	bc30      	pop	{r4, r5}
 800414e:	4770      	bx	lr

08004150 <OS_RdyListInit>:
* Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
************************************************************************************************************************
*/

void  OS_RdyListInit (void)
{
 8004150:	4b06      	ldr	r3, [pc, #24]	; (800416c <OS_RdyListInit+0x1c>)



    for (i = 0u; i < OS_CFG_PRIO_MAX; i++) {                /* Initialize the array of OS_RDY_LIST at each priority   */
        p_rdy_list = &OSRdyList[i];
        p_rdy_list->NbrEntries = (OS_OBJ_QTY)0;
 8004152:	2200      	movs	r2, #0
 8004154:	f503 713d 	add.w	r1, r3, #756	; 0x2f4
 8004158:	801a      	strh	r2, [r3, #0]
        p_rdy_list->HeadPtr    = (OS_TCB   *)0;
 800415a:	f843 2c08 	str.w	r2, [r3, #-8]
        p_rdy_list->TailPtr    = (OS_TCB   *)0;
 800415e:	f843 2c04 	str.w	r2, [r3, #-4]
 8004162:	330c      	adds	r3, #12
    OS_PRIO       i;
    OS_RDY_LIST  *p_rdy_list;



    for (i = 0u; i < OS_CFG_PRIO_MAX; i++) {                /* Initialize the array of OS_RDY_LIST at each priority   */
 8004164:	428b      	cmp	r3, r1
 8004166:	d1f7      	bne.n	8004158 <OS_RdyListInit+0x8>
        p_rdy_list = &OSRdyList[i];
        p_rdy_list->NbrEntries = (OS_OBJ_QTY)0;
        p_rdy_list->HeadPtr    = (OS_TCB   *)0;
        p_rdy_list->TailPtr    = (OS_TCB   *)0;
    }
}
 8004168:	4770      	bx	lr
 800416a:	bf00      	nop
 800416c:	2000e990 	.word	0x2000e990

08004170 <OS_RdyListInsert>:
* Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
************************************************************************************************************************
*/

void  OS_RdyListInsert (OS_TCB  *p_tcb)
{
 8004170:	b570      	push	{r4, r5, r6, lr}
 8004172:	4604      	mov	r4, r0
    OS_PrioInsert(p_tcb->Prio);
 8004174:	f890 0037 	ldrb.w	r0, [r0, #55]	; 0x37
 8004178:	f001 fb1e 	bl	80057b8 <OS_PrioInsert>
    if (p_tcb->Prio == OSPrioCur) {                         /* Are we readying a task at the same prio?               */
 800417c:	4a19      	ldr	r2, [pc, #100]	; (80041e4 <OS_RdyListInsert+0x74>)
 800417e:	f894 3037 	ldrb.w	r3, [r4, #55]	; 0x37
 8004182:	7812      	ldrb	r2, [r2, #0]
 8004184:	429a      	cmp	r2, r3
 8004186:	d016      	beq.n	80041b6 <OS_RdyListInsert+0x46>
    OS_TCB       *p_tcb2;



    p_rdy_list = &OSRdyList[p_tcb->Prio];
    if (p_rdy_list->NbrEntries == (OS_OBJ_QTY)0) {          /* CASE 0: Insert when there are no entries               */
 8004188:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800418c:	4916      	ldr	r1, [pc, #88]	; (80041e8 <OS_RdyListInsert+0x78>)
 800418e:	009b      	lsls	r3, r3, #2
 8004190:	18c8      	adds	r0, r1, r3
 8004192:	8902      	ldrh	r2, [r0, #8]
 8004194:	b142      	cbz	r2, 80041a8 <OS_RdyListInsert+0x38>
        p_tcb->PrevPtr         =  (OS_TCB   *)0;
        p_rdy_list->HeadPtr    =  p_tcb;                    /*         Both list pointers point to this OS_TCB        */
        p_rdy_list->TailPtr    =  p_tcb;
    } else {                                                /* CASE 1: Insert BEFORE the current head of list         */
        p_rdy_list->NbrEntries++;                           /*         One more OS_TCB in the list                    */
        p_tcb->NextPtr         = p_rdy_list->HeadPtr;       /*         Adjust new OS_TCBs links                       */
 8004196:	58cd      	ldr	r5, [r1, r3]
        p_tcb->NextPtr         =  (OS_TCB   *)0;            /*         No other OS_TCBs in the list                   */
        p_tcb->PrevPtr         =  (OS_TCB   *)0;
        p_rdy_list->HeadPtr    =  p_tcb;                    /*         Both list pointers point to this OS_TCB        */
        p_rdy_list->TailPtr    =  p_tcb;
    } else {                                                /* CASE 1: Insert BEFORE the current head of list         */
        p_rdy_list->NbrEntries++;                           /*         One more OS_TCB in the list                    */
 8004198:	3201      	adds	r2, #1
        p_tcb->NextPtr         = p_rdy_list->HeadPtr;       /*         Adjust new OS_TCBs links                       */
        p_tcb->PrevPtr         = (OS_TCB    *)0;
 800419a:	2600      	movs	r6, #0
        p_tcb->NextPtr         =  (OS_TCB   *)0;            /*         No other OS_TCBs in the list                   */
        p_tcb->PrevPtr         =  (OS_TCB   *)0;
        p_rdy_list->HeadPtr    =  p_tcb;                    /*         Both list pointers point to this OS_TCB        */
        p_rdy_list->TailPtr    =  p_tcb;
    } else {                                                /* CASE 1: Insert BEFORE the current head of list         */
        p_rdy_list->NbrEntries++;                           /*         One more OS_TCB in the list                    */
 800419c:	8102      	strh	r2, [r0, #8]
        p_tcb->NextPtr         = p_rdy_list->HeadPtr;       /*         Adjust new OS_TCBs links                       */
 800419e:	60e5      	str	r5, [r4, #12]
        p_tcb->PrevPtr         = (OS_TCB    *)0;
 80041a0:	6126      	str	r6, [r4, #16]
        p_tcb2                 = p_rdy_list->HeadPtr;       /*         Adjust old head of list's links                */
        p_tcb2->PrevPtr        = p_tcb;
 80041a2:	612c      	str	r4, [r5, #16]
        p_rdy_list->HeadPtr    = p_tcb;
 80041a4:	50cc      	str	r4, [r1, r3]
 80041a6:	bd70      	pop	{r4, r5, r6, pc}



    p_rdy_list = &OSRdyList[p_tcb->Prio];
    if (p_rdy_list->NbrEntries == (OS_OBJ_QTY)0) {          /* CASE 0: Insert when there are no entries               */
        p_rdy_list->NbrEntries =  (OS_OBJ_QTY)1;            /*         This is the first entry                        */
 80041a8:	2501      	movs	r5, #1
 80041aa:	8105      	strh	r5, [r0, #8]
        p_tcb->NextPtr         =  (OS_TCB   *)0;            /*         No other OS_TCBs in the list                   */
 80041ac:	60e2      	str	r2, [r4, #12]
        p_tcb->PrevPtr         =  (OS_TCB   *)0;
 80041ae:	6122      	str	r2, [r4, #16]
        p_rdy_list->HeadPtr    =  p_tcb;                    /*         Both list pointers point to this OS_TCB        */
 80041b0:	50cc      	str	r4, [r1, r3]
        p_rdy_list->TailPtr    =  p_tcb;
 80041b2:	6044      	str	r4, [r0, #4]
 80041b4:	bd70      	pop	{r4, r5, r6, pc}
    OS_TCB       *p_tcb2;



    p_rdy_list = &OSRdyList[p_tcb->Prio];
    if (p_rdy_list->NbrEntries == (OS_OBJ_QTY)0) {          /* CASE 0: Insert when there are no entries               */
 80041b6:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 80041ba:	480b      	ldr	r0, [pc, #44]	; (80041e8 <OS_RdyListInsert+0x78>)
 80041bc:	0092      	lsls	r2, r2, #2
 80041be:	1883      	adds	r3, r0, r2
 80041c0:	8919      	ldrh	r1, [r3, #8]
 80041c2:	b931      	cbnz	r1, 80041d2 <OS_RdyListInsert+0x62>
        p_rdy_list->NbrEntries  = (OS_OBJ_QTY)1;            /*         This is the first entry                        */
 80041c4:	2501      	movs	r5, #1
 80041c6:	811d      	strh	r5, [r3, #8]
        p_tcb->NextPtr          = (OS_TCB   *)0;            /*         No other OS_TCBs in the list                   */
 80041c8:	60e1      	str	r1, [r4, #12]
        p_tcb->PrevPtr          = (OS_TCB   *)0;
 80041ca:	6121      	str	r1, [r4, #16]
        p_rdy_list->HeadPtr     = p_tcb;                    /*         Both list pointers point to this OS_TCB        */
 80041cc:	5084      	str	r4, [r0, r2]
        p_rdy_list->TailPtr     = p_tcb;
 80041ce:	605c      	str	r4, [r3, #4]
 80041d0:	bd70      	pop	{r4, r5, r6, pc}
    } else {                                                /* CASE 1: Insert AFTER the current tail of list          */
        p_rdy_list->NbrEntries++;                           /*         One more OS_TCB in the list                    */
        p_tcb->NextPtr          = (OS_TCB   *)0;            /*         Adjust new OS_TCBs links                       */
        p_tcb2                  = p_rdy_list->TailPtr;
 80041d2:	685a      	ldr	r2, [r3, #4]
        p_tcb->NextPtr          = (OS_TCB   *)0;            /*         No other OS_TCBs in the list                   */
        p_tcb->PrevPtr          = (OS_TCB   *)0;
        p_rdy_list->HeadPtr     = p_tcb;                    /*         Both list pointers point to this OS_TCB        */
        p_rdy_list->TailPtr     = p_tcb;
    } else {                                                /* CASE 1: Insert AFTER the current tail of list          */
        p_rdy_list->NbrEntries++;                           /*         One more OS_TCB in the list                    */
 80041d4:	3101      	adds	r1, #1
        p_tcb->NextPtr          = (OS_TCB   *)0;            /*         Adjust new OS_TCBs links                       */
 80041d6:	2000      	movs	r0, #0
        p_tcb->NextPtr          = (OS_TCB   *)0;            /*         No other OS_TCBs in the list                   */
        p_tcb->PrevPtr          = (OS_TCB   *)0;
        p_rdy_list->HeadPtr     = p_tcb;                    /*         Both list pointers point to this OS_TCB        */
        p_rdy_list->TailPtr     = p_tcb;
    } else {                                                /* CASE 1: Insert AFTER the current tail of list          */
        p_rdy_list->NbrEntries++;                           /*         One more OS_TCB in the list                    */
 80041d8:	8119      	strh	r1, [r3, #8]
        p_tcb->NextPtr          = (OS_TCB   *)0;            /*         Adjust new OS_TCBs links                       */
        p_tcb2                  = p_rdy_list->TailPtr;
        p_tcb->PrevPtr          = p_tcb2;
 80041da:	6122      	str	r2, [r4, #16]
        p_tcb->PrevPtr          = (OS_TCB   *)0;
        p_rdy_list->HeadPtr     = p_tcb;                    /*         Both list pointers point to this OS_TCB        */
        p_rdy_list->TailPtr     = p_tcb;
    } else {                                                /* CASE 1: Insert AFTER the current tail of list          */
        p_rdy_list->NbrEntries++;                           /*         One more OS_TCB in the list                    */
        p_tcb->NextPtr          = (OS_TCB   *)0;            /*         Adjust new OS_TCBs links                       */
 80041dc:	60e0      	str	r0, [r4, #12]
        p_tcb2                  = p_rdy_list->TailPtr;
        p_tcb->PrevPtr          = p_tcb2;
        p_tcb2->NextPtr         = p_tcb;                    /*         Adjust old tail of list's links                */
 80041de:	60d4      	str	r4, [r2, #12]
        p_rdy_list->TailPtr     = p_tcb;
 80041e0:	605c      	str	r4, [r3, #4]
 80041e2:	bd70      	pop	{r4, r5, r6, pc}
 80041e4:	2000ec88 	.word	0x2000ec88
 80041e8:	2000e988 	.word	0x2000e988

080041ec <OS_RdyListInsertHead>:
    OS_RDY_LIST  *p_rdy_list;
    OS_TCB       *p_tcb2;



    p_rdy_list = &OSRdyList[p_tcb->Prio];
 80041ec:	f890 3037 	ldrb.w	r3, [r0, #55]	; 0x37
    if (p_rdy_list->NbrEntries == (OS_OBJ_QTY)0) {          /* CASE 0: Insert when there are no entries               */
 80041f0:	490c      	ldr	r1, [pc, #48]	; (8004224 <OS_RdyListInsertHead+0x38>)
 80041f2:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80041f6:	009b      	lsls	r3, r3, #2
* Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
************************************************************************************************************************
*/

void  OS_RdyListInsertHead (OS_TCB  *p_tcb)
{
 80041f8:	b470      	push	{r4, r5, r6}
    OS_TCB       *p_tcb2;



    p_rdy_list = &OSRdyList[p_tcb->Prio];
    if (p_rdy_list->NbrEntries == (OS_OBJ_QTY)0) {          /* CASE 0: Insert when there are no entries               */
 80041fa:	18cc      	adds	r4, r1, r3
 80041fc:	8922      	ldrh	r2, [r4, #8]
 80041fe:	b14a      	cbz	r2, 8004214 <OS_RdyListInsertHead+0x28>
        p_tcb->PrevPtr         =  (OS_TCB   *)0;
        p_rdy_list->HeadPtr    =  p_tcb;                    /*         Both list pointers point to this OS_TCB        */
        p_rdy_list->TailPtr    =  p_tcb;
    } else {                                                /* CASE 1: Insert BEFORE the current head of list         */
        p_rdy_list->NbrEntries++;                           /*         One more OS_TCB in the list                    */
        p_tcb->NextPtr         = p_rdy_list->HeadPtr;       /*         Adjust new OS_TCBs links                       */
 8004200:	58cd      	ldr	r5, [r1, r3]
        p_tcb->PrevPtr         = (OS_TCB    *)0;
 8004202:	2600      	movs	r6, #0
        p_tcb->NextPtr         =  (OS_TCB   *)0;            /*         No other OS_TCBs in the list                   */
        p_tcb->PrevPtr         =  (OS_TCB   *)0;
        p_rdy_list->HeadPtr    =  p_tcb;                    /*         Both list pointers point to this OS_TCB        */
        p_rdy_list->TailPtr    =  p_tcb;
    } else {                                                /* CASE 1: Insert BEFORE the current head of list         */
        p_rdy_list->NbrEntries++;                           /*         One more OS_TCB in the list                    */
 8004204:	3201      	adds	r2, #1
 8004206:	8122      	strh	r2, [r4, #8]
        p_tcb->NextPtr         = p_rdy_list->HeadPtr;       /*         Adjust new OS_TCBs links                       */
 8004208:	60c5      	str	r5, [r0, #12]
        p_tcb->PrevPtr         = (OS_TCB    *)0;
 800420a:	6106      	str	r6, [r0, #16]
        p_tcb2                 = p_rdy_list->HeadPtr;       /*         Adjust old head of list's links                */
        p_tcb2->PrevPtr        = p_tcb;
 800420c:	6128      	str	r0, [r5, #16]
        p_rdy_list->HeadPtr    = p_tcb;
 800420e:	50c8      	str	r0, [r1, r3]
    }
}
 8004210:	bc70      	pop	{r4, r5, r6}
 8004212:	4770      	bx	lr



    p_rdy_list = &OSRdyList[p_tcb->Prio];
    if (p_rdy_list->NbrEntries == (OS_OBJ_QTY)0) {          /* CASE 0: Insert when there are no entries               */
        p_rdy_list->NbrEntries =  (OS_OBJ_QTY)1;            /*         This is the first entry                        */
 8004214:	2501      	movs	r5, #1
 8004216:	8125      	strh	r5, [r4, #8]
        p_tcb->NextPtr         =  (OS_TCB   *)0;            /*         No other OS_TCBs in the list                   */
 8004218:	60c2      	str	r2, [r0, #12]
        p_tcb->PrevPtr         =  (OS_TCB   *)0;
 800421a:	6102      	str	r2, [r0, #16]
        p_rdy_list->HeadPtr    =  p_tcb;                    /*         Both list pointers point to this OS_TCB        */
        p_rdy_list->TailPtr    =  p_tcb;
 800421c:	6060      	str	r0, [r4, #4]
    p_rdy_list = &OSRdyList[p_tcb->Prio];
    if (p_rdy_list->NbrEntries == (OS_OBJ_QTY)0) {          /* CASE 0: Insert when there are no entries               */
        p_rdy_list->NbrEntries =  (OS_OBJ_QTY)1;            /*         This is the first entry                        */
        p_tcb->NextPtr         =  (OS_TCB   *)0;            /*         No other OS_TCBs in the list                   */
        p_tcb->PrevPtr         =  (OS_TCB   *)0;
        p_rdy_list->HeadPtr    =  p_tcb;                    /*         Both list pointers point to this OS_TCB        */
 800421e:	50c8      	str	r0, [r1, r3]
        p_tcb->PrevPtr         = (OS_TCB    *)0;
        p_tcb2                 = p_rdy_list->HeadPtr;       /*         Adjust old head of list's links                */
        p_tcb2->PrevPtr        = p_tcb;
        p_rdy_list->HeadPtr    = p_tcb;
    }
}
 8004220:	bc70      	pop	{r4, r5, r6}
 8004222:	4770      	bx	lr
 8004224:	2000e988 	.word	0x2000e988

08004228 <OS_RdyListInsertTail>:
    OS_RDY_LIST  *p_rdy_list;
    OS_TCB       *p_tcb2;



    p_rdy_list = &OSRdyList[p_tcb->Prio];
 8004228:	f890 3037 	ldrb.w	r3, [r0, #55]	; 0x37
* Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
************************************************************************************************************************
*/

void  OS_RdyListInsertTail (OS_TCB  *p_tcb)
{
 800422c:	b430      	push	{r4, r5}
    OS_TCB       *p_tcb2;



    p_rdy_list = &OSRdyList[p_tcb->Prio];
    if (p_rdy_list->NbrEntries == (OS_OBJ_QTY)0) {          /* CASE 0: Insert when there are no entries               */
 800422e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8004232:	4c0b      	ldr	r4, [pc, #44]	; (8004260 <OS_RdyListInsertTail+0x38>)
 8004234:	009b      	lsls	r3, r3, #2
 8004236:	18e2      	adds	r2, r4, r3
 8004238:	8911      	ldrh	r1, [r2, #8]
 800423a:	b149      	cbz	r1, 8004250 <OS_RdyListInsertTail+0x28>
        p_rdy_list->HeadPtr     = p_tcb;                    /*         Both list pointers point to this OS_TCB        */
        p_rdy_list->TailPtr     = p_tcb;
    } else {                                                /* CASE 1: Insert AFTER the current tail of list          */
        p_rdy_list->NbrEntries++;                           /*         One more OS_TCB in the list                    */
        p_tcb->NextPtr          = (OS_TCB   *)0;            /*         Adjust new OS_TCBs links                       */
        p_tcb2                  = p_rdy_list->TailPtr;
 800423c:	6853      	ldr	r3, [r2, #4]
        p_tcb->PrevPtr          = (OS_TCB   *)0;
        p_rdy_list->HeadPtr     = p_tcb;                    /*         Both list pointers point to this OS_TCB        */
        p_rdy_list->TailPtr     = p_tcb;
    } else {                                                /* CASE 1: Insert AFTER the current tail of list          */
        p_rdy_list->NbrEntries++;                           /*         One more OS_TCB in the list                    */
        p_tcb->NextPtr          = (OS_TCB   *)0;            /*         Adjust new OS_TCBs links                       */
 800423e:	2400      	movs	r4, #0
        p_tcb->NextPtr          = (OS_TCB   *)0;            /*         No other OS_TCBs in the list                   */
        p_tcb->PrevPtr          = (OS_TCB   *)0;
        p_rdy_list->HeadPtr     = p_tcb;                    /*         Both list pointers point to this OS_TCB        */
        p_rdy_list->TailPtr     = p_tcb;
    } else {                                                /* CASE 1: Insert AFTER the current tail of list          */
        p_rdy_list->NbrEntries++;                           /*         One more OS_TCB in the list                    */
 8004240:	3101      	adds	r1, #1
 8004242:	8111      	strh	r1, [r2, #8]
        p_tcb->NextPtr          = (OS_TCB   *)0;            /*         Adjust new OS_TCBs links                       */
 8004244:	60c4      	str	r4, [r0, #12]
        p_tcb2                  = p_rdy_list->TailPtr;
        p_tcb->PrevPtr          = p_tcb2;
 8004246:	6103      	str	r3, [r0, #16]
        p_tcb2->NextPtr         = p_tcb;                    /*         Adjust old tail of list's links                */
        p_rdy_list->TailPtr     = p_tcb;
    }
}
 8004248:	bc30      	pop	{r4, r5}
    } else {                                                /* CASE 1: Insert AFTER the current tail of list          */
        p_rdy_list->NbrEntries++;                           /*         One more OS_TCB in the list                    */
        p_tcb->NextPtr          = (OS_TCB   *)0;            /*         Adjust new OS_TCBs links                       */
        p_tcb2                  = p_rdy_list->TailPtr;
        p_tcb->PrevPtr          = p_tcb2;
        p_tcb2->NextPtr         = p_tcb;                    /*         Adjust old tail of list's links                */
 800424a:	60d8      	str	r0, [r3, #12]
        p_rdy_list->TailPtr     = p_tcb;
 800424c:	6050      	str	r0, [r2, #4]
    }
}
 800424e:	4770      	bx	lr



    p_rdy_list = &OSRdyList[p_tcb->Prio];
    if (p_rdy_list->NbrEntries == (OS_OBJ_QTY)0) {          /* CASE 0: Insert when there are no entries               */
        p_rdy_list->NbrEntries  = (OS_OBJ_QTY)1;            /*         This is the first entry                        */
 8004250:	2501      	movs	r5, #1
 8004252:	8115      	strh	r5, [r2, #8]
        p_tcb->NextPtr          = (OS_TCB   *)0;            /*         No other OS_TCBs in the list                   */
 8004254:	60c1      	str	r1, [r0, #12]
        p_tcb->PrevPtr          = (OS_TCB   *)0;
 8004256:	6101      	str	r1, [r0, #16]
        p_rdy_list->HeadPtr     = p_tcb;                    /*         Both list pointers point to this OS_TCB        */
 8004258:	50e0      	str	r0, [r4, r3]
        p_rdy_list->TailPtr     = p_tcb;
 800425a:	6050      	str	r0, [r2, #4]
        p_tcb2                  = p_rdy_list->TailPtr;
        p_tcb->PrevPtr          = p_tcb2;
        p_tcb2->NextPtr         = p_tcb;                    /*         Adjust old tail of list's links                */
        p_rdy_list->TailPtr     = p_tcb;
    }
}
 800425c:	bc30      	pop	{r4, r5}
 800425e:	4770      	bx	lr
 8004260:	2000e988 	.word	0x2000e988

08004264 <OS_RdyListMoveHeadToTail>:
    OS_TCB  *p_tcb2;
    OS_TCB  *p_tcb3;



    switch (p_rdy_list->NbrEntries) {
 8004264:	8903      	ldrh	r3, [r0, #8]
 8004266:	2b01      	cmp	r3, #1
 8004268:	d90d      	bls.n	8004286 <OS_RdyListMoveHeadToTail+0x22>
 800426a:	2b02      	cmp	r3, #2
 800426c:	d00c      	beq.n	8004288 <OS_RdyListMoveHeadToTail+0x24>
             p_rdy_list->HeadPtr = p_tcb2;
             p_rdy_list->TailPtr = p_tcb1;
             break;

        default:                                            /* Move only if there are more than 2 OS_TCBs in the list */
             p_tcb1              = p_rdy_list->HeadPtr;     /* Point to current head                                  */
 800426e:	6803      	ldr	r3, [r0, #0]
             p_tcb2              = p_rdy_list->TailPtr;     /* Point to current tail                                  */
 8004270:	6841      	ldr	r1, [r0, #4]
             p_tcb3              = p_tcb1->NextPtr;         /* Point to new list head                                 */
 8004272:	68da      	ldr	r2, [r3, #12]
* Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
************************************************************************************************************************
*/

void  OS_RdyListMoveHeadToTail (OS_RDY_LIST  *p_rdy_list)
{
 8004274:	b410      	push	{r4}

        default:                                            /* Move only if there are more than 2 OS_TCBs in the list */
             p_tcb1              = p_rdy_list->HeadPtr;     /* Point to current head                                  */
             p_tcb2              = p_rdy_list->TailPtr;     /* Point to current tail                                  */
             p_tcb3              = p_tcb1->NextPtr;         /* Point to new list head                                 */
             p_tcb3->PrevPtr     = (OS_TCB *)0;             /* Adjust back    link of new list head                   */
 8004276:	2400      	movs	r4, #0
 8004278:	6114      	str	r4, [r2, #16]
             p_tcb1->NextPtr     = (OS_TCB *)0;             /* Adjust forward link of new list tail                   */
 800427a:	60dc      	str	r4, [r3, #12]
             p_tcb1->PrevPtr     = p_tcb2;                  /* Adjust back    link of new list tail                   */
 800427c:	6119      	str	r1, [r3, #16]
             p_tcb2->NextPtr     = p_tcb1;                  /* Adjust forward link of old list tail                   */
 800427e:	60cb      	str	r3, [r1, #12]
             p_rdy_list->HeadPtr = p_tcb3;                  /* Adjust new list head and tail pointers                 */
             p_rdy_list->TailPtr = p_tcb1;
 8004280:	e880 000c 	stmia.w	r0, {r2, r3}
             break;
    }
}
 8004284:	bc10      	pop	{r4}
 8004286:	4770      	bx	lr
        case 0:
        case 1:
             break;

        case 2:                                             /* SWAP the TCBs                                          */
             p_tcb1              = p_rdy_list->HeadPtr;     /* Point to current head                                  */
 8004288:	6803      	ldr	r3, [r0, #0]
             p_tcb2              = p_rdy_list->TailPtr;     /* Point to current tail                                  */
 800428a:	6842      	ldr	r2, [r0, #4]
             p_tcb1->PrevPtr     = p_tcb2;
             p_tcb1->NextPtr     = (OS_TCB *)0;
 800428c:	2100      	movs	r1, #0
             break;

        case 2:                                             /* SWAP the TCBs                                          */
             p_tcb1              = p_rdy_list->HeadPtr;     /* Point to current head                                  */
             p_tcb2              = p_rdy_list->TailPtr;     /* Point to current tail                                  */
             p_tcb1->PrevPtr     = p_tcb2;
 800428e:	611a      	str	r2, [r3, #16]
             p_tcb1->NextPtr     = (OS_TCB *)0;
 8004290:	60d9      	str	r1, [r3, #12]
             p_tcb2->PrevPtr     = (OS_TCB *)0;
 8004292:	6111      	str	r1, [r2, #16]
             p_tcb2->NextPtr     = p_tcb1;
 8004294:	60d3      	str	r3, [r2, #12]
             p_rdy_list->HeadPtr = p_tcb2;
             p_rdy_list->TailPtr = p_tcb1;
 8004296:	e880 000c 	stmia.w	r0, {r2, r3}
 800429a:	4770      	bx	lr

0800429c <OSSchedRoundRobinYield>:
************************************************************************************************************************
*/

#if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
void  OSSchedRoundRobinYield (OS_ERR  *p_err)
{
 800429c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
        return;
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't call this function from an ISR                   */
 80042a0:	4d24      	ldr	r5, [pc, #144]	; (8004334 <OSSchedRoundRobinYield+0x98>)
 80042a2:	782b      	ldrb	r3, [r5, #0]
 80042a4:	b983      	cbnz	r3, 80042c8 <OSSchedRoundRobinYield+0x2c>
       *p_err = OS_ERR_YIELD_ISR;
        return;
    }
#endif

    if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {        /* Can't yield if the scheduler is locked                 */
 80042a6:	4e24      	ldr	r6, [pc, #144]	; (8004338 <OSSchedRoundRobinYield+0x9c>)
 80042a8:	7833      	ldrb	r3, [r6, #0]
 80042aa:	b943      	cbnz	r3, 80042be <OSSchedRoundRobinYield+0x22>
       *p_err = OS_ERR_SCHED_LOCKED;
        return;
    }

    if (OSSchedRoundRobinEn != DEF_TRUE) {                  /* Make sure round-robin has been enabled                 */
 80042ac:	4b23      	ldr	r3, [pc, #140]	; (800433c <OSSchedRoundRobinYield+0xa0>)
 80042ae:	781b      	ldrb	r3, [r3, #0]
 80042b0:	2b01      	cmp	r3, #1
 80042b2:	d00e      	beq.n	80042d2 <OSSchedRoundRobinYield+0x36>
       *p_err = OS_ERR_ROUND_ROBIN_DISABLED;
 80042b4:	f646 137b 	movw	r3, #27003	; 0x697b
 80042b8:	8003      	strh	r3, [r0, #0]
        return;
 80042ba:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        return;
    }
#endif

    if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {        /* Can't yield if the scheduler is locked                 */
       *p_err = OS_ERR_SCHED_LOCKED;
 80042be:	f646 5363 	movw	r3, #28003	; 0x6d63
 80042c2:	8003      	strh	r3, [r0, #0]
        return;
 80042c4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't call this function from an ISR                   */
       *p_err = OS_ERR_YIELD_ISR;
 80042c8:	f248 43d1 	movw	r3, #34001	; 0x84d1
 80042cc:	8003      	strh	r3, [r0, #0]
        return;
 80042ce:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80042d2:	4604      	mov	r4, r0
    if (OSSchedRoundRobinEn != DEF_TRUE) {                  /* Make sure round-robin has been enabled                 */
       *p_err = OS_ERR_ROUND_ROBIN_DISABLED;
        return;
    }

    CPU_CRITICAL_ENTER();
 80042d4:	f7fd fa4e 	bl	8001774 <CPU_SR_Save>
    p_rdy_list = &OSRdyList[OSPrioCur];                     /* Can't yield if it's the only task at that priority     */
 80042d8:	4b19      	ldr	r3, [pc, #100]	; (8004340 <OSSchedRoundRobinYield+0xa4>)
 80042da:	f8df 806c 	ldr.w	r8, [pc, #108]	; 8004348 <OSSchedRoundRobinYield+0xac>
 80042de:	781b      	ldrb	r3, [r3, #0]
    if (OSSchedRoundRobinEn != DEF_TRUE) {                  /* Make sure round-robin has been enabled                 */
       *p_err = OS_ERR_ROUND_ROBIN_DISABLED;
        return;
    }

    CPU_CRITICAL_ENTER();
 80042e0:	4681      	mov	r9, r0
    p_rdy_list = &OSRdyList[OSPrioCur];                     /* Can't yield if it's the only task at that priority     */
 80042e2:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80042e6:	009f      	lsls	r7, r3, #2
 80042e8:	eb07 0308 	add.w	r3, r7, r8
    if (p_rdy_list->NbrEntries < (OS_OBJ_QTY)2) {
 80042ec:	891a      	ldrh	r2, [r3, #8]
 80042ee:	2a01      	cmp	r2, #1
 80042f0:	d916      	bls.n	8004320 <OSSchedRoundRobinYield+0x84>
        CPU_CRITICAL_EXIT();
       *p_err = OS_ERR_ROUND_ROBIN_1;
        return;
    }

    OS_RdyListMoveHeadToTail(p_rdy_list);                   /* Move current OS_TCB to the end of the list             */
 80042f2:	4618      	mov	r0, r3
 80042f4:	f7ff ffb6 	bl	8004264 <OS_RdyListMoveHeadToTail>
    p_tcb = p_rdy_list->HeadPtr;                            /* Point to new OS_TCB at head of the list                */
 80042f8:	f858 3007 	ldr.w	r3, [r8, r7]
    if (p_tcb->TimeQuanta == (OS_TICK)0) {                  /* See if we need to use the default time slice           */
 80042fc:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 80042fe:	b15a      	cbz	r2, 8004318 <OSSchedRoundRobinYield+0x7c>
        p_tcb->TimeQuantaCtr = OSSchedRoundRobinDfltTimeQuanta;
    } else {
        p_tcb->TimeQuantaCtr = p_tcb->TimeQuanta;           /* Load time slice counter with new time                  */
 8004300:	659a      	str	r2, [r3, #88]	; 0x58
    }

    CPU_CRITICAL_EXIT();
 8004302:	4648      	mov	r0, r9
 8004304:	f7fd fa3a 	bl	800177c <CPU_SR_Restore>
{
    CPU_SR_ALLOC();



    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* ISRs still nested?                                     */
 8004308:	782b      	ldrb	r3, [r5, #0]
 800430a:	b90b      	cbnz	r3, 8004310 <OSSchedRoundRobinYield+0x74>
        return;                                             /* Yes ... only schedule when no nested ISRs              */
    }

    if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {        /* Scheduler locked?                                      */
 800430c:	7833      	ldrb	r3, [r6, #0]
 800430e:	b173      	cbz	r3, 800432e <OSSchedRoundRobinYield+0x92>
    }

    CPU_CRITICAL_EXIT();

    OSSched();                                              /* Run new task                                           */
   *p_err = OS_ERR_NONE;
 8004310:	2300      	movs	r3, #0
 8004312:	8023      	strh	r3, [r4, #0]
 8004314:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    }

    OS_RdyListMoveHeadToTail(p_rdy_list);                   /* Move current OS_TCB to the end of the list             */
    p_tcb = p_rdy_list->HeadPtr;                            /* Point to new OS_TCB at head of the list                */
    if (p_tcb->TimeQuanta == (OS_TICK)0) {                  /* See if we need to use the default time slice           */
        p_tcb->TimeQuantaCtr = OSSchedRoundRobinDfltTimeQuanta;
 8004318:	4a0a      	ldr	r2, [pc, #40]	; (8004344 <OSSchedRoundRobinYield+0xa8>)
 800431a:	6812      	ldr	r2, [r2, #0]
 800431c:	659a      	str	r2, [r3, #88]	; 0x58
 800431e:	e7f0      	b.n	8004302 <OSSchedRoundRobinYield+0x66>
    }

    CPU_CRITICAL_ENTER();
    p_rdy_list = &OSRdyList[OSPrioCur];                     /* Can't yield if it's the only task at that priority     */
    if (p_rdy_list->NbrEntries < (OS_OBJ_QTY)2) {
        CPU_CRITICAL_EXIT();
 8004320:	f7fd fa2c 	bl	800177c <CPU_SR_Restore>
       *p_err = OS_ERR_ROUND_ROBIN_1;
 8004324:	f646 137a 	movw	r3, #27002	; 0x697a
 8004328:	8023      	strh	r3, [r4, #0]
        return;
 800432a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800432e:	f7ff fb51 	bl	80039d4 <OSSched.part.0>
 8004332:	e7ed      	b.n	8004310 <OSSchedRoundRobinYield+0x74>
 8004334:	2000ed84 	.word	0x2000ed84
 8004338:	2000e974 	.word	0x2000e974
 800433c:	2000f030 	.word	0x2000f030
 8004340:	2000ec88 	.word	0x2000ec88
 8004344:	2000ef28 	.word	0x2000ef28
 8004348:	2000e988 	.word	0x2000e988

0800434c <OS_RdyListRemove>:
* Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
************************************************************************************************************************
*/

void  OS_RdyListRemove (OS_TCB  *p_tcb)
{
 800434c:	b570      	push	{r4, r5, r6, lr}
 800434e:	4604      	mov	r4, r0
    OS_TCB       *p_tcb2;



    p_rdy_list = &OSRdyList[p_tcb->Prio];
    p_tcb1     = p_tcb->PrevPtr;                            /* Point to next and previous OS_TCB in the list          */
 8004350:	6901      	ldr	r1, [r0, #16]
    p_tcb2     = p_tcb->NextPtr;
 8004352:	68e2      	ldr	r2, [r4, #12]
    OS_TCB       *p_tcb1;
    OS_TCB       *p_tcb2;



    p_rdy_list = &OSRdyList[p_tcb->Prio];
 8004354:	f890 0037 	ldrb.w	r0, [r0, #55]	; 0x37
    p_tcb1     = p_tcb->PrevPtr;                            /* Point to next and previous OS_TCB in the list          */
    p_tcb2     = p_tcb->NextPtr;
    if (p_tcb1 == (OS_TCB *)0) {                            /* Was the OS_TCB to remove was at the head?              */
 8004358:	b171      	cbz	r1, 8004378 <OS_RdyListRemove+0x2c>
            p_rdy_list->NbrEntries--;                       /*      No,  one less entry                               */
            p_tcb2->PrevPtr        = (OS_TCB   *)0;         /*           adjust back link of new list head            */
            p_rdy_list->HeadPtr    = p_tcb2;                /*           adjust OS_RDY_LIST's new head                */
        }
    } else {
        p_rdy_list->NbrEntries--;                           /* No,  one less entry                                    */
 800435a:	4b15      	ldr	r3, [pc, #84]	; (80043b0 <OS_RdyListRemove+0x64>)
 800435c:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 8004360:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8004364:	8903      	ldrh	r3, [r0, #8]
 8004366:	3b01      	subs	r3, #1
 8004368:	8103      	strh	r3, [r0, #8]
        p_tcb1->NextPtr = p_tcb2;
 800436a:	60ca      	str	r2, [r1, #12]
        if (p_tcb2 == (OS_TCB *)0) {
 800436c:	b19a      	cbz	r2, 8004396 <OS_RdyListRemove+0x4a>
            p_rdy_list->TailPtr = p_tcb1;                   /*      Removing the TCB at the tail, adj the tail ptr    */
        } else {
            p_tcb2->PrevPtr     = p_tcb1;
 800436e:	6111      	str	r1, [r2, #16]
        }
    }
    p_tcb->PrevPtr = (OS_TCB *)0;
 8004370:	2300      	movs	r3, #0
 8004372:	6123      	str	r3, [r4, #16]
    p_tcb->NextPtr = (OS_TCB *)0;
 8004374:	60e3      	str	r3, [r4, #12]
 8004376:	bd70      	pop	{r4, r5, r6, pc}

    p_rdy_list = &OSRdyList[p_tcb->Prio];
    p_tcb1     = p_tcb->PrevPtr;                            /* Point to next and previous OS_TCB in the list          */
    p_tcb2     = p_tcb->NextPtr;
    if (p_tcb1 == (OS_TCB *)0) {                            /* Was the OS_TCB to remove was at the head?              */
        if (p_tcb2 == (OS_TCB *)0) {                        /* Yes, was it the only OS_TCB?                           */
 8004378:	b17a      	cbz	r2, 800439a <OS_RdyListRemove+0x4e>
            p_rdy_list->NbrEntries = (OS_OBJ_QTY)0;         /*      Yes, no more entries                              */
            p_rdy_list->HeadPtr    = (OS_TCB   *)0;
            p_rdy_list->TailPtr    = (OS_TCB   *)0;
            OS_PrioRemove(p_tcb->Prio);
        } else {
            p_rdy_list->NbrEntries--;                       /*      No,  one less entry                               */
 800437a:	4d0d      	ldr	r5, [pc, #52]	; (80043b0 <OS_RdyListRemove+0x64>)
 800437c:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 8004380:	0080      	lsls	r0, r0, #2
 8004382:	182e      	adds	r6, r5, r0
 8004384:	8933      	ldrh	r3, [r6, #8]
 8004386:	3b01      	subs	r3, #1
 8004388:	8133      	strh	r3, [r6, #8]
            p_rdy_list->TailPtr = p_tcb1;                   /*      Removing the TCB at the tail, adj the tail ptr    */
        } else {
            p_tcb2->PrevPtr     = p_tcb1;
        }
    }
    p_tcb->PrevPtr = (OS_TCB *)0;
 800438a:	2300      	movs	r3, #0
            p_rdy_list->HeadPtr    = (OS_TCB   *)0;
            p_rdy_list->TailPtr    = (OS_TCB   *)0;
            OS_PrioRemove(p_tcb->Prio);
        } else {
            p_rdy_list->NbrEntries--;                       /*      No,  one less entry                               */
            p_tcb2->PrevPtr        = (OS_TCB   *)0;         /*           adjust back link of new list head            */
 800438c:	6111      	str	r1, [r2, #16]
            p_rdy_list->HeadPtr    = p_tcb2;                /*           adjust OS_RDY_LIST's new head                */
 800438e:	502a      	str	r2, [r5, r0]
            p_rdy_list->TailPtr = p_tcb1;                   /*      Removing the TCB at the tail, adj the tail ptr    */
        } else {
            p_tcb2->PrevPtr     = p_tcb1;
        }
    }
    p_tcb->PrevPtr = (OS_TCB *)0;
 8004390:	6123      	str	r3, [r4, #16]
    p_tcb->NextPtr = (OS_TCB *)0;
 8004392:	60e3      	str	r3, [r4, #12]
 8004394:	bd70      	pop	{r4, r5, r6, pc}
        }
    } else {
        p_rdy_list->NbrEntries--;                           /* No,  one less entry                                    */
        p_tcb1->NextPtr = p_tcb2;
        if (p_tcb2 == (OS_TCB *)0) {
            p_rdy_list->TailPtr = p_tcb1;                   /*      Removing the TCB at the tail, adj the tail ptr    */
 8004396:	6041      	str	r1, [r0, #4]
 8004398:	e7ea      	b.n	8004370 <OS_RdyListRemove+0x24>
    p_rdy_list = &OSRdyList[p_tcb->Prio];
    p_tcb1     = p_tcb->PrevPtr;                            /* Point to next and previous OS_TCB in the list          */
    p_tcb2     = p_tcb->NextPtr;
    if (p_tcb1 == (OS_TCB *)0) {                            /* Was the OS_TCB to remove was at the head?              */
        if (p_tcb2 == (OS_TCB *)0) {                        /* Yes, was it the only OS_TCB?                           */
            p_rdy_list->NbrEntries = (OS_OBJ_QTY)0;         /*      Yes, no more entries                              */
 800439a:	4d05      	ldr	r5, [pc, #20]	; (80043b0 <OS_RdyListRemove+0x64>)
 800439c:	eb00 0340 	add.w	r3, r0, r0, lsl #1
 80043a0:	009b      	lsls	r3, r3, #2
 80043a2:	18e9      	adds	r1, r5, r3
            p_rdy_list->HeadPtr    = (OS_TCB   *)0;
 80043a4:	50ea      	str	r2, [r5, r3]
    p_rdy_list = &OSRdyList[p_tcb->Prio];
    p_tcb1     = p_tcb->PrevPtr;                            /* Point to next and previous OS_TCB in the list          */
    p_tcb2     = p_tcb->NextPtr;
    if (p_tcb1 == (OS_TCB *)0) {                            /* Was the OS_TCB to remove was at the head?              */
        if (p_tcb2 == (OS_TCB *)0) {                        /* Yes, was it the only OS_TCB?                           */
            p_rdy_list->NbrEntries = (OS_OBJ_QTY)0;         /*      Yes, no more entries                              */
 80043a6:	810a      	strh	r2, [r1, #8]
            p_rdy_list->HeadPtr    = (OS_TCB   *)0;
            p_rdy_list->TailPtr    = (OS_TCB   *)0;
 80043a8:	604a      	str	r2, [r1, #4]
            OS_PrioRemove(p_tcb->Prio);
 80043aa:	f001 fa17 	bl	80057dc <OS_PrioRemove>
 80043ae:	e7df      	b.n	8004370 <OS_RdyListRemove+0x24>
 80043b0:	2000e988 	.word	0x2000e988

080043b4 <OS_SchedLockTimeMeasStart>:
************************************************************************************************************************
*/

#if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
void  OS_SchedLockTimeMeasStart (void)
{
 80043b4:	b508      	push	{r3, lr}
    if (OSSchedLockNestingCtr == 1u) {
 80043b6:	4b05      	ldr	r3, [pc, #20]	; (80043cc <OS_SchedLockTimeMeasStart+0x18>)
 80043b8:	781b      	ldrb	r3, [r3, #0]
 80043ba:	2b01      	cmp	r3, #1
 80043bc:	d000      	beq.n	80043c0 <OS_SchedLockTimeMeasStart+0xc>
 80043be:	bd08      	pop	{r3, pc}
        OSSchedLockTimeBegin = CPU_TS_TmrRd();
 80043c0:	f7fc fbe4 	bl	8000b8c <CPU_TS_TmrRd>
 80043c4:	4b02      	ldr	r3, [pc, #8]	; (80043d0 <OS_SchedLockTimeMeasStart+0x1c>)
 80043c6:	6018      	str	r0, [r3, #0]
 80043c8:	bd08      	pop	{r3, pc}
 80043ca:	bf00      	nop
 80043cc:	2000e974 	.word	0x2000e974
 80043d0:	2000ed54 	.word	0x2000ed54

080043d4 <OS_SchedLockTimeMeasStop>:
void  OS_SchedLockTimeMeasStop (void)
{
    CPU_TS_TMR  delta;


    if (OSSchedLockNestingCtr == (OS_NESTING_CTR)0) {       /* Make sure we fully un-nested scheduler lock            */
 80043d4:	4b02      	ldr	r3, [pc, #8]	; (80043e0 <OS_SchedLockTimeMeasStop+0xc>)
 80043d6:	781b      	ldrb	r3, [r3, #0]
 80043d8:	b103      	cbz	r3, 80043dc <OS_SchedLockTimeMeasStop+0x8>
 80043da:	4770      	bx	lr
 80043dc:	f7ff bb30 	b.w	8003a40 <OS_SchedLockTimeMeasStop.part.5>
 80043e0:	2000e974 	.word	0x2000e974

080043e4 <OS_SchedRoundRobin>:
************************************************************************************************************************
*/

#if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
void  OS_SchedRoundRobin (OS_RDY_LIST  *p_rdy_list)
{
 80043e4:	b538      	push	{r3, r4, r5, lr}
    OS_TCB   *p_tcb;
    CPU_SR_ALLOC();



    if (OSSchedRoundRobinEn != DEF_TRUE) {                  /* Make sure round-robin has been enabled                 */
 80043e6:	4b15      	ldr	r3, [pc, #84]	; (800443c <OS_SchedRoundRobin+0x58>)
 80043e8:	781b      	ldrb	r3, [r3, #0]
 80043ea:	2b01      	cmp	r3, #1
 80043ec:	d000      	beq.n	80043f0 <OS_SchedRoundRobin+0xc>
 80043ee:	bd38      	pop	{r3, r4, r5, pc}
 80043f0:	4604      	mov	r4, r0
        return;
    }

    CPU_CRITICAL_ENTER();
 80043f2:	f7fd f9bf 	bl	8001774 <CPU_SR_Save>
    p_tcb = p_rdy_list->HeadPtr;                            /* Decrement time quanta counter                          */
 80043f6:	6823      	ldr	r3, [r4, #0]

    if (OSSchedRoundRobinEn != DEF_TRUE) {                  /* Make sure round-robin has been enabled                 */
        return;
    }

    CPU_CRITICAL_ENTER();
 80043f8:	4605      	mov	r5, r0
    p_tcb = p_rdy_list->HeadPtr;                            /* Decrement time quanta counter                          */

    if (p_tcb == (OS_TCB *)0) {
 80043fa:	b1bb      	cbz	r3, 800442c <OS_SchedRoundRobin+0x48>
        CPU_CRITICAL_EXIT();
        return;
    }

    if (p_tcb == &OSIdleTaskTCB) {
 80043fc:	4a10      	ldr	r2, [pc, #64]	; (8004440 <OS_SchedRoundRobin+0x5c>)
 80043fe:	4293      	cmp	r3, r2
 8004400:	d014      	beq.n	800442c <OS_SchedRoundRobin+0x48>
        CPU_CRITICAL_EXIT();
        return;
    }

    if (p_tcb->TimeQuantaCtr > (OS_TICK)0) {
 8004402:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8004404:	b112      	cbz	r2, 800440c <OS_SchedRoundRobin+0x28>
        p_tcb->TimeQuantaCtr--;
 8004406:	3a01      	subs	r2, #1
 8004408:	659a      	str	r2, [r3, #88]	; 0x58
    }

    if (p_tcb->TimeQuantaCtr > (OS_TICK)0) {                /* Task not done with its time quanta                     */
 800440a:	b97a      	cbnz	r2, 800442c <OS_SchedRoundRobin+0x48>
        CPU_CRITICAL_EXIT();
        return;
    }

    if (p_rdy_list->NbrEntries < (OS_OBJ_QTY)2) {           /* See if it's time to time slice current task            */
 800440c:	8923      	ldrh	r3, [r4, #8]
 800440e:	2b01      	cmp	r3, #1
 8004410:	d90b      	bls.n	800442a <OS_SchedRoundRobin+0x46>
        CPU_CRITICAL_EXIT();                                /* ... only if multiple tasks at same priority            */
        return;
    }

    if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {        /* Can't round-robin if the scheduler is locked           */
 8004412:	4b0c      	ldr	r3, [pc, #48]	; (8004444 <OS_SchedRoundRobin+0x60>)
 8004414:	781b      	ldrb	r3, [r3, #0]
 8004416:	b943      	cbnz	r3, 800442a <OS_SchedRoundRobin+0x46>
        CPU_CRITICAL_EXIT();
        return;
    }

    OS_RdyListMoveHeadToTail(p_rdy_list);                   /* Move current OS_TCB to the end of the list             */
 8004418:	4620      	mov	r0, r4
 800441a:	f7ff ff23 	bl	8004264 <OS_RdyListMoveHeadToTail>
    p_tcb = p_rdy_list->HeadPtr;                            /* Point to new OS_TCB at head of the list                */
 800441e:	6823      	ldr	r3, [r4, #0]
    if (p_tcb->TimeQuanta == (OS_TICK)0) {                  /* See if we need to use the default time slice           */
 8004420:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8004422:	b93a      	cbnz	r2, 8004434 <OS_SchedRoundRobin+0x50>
        p_tcb->TimeQuantaCtr = OSSchedRoundRobinDfltTimeQuanta;
 8004424:	4a08      	ldr	r2, [pc, #32]	; (8004448 <OS_SchedRoundRobin+0x64>)
 8004426:	6812      	ldr	r2, [r2, #0]
 8004428:	659a      	str	r2, [r3, #88]	; 0x58
    } else {
        p_tcb->TimeQuantaCtr = p_tcb->TimeQuanta;           /* Load time slice counter with new time                  */
    }
    CPU_CRITICAL_EXIT();
 800442a:	4628      	mov	r0, r5
}
 800442c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    if (p_tcb->TimeQuanta == (OS_TICK)0) {                  /* See if we need to use the default time slice           */
        p_tcb->TimeQuantaCtr = OSSchedRoundRobinDfltTimeQuanta;
    } else {
        p_tcb->TimeQuantaCtr = p_tcb->TimeQuanta;           /* Load time slice counter with new time                  */
    }
    CPU_CRITICAL_EXIT();
 8004430:	f7fd b9a4 	b.w	800177c <CPU_SR_Restore>
    OS_RdyListMoveHeadToTail(p_rdy_list);                   /* Move current OS_TCB to the end of the list             */
    p_tcb = p_rdy_list->HeadPtr;                            /* Point to new OS_TCB at head of the list                */
    if (p_tcb->TimeQuanta == (OS_TICK)0) {                  /* See if we need to use the default time slice           */
        p_tcb->TimeQuantaCtr = OSSchedRoundRobinDfltTimeQuanta;
    } else {
        p_tcb->TimeQuantaCtr = p_tcb->TimeQuanta;           /* Load time slice counter with new time                  */
 8004434:	659a      	str	r2, [r3, #88]	; 0x58
    }
    CPU_CRITICAL_EXIT();
 8004436:	4628      	mov	r0, r5
 8004438:	e7f8      	b.n	800442c <OS_SchedRoundRobin+0x48>
 800443a:	bf00      	nop
 800443c:	2000f030 	.word	0x2000f030
 8004440:	2000ee58 	.word	0x2000ee58
 8004444:	2000e974 	.word	0x2000e974
 8004448:	2000ef28 	.word	0x2000ef28

0800444c <OS_TaskBlock>:
************************************************************************************************************************
*/

void  OS_TaskBlock (OS_TCB   *p_tcb,
                    OS_TICK   timeout)
{
 800444c:	b510      	push	{r4, lr}
 800444e:	4604      	mov	r4, r0
 8004450:	b082      	sub	sp, #8
    OS_ERR  err;


    if (timeout > (OS_TICK)0) {                             /* Add task to tick list if timeout non zero               */
 8004452:	b939      	cbnz	r1, 8004464 <OS_TaskBlock+0x18>
                          OS_OPT_TIME_TIMEOUT,
                         &err);
        if (err == OS_ERR_NONE) {
            p_tcb->TaskState = OS_TASK_STATE_PEND_TIMEOUT;
        } else {
            p_tcb->TaskState = OS_TASK_STATE_PEND;
 8004454:	2302      	movs	r3, #2
 8004456:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
        }
    } else {
        p_tcb->TaskState = OS_TASK_STATE_PEND;
    }
    OS_RdyListRemove(p_tcb);
 800445a:	4620      	mov	r0, r4
 800445c:	f7ff ff76 	bl	800434c <OS_RdyListRemove>
}
 8004460:	b002      	add	sp, #8
 8004462:	bd10      	pop	{r4, pc}
{
    OS_ERR  err;


    if (timeout > (OS_TICK)0) {                             /* Add task to tick list if timeout non zero               */
        OS_TickListInsert(p_tcb,
 8004464:	f10d 0306 	add.w	r3, sp, #6
 8004468:	2202      	movs	r2, #2
 800446a:	f003 f99d 	bl	80077a8 <OS_TickListInsert>
                          timeout,
                          OS_OPT_TIME_TIMEOUT,
                         &err);
        if (err == OS_ERR_NONE) {
 800446e:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8004472:	2b00      	cmp	r3, #0
 8004474:	d1ee      	bne.n	8004454 <OS_TaskBlock+0x8>
            p_tcb->TaskState = OS_TASK_STATE_PEND_TIMEOUT;
 8004476:	2303      	movs	r3, #3
 8004478:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
            p_tcb->TaskState = OS_TASK_STATE_PEND;
        }
    } else {
        p_tcb->TaskState = OS_TASK_STATE_PEND;
    }
    OS_RdyListRemove(p_tcb);
 800447c:	4620      	mov	r0, r4
 800447e:	f7ff ff65 	bl	800434c <OS_RdyListRemove>
}
 8004482:	b002      	add	sp, #8
 8004484:	bd10      	pop	{r4, pc}
 8004486:	bf00      	nop

08004488 <OS_Pend>:

void  OS_Pend (OS_PEND_DATA  *p_pend_data,
               OS_PEND_OBJ   *p_obj,
               OS_STATE       pending_on,
               OS_TICK        timeout)
{
 8004488:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800448c:	460e      	mov	r6, r1
    OS_PEND_LIST  *p_pend_list;



    OSTCBCurPtr->PendOn     = pending_on;                    /* Resource not available, wait until it is              */
 800448e:	f8df 8090 	ldr.w	r8, [pc, #144]	; 8004520 <OS_Pend+0x98>
    OSTCBCurPtr->PendStatus = OS_STATUS_PEND_OK;
 8004492:	2500      	movs	r5, #0
{
    OS_PEND_LIST  *p_pend_list;



    OSTCBCurPtr->PendOn     = pending_on;                    /* Resource not available, wait until it is              */
 8004494:	f8d8 7000 	ldr.w	r7, [r8]
    OSTCBCurPtr->PendStatus = OS_STATUS_PEND_OK;

    OS_TaskBlock(OSTCBCurPtr,                                /* Block the task and add it to the tick list if needed  */
 8004498:	4619      	mov	r1, r3

void  OS_Pend (OS_PEND_DATA  *p_pend_data,
               OS_PEND_OBJ   *p_obj,
               OS_STATE       pending_on,
               OS_TICK        timeout)
{
 800449a:	4604      	mov	r4, r0
    OS_PEND_LIST  *p_pend_list;



    OSTCBCurPtr->PendOn     = pending_on;                    /* Resource not available, wait until it is              */
 800449c:	f887 2034 	strb.w	r2, [r7, #52]	; 0x34
    OSTCBCurPtr->PendStatus = OS_STATUS_PEND_OK;
 80044a0:	f887 5035 	strb.w	r5, [r7, #53]	; 0x35

    OS_TaskBlock(OSTCBCurPtr,                                /* Block the task and add it to the tick list if needed  */
 80044a4:	4638      	mov	r0, r7
 80044a6:	f7ff ffd1 	bl	800444c <OS_TaskBlock>
                 timeout);

    if (p_obj != (OS_PEND_OBJ *)0) {                         /* Add the current task to the pend list ...             */
        p_pend_list             = &p_obj->PendList;          /* ... if there is an object to pend on                  */
        p_pend_data->PendObjPtr = p_obj;                     /* Save the pointer to the object pending on             */
        OS_PendDataInit((OS_TCB       *)OSTCBCurPtr,         /* Initialize the remaining field                        */
 80044aa:	f8d8 3000 	ldr.w	r3, [r8]
    OSTCBCurPtr->PendStatus = OS_STATUS_PEND_OK;

    OS_TaskBlock(OSTCBCurPtr,                                /* Block the task and add it to the tick list if needed  */
                 timeout);

    if (p_obj != (OS_PEND_OBJ *)0) {                         /* Add the current task to the pend list ...             */
 80044ae:	b1d6      	cbz	r6, 80044e6 <OS_Pend+0x5e>
{
    OS_OBJ_QTY  i;



    p_tcb->PendDataTblEntries = tbl_size;                   /* Link the TCB to the beginning of the table             */
 80044b0:	2201      	movs	r2, #1
    OS_TaskBlock(OSTCBCurPtr,                                /* Block the task and add it to the tick list if needed  */
                 timeout);

    if (p_obj != (OS_PEND_OBJ *)0) {                         /* Add the current task to the pend list ...             */
        p_pend_list             = &p_obj->PendList;          /* ... if there is an object to pend on                  */
        p_pend_data->PendObjPtr = p_obj;                     /* Save the pointer to the object pending on             */
 80044b2:	60e6      	str	r6, [r4, #12]
        OS_PendDataInit((OS_TCB       *)OSTCBCurPtr,         /* Initialize the remaining field                        */
                        (OS_PEND_DATA *)p_pend_data,
                        (OS_OBJ_QTY    )1);
        OS_PendListInsertPrio(p_pend_list,                   /* Insert in the pend list in priority order             */
 80044b4:	4621      	mov	r1, r4
{
    OS_OBJ_QTY  i;



    p_tcb->PendDataTblEntries = tbl_size;                   /* Link the TCB to the beginning of the table             */
 80044b6:	87da      	strh	r2, [r3, #62]	; 0x3e
    p_tcb->PendDataTblPtr     = p_pend_data_tbl;
 80044b8:	631c      	str	r4, [r3, #48]	; 0x30
        p_pend_list             = &p_obj->PendList;          /* ... if there is an object to pend on                  */
        p_pend_data->PendObjPtr = p_obj;                     /* Save the pointer to the object pending on             */
        OS_PendDataInit((OS_TCB       *)OSTCBCurPtr,         /* Initialize the remaining field                        */
                        (OS_PEND_DATA *)p_pend_data,
                        (OS_OBJ_QTY    )1);
        OS_PendListInsertPrio(p_pend_list,                   /* Insert in the pend list in priority order             */
 80044ba:	f106 0008 	add.w	r0, r6, #8
        p_pend_data_tbl->PrevPtr    = (OS_PEND_DATA *)0;
        p_pend_data_tbl->RdyObjPtr  = (OS_PEND_OBJ  *)0;
        p_pend_data_tbl->RdyMsgPtr  = (void         *)0;
        p_pend_data_tbl->RdyMsgSize = (OS_MSG_SIZE   )0;
        p_pend_data_tbl->RdyTS      = (CPU_TS        )0;
        p_pend_data_tbl->TCBPtr     = p_tcb;                /* Every entry points back to the TCB of the task         */
 80044be:	60a3      	str	r3, [r4, #8]

    p_tcb->PendDataTblEntries = tbl_size;                   /* Link the TCB to the beginning of the table             */
    p_tcb->PendDataTblPtr     = p_pend_data_tbl;

    for (i = 0u; i < tbl_size; i++) {
        p_pend_data_tbl->NextPtr    = (OS_PEND_DATA *)0;    /* Initialize all the fields                              */
 80044c0:	6065      	str	r5, [r4, #4]
        p_pend_data_tbl->PrevPtr    = (OS_PEND_DATA *)0;
 80044c2:	6025      	str	r5, [r4, #0]
        p_pend_data_tbl->RdyObjPtr  = (OS_PEND_OBJ  *)0;
 80044c4:	6125      	str	r5, [r4, #16]
        p_pend_data_tbl->RdyMsgPtr  = (void         *)0;
 80044c6:	6165      	str	r5, [r4, #20]
        p_pend_data_tbl->RdyMsgSize = (OS_MSG_SIZE   )0;
 80044c8:	8325      	strh	r5, [r4, #24]
        p_pend_data_tbl->RdyTS      = (CPU_TS        )0;
 80044ca:	61e5      	str	r5, [r4, #28]
        p_pend_list             = &p_obj->PendList;          /* ... if there is an object to pend on                  */
        p_pend_data->PendObjPtr = p_obj;                     /* Save the pointer to the object pending on             */
        OS_PendDataInit((OS_TCB       *)OSTCBCurPtr,         /* Initialize the remaining field                        */
                        (OS_PEND_DATA *)p_pend_data,
                        (OS_OBJ_QTY    )1);
        OS_PendListInsertPrio(p_pend_list,                   /* Insert in the pend list in priority order             */
 80044cc:	f7ff fd5e 	bl	8003f8c <OS_PendListInsertPrio>

    if (p_obj != (OS_PEND_OBJ *)0) {
        p_tcb->DbgNamePtr =  p_obj->NamePtr;                /* Task pending on this object ... save name in TCB       */
        p_pend_list       = &p_obj->PendList;               /* Find name of HP task pending on this object ...        */
        p_pend_data       =  p_pend_list->HeadPtr;
        p_tcb1            =  p_pend_data->TCBPtr;
 80044d0:	68b3      	ldr	r3, [r6, #8]
    OS_PEND_DATA  *p_pend_data;
    OS_TCB        *p_tcb1;


    if (p_obj != (OS_PEND_OBJ *)0) {
        p_tcb->DbgNamePtr =  p_obj->NamePtr;                /* Task pending on this object ... save name in TCB       */
 80044d2:	f8d8 2000 	ldr.w	r2, [r8]
        p_pend_list       = &p_obj->PendList;               /* Find name of HP task pending on this object ...        */
        p_pend_data       =  p_pend_list->HeadPtr;
        p_tcb1            =  p_pend_data->TCBPtr;
        p_obj->DbgNamePtr = p_tcb1->NamePtr;                /* ... Save in object                                     */
 80044d6:	689b      	ldr	r3, [r3, #8]
    OS_PEND_DATA  *p_pend_data;
    OS_TCB        *p_tcb1;


    if (p_obj != (OS_PEND_OBJ *)0) {
        p_tcb->DbgNamePtr =  p_obj->NamePtr;                /* Task pending on this object ... save name in TCB       */
 80044d8:	6871      	ldr	r1, [r6, #4]
        p_pend_list       = &p_obj->PendList;               /* Find name of HP task pending on this object ...        */
        p_pend_data       =  p_pend_list->HeadPtr;
        p_tcb1            =  p_pend_data->TCBPtr;
        p_obj->DbgNamePtr = p_tcb1->NamePtr;                /* ... Save in object                                     */
 80044da:	6a1b      	ldr	r3, [r3, #32]
    OS_PEND_DATA  *p_pend_data;
    OS_TCB        *p_tcb1;


    if (p_obj != (OS_PEND_OBJ *)0) {
        p_tcb->DbgNamePtr =  p_obj->NamePtr;                /* Task pending on this object ... save name in TCB       */
 80044dc:	f8c2 10c0 	str.w	r1, [r2, #192]	; 0xc0
        p_pend_list       = &p_obj->PendList;               /* Find name of HP task pending on this object ...        */
        p_pend_data       =  p_pend_list->HeadPtr;
        p_tcb1            =  p_pend_data->TCBPtr;
        p_obj->DbgNamePtr = p_tcb1->NamePtr;                /* ... Save in object                                     */
 80044e0:	61f3      	str	r3, [r6, #28]
 80044e2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    } else {
        switch (p_tcb->PendOn) {
 80044e6:	f893 2034 	ldrb.w	r2, [r3, #52]	; 0x34
                        (OS_PEND_DATA *)p_pend_data,
                        (OS_OBJ_QTY    )1);
        OS_PendListInsertPrio(p_pend_list,                   /* Insert in the pend list in priority order             */
                              p_pend_data);
    } else {
        OSTCBCurPtr->PendDataTblEntries = (OS_OBJ_QTY    )0; /* If no object being pended on the clear these fields   */
 80044ea:	87de      	strh	r6, [r3, #62]	; 0x3e
        p_pend_list       = &p_obj->PendList;               /* Find name of HP task pending on this object ...        */
        p_pend_data       =  p_pend_list->HeadPtr;
        p_tcb1            =  p_pend_data->TCBPtr;
        p_obj->DbgNamePtr = p_tcb1->NamePtr;                /* ... Save in object                                     */
    } else {
        switch (p_tcb->PendOn) {
 80044ec:	2a02      	cmp	r2, #2
                        (OS_OBJ_QTY    )1);
        OS_PendListInsertPrio(p_pend_list,                   /* Insert in the pend list in priority order             */
                              p_pend_data);
    } else {
        OSTCBCurPtr->PendDataTblEntries = (OS_OBJ_QTY    )0; /* If no object being pended on the clear these fields   */
        OSTCBCurPtr->PendDataTblPtr     = (OS_PEND_DATA *)0; /* ... in the TCB                                        */
 80044ee:	631e      	str	r6, [r3, #48]	; 0x30
        p_pend_list       = &p_obj->PendList;               /* Find name of HP task pending on this object ...        */
        p_pend_data       =  p_pend_list->HeadPtr;
        p_tcb1            =  p_pend_data->TCBPtr;
        p_obj->DbgNamePtr = p_tcb1->NamePtr;                /* ... Save in object                                     */
    } else {
        switch (p_tcb->PendOn) {
 80044f0:	d006      	beq.n	8004500 <OS_Pend+0x78>
 80044f2:	2a07      	cmp	r2, #7
 80044f4:	d109      	bne.n	800450a <OS_Pend+0x82>
            case OS_TASK_PEND_ON_TASK_Q:
                 p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)"Task Q");
                 break;

            case OS_TASK_PEND_ON_TASK_SEM:
                 p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)"Task Sem");
 80044f6:	4a07      	ldr	r2, [pc, #28]	; (8004514 <OS_Pend+0x8c>)
 80044f8:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
 80044fc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        p_tcb1            =  p_pend_data->TCBPtr;
        p_obj->DbgNamePtr = p_tcb1->NamePtr;                /* ... Save in object                                     */
    } else {
        switch (p_tcb->PendOn) {
            case OS_TASK_PEND_ON_TASK_Q:
                 p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)"Task Q");
 8004500:	4a05      	ldr	r2, [pc, #20]	; (8004518 <OS_Pend+0x90>)
 8004502:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
 8004506:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            case OS_TASK_PEND_ON_TASK_SEM:
                 p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)"Task Sem");
                 break;

            default:
                 p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)" ");
 800450a:	4a04      	ldr	r2, [pc, #16]	; (800451c <OS_Pend+0x94>)
 800450c:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
 8004510:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8004514:	08016650 	.word	0x08016650
 8004518:	08016648 	.word	0x08016648
 800451c:	080182f0 	.word	0x080182f0
 8004520:	2000ed58 	.word	0x2000ed58

08004524 <OS_TaskRdy>:
* Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
************************************************************************************************************************
*/

void  OS_TaskRdy (OS_TCB  *p_tcb)
{
 8004524:	b510      	push	{r4, lr}
 8004526:	4604      	mov	r4, r0
    OS_TickListRemove(p_tcb);                               /* Remove from tick list                                  */
 8004528:	f003 f9c4 	bl	80078b4 <OS_TickListRemove>
    if ((p_tcb->TaskState & OS_TASK_STATE_BIT_SUSPENDED) == (OS_STATE)0) {
 800452c:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
 8004530:	075b      	lsls	r3, r3, #29
 8004532:	d500      	bpl.n	8004536 <OS_TaskRdy+0x12>
 8004534:	bd10      	pop	{r4, pc}
        OS_RdyListInsert(p_tcb);                            /* Insert the task in the ready list                      */
 8004536:	4620      	mov	r0, r4
    }
}
 8004538:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

void  OS_TaskRdy (OS_TCB  *p_tcb)
{
    OS_TickListRemove(p_tcb);                               /* Remove from tick list                                  */
    if ((p_tcb->TaskState & OS_TASK_STATE_BIT_SUSPENDED) == (OS_STATE)0) {
        OS_RdyListInsert(p_tcb);                            /* Insert the task in the ready list                      */
 800453c:	f7ff be18 	b.w	8004170 <OS_RdyListInsert>

08004540 <OS_PendAbort>:
*/

void  OS_PendAbort (OS_PEND_OBJ  *p_obj,
                    OS_TCB       *p_tcb,
                    CPU_TS        ts)
{
 8004540:	b538      	push	{r3, r4, r5, lr}
    switch (p_tcb->TaskState) {
 8004542:	f891 3036 	ldrb.w	r3, [r1, #54]	; 0x36
*/

void  OS_PendAbort (OS_PEND_OBJ  *p_obj,
                    OS_TCB       *p_tcb,
                    CPU_TS        ts)
{
 8004546:	460c      	mov	r4, r1
    switch (p_tcb->TaskState) {
 8004548:	3b02      	subs	r3, #2
 800454a:	2b05      	cmp	r3, #5
 800454c:	d81d      	bhi.n	800458a <OS_PendAbort+0x4a>
 800454e:	e8df f003 	tbb	[pc, r3]
 8004552:	1d1d      	.short	0x1d1d
 8004554:	03031c1c 	.word	0x03031c1c
             p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
             break;

        case OS_TASK_STATE_PEND_SUSPENDED:
        case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
             if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
 8004558:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
 800455c:	2b03      	cmp	r3, #3
 800455e:	d043      	beq.n	80045e8 <OS_PendAbort+0xa8>
                 OS_PendAbort1(p_obj,                            /* Indicate which object was pend aborted            */
                               p_tcb,
                               ts);
             }
#if (OS_MSG_EN > 0u)
             p_tcb->MsgPtr     = (void      *)0;
 8004560:	2300      	movs	r3, #0
             p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
#endif
             p_tcb->TS         = ts;
 8004562:	6422      	str	r2, [r4, #64]	; 0x40
                 OS_PendAbort1(p_obj,                            /* Indicate which object was pend aborted            */
                               p_tcb,
                               ts);
             }
#if (OS_MSG_EN > 0u)
             p_tcb->MsgPtr     = (void      *)0;
 8004564:	65e3      	str	r3, [r4, #92]	; 0x5c
             p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
 8004566:	f8a4 3060 	strh.w	r3, [r4, #96]	; 0x60
#endif
             p_tcb->TS         = ts;
             if (p_obj != (OS_PEND_OBJ *)0) {
 800456a:	b110      	cbz	r0, 8004572 <OS_PendAbort+0x32>
                 OS_PendListRemove(p_tcb);                       /* Remove task from all pend lists                   */
 800456c:	4620      	mov	r0, r4
 800456e:	f7ff fd69 	bl	8004044 <OS_PendListRemove>
             }
             OS_TickListRemove(p_tcb);                           /* Cancel the timeout                                */
 8004572:	4620      	mov	r0, r4
 8004574:	f003 f99e 	bl	80078b4 <OS_TickListRemove>
             p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;        /* Pend Aborted task is still suspended              */
 8004578:	2104      	movs	r1, #4
             p_tcb->PendStatus = OS_STATUS_PEND_ABORT;           /* Indicate pend was aborted                         */
 800457a:	2201      	movs	r2, #1
             p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
 800457c:	2300      	movs	r3, #0
             p_tcb->TS         = ts;
             if (p_obj != (OS_PEND_OBJ *)0) {
                 OS_PendListRemove(p_tcb);                       /* Remove task from all pend lists                   */
             }
             OS_TickListRemove(p_tcb);                           /* Cancel the timeout                                */
             p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;        /* Pend Aborted task is still suspended              */
 800457e:	f884 1036 	strb.w	r1, [r4, #54]	; 0x36
             p_tcb->PendStatus = OS_STATUS_PEND_ABORT;           /* Indicate pend was aborted                         */
 8004582:	f884 2035 	strb.w	r2, [r4, #53]	; 0x35
             p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
 8004586:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 800458a:	bd38      	pop	{r3, r4, r5, pc}
        case OS_TASK_STATE_DLY_SUSPENDED:                   /* Cannot Pend Abort a suspended task that was also dly'd */
             break;

        case OS_TASK_STATE_PEND:
        case OS_TASK_STATE_PEND_TIMEOUT:
             if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
 800458c:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
 8004590:	2b03      	cmp	r3, #3
 8004592:	d014      	beq.n	80045be <OS_PendAbort+0x7e>
                 OS_PendAbort1(p_obj,                            /* Indicate which object was pend aborted            */
                               p_tcb,
                               ts);
             }
#if (OS_MSG_EN > 0u)
             p_tcb->MsgPtr     = (void      *)0;
 8004594:	2300      	movs	r3, #0
             p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
#endif
             p_tcb->TS         = ts;
 8004596:	6422      	str	r2, [r4, #64]	; 0x40
                 OS_PendAbort1(p_obj,                            /* Indicate which object was pend aborted            */
                               p_tcb,
                               ts);
             }
#if (OS_MSG_EN > 0u)
             p_tcb->MsgPtr     = (void      *)0;
 8004598:	65e3      	str	r3, [r4, #92]	; 0x5c
             p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
 800459a:	f8a4 3060 	strh.w	r3, [r4, #96]	; 0x60
#endif
             p_tcb->TS         = ts;
             if (p_obj != (OS_PEND_OBJ *)0) {
 800459e:	b110      	cbz	r0, 80045a6 <OS_PendAbort+0x66>
                 OS_PendListRemove(p_tcb);                       /* Remove task from all pend lists                   */
 80045a0:	4620      	mov	r0, r4
 80045a2:	f7ff fd4f 	bl	8004044 <OS_PendListRemove>
             }
             OS_TaskRdy(p_tcb);
 80045a6:	4620      	mov	r0, r4
 80045a8:	f7ff ffbc 	bl	8004524 <OS_TaskRdy>
             p_tcb->TaskState  = OS_TASK_STATE_RDY;              /* Task will be ready                                */
 80045ac:	2300      	movs	r3, #0
             p_tcb->PendStatus = OS_STATUS_PEND_ABORT;           /* Indicate pend was aborted                         */
 80045ae:	2201      	movs	r2, #1
             p_tcb->TS         = ts;
             if (p_obj != (OS_PEND_OBJ *)0) {
                 OS_PendListRemove(p_tcb);                       /* Remove task from all pend lists                   */
             }
             OS_TaskRdy(p_tcb);
             p_tcb->TaskState  = OS_TASK_STATE_RDY;              /* Task will be ready                                */
 80045b0:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
             p_tcb->PendStatus = OS_STATUS_PEND_ABORT;           /* Indicate pend was aborted                         */
             p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
 80045b4:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
             if (p_obj != (OS_PEND_OBJ *)0) {
                 OS_PendListRemove(p_tcb);                       /* Remove task from all pend lists                   */
             }
             OS_TaskRdy(p_tcb);
             p_tcb->TaskState  = OS_TASK_STATE_RDY;              /* Task will be ready                                */
             p_tcb->PendStatus = OS_STATUS_PEND_ABORT;           /* Indicate pend was aborted                         */
 80045b8:	f884 2035 	strb.w	r2, [r4, #53]	; 0x35
             p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
             break;
 80045bc:	bd38      	pop	{r3, r4, r5, pc}
    OS_PEND_DATA   *p_pend_data;



    p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
    n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */
 80045be:	8fe1      	ldrh	r1, [r4, #62]	; 0x3e
    OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
    OS_PEND_DATA   *p_pend_data;



    p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
 80045c0:	6b23      	ldr	r3, [r4, #48]	; 0x30
    n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */

    while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
 80045c2:	2900      	cmp	r1, #0
 80045c4:	d0e6      	beq.n	8004594 <OS_PendAbort+0x54>
        if (p_obj == p_pend_data->PendObjPtr) {                     /* Did we find the object pend aborted?           */
 80045c6:	68dd      	ldr	r5, [r3, #12]
 80045c8:	42a8      	cmp	r0, r5
 80045ca:	d00a      	beq.n	80045e2 <OS_PendAbort+0xa2>
 80045cc:	1e4d      	subs	r5, r1, #1
 80045ce:	b2ad      	uxth	r5, r5
 80045d0:	3501      	adds	r5, #1
 80045d2:	eb03 1545 	add.w	r5, r3, r5, lsl #5
            p_pend_data->RdyObjPtr = p_obj;                         /* Yes, indicate the object in the .RdyObjPtr     */
            p_pend_data->RdyTS     = ts;                            /*      save the timestamp of the pend abort      */
            break;
        }
        p_pend_data++;
 80045d6:	3320      	adds	r3, #32


    p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
    n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */

    while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
 80045d8:	42ab      	cmp	r3, r5
 80045da:	d0db      	beq.n	8004594 <OS_PendAbort+0x54>
        if (p_obj == p_pend_data->PendObjPtr) {                     /* Did we find the object pend aborted?           */
 80045dc:	68d9      	ldr	r1, [r3, #12]
 80045de:	4288      	cmp	r0, r1
 80045e0:	d1f9      	bne.n	80045d6 <OS_PendAbort+0x96>
            p_pend_data->RdyObjPtr = p_obj;                         /* Yes, indicate the object in the .RdyObjPtr     */
 80045e2:	6118      	str	r0, [r3, #16]
            p_pend_data->RdyTS     = ts;                            /*      save the timestamp of the pend abort      */
 80045e4:	61da      	str	r2, [r3, #28]
 80045e6:	e7d5      	b.n	8004594 <OS_PendAbort+0x54>
    OS_PEND_DATA   *p_pend_data;



    p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
    n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */
 80045e8:	8fe1      	ldrh	r1, [r4, #62]	; 0x3e
    OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
    OS_PEND_DATA   *p_pend_data;



    p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
 80045ea:	6b23      	ldr	r3, [r4, #48]	; 0x30
    n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */

    while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
 80045ec:	2900      	cmp	r1, #0
 80045ee:	d0b7      	beq.n	8004560 <OS_PendAbort+0x20>
        if (p_obj == p_pend_data->PendObjPtr) {                     /* Did we find the object pend aborted?           */
 80045f0:	68dd      	ldr	r5, [r3, #12]
 80045f2:	42a8      	cmp	r0, r5
 80045f4:	d00a      	beq.n	800460c <OS_PendAbort+0xcc>
 80045f6:	1e4d      	subs	r5, r1, #1
 80045f8:	b2ad      	uxth	r5, r5
 80045fa:	3501      	adds	r5, #1
 80045fc:	eb03 1545 	add.w	r5, r3, r5, lsl #5
            p_pend_data->RdyObjPtr = p_obj;                         /* Yes, indicate the object in the .RdyObjPtr     */
            p_pend_data->RdyTS     = ts;                            /*      save the timestamp of the pend abort      */
            break;
        }
        p_pend_data++;
 8004600:	3320      	adds	r3, #32


    p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
    n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */

    while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
 8004602:	42ab      	cmp	r3, r5
 8004604:	d0ac      	beq.n	8004560 <OS_PendAbort+0x20>
        if (p_obj == p_pend_data->PendObjPtr) {                     /* Did we find the object pend aborted?           */
 8004606:	68d9      	ldr	r1, [r3, #12]
 8004608:	4288      	cmp	r0, r1
 800460a:	d1f9      	bne.n	8004600 <OS_PendAbort+0xc0>
            p_pend_data->RdyObjPtr = p_obj;                         /* Yes, indicate the object in the .RdyObjPtr     */
 800460c:	6118      	str	r0, [r3, #16]
            p_pend_data->RdyTS     = ts;                            /*      save the timestamp of the pend abort      */
 800460e:	61da      	str	r2, [r3, #28]
 8004610:	e7a6      	b.n	8004560 <OS_PendAbort+0x20>
 8004612:	bf00      	nop

08004614 <OS_PendObjDel>:
*/

void  OS_PendObjDel (OS_PEND_OBJ  *p_obj,
                     OS_TCB       *p_tcb,
                     CPU_TS        ts)
{
 8004614:	b538      	push	{r3, r4, r5, lr}
    switch (p_tcb->TaskState) {
 8004616:	f891 3036 	ldrb.w	r3, [r1, #54]	; 0x36
*/

void  OS_PendObjDel (OS_PEND_OBJ  *p_obj,
                     OS_TCB       *p_tcb,
                     CPU_TS        ts)
{
 800461a:	460c      	mov	r4, r1
    switch (p_tcb->TaskState) {
 800461c:	3b02      	subs	r3, #2
 800461e:	2b05      	cmp	r3, #5
 8004620:	d81b      	bhi.n	800465a <OS_PendObjDel+0x46>
 8004622:	e8df f003 	tbb	[pc, r3]
 8004626:	1b1b      	.short	0x1b1b
 8004628:	03031a1a 	.word	0x03031a1a
             p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;
             break;

        case OS_TASK_STATE_PEND_SUSPENDED:
        case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
             if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
 800462c:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
 8004630:	2b03      	cmp	r3, #3
 8004632:	d03f      	beq.n	80046b4 <OS_PendObjDel+0xa0>
                 OS_PendObjDel1(p_obj,                           /* Indicate which object was pend aborted            */
                                p_tcb,
                                ts);
             }
#if (OS_MSG_EN > 0u)
             p_tcb->MsgPtr     = (void      *)0;
 8004634:	2500      	movs	r5, #0
             p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
#endif
             p_tcb->TS         = ts;
 8004636:	6422      	str	r2, [r4, #64]	; 0x40
             OS_TickListRemove(p_tcb);                           /* Cancel the timeout                                */
 8004638:	4620      	mov	r0, r4
                 OS_PendObjDel1(p_obj,                           /* Indicate which object was pend aborted            */
                                p_tcb,
                                ts);
             }
#if (OS_MSG_EN > 0u)
             p_tcb->MsgPtr     = (void      *)0;
 800463a:	65e5      	str	r5, [r4, #92]	; 0x5c
             p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
 800463c:	f8a4 5060 	strh.w	r5, [r4, #96]	; 0x60
#endif
             p_tcb->TS         = ts;
             OS_TickListRemove(p_tcb);                           /* Cancel the timeout                                */
 8004640:	f003 f938 	bl	80078b4 <OS_TickListRemove>
             OS_PendListRemove(p_tcb);                           /* Remove task from all wait lists                   */
 8004644:	4620      	mov	r0, r4
 8004646:	f7ff fcfd 	bl	8004044 <OS_PendListRemove>
             p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;        /* Task needs to remain suspended                    */
 800464a:	2204      	movs	r2, #4
             p_tcb->PendStatus = OS_STATUS_PEND_DEL;             
 800464c:	2302      	movs	r3, #2
             p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
 800464e:	f884 5034 	strb.w	r5, [r4, #52]	; 0x34
             p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
#endif
             p_tcb->TS         = ts;
             OS_TickListRemove(p_tcb);                           /* Cancel the timeout                                */
             OS_PendListRemove(p_tcb);                           /* Remove task from all wait lists                   */
             p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;        /* Task needs to remain suspended                    */
 8004652:	f884 2036 	strb.w	r2, [r4, #54]	; 0x36
             p_tcb->PendStatus = OS_STATUS_PEND_DEL;             
 8004656:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
 800465a:	bd38      	pop	{r3, r4, r5, pc}
        case OS_TASK_STATE_DLY_SUSPENDED:
             break;

        case OS_TASK_STATE_PEND:
        case OS_TASK_STATE_PEND_TIMEOUT:
             if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
 800465c:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
 8004660:	2b03      	cmp	r3, #3
 8004662:	d012      	beq.n	800468a <OS_PendObjDel+0x76>
                 OS_PendObjDel1(p_obj,                           /* Indicate which object was pend aborted            */
                                p_tcb,
                                ts);
             }
#if (OS_MSG_EN > 0u)
             p_tcb->MsgPtr     = (void *)0;
 8004664:	2500      	movs	r5, #0
             p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
#endif
             p_tcb->TS         = ts;
 8004666:	6422      	str	r2, [r4, #64]	; 0x40
             OS_PendListRemove(p_tcb);                           /* Remove task from all wait lists                   */
 8004668:	4620      	mov	r0, r4
                 OS_PendObjDel1(p_obj,                           /* Indicate which object was pend aborted            */
                                p_tcb,
                                ts);
             }
#if (OS_MSG_EN > 0u)
             p_tcb->MsgPtr     = (void *)0;
 800466a:	65e5      	str	r5, [r4, #92]	; 0x5c
             p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
 800466c:	f8a4 5060 	strh.w	r5, [r4, #96]	; 0x60
#endif
             p_tcb->TS         = ts;
             OS_PendListRemove(p_tcb);                           /* Remove task from all wait lists                   */
 8004670:	f7ff fce8 	bl	8004044 <OS_PendListRemove>
             OS_TaskRdy(p_tcb);
 8004674:	4620      	mov	r0, r4
 8004676:	f7ff ff55 	bl	8004524 <OS_TaskRdy>
             p_tcb->TaskState  = OS_TASK_STATE_RDY;              /* Task is readied because object is deleted         */
             p_tcb->PendStatus = OS_STATUS_PEND_DEL;             
 800467a:	2302      	movs	r3, #2
             p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
#endif
             p_tcb->TS         = ts;
             OS_PendListRemove(p_tcb);                           /* Remove task from all wait lists                   */
             OS_TaskRdy(p_tcb);
             p_tcb->TaskState  = OS_TASK_STATE_RDY;              /* Task is readied because object is deleted         */
 800467c:	f884 5036 	strb.w	r5, [r4, #54]	; 0x36
             p_tcb->PendStatus = OS_STATUS_PEND_DEL;             
             p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;
 8004680:	f884 5034 	strb.w	r5, [r4, #52]	; 0x34
#endif
             p_tcb->TS         = ts;
             OS_PendListRemove(p_tcb);                           /* Remove task from all wait lists                   */
             OS_TaskRdy(p_tcb);
             p_tcb->TaskState  = OS_TASK_STATE_RDY;              /* Task is readied because object is deleted         */
             p_tcb->PendStatus = OS_STATUS_PEND_DEL;             
 8004684:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
             p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;
             break;
 8004688:	bd38      	pop	{r3, r4, r5, pc}
    OS_PEND_DATA   *p_pend_data;



    p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
    n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */
 800468a:	8fe1      	ldrh	r1, [r4, #62]	; 0x3e
    OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
    OS_PEND_DATA   *p_pend_data;



    p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
 800468c:	6b23      	ldr	r3, [r4, #48]	; 0x30
    n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */

    while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
 800468e:	2900      	cmp	r1, #0
 8004690:	d0e8      	beq.n	8004664 <OS_PendObjDel+0x50>
        if (p_obj == p_pend_data->PendObjPtr) {                     /* Did we find the object deleted?                */
 8004692:	68dd      	ldr	r5, [r3, #12]
 8004694:	42a8      	cmp	r0, r5
 8004696:	d00a      	beq.n	80046ae <OS_PendObjDel+0x9a>
 8004698:	1e4d      	subs	r5, r1, #1
 800469a:	b2ad      	uxth	r5, r5
 800469c:	3501      	adds	r5, #1
 800469e:	eb03 1545 	add.w	r5, r3, r5, lsl #5
            p_pend_data->RdyObjPtr = p_obj;                         /* Yes, indicate the object in the .RdyObjPtr     */
            p_pend_data->RdyTS     = ts;                            /*      save the timestamp                        */
            break;
        }
        p_pend_data++;
 80046a2:	3320      	adds	r3, #32


    p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
    n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */

    while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
 80046a4:	42ab      	cmp	r3, r5
 80046a6:	d0dd      	beq.n	8004664 <OS_PendObjDel+0x50>
        if (p_obj == p_pend_data->PendObjPtr) {                     /* Did we find the object deleted?                */
 80046a8:	68d9      	ldr	r1, [r3, #12]
 80046aa:	4288      	cmp	r0, r1
 80046ac:	d1f9      	bne.n	80046a2 <OS_PendObjDel+0x8e>
            p_pend_data->RdyObjPtr = p_obj;                         /* Yes, indicate the object in the .RdyObjPtr     */
 80046ae:	6118      	str	r0, [r3, #16]
            p_pend_data->RdyTS     = ts;                            /*      save the timestamp                        */
 80046b0:	61da      	str	r2, [r3, #28]
 80046b2:	e7d7      	b.n	8004664 <OS_PendObjDel+0x50>
    OS_PEND_DATA   *p_pend_data;



    p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
    n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */
 80046b4:	8fe1      	ldrh	r1, [r4, #62]	; 0x3e
    OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
    OS_PEND_DATA   *p_pend_data;



    p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
 80046b6:	6b23      	ldr	r3, [r4, #48]	; 0x30
    n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */

    while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
 80046b8:	2900      	cmp	r1, #0
 80046ba:	d0bb      	beq.n	8004634 <OS_PendObjDel+0x20>
        if (p_obj == p_pend_data->PendObjPtr) {                     /* Did we find the object deleted?                */
 80046bc:	68dd      	ldr	r5, [r3, #12]
 80046be:	42a8      	cmp	r0, r5
 80046c0:	d00a      	beq.n	80046d8 <OS_PendObjDel+0xc4>
 80046c2:	1e4d      	subs	r5, r1, #1
 80046c4:	b2ad      	uxth	r5, r5
 80046c6:	3501      	adds	r5, #1
 80046c8:	eb03 1545 	add.w	r5, r3, r5, lsl #5
            p_pend_data->RdyObjPtr = p_obj;                         /* Yes, indicate the object in the .RdyObjPtr     */
            p_pend_data->RdyTS     = ts;                            /*      save the timestamp                        */
            break;
        }
        p_pend_data++;
 80046cc:	3320      	adds	r3, #32


    p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
    n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */

    while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
 80046ce:	42ab      	cmp	r3, r5
 80046d0:	d0b0      	beq.n	8004634 <OS_PendObjDel+0x20>
        if (p_obj == p_pend_data->PendObjPtr) {                     /* Did we find the object deleted?                */
 80046d2:	68d9      	ldr	r1, [r3, #12]
 80046d4:	4288      	cmp	r0, r1
 80046d6:	d1f9      	bne.n	80046cc <OS_PendObjDel+0xb8>
            p_pend_data->RdyObjPtr = p_obj;                         /* Yes, indicate the object in the .RdyObjPtr     */
 80046d8:	6118      	str	r0, [r3, #16]
            p_pend_data->RdyTS     = ts;                            /*      save the timestamp                        */
 80046da:	61da      	str	r2, [r3, #28]
 80046dc:	e7aa      	b.n	8004634 <OS_PendObjDel+0x20>
 80046de:	bf00      	nop

080046e0 <OS_Post>:
void  OS_Post (OS_PEND_OBJ  *p_obj,
               OS_TCB       *p_tcb,
               void         *p_void,
               OS_MSG_SIZE   msg_size,
               CPU_TS        ts)
{
 80046e0:	b570      	push	{r4, r5, r6, lr}
 80046e2:	460c      	mov	r4, r1
    switch (p_tcb->TaskState) {
 80046e4:	f891 1036 	ldrb.w	r1, [r1, #54]	; 0x36
void  OS_Post (OS_PEND_OBJ  *p_obj,
               OS_TCB       *p_tcb,
               void         *p_void,
               OS_MSG_SIZE   msg_size,
               CPU_TS        ts)
{
 80046e8:	4605      	mov	r5, r0
    switch (p_tcb->TaskState) {
 80046ea:	3902      	subs	r1, #2
 80046ec:	2905      	cmp	r1, #5
 80046ee:	d822      	bhi.n	8004736 <OS_Post+0x56>
 80046f0:	e8df f001 	tbb	[pc, r1]
 80046f4:	21212222 	.word	0x21212222
 80046f8:	0303      	.short	0x0303
             p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
             break;

        case OS_TASK_STATE_PEND_SUSPENDED:
        case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
             if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
 80046fa:	f894 1034 	ldrb.w	r1, [r4, #52]	; 0x34
 80046fe:	2903      	cmp	r1, #3
 8004700:	d053      	beq.n	80047aa <OS_Post+0xca>
                          msg_size,
                          ts);
             } else {
#if (OS_MSG_EN > 0u)
                 p_tcb->MsgPtr  = p_void;                        /* Deposit message in OS_TCB of task waiting         */
                 p_tcb->MsgSize = msg_size;                      /* ... assuming posting a message                    */
 8004702:	f8a4 3060 	strh.w	r3, [r4, #96]	; 0x60
#endif
                 p_tcb->TS      = ts;
 8004706:	9b04      	ldr	r3, [sp, #16]
                          p_void,
                          msg_size,
                          ts);
             } else {
#if (OS_MSG_EN > 0u)
                 p_tcb->MsgPtr  = p_void;                        /* Deposit message in OS_TCB of task waiting         */
 8004708:	65e2      	str	r2, [r4, #92]	; 0x5c
                 p_tcb->MsgSize = msg_size;                      /* ... assuming posting a message                    */
#endif
                 p_tcb->TS      = ts;
 800470a:	6423      	str	r3, [r4, #64]	; 0x40
             }
             OS_TickListRemove(p_tcb);                           /* Cancel any timeout                                */
 800470c:	4620      	mov	r0, r4
 800470e:	f003 f8d1 	bl	80078b4 <OS_TickListRemove>
             if (p_obj != (OS_PEND_OBJ *)0) {
 8004712:	b145      	cbz	r5, 8004726 <OS_Post+0x46>
                 OS_PendListRemove(p_tcb);                       /* Remove task from wait list(s)                     */
 8004714:	4620      	mov	r0, r4
 8004716:	f7ff fc95 	bl	8004044 <OS_PendListRemove>
    OS_PEND_LIST  *p_pend_list;
    OS_PEND_DATA  *p_pend_data;
    OS_TCB        *p_tcb1;


    p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)" ");          /* Remove name of object pended on for readied task       */
 800471a:	4a34      	ldr	r2, [pc, #208]	; (80047ec <OS_Post+0x10c>)
    p_pend_list       = &p_obj->PendList;
    p_pend_data       =  p_pend_list->HeadPtr;
 800471c:	68ab      	ldr	r3, [r5, #8]
    OS_PEND_LIST  *p_pend_list;
    OS_PEND_DATA  *p_pend_data;
    OS_TCB        *p_tcb1;


    p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)" ");          /* Remove name of object pended on for readied task       */
 800471e:	f8c4 20c0 	str.w	r2, [r4, #192]	; 0xc0
    p_pend_list       = &p_obj->PendList;
    p_pend_data       =  p_pend_list->HeadPtr;
    if (p_pend_data  != (OS_PEND_DATA *)0) {
 8004722:	bb53      	cbnz	r3, 800477a <OS_Post+0x9a>
        p_tcb1            = p_pend_data->TCBPtr;
        p_obj->DbgNamePtr = p_tcb1->NamePtr;
    } else {
        p_obj->DbgNamePtr = (CPU_CHAR *)((void *)" ");      /* No other task pending on object                        */
 8004724:	61ea      	str	r2, [r5, #28]
                 OS_PendDbgNameRemove(p_obj,
                                      p_tcb);
#endif
             }
             p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;
             p_tcb->PendStatus = OS_STATUS_PEND_OK;              /* Clear pend status                                 */
 8004726:	2300      	movs	r3, #0
#if OS_CFG_DBG_EN > 0u
                 OS_PendDbgNameRemove(p_obj,
                                      p_tcb);
#endif
             }
             p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;
 8004728:	2204      	movs	r2, #4
 800472a:	f884 2036 	strb.w	r2, [r4, #54]	; 0x36
             p_tcb->PendStatus = OS_STATUS_PEND_OK;              /* Clear pend status                                 */
 800472e:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
             p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
 8004732:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 8004736:	bd70      	pop	{r4, r5, r6, pc}
        case OS_TASK_STATE_DLY_SUSPENDED:                        /* Cannot Post a suspended task that was also dly'd  */
             break;

        case OS_TASK_STATE_PEND:
        case OS_TASK_STATE_PEND_TIMEOUT:
             if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
 8004738:	f894 1034 	ldrb.w	r1, [r4, #52]	; 0x34
 800473c:	2903      	cmp	r1, #3
 800473e:	d020      	beq.n	8004782 <OS_Post+0xa2>
                          msg_size,
                          ts);
             } else {
#if (OS_MSG_EN > 0u)
                 p_tcb->MsgPtr  = p_void;                        /* Deposit message in OS_TCB of task waiting         */
                 p_tcb->MsgSize = msg_size;                      /* ... assuming posting a message                    */
 8004740:	f8a4 3060 	strh.w	r3, [r4, #96]	; 0x60
#endif
                 p_tcb->TS      = ts;
 8004744:	9b04      	ldr	r3, [sp, #16]
                          p_void,
                          msg_size,
                          ts);
             } else {
#if (OS_MSG_EN > 0u)
                 p_tcb->MsgPtr  = p_void;                        /* Deposit message in OS_TCB of task waiting         */
 8004746:	65e2      	str	r2, [r4, #92]	; 0x5c
                 p_tcb->MsgSize = msg_size;                      /* ... assuming posting a message                    */
#endif
                 p_tcb->TS      = ts;
 8004748:	6423      	str	r3, [r4, #64]	; 0x40
             }
             if (p_obj != (OS_PEND_OBJ *)0) {
 800474a:	b15d      	cbz	r5, 8004764 <OS_Post+0x84>
                 OS_PendListRemove(p_tcb);                       /* Remove task from wait list(s)                     */
 800474c:	4620      	mov	r0, r4
 800474e:	f7ff fc79 	bl	8004044 <OS_PendListRemove>
    OS_PEND_LIST  *p_pend_list;
    OS_PEND_DATA  *p_pend_data;
    OS_TCB        *p_tcb1;


    p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)" ");          /* Remove name of object pended on for readied task       */
 8004752:	4a26      	ldr	r2, [pc, #152]	; (80047ec <OS_Post+0x10c>)
    p_pend_list       = &p_obj->PendList;
    p_pend_data       =  p_pend_list->HeadPtr;
 8004754:	68ab      	ldr	r3, [r5, #8]
    OS_PEND_LIST  *p_pend_list;
    OS_PEND_DATA  *p_pend_data;
    OS_TCB        *p_tcb1;


    p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)" ");          /* Remove name of object pended on for readied task       */
 8004756:	f8c4 20c0 	str.w	r2, [r4, #192]	; 0xc0
    p_pend_list       = &p_obj->PendList;
    p_pend_data       =  p_pend_list->HeadPtr;
    if (p_pend_data  != (OS_PEND_DATA *)0) {
 800475a:	2b00      	cmp	r3, #0
 800475c:	d043      	beq.n	80047e6 <OS_Post+0x106>
        p_tcb1            = p_pend_data->TCBPtr;
        p_obj->DbgNamePtr = p_tcb1->NamePtr;
 800475e:	689b      	ldr	r3, [r3, #8]
 8004760:	6a1b      	ldr	r3, [r3, #32]
 8004762:	61eb      	str	r3, [r5, #28]
#if OS_CFG_DBG_EN > 0u
                 OS_PendDbgNameRemove(p_obj,
                                      p_tcb);
#endif
             }
             OS_TaskRdy(p_tcb);                                  /* Make task ready to run                            */
 8004764:	4620      	mov	r0, r4
 8004766:	f7ff fedd 	bl	8004524 <OS_TaskRdy>
             p_tcb->TaskState  = OS_TASK_STATE_RDY;
 800476a:	2300      	movs	r3, #0
 800476c:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
             p_tcb->PendStatus = OS_STATUS_PEND_OK;              /* Clear pend status                                 */
 8004770:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
             p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
 8004774:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
             break;
 8004778:	bd70      	pop	{r4, r5, r6, pc}
    p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)" ");          /* Remove name of object pended on for readied task       */
    p_pend_list       = &p_obj->PendList;
    p_pend_data       =  p_pend_list->HeadPtr;
    if (p_pend_data  != (OS_PEND_DATA *)0) {
        p_tcb1            = p_pend_data->TCBPtr;
        p_obj->DbgNamePtr = p_tcb1->NamePtr;
 800477a:	689b      	ldr	r3, [r3, #8]
 800477c:	6a1b      	ldr	r3, [r3, #32]
 800477e:	61eb      	str	r3, [r5, #28]
 8004780:	e7d1      	b.n	8004726 <OS_Post+0x46>
    OS_PEND_DATA   *p_pend_data;



    p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
    n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */
 8004782:	8fe0      	ldrh	r0, [r4, #62]	; 0x3e
    OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
    OS_PEND_DATA   *p_pend_data;



    p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
 8004784:	6b21      	ldr	r1, [r4, #48]	; 0x30
    n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */

    while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
 8004786:	2800      	cmp	r0, #0
 8004788:	d0df      	beq.n	800474a <OS_Post+0x6a>
        if (p_obj == p_pend_data->PendObjPtr) {                     /* Did we find the object posted to?              */
 800478a:	68ce      	ldr	r6, [r1, #12]
 800478c:	42b5      	cmp	r5, r6
 800478e:	d024      	beq.n	80047da <OS_Post+0xfa>
 8004790:	1e46      	subs	r6, r0, #1
 8004792:	b2b6      	uxth	r6, r6
 8004794:	3601      	adds	r6, #1
 8004796:	eb01 1646 	add.w	r6, r1, r6, lsl #5
 800479a:	e002      	b.n	80047a2 <OS_Post+0xc2>
 800479c:	68c8      	ldr	r0, [r1, #12]
 800479e:	4285      	cmp	r5, r0
 80047a0:	d01b      	beq.n	80047da <OS_Post+0xfa>
            p_pend_data->RdyMsgPtr  = p_void;                       /*      store the message posted                  */
            p_pend_data->RdyMsgSize = msg_size;                     /*      store the size of the message posted      */
            p_pend_data->RdyTS      = ts;                           /*      save the timestamp of the post            */
            break;
        }
        p_pend_data++;
 80047a2:	3120      	adds	r1, #32


    p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
    n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */

    while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
 80047a4:	42b1      	cmp	r1, r6
 80047a6:	d1f9      	bne.n	800479c <OS_Post+0xbc>
 80047a8:	e7cf      	b.n	800474a <OS_Post+0x6a>
    OS_PEND_DATA   *p_pend_data;



    p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
    n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */
 80047aa:	8fe0      	ldrh	r0, [r4, #62]	; 0x3e
    OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
    OS_PEND_DATA   *p_pend_data;



    p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
 80047ac:	6b21      	ldr	r1, [r4, #48]	; 0x30
    n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */

    while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
 80047ae:	2800      	cmp	r0, #0
 80047b0:	d0ac      	beq.n	800470c <OS_Post+0x2c>
        if (p_obj == p_pend_data->PendObjPtr) {                     /* Did we find the object posted to?              */
 80047b2:	68ce      	ldr	r6, [r1, #12]
 80047b4:	42b5      	cmp	r5, r6
 80047b6:	d00a      	beq.n	80047ce <OS_Post+0xee>
 80047b8:	1e46      	subs	r6, r0, #1
 80047ba:	b2b6      	uxth	r6, r6
 80047bc:	3601      	adds	r6, #1
 80047be:	eb01 1646 	add.w	r6, r1, r6, lsl #5
            p_pend_data->RdyMsgPtr  = p_void;                       /*      store the message posted                  */
            p_pend_data->RdyMsgSize = msg_size;                     /*      store the size of the message posted      */
            p_pend_data->RdyTS      = ts;                           /*      save the timestamp of the post            */
            break;
        }
        p_pend_data++;
 80047c2:	3120      	adds	r1, #32


    p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
    n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */

    while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
 80047c4:	42b1      	cmp	r1, r6
 80047c6:	d0a1      	beq.n	800470c <OS_Post+0x2c>
        if (p_obj == p_pend_data->PendObjPtr) {                     /* Did we find the object posted to?              */
 80047c8:	68c8      	ldr	r0, [r1, #12]
 80047ca:	4285      	cmp	r5, r0
 80047cc:	d1f9      	bne.n	80047c2 <OS_Post+0xe2>
            p_pend_data->RdyObjPtr  = p_obj;                        /* Yes, indicate the object in the .RdyObjPtr     */
            p_pend_data->RdyMsgPtr  = p_void;                       /*      store the message posted                  */
            p_pend_data->RdyMsgSize = msg_size;                     /*      store the size of the message posted      */
 80047ce:	830b      	strh	r3, [r1, #24]
            p_pend_data->RdyTS      = ts;                           /*      save the timestamp of the post            */
 80047d0:	9b04      	ldr	r3, [sp, #16]
    p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
    n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */

    while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
        if (p_obj == p_pend_data->PendObjPtr) {                     /* Did we find the object posted to?              */
            p_pend_data->RdyObjPtr  = p_obj;                        /* Yes, indicate the object in the .RdyObjPtr     */
 80047d2:	610d      	str	r5, [r1, #16]
            p_pend_data->RdyMsgPtr  = p_void;                       /*      store the message posted                  */
 80047d4:	614a      	str	r2, [r1, #20]
            p_pend_data->RdyMsgSize = msg_size;                     /*      store the size of the message posted      */
            p_pend_data->RdyTS      = ts;                           /*      save the timestamp of the post            */
 80047d6:	61cb      	str	r3, [r1, #28]
 80047d8:	e798      	b.n	800470c <OS_Post+0x2c>

    while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
        if (p_obj == p_pend_data->PendObjPtr) {                     /* Did we find the object posted to?              */
            p_pend_data->RdyObjPtr  = p_obj;                        /* Yes, indicate the object in the .RdyObjPtr     */
            p_pend_data->RdyMsgPtr  = p_void;                       /*      store the message posted                  */
            p_pend_data->RdyMsgSize = msg_size;                     /*      store the size of the message posted      */
 80047da:	830b      	strh	r3, [r1, #24]
            p_pend_data->RdyTS      = ts;                           /*      save the timestamp of the post            */
 80047dc:	9b04      	ldr	r3, [sp, #16]
    p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
    n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */

    while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
        if (p_obj == p_pend_data->PendObjPtr) {                     /* Did we find the object posted to?              */
            p_pend_data->RdyObjPtr  = p_obj;                        /* Yes, indicate the object in the .RdyObjPtr     */
 80047de:	610d      	str	r5, [r1, #16]
            p_pend_data->RdyMsgPtr  = p_void;                       /*      store the message posted                  */
 80047e0:	614a      	str	r2, [r1, #20]
            p_pend_data->RdyMsgSize = msg_size;                     /*      store the size of the message posted      */
            p_pend_data->RdyTS      = ts;                           /*      save the timestamp of the post            */
 80047e2:	61cb      	str	r3, [r1, #28]
 80047e4:	e7b1      	b.n	800474a <OS_Post+0x6a>
    p_pend_data       =  p_pend_list->HeadPtr;
    if (p_pend_data  != (OS_PEND_DATA *)0) {
        p_tcb1            = p_pend_data->TCBPtr;
        p_obj->DbgNamePtr = p_tcb1->NamePtr;
    } else {
        p_obj->DbgNamePtr = (CPU_CHAR *)((void *)" ");      /* No other task pending on object                        */
 80047e6:	61ea      	str	r2, [r5, #28]
 80047e8:	e7bc      	b.n	8004764 <OS_Post+0x84>
 80047ea:	bf00      	nop
 80047ec:	080182f0 	.word	0x080182f0

080047f0 <OSStartHighRdy>:
 80047f0:	4818      	ldr	r0, [pc, #96]	; (8004854 <OS_CPU_PendSVHandler_nosave+0x30>)
 80047f2:	21ff      	movs	r1, #255	; 0xff
 80047f4:	7001      	strb	r1, [r0, #0]
 80047f6:	2000      	movs	r0, #0
 80047f8:	f380 8809 	msr	PSP, r0
 80047fc:	4816      	ldr	r0, [pc, #88]	; (8004858 <OS_CPU_PendSVHandler_nosave+0x34>)
 80047fe:	6801      	ldr	r1, [r0, #0]
 8004800:	f381 8808 	msr	MSP, r1
 8004804:	4815      	ldr	r0, [pc, #84]	; (800485c <OS_CPU_PendSVHandler_nosave+0x38>)
 8004806:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
 800480a:	6001      	str	r1, [r0, #0]
 800480c:	b662      	cpsie	i

0800480e <OSStartHang>:
 800480e:	e7fe      	b.n	800480e <OSStartHang>

08004810 <OS_CPU_PendSVHandler>:
 8004810:	b672      	cpsid	i
 8004812:	f3ef 8009 	mrs	r0, PSP
 8004816:	b128      	cbz	r0, 8004824 <OS_CPU_PendSVHandler_nosave>
 8004818:	3820      	subs	r0, #32
 800481a:	e880 0ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp}
 800481e:	4910      	ldr	r1, [pc, #64]	; (8004860 <OS_CPU_PendSVHandler_nosave+0x3c>)
 8004820:	6809      	ldr	r1, [r1, #0]
 8004822:	6008      	str	r0, [r1, #0]

08004824 <OS_CPU_PendSVHandler_nosave>:
 8004824:	b500      	push	{lr}
 8004826:	480f      	ldr	r0, [pc, #60]	; (8004864 <OS_CPU_PendSVHandler_nosave+0x40>)
 8004828:	4780      	blx	r0
 800482a:	f85d eb04 	ldr.w	lr, [sp], #4
 800482e:	480e      	ldr	r0, [pc, #56]	; (8004868 <OS_CPU_PendSVHandler_nosave+0x44>)
 8004830:	490e      	ldr	r1, [pc, #56]	; (800486c <OS_CPU_PendSVHandler_nosave+0x48>)
 8004832:	780a      	ldrb	r2, [r1, #0]
 8004834:	7002      	strb	r2, [r0, #0]
 8004836:	480a      	ldr	r0, [pc, #40]	; (8004860 <OS_CPU_PendSVHandler_nosave+0x3c>)
 8004838:	490d      	ldr	r1, [pc, #52]	; (8004870 <OS_CPU_PendSVHandler_nosave+0x4c>)
 800483a:	680a      	ldr	r2, [r1, #0]
 800483c:	6002      	str	r2, [r0, #0]
 800483e:	6810      	ldr	r0, [r2, #0]
 8004840:	e890 0ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp}
 8004844:	3020      	adds	r0, #32
 8004846:	f380 8809 	msr	PSP, r0
 800484a:	f04e 0e04 	orr.w	lr, lr, #4
 800484e:	b662      	cpsie	i
 8004850:	4770      	bx	lr
 8004852:	0000      	.short	0x0000
 8004854:	e000ed22 	.word	0xe000ed22
 8004858:	2000e968 	.word	0x2000e968
 800485c:	e000ed04 	.word	0xe000ed04
 8004860:	2000ed58 	.word	0x2000ed58
 8004864:	08004989 	.word	0x08004989
 8004868:	2000ec88 	.word	0x2000ec88
 800486c:	2000ec7c 	.word	0x2000ec7c
 8004870:	2000ed64 	.word	0x2000ed64

08004874 <OSIdleTaskHook>:
*/

void  OSIdleTaskHook (void)
{
#if OS_CFG_APP_HOOKS_EN > 0u
    if (OS_AppIdleTaskHookPtr != (OS_APP_HOOK_VOID)0) {
 8004874:	4b02      	ldr	r3, [pc, #8]	; (8004880 <OSIdleTaskHook+0xc>)
 8004876:	681b      	ldr	r3, [r3, #0]
 8004878:	b103      	cbz	r3, 800487c <OSIdleTaskHook+0x8>
        (*OS_AppIdleTaskHookPtr)();
 800487a:	4718      	bx	r3
 800487c:	4770      	bx	lr
 800487e:	bf00      	nop
 8004880:	2000ef2c 	.word	0x2000ef2c

08004884 <OSInitHook>:
    CPU_STK_SIZE   i;
    CPU_STK       *p_stk;


    p_stk = OSCfg_ISRStkBasePtr;                            /* Clear the ISR stack                                    */
    for (i = 0u; i < OSCfg_ISRStkSize; i++) {
 8004884:	4a0c      	ldr	r2, [pc, #48]	; (80048b8 <OSInitHook+0x34>)
{
    CPU_STK_SIZE   i;
    CPU_STK       *p_stk;


    p_stk = OSCfg_ISRStkBasePtr;                            /* Clear the ISR stack                                    */
 8004886:	4b0d      	ldr	r3, [pc, #52]	; (80048bc <OSInitHook+0x38>)
    for (i = 0u; i < OSCfg_ISRStkSize; i++) {
 8004888:	6811      	ldr	r1, [r2, #0]
* Note(s)    : None.
*********************************************************************************************************
*/

void  OSInitHook (void)
{
 800488a:	b410      	push	{r4}
    CPU_STK_SIZE   i;
    CPU_STK       *p_stk;


    p_stk = OSCfg_ISRStkBasePtr;                            /* Clear the ISR stack                                    */
 800488c:	681c      	ldr	r4, [r3, #0]
    for (i = 0u; i < OSCfg_ISRStkSize; i++) {
 800488e:	b181      	cbz	r1, 80048b2 <OSInitHook+0x2e>
 8004890:	2300      	movs	r3, #0
        *p_stk++ = (CPU_STK)0u;
 8004892:	4618      	mov	r0, r3
    CPU_STK_SIZE   i;
    CPU_STK       *p_stk;


    p_stk = OSCfg_ISRStkBasePtr;                            /* Clear the ISR stack                                    */
    for (i = 0u; i < OSCfg_ISRStkSize; i++) {
 8004894:	4622      	mov	r2, r4
 8004896:	3301      	adds	r3, #1
 8004898:	428b      	cmp	r3, r1
        *p_stk++ = (CPU_STK)0u;
 800489a:	f842 0b04 	str.w	r0, [r2], #4
    CPU_STK_SIZE   i;
    CPU_STK       *p_stk;


    p_stk = OSCfg_ISRStkBasePtr;                            /* Clear the ISR stack                                    */
    for (i = 0u; i < OSCfg_ISRStkSize; i++) {
 800489e:	d1fa      	bne.n	8004896 <OSInitHook+0x12>
 80048a0:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80048a4:	3b01      	subs	r3, #1
 80048a6:	009b      	lsls	r3, r3, #2
        *p_stk++ = (CPU_STK)0u;
    }
    OS_CPU_ExceptStkBase = (CPU_STK *)(OSCfg_ISRStkBasePtr + OSCfg_ISRStkSize - 1u);
 80048a8:	4a05      	ldr	r2, [pc, #20]	; (80048c0 <OSInitHook+0x3c>)
 80048aa:	4423      	add	r3, r4
 80048ac:	6013      	str	r3, [r2, #0]
}
 80048ae:	bc10      	pop	{r4}
 80048b0:	4770      	bx	lr
    CPU_STK_SIZE   i;
    CPU_STK       *p_stk;


    p_stk = OSCfg_ISRStkBasePtr;                            /* Clear the ISR stack                                    */
    for (i = 0u; i < OSCfg_ISRStkSize; i++) {
 80048b2:	f06f 0303 	mvn.w	r3, #3
 80048b6:	e7f7      	b.n	80048a8 <OSInitHook+0x24>
 80048b8:	080160fc 	.word	0x080160fc
 80048bc:	08016100 	.word	0x08016100
 80048c0:	2000e968 	.word	0x2000e968

080048c4 <OSStatTaskHook>:
*/

void  OSStatTaskHook (void)
{
#if OS_CFG_APP_HOOKS_EN > 0u
    if (OS_AppStatTaskHookPtr != (OS_APP_HOOK_VOID)0) {
 80048c4:	4b02      	ldr	r3, [pc, #8]	; (80048d0 <OSStatTaskHook+0xc>)
 80048c6:	681b      	ldr	r3, [r3, #0]
 80048c8:	b103      	cbz	r3, 80048cc <OSStatTaskHook+0x8>
        (*OS_AppStatTaskHookPtr)();
 80048ca:	4718      	bx	r3
 80048cc:	4770      	bx	lr
 80048ce:	bf00      	nop
 80048d0:	2000ef48 	.word	0x2000ef48

080048d4 <OSTaskCreateHook>:
*/

void  OSTaskCreateHook (OS_TCB  *p_tcb)
{
#if OS_CFG_APP_HOOKS_EN > 0u
    if (OS_AppTaskCreateHookPtr != (OS_APP_HOOK_TCB)0) {
 80048d4:	4b02      	ldr	r3, [pc, #8]	; (80048e0 <OSTaskCreateHook+0xc>)
 80048d6:	681b      	ldr	r3, [r3, #0]
 80048d8:	b103      	cbz	r3, 80048dc <OSTaskCreateHook+0x8>
        (*OS_AppTaskCreateHookPtr)(p_tcb);
 80048da:	4718      	bx	r3
 80048dc:	4770      	bx	lr
 80048de:	bf00      	nop
 80048e0:	2000ec84 	.word	0x2000ec84

080048e4 <OSTaskDelHook>:
*/

void  OSTaskDelHook (OS_TCB  *p_tcb)
{
#if OS_CFG_APP_HOOKS_EN > 0u
    if (OS_AppTaskDelHookPtr != (OS_APP_HOOK_TCB)0) {
 80048e4:	4b02      	ldr	r3, [pc, #8]	; (80048f0 <OSTaskDelHook+0xc>)
 80048e6:	681b      	ldr	r3, [r3, #0]
 80048e8:	b103      	cbz	r3, 80048ec <OSTaskDelHook+0x8>
        (*OS_AppTaskDelHookPtr)(p_tcb);
 80048ea:	4718      	bx	r3
 80048ec:	4770      	bx	lr
 80048ee:	bf00      	nop
 80048f0:	2000ed74 	.word	0x2000ed74

080048f4 <OSTaskReturnHook>:
*/

void  OSTaskReturnHook (OS_TCB  *p_tcb)
{
#if OS_CFG_APP_HOOKS_EN > 0u
    if (OS_AppTaskReturnHookPtr != (OS_APP_HOOK_TCB)0) {
 80048f4:	4b02      	ldr	r3, [pc, #8]	; (8004900 <OSTaskReturnHook+0xc>)
 80048f6:	681b      	ldr	r3, [r3, #0]
 80048f8:	b103      	cbz	r3, 80048fc <OSTaskReturnHook+0x8>
        (*OS_AppTaskReturnHookPtr)(p_tcb);
 80048fa:	4718      	bx	r3
 80048fc:	4770      	bx	lr
 80048fe:	bf00      	nop
 8004900:	2000e978 	.word	0x2000e978

08004904 <OSTaskStkInit>:
                         void          *p_arg,
                         CPU_STK       *p_stk_base,
                         CPU_STK       *p_stk_limit,
                         CPU_STK_SIZE   stk_size,
                         OS_OPT         opt)
{
 8004904:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004906:	9c05      	ldr	r4, [sp, #20]

    p_stk = &p_stk_base[stk_size];                          /* Load stack pointer                                     */
                                                            /* Registers stacked as if auto-saved on exception        */
    *--p_stk = (CPU_STK)0x01000000u;                        /* xPSR                                                   */
    *--p_stk = (CPU_STK)p_task;                             /* Entry Point                                            */
    *--p_stk = (CPU_STK)OS_TaskReturn;                      /* R14 (LR)                                               */
 8004908:	4f1e      	ldr	r7, [pc, #120]	; (8004984 <OSTaskStkInit+0x80>)
    CPU_STK  *p_stk;


    (void)opt;                                              /* Prevent compiler warning                               */

    p_stk = &p_stk_base[stk_size];                          /* Load stack pointer                                     */
 800490a:	eb02 0284 	add.w	r2, r2, r4, lsl #2
    *--p_stk = (CPU_STK)0x09090909u;                        /* R9                                                     */
    *--p_stk = (CPU_STK)0x08080808u;                        /* R8                                                     */
    *--p_stk = (CPU_STK)0x07070707u;                        /* R7                                                     */
    *--p_stk = (CPU_STK)0x06060606u;                        /* R6                                                     */
    *--p_stk = (CPU_STK)0x05050505u;                        /* R5                                                     */
    *--p_stk = (CPU_STK)0x04040404u;                        /* R4                                                     */
 800490e:	4614      	mov	r4, r2
    (void)opt;                                              /* Prevent compiler warning                               */

    p_stk = &p_stk_base[stk_size];                          /* Load stack pointer                                     */
                                                            /* Registers stacked as if auto-saved on exception        */
    *--p_stk = (CPU_STK)0x01000000u;                        /* xPSR                                                   */
    *--p_stk = (CPU_STK)p_task;                             /* Entry Point                                            */
 8004910:	f842 0c08 	str.w	r0, [r2, #-8]
    *--p_stk = (CPU_STK)OS_TaskReturn;                      /* R14 (LR)                                               */
    *--p_stk = (CPU_STK)0x12121212u;                        /* R12                                                    */
    *--p_stk = (CPU_STK)0x03030303u;                        /* R3                                                     */
    *--p_stk = (CPU_STK)0x02020202u;                        /* R2                                                     */
    *--p_stk = (CPU_STK)p_stk_limit;                        /* R1                                                     */
 8004914:	f842 3c1c 	str.w	r3, [r2, #-28]
    *--p_stk = (CPU_STK)p_arg;                              /* R0 : argument                                          */
 8004918:	f842 1c20 	str.w	r1, [r2, #-32]
    p_stk = &p_stk_base[stk_size];                          /* Load stack pointer                                     */
                                                            /* Registers stacked as if auto-saved on exception        */
    *--p_stk = (CPU_STK)0x01000000u;                        /* xPSR                                                   */
    *--p_stk = (CPU_STK)p_task;                             /* Entry Point                                            */
    *--p_stk = (CPU_STK)OS_TaskReturn;                      /* R14 (LR)                                               */
    *--p_stk = (CPU_STK)0x12121212u;                        /* R12                                                    */
 800491c:	f04f 3612 	mov.w	r6, #303174162	; 0x12121212
    *--p_stk = (CPU_STK)0x03030303u;                        /* R3                                                     */
 8004920:	f04f 3503 	mov.w	r5, #50529027	; 0x3030303
    *--p_stk = (CPU_STK)0x02020202u;                        /* R2                                                     */
 8004924:	f04f 3002 	mov.w	r0, #33686018	; 0x2020202
    *--p_stk = (CPU_STK)p_stk_limit;                        /* R1                                                     */
    *--p_stk = (CPU_STK)p_arg;                              /* R0 : argument                                          */
                                                            /* Remaining registers saved on process stack             */
    *--p_stk = (CPU_STK)0x11111111u;                        /* R11                                                    */
 8004928:	f04f 3111 	mov.w	r1, #286331153	; 0x11111111
    *--p_stk = (CPU_STK)0x10101010u;                        /* R10                                                    */
 800492c:	f04f 3310 	mov.w	r3, #269488144	; 0x10101010

    p_stk = &p_stk_base[stk_size];                          /* Load stack pointer                                     */
                                                            /* Registers stacked as if auto-saved on exception        */
    *--p_stk = (CPU_STK)0x01000000u;                        /* xPSR                                                   */
    *--p_stk = (CPU_STK)p_task;                             /* Entry Point                                            */
    *--p_stk = (CPU_STK)OS_TaskReturn;                      /* R14 (LR)                                               */
 8004930:	f842 7c0c 	str.w	r7, [r2, #-12]
    *--p_stk = (CPU_STK)0x12121212u;                        /* R12                                                    */
 8004934:	f842 6c10 	str.w	r6, [r2, #-16]
    *--p_stk = (CPU_STK)0x03030303u;                        /* R3                                                     */
 8004938:	f842 5c14 	str.w	r5, [r2, #-20]
    *--p_stk = (CPU_STK)0x02020202u;                        /* R2                                                     */
 800493c:	f842 0c18 	str.w	r0, [r2, #-24]
    *--p_stk = (CPU_STK)p_stk_limit;                        /* R1                                                     */
    *--p_stk = (CPU_STK)p_arg;                              /* R0 : argument                                          */
                                                            /* Remaining registers saved on process stack             */
    *--p_stk = (CPU_STK)0x11111111u;                        /* R11                                                    */
 8004940:	f842 1c24 	str.w	r1, [r2, #-36]
    *--p_stk = (CPU_STK)0x10101010u;                        /* R10                                                    */
 8004944:	f842 3c28 	str.w	r3, [r2, #-40]

    (void)opt;                                              /* Prevent compiler warning                               */

    p_stk = &p_stk_base[stk_size];                          /* Load stack pointer                                     */
                                                            /* Registers stacked as if auto-saved on exception        */
    *--p_stk = (CPU_STK)0x01000000u;                        /* xPSR                                                   */
 8004948:	f04f 7e80 	mov.w	lr, #16777216	; 0x1000000
    *--p_stk = (CPU_STK)p_stk_limit;                        /* R1                                                     */
    *--p_stk = (CPU_STK)p_arg;                              /* R0 : argument                                          */
                                                            /* Remaining registers saved on process stack             */
    *--p_stk = (CPU_STK)0x11111111u;                        /* R11                                                    */
    *--p_stk = (CPU_STK)0x10101010u;                        /* R10                                                    */
    *--p_stk = (CPU_STK)0x09090909u;                        /* R9                                                     */
 800494c:	f04f 3709 	mov.w	r7, #151587081	; 0x9090909
    *--p_stk = (CPU_STK)0x08080808u;                        /* R8                                                     */
 8004950:	f04f 3608 	mov.w	r6, #134744072	; 0x8080808
    *--p_stk = (CPU_STK)0x07070707u;                        /* R7                                                     */
 8004954:	f04f 3507 	mov.w	r5, #117901063	; 0x7070707
    *--p_stk = (CPU_STK)0x06060606u;                        /* R6                                                     */
 8004958:	f04f 3006 	mov.w	r0, #101058054	; 0x6060606
    *--p_stk = (CPU_STK)0x05050505u;                        /* R5                                                     */
 800495c:	f04f 3105 	mov.w	r1, #84215045	; 0x5050505
    *--p_stk = (CPU_STK)0x04040404u;                        /* R4                                                     */
 8004960:	f04f 3304 	mov.w	r3, #67372036	; 0x4040404
    *--p_stk = (CPU_STK)0x11111111u;                        /* R11                                                    */
    *--p_stk = (CPU_STK)0x10101010u;                        /* R10                                                    */
    *--p_stk = (CPU_STK)0x09090909u;                        /* R9                                                     */
    *--p_stk = (CPU_STK)0x08080808u;                        /* R8                                                     */
    *--p_stk = (CPU_STK)0x07070707u;                        /* R7                                                     */
    *--p_stk = (CPU_STK)0x06060606u;                        /* R6                                                     */
 8004964:	f842 0c38 	str.w	r0, [r2, #-56]

    (void)opt;                                              /* Prevent compiler warning                               */

    p_stk = &p_stk_base[stk_size];                          /* Load stack pointer                                     */
                                                            /* Registers stacked as if auto-saved on exception        */
    *--p_stk = (CPU_STK)0x01000000u;                        /* xPSR                                                   */
 8004968:	f842 ec04 	str.w	lr, [r2, #-4]
    *--p_stk = (CPU_STK)p_stk_limit;                        /* R1                                                     */
    *--p_stk = (CPU_STK)p_arg;                              /* R0 : argument                                          */
                                                            /* Remaining registers saved on process stack             */
    *--p_stk = (CPU_STK)0x11111111u;                        /* R11                                                    */
    *--p_stk = (CPU_STK)0x10101010u;                        /* R10                                                    */
    *--p_stk = (CPU_STK)0x09090909u;                        /* R9                                                     */
 800496c:	f842 7c2c 	str.w	r7, [r2, #-44]
    *--p_stk = (CPU_STK)0x08080808u;                        /* R8                                                     */
 8004970:	f842 6c30 	str.w	r6, [r2, #-48]
    *--p_stk = (CPU_STK)0x07070707u;                        /* R7                                                     */
 8004974:	f842 5c34 	str.w	r5, [r2, #-52]
    *--p_stk = (CPU_STK)0x06060606u;                        /* R6                                                     */
    *--p_stk = (CPU_STK)0x05050505u;                        /* R5                                                     */
 8004978:	f842 1c3c 	str.w	r1, [r2, #-60]
    *--p_stk = (CPU_STK)0x04040404u;                        /* R4                                                     */
 800497c:	f844 3d40 	str.w	r3, [r4, #-64]!

    return (p_stk);
}
 8004980:	4620      	mov	r0, r4
 8004982:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004984:	080074a9 	.word	0x080074a9

08004988 <OSTaskSwHook>:
*                 to the task being switched out (i.e. the preempted task).
*********************************************************************************************************
*/

void  OSTaskSwHook (void)
{
 8004988:	b538      	push	{r3, r4, r5, lr}
#endif



#if OS_CFG_APP_HOOKS_EN > 0u
    if (OS_AppTaskSwHookPtr != (OS_APP_HOOK_VOID)0) {
 800498a:	4b11      	ldr	r3, [pc, #68]	; (80049d0 <OSTaskSwHook+0x48>)
 800498c:	681b      	ldr	r3, [r3, #0]
 800498e:	b103      	cbz	r3, 8004992 <OSTaskSwHook+0xa>
        (*OS_AppTaskSwHookPtr)();
 8004990:	4798      	blx	r3
    }
#endif

#if OS_CFG_TASK_PROFILE_EN > 0u
    ts = OS_TS_GET();
 8004992:	f7fc f8fb 	bl	8000b8c <CPU_TS_TmrRd>
    if (OSTCBCurPtr != OSTCBHighRdyPtr) {
 8004996:	4b0f      	ldr	r3, [pc, #60]	; (80049d4 <OSTaskSwHook+0x4c>)
 8004998:	4a0f      	ldr	r2, [pc, #60]	; (80049d8 <OSTaskSwHook+0x50>)
 800499a:	681b      	ldr	r3, [r3, #0]
 800499c:	6814      	ldr	r4, [r2, #0]
 800499e:	42a3      	cmp	r3, r4
 80049a0:	d009      	beq.n	80049b6 <OSTaskSwHook+0x2e>
        OSTCBCurPtr->CyclesDelta  = ts - OSTCBCurPtr->CyclesStart;
 80049a2:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
        OSTCBCurPtr->CyclesTotal += (OS_CYCLES)OSTCBCurPtr->CyclesDelta;
 80049a6:	f8d3 109c 	ldr.w	r1, [r3, #156]	; 0x9c
#endif

#if OS_CFG_TASK_PROFILE_EN > 0u
    ts = OS_TS_GET();
    if (OSTCBCurPtr != OSTCBHighRdyPtr) {
        OSTCBCurPtr->CyclesDelta  = ts - OSTCBCurPtr->CyclesStart;
 80049aa:	1a82      	subs	r2, r0, r2
        OSTCBCurPtr->CyclesTotal += (OS_CYCLES)OSTCBCurPtr->CyclesDelta;
 80049ac:	4411      	add	r1, r2
#endif

#if OS_CFG_TASK_PROFILE_EN > 0u
    ts = OS_TS_GET();
    if (OSTCBCurPtr != OSTCBHighRdyPtr) {
        OSTCBCurPtr->CyclesDelta  = ts - OSTCBCurPtr->CyclesStart;
 80049ae:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
        OSTCBCurPtr->CyclesTotal += (OS_CYCLES)OSTCBCurPtr->CyclesDelta;
 80049b2:	f8c3 109c 	str.w	r1, [r3, #156]	; 0x9c
    }
#endif

#if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
                                                            /* Keep track of per-task scheduler lock time             */
    if (OSTCBCurPtr->SchedLockTimeMax < OSSchedLockTimeMaxCur) {
 80049b6:	4a09      	ldr	r2, [pc, #36]	; (80049dc <OSTaskSwHook+0x54>)
 80049b8:	f8d3 50b4 	ldr.w	r5, [r3, #180]	; 0xb4
 80049bc:	6811      	ldr	r1, [r2, #0]
    if (OSTCBCurPtr != OSTCBHighRdyPtr) {
        OSTCBCurPtr->CyclesDelta  = ts - OSTCBCurPtr->CyclesStart;
        OSTCBCurPtr->CyclesTotal += (OS_CYCLES)OSTCBCurPtr->CyclesDelta;
    }

    OSTCBHighRdyPtr->CyclesStart = ts;
 80049be:	f8c4 0098 	str.w	r0, [r4, #152]	; 0x98
    }
#endif

#if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
                                                            /* Keep track of per-task scheduler lock time             */
    if (OSTCBCurPtr->SchedLockTimeMax < OSSchedLockTimeMaxCur) {
 80049c2:	428d      	cmp	r5, r1
        OSTCBCurPtr->SchedLockTimeMax = OSSchedLockTimeMaxCur;
 80049c4:	bf38      	it	cc
 80049c6:	f8c3 10b4 	strcc.w	r1, [r3, #180]	; 0xb4
    }
    OSSchedLockTimeMaxCur = (CPU_TS)0;                      /* Reset the per-task value                               */
 80049ca:	2300      	movs	r3, #0
 80049cc:	6013      	str	r3, [r2, #0]
 80049ce:	bd38      	pop	{r3, r4, r5, pc}
 80049d0:	2000ef38 	.word	0x2000ef38
 80049d4:	2000ed58 	.word	0x2000ed58
 80049d8:	2000ed64 	.word	0x2000ed64
 80049dc:	2000ed68 	.word	0x2000ed68

080049e0 <OSTimeTickHook>:
*/

void  OSTimeTickHook (void)
{
#if OS_CFG_APP_HOOKS_EN > 0u
    if (OS_AppTimeTickHookPtr != (OS_APP_HOOK_VOID)0) {
 80049e0:	4b02      	ldr	r3, [pc, #8]	; (80049ec <OSTimeTickHook+0xc>)
 80049e2:	681b      	ldr	r3, [r3, #0]
 80049e4:	b103      	cbz	r3, 80049e8 <OSTimeTickHook+0x8>
        (*OS_AppTimeTickHookPtr)();
 80049e6:	4718      	bx	r3
 80049e8:	4770      	bx	lr
 80049ea:	bf00      	nop
 80049ec:	2000ed78 	.word	0x2000ed78

080049f0 <OS_CPU_SysTickHandler>:
* Note(s)    : 1) This function MUST be placed on entry 15 of the Cortex-M3 vector table.
*********************************************************************************************************
*/

void  OS_CPU_SysTickHandler (void)
{
 80049f0:	b508      	push	{r3, lr}
    CPU_SR_ALLOC();


    CPU_CRITICAL_ENTER();
 80049f2:	f7fc febf 	bl	8001774 <CPU_SR_Save>
    OSIntNestingCtr++;                                      /* Tell uC/OS-III that we are starting an ISR             */
 80049f6:	4a06      	ldr	r2, [pc, #24]	; (8004a10 <OS_CPU_SysTickHandler+0x20>)
 80049f8:	7813      	ldrb	r3, [r2, #0]
 80049fa:	3301      	adds	r3, #1
 80049fc:	7013      	strb	r3, [r2, #0]
    CPU_CRITICAL_EXIT();
 80049fe:	f7fc febd 	bl	800177c <CPU_SR_Restore>

    OSTimeTick();                                           /* Call uC/OS-III's OSTimeTick()                          */
 8004a02:	f003 f935 	bl	8007c70 <OSTimeTick>

    OSIntExit();                                            /* Tell uC/OS-III that we are leaving the ISR             */
}
 8004a06:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    OSIntNestingCtr++;                                      /* Tell uC/OS-III that we are starting an ISR             */
    CPU_CRITICAL_EXIT();

    OSTimeTick();                                           /* Call uC/OS-III's OSTimeTick()                          */

    OSIntExit();                                            /* Tell uC/OS-III that we are leaving the ISR             */
 8004a0a:	f7ff b841 	b.w	8003a90 <OSIntExit>
 8004a0e:	bf00      	nop
 8004a10:	2000ed84 	.word	0x2000ed84

08004a14 <OS_CPU_SysTickInit>:
void  OS_CPU_SysTickInit (CPU_INT32U  cnts)
{
    CPU_INT32U  prio;


    CPU_REG_NVIC_ST_RELOAD = cnts - 1u;
 8004a14:	4b0a      	ldr	r3, [pc, #40]	; (8004a40 <OS_CPU_SysTickInit+0x2c>)

                                                            /* Set SysTick handler prio.                              */
    prio  = CPU_REG_NVIC_SHPRI3;
 8004a16:	490b      	ldr	r1, [pc, #44]	; (8004a44 <OS_CPU_SysTickInit+0x30>)
void  OS_CPU_SysTickInit (CPU_INT32U  cnts)
{
    CPU_INT32U  prio;


    CPU_REG_NVIC_ST_RELOAD = cnts - 1u;
 8004a18:	3801      	subs	r0, #1
 8004a1a:	6018      	str	r0, [r3, #0]

                                                            /* Set SysTick handler prio.                              */
    prio  = CPU_REG_NVIC_SHPRI3;
 8004a1c:	680a      	ldr	r2, [r1, #0]
    prio &= DEF_BIT_FIELD(24, 0);
 8004a1e:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
    prio |= DEF_BIT_MASK(OS_CPU_CFG_SYSTICK_PRIO, 24);

    CPU_REG_NVIC_SHPRI3 = prio;
 8004a22:	600a      	str	r2, [r1, #0]

                                                            /* Enable timer.                                          */
    CPU_REG_NVIC_ST_CTRL |= CPU_REG_NVIC_ST_CTRL_CLKSOURCE |
 8004a24:	f853 2c04 	ldr.w	r2, [r3, #-4]
 8004a28:	f042 0205 	orr.w	r2, r2, #5
 8004a2c:	f843 2c04 	str.w	r2, [r3, #-4]
                            CPU_REG_NVIC_ST_CTRL_ENABLE;
                                                            /* Enable timer interrupt.                                */
    CPU_REG_NVIC_ST_CTRL |= CPU_REG_NVIC_ST_CTRL_TICKINT;
 8004a30:	f853 2c04 	ldr.w	r2, [r3, #-4]
 8004a34:	f042 0202 	orr.w	r2, r2, #2
 8004a38:	f843 2c04 	str.w	r2, [r3, #-4]
    prio |= DEF_BIT_MASK(OS_CPU_CFG_SYSTICK_PRIO, 24);

    CPU_REG_NVIC_SHPRI3 = prio;

                                                            /* Enable timer.                                          */
    CPU_REG_NVIC_ST_CTRL |= CPU_REG_NVIC_ST_CTRL_CLKSOURCE |
 8004a3c:	4770      	bx	lr
 8004a3e:	bf00      	nop
 8004a40:	e000e014 	.word	0xe000e014
 8004a44:	e000ed20 	.word	0xe000ed20

08004a48 <OS_Dbg_Init>:
*                  DOES NOT optimize out the 'const' variables above.
************************************************************************************************************************
*/

void  OS_Dbg_Init (void)
{
 8004a48:	4770      	bx	lr
 8004a4a:	bf00      	nop

08004a4c <OSFlagCreate>:

void  OSFlagCreate (OS_FLAG_GRP  *p_grp,
                    CPU_CHAR     *p_name,
                    OS_FLAGS      flags,
                    OS_ERR       *p_err)
{
 8004a4c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
        return;
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from ISR ...                             */
 8004a50:	4c19      	ldr	r4, [pc, #100]	; (8004ab8 <OSFlagCreate+0x6c>)
 8004a52:	7826      	ldrb	r6, [r4, #0]
 8004a54:	bb2e      	cbnz	r6, 8004aa2 <OSFlagCreate+0x56>
        return;
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_grp == (OS_FLAG_GRP *)0) {                        /* Validate 'p_grp'                                       */
 8004a56:	b348      	cbz	r0, 8004aac <OSFlagCreate+0x60>
 8004a58:	4604      	mov	r4, r0
 8004a5a:	4690      	mov	r8, r2
 8004a5c:	460d      	mov	r5, r1
 8004a5e:	461f      	mov	r7, r3
       *p_err = OS_ERR_OBJ_PTR_NULL;
        return;
    }
#endif

    OS_CRITICAL_ENTER();
 8004a60:	f7fc fe88 	bl	8001774 <CPU_SR_Save>
    p_grp->Type    = OS_OBJ_TYPE_FLAG;                      /* Set to event flag group type                           */
 8004a64:	4b15      	ldr	r3, [pc, #84]	; (8004abc <OSFlagCreate+0x70>)
       *p_err = OS_ERR_OBJ_PTR_NULL;
        return;
    }
#endif

    OS_CRITICAL_ENTER();
 8004a66:	4681      	mov	r9, r0
    p_grp->Type    = OS_OBJ_TYPE_FLAG;                      /* Set to event flag group type                           */
 8004a68:	6023      	str	r3, [r4, #0]
    p_grp->NamePtr = p_name;
 8004a6a:	6065      	str	r5, [r4, #4]
    p_grp->Flags   = flags;                                 /* Set to desired initial value                           */
 8004a6c:	f8c4 8020 	str.w	r8, [r4, #32]
    p_grp->TS      = (CPU_TS)0;
 8004a70:	6266      	str	r6, [r4, #36]	; 0x24
    OS_PendListInit(&p_grp->PendList);
 8004a72:	f104 0008 	add.w	r0, r4, #8
 8004a76:	f7ff fa71 	bl	8003f5c <OS_PendListInit>
#if OS_CFG_DBG_EN > 0u
void  OS_FlagDbgListAdd (OS_FLAG_GRP  *p_grp)
{
    p_grp->DbgNamePtr                = (CPU_CHAR    *)((void *)" ");
    p_grp->DbgPrevPtr                = (OS_FLAG_GRP *)0;
    if (OSFlagDbgListPtr == (OS_FLAG_GRP *)0) {
 8004a7a:	4911      	ldr	r1, [pc, #68]	; (8004ac0 <OSFlagCreate+0x74>)
*/

#if OS_CFG_DBG_EN > 0u
void  OS_FlagDbgListAdd (OS_FLAG_GRP  *p_grp)
{
    p_grp->DbgNamePtr                = (CPU_CHAR    *)((void *)" ");
 8004a7c:	4a11      	ldr	r2, [pc, #68]	; (8004ac4 <OSFlagCreate+0x78>)
    p_grp->DbgPrevPtr                = (OS_FLAG_GRP *)0;
    if (OSFlagDbgListPtr == (OS_FLAG_GRP *)0) {
 8004a7e:	680b      	ldr	r3, [r1, #0]

#if OS_CFG_DBG_EN > 0u
void  OS_FlagDbgListAdd (OS_FLAG_GRP  *p_grp)
{
    p_grp->DbgNamePtr                = (CPU_CHAR    *)((void *)" ");
    p_grp->DbgPrevPtr                = (OS_FLAG_GRP *)0;
 8004a80:	6166      	str	r6, [r4, #20]
*/

#if OS_CFG_DBG_EN > 0u
void  OS_FlagDbgListAdd (OS_FLAG_GRP  *p_grp)
{
    p_grp->DbgNamePtr                = (CPU_CHAR    *)((void *)" ");
 8004a82:	61e2      	str	r2, [r4, #28]
    p_grp->DbgPrevPtr                = (OS_FLAG_GRP *)0;
    if (OSFlagDbgListPtr == (OS_FLAG_GRP *)0) {
        p_grp->DbgNextPtr            = (OS_FLAG_GRP *)0;
 8004a84:	61a3      	str	r3, [r4, #24]
#if OS_CFG_DBG_EN > 0u
void  OS_FlagDbgListAdd (OS_FLAG_GRP  *p_grp)
{
    p_grp->DbgNamePtr                = (CPU_CHAR    *)((void *)" ");
    p_grp->DbgPrevPtr                = (OS_FLAG_GRP *)0;
    if (OSFlagDbgListPtr == (OS_FLAG_GRP *)0) {
 8004a86:	b103      	cbz	r3, 8004a8a <OSFlagCreate+0x3e>
        p_grp->DbgNextPtr            = (OS_FLAG_GRP *)0;
    } else {
        p_grp->DbgNextPtr            =  OSFlagDbgListPtr;
        OSFlagDbgListPtr->DbgPrevPtr =  p_grp;
 8004a88:	615c      	str	r4, [r3, #20]
    OS_PendListInit(&p_grp->PendList);

#if OS_CFG_DBG_EN > 0u
    OS_FlagDbgListAdd(p_grp);
#endif
    OSFlagQty++;
 8004a8a:	4a0f      	ldr	r2, [pc, #60]	; (8004ac8 <OSFlagCreate+0x7c>)

    OS_CRITICAL_EXIT_NO_SCHED();
 8004a8c:	4648      	mov	r0, r9
    OS_PendListInit(&p_grp->PendList);

#if OS_CFG_DBG_EN > 0u
    OS_FlagDbgListAdd(p_grp);
#endif
    OSFlagQty++;
 8004a8e:	8813      	ldrh	r3, [r2, #0]
        p_grp->DbgNextPtr            = (OS_FLAG_GRP *)0;
    } else {
        p_grp->DbgNextPtr            =  OSFlagDbgListPtr;
        OSFlagDbgListPtr->DbgPrevPtr =  p_grp;
    }
    OSFlagDbgListPtr                 =  p_grp;
 8004a90:	600c      	str	r4, [r1, #0]
    OS_PendListInit(&p_grp->PendList);

#if OS_CFG_DBG_EN > 0u
    OS_FlagDbgListAdd(p_grp);
#endif
    OSFlagQty++;
 8004a92:	3301      	adds	r3, #1
 8004a94:	8013      	strh	r3, [r2, #0]

    OS_CRITICAL_EXIT_NO_SCHED();
 8004a96:	f7fc fe71 	bl	800177c <CPU_SR_Restore>
   *p_err = OS_ERR_NONE;
 8004a9a:	2300      	movs	r3, #0
 8004a9c:	803b      	strh	r3, [r7, #0]
 8004a9e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from ISR ...                             */
       *p_err = OS_ERR_CREATE_ISR;                          /* ... can't CREATE from an ISR                           */
 8004aa2:	f642 62e1 	movw	r2, #12001	; 0x2ee1
 8004aa6:	801a      	strh	r2, [r3, #0]
        return;
 8004aa8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_grp == (OS_FLAG_GRP *)0) {                        /* Validate 'p_grp'                                       */
       *p_err = OS_ERR_OBJ_PTR_NULL;
 8004aac:	f645 52c3 	movw	r2, #24003	; 0x5dc3
 8004ab0:	801a      	strh	r2, [r3, #0]
        return;
 8004ab2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8004ab6:	bf00      	nop
 8004ab8:	2000ed84 	.word	0x2000ed84
 8004abc:	47414c46 	.word	0x47414c46
 8004ac0:	2000ef50 	.word	0x2000ef50
 8004ac4:	080182f0 	.word	0x080182f0
 8004ac8:	2000ef4c 	.word	0x2000ef4c

08004acc <OSFlagPend>:
                      OS_FLAGS      flags,
                      OS_TICK       timeout,
                      OS_OPT        opt,
                      CPU_TS       *p_ts,
                      OS_ERR       *p_err)
{
 8004acc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        return ((OS_FLAGS)0);
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from ISR ...                             */
 8004ad0:	4ca5      	ldr	r4, [pc, #660]	; (8004d68 <OSFlagPend+0x29c>)
                      OS_FLAGS      flags,
                      OS_TICK       timeout,
                      OS_OPT        opt,
                      CPU_TS       *p_ts,
                      OS_ERR       *p_err)
{
 8004ad2:	b089      	sub	sp, #36	; 0x24
        return ((OS_FLAGS)0);
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from ISR ...                             */
 8004ad4:	7827      	ldrb	r7, [r4, #0]
 8004ad6:	bba7      	cbnz	r7, 8004b42 <OSFlagPend+0x76>
        return ((OS_FLAGS)0);
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_grp == (OS_FLAG_GRP *)0) {                        /* Validate 'p_grp'                                       */
 8004ad8:	2800      	cmp	r0, #0
 8004ada:	d07e      	beq.n	8004bda <OSFlagPend+0x10e>
       *p_err = OS_ERR_OBJ_PTR_NULL;
        return ((OS_FLAGS)0);
    }
    switch (opt) {                                          /* Validate 'opt'                                         */
 8004adc:	f5b3 7f84 	cmp.w	r3, #264	; 0x108
 8004ae0:	d00f      	beq.n	8004b02 <OSFlagPend+0x36>
 8004ae2:	d91a      	bls.n	8004b1a <OSFlagPend+0x4e>
 8004ae4:	f248 0508 	movw	r5, #32776	; 0x8008
 8004ae8:	42ab      	cmp	r3, r5
 8004aea:	d00a      	beq.n	8004b02 <OSFlagPend+0x36>
 8004aec:	d938      	bls.n	8004b60 <OSFlagPend+0x94>
 8004aee:	f248 1504 	movw	r5, #33028	; 0x8104
 8004af2:	42ab      	cmp	r3, r5
 8004af4:	d005      	beq.n	8004b02 <OSFlagPend+0x36>
 8004af6:	d875      	bhi.n	8004be4 <OSFlagPend+0x118>
 8004af8:	f5a3 4501 	sub.w	r5, r3, #33024	; 0x8100
 8004afc:	3d01      	subs	r5, #1
 8004afe:	2d01      	cmp	r5, #1
 8004b00:	d817      	bhi.n	8004b32 <OSFlagPend+0x66>
             return ((OS_OBJ_QTY)0);
    }
#endif

#if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    if (p_grp->Type != OS_OBJ_TYPE_FLAG) {                  /* Validate that we are pointing at an event flag         */
 8004b02:	4d9a      	ldr	r5, [pc, #616]	; (8004d6c <OSFlagPend+0x2a0>)
 8004b04:	6806      	ldr	r6, [r0, #0]
 8004b06:	42ae      	cmp	r6, r5
 8004b08:	d036      	beq.n	8004b78 <OSFlagPend+0xac>
       *p_err = OS_ERR_OBJ_TYPE;
 8004b0a:	f645 53c4 	movw	r3, #24004	; 0x5dc4
 8004b0e:	9a13      	ldr	r2, [sp, #76]	; 0x4c
        return ((OS_FLAGS)0);
 8004b10:	2000      	movs	r0, #0
    }
#endif

#if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    if (p_grp->Type != OS_OBJ_TYPE_FLAG) {                  /* Validate that we are pointing at an event flag         */
       *p_err = OS_ERR_OBJ_TYPE;
 8004b12:	8013      	strh	r3, [r2, #0]
        }
    }
    CPU_CRITICAL_EXIT();
   *p_err = OS_ERR_NONE;                                    /* Event(s) must have occurred                            */
    return (flags_rdy);
}
 8004b14:	b009      	add	sp, #36	; 0x24
 8004b16:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
#if OS_CFG_ARG_CHK_EN > 0u
    if (p_grp == (OS_FLAG_GRP *)0) {                        /* Validate 'p_grp'                                       */
       *p_err = OS_ERR_OBJ_PTR_NULL;
        return ((OS_FLAGS)0);
    }
    switch (opt) {                                          /* Validate 'opt'                                         */
 8004b1a:	2b08      	cmp	r3, #8
 8004b1c:	d0f1      	beq.n	8004b02 <OSFlagPend+0x36>
 8004b1e:	d918      	bls.n	8004b52 <OSFlagPend+0x86>
 8004b20:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8004b24:	d905      	bls.n	8004b32 <OSFlagPend+0x66>
 8004b26:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
 8004b2a:	d9ea      	bls.n	8004b02 <OSFlagPend+0x36>
 8004b2c:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
 8004b30:	d0e7      	beq.n	8004b02 <OSFlagPend+0x36>
             break;
#endif

        default:
             CPU_CRITICAL_EXIT();
            *p_err = OS_ERR_OPT_INVALID;
 8004b32:	f645 6325 	movw	r3, #24101	; 0x5e25
 8004b36:	9a13      	ldr	r2, [sp, #76]	; 0x4c
             return ((OS_FLAGS)0);
 8004b38:	2000      	movs	r0, #0
             break;
#endif

        default:
             CPU_CRITICAL_EXIT();
            *p_err = OS_ERR_OPT_INVALID;
 8004b3a:	8013      	strh	r3, [r2, #0]
        }
    }
    CPU_CRITICAL_EXIT();
   *p_err = OS_ERR_NONE;                                    /* Event(s) must have occurred                            */
    return (flags_rdy);
}
 8004b3c:	b009      	add	sp, #36	; 0x24
 8004b3e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from ISR ...                             */
       *p_err = OS_ERR_PEND_ISR;                            /* ... can't PEND from an ISR                             */
 8004b42:	f246 13ae 	movw	r3, #25006	; 0x61ae
 8004b46:	9a13      	ldr	r2, [sp, #76]	; 0x4c
        return ((OS_FLAGS)0);
 8004b48:	2000      	movs	r0, #0
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from ISR ...                             */
       *p_err = OS_ERR_PEND_ISR;                            /* ... can't PEND from an ISR                             */
 8004b4a:	8013      	strh	r3, [r2, #0]
        }
    }
    CPU_CRITICAL_EXIT();
   *p_err = OS_ERR_NONE;                                    /* Event(s) must have occurred                            */
    return (flags_rdy);
}
 8004b4c:	b009      	add	sp, #36	; 0x24
 8004b4e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
#if OS_CFG_ARG_CHK_EN > 0u
    if (p_grp == (OS_FLAG_GRP *)0) {                        /* Validate 'p_grp'                                       */
       *p_err = OS_ERR_OBJ_PTR_NULL;
        return ((OS_FLAGS)0);
    }
    switch (opt) {                                          /* Validate 'opt'                                         */
 8004b52:	2b00      	cmp	r3, #0
 8004b54:	d0ed      	beq.n	8004b32 <OSFlagPend+0x66>
 8004b56:	2b02      	cmp	r3, #2
 8004b58:	d9d3      	bls.n	8004b02 <OSFlagPend+0x36>
 8004b5a:	2b04      	cmp	r3, #4
 8004b5c:	d0d1      	beq.n	8004b02 <OSFlagPend+0x36>
 8004b5e:	e7e8      	b.n	8004b32 <OSFlagPend+0x66>
 8004b60:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8004b64:	d9e5      	bls.n	8004b32 <OSFlagPend+0x66>
 8004b66:	f248 0502 	movw	r5, #32770	; 0x8002
 8004b6a:	42ab      	cmp	r3, r5
 8004b6c:	d9c9      	bls.n	8004b02 <OSFlagPend+0x36>
 8004b6e:	f248 0504 	movw	r5, #32772	; 0x8004
 8004b72:	42ab      	cmp	r3, r5
 8004b74:	d0c5      	beq.n	8004b02 <OSFlagPend+0x36>
 8004b76:	e7dc      	b.n	8004b32 <OSFlagPend+0x66>
        consume = DEF_TRUE;
    } else {
        consume = DEF_FALSE;
    }

    if (p_ts != (CPU_TS *)0) {
 8004b78:	9c12      	ldr	r4, [sp, #72]	; 0x48
 8004b7a:	f403 7780 	and.w	r7, r3, #256	; 0x100
 8004b7e:	b2bf      	uxth	r7, r7
 8004b80:	b10c      	cbz	r4, 8004b86 <OSFlagPend+0xba>
       *p_ts = (CPU_TS)0;                                   /* Initialize the returned timestamp                      */
 8004b82:	2500      	movs	r5, #0
 8004b84:	6025      	str	r5, [r4, #0]
    }

    mode = opt & OS_OPT_PEND_FLAG_MASK;
 8004b86:	f003 080f 	and.w	r8, r3, #15
 8004b8a:	461c      	mov	r4, r3
 8004b8c:	4616      	mov	r6, r2
 8004b8e:	460d      	mov	r5, r1
 8004b90:	4681      	mov	r9, r0
    CPU_CRITICAL_ENTER();
 8004b92:	f7fc fdef 	bl	8001774 <CPU_SR_Save>
    switch (mode) {
 8004b96:	f1b8 0f04 	cmp.w	r8, #4
    if (p_ts != (CPU_TS *)0) {
       *p_ts = (CPU_TS)0;                                   /* Initialize the returned timestamp                      */
    }

    mode = opt & OS_OPT_PEND_FLAG_MASK;
    CPU_CRITICAL_ENTER();
 8004b9a:	4682      	mov	sl, r0
    switch (mode) {
 8004b9c:	d02a      	beq.n	8004bf4 <OSFlagPend+0x128>
 8004b9e:	f1b8 0f08 	cmp.w	r8, #8
 8004ba2:	d124      	bne.n	8004bee <OSFlagPend+0x122>
                 OS_CRITICAL_EXIT_NO_SCHED();
             }
             break;

        case OS_OPT_PEND_FLAG_SET_ANY:
             flags_rdy = (OS_FLAGS)(p_grp->Flags & flags);  /* Extract only the bits we want                          */
 8004ba4:	f8d9 3020 	ldr.w	r3, [r9, #32]
             if (flags_rdy != (OS_FLAGS)0) {                /* See if any flag set                                    */
 8004ba8:	ea15 0b03 	ands.w	fp, r5, r3
 8004bac:	f000 8090 	beq.w	8004cd0 <OSFlagPend+0x204>
                 if (consume == DEF_TRUE) {                 /* See if we need to consume the flags                    */
 8004bb0:	2f00      	cmp	r7, #0
 8004bb2:	f040 80b0 	bne.w	8004d16 <OSFlagPend+0x24a>
                     p_grp->Flags &= ~flags_rdy;            /* Clear ONLY the flags that we got                       */
                 }
                 OSTCBCurPtr->FlagsRdy = flags_rdy;         /* Save flags that were ready                             */
 8004bb6:	4b6e      	ldr	r3, [pc, #440]	; (8004d70 <OSFlagPend+0x2a4>)
 8004bb8:	681b      	ldr	r3, [r3, #0]
 8004bba:	f8c3 b084 	str.w	fp, [r3, #132]	; 0x84
                 if (p_ts != (CPU_TS *)0) {
 8004bbe:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8004bc0:	b11b      	cbz	r3, 8004bca <OSFlagPend+0xfe>
                    *p_ts  = p_grp->TS;
 8004bc2:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
 8004bc6:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8004bc8:	6013      	str	r3, [r2, #0]
                 }
                 CPU_CRITICAL_EXIT();                       /* Yes, condition met, return to caller                   */
 8004bca:	4650      	mov	r0, sl
 8004bcc:	f7fc fdd6 	bl	800177c <CPU_SR_Restore>
                *p_err = OS_ERR_NONE;
 8004bd0:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8004bd2:	2300      	movs	r3, #0
                 return (flags_rdy);
 8004bd4:	4658      	mov	r0, fp
                 OSTCBCurPtr->FlagsRdy = flags_rdy;         /* Save flags that were ready                             */
                 if (p_ts != (CPU_TS *)0) {
                    *p_ts  = p_grp->TS;
                 }
                 CPU_CRITICAL_EXIT();                       /* Yes, condition met, return to caller                   */
                *p_err = OS_ERR_NONE;
 8004bd6:	8013      	strh	r3, [r2, #0]
                 return (flags_rdy);
 8004bd8:	e7b8      	b.n	8004b4c <OSFlagPend+0x80>
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_grp == (OS_FLAG_GRP *)0) {                        /* Validate 'p_grp'                                       */
       *p_err = OS_ERR_OBJ_PTR_NULL;
 8004bda:	f645 53c3 	movw	r3, #24003	; 0x5dc3
 8004bde:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8004be0:	8013      	strh	r3, [r2, #0]
        return ((OS_FLAGS)0);
 8004be2:	e7b3      	b.n	8004b4c <OSFlagPend+0x80>
    }
    switch (opt) {                                          /* Validate 'opt'                                         */
 8004be4:	f248 1508 	movw	r5, #33032	; 0x8108
 8004be8:	42ab      	cmp	r3, r5
 8004bea:	d08a      	beq.n	8004b02 <OSFlagPend+0x36>
 8004bec:	e7a1      	b.n	8004b32 <OSFlagPend+0x66>
             }
             break;
#endif

        default:
             CPU_CRITICAL_EXIT();
 8004bee:	f7fc fdc5 	bl	800177c <CPU_SR_Restore>
 8004bf2:	e79e      	b.n	8004b32 <OSFlagPend+0x66>

    mode = opt & OS_OPT_PEND_FLAG_MASK;
    CPU_CRITICAL_ENTER();
    switch (mode) {
        case OS_OPT_PEND_FLAG_SET_ALL:                      /* See if all required flags are set                      */
             flags_rdy = (OS_FLAGS)(p_grp->Flags & flags);  /* Extract only the bits we want                          */
 8004bf4:	f8d9 3020 	ldr.w	r3, [r9, #32]
             if (flags_rdy == flags) {                      /* Must match ALL the bits that we want                   */
 8004bf8:	ea35 0203 	bics.w	r2, r5, r3
 8004bfc:	d076      	beq.n	8004cec <OSFlagPend+0x220>
                 }
                 CPU_CRITICAL_EXIT();                       /* Yes, condition met, return to caller                   */
                *p_err = OS_ERR_NONE;
                 return (flags_rdy);
             } else {                                       /* Block task until events occur or timeout               */
                 if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {
 8004bfe:	0422      	lsls	r2, r4, #16
 8004c00:	f100 809a 	bmi.w	8004d38 <OSFlagPend+0x26c>
                     CPU_CRITICAL_EXIT();
                    *p_err = OS_ERR_PEND_WOULD_BLOCK;       /* Specified non-blocking so task would block             */
                     return ((OS_FLAGS)0);
                 } else {                                   /* Specified blocking so check is scheduler is locked     */
                     if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) { /* See if called with scheduler locked ...      */
 8004c04:	4b5b      	ldr	r3, [pc, #364]	; (8004d74 <OSFlagPend+0x2a8>)
 8004c06:	7819      	ldrb	r1, [r3, #0]
 8004c08:	2900      	cmp	r1, #0
 8004c0a:	d17c      	bne.n	8004d06 <OSFlagPend+0x23a>
                    OS_FLAG_GRP   *p_grp,
                    OS_FLAGS       flags,
                    OS_OPT         opt,
                    OS_TICK        timeout)
{
    OSTCBCurPtr->FlagsPend = flags;                         /* Save the flags that we need to wait for                */
 8004c0c:	f8df b160 	ldr.w	fp, [pc, #352]	; 8004d70 <OSFlagPend+0x2a4>
    OSTCBCurPtr->FlagsOpt  = opt;                           /* Save the type of wait we are doing                     */
    OSTCBCurPtr->FlagsRdy  = (OS_FLAGS)0;

    OS_Pend(p_pend_data,
 8004c10:	4633      	mov	r3, r6
                    OS_FLAG_GRP   *p_grp,
                    OS_FLAGS       flags,
                    OS_OPT         opt,
                    OS_TICK        timeout)
{
    OSTCBCurPtr->FlagsPend = flags;                         /* Save the flags that we need to wait for                */
 8004c12:	f8db 0000 	ldr.w	r0, [fp]
    OSTCBCurPtr->FlagsOpt  = opt;                           /* Save the type of wait we are doing                     */
    OSTCBCurPtr->FlagsRdy  = (OS_FLAGS)0;

    OS_Pend(p_pend_data,
 8004c16:	2201      	movs	r2, #1
                    OS_OPT         opt,
                    OS_TICK        timeout)
{
    OSTCBCurPtr->FlagsPend = flags;                         /* Save the flags that we need to wait for                */
    OSTCBCurPtr->FlagsOpt  = opt;                           /* Save the type of wait we are doing                     */
    OSTCBCurPtr->FlagsRdy  = (OS_FLAGS)0;
 8004c18:	f8c0 1084 	str.w	r1, [r0, #132]	; 0x84
                    OS_FLAG_GRP   *p_grp,
                    OS_FLAGS       flags,
                    OS_OPT         opt,
                    OS_TICK        timeout)
{
    OSTCBCurPtr->FlagsPend = flags;                         /* Save the flags that we need to wait for                */
 8004c1c:	f8c0 5080 	str.w	r5, [r0, #128]	; 0x80
    OSTCBCurPtr->FlagsOpt  = opt;                           /* Save the type of wait we are doing                     */
    OSTCBCurPtr->FlagsRdy  = (OS_FLAGS)0;

    OS_Pend(p_pend_data,
 8004c20:	4649      	mov	r1, r9
                    OS_FLAGS       flags,
                    OS_OPT         opt,
                    OS_TICK        timeout)
{
    OSTCBCurPtr->FlagsPend = flags;                         /* Save the flags that we need to wait for                */
    OSTCBCurPtr->FlagsOpt  = opt;                           /* Save the type of wait we are doing                     */
 8004c22:	f8a0 4088 	strh.w	r4, [r0, #136]	; 0x88
    OSTCBCurPtr->FlagsRdy  = (OS_FLAGS)0;

    OS_Pend(p_pend_data,
 8004c26:	4668      	mov	r0, sp
 8004c28:	f7ff fc2e 	bl	8004488 <OS_Pend>
                 OS_FlagBlock(&pend_data,
                              p_grp,
                              flags,
                              opt,
                              timeout);
                 OS_CRITICAL_EXIT_NO_SCHED();
 8004c2c:	4650      	mov	r0, sl
 8004c2e:	f7fc fda5 	bl	800177c <CPU_SR_Restore>
             CPU_CRITICAL_EXIT();
            *p_err = OS_ERR_OPT_INVALID;
             return ((OS_FLAGS)0);
    }

    OSSched();                                              /* Find next HPT ready to run                             */
 8004c32:	f7fe ff79 	bl	8003b28 <OSSched>

    CPU_CRITICAL_ENTER();
 8004c36:	f7fc fd9d 	bl	8001774 <CPU_SR_Save>
    switch (OSTCBCurPtr->PendStatus) {
 8004c3a:	f8db 3000 	ldr.w	r3, [fp]
 8004c3e:	f893 2035 	ldrb.w	r2, [r3, #53]	; 0x35
 8004c42:	2a03      	cmp	r2, #3
 8004c44:	d86c      	bhi.n	8004d20 <OSFlagPend+0x254>
 8004c46:	e8df f002 	tbb	[pc, r2]
 8004c4a:	1a25      	.short	0x1a25
 8004c4c:	020f      	.short	0x020f
             CPU_CRITICAL_EXIT();
            *p_err = OS_ERR_PEND_ABORT;
             break;

        case OS_STATUS_PEND_TIMEOUT:                        /* Indicate that we didn't get semaphore within timeout   */
             if (p_ts != (CPU_TS *)0) {
 8004c4e:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8004c50:	b113      	cbz	r3, 8004c58 <OSFlagPend+0x18c>
                *p_ts  = (CPU_TS  )0;
 8004c52:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8004c54:	2300      	movs	r3, #0
 8004c56:	6013      	str	r3, [r2, #0]
             }
             CPU_CRITICAL_EXIT();
 8004c58:	f7fc fd90 	bl	800177c <CPU_SR_Restore>
            *p_err = OS_ERR_TIMEOUT;
 8004c5c:	f247 23d9 	movw	r3, #29401	; 0x72d9
 8004c60:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8004c62:	8013      	strh	r3, [r2, #0]
             CPU_CRITICAL_EXIT();
            *p_err = OS_ERR_STATUS_INVALID;
             break;
    }
    if (*p_err != OS_ERR_NONE) {
        return ((OS_FLAGS)0);
 8004c64:	2000      	movs	r0, #0
 8004c66:	e771      	b.n	8004b4c <OSFlagPend+0x80>
             CPU_CRITICAL_EXIT();
            *p_err = OS_ERR_TIMEOUT;
             break;

        case OS_STATUS_PEND_DEL:                            /* Indicate that object pended on has been deleted        */
             if (p_ts != (CPU_TS *)0) {
 8004c68:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8004c6a:	b10a      	cbz	r2, 8004c70 <OSFlagPend+0x1a4>
                *p_ts  = OSTCBCurPtr->TS;
 8004c6c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004c6e:	6013      	str	r3, [r2, #0]
             }
             CPU_CRITICAL_EXIT();
 8004c70:	f7fc fd84 	bl	800177c <CPU_SR_Restore>
            *p_err = OS_ERR_OBJ_DEL;
 8004c74:	f645 53c2 	movw	r3, #24002	; 0x5dc2
 8004c78:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8004c7a:	8013      	strh	r3, [r2, #0]
             break;
 8004c7c:	e7f2      	b.n	8004c64 <OSFlagPend+0x198>
             }
            *p_err = OS_ERR_NONE;
             break;

        case OS_STATUS_PEND_ABORT:                          /* Indicate that we aborted                               */
             if (p_ts != (CPU_TS *)0) {
 8004c7e:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8004c80:	b10a      	cbz	r2, 8004c86 <OSFlagPend+0x1ba>
                *p_ts  = OSTCBCurPtr->TS;
 8004c82:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004c84:	6013      	str	r3, [r2, #0]
             }
             CPU_CRITICAL_EXIT();
 8004c86:	f7fc fd79 	bl	800177c <CPU_SR_Restore>
            *p_err = OS_ERR_PEND_ABORT;
 8004c8a:	f246 13a9 	movw	r3, #25001	; 0x61a9
 8004c8e:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8004c90:	8013      	strh	r3, [r2, #0]
             break;
 8004c92:	e7e7      	b.n	8004c64 <OSFlagPend+0x198>
    OSSched();                                              /* Find next HPT ready to run                             */

    CPU_CRITICAL_ENTER();
    switch (OSTCBCurPtr->PendStatus) {
        case OS_STATUS_PEND_OK:                             /* We got the vent flags                                  */
             if (p_ts != (CPU_TS *)0) {
 8004c94:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8004c96:	b112      	cbz	r2, 8004c9e <OSFlagPend+0x1d2>
                *p_ts  = OSTCBCurPtr->TS;
 8004c98:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8004c9a:	9912      	ldr	r1, [sp, #72]	; 0x48
 8004c9c:	600a      	str	r2, [r1, #0]
    }
    if (*p_err != OS_ERR_NONE) {
        return ((OS_FLAGS)0);
    }

    flags_rdy = OSTCBCurPtr->FlagsRdy;
 8004c9e:	f8d3 5084 	ldr.w	r5, [r3, #132]	; 0x84
    switch (OSTCBCurPtr->PendStatus) {
        case OS_STATUS_PEND_OK:                             /* We got the vent flags                                  */
             if (p_ts != (CPU_TS *)0) {
                *p_ts  = OSTCBCurPtr->TS;
             }
            *p_err = OS_ERR_NONE;
 8004ca2:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 8004ca4:	2600      	movs	r6, #0
 8004ca6:	801e      	strh	r6, [r3, #0]
    if (*p_err != OS_ERR_NONE) {
        return ((OS_FLAGS)0);
    }

    flags_rdy = OSTCBCurPtr->FlagsRdy;
    if (consume == DEF_TRUE) {                              /* See if we need to consume the flags                    */
 8004ca8:	b15f      	cbz	r7, 8004cc2 <OSFlagPend+0x1f6>
        switch (mode) {
 8004caa:	f1b8 0f04 	cmp.w	r8, #4
 8004cae:	d002      	beq.n	8004cb6 <OSFlagPend+0x1ea>
 8004cb0:	f1b8 0f08 	cmp.w	r8, #8
 8004cb4:	d150      	bne.n	8004d58 <OSFlagPend+0x28c>
            case OS_OPT_PEND_FLAG_SET_ALL:
            case OS_OPT_PEND_FLAG_SET_ANY:                  /* Clear ONLY the flags we got                            */
                 p_grp->Flags &= ~flags_rdy;
 8004cb6:	f8d9 3020 	ldr.w	r3, [r9, #32]
 8004cba:	ea23 0305 	bic.w	r3, r3, r5
 8004cbe:	f8c9 3020 	str.w	r3, [r9, #32]
                 CPU_CRITICAL_EXIT();
                *p_err = OS_ERR_OPT_INVALID;
                 return ((OS_FLAGS)0);
        }
    }
    CPU_CRITICAL_EXIT();
 8004cc2:	f7fc fd5b 	bl	800177c <CPU_SR_Restore>
   *p_err = OS_ERR_NONE;                                    /* Event(s) must have occurred                            */
 8004cc6:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8004cc8:	2300      	movs	r3, #0
    return (flags_rdy);
 8004cca:	4628      	mov	r0, r5
                *p_err = OS_ERR_OPT_INVALID;
                 return ((OS_FLAGS)0);
        }
    }
    CPU_CRITICAL_EXIT();
   *p_err = OS_ERR_NONE;                                    /* Event(s) must have occurred                            */
 8004ccc:	8013      	strh	r3, [r2, #0]
    return (flags_rdy);
 8004cce:	e73d      	b.n	8004b4c <OSFlagPend+0x80>
                 }
                 CPU_CRITICAL_EXIT();                       /* Yes, condition met, return to caller                   */
                *p_err = OS_ERR_NONE;
                 return (flags_rdy);
             } else {                                       /* Block task until events occur or timeout               */
                 if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {
 8004cd0:	0423      	lsls	r3, r4, #16
 8004cd2:	d439      	bmi.n	8004d48 <OSFlagPend+0x27c>
                     CPU_CRITICAL_EXIT();
                    *p_err = OS_ERR_PEND_WOULD_BLOCK;       /* Specified non-blocking so task would block             */
                     return ((OS_FLAGS)0);
                 } else {                                   /* Specified blocking so check is scheduler is locked     */
                     if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) { /* See if called with scheduler locked ...      */
 8004cd4:	4b27      	ldr	r3, [pc, #156]	; (8004d74 <OSFlagPend+0x2a8>)
 8004cd6:	7819      	ldrb	r1, [r3, #0]
 8004cd8:	2900      	cmp	r1, #0
 8004cda:	d097      	beq.n	8004c0c <OSFlagPend+0x140>
                         CPU_CRITICAL_EXIT();
 8004cdc:	f7fc fd4e 	bl	800177c <CPU_SR_Restore>
                        *p_err = OS_ERR_SCHED_LOCKED;                 /* ... can't PEND when locked                   */
 8004ce0:	f646 5363 	movw	r3, #28003	; 0x6d63
 8004ce4:	9a13      	ldr	r2, [sp, #76]	; 0x4c
                         return ((OS_FLAGS)0);
 8004ce6:	4658      	mov	r0, fp
                    *p_err = OS_ERR_PEND_WOULD_BLOCK;       /* Specified non-blocking so task would block             */
                     return ((OS_FLAGS)0);
                 } else {                                   /* Specified blocking so check is scheduler is locked     */
                     if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) { /* See if called with scheduler locked ...      */
                         CPU_CRITICAL_EXIT();
                        *p_err = OS_ERR_SCHED_LOCKED;                 /* ... can't PEND when locked                   */
 8004ce8:	8013      	strh	r3, [r2, #0]
                         return ((OS_FLAGS)0);
 8004cea:	e72f      	b.n	8004b4c <OSFlagPend+0x80>
    CPU_CRITICAL_ENTER();
    switch (mode) {
        case OS_OPT_PEND_FLAG_SET_ALL:                      /* See if all required flags are set                      */
             flags_rdy = (OS_FLAGS)(p_grp->Flags & flags);  /* Extract only the bits we want                          */
             if (flags_rdy == flags) {                      /* Must match ALL the bits that we want                   */
                 if (consume == DEF_TRUE) {                 /* See if we need to consume the flags                    */
 8004cec:	b9ff      	cbnz	r7, 8004d2e <OSFlagPend+0x262>
                     p_grp->Flags &= ~flags_rdy;            /* Clear ONLY the flags that we wanted                    */
                 }
                 OSTCBCurPtr->FlagsRdy = flags_rdy;         /* Save flags that were ready                             */
 8004cee:	4b20      	ldr	r3, [pc, #128]	; (8004d70 <OSFlagPend+0x2a4>)
 8004cf0:	681b      	ldr	r3, [r3, #0]
 8004cf2:	f8c3 5084 	str.w	r5, [r3, #132]	; 0x84
                 if (p_ts != (CPU_TS *)0) {
 8004cf6:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8004cf8:	b11b      	cbz	r3, 8004d02 <OSFlagPend+0x236>
                    *p_ts  = p_grp->TS;
 8004cfa:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
 8004cfe:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8004d00:	6013      	str	r3, [r2, #0]
                 }
                 CPU_CRITICAL_EXIT();                       /* Yes, condition met, return to caller                   */
 8004d02:	4650      	mov	r0, sl
 8004d04:	e7dd      	b.n	8004cc2 <OSFlagPend+0x1f6>
                     CPU_CRITICAL_EXIT();
                    *p_err = OS_ERR_PEND_WOULD_BLOCK;       /* Specified non-blocking so task would block             */
                     return ((OS_FLAGS)0);
                 } else {                                   /* Specified blocking so check is scheduler is locked     */
                     if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) { /* See if called with scheduler locked ...      */
                         CPU_CRITICAL_EXIT();
 8004d06:	f7fc fd39 	bl	800177c <CPU_SR_Restore>
                        *p_err = OS_ERR_SCHED_LOCKED;                 /* ... can't PEND when locked                   */
 8004d0a:	f646 5363 	movw	r3, #28003	; 0x6d63
 8004d0e:	9a13      	ldr	r2, [sp, #76]	; 0x4c
                         return ((OS_FLAGS)0);
 8004d10:	2000      	movs	r0, #0
                    *p_err = OS_ERR_PEND_WOULD_BLOCK;       /* Specified non-blocking so task would block             */
                     return ((OS_FLAGS)0);
                 } else {                                   /* Specified blocking so check is scheduler is locked     */
                     if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) { /* See if called with scheduler locked ...      */
                         CPU_CRITICAL_EXIT();
                        *p_err = OS_ERR_SCHED_LOCKED;                 /* ... can't PEND when locked                   */
 8004d12:	8013      	strh	r3, [r2, #0]
                         return ((OS_FLAGS)0);
 8004d14:	e71a      	b.n	8004b4c <OSFlagPend+0x80>

        case OS_OPT_PEND_FLAG_SET_ANY:
             flags_rdy = (OS_FLAGS)(p_grp->Flags & flags);  /* Extract only the bits we want                          */
             if (flags_rdy != (OS_FLAGS)0) {                /* See if any flag set                                    */
                 if (consume == DEF_TRUE) {                 /* See if we need to consume the flags                    */
                     p_grp->Flags &= ~flags_rdy;            /* Clear ONLY the flags that we got                       */
 8004d16:	ea23 030b 	bic.w	r3, r3, fp
 8004d1a:	f8c9 3020 	str.w	r3, [r9, #32]
 8004d1e:	e74a      	b.n	8004bb6 <OSFlagPend+0xea>
             CPU_CRITICAL_EXIT();
            *p_err = OS_ERR_OBJ_DEL;
             break;

        default:
             CPU_CRITICAL_EXIT();
 8004d20:	f7fc fd2c 	bl	800177c <CPU_SR_Restore>
            *p_err = OS_ERR_STATUS_INVALID;
 8004d24:	f646 632e 	movw	r3, #28206	; 0x6e2e
 8004d28:	9a13      	ldr	r2, [sp, #76]	; 0x4c
 8004d2a:	8013      	strh	r3, [r2, #0]
             break;
 8004d2c:	e79a      	b.n	8004c64 <OSFlagPend+0x198>
    switch (mode) {
        case OS_OPT_PEND_FLAG_SET_ALL:                      /* See if all required flags are set                      */
             flags_rdy = (OS_FLAGS)(p_grp->Flags & flags);  /* Extract only the bits we want                          */
             if (flags_rdy == flags) {                      /* Must match ALL the bits that we want                   */
                 if (consume == DEF_TRUE) {                 /* See if we need to consume the flags                    */
                     p_grp->Flags &= ~flags_rdy;            /* Clear ONLY the flags that we wanted                    */
 8004d2e:	ea23 0305 	bic.w	r3, r3, r5
 8004d32:	f8c9 3020 	str.w	r3, [r9, #32]
 8004d36:	e7da      	b.n	8004cee <OSFlagPend+0x222>
                 CPU_CRITICAL_EXIT();                       /* Yes, condition met, return to caller                   */
                *p_err = OS_ERR_NONE;
                 return (flags_rdy);
             } else {                                       /* Block task until events occur or timeout               */
                 if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {
                     CPU_CRITICAL_EXIT();
 8004d38:	f7fc fd20 	bl	800177c <CPU_SR_Restore>
                    *p_err = OS_ERR_PEND_WOULD_BLOCK;       /* Specified non-blocking so task would block             */
 8004d3c:	f246 13b0 	movw	r3, #25008	; 0x61b0
 8004d40:	9a13      	ldr	r2, [sp, #76]	; 0x4c
                     return ((OS_FLAGS)0);
 8004d42:	2000      	movs	r0, #0
                *p_err = OS_ERR_NONE;
                 return (flags_rdy);
             } else {                                       /* Block task until events occur or timeout               */
                 if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {
                     CPU_CRITICAL_EXIT();
                    *p_err = OS_ERR_PEND_WOULD_BLOCK;       /* Specified non-blocking so task would block             */
 8004d44:	8013      	strh	r3, [r2, #0]
                     return ((OS_FLAGS)0);
 8004d46:	e701      	b.n	8004b4c <OSFlagPend+0x80>
                 CPU_CRITICAL_EXIT();                       /* Yes, condition met, return to caller                   */
                *p_err = OS_ERR_NONE;
                 return (flags_rdy);
             } else {                                       /* Block task until events occur or timeout               */
                 if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {
                     CPU_CRITICAL_EXIT();
 8004d48:	f7fc fd18 	bl	800177c <CPU_SR_Restore>
                    *p_err = OS_ERR_PEND_WOULD_BLOCK;       /* Specified non-blocking so task would block             */
 8004d4c:	f246 13b0 	movw	r3, #25008	; 0x61b0
 8004d50:	9a13      	ldr	r2, [sp, #76]	; 0x4c
                     return ((OS_FLAGS)0);
 8004d52:	4658      	mov	r0, fp
                *p_err = OS_ERR_NONE;
                 return (flags_rdy);
             } else {                                       /* Block task until events occur or timeout               */
                 if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {
                     CPU_CRITICAL_EXIT();
                    *p_err = OS_ERR_PEND_WOULD_BLOCK;       /* Specified non-blocking so task would block             */
 8004d54:	8013      	strh	r3, [r2, #0]
                     return ((OS_FLAGS)0);
 8004d56:	e6f9      	b.n	8004b4c <OSFlagPend+0x80>
            case OS_OPT_PEND_FLAG_CLR_ANY:                  /* Set   ONLY the flags we got                            */
                 p_grp->Flags |=  flags_rdy;
                 break;
#endif
            default:
                 CPU_CRITICAL_EXIT();
 8004d58:	f7fc fd10 	bl	800177c <CPU_SR_Restore>
                *p_err = OS_ERR_OPT_INVALID;
 8004d5c:	f645 6325 	movw	r3, #24101	; 0x5e25
 8004d60:	9a13      	ldr	r2, [sp, #76]	; 0x4c
                 return ((OS_FLAGS)0);
 8004d62:	4630      	mov	r0, r6
                 p_grp->Flags |=  flags_rdy;
                 break;
#endif
            default:
                 CPU_CRITICAL_EXIT();
                *p_err = OS_ERR_OPT_INVALID;
 8004d64:	8013      	strh	r3, [r2, #0]
                 return ((OS_FLAGS)0);
 8004d66:	e6f1      	b.n	8004b4c <OSFlagPend+0x80>
 8004d68:	2000ed84 	.word	0x2000ed84
 8004d6c:	47414c46 	.word	0x47414c46
 8004d70:	2000ed58 	.word	0x2000ed58
 8004d74:	2000e974 	.word	0x2000e974

08004d78 <OSFlagPendGetFlagsRdy>:
* Returns    : The flags that caused the task to be ready.
************************************************************************************************************************
*/

OS_FLAGS  OSFlagPendGetFlagsRdy (OS_ERR  *p_err)
{
 8004d78:	b570      	push	{r4, r5, r6, lr}
        return ((OS_FLAGS)0);
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from ISR ...                             */
 8004d7a:	4b0b      	ldr	r3, [pc, #44]	; (8004da8 <OSFlagPendGetFlagsRdy+0x30>)
 8004d7c:	781e      	ldrb	r6, [r3, #0]
 8004d7e:	b12e      	cbz	r6, 8004d8c <OSFlagPendGetFlagsRdy+0x14>
       *p_err = OS_ERR_PEND_ISR;                            /* ... can't get from an ISR                              */
 8004d80:	f246 12ae 	movw	r2, #25006	; 0x61ae
        return ((OS_FLAGS)0);
 8004d84:	2300      	movs	r3, #0
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from ISR ...                             */
       *p_err = OS_ERR_PEND_ISR;                            /* ... can't get from an ISR                              */
 8004d86:	8002      	strh	r2, [r0, #0]
    CPU_CRITICAL_ENTER();
    flags = OSTCBCurPtr->FlagsRdy;
    CPU_CRITICAL_EXIT();
   *p_err = OS_ERR_NONE;
    return (flags);
}
 8004d88:	4618      	mov	r0, r3
 8004d8a:	bd70      	pop	{r4, r5, r6, pc}
 8004d8c:	4605      	mov	r5, r0
       *p_err = OS_ERR_PEND_ISR;                            /* ... can't get from an ISR                              */
        return ((OS_FLAGS)0);
    }
#endif

    CPU_CRITICAL_ENTER();
 8004d8e:	f7fc fcf1 	bl	8001774 <CPU_SR_Save>
    flags = OSTCBCurPtr->FlagsRdy;
 8004d92:	4b06      	ldr	r3, [pc, #24]	; (8004dac <OSFlagPendGetFlagsRdy+0x34>)
 8004d94:	681b      	ldr	r3, [r3, #0]
 8004d96:	f8d3 4084 	ldr.w	r4, [r3, #132]	; 0x84
    CPU_CRITICAL_EXIT();
 8004d9a:	f7fc fcef 	bl	800177c <CPU_SR_Restore>
   *p_err = OS_ERR_NONE;
    return (flags);
 8004d9e:	4623      	mov	r3, r4
#endif

    CPU_CRITICAL_ENTER();
    flags = OSTCBCurPtr->FlagsRdy;
    CPU_CRITICAL_EXIT();
   *p_err = OS_ERR_NONE;
 8004da0:	802e      	strh	r6, [r5, #0]
    return (flags);
}
 8004da2:	4618      	mov	r0, r3
 8004da4:	bd70      	pop	{r4, r5, r6, pc}
 8004da6:	bf00      	nop
 8004da8:	2000ed84 	.word	0x2000ed84
 8004dac:	2000ed58 	.word	0x2000ed58

08004db0 <OS_FlagBlock>:
void  OS_FlagBlock (OS_PEND_DATA  *p_pend_data,
                    OS_FLAG_GRP   *p_grp,
                    OS_FLAGS       flags,
                    OS_OPT         opt,
                    OS_TICK        timeout)
{
 8004db0:	b470      	push	{r4, r5, r6}
    OSTCBCurPtr->FlagsPend = flags;                         /* Save the flags that we need to wait for                */
 8004db2:	4c07      	ldr	r4, [pc, #28]	; (8004dd0 <OS_FlagBlock+0x20>)
void  OS_FlagBlock (OS_PEND_DATA  *p_pend_data,
                    OS_FLAG_GRP   *p_grp,
                    OS_FLAGS       flags,
                    OS_OPT         opt,
                    OS_TICK        timeout)
{
 8004db4:	9d03      	ldr	r5, [sp, #12]
    OSTCBCurPtr->FlagsPend = flags;                         /* Save the flags that we need to wait for                */
 8004db6:	6824      	ldr	r4, [r4, #0]
    OSTCBCurPtr->FlagsOpt  = opt;                           /* Save the type of wait we are doing                     */
    OSTCBCurPtr->FlagsRdy  = (OS_FLAGS)0;
 8004db8:	2600      	movs	r6, #0
                    OS_FLAG_GRP   *p_grp,
                    OS_FLAGS       flags,
                    OS_OPT         opt,
                    OS_TICK        timeout)
{
    OSTCBCurPtr->FlagsPend = flags;                         /* Save the flags that we need to wait for                */
 8004dba:	f8c4 2080 	str.w	r2, [r4, #128]	; 0x80
    OSTCBCurPtr->FlagsOpt  = opt;                           /* Save the type of wait we are doing                     */
 8004dbe:	f8a4 3088 	strh.w	r3, [r4, #136]	; 0x88
    OSTCBCurPtr->FlagsRdy  = (OS_FLAGS)0;
 8004dc2:	f8c4 6084 	str.w	r6, [r4, #132]	; 0x84

    OS_Pend(p_pend_data,
 8004dc6:	462b      	mov	r3, r5
            (OS_PEND_OBJ *)((void *)p_grp),
             OS_TASK_PEND_ON_FLAG,
             timeout);
}
 8004dc8:	bc70      	pop	{r4, r5, r6}
{
    OSTCBCurPtr->FlagsPend = flags;                         /* Save the flags that we need to wait for                */
    OSTCBCurPtr->FlagsOpt  = opt;                           /* Save the type of wait we are doing                     */
    OSTCBCurPtr->FlagsRdy  = (OS_FLAGS)0;

    OS_Pend(p_pend_data,
 8004dca:	2201      	movs	r2, #1
 8004dcc:	f7ff bb5c 	b.w	8004488 <OS_Pend>
 8004dd0:	2000ed58 	.word	0x2000ed58

08004dd4 <OS_FlagClr>:
{
    OS_PEND_LIST  *p_pend_list;



    p_grp->Type             = OS_OBJ_TYPE_NONE;
 8004dd4:	4904      	ldr	r1, [pc, #16]	; (8004de8 <OS_FlagClr+0x14>)
    p_grp->NamePtr          = (CPU_CHAR *)((void *)"?FLAG");    /* Unknown name                                       */
 8004dd6:	4a05      	ldr	r2, [pc, #20]	; (8004dec <OS_FlagClr+0x18>)
    p_grp->Flags            = (OS_FLAGS )0;
 8004dd8:	2300      	movs	r3, #0
    OS_PEND_LIST  *p_pend_list;



    p_grp->Type             = OS_OBJ_TYPE_NONE;
    p_grp->NamePtr          = (CPU_CHAR *)((void *)"?FLAG");    /* Unknown name                                       */
 8004dda:	e880 0006 	stmia.w	r0, {r1, r2}
    p_grp->Flags            = (OS_FLAGS )0;
 8004dde:	6203      	str	r3, [r0, #32]
    p_pend_list             = &p_grp->PendList;
    OS_PendListInit(p_pend_list);
 8004de0:	3008      	adds	r0, #8
 8004de2:	f7ff b8bb 	b.w	8003f5c <OS_PendListInit>
 8004de6:	bf00      	nop
 8004de8:	454e4f4e 	.word	0x454e4f4e
 8004dec:	0801665c 	.word	0x0801665c

08004df0 <OS_FlagInit>:
        return;
    }
#endif

#if OS_CFG_DBG_EN > 0u
    OSFlagDbgListPtr = (OS_FLAG_GRP *)0;
 8004df0:	4903      	ldr	r1, [pc, #12]	; (8004e00 <OS_FlagInit+0x10>)
#endif

    OSFlagQty        = (OS_OBJ_QTY   )0;
 8004df2:	4a04      	ldr	r2, [pc, #16]	; (8004e04 <OS_FlagInit+0x14>)
        return;
    }
#endif

#if OS_CFG_DBG_EN > 0u
    OSFlagDbgListPtr = (OS_FLAG_GRP *)0;
 8004df4:	2300      	movs	r3, #0
 8004df6:	600b      	str	r3, [r1, #0]
#endif

    OSFlagQty        = (OS_OBJ_QTY   )0;
 8004df8:	8013      	strh	r3, [r2, #0]
   *p_err            = OS_ERR_NONE;
 8004dfa:	8003      	strh	r3, [r0, #0]
 8004dfc:	4770      	bx	lr
 8004dfe:	bf00      	nop
 8004e00:	2000ef50 	.word	0x2000ef50
 8004e04:	2000ef4c 	.word	0x2000ef4c

08004e08 <OS_FlagDbgListAdd>:
#if OS_CFG_DBG_EN > 0u
void  OS_FlagDbgListAdd (OS_FLAG_GRP  *p_grp)
{
    p_grp->DbgNamePtr                = (CPU_CHAR    *)((void *)" ");
    p_grp->DbgPrevPtr                = (OS_FLAG_GRP *)0;
    if (OSFlagDbgListPtr == (OS_FLAG_GRP *)0) {
 8004e08:	4a06      	ldr	r2, [pc, #24]	; (8004e24 <OS_FlagDbgListAdd+0x1c>)
************************************************************************************************************************
*/

#if OS_CFG_DBG_EN > 0u
void  OS_FlagDbgListAdd (OS_FLAG_GRP  *p_grp)
{
 8004e0a:	b410      	push	{r4}
    p_grp->DbgNamePtr                = (CPU_CHAR    *)((void *)" ");
    p_grp->DbgPrevPtr                = (OS_FLAG_GRP *)0;
    if (OSFlagDbgListPtr == (OS_FLAG_GRP *)0) {
 8004e0c:	6813      	ldr	r3, [r2, #0]
*/

#if OS_CFG_DBG_EN > 0u
void  OS_FlagDbgListAdd (OS_FLAG_GRP  *p_grp)
{
    p_grp->DbgNamePtr                = (CPU_CHAR    *)((void *)" ");
 8004e0e:	4c06      	ldr	r4, [pc, #24]	; (8004e28 <OS_FlagDbgListAdd+0x20>)
    p_grp->DbgPrevPtr                = (OS_FLAG_GRP *)0;
 8004e10:	2100      	movs	r1, #0
*/

#if OS_CFG_DBG_EN > 0u
void  OS_FlagDbgListAdd (OS_FLAG_GRP  *p_grp)
{
    p_grp->DbgNamePtr                = (CPU_CHAR    *)((void *)" ");
 8004e12:	61c4      	str	r4, [r0, #28]
    p_grp->DbgPrevPtr                = (OS_FLAG_GRP *)0;
 8004e14:	6141      	str	r1, [r0, #20]
    if (OSFlagDbgListPtr == (OS_FLAG_GRP *)0) {
        p_grp->DbgNextPtr            = (OS_FLAG_GRP *)0;
 8004e16:	6183      	str	r3, [r0, #24]
#if OS_CFG_DBG_EN > 0u
void  OS_FlagDbgListAdd (OS_FLAG_GRP  *p_grp)
{
    p_grp->DbgNamePtr                = (CPU_CHAR    *)((void *)" ");
    p_grp->DbgPrevPtr                = (OS_FLAG_GRP *)0;
    if (OSFlagDbgListPtr == (OS_FLAG_GRP *)0) {
 8004e18:	b103      	cbz	r3, 8004e1c <OS_FlagDbgListAdd+0x14>
        p_grp->DbgNextPtr            = (OS_FLAG_GRP *)0;
    } else {
        p_grp->DbgNextPtr            =  OSFlagDbgListPtr;
        OSFlagDbgListPtr->DbgPrevPtr =  p_grp;
 8004e1a:	6158      	str	r0, [r3, #20]
    }
    OSFlagDbgListPtr                 =  p_grp;
 8004e1c:	6010      	str	r0, [r2, #0]
}
 8004e1e:	bc10      	pop	{r4}
 8004e20:	4770      	bx	lr
 8004e22:	bf00      	nop
 8004e24:	2000ef50 	.word	0x2000ef50
 8004e28:	080182f0 	.word	0x080182f0

08004e2c <OS_FlagDbgListRemove>:
{
    OS_FLAG_GRP  *p_grp_next;
    OS_FLAG_GRP  *p_grp_prev;


    p_grp_prev = p_grp->DbgPrevPtr;
 8004e2c:	6942      	ldr	r2, [r0, #20]
    p_grp_next = p_grp->DbgNextPtr;
 8004e2e:	6983      	ldr	r3, [r0, #24]

    if (p_grp_prev == (OS_FLAG_GRP *)0) {
 8004e30:	b132      	cbz	r2, 8004e40 <OS_FlagDbgListRemove+0x14>
        if (p_grp_next != (OS_FLAG_GRP *)0) {
            p_grp_next->DbgPrevPtr = (OS_FLAG_GRP *)0;
        }
        p_grp->DbgNextPtr = (OS_FLAG_GRP *)0;

    } else if (p_grp_next == (OS_FLAG_GRP *)0) {
 8004e32:	b163      	cbz	r3, 8004e4e <OS_FlagDbgListRemove+0x22>
        p_grp->DbgPrevPtr      = (OS_FLAG_GRP *)0;

    } else {
        p_grp_prev->DbgNextPtr =  p_grp_next;
        p_grp_next->DbgPrevPtr =  p_grp_prev;
        p_grp->DbgNextPtr      = (OS_FLAG_GRP *)0;
 8004e34:	2100      	movs	r1, #0
    } else if (p_grp_next == (OS_FLAG_GRP *)0) {
        p_grp_prev->DbgNextPtr = (OS_FLAG_GRP *)0;
        p_grp->DbgPrevPtr      = (OS_FLAG_GRP *)0;

    } else {
        p_grp_prev->DbgNextPtr =  p_grp_next;
 8004e36:	6193      	str	r3, [r2, #24]
        p_grp_next->DbgPrevPtr =  p_grp_prev;
 8004e38:	615a      	str	r2, [r3, #20]
        p_grp->DbgNextPtr      = (OS_FLAG_GRP *)0;
 8004e3a:	6181      	str	r1, [r0, #24]
        p_grp->DbgPrevPtr      = (OS_FLAG_GRP *)0;
 8004e3c:	6141      	str	r1, [r0, #20]
 8004e3e:	4770      	bx	lr

    p_grp_prev = p_grp->DbgPrevPtr;
    p_grp_next = p_grp->DbgNextPtr;

    if (p_grp_prev == (OS_FLAG_GRP *)0) {
        OSFlagDbgListPtr = p_grp_next;
 8004e40:	4904      	ldr	r1, [pc, #16]	; (8004e54 <OS_FlagDbgListRemove+0x28>)
 8004e42:	600b      	str	r3, [r1, #0]
        if (p_grp_next != (OS_FLAG_GRP *)0) {
 8004e44:	b103      	cbz	r3, 8004e48 <OS_FlagDbgListRemove+0x1c>
            p_grp_next->DbgPrevPtr = (OS_FLAG_GRP *)0;
 8004e46:	615a      	str	r2, [r3, #20]
        }
        p_grp->DbgNextPtr = (OS_FLAG_GRP *)0;
 8004e48:	2300      	movs	r3, #0
 8004e4a:	6183      	str	r3, [r0, #24]
 8004e4c:	4770      	bx	lr

    } else if (p_grp_next == (OS_FLAG_GRP *)0) {
        p_grp_prev->DbgNextPtr = (OS_FLAG_GRP *)0;
 8004e4e:	6193      	str	r3, [r2, #24]
        p_grp->DbgPrevPtr      = (OS_FLAG_GRP *)0;
 8004e50:	6143      	str	r3, [r0, #20]
 8004e52:	4770      	bx	lr
 8004e54:	2000ef50 	.word	0x2000ef50

08004e58 <OS_FlagTaskRdy>:
*/

void   OS_FlagTaskRdy (OS_TCB    *p_tcb,
                       OS_FLAGS   flags_rdy,
                       CPU_TS     ts)
{
 8004e58:	b510      	push	{r4, lr}
 8004e5a:	4604      	mov	r4, r0
    p_tcb->FlagsRdy   = flags_rdy;
    p_tcb->PendStatus = OS_STATUS_PEND_OK;                  /* Clear pend status                                      */
    p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;            /* Indicate no longer pending                             */
    p_tcb->TS         = ts;
    switch (p_tcb->TaskState) {
 8004e5c:	f890 3036 	ldrb.w	r3, [r0, #54]	; 0x36
void   OS_FlagTaskRdy (OS_TCB    *p_tcb,
                       OS_FLAGS   flags_rdy,
                       CPU_TS     ts)
{
    p_tcb->FlagsRdy   = flags_rdy;
    p_tcb->PendStatus = OS_STATUS_PEND_OK;                  /* Clear pend status                                      */
 8004e60:	2000      	movs	r0, #0
    p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;            /* Indicate no longer pending                             */
    p_tcb->TS         = ts;
    switch (p_tcb->TaskState) {
 8004e62:	3b02      	subs	r3, #2

void   OS_FlagTaskRdy (OS_TCB    *p_tcb,
                       OS_FLAGS   flags_rdy,
                       CPU_TS     ts)
{
    p_tcb->FlagsRdy   = flags_rdy;
 8004e64:	f8c4 1084 	str.w	r1, [r4, #132]	; 0x84
    p_tcb->PendStatus = OS_STATUS_PEND_OK;                  /* Clear pend status                                      */
    p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;            /* Indicate no longer pending                             */
    p_tcb->TS         = ts;
 8004e68:	6422      	str	r2, [r4, #64]	; 0x40
void   OS_FlagTaskRdy (OS_TCB    *p_tcb,
                       OS_FLAGS   flags_rdy,
                       CPU_TS     ts)
{
    p_tcb->FlagsRdy   = flags_rdy;
    p_tcb->PendStatus = OS_STATUS_PEND_OK;                  /* Clear pend status                                      */
 8004e6a:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
    p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;            /* Indicate no longer pending                             */
 8004e6e:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
    p_tcb->TS         = ts;
    switch (p_tcb->TaskState) {
 8004e72:	2b05      	cmp	r3, #5
 8004e74:	d807      	bhi.n	8004e86 <OS_FlagTaskRdy+0x2e>
 8004e76:	e8df f003 	tbb	[pc, r3]
 8004e7a:	0b0b      	.short	0x0b0b
 8004e7c:	03030606 	.word	0x03030606
             p_tcb->TaskState = OS_TASK_STATE_RDY;
             break;

        case OS_TASK_STATE_PEND_SUSPENDED:
        case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
             p_tcb->TaskState = OS_TASK_STATE_SUSPENDED;
 8004e80:	2304      	movs	r3, #4
 8004e82:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
             break;

        default:
             break;
    }
    OS_PendListRemove(p_tcb);
 8004e86:	4620      	mov	r0, r4
}
 8004e88:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
             break;

        default:
             break;
    }
    OS_PendListRemove(p_tcb);
 8004e8c:	f7ff b8da 	b.w	8004044 <OS_PendListRemove>
        case OS_TASK_STATE_SUSPENDED:
             break;

        case OS_TASK_STATE_PEND:
        case OS_TASK_STATE_PEND_TIMEOUT:
             OS_TaskRdy(p_tcb);
 8004e90:	4620      	mov	r0, r4
 8004e92:	f7ff fb47 	bl	8004524 <OS_TaskRdy>
             p_tcb->TaskState = OS_TASK_STATE_RDY;
 8004e96:	2300      	movs	r3, #0
 8004e98:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
             break;

        default:
             break;
    }
    OS_PendListRemove(p_tcb);
 8004e9c:	4620      	mov	r0, r4
}
 8004e9e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
             break;

        default:
             break;
    }
    OS_PendListRemove(p_tcb);
 8004ea2:	f7ff b8cf 	b.w	8004044 <OS_PendListRemove>
 8004ea6:	bf00      	nop

08004ea8 <OS_FlagPost>:
OS_FLAGS  OS_FlagPost (OS_FLAG_GRP  *p_grp,
                       OS_FLAGS      flags,
                       OS_OPT        opt,
                       CPU_TS        ts,
                       OS_ERR       *p_err)
{
 8004ea8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8004eac:	4616      	mov	r6, r2
 8004eae:	4605      	mov	r5, r0
 8004eb0:	460c      	mov	r4, r1
 8004eb2:	461f      	mov	r7, r3
    OS_TCB         *p_tcb;
    CPU_SR_ALLOC();



    CPU_CRITICAL_ENTER();
 8004eb4:	f7fc fc5e 	bl	8001774 <CPU_SR_Save>
    switch (opt) {
 8004eb8:	2e01      	cmp	r6, #1
    OS_TCB         *p_tcb;
    CPU_SR_ALLOC();



    CPU_CRITICAL_ENTER();
 8004eba:	4680      	mov	r8, r0
    switch (opt) {
 8004ebc:	d010      	beq.n	8004ee0 <OS_FlagPost+0x38>
 8004ebe:	d352      	bcc.n	8004f66 <OS_FlagPost+0xbe>
 8004ec0:	f5b6 4f00 	cmp.w	r6, #32768	; 0x8000
 8004ec4:	d04f      	beq.n	8004f66 <OS_FlagPost+0xbe>
 8004ec6:	f248 0301 	movw	r3, #32769	; 0x8001
 8004eca:	429e      	cmp	r6, r3
 8004ecc:	d008      	beq.n	8004ee0 <OS_FlagPost+0x38>
        case OS_OPT_POST_FLAG_CLR | OS_OPT_POST_NO_SCHED:
             p_grp->Flags &= ~flags;                            /* Clear the flags specified in the group             */
             break;

        default:
             CPU_CRITICAL_EXIT();                               /* INVALID option                                     */
 8004ece:	f7fc fc55 	bl	800177c <CPU_SR_Restore>
            *p_err = OS_ERR_OPT_INVALID;
 8004ed2:	f645 6325 	movw	r3, #24101	; 0x5e25
 8004ed6:	9a06      	ldr	r2, [sp, #24]
             return ((OS_FLAGS)0);
 8004ed8:	2000      	movs	r0, #0
             p_grp->Flags &= ~flags;                            /* Clear the flags specified in the group             */
             break;

        default:
             CPU_CRITICAL_EXIT();                               /* INVALID option                                     */
            *p_err = OS_ERR_OPT_INVALID;
 8004eda:	8013      	strh	r3, [r2, #0]
             return ((OS_FLAGS)0);
 8004edc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
             p_grp->Flags |=  flags;                            /* Set   the flags specified in the group             */
             break;

        case OS_OPT_POST_FLAG_CLR:
        case OS_OPT_POST_FLAG_CLR | OS_OPT_POST_NO_SCHED:
             p_grp->Flags &= ~flags;                            /* Clear the flags specified in the group             */
 8004ee0:	6a29      	ldr	r1, [r5, #32]
        default:
             CPU_CRITICAL_EXIT();                               /* INVALID option                                     */
            *p_err = OS_ERR_OPT_INVALID;
             return ((OS_FLAGS)0);
    }
    p_grp->TS   = ts;
 8004ee2:	626f      	str	r7, [r5, #36]	; 0x24
             p_grp->Flags |=  flags;                            /* Set   the flags specified in the group             */
             break;

        case OS_OPT_POST_FLAG_CLR:
        case OS_OPT_POST_FLAG_CLR | OS_OPT_POST_NO_SCHED:
             p_grp->Flags &= ~flags;                            /* Clear the flags specified in the group             */
 8004ee4:	ea21 0104 	bic.w	r1, r1, r4
            *p_err = OS_ERR_OPT_INVALID;
             return ((OS_FLAGS)0);
    }
    p_grp->TS   = ts;
    p_pend_list = &p_grp->PendList;
    if (p_pend_list->NbrEntries == 0u) {                        /* Any task waiting on event flag group?              */
 8004ee8:	8a2c      	ldrh	r4, [r5, #16]
             p_grp->Flags |=  flags;                            /* Set   the flags specified in the group             */
             break;

        case OS_OPT_POST_FLAG_CLR:
        case OS_OPT_POST_FLAG_CLR | OS_OPT_POST_NO_SCHED:
             p_grp->Flags &= ~flags;                            /* Clear the flags specified in the group             */
 8004eea:	6229      	str	r1, [r5, #32]
            *p_err = OS_ERR_OPT_INVALID;
             return ((OS_FLAGS)0);
    }
    p_grp->TS   = ts;
    p_pend_list = &p_grp->PendList;
    if (p_pend_list->NbrEntries == 0u) {                        /* Any task waiting on event flag group?              */
 8004eec:	2c00      	cmp	r4, #0
 8004eee:	d041      	beq.n	8004f74 <OS_FlagPost+0xcc>
       *p_err = OS_ERR_NONE;
        return (p_grp->Flags);
    }

    OS_CRITICAL_ENTER_CPU_EXIT();
    p_pend_data = p_pend_list->HeadPtr;
 8004ef0:	68ac      	ldr	r4, [r5, #8]
    p_tcb       = p_pend_data->TCBPtr;
 8004ef2:	68a0      	ldr	r0, [r4, #8]
    while (p_tcb != (OS_TCB *)0) {                              /* Go through all tasks waiting on event flag(s)      */
 8004ef4:	b178      	cbz	r0, 8004f16 <OS_FlagPost+0x6e>
        p_pend_data_next = p_pend_data->NextPtr;
        mode             = p_tcb->FlagsOpt & OS_OPT_PEND_FLAG_MASK;
        switch (mode) {
 8004ef6:	f8b0 3088 	ldrh.w	r3, [r0, #136]	; 0x88

    OS_CRITICAL_ENTER_CPU_EXIT();
    p_pend_data = p_pend_list->HeadPtr;
    p_tcb       = p_pend_data->TCBPtr;
    while (p_tcb != (OS_TCB *)0) {                              /* Go through all tasks waiting on event flag(s)      */
        p_pend_data_next = p_pend_data->NextPtr;
 8004efa:	6864      	ldr	r4, [r4, #4]
        mode             = p_tcb->FlagsOpt & OS_OPT_PEND_FLAG_MASK;
        switch (mode) {
 8004efc:	f003 030f 	and.w	r3, r3, #15
 8004f00:	2b04      	cmp	r3, #4
 8004f02:	d024      	beq.n	8004f4e <OS_FlagPost+0xa6>
 8004f04:	2b08      	cmp	r3, #8
 8004f06:	d118      	bne.n	8004f3a <OS_FlagPost+0x92>
                                    ts);
                 }
                 break;

            case OS_OPT_PEND_FLAG_SET_ANY:                      /* See if any flag set                                */
                 flags_rdy = (OS_FLAGS)(p_grp->Flags & p_tcb->FlagsPend);
 8004f08:	6a2b      	ldr	r3, [r5, #32]
 8004f0a:	f8d0 1080 	ldr.w	r1, [r0, #128]	; 0x80
                 if (flags_rdy != (OS_FLAGS)0) {
 8004f0e:	4019      	ands	r1, r3
 8004f10:	d123      	bne.n	8004f5a <OS_FlagPost+0xb2>
                 OS_CRITICAL_EXIT();
                *p_err = OS_ERR_FLAG_PEND_OPT;
                 return ((OS_FLAGS)0);
        }
        p_pend_data = p_pend_data_next;                         /* Point to next task waiting for event flag(s)       */
        if (p_pend_data != (OS_PEND_DATA *)0) {
 8004f12:	2c00      	cmp	r4, #0
 8004f14:	d1ed      	bne.n	8004ef2 <OS_FlagPost+0x4a>
            p_tcb = p_pend_data->TCBPtr;
        } else {
            p_tcb = (OS_TCB *)0;
        }
    }
    OS_CRITICAL_EXIT_NO_SCHED();
 8004f16:	4640      	mov	r0, r8
 8004f18:	f7fc fc30 	bl	800177c <CPU_SR_Restore>

    if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
 8004f1c:	0433      	lsls	r3, r6, #16
 8004f1e:	d401      	bmi.n	8004f24 <OS_FlagPost+0x7c>
        OSSched();
 8004f20:	f7fe fe02 	bl	8003b28 <OSSched>
    }

    CPU_CRITICAL_ENTER();
 8004f24:	f7fc fc26 	bl	8001774 <CPU_SR_Save>
    flags_cur = p_grp->Flags;
 8004f28:	6a2c      	ldr	r4, [r5, #32]
    CPU_CRITICAL_EXIT();
 8004f2a:	f7fc fc27 	bl	800177c <CPU_SR_Restore>
   *p_err     = OS_ERR_NONE;
 8004f2e:	9a06      	ldr	r2, [sp, #24]
 8004f30:	2300      	movs	r3, #0
    return (flags_cur);
 8004f32:	4620      	mov	r0, r4
    }

    CPU_CRITICAL_ENTER();
    flags_cur = p_grp->Flags;
    CPU_CRITICAL_EXIT();
   *p_err     = OS_ERR_NONE;
 8004f34:	8013      	strh	r3, [r2, #0]
    return (flags_cur);
}
 8004f36:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                                    ts);
                 }
                 break;
#endif
            default:
                 OS_CRITICAL_EXIT();
 8004f3a:	4640      	mov	r0, r8
 8004f3c:	f7fc fc1e 	bl	800177c <CPU_SR_Restore>
                *p_err = OS_ERR_FLAG_PEND_OPT;
 8004f40:	f643 23ff 	movw	r3, #15103	; 0x3aff
 8004f44:	9a06      	ldr	r2, [sp, #24]
                 return ((OS_FLAGS)0);
 8004f46:	2000      	movs	r0, #0
                 }
                 break;
#endif
            default:
                 OS_CRITICAL_EXIT();
                *p_err = OS_ERR_FLAG_PEND_OPT;
 8004f48:	8013      	strh	r3, [r2, #0]
                 return ((OS_FLAGS)0);
 8004f4a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    while (p_tcb != (OS_TCB *)0) {                              /* Go through all tasks waiting on event flag(s)      */
        p_pend_data_next = p_pend_data->NextPtr;
        mode             = p_tcb->FlagsOpt & OS_OPT_PEND_FLAG_MASK;
        switch (mode) {
            case OS_OPT_PEND_FLAG_SET_ALL:                      /* See if all req. flags are set for current node     */
                 flags_rdy = (OS_FLAGS)(p_grp->Flags & p_tcb->FlagsPend);
 8004f4e:	f8d0 1080 	ldr.w	r1, [r0, #128]	; 0x80
                 if (flags_rdy == p_tcb->FlagsPend) {
 8004f52:	6a2b      	ldr	r3, [r5, #32]
 8004f54:	ea31 0303 	bics.w	r3, r1, r3
 8004f58:	d1db      	bne.n	8004f12 <OS_FlagPost+0x6a>
                 break;

            case OS_OPT_PEND_FLAG_SET_ANY:                      /* See if any flag set                                */
                 flags_rdy = (OS_FLAGS)(p_grp->Flags & p_tcb->FlagsPend);
                 if (flags_rdy != (OS_FLAGS)0) {
                     OS_FlagTaskRdy(p_tcb,                      /* Make task RTR, event(s) Rx'd                       */
 8004f5a:	463a      	mov	r2, r7
 8004f5c:	f7ff ff7c 	bl	8004e58 <OS_FlagTaskRdy>
                 OS_CRITICAL_EXIT();
                *p_err = OS_ERR_FLAG_PEND_OPT;
                 return ((OS_FLAGS)0);
        }
        p_pend_data = p_pend_data_next;                         /* Point to next task waiting for event flag(s)       */
        if (p_pend_data != (OS_PEND_DATA *)0) {
 8004f60:	2c00      	cmp	r4, #0
 8004f62:	d1c6      	bne.n	8004ef2 <OS_FlagPost+0x4a>
 8004f64:	e7d7      	b.n	8004f16 <OS_FlagPost+0x6e>

    CPU_CRITICAL_ENTER();
    switch (opt) {
        case OS_OPT_POST_FLAG_SET:
        case OS_OPT_POST_FLAG_SET | OS_OPT_POST_NO_SCHED:
             p_grp->Flags |=  flags;                            /* Set   the flags specified in the group             */
 8004f66:	6a29      	ldr	r1, [r5, #32]
        default:
             CPU_CRITICAL_EXIT();                               /* INVALID option                                     */
            *p_err = OS_ERR_OPT_INVALID;
             return ((OS_FLAGS)0);
    }
    p_grp->TS   = ts;
 8004f68:	626f      	str	r7, [r5, #36]	; 0x24

    CPU_CRITICAL_ENTER();
    switch (opt) {
        case OS_OPT_POST_FLAG_SET:
        case OS_OPT_POST_FLAG_SET | OS_OPT_POST_NO_SCHED:
             p_grp->Flags |=  flags;                            /* Set   the flags specified in the group             */
 8004f6a:	430c      	orrs	r4, r1
 8004f6c:	622c      	str	r4, [r5, #32]
            *p_err = OS_ERR_OPT_INVALID;
             return ((OS_FLAGS)0);
    }
    p_grp->TS   = ts;
    p_pend_list = &p_grp->PendList;
    if (p_pend_list->NbrEntries == 0u) {                        /* Any task waiting on event flag group?              */
 8004f6e:	8a2c      	ldrh	r4, [r5, #16]
 8004f70:	2c00      	cmp	r4, #0
 8004f72:	d1bd      	bne.n	8004ef0 <OS_FlagPost+0x48>
        CPU_CRITICAL_EXIT();                                    /* No                                                 */
 8004f74:	4640      	mov	r0, r8
 8004f76:	f7fc fc01 	bl	800177c <CPU_SR_Restore>
       *p_err = OS_ERR_NONE;
 8004f7a:	9b06      	ldr	r3, [sp, #24]
        return (p_grp->Flags);
 8004f7c:	6a28      	ldr	r0, [r5, #32]
    }
    p_grp->TS   = ts;
    p_pend_list = &p_grp->PendList;
    if (p_pend_list->NbrEntries == 0u) {                        /* Any task waiting on event flag group?              */
        CPU_CRITICAL_EXIT();                                    /* No                                                 */
       *p_err = OS_ERR_NONE;
 8004f7e:	801c      	strh	r4, [r3, #0]
        return (p_grp->Flags);
 8004f80:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08004f84 <OSFlagPost>:
        return ((OS_FLAGS)0);
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_grp == (OS_FLAG_GRP *)0) {                        /* Validate 'p_grp'                                       */
 8004f84:	b330      	cbz	r0, 8004fd4 <OSFlagPost+0x50>

OS_FLAGS  OSFlagPost (OS_FLAG_GRP  *p_grp,
                      OS_FLAGS      flags,
                      OS_OPT        opt,
                      OS_ERR       *p_err)
{
 8004f86:	b5f0      	push	{r4, r5, r6, r7, lr}
#if OS_CFG_ARG_CHK_EN > 0u
    if (p_grp == (OS_FLAG_GRP *)0) {                        /* Validate 'p_grp'                                       */
       *p_err  = OS_ERR_OBJ_PTR_NULL;
        return ((OS_FLAGS)0);
    }
    switch (opt) {                                          /* Validate 'opt'                                         */
 8004f88:	2a01      	cmp	r2, #1

OS_FLAGS  OSFlagPost (OS_FLAG_GRP  *p_grp,
                      OS_FLAGS      flags,
                      OS_OPT        opt,
                      OS_ERR       *p_err)
{
 8004f8a:	b083      	sub	sp, #12
#if OS_CFG_ARG_CHK_EN > 0u
    if (p_grp == (OS_FLAG_GRP *)0) {                        /* Validate 'p_grp'                                       */
       *p_err  = OS_ERR_OBJ_PTR_NULL;
        return ((OS_FLAGS)0);
    }
    switch (opt) {                                          /* Validate 'opt'                                         */
 8004f8c:	d909      	bls.n	8004fa2 <OSFlagPost+0x1e>
 8004f8e:	f5a2 4400 	sub.w	r4, r2, #32768	; 0x8000
 8004f92:	2c01      	cmp	r4, #1
 8004f94:	d905      	bls.n	8004fa2 <OSFlagPost+0x1e>
        case OS_OPT_POST_FLAG_SET | OS_OPT_POST_NO_SCHED:
        case OS_OPT_POST_FLAG_CLR | OS_OPT_POST_NO_SCHED:
             break;

        default:
            *p_err = OS_ERR_OPT_INVALID;
 8004f96:	f645 6225 	movw	r2, #24101	; 0x5e25
             return ((OS_FLAGS)0);
 8004f9a:	2000      	movs	r0, #0
        case OS_OPT_POST_FLAG_SET | OS_OPT_POST_NO_SCHED:
        case OS_OPT_POST_FLAG_CLR | OS_OPT_POST_NO_SCHED:
             break;

        default:
            *p_err = OS_ERR_OPT_INVALID;
 8004f9c:	801a      	strh	r2, [r3, #0]
                            opt,
                            ts,
                            p_err);

    return (flags_cur);
}
 8004f9e:	b003      	add	sp, #12
 8004fa0:	bdf0      	pop	{r4, r5, r6, r7, pc}
             return ((OS_FLAGS)0);
    }
#endif

#if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    if (p_grp->Type != OS_OBJ_TYPE_FLAG) {                  /* Make sure we are pointing to an event flag grp         */
 8004fa2:	4c0e      	ldr	r4, [pc, #56]	; (8004fdc <OSFlagPost+0x58>)
 8004fa4:	6805      	ldr	r5, [r0, #0]
 8004fa6:	42a5      	cmp	r5, r4
 8004fa8:	d005      	beq.n	8004fb6 <OSFlagPost+0x32>
       *p_err = OS_ERR_OBJ_TYPE;
 8004faa:	f645 52c4 	movw	r2, #24004	; 0x5dc4
        return ((OS_FLAGS)0);
 8004fae:	2000      	movs	r0, #0
    }
#endif

#if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    if (p_grp->Type != OS_OBJ_TYPE_FLAG) {                  /* Make sure we are pointing to an event flag grp         */
       *p_err = OS_ERR_OBJ_TYPE;
 8004fb0:	801a      	strh	r2, [r3, #0]
                            opt,
                            ts,
                            p_err);

    return (flags_cur);
}
 8004fb2:	b003      	add	sp, #12
 8004fb4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004fb6:	461e      	mov	r6, r3
 8004fb8:	4604      	mov	r4, r0
 8004fba:	4615      	mov	r5, r2
 8004fbc:	460f      	mov	r7, r1
       *p_err = OS_ERR_OBJ_TYPE;
        return ((OS_FLAGS)0);
    }
#endif

    ts = OS_TS_GET();                                       /* Get timestamp                                          */
 8004fbe:	f7fb fde5 	bl	8000b8c <CPU_TS_TmrRd>
                    (OS_ERR    *)p_err);
        return ((OS_FLAGS)0);
    }
#endif

    flags_cur = OS_FlagPost(p_grp,
 8004fc2:	9600      	str	r6, [sp, #0]
 8004fc4:	4603      	mov	r3, r0
 8004fc6:	462a      	mov	r2, r5
 8004fc8:	4639      	mov	r1, r7
 8004fca:	4620      	mov	r0, r4
 8004fcc:	f7ff ff6c 	bl	8004ea8 <OS_FlagPost>
                            opt,
                            ts,
                            p_err);

    return (flags_cur);
}
 8004fd0:	b003      	add	sp, #12
 8004fd2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_grp == (OS_FLAG_GRP *)0) {                        /* Validate 'p_grp'                                       */
       *p_err  = OS_ERR_OBJ_PTR_NULL;
 8004fd4:	f645 52c3 	movw	r2, #24003	; 0x5dc3
 8004fd8:	801a      	strh	r2, [r3, #0]
                            opt,
                            ts,
                            p_err);

    return (flags_cur);
}
 8004fda:	4770      	bx	lr
 8004fdc:	47414c46 	.word	0x47414c46

08004fe0 <OSMemCreate>:
                   CPU_CHAR     *p_name,
                   void         *p_addr,
                   OS_MEM_QTY    n_blks,
                   OS_MEM_SIZE   blk_size,
                   OS_ERR       *p_err)
{
 8004fe0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
        return;
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
 8004fe4:	4c30      	ldr	r4, [pc, #192]	; (80050a8 <OSMemCreate+0xc8>)
                   CPU_CHAR     *p_name,
                   void         *p_addr,
                   OS_MEM_QTY    n_blks,
                   OS_MEM_SIZE   blk_size,
                   OS_ERR       *p_err)
{
 8004fe6:	f8bd 6020 	ldrh.w	r6, [sp, #32]
        return;
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
 8004fea:	7824      	ldrb	r4, [r4, #0]
 8004fec:	2c00      	cmp	r4, #0
 8004fee:	d142      	bne.n	8005076 <OSMemCreate+0x96>
        return;
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_addr == (void *)0) {                              /* Must pass a valid address for the memory part.         */
 8004ff0:	2a00      	cmp	r2, #0
 8004ff2:	d04c      	beq.n	800508e <OSMemCreate+0xae>
       *p_err   = OS_ERR_MEM_INVALID_P_ADDR;
        return;
    }
    if (n_blks < (OS_MEM_QTY)2) {                           /* Must have at least 2 blocks per partition              */
 8004ff4:	2b01      	cmp	r3, #1
 8004ff6:	d950      	bls.n	800509a <OSMemCreate+0xba>
       *p_err = OS_ERR_MEM_INVALID_BLKS;
        return;
    }
    if (blk_size < sizeof(void *)) {                        /* Must contain space for at least a pointer              */
 8004ff8:	2e03      	cmp	r6, #3
 8004ffa:	d942      	bls.n	8005082 <OSMemCreate+0xa2>
       *p_err = OS_ERR_MEM_INVALID_SIZE;
        return;
    }
    align_msk = sizeof(void *) - 1u;
    if (align_msk > 0u) {
        if (((CPU_ADDR)p_addr & align_msk) != 0u){          /* Must be pointer size aligned                           */
 8004ffc:	0794      	lsls	r4, r2, #30
 8004ffe:	d146      	bne.n	800508e <OSMemCreate+0xae>
           *p_err = OS_ERR_MEM_INVALID_P_ADDR;
            return;
        }
        if ((blk_size & align_msk) != 0u) {                 /* Block size must be a multiple address size             */
 8005000:	f016 0403 	ands.w	r4, r6, #3
 8005004:	d13d      	bne.n	8005082 <OSMemCreate+0xa2>
    }
#endif

    p_link = (void **)p_addr;                               /* Create linked list of free memory blocks               */
    p_blk  = (CPU_INT08U *)p_addr;
    loops  = n_blks - 1u;
 8005006:	4615      	mov	r5, r2
 8005008:	f103 3cff 	add.w	ip, r3, #4294967295
 800500c:	fa1f fc8c 	uxth.w	ip, ip
 8005010:	3401      	adds	r4, #1
    for (i = 0u; i < loops; i++) {
 8005012:	fa1f fe84 	uxth.w	lr, r4
        p_blk +=  blk_size;
 8005016:	19af      	adds	r7, r5, r6
#endif

    p_link = (void **)p_addr;                               /* Create linked list of free memory blocks               */
    p_blk  = (CPU_INT08U *)p_addr;
    loops  = n_blks - 1u;
    for (i = 0u; i < loops; i++) {
 8005018:	45f4      	cmp	ip, lr
        p_blk +=  blk_size;
       *p_link = (void  *)p_blk;                            /* Save pointer to NEXT block in CURRENT block            */
 800501a:	602f      	str	r7, [r5, #0]

    p_link = (void **)p_addr;                               /* Create linked list of free memory blocks               */
    p_blk  = (CPU_INT08U *)p_addr;
    loops  = n_blks - 1u;
    for (i = 0u; i < loops; i++) {
        p_blk +=  blk_size;
 800501c:	463d      	mov	r5, r7
#endif

    p_link = (void **)p_addr;                               /* Create linked list of free memory blocks               */
    p_blk  = (CPU_INT08U *)p_addr;
    loops  = n_blks - 1u;
    for (i = 0u; i < loops; i++) {
 800501e:	d8f7      	bhi.n	8005010 <OSMemCreate+0x30>
 8005020:	4605      	mov	r5, r0
 8005022:	4690      	mov	r8, r2
 8005024:	461c      	mov	r4, r3
 8005026:	460f      	mov	r7, r1
        p_blk +=  blk_size;
       *p_link = (void  *)p_blk;                            /* Save pointer to NEXT block in CURRENT block            */
        p_link = (void **)(void *)p_blk;                    /* Position     to NEXT block                             */
    }
   *p_link             = (void *)0;                         /* Last memory block points to NULL                       */
 8005028:	3b02      	subs	r3, #2
 800502a:	b29b      	uxth	r3, r3
 800502c:	fb03 6306 	mla	r3, r3, r6, r6
 8005030:	f04f 0900 	mov.w	r9, #0
 8005034:	f842 9003 	str.w	r9, [r2, r3]

    OS_CRITICAL_ENTER();
 8005038:	f7fc fb9c 	bl	8001774 <CPU_SR_Save>

#if OS_CFG_DBG_EN > 0u
void  OS_MemDbgListAdd (OS_MEM  *p_mem)
{
    p_mem->DbgPrevPtr               = (OS_MEM *)0;
    if (OSMemDbgListPtr == (OS_MEM *)0) {
 800503c:	491b      	ldr	r1, [pc, #108]	; (80050ac <OSMemCreate+0xcc>)
        p_link = (void **)(void *)p_blk;                    /* Position     to NEXT block                             */
    }
   *p_link             = (void *)0;                         /* Last memory block points to NULL                       */

    OS_CRITICAL_ENTER();
    p_mem->Type        = OS_OBJ_TYPE_MEM;                   /* Set the type of object                                 */
 800503e:	4a1c      	ldr	r2, [pc, #112]	; (80050b0 <OSMemCreate+0xd0>)

#if OS_CFG_DBG_EN > 0u
void  OS_MemDbgListAdd (OS_MEM  *p_mem)
{
    p_mem->DbgPrevPtr               = (OS_MEM *)0;
    if (OSMemDbgListPtr == (OS_MEM *)0) {
 8005040:	680b      	ldr	r3, [r1, #0]
*/

#if OS_CFG_DBG_EN > 0u
void  OS_MemDbgListAdd (OS_MEM  *p_mem)
{
    p_mem->DbgPrevPtr               = (OS_MEM *)0;
 8005042:	f8c5 9018 	str.w	r9, [r5, #24]
    }
   *p_link             = (void *)0;                         /* Last memory block points to NULL                       */

    OS_CRITICAL_ENTER();
    p_mem->Type        = OS_OBJ_TYPE_MEM;                   /* Set the type of object                                 */
    p_mem->NamePtr     = p_name;                            /* Save name of memory partition                          */
 8005046:	60af      	str	r7, [r5, #8]
    p_mem->AddrPtr     = p_addr;                            /* Store start address of memory partition                */
 8005048:	f8c5 8004 	str.w	r8, [r5, #4]
    p_mem->FreeListPtr = p_addr;                            /* Initialize pointer to pool of free blocks              */
 800504c:	f8c5 800c 	str.w	r8, [r5, #12]
    p_mem->NbrFree     = n_blks;                            /* Store number of free blocks in MCB                     */
 8005050:	82ac      	strh	r4, [r5, #20]
    p_mem->NbrMax      = n_blks;
 8005052:	826c      	strh	r4, [r5, #18]
    p_mem->BlkSize     = blk_size;                          /* Store block size of each memory blocks                 */
 8005054:	822e      	strh	r6, [r5, #16]
        p_link = (void **)(void *)p_blk;                    /* Position     to NEXT block                             */
    }
   *p_link             = (void *)0;                         /* Last memory block points to NULL                       */

    OS_CRITICAL_ENTER();
    p_mem->Type        = OS_OBJ_TYPE_MEM;                   /* Set the type of object                                 */
 8005056:	602a      	str	r2, [r5, #0]
#if OS_CFG_DBG_EN > 0u
void  OS_MemDbgListAdd (OS_MEM  *p_mem)
{
    p_mem->DbgPrevPtr               = (OS_MEM *)0;
    if (OSMemDbgListPtr == (OS_MEM *)0) {
        p_mem->DbgNextPtr           = (OS_MEM *)0;
 8005058:	61eb      	str	r3, [r5, #28]

#if OS_CFG_DBG_EN > 0u
void  OS_MemDbgListAdd (OS_MEM  *p_mem)
{
    p_mem->DbgPrevPtr               = (OS_MEM *)0;
    if (OSMemDbgListPtr == (OS_MEM *)0) {
 800505a:	b103      	cbz	r3, 800505e <OSMemCreate+0x7e>
        p_mem->DbgNextPtr           = (OS_MEM *)0;
    } else {
        p_mem->DbgNextPtr           =  OSMemDbgListPtr;
        OSMemDbgListPtr->DbgPrevPtr =  p_mem;
 800505c:	619d      	str	r5, [r3, #24]

#if OS_CFG_DBG_EN > 0u
    OS_MemDbgListAdd(p_mem);
#endif

    OSMemQty++;
 800505e:	4a15      	ldr	r2, [pc, #84]	; (80050b4 <OSMemCreate+0xd4>)
        p_mem->DbgNextPtr           = (OS_MEM *)0;
    } else {
        p_mem->DbgNextPtr           =  OSMemDbgListPtr;
        OSMemDbgListPtr->DbgPrevPtr =  p_mem;
    }
    OSMemDbgListPtr                 =  p_mem;
 8005060:	600d      	str	r5, [r1, #0]

#if OS_CFG_DBG_EN > 0u
    OS_MemDbgListAdd(p_mem);
#endif

    OSMemQty++;
 8005062:	8813      	ldrh	r3, [r2, #0]
 8005064:	3301      	adds	r3, #1
 8005066:	8013      	strh	r3, [r2, #0]

    OS_CRITICAL_EXIT_NO_SCHED();
 8005068:	f7fc fb88 	bl	800177c <CPU_SR_Restore>
   *p_err = OS_ERR_NONE;
 800506c:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800506e:	2300      	movs	r3, #0
 8005070:	8013      	strh	r3, [r2, #0]
 8005072:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
       *p_err = OS_ERR_MEM_CREATE_ISR;
 8005076:	f245 63b9 	movw	r3, #22201	; 0x56b9
 800507a:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800507c:	8013      	strh	r3, [r2, #0]
        return;
 800507e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if (n_blks < (OS_MEM_QTY)2) {                           /* Must have at least 2 blocks per partition              */
       *p_err = OS_ERR_MEM_INVALID_BLKS;
        return;
    }
    if (blk_size < sizeof(void *)) {                        /* Must contain space for at least a pointer              */
       *p_err = OS_ERR_MEM_INVALID_SIZE;
 8005082:	f245 63c1 	movw	r3, #22209	; 0x56c1
 8005086:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8005088:	8013      	strh	r3, [r2, #0]
        return;
 800508a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_addr == (void *)0) {                              /* Must pass a valid address for the memory part.         */
       *p_err   = OS_ERR_MEM_INVALID_P_ADDR;
 800508e:	f245 63bb 	movw	r3, #22203	; 0x56bb
 8005092:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8005094:	8013      	strh	r3, [r2, #0]
        return;
 8005096:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    }
    if (n_blks < (OS_MEM_QTY)2) {                           /* Must have at least 2 blocks per partition              */
       *p_err = OS_ERR_MEM_INVALID_BLKS;
 800509a:	f245 63bc 	movw	r3, #22204	; 0x56bc
 800509e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80050a0:	8013      	strh	r3, [r2, #0]
        return;
 80050a2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80050a6:	bf00      	nop
 80050a8:	2000ed84 	.word	0x2000ed84
 80050ac:	2000ef24 	.word	0x2000ef24
 80050b0:	204d454d 	.word	0x204d454d
 80050b4:	2000ef5a 	.word	0x2000ef5a

080050b8 <OSMemGet>:
************************************************************************************************************************
*/

void  *OSMemGet (OS_MEM  *p_mem,
                 OS_ERR  *p_err)
{
 80050b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        return ((void *)0);
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_mem == (OS_MEM *)0) {                             /* Must point to a valid memory partition                 */
 80050ba:	b1b8      	cbz	r0, 80050ec <OSMemGet+0x34>
 80050bc:	4604      	mov	r4, r0
 80050be:	460f      	mov	r7, r1
       *p_err  = OS_ERR_MEM_INVALID_P_MEM;
        return ((void *)0);
    }
#endif

    CPU_CRITICAL_ENTER();
 80050c0:	f7fc fb58 	bl	8001774 <CPU_SR_Save>
    if (p_mem->NbrFree == (OS_MEM_QTY)0) {                  /* See if there are any free memory blocks                */
 80050c4:	8aa5      	ldrh	r5, [r4, #20]
 80050c6:	b155      	cbz	r5, 80050de <OSMemGet+0x26>
        CPU_CRITICAL_EXIT();
       *p_err = OS_ERR_MEM_NO_FREE_BLKS;                    /* No,  Notify caller of empty memory partition           */
        return ((void *)0);                                 /*      Return NULL pointer to caller                     */
    }
    p_blk              = p_mem->FreeListPtr;                /* Yes, point to next free memory block                   */
 80050c8:	68e6      	ldr	r6, [r4, #12]
    p_mem->FreeListPtr = *(void **)p_blk;                   /*      Adjust pointer to new free list                   */
    p_mem->NbrFree--;                                       /*      One less memory block in this partition           */
 80050ca:	1e6b      	subs	r3, r5, #1
        CPU_CRITICAL_EXIT();
       *p_err = OS_ERR_MEM_NO_FREE_BLKS;                    /* No,  Notify caller of empty memory partition           */
        return ((void *)0);                                 /*      Return NULL pointer to caller                     */
    }
    p_blk              = p_mem->FreeListPtr;                /* Yes, point to next free memory block                   */
    p_mem->FreeListPtr = *(void **)p_blk;                   /*      Adjust pointer to new free list                   */
 80050cc:	6832      	ldr	r2, [r6, #0]
    p_mem->NbrFree--;                                       /*      One less memory block in this partition           */
 80050ce:	82a3      	strh	r3, [r4, #20]
        CPU_CRITICAL_EXIT();
       *p_err = OS_ERR_MEM_NO_FREE_BLKS;                    /* No,  Notify caller of empty memory partition           */
        return ((void *)0);                                 /*      Return NULL pointer to caller                     */
    }
    p_blk              = p_mem->FreeListPtr;                /* Yes, point to next free memory block                   */
    p_mem->FreeListPtr = *(void **)p_blk;                   /*      Adjust pointer to new free list                   */
 80050d0:	60e2      	str	r2, [r4, #12]
    p_mem->NbrFree--;                                       /*      One less memory block in this partition           */
    CPU_CRITICAL_EXIT();
 80050d2:	f7fc fb53 	bl	800177c <CPU_SR_Restore>
   *p_err = OS_ERR_NONE;                                    /*      No error                                          */
 80050d6:	2300      	movs	r3, #0
    return (p_blk);                                         /*      Return memory block to caller                     */
 80050d8:	4630      	mov	r0, r6
    }
    p_blk              = p_mem->FreeListPtr;                /* Yes, point to next free memory block                   */
    p_mem->FreeListPtr = *(void **)p_blk;                   /*      Adjust pointer to new free list                   */
    p_mem->NbrFree--;                                       /*      One less memory block in this partition           */
    CPU_CRITICAL_EXIT();
   *p_err = OS_ERR_NONE;                                    /*      No error                                          */
 80050da:	803b      	strh	r3, [r7, #0]
    return (p_blk);                                         /*      Return memory block to caller                     */
}
 80050dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    }
#endif

    CPU_CRITICAL_ENTER();
    if (p_mem->NbrFree == (OS_MEM_QTY)0) {                  /* See if there are any free memory blocks                */
        CPU_CRITICAL_EXIT();
 80050de:	f7fc fb4d 	bl	800177c <CPU_SR_Restore>
       *p_err = OS_ERR_MEM_NO_FREE_BLKS;                    /* No,  Notify caller of empty memory partition           */
 80050e2:	f245 63c2 	movw	r3, #22210	; 0x56c2
        return ((void *)0);                                 /*      Return NULL pointer to caller                     */
 80050e6:	4628      	mov	r0, r5
#endif

    CPU_CRITICAL_ENTER();
    if (p_mem->NbrFree == (OS_MEM_QTY)0) {                  /* See if there are any free memory blocks                */
        CPU_CRITICAL_EXIT();
       *p_err = OS_ERR_MEM_NO_FREE_BLKS;                    /* No,  Notify caller of empty memory partition           */
 80050e8:	803b      	strh	r3, [r7, #0]
        return ((void *)0);                                 /*      Return NULL pointer to caller                     */
 80050ea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_mem == (OS_MEM *)0) {                             /* Must point to a valid memory partition                 */
       *p_err  = OS_ERR_MEM_INVALID_P_MEM;
 80050ec:	f245 63bf 	movw	r3, #22207	; 0x56bf
 80050f0:	800b      	strh	r3, [r1, #0]
        return ((void *)0);
 80050f2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080050f4 <OSMemPut>:
        return;
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_mem == (OS_MEM *)0) {                             /* Must point to a valid memory partition                 */
 80050f4:	b1f0      	cbz	r0, 8005134 <OSMemPut+0x40>
       *p_err  = OS_ERR_MEM_INVALID_P_MEM;
        return;
    }
    if (p_blk == (void *)0) {                               /* Must release a valid block                             */
 80050f6:	b1c9      	cbz	r1, 800512c <OSMemPut+0x38>
*/

void  OSMemPut (OS_MEM  *p_mem,
                void    *p_blk,
                OS_ERR  *p_err)
{
 80050f8:	b570      	push	{r4, r5, r6, lr}
 80050fa:	4604      	mov	r4, r0
 80050fc:	4616      	mov	r6, r2
 80050fe:	460d      	mov	r5, r1
       *p_err  = OS_ERR_MEM_INVALID_P_BLK;
        return;
    }
#endif

    CPU_CRITICAL_ENTER();
 8005100:	f7fc fb38 	bl	8001774 <CPU_SR_Save>
    if (p_mem->NbrFree >= p_mem->NbrMax) {                  /* Make sure all blocks not already returned              */
 8005104:	8aa3      	ldrh	r3, [r4, #20]
 8005106:	8a62      	ldrh	r2, [r4, #18]
 8005108:	429a      	cmp	r2, r3
 800510a:	d909      	bls.n	8005120 <OSMemPut+0x2c>
        CPU_CRITICAL_EXIT();
       *p_err = OS_ERR_MEM_FULL;
        return;
    }
    *(void **)p_blk    = p_mem->FreeListPtr;                /* Insert released block into free block list             */
 800510c:	68e2      	ldr	r2, [r4, #12]
    p_mem->FreeListPtr = p_blk;
    p_mem->NbrFree++;                                       /* One more memory block in this partition                */
 800510e:	3301      	adds	r3, #1
    if (p_mem->NbrFree >= p_mem->NbrMax) {                  /* Make sure all blocks not already returned              */
        CPU_CRITICAL_EXIT();
       *p_err = OS_ERR_MEM_FULL;
        return;
    }
    *(void **)p_blk    = p_mem->FreeListPtr;                /* Insert released block into free block list             */
 8005110:	602a      	str	r2, [r5, #0]
    p_mem->FreeListPtr = p_blk;
    p_mem->NbrFree++;                                       /* One more memory block in this partition                */
 8005112:	82a3      	strh	r3, [r4, #20]
        CPU_CRITICAL_EXIT();
       *p_err = OS_ERR_MEM_FULL;
        return;
    }
    *(void **)p_blk    = p_mem->FreeListPtr;                /* Insert released block into free block list             */
    p_mem->FreeListPtr = p_blk;
 8005114:	60e5      	str	r5, [r4, #12]
    p_mem->NbrFree++;                                       /* One more memory block in this partition                */
    CPU_CRITICAL_EXIT();
 8005116:	f7fc fb31 	bl	800177c <CPU_SR_Restore>
   *p_err              = OS_ERR_NONE;                       /* Notify caller that memory block was released           */
 800511a:	2300      	movs	r3, #0
 800511c:	8033      	strh	r3, [r6, #0]
 800511e:	bd70      	pop	{r4, r5, r6, pc}
    }
#endif

    CPU_CRITICAL_ENTER();
    if (p_mem->NbrFree >= p_mem->NbrMax) {                  /* Make sure all blocks not already returned              */
        CPU_CRITICAL_EXIT();
 8005120:	f7fc fb2c 	bl	800177c <CPU_SR_Restore>
       *p_err = OS_ERR_MEM_FULL;
 8005124:	f245 63ba 	movw	r3, #22202	; 0x56ba
 8005128:	8033      	strh	r3, [r6, #0]
        return;
 800512a:	bd70      	pop	{r4, r5, r6, pc}
    if (p_mem == (OS_MEM *)0) {                             /* Must point to a valid memory partition                 */
       *p_err  = OS_ERR_MEM_INVALID_P_MEM;
        return;
    }
    if (p_blk == (void *)0) {                               /* Must release a valid block                             */
       *p_err  = OS_ERR_MEM_INVALID_P_BLK;
 800512c:	f245 63be 	movw	r3, #22206	; 0x56be
 8005130:	8013      	strh	r3, [r2, #0]
 8005132:	4770      	bx	lr
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_mem == (OS_MEM *)0) {                             /* Must point to a valid memory partition                 */
       *p_err  = OS_ERR_MEM_INVALID_P_MEM;
 8005134:	f245 63bf 	movw	r3, #22207	; 0x56bf
 8005138:	8013      	strh	r3, [r2, #0]
        return;
 800513a:	4770      	bx	lr

0800513c <OS_MemDbgListAdd>:

#if OS_CFG_DBG_EN > 0u
void  OS_MemDbgListAdd (OS_MEM  *p_mem)
{
    p_mem->DbgPrevPtr               = (OS_MEM *)0;
    if (OSMemDbgListPtr == (OS_MEM *)0) {
 800513c:	4a04      	ldr	r2, [pc, #16]	; (8005150 <OS_MemDbgListAdd+0x14>)
*/

#if OS_CFG_DBG_EN > 0u
void  OS_MemDbgListAdd (OS_MEM  *p_mem)
{
    p_mem->DbgPrevPtr               = (OS_MEM *)0;
 800513e:	2100      	movs	r1, #0
    if (OSMemDbgListPtr == (OS_MEM *)0) {
 8005140:	6813      	ldr	r3, [r2, #0]
*/

#if OS_CFG_DBG_EN > 0u
void  OS_MemDbgListAdd (OS_MEM  *p_mem)
{
    p_mem->DbgPrevPtr               = (OS_MEM *)0;
 8005142:	6181      	str	r1, [r0, #24]
    if (OSMemDbgListPtr == (OS_MEM *)0) {
        p_mem->DbgNextPtr           = (OS_MEM *)0;
 8005144:	61c3      	str	r3, [r0, #28]

#if OS_CFG_DBG_EN > 0u
void  OS_MemDbgListAdd (OS_MEM  *p_mem)
{
    p_mem->DbgPrevPtr               = (OS_MEM *)0;
    if (OSMemDbgListPtr == (OS_MEM *)0) {
 8005146:	b103      	cbz	r3, 800514a <OS_MemDbgListAdd+0xe>
        p_mem->DbgNextPtr           = (OS_MEM *)0;
    } else {
        p_mem->DbgNextPtr           =  OSMemDbgListPtr;
        OSMemDbgListPtr->DbgPrevPtr =  p_mem;
 8005148:	6198      	str	r0, [r3, #24]
    }
    OSMemDbgListPtr                 =  p_mem;
 800514a:	6010      	str	r0, [r2, #0]
 800514c:	4770      	bx	lr
 800514e:	bf00      	nop
 8005150:	2000ef24 	.word	0x2000ef24

08005154 <OS_MemInit>:
        return;
    }
#endif

#if OS_CFG_DBG_EN > 0u
    OSMemDbgListPtr = (OS_MEM   *)0;
 8005154:	4903      	ldr	r1, [pc, #12]	; (8005164 <OS_MemInit+0x10>)
#endif

    OSMemQty        = (OS_OBJ_QTY)0;
 8005156:	4a04      	ldr	r2, [pc, #16]	; (8005168 <OS_MemInit+0x14>)
        return;
    }
#endif

#if OS_CFG_DBG_EN > 0u
    OSMemDbgListPtr = (OS_MEM   *)0;
 8005158:	2300      	movs	r3, #0
 800515a:	600b      	str	r3, [r1, #0]
#endif

    OSMemQty        = (OS_OBJ_QTY)0;
 800515c:	8013      	strh	r3, [r2, #0]
   *p_err           = OS_ERR_NONE;
 800515e:	8003      	strh	r3, [r0, #0]
 8005160:	4770      	bx	lr
 8005162:	bf00      	nop
 8005164:	2000ef24 	.word	0x2000ef24
 8005168:	2000ef5a 	.word	0x2000ef5a

0800516c <OS_MsgPoolInit>:
        return;
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (OSCfg_MsgPoolBasePtr == (OS_MSG *)0) {
 800516c:	4b1b      	ldr	r3, [pc, #108]	; (80051dc <OS_MsgPoolInit+0x70>)
* Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
************************************************************************************************************************
*/

void  OS_MsgPoolInit (OS_ERR  *p_err)
{
 800516e:	b470      	push	{r4, r5, r6}
        return;
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (OSCfg_MsgPoolBasePtr == (OS_MSG *)0) {
 8005170:	681d      	ldr	r5, [r3, #0]
 8005172:	b365      	cbz	r5, 80051ce <OS_MsgPoolInit+0x62>
       *p_err = OS_ERR_MSG_POOL_NULL_PTR;
        return;
    }
    if (OSCfg_MsgPoolSize == (OS_MSG_QTY)0) {
 8005174:	4b1a      	ldr	r3, [pc, #104]	; (80051e0 <OS_MsgPoolInit+0x74>)
 8005176:	881e      	ldrh	r6, [r3, #0]
 8005178:	b326      	cbz	r6, 80051c4 <OS_MsgPoolInit+0x58>

    p_msg1 = OSCfg_MsgPoolBasePtr;
    p_msg2 = OSCfg_MsgPoolBasePtr;
    p_msg2++;
    loops  = OSCfg_MsgPoolSize - 1u;
    for (i = 0u; i < loops; i++) {                          /* Init. list of free OS_MSGs                             */
 800517a:	2e01      	cmp	r6, #1
    }
#endif

    p_msg1 = OSCfg_MsgPoolBasePtr;
    p_msg2 = OSCfg_MsgPoolBasePtr;
    p_msg2++;
 800517c:	f105 0310 	add.w	r3, r5, #16
    loops  = OSCfg_MsgPoolSize - 1u;
    for (i = 0u; i < loops; i++) {                          /* Init. list of free OS_MSGs                             */
 8005180:	d02a      	beq.n	80051d8 <OS_MsgPoolInit+0x6c>
 8005182:	1eb4      	subs	r4, r6, #2
 8005184:	b2a4      	uxth	r4, r4
 8005186:	1ca1      	adds	r1, r4, #2
 8005188:	eb05 1101 	add.w	r1, r5, r1, lsl #4
        p_msg1->NextPtr = p_msg2;
        p_msg1->MsgPtr  = (void      *)0;
 800518c:	2200      	movs	r2, #0
 800518e:	f843 2c0c 	str.w	r2, [r3, #-12]
        p_msg1->MsgSize = (OS_MSG_SIZE)0u;
 8005192:	f823 2c08 	strh.w	r2, [r3, #-8]
        p_msg1->MsgTS   = (CPU_TS     )0u;
 8005196:	f843 2c04 	str.w	r2, [r3, #-4]
    p_msg1 = OSCfg_MsgPoolBasePtr;
    p_msg2 = OSCfg_MsgPoolBasePtr;
    p_msg2++;
    loops  = OSCfg_MsgPoolSize - 1u;
    for (i = 0u; i < loops; i++) {                          /* Init. list of free OS_MSGs                             */
        p_msg1->NextPtr = p_msg2;
 800519a:	f843 3c10 	str.w	r3, [r3, #-16]
        p_msg1->MsgPtr  = (void      *)0;
        p_msg1->MsgSize = (OS_MSG_SIZE)0u;
        p_msg1->MsgTS   = (CPU_TS     )0u;
        p_msg1++;
        p_msg2++;
 800519e:	3310      	adds	r3, #16

    p_msg1 = OSCfg_MsgPoolBasePtr;
    p_msg2 = OSCfg_MsgPoolBasePtr;
    p_msg2++;
    loops  = OSCfg_MsgPoolSize - 1u;
    for (i = 0u; i < loops; i++) {                          /* Init. list of free OS_MSGs                             */
 80051a0:	428b      	cmp	r3, r1
 80051a2:	d1f4      	bne.n	800518e <OS_MsgPoolInit+0x22>
 80051a4:	1c63      	adds	r3, r4, #1
 80051a6:	eb05 1303 	add.w	r3, r5, r3, lsl #4
    p_msg1->NextPtr = (OS_MSG    *)0;                       /* Last OS_MSG                                            */
    p_msg1->MsgPtr  = (void      *)0;
    p_msg1->MsgSize = (OS_MSG_SIZE)0u;
    p_msg1->MsgTS   = (CPU_TS     )0u;

    OSMsgPool.NextPtr    =  OSCfg_MsgPoolBasePtr;
 80051aa:	490e      	ldr	r1, [pc, #56]	; (80051e4 <OS_MsgPoolInit+0x78>)
        p_msg1->MsgSize = (OS_MSG_SIZE)0u;
        p_msg1->MsgTS   = (CPU_TS     )0u;
        p_msg1++;
        p_msg2++;
    }
    p_msg1->NextPtr = (OS_MSG    *)0;                       /* Last OS_MSG                                            */
 80051ac:	2200      	movs	r2, #0
 80051ae:	601a      	str	r2, [r3, #0]
    p_msg1->MsgPtr  = (void      *)0;
 80051b0:	605a      	str	r2, [r3, #4]
    p_msg1->MsgSize = (OS_MSG_SIZE)0u;
 80051b2:	811a      	strh	r2, [r3, #8]
    p_msg1->MsgTS   = (CPU_TS     )0u;

    OSMsgPool.NextPtr    =  OSCfg_MsgPoolBasePtr;
 80051b4:	600d      	str	r5, [r1, #0]
    OSMsgPool.NbrFree    =  OSCfg_MsgPoolSize;
 80051b6:	808e      	strh	r6, [r1, #4]
        p_msg2++;
    }
    p_msg1->NextPtr = (OS_MSG    *)0;                       /* Last OS_MSG                                            */
    p_msg1->MsgPtr  = (void      *)0;
    p_msg1->MsgSize = (OS_MSG_SIZE)0u;
    p_msg1->MsgTS   = (CPU_TS     )0u;
 80051b8:	60da      	str	r2, [r3, #12]

    OSMsgPool.NextPtr    =  OSCfg_MsgPoolBasePtr;
    OSMsgPool.NbrFree    =  OSCfg_MsgPoolSize;
    OSMsgPool.NbrUsed    = (OS_MSG_QTY)0;
 80051ba:	80ca      	strh	r2, [r1, #6]
    OSMsgPool.NbrUsedMax = (OS_MSG_QTY)0;
 80051bc:	810a      	strh	r2, [r1, #8]
   *p_err                =  OS_ERR_NONE;
}
 80051be:	bc70      	pop	{r4, r5, r6}

    OSMsgPool.NextPtr    =  OSCfg_MsgPoolBasePtr;
    OSMsgPool.NbrFree    =  OSCfg_MsgPoolSize;
    OSMsgPool.NbrUsed    = (OS_MSG_QTY)0;
    OSMsgPool.NbrUsedMax = (OS_MSG_QTY)0;
   *p_err                =  OS_ERR_NONE;
 80051c0:	8002      	strh	r2, [r0, #0]
}
 80051c2:	4770      	bx	lr
    if (OSCfg_MsgPoolBasePtr == (OS_MSG *)0) {
       *p_err = OS_ERR_MSG_POOL_NULL_PTR;
        return;
    }
    if (OSCfg_MsgPoolSize == (OS_MSG_QTY)0) {
       *p_err = OS_ERR_MSG_POOL_EMPTY;
 80051c4:	f245 731d 	movw	r3, #22301	; 0x571d
    OSMsgPool.NextPtr    =  OSCfg_MsgPoolBasePtr;
    OSMsgPool.NbrFree    =  OSCfg_MsgPoolSize;
    OSMsgPool.NbrUsed    = (OS_MSG_QTY)0;
    OSMsgPool.NbrUsedMax = (OS_MSG_QTY)0;
   *p_err                =  OS_ERR_NONE;
}
 80051c8:	bc70      	pop	{r4, r5, r6}
    if (OSCfg_MsgPoolBasePtr == (OS_MSG *)0) {
       *p_err = OS_ERR_MSG_POOL_NULL_PTR;
        return;
    }
    if (OSCfg_MsgPoolSize == (OS_MSG_QTY)0) {
       *p_err = OS_ERR_MSG_POOL_EMPTY;
 80051ca:	8003      	strh	r3, [r0, #0]
    OSMsgPool.NextPtr    =  OSCfg_MsgPoolBasePtr;
    OSMsgPool.NbrFree    =  OSCfg_MsgPoolSize;
    OSMsgPool.NbrUsed    = (OS_MSG_QTY)0;
    OSMsgPool.NbrUsedMax = (OS_MSG_QTY)0;
   *p_err                =  OS_ERR_NONE;
}
 80051cc:	4770      	bx	lr
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (OSCfg_MsgPoolBasePtr == (OS_MSG *)0) {
       *p_err = OS_ERR_MSG_POOL_NULL_PTR;
 80051ce:	f245 731e 	movw	r3, #22302	; 0x571e
    OSMsgPool.NextPtr    =  OSCfg_MsgPoolBasePtr;
    OSMsgPool.NbrFree    =  OSCfg_MsgPoolSize;
    OSMsgPool.NbrUsed    = (OS_MSG_QTY)0;
    OSMsgPool.NbrUsedMax = (OS_MSG_QTY)0;
   *p_err                =  OS_ERR_NONE;
}
 80051d2:	bc70      	pop	{r4, r5, r6}
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (OSCfg_MsgPoolBasePtr == (OS_MSG *)0) {
       *p_err = OS_ERR_MSG_POOL_NULL_PTR;
 80051d4:	8003      	strh	r3, [r0, #0]
    OSMsgPool.NextPtr    =  OSCfg_MsgPoolBasePtr;
    OSMsgPool.NbrFree    =  OSCfg_MsgPoolSize;
    OSMsgPool.NbrUsed    = (OS_MSG_QTY)0;
    OSMsgPool.NbrUsedMax = (OS_MSG_QTY)0;
   *p_err                =  OS_ERR_NONE;
}
 80051d6:	4770      	bx	lr

    p_msg1 = OSCfg_MsgPoolBasePtr;
    p_msg2 = OSCfg_MsgPoolBasePtr;
    p_msg2++;
    loops  = OSCfg_MsgPoolSize - 1u;
    for (i = 0u; i < loops; i++) {                          /* Init. list of free OS_MSGs                             */
 80051d8:	462b      	mov	r3, r5
 80051da:	e7e6      	b.n	80051aa <OS_MsgPoolInit+0x3e>
 80051dc:	080160ec 	.word	0x080160ec
 80051e0:	080160f4 	.word	0x080160f4
 80051e4:	2000ee4c 	.word	0x2000ee4c

080051e8 <OS_MsgQFreeAll>:
* Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
************************************************************************************************************************
*/

OS_MSG_QTY  OS_MsgQFreeAll (OS_MSG_Q  *p_msg_q)
{
 80051e8:	4603      	mov	r3, r0
    OS_MSG      *p_msg;
    OS_MSG_QTY   qty;



    qty = p_msg_q->NbrEntries;                              /* Get the number of OS_MSGs being freed                  */
 80051ea:	8940      	ldrh	r0, [r0, #10]
    if (p_msg_q->NbrEntries > (OS_MSG_QTY)0) {
 80051ec:	b190      	cbz	r0, 8005214 <OS_MsgQFreeAll+0x2c>
        p_msg                   = p_msg_q->InPtr;           /* Point to end of message chain                          */
        p_msg->NextPtr          = OSMsgPool.NextPtr;
 80051ee:	4a0a      	ldr	r2, [pc, #40]	; (8005218 <OS_MsgQFreeAll+0x30>)
* Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
************************************************************************************************************************
*/

OS_MSG_QTY  OS_MsgQFreeAll (OS_MSG_Q  *p_msg_q)
{
 80051f0:	b4f0      	push	{r4, r5, r6, r7}


    qty = p_msg_q->NbrEntries;                              /* Get the number of OS_MSGs being freed                  */
    if (p_msg_q->NbrEntries > (OS_MSG_QTY)0) {
        p_msg                   = p_msg_q->InPtr;           /* Point to end of message chain                          */
        p_msg->NextPtr          = OSMsgPool.NextPtr;
 80051f2:	6819      	ldr	r1, [r3, #0]
        OSMsgPool.NextPtr       = p_msg_q->OutPtr;          /* Point to beginning of message chain                    */
        OSMsgPool.NbrUsed      -= p_msg_q->NbrEntries;      /* Update statistics for free list of messages            */
 80051f4:	88d5      	ldrh	r5, [r2, #6]
        OSMsgPool.NbrFree      += p_msg_q->NbrEntries;
 80051f6:	8894      	ldrh	r4, [r2, #4]


    qty = p_msg_q->NbrEntries;                              /* Get the number of OS_MSGs being freed                  */
    if (p_msg_q->NbrEntries > (OS_MSG_QTY)0) {
        p_msg                   = p_msg_q->InPtr;           /* Point to end of message chain                          */
        p_msg->NextPtr          = OSMsgPool.NextPtr;
 80051f8:	6816      	ldr	r6, [r2, #0]
        OSMsgPool.NextPtr       = p_msg_q->OutPtr;          /* Point to beginning of message chain                    */
 80051fa:	685f      	ldr	r7, [r3, #4]
        OSMsgPool.NbrUsed      -= p_msg_q->NbrEntries;      /* Update statistics for free list of messages            */
 80051fc:	1a2d      	subs	r5, r5, r0


    qty = p_msg_q->NbrEntries;                              /* Get the number of OS_MSGs being freed                  */
    if (p_msg_q->NbrEntries > (OS_MSG_QTY)0) {
        p_msg                   = p_msg_q->InPtr;           /* Point to end of message chain                          */
        p_msg->NextPtr          = OSMsgPool.NextPtr;
 80051fe:	600e      	str	r6, [r1, #0]
        OSMsgPool.NextPtr       = p_msg_q->OutPtr;          /* Point to beginning of message chain                    */
        OSMsgPool.NbrUsed      -= p_msg_q->NbrEntries;      /* Update statistics for free list of messages            */
        OSMsgPool.NbrFree      += p_msg_q->NbrEntries;
 8005200:	4404      	add	r4, r0
        p_msg_q->NbrEntries     = (OS_MSG_QTY)0;            /* Flush the message queue                                */
 8005202:	2100      	movs	r1, #0
    qty = p_msg_q->NbrEntries;                              /* Get the number of OS_MSGs being freed                  */
    if (p_msg_q->NbrEntries > (OS_MSG_QTY)0) {
        p_msg                   = p_msg_q->InPtr;           /* Point to end of message chain                          */
        p_msg->NextPtr          = OSMsgPool.NextPtr;
        OSMsgPool.NextPtr       = p_msg_q->OutPtr;          /* Point to beginning of message chain                    */
        OSMsgPool.NbrUsed      -= p_msg_q->NbrEntries;      /* Update statistics for free list of messages            */
 8005204:	80d5      	strh	r5, [r2, #6]
        OSMsgPool.NbrFree      += p_msg_q->NbrEntries;
 8005206:	8094      	strh	r4, [r2, #4]

    qty = p_msg_q->NbrEntries;                              /* Get the number of OS_MSGs being freed                  */
    if (p_msg_q->NbrEntries > (OS_MSG_QTY)0) {
        p_msg                   = p_msg_q->InPtr;           /* Point to end of message chain                          */
        p_msg->NextPtr          = OSMsgPool.NextPtr;
        OSMsgPool.NextPtr       = p_msg_q->OutPtr;          /* Point to beginning of message chain                    */
 8005208:	6017      	str	r7, [r2, #0]
        OSMsgPool.NbrUsed      -= p_msg_q->NbrEntries;      /* Update statistics for free list of messages            */
        OSMsgPool.NbrFree      += p_msg_q->NbrEntries;
        p_msg_q->NbrEntries     = (OS_MSG_QTY)0;            /* Flush the message queue                                */
 800520a:	8159      	strh	r1, [r3, #10]
        p_msg_q->NbrEntriesMax  = (OS_MSG_QTY)0;
 800520c:	8199      	strh	r1, [r3, #12]
        p_msg_q->InPtr          = (OS_MSG   *)0;
 800520e:	6019      	str	r1, [r3, #0]
        p_msg_q->OutPtr         = (OS_MSG   *)0;
 8005210:	6059      	str	r1, [r3, #4]
    }
    return (qty);
}
 8005212:	bcf0      	pop	{r4, r5, r6, r7}
 8005214:	4770      	bx	lr
 8005216:	bf00      	nop
 8005218:	2000ee4c 	.word	0x2000ee4c

0800521c <OS_MsgQInit>:

void  OS_MsgQInit (OS_MSG_Q    *p_msg_q,
                   OS_MSG_QTY   size)
{
    p_msg_q->NbrEntriesSize = (OS_MSG_QTY)size;
    p_msg_q->NbrEntries     = (OS_MSG_QTY)0;
 800521c:	2300      	movs	r3, #0
*/

void  OS_MsgQInit (OS_MSG_Q    *p_msg_q,
                   OS_MSG_QTY   size)
{
    p_msg_q->NbrEntriesSize = (OS_MSG_QTY)size;
 800521e:	8101      	strh	r1, [r0, #8]
    p_msg_q->NbrEntries     = (OS_MSG_QTY)0;
 8005220:	8143      	strh	r3, [r0, #10]
    p_msg_q->NbrEntriesMax  = (OS_MSG_QTY)0;
 8005222:	8183      	strh	r3, [r0, #12]
    p_msg_q->InPtr          = (OS_MSG   *)0;
 8005224:	6003      	str	r3, [r0, #0]
    p_msg_q->OutPtr         = (OS_MSG   *)0;
 8005226:	6043      	str	r3, [r0, #4]
 8005228:	4770      	bx	lr
 800522a:	bf00      	nop

0800522c <OS_MsgQGet>:

void  *OS_MsgQGet (OS_MSG_Q     *p_msg_q,
                   OS_MSG_SIZE  *p_msg_size,
                   CPU_TS       *p_ts,
                   OS_ERR       *p_err)
{
 800522c:	b4f0      	push	{r4, r5, r6, r7}
        OS_SAFETY_CRITICAL_EXCEPTION();
        return ((void *)0);
    }
#endif

    if (p_msg_q->NbrEntries == (OS_MSG_QTY)0) {             /* Is the queue empty?                                    */
 800522e:	8944      	ldrh	r4, [r0, #10]
 8005230:	b1f4      	cbz	r4, 8005270 <OS_MsgQGet+0x44>
        }
       *p_err = OS_ERR_Q_EMPTY;
        return ((void *)0);
    }

    p_msg           = p_msg_q->OutPtr;                      /* No, get the next message to extract from the queue     */
 8005232:	6844      	ldr	r4, [r0, #4]
    p_void          = p_msg->MsgPtr;
   *p_msg_size      = p_msg->MsgSize;
 8005234:	8926      	ldrh	r6, [r4, #8]
       *p_err = OS_ERR_Q_EMPTY;
        return ((void *)0);
    }

    p_msg           = p_msg_q->OutPtr;                      /* No, get the next message to extract from the queue     */
    p_void          = p_msg->MsgPtr;
 8005236:	6865      	ldr	r5, [r4, #4]
   *p_msg_size      = p_msg->MsgSize;
 8005238:	800e      	strh	r6, [r1, #0]
    if (p_ts != (CPU_TS *)0) {
 800523a:	b10a      	cbz	r2, 8005240 <OS_MsgQGet+0x14>
       *p_ts  = p_msg->MsgTS;
 800523c:	68e1      	ldr	r1, [r4, #12]
 800523e:	6011      	str	r1, [r2, #0]
    }

    p_msg_q->OutPtr = p_msg->NextPtr;                       /* Point to next message to extract                       */
 8005240:	6822      	ldr	r2, [r4, #0]
 8005242:	6042      	str	r2, [r0, #4]

    if (p_msg_q->OutPtr == (OS_MSG *)0) {                   /* Are there any more messages in the queue?              */
 8005244:	b18a      	cbz	r2, 800526a <OS_MsgQGet+0x3e>
        p_msg_q->InPtr      = (OS_MSG   *)0;                /* No                                                     */
        p_msg_q->NbrEntries = (OS_MSG_QTY)0;
    } else {
        p_msg_q->NbrEntries--;                              /* Yes, One less message in the queue                     */
 8005246:	8942      	ldrh	r2, [r0, #10]
 8005248:	3a01      	subs	r2, #1
 800524a:	8142      	strh	r2, [r0, #10]
    }

    p_msg->NextPtr    = OSMsgPool.NextPtr;                  /* Return message control block to free list              */
 800524c:	4a0d      	ldr	r2, [pc, #52]	; (8005284 <OS_MsgQGet+0x58>)
    OSMsgPool.NextPtr = p_msg;
    OSMsgPool.NbrFree++;
    OSMsgPool.NbrUsed--;

   *p_err             = OS_ERR_NONE;
    return (p_void);
 800524e:	4628      	mov	r0, r5
        p_msg_q->NbrEntries--;                              /* Yes, One less message in the queue                     */
    }

    p_msg->NextPtr    = OSMsgPool.NextPtr;                  /* Return message control block to free list              */
    OSMsgPool.NextPtr = p_msg;
    OSMsgPool.NbrFree++;
 8005250:	8895      	ldrh	r5, [r2, #4]
    OSMsgPool.NbrUsed--;
 8005252:	88d1      	ldrh	r1, [r2, #6]
        p_msg_q->NbrEntries = (OS_MSG_QTY)0;
    } else {
        p_msg_q->NbrEntries--;                              /* Yes, One less message in the queue                     */
    }

    p_msg->NextPtr    = OSMsgPool.NextPtr;                  /* Return message control block to free list              */
 8005254:	6816      	ldr	r6, [r2, #0]
    OSMsgPool.NextPtr = p_msg;
    OSMsgPool.NbrFree++;
    OSMsgPool.NbrUsed--;

   *p_err             = OS_ERR_NONE;
 8005256:	2700      	movs	r7, #0
        p_msg_q->NbrEntries--;                              /* Yes, One less message in the queue                     */
    }

    p_msg->NextPtr    = OSMsgPool.NextPtr;                  /* Return message control block to free list              */
    OSMsgPool.NextPtr = p_msg;
    OSMsgPool.NbrFree++;
 8005258:	3501      	adds	r5, #1
    OSMsgPool.NbrUsed--;
 800525a:	3901      	subs	r1, #1
        p_msg_q->NbrEntries = (OS_MSG_QTY)0;
    } else {
        p_msg_q->NbrEntries--;                              /* Yes, One less message in the queue                     */
    }

    p_msg->NextPtr    = OSMsgPool.NextPtr;                  /* Return message control block to free list              */
 800525c:	6026      	str	r6, [r4, #0]
    OSMsgPool.NextPtr = p_msg;
    OSMsgPool.NbrFree++;
 800525e:	8095      	strh	r5, [r2, #4]
    } else {
        p_msg_q->NbrEntries--;                              /* Yes, One less message in the queue                     */
    }

    p_msg->NextPtr    = OSMsgPool.NextPtr;                  /* Return message control block to free list              */
    OSMsgPool.NextPtr = p_msg;
 8005260:	6014      	str	r4, [r2, #0]
    OSMsgPool.NbrFree++;
    OSMsgPool.NbrUsed--;
 8005262:	80d1      	strh	r1, [r2, #6]

   *p_err             = OS_ERR_NONE;
 8005264:	801f      	strh	r7, [r3, #0]
    return (p_void);
}
 8005266:	bcf0      	pop	{r4, r5, r6, r7}
 8005268:	4770      	bx	lr
    }

    p_msg_q->OutPtr = p_msg->NextPtr;                       /* Point to next message to extract                       */

    if (p_msg_q->OutPtr == (OS_MSG *)0) {                   /* Are there any more messages in the queue?              */
        p_msg_q->InPtr      = (OS_MSG   *)0;                /* No                                                     */
 800526a:	6002      	str	r2, [r0, #0]
        p_msg_q->NbrEntries = (OS_MSG_QTY)0;
 800526c:	8142      	strh	r2, [r0, #10]
 800526e:	e7ed      	b.n	800524c <OS_MsgQGet+0x20>
        return ((void *)0);
    }
#endif

    if (p_msg_q->NbrEntries == (OS_MSG_QTY)0) {             /* Is the queue empty?                                    */
       *p_msg_size = (OS_MSG_SIZE)0;                        /* Yes                                                    */
 8005270:	800c      	strh	r4, [r1, #0]
        if (p_ts != (CPU_TS *)0) {
 8005272:	b102      	cbz	r2, 8005276 <OS_MsgQGet+0x4a>
           *p_ts  = (CPU_TS  )0;
 8005274:	6014      	str	r4, [r2, #0]
        }
       *p_err = OS_ERR_Q_EMPTY;
 8005276:	f246 5292 	movw	r2, #26002	; 0x6592
    OSMsgPool.NbrFree++;
    OSMsgPool.NbrUsed--;

   *p_err             = OS_ERR_NONE;
    return (p_void);
}
 800527a:	bcf0      	pop	{r4, r5, r6, r7}
       *p_msg_size = (OS_MSG_SIZE)0;                        /* Yes                                                    */
        if (p_ts != (CPU_TS *)0) {
           *p_ts  = (CPU_TS  )0;
        }
       *p_err = OS_ERR_Q_EMPTY;
        return ((void *)0);
 800527c:	2000      	movs	r0, #0
    if (p_msg_q->NbrEntries == (OS_MSG_QTY)0) {             /* Is the queue empty?                                    */
       *p_msg_size = (OS_MSG_SIZE)0;                        /* Yes                                                    */
        if (p_ts != (CPU_TS *)0) {
           *p_ts  = (CPU_TS  )0;
        }
       *p_err = OS_ERR_Q_EMPTY;
 800527e:	801a      	strh	r2, [r3, #0]
    OSMsgPool.NbrFree++;
    OSMsgPool.NbrUsed--;

   *p_err             = OS_ERR_NONE;
    return (p_void);
}
 8005280:	4770      	bx	lr
 8005282:	bf00      	nop
 8005284:	2000ee4c 	.word	0x2000ee4c

08005288 <OS_MsgQPut>:
                  void         *p_void,
                  OS_MSG_SIZE   msg_size,
                  OS_OPT        opt,
                  CPU_TS        ts,
                  OS_ERR       *p_err)
{
 8005288:	b5f0      	push	{r4, r5, r6, r7, lr}
        OS_SAFETY_CRITICAL_EXCEPTION();
        return;
    }
#endif

    if (p_msg_q->NbrEntries >= p_msg_q->NbrEntriesSize) {
 800528a:	8945      	ldrh	r5, [r0, #10]
 800528c:	8904      	ldrh	r4, [r0, #8]
 800528e:	42ac      	cmp	r4, r5
 8005290:	d934      	bls.n	80052fc <OS_MsgQPut+0x74>
       *p_err = OS_ERR_Q_MAX;                               /* Message queue cannot accept any more messages          */
        return;
    }

    if (OSMsgPool.NbrFree == (OS_MSG_QTY)0) {
 8005292:	4c22      	ldr	r4, [pc, #136]	; (800531c <OS_MsgQPut+0x94>)
 8005294:	f8b4 e004 	ldrh.w	lr, [r4, #4]
 8005298:	f1be 0f00 	cmp.w	lr, #0
 800529c:	d029      	beq.n	80052f2 <OS_MsgQPut+0x6a>
       *p_err = OS_ERR_MSG_POOL_EMPTY;                      /* No more OS_MSG to use                                  */
        return;
    }

    p_msg             = OSMsgPool.NextPtr;                  /* Remove message control block from free list            */
 800529e:	6826      	ldr	r6, [r4, #0]
    OSMsgPool.NextPtr = p_msg->NextPtr;
    OSMsgPool.NbrFree--;
    OSMsgPool.NbrUsed++;
 80052a0:	f8b4 c006 	ldrh.w	ip, [r4, #6]
       *p_err = OS_ERR_MSG_POOL_EMPTY;                      /* No more OS_MSG to use                                  */
        return;
    }

    p_msg             = OSMsgPool.NextPtr;                  /* Remove message control block from free list            */
    OSMsgPool.NextPtr = p_msg->NextPtr;
 80052a4:	6837      	ldr	r7, [r6, #0]
    OSMsgPool.NbrFree--;
 80052a6:	f10e 3eff 	add.w	lr, lr, #4294967295
       *p_err = OS_ERR_MSG_POOL_EMPTY;                      /* No more OS_MSG to use                                  */
        return;
    }

    p_msg             = OSMsgPool.NextPtr;                  /* Remove message control block from free list            */
    OSMsgPool.NextPtr = p_msg->NextPtr;
 80052aa:	6027      	str	r7, [r4, #0]
    OSMsgPool.NbrFree--;
 80052ac:	f8a4 e004 	strh.w	lr, [r4, #4]
    OSMsgPool.NbrUsed++;
 80052b0:	f10c 0701 	add.w	r7, ip, #1
    if (OSMsgPool.NbrUsedMax < OSMsgPool.NbrUsed) {
 80052b4:	f8b4 e008 	ldrh.w	lr, [r4, #8]
    }

    p_msg             = OSMsgPool.NextPtr;                  /* Remove message control block from free list            */
    OSMsgPool.NextPtr = p_msg->NextPtr;
    OSMsgPool.NbrFree--;
    OSMsgPool.NbrUsed++;
 80052b8:	b2bf      	uxth	r7, r7
    if (OSMsgPool.NbrUsedMax < OSMsgPool.NbrUsed) {
 80052ba:	45be      	cmp	lr, r7
    }

    p_msg             = OSMsgPool.NextPtr;                  /* Remove message control block from free list            */
    OSMsgPool.NextPtr = p_msg->NextPtr;
    OSMsgPool.NbrFree--;
    OSMsgPool.NbrUsed++;
 80052bc:	80e7      	strh	r7, [r4, #6]
    if (OSMsgPool.NbrUsedMax < OSMsgPool.NbrUsed) {
        OSMsgPool.NbrUsedMax = OSMsgPool.NbrUsed;
 80052be:	bf38      	it	cc
 80052c0:	8127      	strhcc	r7, [r4, #8]
    }

    if (p_msg_q->NbrEntries == (OS_MSG_QTY)0) {             /* Is this first message placed in the queue?             */
 80052c2:	b305      	cbz	r5, 8005306 <OS_MsgQPut+0x7e>
        p_msg_q->InPtr         = p_msg;                     /* Yes                                                    */
        p_msg_q->OutPtr        = p_msg;
        p_msg_q->NbrEntries    = (OS_MSG_QTY)1;
        p_msg->NextPtr         = (OS_MSG *)0;
    } else {                                                /* No                                                     */
        if ((opt & OS_OPT_POST_LIFO) == OS_OPT_POST_FIFO) { /* Is it FIFO or LIFO?                                    */
 80052c4:	f003 0310 	and.w	r3, r3, #16
 80052c8:	b29b      	uxth	r3, r3
 80052ca:	bb13      	cbnz	r3, 8005312 <OS_MsgQPut+0x8a>
            p_msg_in           = p_msg_q->InPtr;            /* FIFO, add to the head                                  */
            p_msg_in->NextPtr  = p_msg;
 80052cc:	6804      	ldr	r4, [r0, #0]
 80052ce:	6026      	str	r6, [r4, #0]
            p_msg_q->InPtr     = p_msg;
 80052d0:	6006      	str	r6, [r0, #0]
            p_msg->NextPtr     = (OS_MSG *)0;
 80052d2:	6033      	str	r3, [r6, #0]
        } else {
            p_msg->NextPtr     = p_msg_q->OutPtr;           /* LIFO, add to the tail                                  */
            p_msg_q->OutPtr    = p_msg;
        }
        p_msg_q->NbrEntries++;
 80052d4:	3501      	adds	r5, #1
 80052d6:	b2ab      	uxth	r3, r5
 80052d8:	8143      	strh	r3, [r0, #10]
    }
    if (p_msg_q->NbrEntriesMax < p_msg_q->NbrEntries) {
 80052da:	8984      	ldrh	r4, [r0, #12]
 80052dc:	429c      	cmp	r4, r3
        p_msg_q->NbrEntriesMax = p_msg_q->NbrEntries;
 80052de:	bf38      	it	cc
 80052e0:	8183      	strhcc	r3, [r0, #12]
    }
    p_msg->MsgPtr  = p_void;                                /* Deposit message in the message queue entry             */
    p_msg->MsgSize = msg_size;
 80052e2:	8132      	strh	r2, [r6, #8]
    p_msg->MsgTS   = ts;
 80052e4:	9a05      	ldr	r2, [sp, #20]
   *p_err          = OS_ERR_NONE;
 80052e6:	2300      	movs	r3, #0
    if (p_msg_q->NbrEntriesMax < p_msg_q->NbrEntries) {
        p_msg_q->NbrEntriesMax = p_msg_q->NbrEntries;
    }
    p_msg->MsgPtr  = p_void;                                /* Deposit message in the message queue entry             */
    p_msg->MsgSize = msg_size;
    p_msg->MsgTS   = ts;
 80052e8:	60f2      	str	r2, [r6, #12]
   *p_err          = OS_ERR_NONE;
 80052ea:	9a06      	ldr	r2, [sp, #24]
        p_msg_q->NbrEntries++;
    }
    if (p_msg_q->NbrEntriesMax < p_msg_q->NbrEntries) {
        p_msg_q->NbrEntriesMax = p_msg_q->NbrEntries;
    }
    p_msg->MsgPtr  = p_void;                                /* Deposit message in the message queue entry             */
 80052ec:	6071      	str	r1, [r6, #4]
    p_msg->MsgSize = msg_size;
    p_msg->MsgTS   = ts;
   *p_err          = OS_ERR_NONE;
 80052ee:	8013      	strh	r3, [r2, #0]
 80052f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
       *p_err = OS_ERR_Q_MAX;                               /* Message queue cannot accept any more messages          */
        return;
    }

    if (OSMsgPool.NbrFree == (OS_MSG_QTY)0) {
       *p_err = OS_ERR_MSG_POOL_EMPTY;                      /* No more OS_MSG to use                                  */
 80052f2:	f245 731d 	movw	r3, #22301	; 0x571d
 80052f6:	9a06      	ldr	r2, [sp, #24]
 80052f8:	8013      	strh	r3, [r2, #0]
        return;
 80052fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return;
    }
#endif

    if (p_msg_q->NbrEntries >= p_msg_q->NbrEntriesSize) {
       *p_err = OS_ERR_Q_MAX;                               /* Message queue cannot accept any more messages          */
 80052fc:	f246 5393 	movw	r3, #26003	; 0x6593
 8005300:	9a06      	ldr	r2, [sp, #24]
 8005302:	8013      	strh	r3, [r2, #0]
        return;
 8005304:	bdf0      	pop	{r4, r5, r6, r7, pc}
    }

    if (p_msg_q->NbrEntries == (OS_MSG_QTY)0) {             /* Is this first message placed in the queue?             */
        p_msg_q->InPtr         = p_msg;                     /* Yes                                                    */
        p_msg_q->OutPtr        = p_msg;
        p_msg_q->NbrEntries    = (OS_MSG_QTY)1;
 8005306:	2301      	movs	r3, #1
    if (OSMsgPool.NbrUsedMax < OSMsgPool.NbrUsed) {
        OSMsgPool.NbrUsedMax = OSMsgPool.NbrUsed;
    }

    if (p_msg_q->NbrEntries == (OS_MSG_QTY)0) {             /* Is this first message placed in the queue?             */
        p_msg_q->InPtr         = p_msg;                     /* Yes                                                    */
 8005308:	6006      	str	r6, [r0, #0]
        p_msg_q->OutPtr        = p_msg;
 800530a:	6046      	str	r6, [r0, #4]
        p_msg_q->NbrEntries    = (OS_MSG_QTY)1;
 800530c:	8143      	strh	r3, [r0, #10]
        p_msg->NextPtr         = (OS_MSG *)0;
 800530e:	6035      	str	r5, [r6, #0]
 8005310:	e7e3      	b.n	80052da <OS_MsgQPut+0x52>
            p_msg_in           = p_msg_q->InPtr;            /* FIFO, add to the head                                  */
            p_msg_in->NextPtr  = p_msg;
            p_msg_q->InPtr     = p_msg;
            p_msg->NextPtr     = (OS_MSG *)0;
        } else {
            p_msg->NextPtr     = p_msg_q->OutPtr;           /* LIFO, add to the tail                                  */
 8005312:	6843      	ldr	r3, [r0, #4]
 8005314:	6033      	str	r3, [r6, #0]
            p_msg_q->OutPtr    = p_msg;
 8005316:	6046      	str	r6, [r0, #4]
 8005318:	e7dc      	b.n	80052d4 <OS_MsgQPut+0x4c>
 800531a:	bf00      	nop
 800531c:	2000ee4c 	.word	0x2000ee4c

08005320 <OSMutexCreate>:
*/

void  OSMutexCreate (OS_MUTEX  *p_mutex,
                     CPU_CHAR  *p_name,
                     OS_ERR    *p_err)
{
 8005320:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
        return;
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to be called from an ISR                   */
 8005324:	4b1a      	ldr	r3, [pc, #104]	; (8005390 <OSMutexCreate+0x70>)
 8005326:	781e      	ldrb	r6, [r3, #0]
 8005328:	bb46      	cbnz	r6, 800537c <OSMutexCreate+0x5c>
        return;
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_mutex == (OS_MUTEX *)0) {                         /* Validate 'p_mutex'                                     */
 800532a:	b360      	cbz	r0, 8005386 <OSMutexCreate+0x66>
 800532c:	4604      	mov	r4, r0
 800532e:	460d      	mov	r5, r1
 8005330:	4617      	mov	r7, r2
       *p_err = OS_ERR_OBJ_PTR_NULL;
        return;
    }
#endif

    OS_CRITICAL_ENTER();
 8005332:	f7fc fa1f 	bl	8001774 <CPU_SR_Save>
    p_mutex->Type              =  OS_OBJ_TYPE_MUTEX;        /* Mark the data structure as a mutex                     */
 8005336:	4a17      	ldr	r2, [pc, #92]	; (8005394 <OSMutexCreate+0x74>)
    p_mutex->NamePtr           =  p_name;
    p_mutex->OwnerTCBPtr       = (OS_TCB       *)0;
    p_mutex->OwnerNestingCtr   = (OS_NESTING_CTR)0;         /* Mutex is available                                     */
    p_mutex->TS                = (CPU_TS        )0;
    p_mutex->OwnerOriginalPrio =  OS_CFG_PRIO_MAX;
 8005338:	233f      	movs	r3, #63	; 0x3f
        return;
    }
#endif

    OS_CRITICAL_ENTER();
    p_mutex->Type              =  OS_OBJ_TYPE_MUTEX;        /* Mark the data structure as a mutex                     */
 800533a:	6022      	str	r2, [r4, #0]
    p_mutex->NamePtr           =  p_name;
    p_mutex->OwnerTCBPtr       = (OS_TCB       *)0;
    p_mutex->OwnerNestingCtr   = (OS_NESTING_CTR)0;         /* Mutex is available                                     */
    p_mutex->TS                = (CPU_TS        )0;
    p_mutex->OwnerOriginalPrio =  OS_CFG_PRIO_MAX;
 800533c:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
       *p_err = OS_ERR_OBJ_PTR_NULL;
        return;
    }
#endif

    OS_CRITICAL_ENTER();
 8005340:	4680      	mov	r8, r0
    p_mutex->Type              =  OS_OBJ_TYPE_MUTEX;        /* Mark the data structure as a mutex                     */
    p_mutex->NamePtr           =  p_name;
 8005342:	6065      	str	r5, [r4, #4]
    p_mutex->OwnerTCBPtr       = (OS_TCB       *)0;
 8005344:	6226      	str	r6, [r4, #32]
    p_mutex->OwnerNestingCtr   = (OS_NESTING_CTR)0;         /* Mutex is available                                     */
 8005346:	f884 6025 	strb.w	r6, [r4, #37]	; 0x25
    p_mutex->TS                = (CPU_TS        )0;
 800534a:	62a6      	str	r6, [r4, #40]	; 0x28
    p_mutex->OwnerOriginalPrio =  OS_CFG_PRIO_MAX;
    OS_PendListInit(&p_mutex->PendList);                    /* Initialize the waiting list                            */
 800534c:	f104 0008 	add.w	r0, r4, #8
 8005350:	f7fe fe04 	bl	8003f5c <OS_PendListInit>
#if OS_CFG_DBG_EN > 0u
void  OS_MutexDbgListAdd (OS_MUTEX  *p_mutex)
{
    p_mutex->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
    p_mutex->DbgPrevPtr               = (OS_MUTEX *)0;
    if (OSMutexDbgListPtr == (OS_MUTEX *)0) {
 8005354:	4910      	ldr	r1, [pc, #64]	; (8005398 <OSMutexCreate+0x78>)


#if OS_CFG_DBG_EN > 0u
void  OS_MutexDbgListAdd (OS_MUTEX  *p_mutex)
{
    p_mutex->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
 8005356:	4a11      	ldr	r2, [pc, #68]	; (800539c <OSMutexCreate+0x7c>)
    p_mutex->DbgPrevPtr               = (OS_MUTEX *)0;
    if (OSMutexDbgListPtr == (OS_MUTEX *)0) {
 8005358:	680b      	ldr	r3, [r1, #0]

#if OS_CFG_DBG_EN > 0u
void  OS_MutexDbgListAdd (OS_MUTEX  *p_mutex)
{
    p_mutex->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
    p_mutex->DbgPrevPtr               = (OS_MUTEX *)0;
 800535a:	6166      	str	r6, [r4, #20]


#if OS_CFG_DBG_EN > 0u
void  OS_MutexDbgListAdd (OS_MUTEX  *p_mutex)
{
    p_mutex->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
 800535c:	61e2      	str	r2, [r4, #28]
    p_mutex->DbgPrevPtr               = (OS_MUTEX *)0;
    if (OSMutexDbgListPtr == (OS_MUTEX *)0) {
        p_mutex->DbgNextPtr           = (OS_MUTEX *)0;
 800535e:	61a3      	str	r3, [r4, #24]
#if OS_CFG_DBG_EN > 0u
void  OS_MutexDbgListAdd (OS_MUTEX  *p_mutex)
{
    p_mutex->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
    p_mutex->DbgPrevPtr               = (OS_MUTEX *)0;
    if (OSMutexDbgListPtr == (OS_MUTEX *)0) {
 8005360:	b103      	cbz	r3, 8005364 <OSMutexCreate+0x44>
        p_mutex->DbgNextPtr           = (OS_MUTEX *)0;
    } else {
        p_mutex->DbgNextPtr           =  OSMutexDbgListPtr;
        OSMutexDbgListPtr->DbgPrevPtr =  p_mutex;
 8005362:	615c      	str	r4, [r3, #20]
    OS_PendListInit(&p_mutex->PendList);                    /* Initialize the waiting list                            */

#if OS_CFG_DBG_EN > 0u
    OS_MutexDbgListAdd(p_mutex);
#endif
    OSMutexQty++;
 8005364:	4a0e      	ldr	r2, [pc, #56]	; (80053a0 <OSMutexCreate+0x80>)

    OS_CRITICAL_EXIT_NO_SCHED();
 8005366:	4640      	mov	r0, r8
    OS_PendListInit(&p_mutex->PendList);                    /* Initialize the waiting list                            */

#if OS_CFG_DBG_EN > 0u
    OS_MutexDbgListAdd(p_mutex);
#endif
    OSMutexQty++;
 8005368:	8813      	ldrh	r3, [r2, #0]
        p_mutex->DbgNextPtr           = (OS_MUTEX *)0;
    } else {
        p_mutex->DbgNextPtr           =  OSMutexDbgListPtr;
        OSMutexDbgListPtr->DbgPrevPtr =  p_mutex;
    }
    OSMutexDbgListPtr                 =  p_mutex;
 800536a:	600c      	str	r4, [r1, #0]
    OS_PendListInit(&p_mutex->PendList);                    /* Initialize the waiting list                            */

#if OS_CFG_DBG_EN > 0u
    OS_MutexDbgListAdd(p_mutex);
#endif
    OSMutexQty++;
 800536c:	3301      	adds	r3, #1
 800536e:	8013      	strh	r3, [r2, #0]

    OS_CRITICAL_EXIT_NO_SCHED();
 8005370:	f7fc fa04 	bl	800177c <CPU_SR_Restore>
   *p_err = OS_ERR_NONE;
 8005374:	2300      	movs	r3, #0
 8005376:	803b      	strh	r3, [r7, #0]
 8005378:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to be called from an ISR                   */
       *p_err = OS_ERR_CREATE_ISR;
 800537c:	f642 63e1 	movw	r3, #12001	; 0x2ee1
 8005380:	8013      	strh	r3, [r2, #0]
        return;
 8005382:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_mutex == (OS_MUTEX *)0) {                         /* Validate 'p_mutex'                                     */
       *p_err = OS_ERR_OBJ_PTR_NULL;
 8005386:	f645 53c3 	movw	r3, #24003	; 0x5dc3
 800538a:	8013      	strh	r3, [r2, #0]
        return;
 800538c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005390:	2000ed84 	.word	0x2000ed84
 8005394:	5854554d 	.word	0x5854554d
 8005398:	2000f034 	.word	0x2000f034
 800539c:	080182f0 	.word	0x080182f0
 80053a0:	2000ef5c 	.word	0x2000ef5c

080053a4 <OSMutexPend>:
void  OSMutexPend (OS_MUTEX  *p_mutex,
                   OS_TICK    timeout,
                   OS_OPT     opt,
                   CPU_TS    *p_ts,
                   OS_ERR    *p_err)
{
 80053a4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
        return;
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
 80053a8:	4c82      	ldr	r4, [pc, #520]	; (80055b4 <OSMutexPend+0x210>)
void  OSMutexPend (OS_MUTEX  *p_mutex,
                   OS_TICK    timeout,
                   OS_OPT     opt,
                   CPU_TS    *p_ts,
                   OS_ERR    *p_err)
{
 80053aa:	b08b      	sub	sp, #44	; 0x2c
        return;
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
 80053ac:	7824      	ldrb	r4, [r4, #0]
 80053ae:	b134      	cbz	r4, 80053be <OSMutexPend+0x1a>
       *p_err = OS_ERR_PEND_ISR;
 80053b0:	f246 13ae 	movw	r3, #25006	; 0x61ae
 80053b4:	9a12      	ldr	r2, [sp, #72]	; 0x48
 80053b6:	8013      	strh	r3, [r2, #0]
        default:
            *p_err = OS_ERR_STATUS_INVALID;
             break;
    }
    CPU_CRITICAL_EXIT();
}
 80053b8:	b00b      	add	sp, #44	; 0x2c
 80053ba:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        return;
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_mutex == (OS_MUTEX *)0) {                         /* Validate arguments                                     */
 80053be:	b1a8      	cbz	r0, 80053ec <OSMutexPend+0x48>
       *p_err = OS_ERR_OBJ_PTR_NULL;
        return;
    }
    switch (opt) {                                          /* Validate 'opt'                                         */
 80053c0:	b14a      	cbz	r2, 80053d6 <OSMutexPend+0x32>
 80053c2:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
 80053c6:	d006      	beq.n	80053d6 <OSMutexPend+0x32>
        case OS_OPT_PEND_BLOCKING:
        case OS_OPT_PEND_NON_BLOCKING:
             break;

        default:
            *p_err = OS_ERR_OPT_INVALID;
 80053c8:	f645 6325 	movw	r3, #24101	; 0x5e25
 80053cc:	9a12      	ldr	r2, [sp, #72]	; 0x48
 80053ce:	8013      	strh	r3, [r2, #0]
        default:
            *p_err = OS_ERR_STATUS_INVALID;
             break;
    }
    CPU_CRITICAL_EXIT();
}
 80053d0:	b00b      	add	sp, #44	; 0x2c
 80053d2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
             return;
    }
#endif

#if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    if (p_mutex->Type != OS_OBJ_TYPE_MUTEX) {               /* Make sure mutex was created                            */
 80053d6:	4c78      	ldr	r4, [pc, #480]	; (80055b8 <OSMutexPend+0x214>)
 80053d8:	6805      	ldr	r5, [r0, #0]
 80053da:	42a5      	cmp	r5, r4
 80053dc:	d00b      	beq.n	80053f6 <OSMutexPend+0x52>
       *p_err = OS_ERR_OBJ_TYPE;
 80053de:	f645 53c4 	movw	r3, #24004	; 0x5dc4
 80053e2:	9a12      	ldr	r2, [sp, #72]	; 0x48
 80053e4:	8013      	strh	r3, [r2, #0]
        default:
            *p_err = OS_ERR_STATUS_INVALID;
             break;
    }
    CPU_CRITICAL_EXIT();
}
 80053e6:	b00b      	add	sp, #44	; 0x2c
 80053e8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_mutex == (OS_MUTEX *)0) {                         /* Validate arguments                                     */
       *p_err = OS_ERR_OBJ_PTR_NULL;
 80053ec:	f645 53c3 	movw	r3, #24003	; 0x5dc3
 80053f0:	9a12      	ldr	r2, [sp, #72]	; 0x48
 80053f2:	8013      	strh	r3, [r2, #0]
        return;
 80053f4:	e7e0      	b.n	80053b8 <OSMutexPend+0x14>
 80053f6:	461f      	mov	r7, r3
 80053f8:	4615      	mov	r5, r2
 80053fa:	460e      	mov	r6, r1
 80053fc:	4604      	mov	r4, r0
       *p_err = OS_ERR_OBJ_TYPE;
        return;
    }
#endif

    if (p_ts != (CPU_TS *)0) {
 80053fe:	2b00      	cmp	r3, #0
 8005400:	d047      	beq.n	8005492 <OSMutexPend+0xee>
       *p_ts  = (CPU_TS  )0;                                /* Initialize the returned timestamp                      */
 8005402:	2300      	movs	r3, #0
 8005404:	603b      	str	r3, [r7, #0]
    }

    CPU_CRITICAL_ENTER();
 8005406:	f7fc f9b5 	bl	8001774 <CPU_SR_Save>
    if (p_mutex->OwnerNestingCtr == (OS_NESTING_CTR)0) {    /* Resource available?                                    */
 800540a:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25

    if (p_ts != (CPU_TS *)0) {
       *p_ts  = (CPU_TS  )0;                                /* Initialize the returned timestamp                      */
    }

    CPU_CRITICAL_ENTER();
 800540e:	4680      	mov	r8, r0
    if (p_mutex->OwnerNestingCtr == (OS_NESTING_CTR)0) {    /* Resource available?                                    */
 8005410:	b363      	cbz	r3, 800546c <OSMutexPend+0xc8>
        CPU_CRITICAL_EXIT();
       *p_err = OS_ERR_NONE;
        return;
    }

    if (OSTCBCurPtr == p_mutex->OwnerTCBPtr) {              /* See if current task is already the owner of the mutex  */
 8005412:	f8df 91ac 	ldr.w	r9, [pc, #428]	; 80055c0 <OSMutexPend+0x21c>
 8005416:	6a22      	ldr	r2, [r4, #32]
 8005418:	f8d9 1000 	ldr.w	r1, [r9]
 800541c:	4291      	cmp	r1, r2
 800541e:	f000 80ae 	beq.w	800557e <OSMutexPend+0x1da>
        CPU_CRITICAL_EXIT();
       *p_err = OS_ERR_MUTEX_OWNER;                         /* Indicate that current task already owns the mutex      */
        return;
    }

    if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {    /* Caller wants to block if not available?                */
 8005422:	042b      	lsls	r3, r5, #16
 8005424:	f100 80b1 	bmi.w	800558a <OSMutexPend+0x1e6>
        CPU_CRITICAL_EXIT();
       *p_err = OS_ERR_PEND_WOULD_BLOCK;                    /* No                                                     */
        return;
    } else {
        if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /* Can't pend when the scheduler is locked                */
 8005428:	4b64      	ldr	r3, [pc, #400]	; (80055bc <OSMutexPend+0x218>)
 800542a:	781b      	ldrb	r3, [r3, #0]
 800542c:	2b00      	cmp	r3, #0
 800542e:	f040 808b 	bne.w	8005548 <OSMutexPend+0x1a4>
        }
    }
                                                            /* Lock the scheduler/re-enable interrupts                */
    OS_CRITICAL_ENTER_CPU_EXIT();
    p_tcb = p_mutex->OwnerTCBPtr;                           /* Point to the TCB of the Mutex owner                    */
    if (p_tcb->Prio > OSTCBCurPtr->Prio) {                  /* See if mutex owner has a lower priority than current   */
 8005432:	f891 1037 	ldrb.w	r1, [r1, #55]	; 0x37
 8005436:	f892 3037 	ldrb.w	r3, [r2, #55]	; 0x37
 800543a:	428b      	cmp	r3, r1
 800543c:	d94c      	bls.n	80054d8 <OSMutexPend+0x134>
        switch (p_tcb->TaskState) {
 800543e:	f892 3036 	ldrb.w	r3, [r2, #54]	; 0x36
 8005442:	2b07      	cmp	r3, #7
 8005444:	d80a      	bhi.n	800545c <OSMutexPend+0xb8>
 8005446:	2001      	movs	r0, #1
 8005448:	4098      	lsls	r0, r3
 800544a:	f010 0fcc 	tst.w	r0, #204	; 0xcc
 800544e:	f040 80ac 	bne.w	80055aa <OSMutexPend+0x206>
 8005452:	f010 0f32 	tst.w	r0, #50	; 0x32
 8005456:	f040 80a0 	bne.w	800559a <OSMutexPend+0x1f6>
 800545a:	b363      	cbz	r3, 80054b6 <OSMutexPend+0x112>
                 OS_PendListChangePrio(p_tcb,
                                       OSTCBCurPtr->Prio);
                 break;

            default:
                 OS_CRITICAL_EXIT();
 800545c:	4640      	mov	r0, r8
 800545e:	f7fc f98d 	bl	800177c <CPU_SR_Restore>
                *p_err = OS_ERR_STATE_INVALID;
 8005462:	f646 632d 	movw	r3, #28205	; 0x6e2d
 8005466:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8005468:	8013      	strh	r3, [r2, #0]
                 return;
 800546a:	e7a5      	b.n	80053b8 <OSMutexPend+0x14>
       *p_ts  = (CPU_TS  )0;                                /* Initialize the returned timestamp                      */
    }

    CPU_CRITICAL_ENTER();
    if (p_mutex->OwnerNestingCtr == (OS_NESTING_CTR)0) {    /* Resource available?                                    */
        p_mutex->OwnerTCBPtr       =  OSTCBCurPtr;          /* Yes, caller may proceed                                */
 800546c:	4b54      	ldr	r3, [pc, #336]	; (80055c0 <OSMutexPend+0x21c>)
        p_mutex->OwnerOriginalPrio =  OSTCBCurPtr->Prio;
        p_mutex->OwnerNestingCtr   = (OS_NESTING_CTR)1;
        if (p_ts != (CPU_TS *)0) {
           *p_ts  = p_mutex->TS;
 800546e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
       *p_ts  = (CPU_TS  )0;                                /* Initialize the returned timestamp                      */
    }

    CPU_CRITICAL_ENTER();
    if (p_mutex->OwnerNestingCtr == (OS_NESTING_CTR)0) {    /* Resource available?                                    */
        p_mutex->OwnerTCBPtr       =  OSTCBCurPtr;          /* Yes, caller may proceed                                */
 8005470:	681b      	ldr	r3, [r3, #0]
        p_mutex->OwnerOriginalPrio =  OSTCBCurPtr->Prio;
        p_mutex->OwnerNestingCtr   = (OS_NESTING_CTR)1;
 8005472:	2101      	movs	r1, #1
       *p_ts  = (CPU_TS  )0;                                /* Initialize the returned timestamp                      */
    }

    CPU_CRITICAL_ENTER();
    if (p_mutex->OwnerNestingCtr == (OS_NESTING_CTR)0) {    /* Resource available?                                    */
        p_mutex->OwnerTCBPtr       =  OSTCBCurPtr;          /* Yes, caller may proceed                                */
 8005474:	6223      	str	r3, [r4, #32]
        p_mutex->OwnerOriginalPrio =  OSTCBCurPtr->Prio;
 8005476:	f893 3037 	ldrb.w	r3, [r3, #55]	; 0x37
        p_mutex->OwnerNestingCtr   = (OS_NESTING_CTR)1;
 800547a:	f884 1025 	strb.w	r1, [r4, #37]	; 0x25
    }

    CPU_CRITICAL_ENTER();
    if (p_mutex->OwnerNestingCtr == (OS_NESTING_CTR)0) {    /* Resource available?                                    */
        p_mutex->OwnerTCBPtr       =  OSTCBCurPtr;          /* Yes, caller may proceed                                */
        p_mutex->OwnerOriginalPrio =  OSTCBCurPtr->Prio;
 800547e:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
        p_mutex->OwnerNestingCtr   = (OS_NESTING_CTR)1;
        if (p_ts != (CPU_TS *)0) {
           *p_ts  = p_mutex->TS;
 8005482:	603a      	str	r2, [r7, #0]
        }
        CPU_CRITICAL_EXIT();
 8005484:	4640      	mov	r0, r8
 8005486:	f7fc f979 	bl	800177c <CPU_SR_Restore>
       *p_err = OS_ERR_NONE;
 800548a:	9a12      	ldr	r2, [sp, #72]	; 0x48
 800548c:	2300      	movs	r3, #0
 800548e:	8013      	strh	r3, [r2, #0]
        return;
 8005490:	e792      	b.n	80053b8 <OSMutexPend+0x14>

    if (p_ts != (CPU_TS *)0) {
       *p_ts  = (CPU_TS  )0;                                /* Initialize the returned timestamp                      */
    }

    CPU_CRITICAL_ENTER();
 8005492:	f7fc f96f 	bl	8001774 <CPU_SR_Save>
    if (p_mutex->OwnerNestingCtr == (OS_NESTING_CTR)0) {    /* Resource available?                                    */
 8005496:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25

    if (p_ts != (CPU_TS *)0) {
       *p_ts  = (CPU_TS  )0;                                /* Initialize the returned timestamp                      */
    }

    CPU_CRITICAL_ENTER();
 800549a:	4680      	mov	r8, r0
    if (p_mutex->OwnerNestingCtr == (OS_NESTING_CTR)0) {    /* Resource available?                                    */
 800549c:	2b00      	cmp	r3, #0
 800549e:	d15b      	bne.n	8005558 <OSMutexPend+0x1b4>
        p_mutex->OwnerTCBPtr       =  OSTCBCurPtr;          /* Yes, caller may proceed                                */
 80054a0:	4b47      	ldr	r3, [pc, #284]	; (80055c0 <OSMutexPend+0x21c>)
        p_mutex->OwnerOriginalPrio =  OSTCBCurPtr->Prio;
        p_mutex->OwnerNestingCtr   = (OS_NESTING_CTR)1;
 80054a2:	2201      	movs	r2, #1
       *p_ts  = (CPU_TS  )0;                                /* Initialize the returned timestamp                      */
    }

    CPU_CRITICAL_ENTER();
    if (p_mutex->OwnerNestingCtr == (OS_NESTING_CTR)0) {    /* Resource available?                                    */
        p_mutex->OwnerTCBPtr       =  OSTCBCurPtr;          /* Yes, caller may proceed                                */
 80054a4:	681b      	ldr	r3, [r3, #0]
 80054a6:	6223      	str	r3, [r4, #32]
        p_mutex->OwnerOriginalPrio =  OSTCBCurPtr->Prio;
 80054a8:	f893 3037 	ldrb.w	r3, [r3, #55]	; 0x37
        p_mutex->OwnerNestingCtr   = (OS_NESTING_CTR)1;
 80054ac:	f884 2025 	strb.w	r2, [r4, #37]	; 0x25
    }

    CPU_CRITICAL_ENTER();
    if (p_mutex->OwnerNestingCtr == (OS_NESTING_CTR)0) {    /* Resource available?                                    */
        p_mutex->OwnerTCBPtr       =  OSTCBCurPtr;          /* Yes, caller may proceed                                */
        p_mutex->OwnerOriginalPrio =  OSTCBCurPtr->Prio;
 80054b0:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
 80054b4:	e7e6      	b.n	8005484 <OSMutexPend+0xe0>
    OS_CRITICAL_ENTER_CPU_EXIT();
    p_tcb = p_mutex->OwnerTCBPtr;                           /* Point to the TCB of the Mutex owner                    */
    if (p_tcb->Prio > OSTCBCurPtr->Prio) {                  /* See if mutex owner has a lower priority than current   */
        switch (p_tcb->TaskState) {
            case OS_TASK_STATE_RDY:
                 OS_RdyListRemove(p_tcb);                   /* Remove from ready list at current priority             */
 80054b6:	4610      	mov	r0, r2
 80054b8:	9201      	str	r2, [sp, #4]
 80054ba:	f7fe ff47 	bl	800434c <OS_RdyListRemove>
                 p_tcb->Prio = OSTCBCurPtr->Prio;           /* Raise owner's priority                                 */
 80054be:	f8d9 3000 	ldr.w	r3, [r9]
 80054c2:	9a01      	ldr	r2, [sp, #4]
 80054c4:	f893 0037 	ldrb.w	r0, [r3, #55]	; 0x37
 80054c8:	f882 0037 	strb.w	r0, [r2, #55]	; 0x37
                 OS_PrioInsert(p_tcb->Prio);
 80054cc:	f000 f974 	bl	80057b8 <OS_PrioInsert>
                 OS_RdyListInsertHead(p_tcb);               /* Insert in ready list at new priority                   */
 80054d0:	9a01      	ldr	r2, [sp, #4]
 80054d2:	4610      	mov	r0, r2
 80054d4:	f7fe fe8a 	bl	80041ec <OS_RdyListInsertHead>
                *p_err = OS_ERR_STATE_INVALID;
                 return;
        }
    }

    OS_Pend(&pend_data,                                     /* Block task pending on Mutex                            */
 80054d8:	4633      	mov	r3, r6
 80054da:	2204      	movs	r2, #4
 80054dc:	4621      	mov	r1, r4
 80054de:	a802      	add	r0, sp, #8
 80054e0:	f7fe ffd2 	bl	8004488 <OS_Pend>
            (OS_PEND_OBJ *)((void *)p_mutex),
             OS_TASK_PEND_ON_MUTEX,
             timeout);

    OS_CRITICAL_EXIT_NO_SCHED();
 80054e4:	4640      	mov	r0, r8
 80054e6:	f7fc f949 	bl	800177c <CPU_SR_Restore>

    OSSched();                                              /* Find the next highest priority task ready to run       */
 80054ea:	f7fe fb1d 	bl	8003b28 <OSSched>

    CPU_CRITICAL_ENTER();
 80054ee:	f7fc f941 	bl	8001774 <CPU_SR_Save>
    switch (OSTCBCurPtr->PendStatus) {
 80054f2:	f8d9 2000 	ldr.w	r2, [r9]
 80054f6:	f892 3035 	ldrb.w	r3, [r2, #53]	; 0x35
 80054fa:	2b03      	cmp	r3, #3
 80054fc:	d850      	bhi.n	80055a0 <OSMutexPend+0x1fc>
 80054fe:	e8df f003 	tbb	[pc, r3]
 8005502:	141c      	.short	0x141c
 8005504:	020c      	.short	0x020c
             }
            *p_err = OS_ERR_PEND_ABORT;
             break;

        case OS_STATUS_PEND_TIMEOUT:                        /* Indicate that we didn't get mutex within timeout       */
             if (p_ts != (CPU_TS *)0) {
 8005506:	b10f      	cbz	r7, 800550c <OSMutexPend+0x168>
                *p_ts  = (CPU_TS  )0;
 8005508:	2300      	movs	r3, #0
 800550a:	603b      	str	r3, [r7, #0]
             }
            *p_err = OS_ERR_TIMEOUT;
 800550c:	f247 23d9 	movw	r3, #29401	; 0x72d9
 8005510:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8005512:	8013      	strh	r3, [r2, #0]

        default:
            *p_err = OS_ERR_STATUS_INVALID;
             break;
    }
    CPU_CRITICAL_EXIT();
 8005514:	f7fc f932 	bl	800177c <CPU_SR_Restore>
 8005518:	e74e      	b.n	80053b8 <OSMutexPend+0x14>
             }
            *p_err = OS_ERR_TIMEOUT;
             break;

        case OS_STATUS_PEND_DEL:                            /* Indicate that object pended on has been deleted        */
             if (p_ts != (CPU_TS *)0) {
 800551a:	b10f      	cbz	r7, 8005520 <OSMutexPend+0x17c>
                *p_ts  = OSTCBCurPtr->TS;
 800551c:	6c13      	ldr	r3, [r2, #64]	; 0x40
 800551e:	603b      	str	r3, [r7, #0]
             }
            *p_err = OS_ERR_OBJ_DEL;
 8005520:	f645 53c2 	movw	r3, #24002	; 0x5dc2
 8005524:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8005526:	8013      	strh	r3, [r2, #0]
             break;
 8005528:	e7f4      	b.n	8005514 <OSMutexPend+0x170>
             }
            *p_err = OS_ERR_NONE;
             break;

        case OS_STATUS_PEND_ABORT:                          /* Indicate that we aborted                               */
             if (p_ts != (CPU_TS *)0) {
 800552a:	b10f      	cbz	r7, 8005530 <OSMutexPend+0x18c>
                *p_ts  = OSTCBCurPtr->TS;
 800552c:	6c13      	ldr	r3, [r2, #64]	; 0x40
 800552e:	603b      	str	r3, [r7, #0]
             }
            *p_err = OS_ERR_PEND_ABORT;
 8005530:	f246 13a9 	movw	r3, #25001	; 0x61a9
 8005534:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8005536:	8013      	strh	r3, [r2, #0]
             break;
 8005538:	e7ec      	b.n	8005514 <OSMutexPend+0x170>
    OSSched();                                              /* Find the next highest priority task ready to run       */

    CPU_CRITICAL_ENTER();
    switch (OSTCBCurPtr->PendStatus) {
        case OS_STATUS_PEND_OK:                             /* We got the mutex                                       */
             if (p_ts != (CPU_TS *)0) {
 800553a:	b10f      	cbz	r7, 8005540 <OSMutexPend+0x19c>
                *p_ts  = OSTCBCurPtr->TS;
 800553c:	6c13      	ldr	r3, [r2, #64]	; 0x40
 800553e:	603b      	str	r3, [r7, #0]
             }
            *p_err = OS_ERR_NONE;
 8005540:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8005542:	2300      	movs	r3, #0
 8005544:	8013      	strh	r3, [r2, #0]
             break;
 8005546:	e7e5      	b.n	8005514 <OSMutexPend+0x170>
        CPU_CRITICAL_EXIT();
       *p_err = OS_ERR_PEND_WOULD_BLOCK;                    /* No                                                     */
        return;
    } else {
        if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /* Can't pend when the scheduler is locked                */
            CPU_CRITICAL_EXIT();
 8005548:	4640      	mov	r0, r8
 800554a:	f7fc f917 	bl	800177c <CPU_SR_Restore>
           *p_err = OS_ERR_SCHED_LOCKED;
 800554e:	f646 5363 	movw	r3, #28003	; 0x6d63
 8005552:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8005554:	8013      	strh	r3, [r2, #0]
            return;
 8005556:	e72f      	b.n	80053b8 <OSMutexPend+0x14>
        CPU_CRITICAL_EXIT();
       *p_err = OS_ERR_NONE;
        return;
    }

    if (OSTCBCurPtr == p_mutex->OwnerTCBPtr) {              /* See if current task is already the owner of the mutex  */
 8005558:	f8df 9064 	ldr.w	r9, [pc, #100]	; 80055c0 <OSMutexPend+0x21c>
 800555c:	6a22      	ldr	r2, [r4, #32]
 800555e:	f8d9 1000 	ldr.w	r1, [r9]
 8005562:	428a      	cmp	r2, r1
 8005564:	f47f af5d 	bne.w	8005422 <OSMutexPend+0x7e>
        p_mutex->OwnerNestingCtr++;
 8005568:	3301      	adds	r3, #1
 800556a:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25
        if (p_ts != (CPU_TS *)0) {
           *p_ts  = p_mutex->TS;
        }
        CPU_CRITICAL_EXIT();
 800556e:	4640      	mov	r0, r8
 8005570:	f7fc f904 	bl	800177c <CPU_SR_Restore>
       *p_err = OS_ERR_MUTEX_OWNER;                         /* Indicate that current task already owns the mutex      */
 8005574:	f245 7382 	movw	r3, #22402	; 0x5782
 8005578:	9a12      	ldr	r2, [sp, #72]	; 0x48
 800557a:	8013      	strh	r3, [r2, #0]
        return;
 800557c:	e71c      	b.n	80053b8 <OSMutexPend+0x14>
    }

    if (OSTCBCurPtr == p_mutex->OwnerTCBPtr) {              /* See if current task is already the owner of the mutex  */
        p_mutex->OwnerNestingCtr++;
        if (p_ts != (CPU_TS *)0) {
           *p_ts  = p_mutex->TS;
 800557e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
       *p_err = OS_ERR_NONE;
        return;
    }

    if (OSTCBCurPtr == p_mutex->OwnerTCBPtr) {              /* See if current task is already the owner of the mutex  */
        p_mutex->OwnerNestingCtr++;
 8005580:	3301      	adds	r3, #1
 8005582:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25
        if (p_ts != (CPU_TS *)0) {
           *p_ts  = p_mutex->TS;
 8005586:	603a      	str	r2, [r7, #0]
 8005588:	e7f1      	b.n	800556e <OSMutexPend+0x1ca>
       *p_err = OS_ERR_MUTEX_OWNER;                         /* Indicate that current task already owns the mutex      */
        return;
    }

    if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {    /* Caller wants to block if not available?                */
        CPU_CRITICAL_EXIT();
 800558a:	4640      	mov	r0, r8
 800558c:	f7fc f8f6 	bl	800177c <CPU_SR_Restore>
       *p_err = OS_ERR_PEND_WOULD_BLOCK;                    /* No                                                     */
 8005590:	f246 13b0 	movw	r3, #25008	; 0x61b0
 8005594:	9a12      	ldr	r2, [sp, #72]	; 0x48
 8005596:	8013      	strh	r3, [r2, #0]
        return;
 8005598:	e70e      	b.n	80053b8 <OSMutexPend+0x14>
                 break;

            case OS_TASK_STATE_DLY:
            case OS_TASK_STATE_DLY_SUSPENDED:
            case OS_TASK_STATE_SUSPENDED:
                 p_tcb->Prio = OSTCBCurPtr->Prio;           /* Only need to raise the owner's priority                */
 800559a:	f882 1037 	strb.w	r1, [r2, #55]	; 0x37
                 break;
 800559e:	e79b      	b.n	80054d8 <OSMutexPend+0x134>
             }
            *p_err = OS_ERR_OBJ_DEL;
             break;

        default:
            *p_err = OS_ERR_STATUS_INVALID;
 80055a0:	f646 632e 	movw	r3, #28206	; 0x6e2e
 80055a4:	9a12      	ldr	r2, [sp, #72]	; 0x48
 80055a6:	8013      	strh	r3, [r2, #0]
             break;
 80055a8:	e7b4      	b.n	8005514 <OSMutexPend+0x170>

            case OS_TASK_STATE_PEND:                        /* Change the position of the task in the wait list       */
            case OS_TASK_STATE_PEND_TIMEOUT:
            case OS_TASK_STATE_PEND_SUSPENDED:
            case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
                 OS_PendListChangePrio(p_tcb,
 80055aa:	4610      	mov	r0, r2
 80055ac:	f7fe fd1c 	bl	8003fe8 <OS_PendListChangePrio>
                                       OSTCBCurPtr->Prio);
                 break;
 80055b0:	e792      	b.n	80054d8 <OSMutexPend+0x134>
 80055b2:	bf00      	nop
 80055b4:	2000ed84 	.word	0x2000ed84
 80055b8:	5854554d 	.word	0x5854554d
 80055bc:	2000e974 	.word	0x2000e974
 80055c0:	2000ed58 	.word	0x2000ed58

080055c4 <OSMutexPost>:
*/

void  OSMutexPost (OS_MUTEX  *p_mutex,
                   OS_OPT     opt,
                   OS_ERR    *p_err)
{
 80055c4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
        return;
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
 80055c8:	4b44      	ldr	r3, [pc, #272]	; (80056dc <OSMutexPost+0x118>)
*/

void  OSMutexPost (OS_MUTEX  *p_mutex,
                   OS_OPT     opt,
                   OS_ERR    *p_err)
{
 80055ca:	b082      	sub	sp, #8
        return;
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
 80055cc:	781b      	ldrb	r3, [r3, #0]
 80055ce:	b9a3      	cbnz	r3, 80055fa <OSMutexPost+0x36>
        return;
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_mutex == (OS_MUTEX *)0) {                         /* Validate 'p_mutex'                                     */
 80055d0:	b350      	cbz	r0, 8005628 <OSMutexPost+0x64>
       *p_err = OS_ERR_OBJ_PTR_NULL;
        return;
    }
    switch (opt) {                                          /* Validate 'opt'                                         */
 80055d2:	b141      	cbz	r1, 80055e6 <OSMutexPost+0x22>
 80055d4:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 80055d8:	d005      	beq.n	80055e6 <OSMutexPost+0x22>
        case OS_OPT_POST_NONE:
        case OS_OPT_POST_NO_SCHED:
             break;

        default:
            *p_err =  OS_ERR_OPT_INVALID;
 80055da:	f645 6325 	movw	r3, #24101	; 0x5e25
 80055de:	8013      	strh	r3, [r2, #0]
    if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
        OSSched();                                          /* Run the scheduler                                      */
    }

   *p_err = OS_ERR_NONE;
}
 80055e0:	b002      	add	sp, #8
 80055e2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
             return;
    }
#endif

#if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    if (p_mutex->Type != OS_OBJ_TYPE_MUTEX) {               /* Make sure mutex was created                            */
 80055e6:	4b3e      	ldr	r3, [pc, #248]	; (80056e0 <OSMutexPost+0x11c>)
 80055e8:	6804      	ldr	r4, [r0, #0]
 80055ea:	429c      	cmp	r4, r3
 80055ec:	d00b      	beq.n	8005606 <OSMutexPost+0x42>
       *p_err = OS_ERR_OBJ_TYPE;
 80055ee:	f645 53c4 	movw	r3, #24004	; 0x5dc4
 80055f2:	8013      	strh	r3, [r2, #0]
    if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
        OSSched();                                          /* Run the scheduler                                      */
    }

   *p_err = OS_ERR_NONE;
}
 80055f4:	b002      	add	sp, #8
 80055f6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
       *p_err = OS_ERR_POST_ISR;
 80055fa:	f246 230e 	movw	r3, #25102	; 0x620e
 80055fe:	8013      	strh	r3, [r2, #0]
    if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
        OSSched();                                          /* Run the scheduler                                      */
    }

   *p_err = OS_ERR_NONE;
}
 8005600:	b002      	add	sp, #8
 8005602:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8005606:	4604      	mov	r4, r0
 8005608:	4615      	mov	r5, r2
 800560a:	460e      	mov	r6, r1
       *p_err = OS_ERR_OBJ_TYPE;
        return;
    }
#endif

    CPU_CRITICAL_ENTER();
 800560c:	f7fc f8b2 	bl	8001774 <CPU_SR_Save>
    if (OSTCBCurPtr != p_mutex->OwnerTCBPtr) {              /* Make sure the mutex owner is releasing the mutex       */
 8005610:	4f34      	ldr	r7, [pc, #208]	; (80056e4 <OSMutexPost+0x120>)
 8005612:	6a22      	ldr	r2, [r4, #32]
 8005614:	683b      	ldr	r3, [r7, #0]
       *p_err = OS_ERR_OBJ_TYPE;
        return;
    }
#endif

    CPU_CRITICAL_ENTER();
 8005616:	4680      	mov	r8, r0
    if (OSTCBCurPtr != p_mutex->OwnerTCBPtr) {              /* Make sure the mutex owner is releasing the mutex       */
 8005618:	429a      	cmp	r2, r3
 800561a:	d009      	beq.n	8005630 <OSMutexPost+0x6c>
        CPU_CRITICAL_EXIT();
 800561c:	f7fc f8ae 	bl	800177c <CPU_SR_Restore>
       *p_err = OS_ERR_MUTEX_NOT_OWNER;
 8005620:	f245 7381 	movw	r3, #22401	; 0x5781
 8005624:	802b      	strh	r3, [r5, #0]
        return;
 8005626:	e7db      	b.n	80055e0 <OSMutexPost+0x1c>
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_mutex == (OS_MUTEX *)0) {                         /* Validate 'p_mutex'                                     */
       *p_err = OS_ERR_OBJ_PTR_NULL;
 8005628:	f645 53c3 	movw	r3, #24003	; 0x5dc3
 800562c:	8013      	strh	r3, [r2, #0]
        return;
 800562e:	e7d7      	b.n	80055e0 <OSMutexPost+0x1c>
       *p_err = OS_ERR_MUTEX_NOT_OWNER;
        return;
    }

    OS_CRITICAL_ENTER_CPU_EXIT();
    ts          = OS_TS_GET();                              /* Get timestamp                                          */
 8005630:	f7fb faac 	bl	8000b8c <CPU_TS_TmrRd>
    p_mutex->TS = ts;
    p_mutex->OwnerNestingCtr--;                             /* Decrement owner's nesting counter                      */
 8005634:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
       *p_err = OS_ERR_MUTEX_NOT_OWNER;
        return;
    }

    OS_CRITICAL_ENTER_CPU_EXIT();
    ts          = OS_TS_GET();                              /* Get timestamp                                          */
 8005638:	4681      	mov	r9, r0
    p_mutex->TS = ts;
    p_mutex->OwnerNestingCtr--;                             /* Decrement owner's nesting counter                      */
 800563a:	3b01      	subs	r3, #1
 800563c:	b2db      	uxtb	r3, r3
        return;
    }

    OS_CRITICAL_ENTER_CPU_EXIT();
    ts          = OS_TS_GET();                              /* Get timestamp                                          */
    p_mutex->TS = ts;
 800563e:	62a0      	str	r0, [r4, #40]	; 0x28
    p_mutex->OwnerNestingCtr--;                             /* Decrement owner's nesting counter                      */
 8005640:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25
    if (p_mutex->OwnerNestingCtr > (OS_NESTING_CTR)0) {     /* Are we done with all nestings?                         */
 8005644:	2b00      	cmp	r3, #0
 8005646:	d138      	bne.n	80056ba <OSMutexPost+0xf6>
       *p_err = OS_ERR_MUTEX_NESTING;
        return;
    }

    p_pend_list = &p_mutex->PendList;
    if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0) {         /* Any task waiting on mutex?                             */
 8005648:	f8b4 a010 	ldrh.w	sl, [r4, #16]
 800564c:	f1ba 0f00 	cmp.w	sl, #0
 8005650:	d03a      	beq.n	80056c8 <OSMutexPost+0x104>
        OS_CRITICAL_EXIT();
       *p_err = OS_ERR_NONE;
        return;
    }
                                                            /* Yes                                                    */
    if (OSTCBCurPtr->Prio != p_mutex->OwnerOriginalPrio) {
 8005652:	6838      	ldr	r0, [r7, #0]
 8005654:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
 8005658:	f890 2037 	ldrb.w	r2, [r0, #55]	; 0x37
 800565c:	429a      	cmp	r2, r3
 800565e:	d011      	beq.n	8005684 <OSMutexPost+0xc0>
        OS_RdyListRemove(OSTCBCurPtr);
 8005660:	f7fe fe74 	bl	800434c <OS_RdyListRemove>
        OSTCBCurPtr->Prio = p_mutex->OwnerOriginalPrio;     /* Lower owner's priority back to its original one        */
 8005664:	f894 2024 	ldrb.w	r2, [r4, #36]	; 0x24
 8005668:	683b      	ldr	r3, [r7, #0]
        OS_PrioInsert(OSTCBCurPtr->Prio);
 800566a:	4610      	mov	r0, r2
        return;
    }
                                                            /* Yes                                                    */
    if (OSTCBCurPtr->Prio != p_mutex->OwnerOriginalPrio) {
        OS_RdyListRemove(OSTCBCurPtr);
        OSTCBCurPtr->Prio = p_mutex->OwnerOriginalPrio;     /* Lower owner's priority back to its original one        */
 800566c:	f883 2037 	strb.w	r2, [r3, #55]	; 0x37
        OS_PrioInsert(OSTCBCurPtr->Prio);
 8005670:	f000 f8a2 	bl	80057b8 <OS_PrioInsert>
        OS_RdyListInsertTail(OSTCBCurPtr);                  /* Insert owner in ready list at new priority             */
 8005674:	6838      	ldr	r0, [r7, #0]
 8005676:	f7fe fdd7 	bl	8004228 <OS_RdyListInsertTail>
        OSPrioCur         = OSTCBCurPtr->Prio;
 800567a:	683a      	ldr	r2, [r7, #0]
 800567c:	4b1a      	ldr	r3, [pc, #104]	; (80056e8 <OSMutexPost+0x124>)
 800567e:	f892 2037 	ldrb.w	r2, [r2, #55]	; 0x37
 8005682:	701a      	strb	r2, [r3, #0]
    }
                                                            /* Get TCB from head of pend list                         */
    p_tcb                      = p_pend_list->HeadPtr->TCBPtr;
 8005684:	68a3      	ldr	r3, [r4, #8]
    p_mutex->OwnerTCBPtr       = p_tcb;                     /* Give mutex to new owner                                */
    p_mutex->OwnerOriginalPrio = p_tcb->Prio;
    p_mutex->OwnerNestingCtr   = (OS_NESTING_CTR)1;
 8005686:	2201      	movs	r2, #1
        OS_PrioInsert(OSTCBCurPtr->Prio);
        OS_RdyListInsertTail(OSTCBCurPtr);                  /* Insert owner in ready list at new priority             */
        OSPrioCur         = OSTCBCurPtr->Prio;
    }
                                                            /* Get TCB from head of pend list                         */
    p_tcb                      = p_pend_list->HeadPtr->TCBPtr;
 8005688:	6899      	ldr	r1, [r3, #8]
    p_mutex->OwnerTCBPtr       = p_tcb;                     /* Give mutex to new owner                                */
    p_mutex->OwnerOriginalPrio = p_tcb->Prio;
    p_mutex->OwnerNestingCtr   = (OS_NESTING_CTR)1;
                                                            /* Post to mutex                                          */
    OS_Post((OS_PEND_OBJ *)((void *)p_mutex),
 800568a:	4620      	mov	r0, r4
        OS_RdyListInsertTail(OSTCBCurPtr);                  /* Insert owner in ready list at new priority             */
        OSPrioCur         = OSTCBCurPtr->Prio;
    }
                                                            /* Get TCB from head of pend list                         */
    p_tcb                      = p_pend_list->HeadPtr->TCBPtr;
    p_mutex->OwnerTCBPtr       = p_tcb;                     /* Give mutex to new owner                                */
 800568c:	6221      	str	r1, [r4, #32]
    p_mutex->OwnerOriginalPrio = p_tcb->Prio;
 800568e:	f891 3037 	ldrb.w	r3, [r1, #55]	; 0x37
 8005692:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
    p_mutex->OwnerNestingCtr   = (OS_NESTING_CTR)1;
                                                            /* Post to mutex                                          */
    OS_Post((OS_PEND_OBJ *)((void *)p_mutex),
 8005696:	2300      	movs	r3, #0
 8005698:	f8cd 9000 	str.w	r9, [sp]
    }
                                                            /* Get TCB from head of pend list                         */
    p_tcb                      = p_pend_list->HeadPtr->TCBPtr;
    p_mutex->OwnerTCBPtr       = p_tcb;                     /* Give mutex to new owner                                */
    p_mutex->OwnerOriginalPrio = p_tcb->Prio;
    p_mutex->OwnerNestingCtr   = (OS_NESTING_CTR)1;
 800569c:	f884 2025 	strb.w	r2, [r4, #37]	; 0x25
                                                            /* Post to mutex                                          */
    OS_Post((OS_PEND_OBJ *)((void *)p_mutex),
 80056a0:	461a      	mov	r2, r3
 80056a2:	f7ff f81d 	bl	80046e0 <OS_Post>
            (OS_TCB      *)p_tcb,
            (void        *)0,
            (OS_MSG_SIZE  )0,
            (CPU_TS       )ts);

    OS_CRITICAL_EXIT_NO_SCHED();
 80056a6:	4640      	mov	r0, r8
 80056a8:	f7fc f868 	bl	800177c <CPU_SR_Restore>

    if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
 80056ac:	0433      	lsls	r3, r6, #16
 80056ae:	d401      	bmi.n	80056b4 <OSMutexPost+0xf0>
        OSSched();                                          /* Run the scheduler                                      */
 80056b0:	f7fe fa3a 	bl	8003b28 <OSSched>
    }

   *p_err = OS_ERR_NONE;
 80056b4:	2300      	movs	r3, #0
 80056b6:	802b      	strh	r3, [r5, #0]
 80056b8:	e792      	b.n	80055e0 <OSMutexPost+0x1c>
    OS_CRITICAL_ENTER_CPU_EXIT();
    ts          = OS_TS_GET();                              /* Get timestamp                                          */
    p_mutex->TS = ts;
    p_mutex->OwnerNestingCtr--;                             /* Decrement owner's nesting counter                      */
    if (p_mutex->OwnerNestingCtr > (OS_NESTING_CTR)0) {     /* Are we done with all nestings?                         */
        OS_CRITICAL_EXIT();                                 /* No                                                     */
 80056ba:	4640      	mov	r0, r8
 80056bc:	f7fc f85e 	bl	800177c <CPU_SR_Restore>
       *p_err = OS_ERR_MUTEX_NESTING;
 80056c0:	f245 7383 	movw	r3, #22403	; 0x5783
 80056c4:	802b      	strh	r3, [r5, #0]
        return;
 80056c6:	e78b      	b.n	80055e0 <OSMutexPost+0x1c>
    }

    p_pend_list = &p_mutex->PendList;
    if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0) {         /* Any task waiting on mutex?                             */
        p_mutex->OwnerTCBPtr     = (OS_TCB       *)0;       /* No                                                     */
 80056c8:	f8c4 a020 	str.w	sl, [r4, #32]
        p_mutex->OwnerNestingCtr = (OS_NESTING_CTR)0;
 80056cc:	f884 a025 	strb.w	sl, [r4, #37]	; 0x25
        OS_CRITICAL_EXIT();
 80056d0:	4640      	mov	r0, r8
 80056d2:	f7fc f853 	bl	800177c <CPU_SR_Restore>
       *p_err = OS_ERR_NONE;
 80056d6:	f8a5 a000 	strh.w	sl, [r5]
        return;
 80056da:	e781      	b.n	80055e0 <OSMutexPost+0x1c>
 80056dc:	2000ed84 	.word	0x2000ed84
 80056e0:	5854554d 	.word	0x5854554d
 80056e4:	2000ed58 	.word	0x2000ed58
 80056e8:	2000ec88 	.word	0x2000ec88

080056ec <OS_MutexClr>:
* Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
************************************************************************************************************************
*/

void  OS_MutexClr (OS_MUTEX  *p_mutex)
{
 80056ec:	b410      	push	{r4}
    p_mutex->Type              =  OS_OBJ_TYPE_NONE;         /* Mark the data structure as a NONE                      */
    p_mutex->NamePtr           = (CPU_CHAR     *)((void *)"?MUTEX");
    p_mutex->OwnerTCBPtr       = (OS_TCB       *)0;
 80056ee:	2300      	movs	r3, #0
************************************************************************************************************************
*/

void  OS_MutexClr (OS_MUTEX  *p_mutex)
{
    p_mutex->Type              =  OS_OBJ_TYPE_NONE;         /* Mark the data structure as a NONE                      */
 80056f0:	4c07      	ldr	r4, [pc, #28]	; (8005710 <OS_MutexClr+0x24>)
    p_mutex->NamePtr           = (CPU_CHAR     *)((void *)"?MUTEX");
 80056f2:	4908      	ldr	r1, [pc, #32]	; (8005714 <OS_MutexClr+0x28>)
    p_mutex->OwnerTCBPtr       = (OS_TCB       *)0;
    p_mutex->OwnerNestingCtr   = (OS_NESTING_CTR)0;
    p_mutex->TS                = (CPU_TS        )0;
    p_mutex->OwnerOriginalPrio =  OS_CFG_PRIO_MAX;
 80056f4:	223f      	movs	r2, #63	; 0x3f
 80056f6:	f880 2024 	strb.w	r2, [r0, #36]	; 0x24
void  OS_MutexClr (OS_MUTEX  *p_mutex)
{
    p_mutex->Type              =  OS_OBJ_TYPE_NONE;         /* Mark the data structure as a NONE                      */
    p_mutex->NamePtr           = (CPU_CHAR     *)((void *)"?MUTEX");
    p_mutex->OwnerTCBPtr       = (OS_TCB       *)0;
    p_mutex->OwnerNestingCtr   = (OS_NESTING_CTR)0;
 80056fa:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
************************************************************************************************************************
*/

void  OS_MutexClr (OS_MUTEX  *p_mutex)
{
    p_mutex->Type              =  OS_OBJ_TYPE_NONE;         /* Mark the data structure as a NONE                      */
 80056fe:	6004      	str	r4, [r0, #0]
    p_mutex->NamePtr           = (CPU_CHAR     *)((void *)"?MUTEX");
 8005700:	6041      	str	r1, [r0, #4]
    p_mutex->OwnerTCBPtr       = (OS_TCB       *)0;
 8005702:	6203      	str	r3, [r0, #32]
    p_mutex->OwnerNestingCtr   = (OS_NESTING_CTR)0;
    p_mutex->TS                = (CPU_TS        )0;
 8005704:	6283      	str	r3, [r0, #40]	; 0x28
    p_mutex->OwnerOriginalPrio =  OS_CFG_PRIO_MAX;
    OS_PendListInit(&p_mutex->PendList);                    /* Initialize the waiting list                            */
}
 8005706:	bc10      	pop	{r4}
    p_mutex->NamePtr           = (CPU_CHAR     *)((void *)"?MUTEX");
    p_mutex->OwnerTCBPtr       = (OS_TCB       *)0;
    p_mutex->OwnerNestingCtr   = (OS_NESTING_CTR)0;
    p_mutex->TS                = (CPU_TS        )0;
    p_mutex->OwnerOriginalPrio =  OS_CFG_PRIO_MAX;
    OS_PendListInit(&p_mutex->PendList);                    /* Initialize the waiting list                            */
 8005708:	3008      	adds	r0, #8
 800570a:	f7fe bc27 	b.w	8003f5c <OS_PendListInit>
 800570e:	bf00      	nop
 8005710:	454e4f4e 	.word	0x454e4f4e
 8005714:	08016664 	.word	0x08016664

08005718 <OS_MutexDbgListAdd>:
#if OS_CFG_DBG_EN > 0u
void  OS_MutexDbgListAdd (OS_MUTEX  *p_mutex)
{
    p_mutex->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
    p_mutex->DbgPrevPtr               = (OS_MUTEX *)0;
    if (OSMutexDbgListPtr == (OS_MUTEX *)0) {
 8005718:	4a06      	ldr	r2, [pc, #24]	; (8005734 <OS_MutexDbgListAdd+0x1c>)
*/


#if OS_CFG_DBG_EN > 0u
void  OS_MutexDbgListAdd (OS_MUTEX  *p_mutex)
{
 800571a:	b410      	push	{r4}
    p_mutex->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
    p_mutex->DbgPrevPtr               = (OS_MUTEX *)0;
    if (OSMutexDbgListPtr == (OS_MUTEX *)0) {
 800571c:	6813      	ldr	r3, [r2, #0]


#if OS_CFG_DBG_EN > 0u
void  OS_MutexDbgListAdd (OS_MUTEX  *p_mutex)
{
    p_mutex->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
 800571e:	4c06      	ldr	r4, [pc, #24]	; (8005738 <OS_MutexDbgListAdd+0x20>)
    p_mutex->DbgPrevPtr               = (OS_MUTEX *)0;
 8005720:	2100      	movs	r1, #0


#if OS_CFG_DBG_EN > 0u
void  OS_MutexDbgListAdd (OS_MUTEX  *p_mutex)
{
    p_mutex->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
 8005722:	61c4      	str	r4, [r0, #28]
    p_mutex->DbgPrevPtr               = (OS_MUTEX *)0;
 8005724:	6141      	str	r1, [r0, #20]
    if (OSMutexDbgListPtr == (OS_MUTEX *)0) {
        p_mutex->DbgNextPtr           = (OS_MUTEX *)0;
 8005726:	6183      	str	r3, [r0, #24]
#if OS_CFG_DBG_EN > 0u
void  OS_MutexDbgListAdd (OS_MUTEX  *p_mutex)
{
    p_mutex->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
    p_mutex->DbgPrevPtr               = (OS_MUTEX *)0;
    if (OSMutexDbgListPtr == (OS_MUTEX *)0) {
 8005728:	b103      	cbz	r3, 800572c <OS_MutexDbgListAdd+0x14>
        p_mutex->DbgNextPtr           = (OS_MUTEX *)0;
    } else {
        p_mutex->DbgNextPtr           =  OSMutexDbgListPtr;
        OSMutexDbgListPtr->DbgPrevPtr =  p_mutex;
 800572a:	6158      	str	r0, [r3, #20]
    }
    OSMutexDbgListPtr                 =  p_mutex;
 800572c:	6010      	str	r0, [r2, #0]
}
 800572e:	bc10      	pop	{r4}
 8005730:	4770      	bx	lr
 8005732:	bf00      	nop
 8005734:	2000f034 	.word	0x2000f034
 8005738:	080182f0 	.word	0x080182f0

0800573c <OS_MutexDbgListRemove>:
{
    OS_MUTEX  *p_mutex_next;
    OS_MUTEX  *p_mutex_prev;


    p_mutex_prev = p_mutex->DbgPrevPtr;
 800573c:	6942      	ldr	r2, [r0, #20]
    p_mutex_next = p_mutex->DbgNextPtr;
 800573e:	6983      	ldr	r3, [r0, #24]

    if (p_mutex_prev == (OS_MUTEX *)0) {
 8005740:	b132      	cbz	r2, 8005750 <OS_MutexDbgListRemove+0x14>
        if (p_mutex_next != (OS_MUTEX *)0) {
            p_mutex_next->DbgPrevPtr = (OS_MUTEX *)0;
        }
        p_mutex->DbgNextPtr = (OS_MUTEX *)0;

    } else if (p_mutex_next == (OS_MUTEX *)0) {
 8005742:	b163      	cbz	r3, 800575e <OS_MutexDbgListRemove+0x22>
        p_mutex->DbgPrevPtr      = (OS_MUTEX *)0;

    } else {
        p_mutex_prev->DbgNextPtr =  p_mutex_next;
        p_mutex_next->DbgPrevPtr =  p_mutex_prev;
        p_mutex->DbgNextPtr      = (OS_MUTEX *)0;
 8005744:	2100      	movs	r1, #0
    } else if (p_mutex_next == (OS_MUTEX *)0) {
        p_mutex_prev->DbgNextPtr = (OS_MUTEX *)0;
        p_mutex->DbgPrevPtr      = (OS_MUTEX *)0;

    } else {
        p_mutex_prev->DbgNextPtr =  p_mutex_next;
 8005746:	6193      	str	r3, [r2, #24]
        p_mutex_next->DbgPrevPtr =  p_mutex_prev;
 8005748:	615a      	str	r2, [r3, #20]
        p_mutex->DbgNextPtr      = (OS_MUTEX *)0;
 800574a:	6181      	str	r1, [r0, #24]
        p_mutex->DbgPrevPtr      = (OS_MUTEX *)0;
 800574c:	6141      	str	r1, [r0, #20]
 800574e:	4770      	bx	lr

    p_mutex_prev = p_mutex->DbgPrevPtr;
    p_mutex_next = p_mutex->DbgNextPtr;

    if (p_mutex_prev == (OS_MUTEX *)0) {
        OSMutexDbgListPtr = p_mutex_next;
 8005750:	4904      	ldr	r1, [pc, #16]	; (8005764 <OS_MutexDbgListRemove+0x28>)
 8005752:	600b      	str	r3, [r1, #0]
        if (p_mutex_next != (OS_MUTEX *)0) {
 8005754:	b103      	cbz	r3, 8005758 <OS_MutexDbgListRemove+0x1c>
            p_mutex_next->DbgPrevPtr = (OS_MUTEX *)0;
 8005756:	615a      	str	r2, [r3, #20]
        }
        p_mutex->DbgNextPtr = (OS_MUTEX *)0;
 8005758:	2300      	movs	r3, #0
 800575a:	6183      	str	r3, [r0, #24]
 800575c:	4770      	bx	lr

    } else if (p_mutex_next == (OS_MUTEX *)0) {
        p_mutex_prev->DbgNextPtr = (OS_MUTEX *)0;
 800575e:	6193      	str	r3, [r2, #24]
        p_mutex->DbgPrevPtr      = (OS_MUTEX *)0;
 8005760:	6143      	str	r3, [r0, #20]
 8005762:	4770      	bx	lr
 8005764:	2000f034 	.word	0x2000f034

08005768 <OS_MutexInit>:
        return;
    }
#endif

#if OS_CFG_DBG_EN > 0u
    OSMutexDbgListPtr = (OS_MUTEX *)0;
 8005768:	4903      	ldr	r1, [pc, #12]	; (8005778 <OS_MutexInit+0x10>)
#endif

    OSMutexQty        = (OS_OBJ_QTY)0;
 800576a:	4a04      	ldr	r2, [pc, #16]	; (800577c <OS_MutexInit+0x14>)
        return;
    }
#endif

#if OS_CFG_DBG_EN > 0u
    OSMutexDbgListPtr = (OS_MUTEX *)0;
 800576c:	2300      	movs	r3, #0
 800576e:	600b      	str	r3, [r1, #0]
#endif

    OSMutexQty        = (OS_OBJ_QTY)0;
 8005770:	8013      	strh	r3, [r2, #0]
   *p_err             =  OS_ERR_NONE;
 8005772:	8003      	strh	r3, [r0, #0]
 8005774:	4770      	bx	lr
 8005776:	bf00      	nop
 8005778:	2000f034 	.word	0x2000f034
 800577c:	2000ef5c 	.word	0x2000ef5c

08005780 <OS_PrioInit>:
    CPU_DATA  i;


                                                            /* Clear the bitmap table ... no task is ready            */
    for (i = 0u; i < OS_PRIO_TBL_SIZE; i++) {
         OSPrioTbl[i] = (CPU_DATA)0;
 8005780:	4b02      	ldr	r3, [pc, #8]	; (800578c <OS_PrioInit+0xc>)
 8005782:	2200      	movs	r2, #0
 8005784:	601a      	str	r2, [r3, #0]
 8005786:	605a      	str	r2, [r3, #4]
 8005788:	4770      	bx	lr
 800578a:	bf00      	nop
 800578c:	2000e96c 	.word	0x2000e96c

08005790 <OS_PrioGetHighest>:
    OS_PRIO    prio;


    prio  = (OS_PRIO)0;
    p_tbl = &OSPrioTbl[0];
    while (*p_tbl == (CPU_DATA)0) {                         /* Search the bitmap table for the highest priority       */
 8005790:	4b08      	ldr	r3, [pc, #32]	; (80057b4 <OS_PrioGetHighest+0x24>)
* Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
************************************************************************************************************************
*/

OS_PRIO  OS_PrioGetHighest (void)
{
 8005792:	b510      	push	{r4, lr}
    OS_PRIO    prio;


    prio  = (OS_PRIO)0;
    p_tbl = &OSPrioTbl[0];
    while (*p_tbl == (CPU_DATA)0) {                         /* Search the bitmap table for the highest priority       */
 8005794:	6818      	ldr	r0, [r3, #0]
 8005796:	b958      	cbnz	r0, 80057b0 <OS_PrioGetHighest+0x20>
 8005798:	4604      	mov	r4, r0
 800579a:	f853 0f04 	ldr.w	r0, [r3, #4]!
        prio += DEF_INT_CPU_NBR_BITS;                       /* Compute the step of each CPU_DATA entry                */
 800579e:	3420      	adds	r4, #32
 80057a0:	b2e4      	uxtb	r4, r4
    OS_PRIO    prio;


    prio  = (OS_PRIO)0;
    p_tbl = &OSPrioTbl[0];
    while (*p_tbl == (CPU_DATA)0) {                         /* Search the bitmap table for the highest priority       */
 80057a2:	2800      	cmp	r0, #0
 80057a4:	d0f9      	beq.n	800579a <OS_PrioGetHighest+0xa>
        prio += DEF_INT_CPU_NBR_BITS;                       /* Compute the step of each CPU_DATA entry                */
        p_tbl++;
    }
    prio += (OS_PRIO)CPU_CntLeadZeros(*p_tbl);              /* Find the position of the first bit set at the entry    */
 80057a6:	f7fb fff0 	bl	800178a <CPU_CntLeadZeros>
    return (prio);
 80057aa:	4420      	add	r0, r4
}
 80057ac:	b2c0      	uxtb	r0, r0
 80057ae:	bd10      	pop	{r4, pc}
{
    CPU_DATA  *p_tbl;
    OS_PRIO    prio;


    prio  = (OS_PRIO)0;
 80057b0:	2400      	movs	r4, #0
 80057b2:	e7f8      	b.n	80057a6 <OS_PrioGetHighest+0x16>
 80057b4:	2000e96c 	.word	0x2000e96c

080057b8 <OS_PrioInsert>:
* Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
************************************************************************************************************************
*/

void  OS_PrioInsert (OS_PRIO  prio)
{
 80057b8:	b410      	push	{r4}

    ix             = prio / DEF_INT_CPU_NBR_BITS;
    bit_nbr        = (CPU_DATA)prio & (DEF_INT_CPU_NBR_BITS - 1u);
    bit            = 1u;
    bit          <<= (DEF_INT_CPU_NBR_BITS - 1u) - bit_nbr;
    OSPrioTbl[ix] |= bit;
 80057ba:	4c07      	ldr	r4, [pc, #28]	; (80057d8 <OS_PrioInsert+0x20>)
 80057bc:	f000 021f 	and.w	r2, r0, #31
 80057c0:	0940      	lsrs	r0, r0, #5
 80057c2:	f854 3020 	ldr.w	r3, [r4, r0, lsl #2]
 80057c6:	f1c2 011f 	rsb	r1, r2, #31
 80057ca:	2201      	movs	r2, #1
 80057cc:	408a      	lsls	r2, r1
 80057ce:	4313      	orrs	r3, r2
 80057d0:	f844 3020 	str.w	r3, [r4, r0, lsl #2]
}
 80057d4:	bc10      	pop	{r4}
 80057d6:	4770      	bx	lr
 80057d8:	2000e96c 	.word	0x2000e96c

080057dc <OS_PrioRemove>:
* Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
************************************************************************************************************************
*/

void  OS_PrioRemove (OS_PRIO  prio)
{
 80057dc:	b410      	push	{r4}

    ix             = prio / DEF_INT_CPU_NBR_BITS;
    bit_nbr        = (CPU_DATA)prio & (DEF_INT_CPU_NBR_BITS - 1u);
    bit            = 1u;
    bit          <<= (DEF_INT_CPU_NBR_BITS - 1u) - bit_nbr;
    OSPrioTbl[ix] &= ~bit;
 80057de:	4c08      	ldr	r4, [pc, #32]	; (8005800 <OS_PrioRemove+0x24>)
 80057e0:	f000 021f 	and.w	r2, r0, #31
 80057e4:	0940      	lsrs	r0, r0, #5
 80057e6:	f854 3020 	ldr.w	r3, [r4, r0, lsl #2]
 80057ea:	f1c2 011f 	rsb	r1, r2, #31
 80057ee:	2201      	movs	r2, #1
 80057f0:	408a      	lsls	r2, r1
 80057f2:	ea23 0302 	bic.w	r3, r3, r2
 80057f6:	f844 3020 	str.w	r3, [r4, r0, lsl #2]
}
 80057fa:	bc10      	pop	{r4}
 80057fc:	4770      	bx	lr
 80057fe:	bf00      	nop
 8005800:	2000e96c 	.word	0x2000e96c

08005804 <OSQCreate>:
void  OSQCreate (OS_Q        *p_q,
                 CPU_CHAR    *p_name,
                 OS_MSG_QTY   max_qty,
                 OS_ERR      *p_err)

{
 8005804:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
        return;
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to be called from an ISR                   */
 8005808:	4d1e      	ldr	r5, [pc, #120]	; (8005884 <OSQCreate+0x80>)
 800580a:	782f      	ldrb	r7, [r5, #0]
 800580c:	2f00      	cmp	r7, #0
 800580e:	d12f      	bne.n	8005870 <OSQCreate+0x6c>
        return;
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_q == (OS_Q *)0) {                                 /* Validate arguments                                     */
 8005810:	2800      	cmp	r0, #0
 8005812:	d032      	beq.n	800587a <OSQCreate+0x76>
       *p_err = OS_ERR_OBJ_PTR_NULL;
        return;
    }
    if (max_qty == (OS_MSG_QTY)0) {                         /* Cannot specify a zero size queue                       */
 8005814:	b922      	cbnz	r2, 8005820 <OSQCreate+0x1c>
       *p_err = OS_ERR_Q_SIZE;
 8005816:	f246 5294 	movw	r2, #26004	; 0x6594
 800581a:	801a      	strh	r2, [r3, #0]
        return;
 800581c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8005820:	4604      	mov	r4, r0
 8005822:	4615      	mov	r5, r2
 8005824:	4688      	mov	r8, r1
 8005826:	461e      	mov	r6, r3
    }
#endif

    OS_CRITICAL_ENTER();
 8005828:	f7fb ffa4 	bl	8001774 <CPU_SR_Save>
    p_q->Type    = OS_OBJ_TYPE_Q;                           /* Mark the data structure as a message queue             */
 800582c:	4b16      	ldr	r3, [pc, #88]	; (8005888 <OSQCreate+0x84>)
    p_q->NamePtr = p_name;
    OS_MsgQInit(&p_q->MsgQ,                                 /* Initialize the queue                                   */
 800582e:	4629      	mov	r1, r5
        return;
    }
#endif

    OS_CRITICAL_ENTER();
    p_q->Type    = OS_OBJ_TYPE_Q;                           /* Mark the data structure as a message queue             */
 8005830:	6023      	str	r3, [r4, #0]
       *p_err = OS_ERR_Q_SIZE;
        return;
    }
#endif

    OS_CRITICAL_ENTER();
 8005832:	4681      	mov	r9, r0
    p_q->Type    = OS_OBJ_TYPE_Q;                           /* Mark the data structure as a message queue             */
    p_q->NamePtr = p_name;
 8005834:	f8c4 8004 	str.w	r8, [r4, #4]
    OS_MsgQInit(&p_q->MsgQ,                                 /* Initialize the queue                                   */
 8005838:	f104 0020 	add.w	r0, r4, #32
 800583c:	f7ff fcee 	bl	800521c <OS_MsgQInit>
                max_qty);
    OS_PendListInit(&p_q->PendList);                        /* Initialize the waiting list                            */
 8005840:	f104 0008 	add.w	r0, r4, #8
 8005844:	f7fe fb8a 	bl	8003f5c <OS_PendListInit>
#if OS_CFG_DBG_EN > 0u
void  OS_QDbgListAdd (OS_Q  *p_q)
{
    p_q->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
    p_q->DbgPrevPtr               = (OS_Q     *)0;
    if (OSQDbgListPtr == (OS_Q *)0) {
 8005848:	4910      	ldr	r1, [pc, #64]	; (800588c <OSQCreate+0x88>)


#if OS_CFG_DBG_EN > 0u
void  OS_QDbgListAdd (OS_Q  *p_q)
{
    p_q->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
 800584a:	4a11      	ldr	r2, [pc, #68]	; (8005890 <OSQCreate+0x8c>)
    p_q->DbgPrevPtr               = (OS_Q     *)0;
    if (OSQDbgListPtr == (OS_Q *)0) {
 800584c:	680b      	ldr	r3, [r1, #0]

#if OS_CFG_DBG_EN > 0u
void  OS_QDbgListAdd (OS_Q  *p_q)
{
    p_q->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
    p_q->DbgPrevPtr               = (OS_Q     *)0;
 800584e:	6167      	str	r7, [r4, #20]


#if OS_CFG_DBG_EN > 0u
void  OS_QDbgListAdd (OS_Q  *p_q)
{
    p_q->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
 8005850:	61e2      	str	r2, [r4, #28]
    p_q->DbgPrevPtr               = (OS_Q     *)0;
    if (OSQDbgListPtr == (OS_Q *)0) {
        p_q->DbgNextPtr           = (OS_Q     *)0;
 8005852:	61a3      	str	r3, [r4, #24]
#if OS_CFG_DBG_EN > 0u
void  OS_QDbgListAdd (OS_Q  *p_q)
{
    p_q->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
    p_q->DbgPrevPtr               = (OS_Q     *)0;
    if (OSQDbgListPtr == (OS_Q *)0) {
 8005854:	b103      	cbz	r3, 8005858 <OSQCreate+0x54>
        p_q->DbgNextPtr           = (OS_Q     *)0;
    } else {
        p_q->DbgNextPtr           =  OSQDbgListPtr;
        OSQDbgListPtr->DbgPrevPtr =  p_q;
 8005856:	615c      	str	r4, [r3, #20]
    OS_PendListInit(&p_q->PendList);                        /* Initialize the waiting list                            */

#if OS_CFG_DBG_EN > 0u
    OS_QDbgListAdd(p_q);
#endif
    OSQQty++;                                               /* One more queue created                                 */
 8005858:	4a0e      	ldr	r2, [pc, #56]	; (8005894 <OSQCreate+0x90>)

    OS_CRITICAL_EXIT_NO_SCHED();
 800585a:	4648      	mov	r0, r9
    OS_PendListInit(&p_q->PendList);                        /* Initialize the waiting list                            */

#if OS_CFG_DBG_EN > 0u
    OS_QDbgListAdd(p_q);
#endif
    OSQQty++;                                               /* One more queue created                                 */
 800585c:	8813      	ldrh	r3, [r2, #0]
        p_q->DbgNextPtr           = (OS_Q     *)0;
    } else {
        p_q->DbgNextPtr           =  OSQDbgListPtr;
        OSQDbgListPtr->DbgPrevPtr =  p_q;
    }
    OSQDbgListPtr                 =  p_q;
 800585e:	600c      	str	r4, [r1, #0]
    OS_PendListInit(&p_q->PendList);                        /* Initialize the waiting list                            */

#if OS_CFG_DBG_EN > 0u
    OS_QDbgListAdd(p_q);
#endif
    OSQQty++;                                               /* One more queue created                                 */
 8005860:	3301      	adds	r3, #1
 8005862:	8013      	strh	r3, [r2, #0]

    OS_CRITICAL_EXIT_NO_SCHED();
 8005864:	f7fb ff8a 	bl	800177c <CPU_SR_Restore>
   *p_err = OS_ERR_NONE;
 8005868:	2300      	movs	r3, #0
 800586a:	8033      	strh	r3, [r6, #0]
 800586c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to be called from an ISR                   */
       *p_err = OS_ERR_CREATE_ISR;
 8005870:	f642 62e1 	movw	r2, #12001	; 0x2ee1
 8005874:	801a      	strh	r2, [r3, #0]
        return;
 8005876:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_q == (OS_Q *)0) {                                 /* Validate arguments                                     */
       *p_err = OS_ERR_OBJ_PTR_NULL;
 800587a:	f645 52c3 	movw	r2, #24003	; 0x5dc3
 800587e:	801a      	strh	r2, [r3, #0]
        return;
 8005880:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8005884:	2000ed84 	.word	0x2000ed84
 8005888:	55455551 	.word	0x55455551
 800588c:	2000ef1c 	.word	0x2000ef1c
 8005890:	080182f0 	.word	0x080182f0
 8005894:	2000ed5c 	.word	0x2000ed5c

08005898 <OSQFlush>:
*/

#if OS_CFG_Q_FLUSH_EN > 0u
OS_MSG_QTY  OSQFlush (OS_Q    *p_q,
                      OS_ERR  *p_err)
{
 8005898:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        return ((OS_MSG_QTY)0);
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't flush a message queue from an ISR                */
 800589a:	4b13      	ldr	r3, [pc, #76]	; (80058e8 <OSQFlush+0x50>)
 800589c:	781d      	ldrb	r5, [r3, #0]
 800589e:	b94d      	cbnz	r5, 80058b4 <OSQFlush+0x1c>
        return ((OS_MSG_QTY)0);
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_q == (OS_Q *)0) {                                 /* Validate arguments                                     */
 80058a0:	b1e8      	cbz	r0, 80058de <OSQFlush+0x46>
        return ((OS_MSG_QTY)0);
    }
#endif

#if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    if (p_q->Type != OS_OBJ_TYPE_Q) {                       /* Make sure message queue was created                    */
 80058a2:	4b12      	ldr	r3, [pc, #72]	; (80058ec <OSQFlush+0x54>)
 80058a4:	6802      	ldr	r2, [r0, #0]
 80058a6:	429a      	cmp	r2, r3
 80058a8:	d009      	beq.n	80058be <OSQFlush+0x26>
       *p_err = OS_ERR_OBJ_TYPE;
 80058aa:	f645 53c4 	movw	r3, #24004	; 0x5dc4
        return ((OS_MSG_QTY)0);
 80058ae:	4628      	mov	r0, r5
    }
#endif

#if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    if (p_q->Type != OS_OBJ_TYPE_Q) {                       /* Make sure message queue was created                    */
       *p_err = OS_ERR_OBJ_TYPE;
 80058b0:	800b      	strh	r3, [r1, #0]
        return ((OS_MSG_QTY)0);
 80058b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't flush a message queue from an ISR                */
       *p_err = OS_ERR_FLUSH_ISR;
 80058b4:	f44f 536c 	mov.w	r3, #15104	; 0x3b00
 80058b8:	800b      	strh	r3, [r1, #0]
        return ((OS_MSG_QTY)0);
 80058ba:	2000      	movs	r0, #0
 80058bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80058be:	460e      	mov	r6, r1
 80058c0:	4604      	mov	r4, r0
       *p_err = OS_ERR_OBJ_TYPE;
        return ((OS_MSG_QTY)0);
    }
#endif

    OS_CRITICAL_ENTER();
 80058c2:	f7fb ff57 	bl	8001774 <CPU_SR_Save>
 80058c6:	4607      	mov	r7, r0
    entries = OS_MsgQFreeAll(&p_q->MsgQ);                   /* Return all OS_MSGs to the OS_MSG pool                  */
 80058c8:	f104 0020 	add.w	r0, r4, #32
 80058cc:	f7ff fc8c 	bl	80051e8 <OS_MsgQFreeAll>
 80058d0:	4604      	mov	r4, r0
    OS_CRITICAL_EXIT();
 80058d2:	4638      	mov	r0, r7
 80058d4:	f7fb ff52 	bl	800177c <CPU_SR_Restore>
   *p_err   = OS_ERR_NONE;
    return ((OS_MSG_QTY)entries);
 80058d8:	4620      	mov	r0, r4
#endif

    OS_CRITICAL_ENTER();
    entries = OS_MsgQFreeAll(&p_q->MsgQ);                   /* Return all OS_MSGs to the OS_MSG pool                  */
    OS_CRITICAL_EXIT();
   *p_err   = OS_ERR_NONE;
 80058da:	8035      	strh	r5, [r6, #0]
    return ((OS_MSG_QTY)entries);
}
 80058dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_q == (OS_Q *)0) {                                 /* Validate arguments                                     */
       *p_err = OS_ERR_OBJ_PTR_NULL;
 80058de:	f645 53c3 	movw	r3, #24003	; 0x5dc3
 80058e2:	800b      	strh	r3, [r1, #0]
        return ((OS_MSG_QTY)0);
 80058e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80058e6:	bf00      	nop
 80058e8:	2000ed84 	.word	0x2000ed84
 80058ec:	55455551 	.word	0x55455551

080058f0 <OSQPend>:
                OS_TICK       timeout,
                OS_OPT        opt,
                OS_MSG_SIZE  *p_msg_size,
                CPU_TS       *p_ts,
                OS_ERR       *p_err)
{
 80058f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        return ((void *)0);
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
 80058f4:	4c59      	ldr	r4, [pc, #356]	; (8005a5c <OSQPend+0x16c>)
                OS_TICK       timeout,
                OS_OPT        opt,
                OS_MSG_SIZE  *p_msg_size,
                CPU_TS       *p_ts,
                OS_ERR       *p_err)
{
 80058f6:	b089      	sub	sp, #36	; 0x24
        return ((void *)0);
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
 80058f8:	7824      	ldrb	r4, [r4, #0]
                OS_TICK       timeout,
                OS_OPT        opt,
                OS_MSG_SIZE  *p_msg_size,
                CPU_TS       *p_ts,
                OS_ERR       *p_err)
{
 80058fa:	9f12      	ldr	r7, [sp, #72]	; 0x48
 80058fc:	9e13      	ldr	r6, [sp, #76]	; 0x4c
        return ((void *)0);
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
 80058fe:	2c00      	cmp	r4, #0
 8005900:	f040 8083 	bne.w	8005a0a <OSQPend+0x11a>
        return ((void *)0);
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_q == (OS_Q *)0) {                                 /* Validate arguments                                     */
 8005904:	2800      	cmp	r0, #0
 8005906:	f000 8097 	beq.w	8005a38 <OSQPend+0x148>
       *p_err = OS_ERR_OBJ_PTR_NULL;
        return ((void *)0);
    }
    if (p_msg_size == (OS_MSG_SIZE *)0) {
 800590a:	2b00      	cmp	r3, #0
 800590c:	f000 8098 	beq.w	8005a40 <OSQPend+0x150>
       *p_err = OS_ERR_PTR_INVALID;
        return ((void *)0);
    }
    switch (opt) {
 8005910:	b112      	cbz	r2, 8005918 <OSQPend+0x28>
 8005912:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
 8005916:	d16c      	bne.n	80059f2 <OSQPend+0x102>
             return ((void *)0);
    }
#endif

#if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    if (p_q->Type != OS_OBJ_TYPE_Q) {                       /* Make sure message queue was created                    */
 8005918:	4c51      	ldr	r4, [pc, #324]	; (8005a60 <OSQPend+0x170>)
 800591a:	6805      	ldr	r5, [r0, #0]
 800591c:	42a5      	cmp	r5, r4
 800591e:	d16d      	bne.n	80059fc <OSQPend+0x10c>
       *p_err = OS_ERR_OBJ_TYPE;
        return ((void *)0);
    }
#endif

    if (p_ts != (CPU_TS *)0) {
 8005920:	b10f      	cbz	r7, 8005926 <OSQPend+0x36>
       *p_ts  = (CPU_TS  )0;                                /* Initialize the returned timestamp                      */
 8005922:	2400      	movs	r4, #0
 8005924:	603c      	str	r4, [r7, #0]
 8005926:	4698      	mov	r8, r3
 8005928:	4691      	mov	r9, r2
 800592a:	468a      	mov	sl, r1
 800592c:	4604      	mov	r4, r0
    }

    CPU_CRITICAL_ENTER();
 800592e:	f7fb ff21 	bl	8001774 <CPU_SR_Save>
    p_void = OS_MsgQGet(&p_q->MsgQ,                         /* Any message waiting in the message queue?              */
 8005932:	4633      	mov	r3, r6

    if (p_ts != (CPU_TS *)0) {
       *p_ts  = (CPU_TS  )0;                                /* Initialize the returned timestamp                      */
    }

    CPU_CRITICAL_ENTER();
 8005934:	4683      	mov	fp, r0
    p_void = OS_MsgQGet(&p_q->MsgQ,                         /* Any message waiting in the message queue?              */
 8005936:	463a      	mov	r2, r7
 8005938:	4641      	mov	r1, r8
 800593a:	f104 0020 	add.w	r0, r4, #32
 800593e:	f7ff fc75 	bl	800522c <OS_MsgQGet>
                        p_msg_size,
                        p_ts,
                        p_err);
    if (*p_err == OS_ERR_NONE) {
 8005942:	8833      	ldrh	r3, [r6, #0]
    if (p_ts != (CPU_TS *)0) {
       *p_ts  = (CPU_TS  )0;                                /* Initialize the returned timestamp                      */
    }

    CPU_CRITICAL_ENTER();
    p_void = OS_MsgQGet(&p_q->MsgQ,                         /* Any message waiting in the message queue?              */
 8005944:	4605      	mov	r5, r0
                        p_msg_size,
                        p_ts,
                        p_err);
    if (*p_err == OS_ERR_NONE) {
 8005946:	b1eb      	cbz	r3, 8005984 <OSQPend+0x94>
        CPU_CRITICAL_EXIT();
        return (p_void);                                    /* Yes, Return message received                           */
    }

    if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {    /* Caller wants to block if not available?                */
 8005948:	f419 4f00 	tst.w	r9, #32768	; 0x8000
 800594c:	d17d      	bne.n	8005a4a <OSQPend+0x15a>
        CPU_CRITICAL_EXIT();
       *p_err = OS_ERR_PEND_WOULD_BLOCK;                    /* No                                                     */
        return ((void *)0);
    } else {
        if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /* Can't pend when the scheduler is locked                */
 800594e:	4b45      	ldr	r3, [pc, #276]	; (8005a64 <OSQPend+0x174>)
 8005950:	781b      	ldrb	r3, [r3, #0]
 8005952:	2b00      	cmp	r3, #0
 8005954:	d168      	bne.n	8005a28 <OSQPend+0x138>
            return ((void *)0);
        }
    }
                                                            /* Lock the scheduler/re-enable interrupts                */
    OS_CRITICAL_ENTER_CPU_EXIT();
    OS_Pend(&pend_data,                                     /* Block task pending on Message Queue                    */
 8005956:	4653      	mov	r3, sl
 8005958:	2205      	movs	r2, #5
 800595a:	4621      	mov	r1, r4
 800595c:	4668      	mov	r0, sp
 800595e:	f7fe fd93 	bl	8004488 <OS_Pend>
            (OS_PEND_OBJ *)((void *)p_q),
            OS_TASK_PEND_ON_Q,
            timeout);
    OS_CRITICAL_EXIT_NO_SCHED();
 8005962:	4658      	mov	r0, fp
 8005964:	f7fb ff0a 	bl	800177c <CPU_SR_Restore>

    OSSched();                                              /* Find the next highest priority task ready to run       */
 8005968:	f7fe f8de 	bl	8003b28 <OSSched>

    CPU_CRITICAL_ENTER();
 800596c:	f7fb ff02 	bl	8001774 <CPU_SR_Save>
    switch (OSTCBCurPtr->PendStatus) {
 8005970:	4b3d      	ldr	r3, [pc, #244]	; (8005a68 <OSQPend+0x178>)
 8005972:	681a      	ldr	r2, [r3, #0]
 8005974:	f892 3035 	ldrb.w	r3, [r2, #53]	; 0x35
 8005978:	2b03      	cmp	r3, #3
 800597a:	d84d      	bhi.n	8005a18 <OSQPend+0x128>
 800597c:	e8df f003 	tbb	[pc, r3]
 8005980:	0918232e 	.word	0x0918232e
    p_void = OS_MsgQGet(&p_q->MsgQ,                         /* Any message waiting in the message queue?              */
                        p_msg_size,
                        p_ts,
                        p_err);
    if (*p_err == OS_ERR_NONE) {
        CPU_CRITICAL_EXIT();
 8005984:	4658      	mov	r0, fp
 8005986:	f7fb fef9 	bl	800177c <CPU_SR_Restore>
        return (p_void);                                    /* Yes, Return message received                           */
 800598a:	4628      	mov	r0, r5
            *p_err      = OS_ERR_STATUS_INVALID;
             break;
    }
    CPU_CRITICAL_EXIT();
    return (p_void);
}
 800598c:	b009      	add	sp, #36	; 0x24
 800598e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            *p_err      = OS_ERR_PEND_ABORT;
             break;

        case OS_STATUS_PEND_TIMEOUT:                        /* Indicate that we didn't get event within TO            */
             p_void     = (void      *)0;
            *p_msg_size = (OS_MSG_SIZE)0;
 8005992:	2300      	movs	r3, #0
 8005994:	f8a8 3000 	strh.w	r3, [r8]
             if (p_ts  != (CPU_TS *)0) {
 8005998:	b107      	cbz	r7, 800599c <OSQPend+0xac>
                *p_ts   = (CPU_TS  )0;
 800599a:	603b      	str	r3, [r7, #0]
             }
            *p_err      = OS_ERR_TIMEOUT;
 800599c:	f247 23d9 	movw	r3, #29401	; 0x72d9
             }
            *p_err      = OS_ERR_PEND_ABORT;
             break;

        case OS_STATUS_PEND_TIMEOUT:                        /* Indicate that we didn't get event within TO            */
             p_void     = (void      *)0;
 80059a0:	2400      	movs	r4, #0
            *p_msg_size = (OS_MSG_SIZE)0;
             if (p_ts  != (CPU_TS *)0) {
                *p_ts   = (CPU_TS  )0;
             }
            *p_err      = OS_ERR_TIMEOUT;
 80059a2:	8033      	strh	r3, [r6, #0]
             p_void     = (void      *)0;
            *p_msg_size = (OS_MSG_SIZE)0;
            *p_err      = OS_ERR_STATUS_INVALID;
             break;
    }
    CPU_CRITICAL_EXIT();
 80059a4:	f7fb feea 	bl	800177c <CPU_SR_Restore>
    return (p_void);
 80059a8:	4620      	mov	r0, r4
}
 80059aa:	b009      	add	sp, #36	; 0x24
 80059ac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            *p_err      = OS_ERR_TIMEOUT;
             break;

        case OS_STATUS_PEND_DEL:                            /* Indicate that object pended on has been deleted        */
             p_void     = (void      *)0;
            *p_msg_size = (OS_MSG_SIZE)0;
 80059b0:	2300      	movs	r3, #0
 80059b2:	f8a8 3000 	strh.w	r3, [r8]
             if (p_ts  != (CPU_TS *)0) {
 80059b6:	b10f      	cbz	r7, 80059bc <OSQPend+0xcc>
                *p_ts   =  OSTCBCurPtr->TS;
 80059b8:	6c13      	ldr	r3, [r2, #64]	; 0x40
 80059ba:	603b      	str	r3, [r7, #0]
             }
            *p_err      = OS_ERR_OBJ_DEL;
 80059bc:	f645 53c2 	movw	r3, #24002	; 0x5dc2
             }
            *p_err      = OS_ERR_TIMEOUT;
             break;

        case OS_STATUS_PEND_DEL:                            /* Indicate that object pended on has been deleted        */
             p_void     = (void      *)0;
 80059c0:	2400      	movs	r4, #0
            *p_msg_size = (OS_MSG_SIZE)0;
             if (p_ts  != (CPU_TS *)0) {
                *p_ts   =  OSTCBCurPtr->TS;
             }
            *p_err      = OS_ERR_OBJ_DEL;
 80059c2:	8033      	strh	r3, [r6, #0]
             break;
 80059c4:	e7ee      	b.n	80059a4 <OSQPend+0xb4>
            *p_err      = OS_ERR_NONE;
             break;

        case OS_STATUS_PEND_ABORT:                          /* Indicate that we aborted                               */
             p_void     = (void      *)0;
            *p_msg_size = (OS_MSG_SIZE)0;
 80059c6:	2300      	movs	r3, #0
 80059c8:	f8a8 3000 	strh.w	r3, [r8]
             if (p_ts  != (CPU_TS *)0) {
 80059cc:	b10f      	cbz	r7, 80059d2 <OSQPend+0xe2>
                *p_ts   =  OSTCBCurPtr->TS;
 80059ce:	6c13      	ldr	r3, [r2, #64]	; 0x40
 80059d0:	603b      	str	r3, [r7, #0]
             }
            *p_err      = OS_ERR_PEND_ABORT;
 80059d2:	f246 13a9 	movw	r3, #25001	; 0x61a9
             }
            *p_err      = OS_ERR_NONE;
             break;

        case OS_STATUS_PEND_ABORT:                          /* Indicate that we aborted                               */
             p_void     = (void      *)0;
 80059d6:	2400      	movs	r4, #0
            *p_msg_size = (OS_MSG_SIZE)0;
             if (p_ts  != (CPU_TS *)0) {
                *p_ts   =  OSTCBCurPtr->TS;
             }
            *p_err      = OS_ERR_PEND_ABORT;
 80059d8:	8033      	strh	r3, [r6, #0]
             break;
 80059da:	e7e3      	b.n	80059a4 <OSQPend+0xb4>

    CPU_CRITICAL_ENTER();
    switch (OSTCBCurPtr->PendStatus) {
        case OS_STATUS_PEND_OK:                             /* Extract message from TCB (Put there by Post)           */
             p_void     = OSTCBCurPtr->MsgPtr;
            *p_msg_size = OSTCBCurPtr->MsgSize;
 80059dc:	f8b2 3060 	ldrh.w	r3, [r2, #96]	; 0x60
    OSSched();                                              /* Find the next highest priority task ready to run       */

    CPU_CRITICAL_ENTER();
    switch (OSTCBCurPtr->PendStatus) {
        case OS_STATUS_PEND_OK:                             /* Extract message from TCB (Put there by Post)           */
             p_void     = OSTCBCurPtr->MsgPtr;
 80059e0:	6dd4      	ldr	r4, [r2, #92]	; 0x5c
            *p_msg_size = OSTCBCurPtr->MsgSize;
 80059e2:	f8a8 3000 	strh.w	r3, [r8]
             if (p_ts  != (CPU_TS *)0) {
 80059e6:	b10f      	cbz	r7, 80059ec <OSQPend+0xfc>
                *p_ts   =  OSTCBCurPtr->TS;
 80059e8:	6c13      	ldr	r3, [r2, #64]	; 0x40
 80059ea:	603b      	str	r3, [r7, #0]
             }
            *p_err      = OS_ERR_NONE;
 80059ec:	2300      	movs	r3, #0
 80059ee:	8033      	strh	r3, [r6, #0]
             break;
 80059f0:	e7d8      	b.n	80059a4 <OSQPend+0xb4>
        case OS_OPT_PEND_BLOCKING:
        case OS_OPT_PEND_NON_BLOCKING:
             break;

        default:
            *p_err = OS_ERR_OPT_INVALID;
 80059f2:	f645 6325 	movw	r3, #24101	; 0x5e25
             return ((void *)0);
 80059f6:	4620      	mov	r0, r4
        case OS_OPT_PEND_BLOCKING:
        case OS_OPT_PEND_NON_BLOCKING:
             break;

        default:
            *p_err = OS_ERR_OPT_INVALID;
 80059f8:	8033      	strh	r3, [r6, #0]
             return ((void *)0);
 80059fa:	e7c7      	b.n	800598c <OSQPend+0x9c>
    }
#endif

#if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    if (p_q->Type != OS_OBJ_TYPE_Q) {                       /* Make sure message queue was created                    */
       *p_err = OS_ERR_OBJ_TYPE;
 80059fc:	f645 53c4 	movw	r3, #24004	; 0x5dc4
        return ((void *)0);
 8005a00:	2000      	movs	r0, #0
    }
#endif

#if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    if (p_q->Type != OS_OBJ_TYPE_Q) {                       /* Make sure message queue was created                    */
       *p_err = OS_ERR_OBJ_TYPE;
 8005a02:	8033      	strh	r3, [r6, #0]
            *p_err      = OS_ERR_STATUS_INVALID;
             break;
    }
    CPU_CRITICAL_EXIT();
    return (p_void);
}
 8005a04:	b009      	add	sp, #36	; 0x24
 8005a06:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
       *p_err = OS_ERR_PEND_ISR;
 8005a0a:	f246 13ae 	movw	r3, #25006	; 0x61ae
        return ((void *)0);
 8005a0e:	2000      	movs	r0, #0
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
       *p_err = OS_ERR_PEND_ISR;
 8005a10:	8033      	strh	r3, [r6, #0]
            *p_err      = OS_ERR_STATUS_INVALID;
             break;
    }
    CPU_CRITICAL_EXIT();
    return (p_void);
}
 8005a12:	b009      	add	sp, #36	; 0x24
 8005a14:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
             break;

        default:
             p_void     = (void      *)0;
            *p_msg_size = (OS_MSG_SIZE)0;
            *p_err      = OS_ERR_STATUS_INVALID;
 8005a18:	f646 622e 	movw	r2, #28206	; 0x6e2e
            *p_err      = OS_ERR_OBJ_DEL;
             break;

        default:
             p_void     = (void      *)0;
            *p_msg_size = (OS_MSG_SIZE)0;
 8005a1c:	2300      	movs	r3, #0
 8005a1e:	f8a8 3000 	strh.w	r3, [r8]
             }
            *p_err      = OS_ERR_OBJ_DEL;
             break;

        default:
             p_void     = (void      *)0;
 8005a22:	461c      	mov	r4, r3
            *p_msg_size = (OS_MSG_SIZE)0;
            *p_err      = OS_ERR_STATUS_INVALID;
 8005a24:	8032      	strh	r2, [r6, #0]
             break;
 8005a26:	e7bd      	b.n	80059a4 <OSQPend+0xb4>
        CPU_CRITICAL_EXIT();
       *p_err = OS_ERR_PEND_WOULD_BLOCK;                    /* No                                                     */
        return ((void *)0);
    } else {
        if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /* Can't pend when the scheduler is locked                */
            CPU_CRITICAL_EXIT();
 8005a28:	4658      	mov	r0, fp
 8005a2a:	f7fb fea7 	bl	800177c <CPU_SR_Restore>
           *p_err = OS_ERR_SCHED_LOCKED;
 8005a2e:	f646 5363 	movw	r3, #28003	; 0x6d63
            return ((void *)0);
 8005a32:	2000      	movs	r0, #0
       *p_err = OS_ERR_PEND_WOULD_BLOCK;                    /* No                                                     */
        return ((void *)0);
    } else {
        if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /* Can't pend when the scheduler is locked                */
            CPU_CRITICAL_EXIT();
           *p_err = OS_ERR_SCHED_LOCKED;
 8005a34:	8033      	strh	r3, [r6, #0]
            return ((void *)0);
 8005a36:	e7a9      	b.n	800598c <OSQPend+0x9c>
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_q == (OS_Q *)0) {                                 /* Validate arguments                                     */
       *p_err = OS_ERR_OBJ_PTR_NULL;
 8005a38:	f645 53c3 	movw	r3, #24003	; 0x5dc3
 8005a3c:	8033      	strh	r3, [r6, #0]
        return ((void *)0);
 8005a3e:	e7a5      	b.n	800598c <OSQPend+0x9c>
    }
    if (p_msg_size == (OS_MSG_SIZE *)0) {
       *p_err = OS_ERR_PTR_INVALID;
 8005a40:	f246 22d5 	movw	r2, #25301	; 0x62d5
        return ((void *)0);
 8005a44:	4618      	mov	r0, r3
    if (p_q == (OS_Q *)0) {                                 /* Validate arguments                                     */
       *p_err = OS_ERR_OBJ_PTR_NULL;
        return ((void *)0);
    }
    if (p_msg_size == (OS_MSG_SIZE *)0) {
       *p_err = OS_ERR_PTR_INVALID;
 8005a46:	8032      	strh	r2, [r6, #0]
        return ((void *)0);
 8005a48:	e7a0      	b.n	800598c <OSQPend+0x9c>
        CPU_CRITICAL_EXIT();
        return (p_void);                                    /* Yes, Return message received                           */
    }

    if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {    /* Caller wants to block if not available?                */
        CPU_CRITICAL_EXIT();
 8005a4a:	4658      	mov	r0, fp
 8005a4c:	f7fb fe96 	bl	800177c <CPU_SR_Restore>
       *p_err = OS_ERR_PEND_WOULD_BLOCK;                    /* No                                                     */
 8005a50:	f246 13b0 	movw	r3, #25008	; 0x61b0
        return ((void *)0);
 8005a54:	2000      	movs	r0, #0
        return (p_void);                                    /* Yes, Return message received                           */
    }

    if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {    /* Caller wants to block if not available?                */
        CPU_CRITICAL_EXIT();
       *p_err = OS_ERR_PEND_WOULD_BLOCK;                    /* No                                                     */
 8005a56:	8033      	strh	r3, [r6, #0]
        return ((void *)0);
 8005a58:	e798      	b.n	800598c <OSQPend+0x9c>
 8005a5a:	bf00      	nop
 8005a5c:	2000ed84 	.word	0x2000ed84
 8005a60:	55455551 	.word	0x55455551
 8005a64:	2000e974 	.word	0x2000e974
 8005a68:	2000ed58 	.word	0x2000ed58

08005a6c <OSQPendAbort>:

#if OS_CFG_Q_PEND_ABORT_EN > 0u
OS_OBJ_QTY  OSQPendAbort (OS_Q    *p_q,
                          OS_OPT   opt,
                          OS_ERR  *p_err)
{
 8005a6c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
        return ((OS_OBJ_QTY)0u);
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0u) {             /* Not allowed to Pend Abort from an ISR                  */
 8005a70:	4b2e      	ldr	r3, [pc, #184]	; (8005b2c <OSQPendAbort+0xc0>)
 8005a72:	781b      	ldrb	r3, [r3, #0]
 8005a74:	b9fb      	cbnz	r3, 8005ab6 <OSQPendAbort+0x4a>
        return ((OS_OBJ_QTY)0u);
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_q == (OS_Q *)0) {                                 /* Validate 'p_q'                                         */
 8005a76:	2800      	cmp	r0, #0
 8005a78:	d04d      	beq.n	8005b16 <OSQPendAbort+0xaa>
       *p_err =  OS_ERR_OBJ_PTR_NULL;
        return ((OS_OBJ_QTY)0u);
    }
    switch (opt) {                                          /* Validate 'opt'                                         */
 8005a7a:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 8005a7e:	d00f      	beq.n	8005aa0 <OSQPendAbort+0x34>
 8005a80:	d90c      	bls.n	8005a9c <OSQPendAbort+0x30>
 8005a82:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 8005a86:	d00b      	beq.n	8005aa0 <OSQPendAbort+0x34>
 8005a88:	f5b1 4f01 	cmp.w	r1, #33024	; 0x8100
 8005a8c:	d008      	beq.n	8005aa0 <OSQPendAbort+0x34>
        case OS_OPT_PEND_ABORT_1   | OS_OPT_POST_NO_SCHED:
        case OS_OPT_PEND_ABORT_ALL | OS_OPT_POST_NO_SCHED:
             break;

        default:
            *p_err =  OS_ERR_OPT_INVALID;
 8005a8e:	f645 6325 	movw	r3, #24101	; 0x5e25
             return ((OS_OBJ_QTY)0u);
 8005a92:	2400      	movs	r4, #0
        case OS_OPT_PEND_ABORT_1   | OS_OPT_POST_NO_SCHED:
        case OS_OPT_PEND_ABORT_ALL | OS_OPT_POST_NO_SCHED:
             break;

        default:
            *p_err =  OS_ERR_OPT_INVALID;
 8005a94:	8013      	strh	r3, [r2, #0]
        OSSched();                                          /* Run the scheduler                                      */
    }

   *p_err = OS_ERR_NONE;
    return (nbr_tasks);
}
 8005a96:	4620      	mov	r0, r4
 8005a98:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
#if OS_CFG_ARG_CHK_EN > 0u
    if (p_q == (OS_Q *)0) {                                 /* Validate 'p_q'                                         */
       *p_err =  OS_ERR_OBJ_PTR_NULL;
        return ((OS_OBJ_QTY)0u);
    }
    switch (opt) {                                          /* Validate 'opt'                                         */
 8005a9c:	2900      	cmp	r1, #0
 8005a9e:	d1f6      	bne.n	8005a8e <OSQPendAbort+0x22>
             return ((OS_OBJ_QTY)0u);
    }
#endif

#if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    if (p_q->Type != OS_OBJ_TYPE_Q) {                       /* Make sure queue was created                            */
 8005aa0:	4b23      	ldr	r3, [pc, #140]	; (8005b30 <OSQPendAbort+0xc4>)
 8005aa2:	6804      	ldr	r4, [r0, #0]
 8005aa4:	429c      	cmp	r4, r3
 8005aa6:	d00d      	beq.n	8005ac4 <OSQPendAbort+0x58>
       *p_err =  OS_ERR_OBJ_TYPE;
 8005aa8:	f645 53c4 	movw	r3, #24004	; 0x5dc4
        return ((OS_OBJ_QTY)0u);
 8005aac:	2400      	movs	r4, #0
    }
#endif

#if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    if (p_q->Type != OS_OBJ_TYPE_Q) {                       /* Make sure queue was created                            */
       *p_err =  OS_ERR_OBJ_TYPE;
 8005aae:	8013      	strh	r3, [r2, #0]
        OSSched();                                          /* Run the scheduler                                      */
    }

   *p_err = OS_ERR_NONE;
    return (nbr_tasks);
}
 8005ab0:	4620      	mov	r0, r4
 8005ab2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0u) {             /* Not allowed to Pend Abort from an ISR                  */
       *p_err =  OS_ERR_PEND_ABORT_ISR;
 8005ab6:	f246 13aa 	movw	r3, #25002	; 0x61aa
        return ((OS_OBJ_QTY)0u);
 8005aba:	2400      	movs	r4, #0
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0u) {             /* Not allowed to Pend Abort from an ISR                  */
       *p_err =  OS_ERR_PEND_ABORT_ISR;
 8005abc:	8013      	strh	r3, [r2, #0]
        OSSched();                                          /* Run the scheduler                                      */
    }

   *p_err = OS_ERR_NONE;
    return (nbr_tasks);
}
 8005abe:	4620      	mov	r0, r4
 8005ac0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8005ac4:	4680      	mov	r8, r0
 8005ac6:	4617      	mov	r7, r2
 8005ac8:	460e      	mov	r6, r1
       *p_err =  OS_ERR_OBJ_TYPE;
        return ((OS_OBJ_QTY)0u);
    }
#endif

    CPU_CRITICAL_ENTER();
 8005aca:	f7fb fe53 	bl	8001774 <CPU_SR_Save>
    p_pend_list = &p_q->PendList;
    if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0u) {        /* Any task waiting on queue?                             */
 8005ace:	f8b8 4010 	ldrh.w	r4, [r8, #16]
       *p_err =  OS_ERR_OBJ_TYPE;
        return ((OS_OBJ_QTY)0u);
    }
#endif

    CPU_CRITICAL_ENTER();
 8005ad2:	4681      	mov	r9, r0
    p_pend_list = &p_q->PendList;
    if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0u) {        /* Any task waiting on queue?                             */
 8005ad4:	b324      	cbz	r4, 8005b20 <OSQPendAbort+0xb4>
        return ((OS_OBJ_QTY)0u);
    }

    OS_CRITICAL_ENTER_CPU_EXIT();
    nbr_tasks = 0u;
    ts        = OS_TS_GET();                                /* Get local time stamp so all tasks get the same time    */
 8005ad6:	f7fb f859 	bl	8000b8c <CPU_TS_TmrRd>
       *p_err =  OS_ERR_PEND_ABORT_NONE;
        return ((OS_OBJ_QTY)0u);
    }

    OS_CRITICAL_ENTER_CPU_EXIT();
    nbr_tasks = 0u;
 8005ada:	2500      	movs	r5, #0
    ts        = OS_TS_GET();                                /* Get local time stamp so all tasks get the same time    */
 8005adc:	4604      	mov	r4, r0
    while (p_pend_list->NbrEntries > (OS_OBJ_QTY)0u) {
 8005ade:	e00b      	b.n	8005af8 <OSQPendAbort+0x8c>
        p_tcb = p_pend_list->HeadPtr->TCBPtr;
 8005ae0:	f8d8 3008 	ldr.w	r3, [r8, #8]
        OS_PendAbort((OS_PEND_OBJ *)((void *)p_q),
 8005ae4:	4622      	mov	r2, r4
 8005ae6:	6899      	ldr	r1, [r3, #8]
 8005ae8:	4640      	mov	r0, r8
 8005aea:	f7fe fd29 	bl	8004540 <OS_PendAbort>
                     p_tcb,
                     ts);
        nbr_tasks++;
 8005aee:	3501      	adds	r5, #1
        if (opt != OS_OPT_PEND_ABORT_ALL) {                 /* Pend abort all tasks waiting?                          */
 8005af0:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
    while (p_pend_list->NbrEntries > (OS_OBJ_QTY)0u) {
        p_tcb = p_pend_list->HeadPtr->TCBPtr;
        OS_PendAbort((OS_PEND_OBJ *)((void *)p_q),
                     p_tcb,
                     ts);
        nbr_tasks++;
 8005af4:	b2ad      	uxth	r5, r5
        if (opt != OS_OPT_PEND_ABORT_ALL) {                 /* Pend abort all tasks waiting?                          */
 8005af6:	d103      	bne.n	8005b00 <OSQPendAbort+0x94>
    }

    OS_CRITICAL_ENTER_CPU_EXIT();
    nbr_tasks = 0u;
    ts        = OS_TS_GET();                                /* Get local time stamp so all tasks get the same time    */
    while (p_pend_list->NbrEntries > (OS_OBJ_QTY)0u) {
 8005af8:	f8b8 3010 	ldrh.w	r3, [r8, #16]
 8005afc:	2b00      	cmp	r3, #0
 8005afe:	d1ef      	bne.n	8005ae0 <OSQPendAbort+0x74>
        nbr_tasks++;
        if (opt != OS_OPT_PEND_ABORT_ALL) {                 /* Pend abort all tasks waiting?                          */
            break;                                          /* No                                                     */
        }
    }
    OS_CRITICAL_EXIT_NO_SCHED();
 8005b00:	4648      	mov	r0, r9
 8005b02:	f7fb fe3b 	bl	800177c <CPU_SR_Restore>

    if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0u) {
 8005b06:	0433      	lsls	r3, r6, #16
 8005b08:	d401      	bmi.n	8005b0e <OSQPendAbort+0xa2>
        OSSched();                                          /* Run the scheduler                                      */
 8005b0a:	f7fe f80d 	bl	8003b28 <OSSched>
    }

   *p_err = OS_ERR_NONE;
 8005b0e:	2300      	movs	r3, #0
    return (nbr_tasks);
 8005b10:	462c      	mov	r4, r5

    if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0u) {
        OSSched();                                          /* Run the scheduler                                      */
    }

   *p_err = OS_ERR_NONE;
 8005b12:	803b      	strh	r3, [r7, #0]
    return (nbr_tasks);
 8005b14:	e7cc      	b.n	8005ab0 <OSQPendAbort+0x44>
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_q == (OS_Q *)0) {                                 /* Validate 'p_q'                                         */
       *p_err =  OS_ERR_OBJ_PTR_NULL;
 8005b16:	f645 53c3 	movw	r3, #24003	; 0x5dc3
        return ((OS_OBJ_QTY)0u);
 8005b1a:	4604      	mov	r4, r0
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_q == (OS_Q *)0) {                                 /* Validate 'p_q'                                         */
       *p_err =  OS_ERR_OBJ_PTR_NULL;
 8005b1c:	8013      	strh	r3, [r2, #0]
        return ((OS_OBJ_QTY)0u);
 8005b1e:	e7c7      	b.n	8005ab0 <OSQPendAbort+0x44>
#endif

    CPU_CRITICAL_ENTER();
    p_pend_list = &p_q->PendList;
    if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0u) {        /* Any task waiting on queue?                             */
        CPU_CRITICAL_EXIT();                                /* No                                                     */
 8005b20:	f7fb fe2c 	bl	800177c <CPU_SR_Restore>
       *p_err =  OS_ERR_PEND_ABORT_NONE;
 8005b24:	f246 13ab 	movw	r3, #25003	; 0x61ab
 8005b28:	803b      	strh	r3, [r7, #0]
        return ((OS_OBJ_QTY)0u);
 8005b2a:	e7c1      	b.n	8005ab0 <OSQPendAbort+0x44>
 8005b2c:	2000ed84 	.word	0x2000ed84
 8005b30:	55455551 	.word	0x55455551

08005b34 <OS_QClr>:
* Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
************************************************************************************************************************
*/

void  OS_QClr (OS_Q  *p_q)
{
 8005b34:	b538      	push	{r3, r4, r5, lr}
 8005b36:	4604      	mov	r4, r0
    (void)OS_MsgQFreeAll(&p_q->MsgQ);                       /* Return all OS_MSGs to the free list                    */
 8005b38:	f100 0520 	add.w	r5, r0, #32
 8005b3c:	4628      	mov	r0, r5
 8005b3e:	f7ff fb53 	bl	80051e8 <OS_MsgQFreeAll>
    p_q->Type    =  OS_OBJ_TYPE_NONE;                       /* Mark the data structure as a NONE                      */
    p_q->NamePtr = (CPU_CHAR *)((void *)"?Q");
 8005b42:	4b07      	ldr	r3, [pc, #28]	; (8005b60 <OS_QClr+0x2c>)
*/

void  OS_QClr (OS_Q  *p_q)
{
    (void)OS_MsgQFreeAll(&p_q->MsgQ);                       /* Return all OS_MSGs to the free list                    */
    p_q->Type    =  OS_OBJ_TYPE_NONE;                       /* Mark the data structure as a NONE                      */
 8005b44:	4a07      	ldr	r2, [pc, #28]	; (8005b64 <OS_QClr+0x30>)
    p_q->NamePtr = (CPU_CHAR *)((void *)"?Q");
    OS_MsgQInit(&p_q->MsgQ,                                 /* Initialize the list of OS_MSGs                         */
 8005b46:	4628      	mov	r0, r5

void  OS_QClr (OS_Q  *p_q)
{
    (void)OS_MsgQFreeAll(&p_q->MsgQ);                       /* Return all OS_MSGs to the free list                    */
    p_q->Type    =  OS_OBJ_TYPE_NONE;                       /* Mark the data structure as a NONE                      */
    p_q->NamePtr = (CPU_CHAR *)((void *)"?Q");
 8005b48:	e884 000c 	stmia.w	r4, {r2, r3}
    OS_MsgQInit(&p_q->MsgQ,                                 /* Initialize the list of OS_MSGs                         */
 8005b4c:	2100      	movs	r1, #0
 8005b4e:	f7ff fb65 	bl	800521c <OS_MsgQInit>
                0u);
    OS_PendListInit(&p_q->PendList);                        /* Initialize the waiting list                            */
 8005b52:	f104 0008 	add.w	r0, r4, #8
}
 8005b56:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    (void)OS_MsgQFreeAll(&p_q->MsgQ);                       /* Return all OS_MSGs to the free list                    */
    p_q->Type    =  OS_OBJ_TYPE_NONE;                       /* Mark the data structure as a NONE                      */
    p_q->NamePtr = (CPU_CHAR *)((void *)"?Q");
    OS_MsgQInit(&p_q->MsgQ,                                 /* Initialize the list of OS_MSGs                         */
                0u);
    OS_PendListInit(&p_q->PendList);                        /* Initialize the waiting list                            */
 8005b5a:	f7fe b9ff 	b.w	8003f5c <OS_PendListInit>
 8005b5e:	bf00      	nop
 8005b60:	0801666c 	.word	0x0801666c
 8005b64:	454e4f4e 	.word	0x454e4f4e

08005b68 <OSQDel>:

#if OS_CFG_Q_DEL_EN > 0u
OS_OBJ_QTY  OSQDel (OS_Q    *p_q,
                    OS_OPT   opt,
                    OS_ERR  *p_err)
{
 8005b68:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
        return ((OS_OBJ_QTY)0);
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't delete a message queue from an ISR               */
 8005b6c:	4b44      	ldr	r3, [pc, #272]	; (8005c80 <OSQDel+0x118>)
 8005b6e:	781b      	ldrb	r3, [r3, #0]
 8005b70:	b99b      	cbnz	r3, 8005b9a <OSQDel+0x32>
        return ((OS_OBJ_QTY)0);
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_q == (OS_Q *)0) {                                 /* Validate 'p_q'                                         */
 8005b72:	2800      	cmp	r0, #0
 8005b74:	d03b      	beq.n	8005bee <OSQDel+0x86>
       *p_err =  OS_ERR_OBJ_PTR_NULL;
        return ((OS_OBJ_QTY)0u);
    }
    switch (opt) {                                          /* Validate 'opt'                                         */
 8005b76:	2901      	cmp	r1, #1
 8005b78:	d809      	bhi.n	8005b8e <OSQDel+0x26>
             return ((OS_OBJ_QTY)0u);
    }
#endif

#if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    if (p_q->Type != OS_OBJ_TYPE_Q) {                       /* Make sure message queue was created                    */
 8005b7a:	4c42      	ldr	r4, [pc, #264]	; (8005c84 <OSQDel+0x11c>)
 8005b7c:	6805      	ldr	r5, [r0, #0]
 8005b7e:	42a5      	cmp	r5, r4
 8005b80:	d011      	beq.n	8005ba6 <OSQDel+0x3e>
       *p_err = OS_ERR_OBJ_TYPE;
 8005b82:	f645 51c4 	movw	r1, #24004	; 0x5dc4
        return ((OS_OBJ_QTY)0);
 8005b86:	4618      	mov	r0, r3
    }
#endif

#if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    if (p_q->Type != OS_OBJ_TYPE_Q) {                       /* Make sure message queue was created                    */
       *p_err = OS_ERR_OBJ_TYPE;
 8005b88:	8011      	strh	r1, [r2, #0]
        return ((OS_OBJ_QTY)0);
 8005b8a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        case OS_OPT_DEL_NO_PEND:
        case OS_OPT_DEL_ALWAYS:
             break;

        default:
            *p_err =  OS_ERR_OPT_INVALID;
 8005b8e:	f645 6125 	movw	r1, #24101	; 0x5e25
             return ((OS_OBJ_QTY)0u);
 8005b92:	4618      	mov	r0, r3
        case OS_OPT_DEL_NO_PEND:
        case OS_OPT_DEL_ALWAYS:
             break;

        default:
            *p_err =  OS_ERR_OPT_INVALID;
 8005b94:	8011      	strh	r1, [r2, #0]
             return ((OS_OBJ_QTY)0u);
 8005b96:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't delete a message queue from an ISR               */
       *p_err = OS_ERR_DEL_ISR;
 8005b9a:	f243 23c9 	movw	r3, #13001	; 0x32c9
        return ((OS_OBJ_QTY)0);
 8005b9e:	2000      	movs	r0, #0
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't delete a message queue from an ISR               */
       *p_err = OS_ERR_DEL_ISR;
 8005ba0:	8013      	strh	r3, [r2, #0]
        return ((OS_OBJ_QTY)0);
 8005ba2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8005ba6:	460f      	mov	r7, r1
 8005ba8:	4605      	mov	r5, r0
 8005baa:	4616      	mov	r6, r2
       *p_err = OS_ERR_OBJ_TYPE;
        return ((OS_OBJ_QTY)0);
    }
#endif

    CPU_CRITICAL_ENTER();
 8005bac:	f7fb fde2 	bl	8001774 <CPU_SR_Save>
    p_pend_list = &p_q->PendList;
    cnt         = p_pend_list->NbrEntries;
    nbr_tasks   = cnt;
    switch (opt) {
 8005bb0:	2f01      	cmp	r7, #1
       *p_err = OS_ERR_OBJ_TYPE;
        return ((OS_OBJ_QTY)0);
    }
#endif

    CPU_CRITICAL_ENTER();
 8005bb2:	4680      	mov	r8, r0
    p_pend_list = &p_q->PendList;
    cnt         = p_pend_list->NbrEntries;
 8005bb4:	8a2c      	ldrh	r4, [r5, #16]
    nbr_tasks   = cnt;
    switch (opt) {
 8005bb6:	d01f      	beq.n	8005bf8 <OSQDel+0x90>
        case OS_OPT_DEL_NO_PEND:                            /* Delete message queue only if no task waiting           */
             if (nbr_tasks == (OS_OBJ_QTY)0) {
 8005bb8:	2c00      	cmp	r4, #0
 8005bba:	d146      	bne.n	8005c4a <OSQDel+0xe2>
{
    OS_Q  *p_q_next;
    OS_Q  *p_q_prev;


    p_q_prev = p_q->DbgPrevPtr;
 8005bbc:	696a      	ldr	r2, [r5, #20]
    p_q_next = p_q->DbgNextPtr;
 8005bbe:	69ab      	ldr	r3, [r5, #24]

    if (p_q_prev == (OS_Q *)0) {
 8005bc0:	2a00      	cmp	r2, #0
 8005bc2:	d054      	beq.n	8005c6e <OSQDel+0x106>
            p_q_next->DbgPrevPtr = (OS_Q *)0;
        }
        p_q->DbgNextPtr = (OS_Q *)0;

    } else if (p_q_next == (OS_Q *)0) {
        p_q_prev->DbgNextPtr = (OS_Q *)0;
 8005bc4:	6193      	str	r3, [r2, #24]
        if (p_q_next != (OS_Q *)0) {
            p_q_next->DbgPrevPtr = (OS_Q *)0;
        }
        p_q->DbgNextPtr = (OS_Q *)0;

    } else if (p_q_next == (OS_Q *)0) {
 8005bc6:	2b00      	cmp	r3, #0
 8005bc8:	d058      	beq.n	8005c7c <OSQDel+0x114>
        p_q_prev->DbgNextPtr = (OS_Q *)0;
        p_q->DbgPrevPtr      = (OS_Q *)0;

    } else {
        p_q_prev->DbgNextPtr =  p_q_next;
        p_q_next->DbgPrevPtr =  p_q_prev;
 8005bca:	615a      	str	r2, [r3, #20]
        p_q->DbgNextPtr      = (OS_Q *)0;
 8005bcc:	61ac      	str	r4, [r5, #24]
        p_q->DbgPrevPtr      = (OS_Q *)0;
 8005bce:	616c      	str	r4, [r5, #20]
        case OS_OPT_DEL_NO_PEND:                            /* Delete message queue only if no task waiting           */
             if (nbr_tasks == (OS_OBJ_QTY)0) {
#if OS_CFG_DBG_EN > 0u
                 OS_QDbgListRemove(p_q);
#endif
                 OSQQty--;
 8005bd0:	4a2d      	ldr	r2, [pc, #180]	; (8005c88 <OSQDel+0x120>)
                 OS_QClr(p_q);
 8005bd2:	4628      	mov	r0, r5
        case OS_OPT_DEL_NO_PEND:                            /* Delete message queue only if no task waiting           */
             if (nbr_tasks == (OS_OBJ_QTY)0) {
#if OS_CFG_DBG_EN > 0u
                 OS_QDbgListRemove(p_q);
#endif
                 OSQQty--;
 8005bd4:	8813      	ldrh	r3, [r2, #0]
 8005bd6:	3b01      	subs	r3, #1
 8005bd8:	8013      	strh	r3, [r2, #0]
                 OS_QClr(p_q);
 8005bda:	f7ff ffab 	bl	8005b34 <OS_QClr>
                 CPU_CRITICAL_EXIT();
 8005bde:	4640      	mov	r0, r8
 8005be0:	f7fb fdcc 	bl	800177c <CPU_SR_Restore>
                *p_err = OS_ERR_NONE;
 8005be4:	2300      	movs	r3, #0
 8005be6:	8033      	strh	r3, [r6, #0]
 8005be8:	4618      	mov	r0, r3
 8005bea:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_q == (OS_Q *)0) {                                 /* Validate 'p_q'                                         */
       *p_err =  OS_ERR_OBJ_PTR_NULL;
 8005bee:	f645 53c3 	movw	r3, #24003	; 0x5dc3
 8005bf2:	8013      	strh	r3, [r2, #0]
        return ((OS_OBJ_QTY)0u);
 8005bf4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
             }
             break;

        case OS_OPT_DEL_ALWAYS:                             /* Always delete the message queue                        */
             OS_CRITICAL_ENTER_CPU_EXIT();
             ts = OS_TS_GET();                              /* Get local time stamp so all tasks get the same time    */
 8005bf8:	f7fa ffc8 	bl	8000b8c <CPU_TS_TmrRd>
             while (cnt > 0u) {                             /* Remove all tasks from the pend list                    */
 8005bfc:	4627      	mov	r7, r4
             }
             break;

        case OS_OPT_DEL_ALWAYS:                             /* Always delete the message queue                        */
             OS_CRITICAL_ENTER_CPU_EXIT();
             ts = OS_TS_GET();                              /* Get local time stamp so all tasks get the same time    */
 8005bfe:	4681      	mov	r9, r0
             while (cnt > 0u) {                             /* Remove all tasks from the pend list                    */
 8005c00:	b14c      	cbz	r4, 8005c16 <OSQDel+0xae>
                 p_pend_data = p_pend_list->HeadPtr;
                 p_tcb       = p_pend_data->TCBPtr;
 8005c02:	68ab      	ldr	r3, [r5, #8]
                 OS_PendObjDel((OS_PEND_OBJ *)((void *)p_q),
                               p_tcb,
                               ts);
                 cnt--;
 8005c04:	3f01      	subs	r7, #1
             OS_CRITICAL_ENTER_CPU_EXIT();
             ts = OS_TS_GET();                              /* Get local time stamp so all tasks get the same time    */
             while (cnt > 0u) {                             /* Remove all tasks from the pend list                    */
                 p_pend_data = p_pend_list->HeadPtr;
                 p_tcb       = p_pend_data->TCBPtr;
                 OS_PendObjDel((OS_PEND_OBJ *)((void *)p_q),
 8005c06:	464a      	mov	r2, r9
 8005c08:	6899      	ldr	r1, [r3, #8]
 8005c0a:	4628      	mov	r0, r5
                               p_tcb,
                               ts);
                 cnt--;
 8005c0c:	b2bf      	uxth	r7, r7
             OS_CRITICAL_ENTER_CPU_EXIT();
             ts = OS_TS_GET();                              /* Get local time stamp so all tasks get the same time    */
             while (cnt > 0u) {                             /* Remove all tasks from the pend list                    */
                 p_pend_data = p_pend_list->HeadPtr;
                 p_tcb       = p_pend_data->TCBPtr;
                 OS_PendObjDel((OS_PEND_OBJ *)((void *)p_q),
 8005c0e:	f7fe fd01 	bl	8004614 <OS_PendObjDel>
             break;

        case OS_OPT_DEL_ALWAYS:                             /* Always delete the message queue                        */
             OS_CRITICAL_ENTER_CPU_EXIT();
             ts = OS_TS_GET();                              /* Get local time stamp so all tasks get the same time    */
             while (cnt > 0u) {                             /* Remove all tasks from the pend list                    */
 8005c12:	2f00      	cmp	r7, #0
 8005c14:	d1f5      	bne.n	8005c02 <OSQDel+0x9a>
{
    OS_Q  *p_q_next;
    OS_Q  *p_q_prev;


    p_q_prev = p_q->DbgPrevPtr;
 8005c16:	696a      	ldr	r2, [r5, #20]
    p_q_next = p_q->DbgNextPtr;
 8005c18:	69ab      	ldr	r3, [r5, #24]

    if (p_q_prev == (OS_Q *)0) {
 8005c1a:	b1f2      	cbz	r2, 8005c5a <OSQDel+0xf2>
        if (p_q_next != (OS_Q *)0) {
            p_q_next->DbgPrevPtr = (OS_Q *)0;
        }
        p_q->DbgNextPtr = (OS_Q *)0;

    } else if (p_q_next == (OS_Q *)0) {
 8005c1c:	b323      	cbz	r3, 8005c68 <OSQDel+0x100>
        p_q->DbgPrevPtr      = (OS_Q *)0;

    } else {
        p_q_prev->DbgNextPtr =  p_q_next;
        p_q_next->DbgPrevPtr =  p_q_prev;
        p_q->DbgNextPtr      = (OS_Q *)0;
 8005c1e:	2100      	movs	r1, #0
    } else if (p_q_next == (OS_Q *)0) {
        p_q_prev->DbgNextPtr = (OS_Q *)0;
        p_q->DbgPrevPtr      = (OS_Q *)0;

    } else {
        p_q_prev->DbgNextPtr =  p_q_next;
 8005c20:	6193      	str	r3, [r2, #24]
        p_q_next->DbgPrevPtr =  p_q_prev;
 8005c22:	615a      	str	r2, [r3, #20]
        p_q->DbgNextPtr      = (OS_Q *)0;
 8005c24:	61a9      	str	r1, [r5, #24]
        p_q->DbgPrevPtr      = (OS_Q *)0;
 8005c26:	6169      	str	r1, [r5, #20]
                 cnt--;
             }
#if OS_CFG_DBG_EN > 0u
             OS_QDbgListRemove(p_q);
#endif
             OSQQty--;
 8005c28:	4a17      	ldr	r2, [pc, #92]	; (8005c88 <OSQDel+0x120>)
             OS_QClr(p_q);
 8005c2a:	4628      	mov	r0, r5
                 cnt--;
             }
#if OS_CFG_DBG_EN > 0u
             OS_QDbgListRemove(p_q);
#endif
             OSQQty--;
 8005c2c:	8813      	ldrh	r3, [r2, #0]
 8005c2e:	3b01      	subs	r3, #1
 8005c30:	8013      	strh	r3, [r2, #0]
             OS_QClr(p_q);
 8005c32:	f7ff ff7f 	bl	8005b34 <OS_QClr>
             OS_CRITICAL_EXIT_NO_SCHED();
 8005c36:	4640      	mov	r0, r8
 8005c38:	f7fb fda0 	bl	800177c <CPU_SR_Restore>
             OSSched();                                     /* Find highest priority task ready to run                */
 8005c3c:	f7fd ff74 	bl	8003b28 <OSSched>
            *p_err = OS_ERR_NONE;
 8005c40:	2300      	movs	r3, #0
    }
#endif

    CPU_CRITICAL_ENTER();
    p_pend_list = &p_q->PendList;
    cnt         = p_pend_list->NbrEntries;
 8005c42:	4620      	mov	r0, r4
#endif
             OSQQty--;
             OS_QClr(p_q);
             OS_CRITICAL_EXIT_NO_SCHED();
             OSSched();                                     /* Find highest priority task ready to run                */
            *p_err = OS_ERR_NONE;
 8005c44:	8033      	strh	r3, [r6, #0]
             CPU_CRITICAL_EXIT();
            *p_err = OS_ERR_OPT_INVALID;
             break;
    }
    return (nbr_tasks);
}
 8005c46:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
                 OSQQty--;
                 OS_QClr(p_q);
                 CPU_CRITICAL_EXIT();
                *p_err = OS_ERR_NONE;
             } else {
                 CPU_CRITICAL_EXIT();
 8005c4a:	f7fb fd97 	bl	800177c <CPU_SR_Restore>
                *p_err = OS_ERR_TASK_WAITING;
 8005c4e:	f247 135f 	movw	r3, #29023	; 0x715f
 8005c52:	4620      	mov	r0, r4
 8005c54:	8033      	strh	r3, [r6, #0]
 8005c56:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

    p_q_prev = p_q->DbgPrevPtr;
    p_q_next = p_q->DbgNextPtr;

    if (p_q_prev == (OS_Q *)0) {
        OSQDbgListPtr = p_q_next;
 8005c5a:	490c      	ldr	r1, [pc, #48]	; (8005c8c <OSQDel+0x124>)
 8005c5c:	600b      	str	r3, [r1, #0]
        if (p_q_next != (OS_Q *)0) {
 8005c5e:	b103      	cbz	r3, 8005c62 <OSQDel+0xfa>
            p_q_next->DbgPrevPtr = (OS_Q *)0;
 8005c60:	615a      	str	r2, [r3, #20]
        }
        p_q->DbgNextPtr = (OS_Q *)0;
 8005c62:	2300      	movs	r3, #0
 8005c64:	61ab      	str	r3, [r5, #24]
 8005c66:	e7df      	b.n	8005c28 <OSQDel+0xc0>

    } else if (p_q_next == (OS_Q *)0) {
        p_q_prev->DbgNextPtr = (OS_Q *)0;
 8005c68:	6193      	str	r3, [r2, #24]
        p_q->DbgPrevPtr      = (OS_Q *)0;
 8005c6a:	616b      	str	r3, [r5, #20]
 8005c6c:	e7dc      	b.n	8005c28 <OSQDel+0xc0>

    p_q_prev = p_q->DbgPrevPtr;
    p_q_next = p_q->DbgNextPtr;

    if (p_q_prev == (OS_Q *)0) {
        OSQDbgListPtr = p_q_next;
 8005c6e:	4907      	ldr	r1, [pc, #28]	; (8005c8c <OSQDel+0x124>)
 8005c70:	600b      	str	r3, [r1, #0]
        if (p_q_next != (OS_Q *)0) {
 8005c72:	b103      	cbz	r3, 8005c76 <OSQDel+0x10e>
            p_q_next->DbgPrevPtr = (OS_Q *)0;
 8005c74:	615a      	str	r2, [r3, #20]
        }
        p_q->DbgNextPtr = (OS_Q *)0;
 8005c76:	2300      	movs	r3, #0
 8005c78:	61ab      	str	r3, [r5, #24]
 8005c7a:	e7a9      	b.n	8005bd0 <OSQDel+0x68>

    } else if (p_q_next == (OS_Q *)0) {
        p_q_prev->DbgNextPtr = (OS_Q *)0;
        p_q->DbgPrevPtr      = (OS_Q *)0;
 8005c7c:	616b      	str	r3, [r5, #20]
 8005c7e:	e7a7      	b.n	8005bd0 <OSQDel+0x68>
 8005c80:	2000ed84 	.word	0x2000ed84
 8005c84:	55455551 	.word	0x55455551
 8005c88:	2000ed5c 	.word	0x2000ed5c
 8005c8c:	2000ef1c 	.word	0x2000ef1c

08005c90 <OS_QDbgListAdd>:
#if OS_CFG_DBG_EN > 0u
void  OS_QDbgListAdd (OS_Q  *p_q)
{
    p_q->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
    p_q->DbgPrevPtr               = (OS_Q     *)0;
    if (OSQDbgListPtr == (OS_Q *)0) {
 8005c90:	4a06      	ldr	r2, [pc, #24]	; (8005cac <OS_QDbgListAdd+0x1c>)
*/


#if OS_CFG_DBG_EN > 0u
void  OS_QDbgListAdd (OS_Q  *p_q)
{
 8005c92:	b410      	push	{r4}
    p_q->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
    p_q->DbgPrevPtr               = (OS_Q     *)0;
    if (OSQDbgListPtr == (OS_Q *)0) {
 8005c94:	6813      	ldr	r3, [r2, #0]


#if OS_CFG_DBG_EN > 0u
void  OS_QDbgListAdd (OS_Q  *p_q)
{
    p_q->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
 8005c96:	4c06      	ldr	r4, [pc, #24]	; (8005cb0 <OS_QDbgListAdd+0x20>)
    p_q->DbgPrevPtr               = (OS_Q     *)0;
 8005c98:	2100      	movs	r1, #0


#if OS_CFG_DBG_EN > 0u
void  OS_QDbgListAdd (OS_Q  *p_q)
{
    p_q->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
 8005c9a:	61c4      	str	r4, [r0, #28]
    p_q->DbgPrevPtr               = (OS_Q     *)0;
 8005c9c:	6141      	str	r1, [r0, #20]
    if (OSQDbgListPtr == (OS_Q *)0) {
        p_q->DbgNextPtr           = (OS_Q     *)0;
 8005c9e:	6183      	str	r3, [r0, #24]
#if OS_CFG_DBG_EN > 0u
void  OS_QDbgListAdd (OS_Q  *p_q)
{
    p_q->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
    p_q->DbgPrevPtr               = (OS_Q     *)0;
    if (OSQDbgListPtr == (OS_Q *)0) {
 8005ca0:	b103      	cbz	r3, 8005ca4 <OS_QDbgListAdd+0x14>
        p_q->DbgNextPtr           = (OS_Q     *)0;
    } else {
        p_q->DbgNextPtr           =  OSQDbgListPtr;
        OSQDbgListPtr->DbgPrevPtr =  p_q;
 8005ca2:	6158      	str	r0, [r3, #20]
    }
    OSQDbgListPtr                 =  p_q;
 8005ca4:	6010      	str	r0, [r2, #0]
}
 8005ca6:	bc10      	pop	{r4}
 8005ca8:	4770      	bx	lr
 8005caa:	bf00      	nop
 8005cac:	2000ef1c 	.word	0x2000ef1c
 8005cb0:	080182f0 	.word	0x080182f0

08005cb4 <OS_QDbgListRemove>:
{
    OS_Q  *p_q_next;
    OS_Q  *p_q_prev;


    p_q_prev = p_q->DbgPrevPtr;
 8005cb4:	6942      	ldr	r2, [r0, #20]
    p_q_next = p_q->DbgNextPtr;
 8005cb6:	6983      	ldr	r3, [r0, #24]

    if (p_q_prev == (OS_Q *)0) {
 8005cb8:	b132      	cbz	r2, 8005cc8 <OS_QDbgListRemove+0x14>
        if (p_q_next != (OS_Q *)0) {
            p_q_next->DbgPrevPtr = (OS_Q *)0;
        }
        p_q->DbgNextPtr = (OS_Q *)0;

    } else if (p_q_next == (OS_Q *)0) {
 8005cba:	b163      	cbz	r3, 8005cd6 <OS_QDbgListRemove+0x22>
        p_q->DbgPrevPtr      = (OS_Q *)0;

    } else {
        p_q_prev->DbgNextPtr =  p_q_next;
        p_q_next->DbgPrevPtr =  p_q_prev;
        p_q->DbgNextPtr      = (OS_Q *)0;
 8005cbc:	2100      	movs	r1, #0
    } else if (p_q_next == (OS_Q *)0) {
        p_q_prev->DbgNextPtr = (OS_Q *)0;
        p_q->DbgPrevPtr      = (OS_Q *)0;

    } else {
        p_q_prev->DbgNextPtr =  p_q_next;
 8005cbe:	6193      	str	r3, [r2, #24]
        p_q_next->DbgPrevPtr =  p_q_prev;
 8005cc0:	615a      	str	r2, [r3, #20]
        p_q->DbgNextPtr      = (OS_Q *)0;
 8005cc2:	6181      	str	r1, [r0, #24]
        p_q->DbgPrevPtr      = (OS_Q *)0;
 8005cc4:	6141      	str	r1, [r0, #20]
 8005cc6:	4770      	bx	lr

    p_q_prev = p_q->DbgPrevPtr;
    p_q_next = p_q->DbgNextPtr;

    if (p_q_prev == (OS_Q *)0) {
        OSQDbgListPtr = p_q_next;
 8005cc8:	4904      	ldr	r1, [pc, #16]	; (8005cdc <OS_QDbgListRemove+0x28>)
 8005cca:	600b      	str	r3, [r1, #0]
        if (p_q_next != (OS_Q *)0) {
 8005ccc:	b103      	cbz	r3, 8005cd0 <OS_QDbgListRemove+0x1c>
            p_q_next->DbgPrevPtr = (OS_Q *)0;
 8005cce:	615a      	str	r2, [r3, #20]
        }
        p_q->DbgNextPtr = (OS_Q *)0;
 8005cd0:	2300      	movs	r3, #0
 8005cd2:	6183      	str	r3, [r0, #24]
 8005cd4:	4770      	bx	lr

    } else if (p_q_next == (OS_Q *)0) {
        p_q_prev->DbgNextPtr = (OS_Q *)0;
 8005cd6:	6193      	str	r3, [r2, #24]
        p_q->DbgPrevPtr      = (OS_Q *)0;
 8005cd8:	6143      	str	r3, [r0, #20]
 8005cda:	4770      	bx	lr
 8005cdc:	2000ef1c 	.word	0x2000ef1c

08005ce0 <OS_QInit>:
        return;
    }
#endif

#if OS_CFG_DBG_EN > 0u
    OSQDbgListPtr = (OS_Q *)0;
 8005ce0:	4903      	ldr	r1, [pc, #12]	; (8005cf0 <OS_QInit+0x10>)
#endif

    OSQQty        = (OS_OBJ_QTY)0;
 8005ce2:	4a04      	ldr	r2, [pc, #16]	; (8005cf4 <OS_QInit+0x14>)
        return;
    }
#endif

#if OS_CFG_DBG_EN > 0u
    OSQDbgListPtr = (OS_Q *)0;
 8005ce4:	2300      	movs	r3, #0
 8005ce6:	600b      	str	r3, [r1, #0]
#endif

    OSQQty        = (OS_OBJ_QTY)0;
 8005ce8:	8013      	strh	r3, [r2, #0]
   *p_err         = OS_ERR_NONE;
 8005cea:	8003      	strh	r3, [r0, #0]
 8005cec:	4770      	bx	lr
 8005cee:	bf00      	nop
 8005cf0:	2000ef1c 	.word	0x2000ef1c
 8005cf4:	2000ed5c 	.word	0x2000ed5c

08005cf8 <OS_QPost>:
                void         *p_void,
                OS_MSG_SIZE   msg_size,
                OS_OPT        opt,
                CPU_TS        ts,
                OS_ERR       *p_err)
{
 8005cf8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005cfc:	b085      	sub	sp, #20
 8005cfe:	4606      	mov	r6, r0
 8005d00:	469a      	mov	sl, r3
 8005d02:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8005d04:	460f      	mov	r7, r1
 8005d06:	4690      	mov	r8, r2
 8005d08:	f8dd 9038 	ldr.w	r9, [sp, #56]	; 0x38
 8005d0c:	461d      	mov	r5, r3
 8005d0e:	9303      	str	r3, [sp, #12]
    OS_TCB        *p_tcb;
    CPU_SR_ALLOC();



    OS_CRITICAL_ENTER();
 8005d10:	f7fb fd30 	bl	8001774 <CPU_SR_Save>
    p_pend_list = &p_q->PendList;
    if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0) {         /* Any task waiting on message queue?                     */
 8005d14:	8a34      	ldrh	r4, [r6, #16]
    OS_TCB        *p_tcb;
    CPU_SR_ALLOC();



    OS_CRITICAL_ENTER();
 8005d16:	4683      	mov	fp, r0
    p_pend_list = &p_q->PendList;
    if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0) {         /* Any task waiting on message queue?                     */
 8005d18:	b984      	cbnz	r4, 8005d3c <OS_QPost+0x44>
        if ((opt & OS_OPT_POST_LIFO) == (OS_OPT)0) {        /* Determine whether we post FIFO or LIFO                 */
            post_type = OS_OPT_POST_FIFO;
        } else {
            post_type = OS_OPT_POST_LIFO;
        }
        OS_MsgQPut(&p_q->MsgQ,                              /* Place message in the message queue                     */
 8005d1a:	f106 0020 	add.w	r0, r6, #32
 8005d1e:	9501      	str	r5, [sp, #4]
 8005d20:	f8cd 9000 	str.w	r9, [sp]
 8005d24:	f00a 0310 	and.w	r3, sl, #16
 8005d28:	4642      	mov	r2, r8
 8005d2a:	4639      	mov	r1, r7
 8005d2c:	f7ff faac 	bl	8005288 <OS_MsgQPut>
                   p_void,
                   msg_size,
                   post_type,
                   ts,
                   p_err);
        OS_CRITICAL_EXIT();
 8005d30:	4658      	mov	r0, fp
    OS_CRITICAL_EXIT_NO_SCHED();
    if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
        OSSched();                                          /* Run the scheduler                                      */
    }
   *p_err = OS_ERR_NONE;
}
 8005d32:	b005      	add	sp, #20
 8005d34:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
                   p_void,
                   msg_size,
                   post_type,
                   ts,
                   p_err);
        OS_CRITICAL_EXIT();
 8005d38:	f7fb bd20 	b.w	800177c <CPU_SR_Restore>
    }

    if ((opt & OS_OPT_POST_ALL) != (OS_OPT)0) {             /* Post message to all tasks waiting?                     */
        cnt = p_pend_list->NbrEntries;                      /* Yes                                                    */
    } else {
        cnt = (OS_OBJ_QTY)1;                                /* No                                                     */
 8005d3c:	f41a 7f00 	tst.w	sl, #512	; 0x200
    }
    p_pend_data = p_pend_list->HeadPtr;
 8005d40:	68b5      	ldr	r5, [r6, #8]
    }

    if ((opt & OS_OPT_POST_ALL) != (OS_OPT)0) {             /* Post message to all tasks waiting?                     */
        cnt = p_pend_list->NbrEntries;                      /* Yes                                                    */
    } else {
        cnt = (OS_OBJ_QTY)1;                                /* No                                                     */
 8005d42:	bf08      	it	eq
 8005d44:	2401      	moveq	r4, #1
                p_tcb,
                p_void,
                msg_size,
                ts);
        p_pend_data = p_pend_data_next;
        cnt--;
 8005d46:	3c01      	subs	r4, #1
    } else {
        cnt = (OS_OBJ_QTY)1;                                /* No                                                     */
    }
    p_pend_data = p_pend_list->HeadPtr;
    while (cnt > 0u) {
        p_tcb            = p_pend_data->TCBPtr;
 8005d48:	68a9      	ldr	r1, [r5, #8]
        p_pend_data_next = p_pend_data->NextPtr;
        OS_Post((OS_PEND_OBJ *)((void *)p_q),
 8005d4a:	4643      	mov	r3, r8
        cnt = (OS_OBJ_QTY)1;                                /* No                                                     */
    }
    p_pend_data = p_pend_list->HeadPtr;
    while (cnt > 0u) {
        p_tcb            = p_pend_data->TCBPtr;
        p_pend_data_next = p_pend_data->NextPtr;
 8005d4c:	686d      	ldr	r5, [r5, #4]
        OS_Post((OS_PEND_OBJ *)((void *)p_q),
 8005d4e:	463a      	mov	r2, r7
 8005d50:	f8cd 9000 	str.w	r9, [sp]
 8005d54:	4630      	mov	r0, r6
                p_tcb,
                p_void,
                msg_size,
                ts);
        p_pend_data = p_pend_data_next;
        cnt--;
 8005d56:	b2a4      	uxth	r4, r4
    }
    p_pend_data = p_pend_list->HeadPtr;
    while (cnt > 0u) {
        p_tcb            = p_pend_data->TCBPtr;
        p_pend_data_next = p_pend_data->NextPtr;
        OS_Post((OS_PEND_OBJ *)((void *)p_q),
 8005d58:	f7fe fcc2 	bl	80046e0 <OS_Post>
        cnt = p_pend_list->NbrEntries;                      /* Yes                                                    */
    } else {
        cnt = (OS_OBJ_QTY)1;                                /* No                                                     */
    }
    p_pend_data = p_pend_list->HeadPtr;
    while (cnt > 0u) {
 8005d5c:	2c00      	cmp	r4, #0
 8005d5e:	d1f2      	bne.n	8005d46 <OS_QPost+0x4e>
                msg_size,
                ts);
        p_pend_data = p_pend_data_next;
        cnt--;
    }
    OS_CRITICAL_EXIT_NO_SCHED();
 8005d60:	4658      	mov	r0, fp
 8005d62:	f7fb fd0b 	bl	800177c <CPU_SR_Restore>
    if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
 8005d66:	f41a 4f00 	tst.w	sl, #32768	; 0x8000
 8005d6a:	d101      	bne.n	8005d70 <OS_QPost+0x78>
        OSSched();                                          /* Run the scheduler                                      */
 8005d6c:	f7fd fedc 	bl	8003b28 <OSSched>
    }
   *p_err = OS_ERR_NONE;
 8005d70:	9a03      	ldr	r2, [sp, #12]
 8005d72:	2300      	movs	r3, #0
 8005d74:	8013      	strh	r3, [r2, #0]
}
 8005d76:	b005      	add	sp, #20
 8005d78:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08005d7c <OSQPost>:
void  OSQPost (OS_Q         *p_q,
               void         *p_void,
               OS_MSG_SIZE   msg_size,
               OS_OPT        opt,
               OS_ERR       *p_err)
{
 8005d7c:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005d7e:	b083      	sub	sp, #12
        return;
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_q == (OS_Q *)0) {                                 /* Validate 'p_q'                                         */
 8005d80:	2800      	cmp	r0, #0
 8005d82:	d03f      	beq.n	8005e04 <OSQPost+0x88>
       *p_err = OS_ERR_OBJ_PTR_NULL;
        return;
    }
    switch (opt) {                                          /* Validate 'opt'                                         */
 8005d84:	f5b3 7f04 	cmp.w	r3, #528	; 0x210
 8005d88:	d015      	beq.n	8005db6 <OSQPost+0x3a>
 8005d8a:	d91e      	bls.n	8005dca <OSQPost+0x4e>
 8005d8c:	f248 0410 	movw	r4, #32784	; 0x8010
 8005d90:	42a3      	cmp	r3, r4
 8005d92:	d010      	beq.n	8005db6 <OSQPost+0x3a>
 8005d94:	d90c      	bls.n	8005db0 <OSQPost+0x34>
 8005d96:	f5b3 4f02 	cmp.w	r3, #33280	; 0x8200
 8005d9a:	d00c      	beq.n	8005db6 <OSQPost+0x3a>
 8005d9c:	f248 2410 	movw	r4, #33296	; 0x8210
 8005da0:	42a3      	cmp	r3, r4
 8005da2:	d008      	beq.n	8005db6 <OSQPost+0x3a>
        case OS_OPT_POST_FIFO | OS_OPT_POST_ALL | OS_OPT_POST_NO_SCHED:
        case OS_OPT_POST_LIFO | OS_OPT_POST_ALL | OS_OPT_POST_NO_SCHED:
             break;

        default:
            *p_err =  OS_ERR_OPT_INVALID;
 8005da4:	f645 6325 	movw	r3, #24101	; 0x5e25
 8005da8:	9a08      	ldr	r2, [sp, #32]
 8005daa:	8013      	strh	r3, [r2, #0]
             p_void,
             msg_size,
             opt,
             ts,
             p_err);
}
 8005dac:	b003      	add	sp, #12
 8005dae:	bdf0      	pop	{r4, r5, r6, r7, pc}
#if OS_CFG_ARG_CHK_EN > 0u
    if (p_q == (OS_Q *)0) {                                 /* Validate 'p_q'                                         */
       *p_err = OS_ERR_OBJ_PTR_NULL;
        return;
    }
    switch (opt) {                                          /* Validate 'opt'                                         */
 8005db0:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8005db4:	d1f6      	bne.n	8005da4 <OSQPost+0x28>
             return;
    }
#endif

#if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    if (p_q->Type != OS_OBJ_TYPE_Q) {                       /* Make sure message queue was created                    */
 8005db6:	4c16      	ldr	r4, [pc, #88]	; (8005e10 <OSQPost+0x94>)
 8005db8:	6805      	ldr	r5, [r0, #0]
 8005dba:	42a5      	cmp	r5, r4
 8005dbc:	d011      	beq.n	8005de2 <OSQPost+0x66>
       *p_err = OS_ERR_OBJ_TYPE;
 8005dbe:	f645 53c4 	movw	r3, #24004	; 0x5dc4
 8005dc2:	9a08      	ldr	r2, [sp, #32]
 8005dc4:	8013      	strh	r3, [r2, #0]
             p_void,
             msg_size,
             opt,
             ts,
             p_err);
}
 8005dc6:	b003      	add	sp, #12
 8005dc8:	bdf0      	pop	{r4, r5, r6, r7, pc}
#if OS_CFG_ARG_CHK_EN > 0u
    if (p_q == (OS_Q *)0) {                                 /* Validate 'p_q'                                         */
       *p_err = OS_ERR_OBJ_PTR_NULL;
        return;
    }
    switch (opt) {                                          /* Validate 'opt'                                         */
 8005dca:	2b10      	cmp	r3, #16
 8005dcc:	d0f3      	beq.n	8005db6 <OSQPost+0x3a>
 8005dce:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8005dd2:	d0f0      	beq.n	8005db6 <OSQPost+0x3a>
 8005dd4:	2b00      	cmp	r3, #0
 8005dd6:	d0ee      	beq.n	8005db6 <OSQPost+0x3a>
        case OS_OPT_POST_FIFO | OS_OPT_POST_ALL | OS_OPT_POST_NO_SCHED:
        case OS_OPT_POST_LIFO | OS_OPT_POST_ALL | OS_OPT_POST_NO_SCHED:
             break;

        default:
            *p_err =  OS_ERR_OPT_INVALID;
 8005dd8:	f645 6325 	movw	r3, #24101	; 0x5e25
 8005ddc:	9a08      	ldr	r2, [sp, #32]
 8005dde:	8013      	strh	r3, [r2, #0]
 8005de0:	e7e4      	b.n	8005dac <OSQPost+0x30>
 8005de2:	461c      	mov	r4, r3
 8005de4:	4605      	mov	r5, r0
 8005de6:	4617      	mov	r7, r2
 8005de8:	460e      	mov	r6, r1
       *p_err = OS_ERR_OBJ_TYPE;
        return;
    }
#endif

    ts = OS_TS_GET();                                       /* Get timestamp                                          */
 8005dea:	f7fa fecf 	bl	8000b8c <CPU_TS_TmrRd>
                    (OS_ERR    *)p_err);
        return;
    }
#endif

    OS_QPost(p_q,
 8005dee:	9b08      	ldr	r3, [sp, #32]
 8005df0:	463a      	mov	r2, r7
 8005df2:	e88d 0009 	stmia.w	sp, {r0, r3}
 8005df6:	4631      	mov	r1, r6
 8005df8:	4623      	mov	r3, r4
 8005dfa:	4628      	mov	r0, r5
 8005dfc:	f7ff ff7c 	bl	8005cf8 <OS_QPost>
             p_void,
             msg_size,
             opt,
             ts,
             p_err);
}
 8005e00:	b003      	add	sp, #12
 8005e02:	bdf0      	pop	{r4, r5, r6, r7, pc}
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_q == (OS_Q *)0) {                                 /* Validate 'p_q'                                         */
       *p_err = OS_ERR_OBJ_PTR_NULL;
 8005e04:	f645 53c3 	movw	r3, #24003	; 0x5dc3
 8005e08:	9a08      	ldr	r2, [sp, #32]
 8005e0a:	8013      	strh	r3, [r2, #0]
             p_void,
             msg_size,
             opt,
             ts,
             p_err);
}
 8005e0c:	b003      	add	sp, #12
 8005e0e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005e10:	55455551 	.word	0x55455551

08005e14 <OSSemCreate>:

void  OSSemCreate (OS_SEM      *p_sem,
                   CPU_CHAR    *p_name,
                   OS_SEM_CTR   cnt,
                   OS_ERR      *p_err)
{
 8005e14:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
        return;
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to be called from an ISR                   */
 8005e18:	4c19      	ldr	r4, [pc, #100]	; (8005e80 <OSSemCreate+0x6c>)
 8005e1a:	7826      	ldrb	r6, [r4, #0]
 8005e1c:	bb2e      	cbnz	r6, 8005e6a <OSSemCreate+0x56>
        return;
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
 8005e1e:	b348      	cbz	r0, 8005e74 <OSSemCreate+0x60>
 8005e20:	4604      	mov	r4, r0
 8005e22:	4690      	mov	r8, r2
 8005e24:	460d      	mov	r5, r1
 8005e26:	461f      	mov	r7, r3
       *p_err = OS_ERR_OBJ_PTR_NULL;
        return;
    }
#endif

    OS_CRITICAL_ENTER();
 8005e28:	f7fb fca4 	bl	8001774 <CPU_SR_Save>
    p_sem->Type    = OS_OBJ_TYPE_SEM;                       /* Mark the data structure as a semaphore                 */
 8005e2c:	4b15      	ldr	r3, [pc, #84]	; (8005e84 <OSSemCreate+0x70>)
       *p_err = OS_ERR_OBJ_PTR_NULL;
        return;
    }
#endif

    OS_CRITICAL_ENTER();
 8005e2e:	4681      	mov	r9, r0
    p_sem->Type    = OS_OBJ_TYPE_SEM;                       /* Mark the data structure as a semaphore                 */
 8005e30:	e884 0028 	stmia.w	r4, {r3, r5}
    p_sem->Ctr     = cnt;                                   /* Set semaphore value                                    */
 8005e34:	f8c4 8020 	str.w	r8, [r4, #32]
    p_sem->TS      = (CPU_TS)0;
 8005e38:	6266      	str	r6, [r4, #36]	; 0x24
    p_sem->NamePtr = p_name;                                /* Save the name of the semaphore                         */
    OS_PendListInit(&p_sem->PendList);                      /* Initialize the waiting list                            */
 8005e3a:	f104 0008 	add.w	r0, r4, #8
 8005e3e:	f7fe f88d 	bl	8003f5c <OS_PendListInit>
#if OS_CFG_DBG_EN > 0u
void  OS_SemDbgListAdd (OS_SEM  *p_sem)
{
    p_sem->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
    p_sem->DbgPrevPtr               = (OS_SEM   *)0;
    if (OSSemDbgListPtr == (OS_SEM *)0) {
 8005e42:	4911      	ldr	r1, [pc, #68]	; (8005e88 <OSSemCreate+0x74>)


#if OS_CFG_DBG_EN > 0u
void  OS_SemDbgListAdd (OS_SEM  *p_sem)
{
    p_sem->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
 8005e44:	4a11      	ldr	r2, [pc, #68]	; (8005e8c <OSSemCreate+0x78>)
    p_sem->DbgPrevPtr               = (OS_SEM   *)0;
    if (OSSemDbgListPtr == (OS_SEM *)0) {
 8005e46:	680b      	ldr	r3, [r1, #0]

#if OS_CFG_DBG_EN > 0u
void  OS_SemDbgListAdd (OS_SEM  *p_sem)
{
    p_sem->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
    p_sem->DbgPrevPtr               = (OS_SEM   *)0;
 8005e48:	6166      	str	r6, [r4, #20]


#if OS_CFG_DBG_EN > 0u
void  OS_SemDbgListAdd (OS_SEM  *p_sem)
{
    p_sem->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
 8005e4a:	61e2      	str	r2, [r4, #28]
    p_sem->DbgPrevPtr               = (OS_SEM   *)0;
    if (OSSemDbgListPtr == (OS_SEM *)0) {
        p_sem->DbgNextPtr           = (OS_SEM   *)0;
 8005e4c:	61a3      	str	r3, [r4, #24]
#if OS_CFG_DBG_EN > 0u
void  OS_SemDbgListAdd (OS_SEM  *p_sem)
{
    p_sem->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
    p_sem->DbgPrevPtr               = (OS_SEM   *)0;
    if (OSSemDbgListPtr == (OS_SEM *)0) {
 8005e4e:	b103      	cbz	r3, 8005e52 <OSSemCreate+0x3e>
        p_sem->DbgNextPtr           = (OS_SEM   *)0;
    } else {
        p_sem->DbgNextPtr           =  OSSemDbgListPtr;
        OSSemDbgListPtr->DbgPrevPtr =  p_sem;
 8005e50:	615c      	str	r4, [r3, #20]
    OS_PendListInit(&p_sem->PendList);                      /* Initialize the waiting list                            */

#if OS_CFG_DBG_EN > 0u
    OS_SemDbgListAdd(p_sem);
#endif
    OSSemQty++;
 8005e52:	4a0f      	ldr	r2, [pc, #60]	; (8005e90 <OSSemCreate+0x7c>)

    OS_CRITICAL_EXIT_NO_SCHED();
 8005e54:	4648      	mov	r0, r9
    OS_PendListInit(&p_sem->PendList);                      /* Initialize the waiting list                            */

#if OS_CFG_DBG_EN > 0u
    OS_SemDbgListAdd(p_sem);
#endif
    OSSemQty++;
 8005e56:	8813      	ldrh	r3, [r2, #0]
        p_sem->DbgNextPtr           = (OS_SEM   *)0;
    } else {
        p_sem->DbgNextPtr           =  OSSemDbgListPtr;
        OSSemDbgListPtr->DbgPrevPtr =  p_sem;
    }
    OSSemDbgListPtr                 =  p_sem;
 8005e58:	600c      	str	r4, [r1, #0]
    OS_PendListInit(&p_sem->PendList);                      /* Initialize the waiting list                            */

#if OS_CFG_DBG_EN > 0u
    OS_SemDbgListAdd(p_sem);
#endif
    OSSemQty++;
 8005e5a:	3301      	adds	r3, #1
 8005e5c:	8013      	strh	r3, [r2, #0]

    OS_CRITICAL_EXIT_NO_SCHED();
 8005e5e:	f7fb fc8d 	bl	800177c <CPU_SR_Restore>
   *p_err = OS_ERR_NONE;
 8005e62:	2300      	movs	r3, #0
 8005e64:	803b      	strh	r3, [r7, #0]
 8005e66:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to be called from an ISR                   */
       *p_err = OS_ERR_CREATE_ISR;
 8005e6a:	f642 62e1 	movw	r2, #12001	; 0x2ee1
 8005e6e:	801a      	strh	r2, [r3, #0]
        return;
 8005e70:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
       *p_err = OS_ERR_OBJ_PTR_NULL;
 8005e74:	f645 52c3 	movw	r2, #24003	; 0x5dc3
 8005e78:	801a      	strh	r2, [r3, #0]
        return;
 8005e7a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8005e7e:	bf00      	nop
 8005e80:	2000ed84 	.word	0x2000ed84
 8005e84:	414d4553 	.word	0x414d4553
 8005e88:	2000ec80 	.word	0x2000ec80
 8005e8c:	080182f0 	.word	0x080182f0
 8005e90:	2000ef20 	.word	0x2000ef20

08005e94 <OSSemDel>:

#if OS_CFG_SEM_DEL_EN > 0u
OS_OBJ_QTY  OSSemDel (OS_SEM  *p_sem,
                      OS_OPT   opt,
                      OS_ERR  *p_err)
{
 8005e94:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
        return ((OS_OBJ_QTY)0);
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to delete a semaphore from an ISR          */
 8005e98:	4b4b      	ldr	r3, [pc, #300]	; (8005fc8 <OSSemDel+0x134>)
 8005e9a:	781b      	ldrb	r3, [r3, #0]
 8005e9c:	b99b      	cbnz	r3, 8005ec6 <OSSemDel+0x32>
        return ((OS_OBJ_QTY)0);
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
 8005e9e:	2800      	cmp	r0, #0
 8005ea0:	d042      	beq.n	8005f28 <OSSemDel+0x94>
       *p_err = OS_ERR_OBJ_PTR_NULL;
        return ((OS_OBJ_QTY)0);
    }
    switch (opt) {                                          /* Validate 'opt'                                         */
 8005ea2:	2901      	cmp	r1, #1
 8005ea4:	d809      	bhi.n	8005eba <OSSemDel+0x26>
             return ((OS_OBJ_QTY)0);
    }
#endif

#if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    if (p_sem->Type != OS_OBJ_TYPE_SEM) {                   /* Make sure semaphore was created                        */
 8005ea6:	4c49      	ldr	r4, [pc, #292]	; (8005fcc <OSSemDel+0x138>)
 8005ea8:	6805      	ldr	r5, [r0, #0]
 8005eaa:	42a5      	cmp	r5, r4
 8005eac:	d011      	beq.n	8005ed2 <OSSemDel+0x3e>
       *p_err = OS_ERR_OBJ_TYPE;
 8005eae:	f645 51c4 	movw	r1, #24004	; 0x5dc4
        return ((OS_OBJ_QTY)0);
 8005eb2:	4618      	mov	r0, r3
    }
#endif

#if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    if (p_sem->Type != OS_OBJ_TYPE_SEM) {                   /* Make sure semaphore was created                        */
       *p_err = OS_ERR_OBJ_TYPE;
 8005eb4:	8011      	strh	r1, [r2, #0]
        return ((OS_OBJ_QTY)0);
 8005eb6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        case OS_OPT_DEL_NO_PEND:
        case OS_OPT_DEL_ALWAYS:
             break;

        default:
            *p_err = OS_ERR_OPT_INVALID;
 8005eba:	f645 6125 	movw	r1, #24101	; 0x5e25
             return ((OS_OBJ_QTY)0);
 8005ebe:	4618      	mov	r0, r3
        case OS_OPT_DEL_NO_PEND:
        case OS_OPT_DEL_ALWAYS:
             break;

        default:
            *p_err = OS_ERR_OPT_INVALID;
 8005ec0:	8011      	strh	r1, [r2, #0]
             return ((OS_OBJ_QTY)0);
 8005ec2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to delete a semaphore from an ISR          */
       *p_err = OS_ERR_DEL_ISR;
 8005ec6:	f243 23c9 	movw	r3, #13001	; 0x32c9
        return ((OS_OBJ_QTY)0);
 8005eca:	2000      	movs	r0, #0
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to delete a semaphore from an ISR          */
       *p_err = OS_ERR_DEL_ISR;
 8005ecc:	8013      	strh	r3, [r2, #0]
        return ((OS_OBJ_QTY)0);
 8005ece:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8005ed2:	460f      	mov	r7, r1
 8005ed4:	4605      	mov	r5, r0
 8005ed6:	4616      	mov	r6, r2
       *p_err = OS_ERR_OBJ_TYPE;
        return ((OS_OBJ_QTY)0);
    }
#endif

    CPU_CRITICAL_ENTER();
 8005ed8:	f7fb fc4c 	bl	8001774 <CPU_SR_Save>
    p_pend_list = &p_sem->PendList;
    cnt         = p_pend_list->NbrEntries;
    nbr_tasks   = cnt;
    switch (opt) {
 8005edc:	2f01      	cmp	r7, #1
       *p_err = OS_ERR_OBJ_TYPE;
        return ((OS_OBJ_QTY)0);
    }
#endif

    CPU_CRITICAL_ENTER();
 8005ede:	4680      	mov	r8, r0
    p_pend_list = &p_sem->PendList;
    cnt         = p_pend_list->NbrEntries;
 8005ee0:	8a2c      	ldrh	r4, [r5, #16]
    nbr_tasks   = cnt;
    switch (opt) {
 8005ee2:	d026      	beq.n	8005f32 <OSSemDel+0x9e>
        case OS_OPT_DEL_NO_PEND:                            /* Delete semaphore only if no task waiting               */
             if (nbr_tasks == (OS_OBJ_QTY)0) {
 8005ee4:	2c00      	cmp	r4, #0
 8005ee6:	d154      	bne.n	8005f92 <OSSemDel+0xfe>
{
    OS_SEM  *p_sem_next;
    OS_SEM  *p_sem_prev;


    p_sem_prev = p_sem->DbgPrevPtr;
 8005ee8:	696a      	ldr	r2, [r5, #20]
    p_sem_next = p_sem->DbgNextPtr;
 8005eea:	69ab      	ldr	r3, [r5, #24]

    if (p_sem_prev == (OS_SEM *)0) {
 8005eec:	2a00      	cmp	r2, #0
 8005eee:	d062      	beq.n	8005fb6 <OSSemDel+0x122>
            p_sem_next->DbgPrevPtr = (OS_SEM *)0;
        }
        p_sem->DbgNextPtr = (OS_SEM *)0;

    } else if (p_sem_next == (OS_SEM *)0) {
        p_sem_prev->DbgNextPtr = (OS_SEM *)0;
 8005ef0:	6193      	str	r3, [r2, #24]
        if (p_sem_next != (OS_SEM *)0) {
            p_sem_next->DbgPrevPtr = (OS_SEM *)0;
        }
        p_sem->DbgNextPtr = (OS_SEM *)0;

    } else if (p_sem_next == (OS_SEM *)0) {
 8005ef2:	2b00      	cmp	r3, #0
 8005ef4:	d066      	beq.n	8005fc4 <OSSemDel+0x130>
        p_sem_prev->DbgNextPtr = (OS_SEM *)0;
        p_sem->DbgPrevPtr      = (OS_SEM *)0;

    } else {
        p_sem_prev->DbgNextPtr =  p_sem_next;
        p_sem_next->DbgPrevPtr =  p_sem_prev;
 8005ef6:	615a      	str	r2, [r3, #20]
        p_sem->DbgNextPtr      = (OS_SEM *)0;
 8005ef8:	61ac      	str	r4, [r5, #24]
        p_sem->DbgPrevPtr      = (OS_SEM *)0;
 8005efa:	616c      	str	r4, [r5, #20]
        case OS_OPT_DEL_NO_PEND:                            /* Delete semaphore only if no task waiting               */
             if (nbr_tasks == (OS_OBJ_QTY)0) {
#if OS_CFG_DBG_EN > 0u
                 OS_SemDbgListRemove(p_sem);
#endif
                 OSSemQty--;
 8005efc:	4a34      	ldr	r2, [pc, #208]	; (8005fd0 <OSSemDel+0x13c>)
************************************************************************************************************************
*/

void  OS_SemClr (OS_SEM  *p_sem)
{
    p_sem->Type    = OS_OBJ_TYPE_NONE;                      /* Mark the data structure as a NONE                      */
 8005efe:	4935      	ldr	r1, [pc, #212]	; (8005fd4 <OSSemDel+0x140>)
        case OS_OPT_DEL_NO_PEND:                            /* Delete semaphore only if no task waiting               */
             if (nbr_tasks == (OS_OBJ_QTY)0) {
#if OS_CFG_DBG_EN > 0u
                 OS_SemDbgListRemove(p_sem);
#endif
                 OSSemQty--;
 8005f00:	8813      	ldrh	r3, [r2, #0]
void  OS_SemClr (OS_SEM  *p_sem)
{
    p_sem->Type    = OS_OBJ_TYPE_NONE;                      /* Mark the data structure as a NONE                      */
    p_sem->Ctr     = (OS_SEM_CTR)0;                         /* Set semaphore value                                    */
    p_sem->TS      = (CPU_TS    )0;                         /* Clear the time stamp                                   */
    p_sem->NamePtr = (CPU_CHAR *)((void *)"?SEM");
 8005f02:	4835      	ldr	r0, [pc, #212]	; (8005fd8 <OSSemDel+0x144>)
*/

void  OS_SemClr (OS_SEM  *p_sem)
{
    p_sem->Type    = OS_OBJ_TYPE_NONE;                      /* Mark the data structure as a NONE                      */
    p_sem->Ctr     = (OS_SEM_CTR)0;                         /* Set semaphore value                                    */
 8005f04:	2400      	movs	r4, #0
        case OS_OPT_DEL_NO_PEND:                            /* Delete semaphore only if no task waiting               */
             if (nbr_tasks == (OS_OBJ_QTY)0) {
#if OS_CFG_DBG_EN > 0u
                 OS_SemDbgListRemove(p_sem);
#endif
                 OSSemQty--;
 8005f06:	3b01      	subs	r3, #1
 8005f08:	8013      	strh	r3, [r2, #0]
void  OS_SemClr (OS_SEM  *p_sem)
{
    p_sem->Type    = OS_OBJ_TYPE_NONE;                      /* Mark the data structure as a NONE                      */
    p_sem->Ctr     = (OS_SEM_CTR)0;                         /* Set semaphore value                                    */
    p_sem->TS      = (CPU_TS    )0;                         /* Clear the time stamp                                   */
    p_sem->NamePtr = (CPU_CHAR *)((void *)"?SEM");
 8005f0a:	6068      	str	r0, [r5, #4]
************************************************************************************************************************
*/

void  OS_SemClr (OS_SEM  *p_sem)
{
    p_sem->Type    = OS_OBJ_TYPE_NONE;                      /* Mark the data structure as a NONE                      */
 8005f0c:	6029      	str	r1, [r5, #0]
    p_sem->Ctr     = (OS_SEM_CTR)0;                         /* Set semaphore value                                    */
    p_sem->TS      = (CPU_TS    )0;                         /* Clear the time stamp                                   */
    p_sem->NamePtr = (CPU_CHAR *)((void *)"?SEM");
    OS_PendListInit(&p_sem->PendList);                      /* Initialize the waiting list                            */
 8005f0e:	f105 0008 	add.w	r0, r5, #8
*/

void  OS_SemClr (OS_SEM  *p_sem)
{
    p_sem->Type    = OS_OBJ_TYPE_NONE;                      /* Mark the data structure as a NONE                      */
    p_sem->Ctr     = (OS_SEM_CTR)0;                         /* Set semaphore value                                    */
 8005f12:	622c      	str	r4, [r5, #32]
    p_sem->TS      = (CPU_TS    )0;                         /* Clear the time stamp                                   */
 8005f14:	626c      	str	r4, [r5, #36]	; 0x24
    p_sem->NamePtr = (CPU_CHAR *)((void *)"?SEM");
    OS_PendListInit(&p_sem->PendList);                      /* Initialize the waiting list                            */
 8005f16:	f7fe f821 	bl	8003f5c <OS_PendListInit>
#if OS_CFG_DBG_EN > 0u
                 OS_SemDbgListRemove(p_sem);
#endif
                 OSSemQty--;
                 OS_SemClr(p_sem);
                 CPU_CRITICAL_EXIT();
 8005f1a:	4640      	mov	r0, r8
 8005f1c:	f7fb fc2e 	bl	800177c <CPU_SR_Restore>
                *p_err = OS_ERR_NONE;
 8005f20:	8034      	strh	r4, [r6, #0]
 8005f22:	4620      	mov	r0, r4
 8005f24:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
       *p_err = OS_ERR_OBJ_PTR_NULL;
 8005f28:	f645 53c3 	movw	r3, #24003	; 0x5dc3
 8005f2c:	8013      	strh	r3, [r2, #0]
        return ((OS_OBJ_QTY)0);
 8005f2e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
             }
             break;

        case OS_OPT_DEL_ALWAYS:                             /* Always delete the semaphore                            */
             OS_CRITICAL_ENTER_CPU_EXIT();
             ts = OS_TS_GET();                              /* Get local time stamp so all tasks get the same time    */
 8005f32:	f7fa fe2b 	bl	8000b8c <CPU_TS_TmrRd>
             while (cnt > 0u) {                             /* Remove all tasks on the pend list                      */
 8005f36:	4627      	mov	r7, r4
             }
             break;

        case OS_OPT_DEL_ALWAYS:                             /* Always delete the semaphore                            */
             OS_CRITICAL_ENTER_CPU_EXIT();
             ts = OS_TS_GET();                              /* Get local time stamp so all tasks get the same time    */
 8005f38:	4681      	mov	r9, r0
             while (cnt > 0u) {                             /* Remove all tasks on the pend list                      */
 8005f3a:	b14c      	cbz	r4, 8005f50 <OSSemDel+0xbc>
                 p_pend_data = p_pend_list->HeadPtr;
                 p_tcb       = p_pend_data->TCBPtr;
 8005f3c:	68ab      	ldr	r3, [r5, #8]
                 OS_PendObjDel((OS_PEND_OBJ *)((void *)p_sem),
                               p_tcb,
                               ts);
                 cnt--;
 8005f3e:	3f01      	subs	r7, #1
             OS_CRITICAL_ENTER_CPU_EXIT();
             ts = OS_TS_GET();                              /* Get local time stamp so all tasks get the same time    */
             while (cnt > 0u) {                             /* Remove all tasks on the pend list                      */
                 p_pend_data = p_pend_list->HeadPtr;
                 p_tcb       = p_pend_data->TCBPtr;
                 OS_PendObjDel((OS_PEND_OBJ *)((void *)p_sem),
 8005f40:	464a      	mov	r2, r9
 8005f42:	6899      	ldr	r1, [r3, #8]
 8005f44:	4628      	mov	r0, r5
                               p_tcb,
                               ts);
                 cnt--;
 8005f46:	b2bf      	uxth	r7, r7
             OS_CRITICAL_ENTER_CPU_EXIT();
             ts = OS_TS_GET();                              /* Get local time stamp so all tasks get the same time    */
             while (cnt > 0u) {                             /* Remove all tasks on the pend list                      */
                 p_pend_data = p_pend_list->HeadPtr;
                 p_tcb       = p_pend_data->TCBPtr;
                 OS_PendObjDel((OS_PEND_OBJ *)((void *)p_sem),
 8005f48:	f7fe fb64 	bl	8004614 <OS_PendObjDel>
             break;

        case OS_OPT_DEL_ALWAYS:                             /* Always delete the semaphore                            */
             OS_CRITICAL_ENTER_CPU_EXIT();
             ts = OS_TS_GET();                              /* Get local time stamp so all tasks get the same time    */
             while (cnt > 0u) {                             /* Remove all tasks on the pend list                      */
 8005f4c:	2f00      	cmp	r7, #0
 8005f4e:	d1f5      	bne.n	8005f3c <OSSemDel+0xa8>
{
    OS_SEM  *p_sem_next;
    OS_SEM  *p_sem_prev;


    p_sem_prev = p_sem->DbgPrevPtr;
 8005f50:	696a      	ldr	r2, [r5, #20]
    p_sem_next = p_sem->DbgNextPtr;
 8005f52:	69ab      	ldr	r3, [r5, #24]

    if (p_sem_prev == (OS_SEM *)0) {
 8005f54:	b32a      	cbz	r2, 8005fa2 <OSSemDel+0x10e>
        if (p_sem_next != (OS_SEM *)0) {
            p_sem_next->DbgPrevPtr = (OS_SEM *)0;
        }
        p_sem->DbgNextPtr = (OS_SEM *)0;

    } else if (p_sem_next == (OS_SEM *)0) {
 8005f56:	b35b      	cbz	r3, 8005fb0 <OSSemDel+0x11c>
        p_sem->DbgPrevPtr      = (OS_SEM *)0;

    } else {
        p_sem_prev->DbgNextPtr =  p_sem_next;
        p_sem_next->DbgPrevPtr =  p_sem_prev;
        p_sem->DbgNextPtr      = (OS_SEM *)0;
 8005f58:	2100      	movs	r1, #0
    } else if (p_sem_next == (OS_SEM *)0) {
        p_sem_prev->DbgNextPtr = (OS_SEM *)0;
        p_sem->DbgPrevPtr      = (OS_SEM *)0;

    } else {
        p_sem_prev->DbgNextPtr =  p_sem_next;
 8005f5a:	6193      	str	r3, [r2, #24]
        p_sem_next->DbgPrevPtr =  p_sem_prev;
 8005f5c:	615a      	str	r2, [r3, #20]
        p_sem->DbgNextPtr      = (OS_SEM *)0;
 8005f5e:	61a9      	str	r1, [r5, #24]
        p_sem->DbgPrevPtr      = (OS_SEM *)0;
 8005f60:	6169      	str	r1, [r5, #20]
                 cnt--;
             }
#if OS_CFG_DBG_EN > 0u
             OS_SemDbgListRemove(p_sem);
#endif
             OSSemQty--;
 8005f62:	4a1b      	ldr	r2, [pc, #108]	; (8005fd0 <OSSemDel+0x13c>)
void  OS_SemClr (OS_SEM  *p_sem)
{
    p_sem->Type    = OS_OBJ_TYPE_NONE;                      /* Mark the data structure as a NONE                      */
    p_sem->Ctr     = (OS_SEM_CTR)0;                         /* Set semaphore value                                    */
    p_sem->TS      = (CPU_TS    )0;                         /* Clear the time stamp                                   */
    p_sem->NamePtr = (CPU_CHAR *)((void *)"?SEM");
 8005f64:	491c      	ldr	r1, [pc, #112]	; (8005fd8 <OSSemDel+0x144>)
                 cnt--;
             }
#if OS_CFG_DBG_EN > 0u
             OS_SemDbgListRemove(p_sem);
#endif
             OSSemQty--;
 8005f66:	8813      	ldrh	r3, [r2, #0]
************************************************************************************************************************
*/

void  OS_SemClr (OS_SEM  *p_sem)
{
    p_sem->Type    = OS_OBJ_TYPE_NONE;                      /* Mark the data structure as a NONE                      */
 8005f68:	481a      	ldr	r0, [pc, #104]	; (8005fd4 <OSSemDel+0x140>)
                 cnt--;
             }
#if OS_CFG_DBG_EN > 0u
             OS_SemDbgListRemove(p_sem);
#endif
             OSSemQty--;
 8005f6a:	3b01      	subs	r3, #1
*/

void  OS_SemClr (OS_SEM  *p_sem)
{
    p_sem->Type    = OS_OBJ_TYPE_NONE;                      /* Mark the data structure as a NONE                      */
    p_sem->Ctr     = (OS_SEM_CTR)0;                         /* Set semaphore value                                    */
 8005f6c:	2700      	movs	r7, #0
                 cnt--;
             }
#if OS_CFG_DBG_EN > 0u
             OS_SemDbgListRemove(p_sem);
#endif
             OSSemQty--;
 8005f6e:	8013      	strh	r3, [r2, #0]
*/

void  OS_SemClr (OS_SEM  *p_sem)
{
    p_sem->Type    = OS_OBJ_TYPE_NONE;                      /* Mark the data structure as a NONE                      */
    p_sem->Ctr     = (OS_SEM_CTR)0;                         /* Set semaphore value                                    */
 8005f70:	622f      	str	r7, [r5, #32]
    p_sem->TS      = (CPU_TS    )0;                         /* Clear the time stamp                                   */
    p_sem->NamePtr = (CPU_CHAR *)((void *)"?SEM");
 8005f72:	e885 0003 	stmia.w	r5, {r0, r1}

void  OS_SemClr (OS_SEM  *p_sem)
{
    p_sem->Type    = OS_OBJ_TYPE_NONE;                      /* Mark the data structure as a NONE                      */
    p_sem->Ctr     = (OS_SEM_CTR)0;                         /* Set semaphore value                                    */
    p_sem->TS      = (CPU_TS    )0;                         /* Clear the time stamp                                   */
 8005f76:	626f      	str	r7, [r5, #36]	; 0x24
    p_sem->NamePtr = (CPU_CHAR *)((void *)"?SEM");
    OS_PendListInit(&p_sem->PendList);                      /* Initialize the waiting list                            */
 8005f78:	f105 0008 	add.w	r0, r5, #8
 8005f7c:	f7fd ffee 	bl	8003f5c <OS_PendListInit>
#if OS_CFG_DBG_EN > 0u
             OS_SemDbgListRemove(p_sem);
#endif
             OSSemQty--;
             OS_SemClr(p_sem);
             OS_CRITICAL_EXIT_NO_SCHED();
 8005f80:	4640      	mov	r0, r8
 8005f82:	f7fb fbfb 	bl	800177c <CPU_SR_Restore>
             OSSched();                                     /* Find highest priority task ready to run                */
 8005f86:	f7fd fdcf 	bl	8003b28 <OSSched>
    }
#endif

    CPU_CRITICAL_ENTER();
    p_pend_list = &p_sem->PendList;
    cnt         = p_pend_list->NbrEntries;
 8005f8a:	4620      	mov	r0, r4
#endif
             OSSemQty--;
             OS_SemClr(p_sem);
             OS_CRITICAL_EXIT_NO_SCHED();
             OSSched();                                     /* Find highest priority task ready to run                */
            *p_err = OS_ERR_NONE;
 8005f8c:	8037      	strh	r7, [r6, #0]
             CPU_CRITICAL_EXIT();
            *p_err = OS_ERR_OPT_INVALID;
             break;
    }
    return ((OS_OBJ_QTY)nbr_tasks);
}
 8005f8e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
                 OSSemQty--;
                 OS_SemClr(p_sem);
                 CPU_CRITICAL_EXIT();
                *p_err = OS_ERR_NONE;
             } else {
                 CPU_CRITICAL_EXIT();
 8005f92:	f7fb fbf3 	bl	800177c <CPU_SR_Restore>
                *p_err = OS_ERR_TASK_WAITING;
 8005f96:	f247 135f 	movw	r3, #29023	; 0x715f
 8005f9a:	4620      	mov	r0, r4
 8005f9c:	8033      	strh	r3, [r6, #0]
 8005f9e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

    p_sem_prev = p_sem->DbgPrevPtr;
    p_sem_next = p_sem->DbgNextPtr;

    if (p_sem_prev == (OS_SEM *)0) {
        OSSemDbgListPtr = p_sem_next;
 8005fa2:	490e      	ldr	r1, [pc, #56]	; (8005fdc <OSSemDel+0x148>)
 8005fa4:	600b      	str	r3, [r1, #0]
        if (p_sem_next != (OS_SEM *)0) {
 8005fa6:	b103      	cbz	r3, 8005faa <OSSemDel+0x116>
            p_sem_next->DbgPrevPtr = (OS_SEM *)0;
 8005fa8:	615a      	str	r2, [r3, #20]
        }
        p_sem->DbgNextPtr = (OS_SEM *)0;
 8005faa:	2300      	movs	r3, #0
 8005fac:	61ab      	str	r3, [r5, #24]
 8005fae:	e7d8      	b.n	8005f62 <OSSemDel+0xce>

    } else if (p_sem_next == (OS_SEM *)0) {
        p_sem_prev->DbgNextPtr = (OS_SEM *)0;
 8005fb0:	6193      	str	r3, [r2, #24]
        p_sem->DbgPrevPtr      = (OS_SEM *)0;
 8005fb2:	616b      	str	r3, [r5, #20]
 8005fb4:	e7d5      	b.n	8005f62 <OSSemDel+0xce>

    p_sem_prev = p_sem->DbgPrevPtr;
    p_sem_next = p_sem->DbgNextPtr;

    if (p_sem_prev == (OS_SEM *)0) {
        OSSemDbgListPtr = p_sem_next;
 8005fb6:	4909      	ldr	r1, [pc, #36]	; (8005fdc <OSSemDel+0x148>)
 8005fb8:	600b      	str	r3, [r1, #0]
        if (p_sem_next != (OS_SEM *)0) {
 8005fba:	b103      	cbz	r3, 8005fbe <OSSemDel+0x12a>
            p_sem_next->DbgPrevPtr = (OS_SEM *)0;
 8005fbc:	615a      	str	r2, [r3, #20]
        }
        p_sem->DbgNextPtr = (OS_SEM *)0;
 8005fbe:	2300      	movs	r3, #0
 8005fc0:	61ab      	str	r3, [r5, #24]
 8005fc2:	e79b      	b.n	8005efc <OSSemDel+0x68>

    } else if (p_sem_next == (OS_SEM *)0) {
        p_sem_prev->DbgNextPtr = (OS_SEM *)0;
        p_sem->DbgPrevPtr      = (OS_SEM *)0;
 8005fc4:	616b      	str	r3, [r5, #20]
 8005fc6:	e799      	b.n	8005efc <OSSemDel+0x68>
 8005fc8:	2000ed84 	.word	0x2000ed84
 8005fcc:	414d4553 	.word	0x414d4553
 8005fd0:	2000ef20 	.word	0x2000ef20
 8005fd4:	454e4f4e 	.word	0x454e4f4e
 8005fd8:	08016670 	.word	0x08016670
 8005fdc:	2000ec80 	.word	0x2000ec80

08005fe0 <OSSemPend>:
OS_SEM_CTR  OSSemPend (OS_SEM   *p_sem,
                       OS_TICK   timeout,
                       OS_OPT    opt,
                       CPU_TS   *p_ts,
                       OS_ERR   *p_err)
{
 8005fe0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
        return ((OS_SEM_CTR)0);
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
 8005fe4:	4c5a      	ldr	r4, [pc, #360]	; (8006150 <OSSemPend+0x170>)
OS_SEM_CTR  OSSemPend (OS_SEM   *p_sem,
                       OS_TICK   timeout,
                       OS_OPT    opt,
                       CPU_TS   *p_ts,
                       OS_ERR   *p_err)
{
 8005fe6:	b089      	sub	sp, #36	; 0x24
        return ((OS_SEM_CTR)0);
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
 8005fe8:	7824      	ldrb	r4, [r4, #0]
 8005fea:	b9d4      	cbnz	r4, 8006022 <OSSemPend+0x42>
        return ((OS_SEM_CTR)0);
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
 8005fec:	2800      	cmp	r0, #0
 8005fee:	d058      	beq.n	80060a2 <OSSemPend+0xc2>
       *p_err = OS_ERR_OBJ_PTR_NULL;
        return ((OS_SEM_CTR)0);
    }
    switch (opt) {                                          /* Validate 'opt'                                         */
 8005ff0:	b152      	cbz	r2, 8006008 <OSSemPend+0x28>
 8005ff2:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
 8005ff6:	d007      	beq.n	8006008 <OSSemPend+0x28>
        case OS_OPT_PEND_BLOCKING:
        case OS_OPT_PEND_NON_BLOCKING:
             break;

        default:
            *p_err = OS_ERR_OPT_INVALID;
 8005ff8:	f645 6325 	movw	r3, #24101	; 0x5e25
 8005ffc:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8005ffe:	8013      	strh	r3, [r2, #0]
             return ((OS_SEM_CTR)0);
    }
    ctr = p_sem->Ctr;
    CPU_CRITICAL_EXIT();
    return (ctr);
}
 8006000:	4620      	mov	r0, r4
 8006002:	b009      	add	sp, #36	; 0x24
 8006004:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
             return ((OS_SEM_CTR)0);
    }
#endif

#if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    if (p_sem->Type != OS_OBJ_TYPE_SEM) {                   /* Make sure semaphore was created                        */
 8006008:	4c52      	ldr	r4, [pc, #328]	; (8006154 <OSSemPend+0x174>)
 800600a:	6805      	ldr	r5, [r0, #0]
 800600c:	42a5      	cmp	r5, r4
 800600e:	d011      	beq.n	8006034 <OSSemPend+0x54>
       *p_err = OS_ERR_OBJ_TYPE;
        return ((OS_SEM_CTR)0);
 8006010:	2400      	movs	r4, #0
    }
#endif

#if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    if (p_sem->Type != OS_OBJ_TYPE_SEM) {                   /* Make sure semaphore was created                        */
       *p_err = OS_ERR_OBJ_TYPE;
 8006012:	f645 53c4 	movw	r3, #24004	; 0x5dc4
             return ((OS_SEM_CTR)0);
    }
    ctr = p_sem->Ctr;
    CPU_CRITICAL_EXIT();
    return (ctr);
}
 8006016:	4620      	mov	r0, r4
    }
#endif

#if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    if (p_sem->Type != OS_OBJ_TYPE_SEM) {                   /* Make sure semaphore was created                        */
       *p_err = OS_ERR_OBJ_TYPE;
 8006018:	9a10      	ldr	r2, [sp, #64]	; 0x40
 800601a:	8013      	strh	r3, [r2, #0]
             return ((OS_SEM_CTR)0);
    }
    ctr = p_sem->Ctr;
    CPU_CRITICAL_EXIT();
    return (ctr);
}
 800601c:	b009      	add	sp, #36	; 0x24
 800601e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
       *p_err = OS_ERR_PEND_ISR;
        return ((OS_SEM_CTR)0);
 8006022:	2400      	movs	r4, #0
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
       *p_err = OS_ERR_PEND_ISR;
 8006024:	f246 13ae 	movw	r3, #25006	; 0x61ae
             return ((OS_SEM_CTR)0);
    }
    ctr = p_sem->Ctr;
    CPU_CRITICAL_EXIT();
    return (ctr);
}
 8006028:	4620      	mov	r0, r4
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
       *p_err = OS_ERR_PEND_ISR;
 800602a:	9a10      	ldr	r2, [sp, #64]	; 0x40
 800602c:	8013      	strh	r3, [r2, #0]
             return ((OS_SEM_CTR)0);
    }
    ctr = p_sem->Ctr;
    CPU_CRITICAL_EXIT();
    return (ctr);
}
 800602e:	b009      	add	sp, #36	; 0x24
 8006030:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8006034:	4698      	mov	r8, r3
 8006036:	4614      	mov	r4, r2
 8006038:	460f      	mov	r7, r1
 800603a:	4606      	mov	r6, r0
       *p_err = OS_ERR_OBJ_TYPE;
        return ((OS_SEM_CTR)0);
    }
#endif

    if (p_ts != (CPU_TS *)0) {
 800603c:	2b00      	cmp	r3, #0
 800603e:	d06d      	beq.n	800611c <OSSemPend+0x13c>
       *p_ts  = (CPU_TS)0;                                  /* Initialize the returned timestamp                      */
 8006040:	2300      	movs	r3, #0
 8006042:	f8c8 3000 	str.w	r3, [r8]
    }
    CPU_CRITICAL_ENTER();
 8006046:	f7fb fb95 	bl	8001774 <CPU_SR_Save>
    if (p_sem->Ctr > (OS_SEM_CTR)0) {                       /* Resource available?                                    */
 800604a:	6a33      	ldr	r3, [r6, #32]
#endif

    if (p_ts != (CPU_TS *)0) {
       *p_ts  = (CPU_TS)0;                                  /* Initialize the returned timestamp                      */
    }
    CPU_CRITICAL_ENTER();
 800604c:	4681      	mov	r9, r0
    if (p_sem->Ctr > (OS_SEM_CTR)0) {                       /* Resource available?                                    */
 800604e:	b163      	cbz	r3, 800606a <OSSemPend+0x8a>
        p_sem->Ctr--;                                       /* Yes, caller may proceed                                */
        if (p_ts != (CPU_TS *)0) {
           *p_ts  = p_sem->TS;                              /*      get timestamp of last post                        */
 8006050:	6a72      	ldr	r2, [r6, #36]	; 0x24
    if (p_ts != (CPU_TS *)0) {
       *p_ts  = (CPU_TS)0;                                  /* Initialize the returned timestamp                      */
    }
    CPU_CRITICAL_ENTER();
    if (p_sem->Ctr > (OS_SEM_CTR)0) {                       /* Resource available?                                    */
        p_sem->Ctr--;                                       /* Yes, caller may proceed                                */
 8006052:	3b01      	subs	r3, #1
 8006054:	6233      	str	r3, [r6, #32]
        if (p_ts != (CPU_TS *)0) {
           *p_ts  = p_sem->TS;                              /*      get timestamp of last post                        */
 8006056:	f8c8 2000 	str.w	r2, [r8]
 800605a:	6a34      	ldr	r4, [r6, #32]
        }
        ctr   = p_sem->Ctr;
        CPU_CRITICAL_EXIT();
 800605c:	4648      	mov	r0, r9
 800605e:	f7fb fb8d 	bl	800177c <CPU_SR_Restore>
       *p_err = OS_ERR_NONE;
 8006062:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8006064:	2300      	movs	r3, #0
 8006066:	8013      	strh	r3, [r2, #0]
        return (ctr);
 8006068:	e7ca      	b.n	8006000 <OSSemPend+0x20>
    }

    if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {    /* Caller wants to block if not available?                */
 800606a:	0423      	lsls	r3, r4, #16
 800606c:	d467      	bmi.n	800613e <OSSemPend+0x15e>
        ctr   = p_sem->Ctr;                                 /* No                                                     */
        CPU_CRITICAL_EXIT();
       *p_err = OS_ERR_PEND_WOULD_BLOCK;
        return (ctr);
    } else {                                                /* Yes                                                    */
        if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /* Can't pend when the scheduler is locked                */
 800606e:	4b3a      	ldr	r3, [pc, #232]	; (8006158 <OSSemPend+0x178>)
 8006070:	781b      	ldrb	r3, [r3, #0]
 8006072:	b9e3      	cbnz	r3, 80060ae <OSSemPend+0xce>
            return ((OS_SEM_CTR)0);
        }
    }
                                                            /* Lock the scheduler/re-enable interrupts                */
    OS_CRITICAL_ENTER_CPU_EXIT();
    OS_Pend(&pend_data,                                     /* Block task pending on Semaphore                        */
 8006074:	463b      	mov	r3, r7
 8006076:	2206      	movs	r2, #6
 8006078:	4631      	mov	r1, r6
 800607a:	4668      	mov	r0, sp
 800607c:	f7fe fa04 	bl	8004488 <OS_Pend>
            (OS_PEND_OBJ *)((void *)p_sem),
            OS_TASK_PEND_ON_SEM,
            timeout);

    OS_CRITICAL_EXIT_NO_SCHED();
 8006080:	4648      	mov	r0, r9
 8006082:	f7fb fb7b 	bl	800177c <CPU_SR_Restore>

    OSSched();                                              /* Find the next highest priority task ready to run       */
 8006086:	f7fd fd4f 	bl	8003b28 <OSSched>

    CPU_CRITICAL_ENTER();
 800608a:	f7fb fb73 	bl	8001774 <CPU_SR_Save>
    switch (OSTCBCurPtr->PendStatus) {
 800608e:	4b33      	ldr	r3, [pc, #204]	; (800615c <OSSemPend+0x17c>)
 8006090:	681a      	ldr	r2, [r3, #0]
 8006092:	f892 3035 	ldrb.w	r3, [r2, #53]	; 0x35
 8006096:	2b03      	cmp	r3, #3
 8006098:	d849      	bhi.n	800612e <OSSemPend+0x14e>
 800609a:	e8df f003 	tbb	[pc, r3]
 800609e:	2a35      	.short	0x2a35
 80060a0:	111f      	.short	0x111f
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
       *p_err = OS_ERR_OBJ_PTR_NULL;
 80060a2:	f645 53c3 	movw	r3, #24003	; 0x5dc3
 80060a6:	9a10      	ldr	r2, [sp, #64]	; 0x40
        return ((OS_SEM_CTR)0);
 80060a8:	4604      	mov	r4, r0
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
       *p_err = OS_ERR_OBJ_PTR_NULL;
 80060aa:	8013      	strh	r3, [r2, #0]
        return ((OS_SEM_CTR)0);
 80060ac:	e7a8      	b.n	8006000 <OSSemPend+0x20>
        CPU_CRITICAL_EXIT();
       *p_err = OS_ERR_PEND_WOULD_BLOCK;
        return (ctr);
    } else {                                                /* Yes                                                    */
        if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /* Can't pend when the scheduler is locked                */
            CPU_CRITICAL_EXIT();
 80060ae:	4648      	mov	r0, r9
 80060b0:	f7fb fb64 	bl	800177c <CPU_SR_Restore>
           *p_err = OS_ERR_SCHED_LOCKED;
 80060b4:	f646 5363 	movw	r3, #28003	; 0x6d63
 80060b8:	9a10      	ldr	r2, [sp, #64]	; 0x40
            return ((OS_SEM_CTR)0);
 80060ba:	2400      	movs	r4, #0
       *p_err = OS_ERR_PEND_WOULD_BLOCK;
        return (ctr);
    } else {                                                /* Yes                                                    */
        if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /* Can't pend when the scheduler is locked                */
            CPU_CRITICAL_EXIT();
           *p_err = OS_ERR_SCHED_LOCKED;
 80060bc:	8013      	strh	r3, [r2, #0]
            return ((OS_SEM_CTR)0);
 80060be:	e79f      	b.n	8006000 <OSSemPend+0x20>
             }
            *p_err = OS_ERR_PEND_ABORT;
             break;

        case OS_STATUS_PEND_TIMEOUT:                        /* Indicate that we didn't get semaphore within timeout   */
             if (p_ts != (CPU_TS *)0) {
 80060c0:	f1b8 0f00 	cmp.w	r8, #0
 80060c4:	d002      	beq.n	80060cc <OSSemPend+0xec>
                *p_ts  = (CPU_TS  )0;
 80060c6:	2300      	movs	r3, #0
 80060c8:	f8c8 3000 	str.w	r3, [r8]
             }
            *p_err = OS_ERR_TIMEOUT;
 80060cc:	f247 23d9 	movw	r3, #29401	; 0x72d9
 80060d0:	9a10      	ldr	r2, [sp, #64]	; 0x40
 80060d2:	8013      	strh	r3, [r2, #0]
        default:
            *p_err = OS_ERR_STATUS_INVALID;
             CPU_CRITICAL_EXIT();
             return ((OS_SEM_CTR)0);
    }
    ctr = p_sem->Ctr;
 80060d4:	6a34      	ldr	r4, [r6, #32]
    CPU_CRITICAL_EXIT();
 80060d6:	f7fb fb51 	bl	800177c <CPU_SR_Restore>
    return (ctr);
 80060da:	e791      	b.n	8006000 <OSSemPend+0x20>
             }
            *p_err = OS_ERR_TIMEOUT;
             break;

        case OS_STATUS_PEND_DEL:                            /* Indicate that object pended on has been deleted        */
             if (p_ts != (CPU_TS *)0) {
 80060dc:	f1b8 0f00 	cmp.w	r8, #0
 80060e0:	d002      	beq.n	80060e8 <OSSemPend+0x108>
                *p_ts  =  OSTCBCurPtr->TS;
 80060e2:	6c13      	ldr	r3, [r2, #64]	; 0x40
 80060e4:	f8c8 3000 	str.w	r3, [r8]
             }
            *p_err = OS_ERR_OBJ_DEL;
 80060e8:	f645 53c2 	movw	r3, #24002	; 0x5dc2
 80060ec:	9a10      	ldr	r2, [sp, #64]	; 0x40
 80060ee:	8013      	strh	r3, [r2, #0]
             break;
 80060f0:	e7f0      	b.n	80060d4 <OSSemPend+0xf4>
             }
            *p_err = OS_ERR_NONE;
             break;

        case OS_STATUS_PEND_ABORT:                          /* Indicate that we aborted                               */
             if (p_ts != (CPU_TS *)0) {
 80060f2:	f1b8 0f00 	cmp.w	r8, #0
 80060f6:	d002      	beq.n	80060fe <OSSemPend+0x11e>
                *p_ts  =  OSTCBCurPtr->TS;
 80060f8:	6c13      	ldr	r3, [r2, #64]	; 0x40
 80060fa:	f8c8 3000 	str.w	r3, [r8]
             }
            *p_err = OS_ERR_PEND_ABORT;
 80060fe:	f246 13a9 	movw	r3, #25001	; 0x61a9
 8006102:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8006104:	8013      	strh	r3, [r2, #0]
             break;
 8006106:	e7e5      	b.n	80060d4 <OSSemPend+0xf4>
    OSSched();                                              /* Find the next highest priority task ready to run       */

    CPU_CRITICAL_ENTER();
    switch (OSTCBCurPtr->PendStatus) {
        case OS_STATUS_PEND_OK:                             /* We got the semaphore                                   */
             if (p_ts != (CPU_TS *)0) {
 8006108:	f1b8 0f00 	cmp.w	r8, #0
 800610c:	d002      	beq.n	8006114 <OSSemPend+0x134>
                *p_ts  =  OSTCBCurPtr->TS;
 800610e:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8006110:	f8c8 3000 	str.w	r3, [r8]
             }
            *p_err = OS_ERR_NONE;
 8006114:	9a10      	ldr	r2, [sp, #64]	; 0x40
 8006116:	2300      	movs	r3, #0
 8006118:	8013      	strh	r3, [r2, #0]
             break;
 800611a:	e7db      	b.n	80060d4 <OSSemPend+0xf4>
#endif

    if (p_ts != (CPU_TS *)0) {
       *p_ts  = (CPU_TS)0;                                  /* Initialize the returned timestamp                      */
    }
    CPU_CRITICAL_ENTER();
 800611c:	f7fb fb2a 	bl	8001774 <CPU_SR_Save>
    if (p_sem->Ctr > (OS_SEM_CTR)0) {                       /* Resource available?                                    */
 8006120:	6a35      	ldr	r5, [r6, #32]
#endif

    if (p_ts != (CPU_TS *)0) {
       *p_ts  = (CPU_TS)0;                                  /* Initialize the returned timestamp                      */
    }
    CPU_CRITICAL_ENTER();
 8006122:	4681      	mov	r9, r0
    if (p_sem->Ctr > (OS_SEM_CTR)0) {                       /* Resource available?                                    */
 8006124:	2d00      	cmp	r5, #0
 8006126:	d0a0      	beq.n	800606a <OSSemPend+0x8a>
        p_sem->Ctr--;                                       /* Yes, caller may proceed                                */
 8006128:	1e6c      	subs	r4, r5, #1
 800612a:	6234      	str	r4, [r6, #32]
 800612c:	e796      	b.n	800605c <OSSemPend+0x7c>
             }
            *p_err = OS_ERR_OBJ_DEL;
             break;

        default:
            *p_err = OS_ERR_STATUS_INVALID;
 800612e:	f646 632e 	movw	r3, #28206	; 0x6e2e
 8006132:	9a10      	ldr	r2, [sp, #64]	; 0x40
             CPU_CRITICAL_EXIT();
             return ((OS_SEM_CTR)0);
 8006134:	2400      	movs	r4, #0
             }
            *p_err = OS_ERR_OBJ_DEL;
             break;

        default:
            *p_err = OS_ERR_STATUS_INVALID;
 8006136:	8013      	strh	r3, [r2, #0]
             CPU_CRITICAL_EXIT();
 8006138:	f7fb fb20 	bl	800177c <CPU_SR_Restore>
             return ((OS_SEM_CTR)0);
 800613c:	e760      	b.n	8006000 <OSSemPend+0x20>
        return (ctr);
    }

    if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {    /* Caller wants to block if not available?                */
        ctr   = p_sem->Ctr;                                 /* No                                                     */
        CPU_CRITICAL_EXIT();
 800613e:	4648      	mov	r0, r9
 8006140:	f7fb fb1c 	bl	800177c <CPU_SR_Restore>
       *p_err = OS_ERR_PEND_WOULD_BLOCK;
 8006144:	f246 13b0 	movw	r3, #25008	; 0x61b0
 8006148:	9a10      	ldr	r2, [sp, #64]	; 0x40
        return (ctr);
 800614a:	2400      	movs	r4, #0
    }

    if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {    /* Caller wants to block if not available?                */
        ctr   = p_sem->Ctr;                                 /* No                                                     */
        CPU_CRITICAL_EXIT();
       *p_err = OS_ERR_PEND_WOULD_BLOCK;
 800614c:	8013      	strh	r3, [r2, #0]
        return (ctr);
 800614e:	e757      	b.n	8006000 <OSSemPend+0x20>
 8006150:	2000ed84 	.word	0x2000ed84
 8006154:	414d4553 	.word	0x414d4553
 8006158:	2000e974 	.word	0x2000e974
 800615c:	2000ed58 	.word	0x2000ed58

08006160 <OSSemPendAbort>:

#if OS_CFG_SEM_PEND_ABORT_EN > 0u
OS_OBJ_QTY  OSSemPendAbort (OS_SEM  *p_sem,
                            OS_OPT   opt,
                            OS_ERR  *p_err)
{
 8006160:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
        return ((OS_OBJ_QTY)0u);
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0u) {             /* Not allowed to Pend Abort from an ISR                  */
 8006164:	4b2e      	ldr	r3, [pc, #184]	; (8006220 <OSSemPendAbort+0xc0>)
 8006166:	781b      	ldrb	r3, [r3, #0]
 8006168:	b9fb      	cbnz	r3, 80061aa <OSSemPendAbort+0x4a>
        return ((OS_OBJ_QTY)0u);
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
 800616a:	2800      	cmp	r0, #0
 800616c:	d04d      	beq.n	800620a <OSSemPendAbort+0xaa>
       *p_err =  OS_ERR_OBJ_PTR_NULL;
        return ((OS_OBJ_QTY)0u);
    }
    switch (opt) {                                          /* Validate 'opt'                                         */
 800616e:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 8006172:	d00f      	beq.n	8006194 <OSSemPendAbort+0x34>
 8006174:	d90c      	bls.n	8006190 <OSSemPendAbort+0x30>
 8006176:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 800617a:	d00b      	beq.n	8006194 <OSSemPendAbort+0x34>
 800617c:	f5b1 4f01 	cmp.w	r1, #33024	; 0x8100
 8006180:	d008      	beq.n	8006194 <OSSemPendAbort+0x34>
        case OS_OPT_PEND_ABORT_1   | OS_OPT_POST_NO_SCHED:
        case OS_OPT_PEND_ABORT_ALL | OS_OPT_POST_NO_SCHED:
             break;

        default:
            *p_err =  OS_ERR_OPT_INVALID;
 8006182:	f645 6325 	movw	r3, #24101	; 0x5e25
             return ((OS_OBJ_QTY)0u);
 8006186:	2400      	movs	r4, #0
        case OS_OPT_PEND_ABORT_1   | OS_OPT_POST_NO_SCHED:
        case OS_OPT_PEND_ABORT_ALL | OS_OPT_POST_NO_SCHED:
             break;

        default:
            *p_err =  OS_ERR_OPT_INVALID;
 8006188:	8013      	strh	r3, [r2, #0]
        OSSched();                                          /* Run the scheduler                                      */
    }

   *p_err = OS_ERR_NONE;
    return (nbr_tasks);
}
 800618a:	4620      	mov	r0, r4
 800618c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
#if OS_CFG_ARG_CHK_EN > 0u
    if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
       *p_err =  OS_ERR_OBJ_PTR_NULL;
        return ((OS_OBJ_QTY)0u);
    }
    switch (opt) {                                          /* Validate 'opt'                                         */
 8006190:	2900      	cmp	r1, #0
 8006192:	d1f6      	bne.n	8006182 <OSSemPendAbort+0x22>
             return ((OS_OBJ_QTY)0u);
    }
#endif

#if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    if (p_sem->Type != OS_OBJ_TYPE_SEM) {                   /* Make sure semaphore was created                        */
 8006194:	4b23      	ldr	r3, [pc, #140]	; (8006224 <OSSemPendAbort+0xc4>)
 8006196:	6804      	ldr	r4, [r0, #0]
 8006198:	429c      	cmp	r4, r3
 800619a:	d00d      	beq.n	80061b8 <OSSemPendAbort+0x58>
       *p_err =  OS_ERR_OBJ_TYPE;
 800619c:	f645 53c4 	movw	r3, #24004	; 0x5dc4
        return ((OS_OBJ_QTY)0u);
 80061a0:	2400      	movs	r4, #0
    }
#endif

#if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    if (p_sem->Type != OS_OBJ_TYPE_SEM) {                   /* Make sure semaphore was created                        */
       *p_err =  OS_ERR_OBJ_TYPE;
 80061a2:	8013      	strh	r3, [r2, #0]
        OSSched();                                          /* Run the scheduler                                      */
    }

   *p_err = OS_ERR_NONE;
    return (nbr_tasks);
}
 80061a4:	4620      	mov	r0, r4
 80061a6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0u) {             /* Not allowed to Pend Abort from an ISR                  */
       *p_err =  OS_ERR_PEND_ABORT_ISR;
 80061aa:	f246 13aa 	movw	r3, #25002	; 0x61aa
        return ((OS_OBJ_QTY)0u);
 80061ae:	2400      	movs	r4, #0
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0u) {             /* Not allowed to Pend Abort from an ISR                  */
       *p_err =  OS_ERR_PEND_ABORT_ISR;
 80061b0:	8013      	strh	r3, [r2, #0]
        OSSched();                                          /* Run the scheduler                                      */
    }

   *p_err = OS_ERR_NONE;
    return (nbr_tasks);
}
 80061b2:	4620      	mov	r0, r4
 80061b4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80061b8:	4680      	mov	r8, r0
 80061ba:	4617      	mov	r7, r2
 80061bc:	460e      	mov	r6, r1
       *p_err =  OS_ERR_OBJ_TYPE;
        return ((OS_OBJ_QTY)0u);
    }
#endif

    CPU_CRITICAL_ENTER();
 80061be:	f7fb fad9 	bl	8001774 <CPU_SR_Save>
    p_pend_list = &p_sem->PendList;
    if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0u) {        /* Any task waiting on semaphore?                         */
 80061c2:	f8b8 4010 	ldrh.w	r4, [r8, #16]
       *p_err =  OS_ERR_OBJ_TYPE;
        return ((OS_OBJ_QTY)0u);
    }
#endif

    CPU_CRITICAL_ENTER();
 80061c6:	4681      	mov	r9, r0
    p_pend_list = &p_sem->PendList;
    if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0u) {        /* Any task waiting on semaphore?                         */
 80061c8:	b324      	cbz	r4, 8006214 <OSSemPendAbort+0xb4>
        return ((OS_OBJ_QTY)0u);
    }

    OS_CRITICAL_ENTER_CPU_EXIT();
    nbr_tasks = 0u;
    ts        = OS_TS_GET();                                /* Get local time stamp so all tasks get the same time    */
 80061ca:	f7fa fcdf 	bl	8000b8c <CPU_TS_TmrRd>
       *p_err =  OS_ERR_PEND_ABORT_NONE;
        return ((OS_OBJ_QTY)0u);
    }

    OS_CRITICAL_ENTER_CPU_EXIT();
    nbr_tasks = 0u;
 80061ce:	2500      	movs	r5, #0
    ts        = OS_TS_GET();                                /* Get local time stamp so all tasks get the same time    */
 80061d0:	4604      	mov	r4, r0
    while (p_pend_list->NbrEntries > (OS_OBJ_QTY)0u) {
 80061d2:	e00b      	b.n	80061ec <OSSemPendAbort+0x8c>
        p_tcb = p_pend_list->HeadPtr->TCBPtr;
 80061d4:	f8d8 3008 	ldr.w	r3, [r8, #8]
        OS_PendAbort((OS_PEND_OBJ *)((void *)p_sem),
 80061d8:	4622      	mov	r2, r4
 80061da:	6899      	ldr	r1, [r3, #8]
 80061dc:	4640      	mov	r0, r8
 80061de:	f7fe f9af 	bl	8004540 <OS_PendAbort>
                     p_tcb,
                     ts);
        nbr_tasks++;
 80061e2:	3501      	adds	r5, #1
        if (opt != OS_OPT_PEND_ABORT_ALL) {                 /* Pend abort all tasks waiting?                          */
 80061e4:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
    while (p_pend_list->NbrEntries > (OS_OBJ_QTY)0u) {
        p_tcb = p_pend_list->HeadPtr->TCBPtr;
        OS_PendAbort((OS_PEND_OBJ *)((void *)p_sem),
                     p_tcb,
                     ts);
        nbr_tasks++;
 80061e8:	b2ad      	uxth	r5, r5
        if (opt != OS_OPT_PEND_ABORT_ALL) {                 /* Pend abort all tasks waiting?                          */
 80061ea:	d103      	bne.n	80061f4 <OSSemPendAbort+0x94>
    }

    OS_CRITICAL_ENTER_CPU_EXIT();
    nbr_tasks = 0u;
    ts        = OS_TS_GET();                                /* Get local time stamp so all tasks get the same time    */
    while (p_pend_list->NbrEntries > (OS_OBJ_QTY)0u) {
 80061ec:	f8b8 3010 	ldrh.w	r3, [r8, #16]
 80061f0:	2b00      	cmp	r3, #0
 80061f2:	d1ef      	bne.n	80061d4 <OSSemPendAbort+0x74>
        nbr_tasks++;
        if (opt != OS_OPT_PEND_ABORT_ALL) {                 /* Pend abort all tasks waiting?                          */
            break;                                          /* No                                                     */
        }
    }
    OS_CRITICAL_EXIT_NO_SCHED();
 80061f4:	4648      	mov	r0, r9
 80061f6:	f7fb fac1 	bl	800177c <CPU_SR_Restore>

    if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0u) {
 80061fa:	0433      	lsls	r3, r6, #16
 80061fc:	d401      	bmi.n	8006202 <OSSemPendAbort+0xa2>
        OSSched();                                          /* Run the scheduler                                      */
 80061fe:	f7fd fc93 	bl	8003b28 <OSSched>
    }

   *p_err = OS_ERR_NONE;
 8006202:	2300      	movs	r3, #0
    return (nbr_tasks);
 8006204:	462c      	mov	r4, r5

    if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0u) {
        OSSched();                                          /* Run the scheduler                                      */
    }

   *p_err = OS_ERR_NONE;
 8006206:	803b      	strh	r3, [r7, #0]
    return (nbr_tasks);
 8006208:	e7cc      	b.n	80061a4 <OSSemPendAbort+0x44>
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
       *p_err =  OS_ERR_OBJ_PTR_NULL;
 800620a:	f645 53c3 	movw	r3, #24003	; 0x5dc3
        return ((OS_OBJ_QTY)0u);
 800620e:	4604      	mov	r4, r0
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
       *p_err =  OS_ERR_OBJ_PTR_NULL;
 8006210:	8013      	strh	r3, [r2, #0]
        return ((OS_OBJ_QTY)0u);
 8006212:	e7c7      	b.n	80061a4 <OSSemPendAbort+0x44>
#endif

    CPU_CRITICAL_ENTER();
    p_pend_list = &p_sem->PendList;
    if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0u) {        /* Any task waiting on semaphore?                         */
        CPU_CRITICAL_EXIT();                                /* No                                                     */
 8006214:	f7fb fab2 	bl	800177c <CPU_SR_Restore>
       *p_err =  OS_ERR_PEND_ABORT_NONE;
 8006218:	f246 13ab 	movw	r3, #25003	; 0x61ab
 800621c:	803b      	strh	r3, [r7, #0]
        return ((OS_OBJ_QTY)0u);
 800621e:	e7c1      	b.n	80061a4 <OSSemPendAbort+0x44>
 8006220:	2000ed84 	.word	0x2000ed84
 8006224:	414d4553 	.word	0x414d4553

08006228 <OSSemSet>:
        return;
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't call this function from an ISR                   */
 8006228:	4b13      	ldr	r3, [pc, #76]	; (8006278 <OSSemSet+0x50>)
 800622a:	781b      	ldrb	r3, [r3, #0]
 800622c:	b94b      	cbnz	r3, 8006242 <OSSemSet+0x1a>
        return;
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
 800622e:	b1d8      	cbz	r0, 8006268 <OSSemSet+0x40>

#if OS_CFG_SEM_SET_EN > 0u
void  OSSemSet (OS_SEM      *p_sem,
                OS_SEM_CTR   cnt,
                OS_ERR      *p_err)
{
 8006230:	b570      	push	{r4, r5, r6, lr}
        return;
    }
#endif

#if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    if (p_sem->Type != OS_OBJ_TYPE_SEM) {                   /* Make sure semaphore was created                        */
 8006232:	4c12      	ldr	r4, [pc, #72]	; (800627c <OSSemSet+0x54>)
 8006234:	6805      	ldr	r5, [r0, #0]
 8006236:	42a5      	cmp	r5, r4
 8006238:	d007      	beq.n	800624a <OSSemSet+0x22>
       *p_err = OS_ERR_OBJ_TYPE;
 800623a:	f645 53c4 	movw	r3, #24004	; 0x5dc4
 800623e:	8013      	strh	r3, [r2, #0]
        return;
 8006240:	bd70      	pop	{r4, r5, r6, pc}
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't call this function from an ISR                   */
       *p_err = OS_ERR_SET_ISR;
 8006242:	f646 53c6 	movw	r3, #28102	; 0x6dc6
 8006246:	8013      	strh	r3, [r2, #0]
        return;
 8006248:	4770      	bx	lr
 800624a:	4604      	mov	r4, r0
       *p_err = OS_ERR_OBJ_TYPE;
        return;
    }
#endif

   *p_err = OS_ERR_NONE;
 800624c:	8013      	strh	r3, [r2, #0]
 800624e:	4615      	mov	r5, r2
 8006250:	460e      	mov	r6, r1
    CPU_CRITICAL_ENTER();
 8006252:	f7fb fa8f 	bl	8001774 <CPU_SR_Save>
    if (p_sem->Ctr > (OS_SEM_CTR)0) {                       /* See if semaphore already has a count                   */
 8006256:	6a23      	ldr	r3, [r4, #32]
 8006258:	b90b      	cbnz	r3, 800625e <OSSemSet+0x36>
        p_sem->Ctr = cnt;                                   /* Yes, set it to the new value specified.                */
    } else {
        p_pend_list = &p_sem->PendList;                     /* No                                                     */
        if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0) {     /*      See if task(s) waiting?                           */
 800625a:	8a23      	ldrh	r3, [r4, #16]
 800625c:	b943      	cbnz	r3, 8006270 <OSSemSet+0x48>
#endif

   *p_err = OS_ERR_NONE;
    CPU_CRITICAL_ENTER();
    if (p_sem->Ctr > (OS_SEM_CTR)0) {                       /* See if semaphore already has a count                   */
        p_sem->Ctr = cnt;                                   /* Yes, set it to the new value specified.                */
 800625e:	6226      	str	r6, [r4, #32]
        } else {
           *p_err      = OS_ERR_TASK_WAITING;
        }
    }
    CPU_CRITICAL_EXIT();
}
 8006260:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            p_sem->Ctr = cnt;                               /*      No, OK to set the value                           */
        } else {
           *p_err      = OS_ERR_TASK_WAITING;
        }
    }
    CPU_CRITICAL_EXIT();
 8006264:	f7fb ba8a 	b.w	800177c <CPU_SR_Restore>
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
       *p_err = OS_ERR_OBJ_PTR_NULL;
 8006268:	f645 53c3 	movw	r3, #24003	; 0x5dc3
 800626c:	8013      	strh	r3, [r2, #0]
 800626e:	4770      	bx	lr
    } else {
        p_pend_list = &p_sem->PendList;                     /* No                                                     */
        if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0) {     /*      See if task(s) waiting?                           */
            p_sem->Ctr = cnt;                               /*      No, OK to set the value                           */
        } else {
           *p_err      = OS_ERR_TASK_WAITING;
 8006270:	f247 135f 	movw	r3, #29023	; 0x715f
 8006274:	802b      	strh	r3, [r5, #0]
 8006276:	e7f3      	b.n	8006260 <OSSemSet+0x38>
 8006278:	2000ed84 	.word	0x2000ed84
 800627c:	414d4553 	.word	0x414d4553

08006280 <OS_SemClr>:
************************************************************************************************************************
*/

void  OS_SemClr (OS_SEM  *p_sem)
{
    p_sem->Type    = OS_OBJ_TYPE_NONE;                      /* Mark the data structure as a NONE                      */
 8006280:	4904      	ldr	r1, [pc, #16]	; (8006294 <OS_SemClr+0x14>)
    p_sem->Ctr     = (OS_SEM_CTR)0;                         /* Set semaphore value                                    */
    p_sem->TS      = (CPU_TS    )0;                         /* Clear the time stamp                                   */
    p_sem->NamePtr = (CPU_CHAR *)((void *)"?SEM");
 8006282:	4a05      	ldr	r2, [pc, #20]	; (8006298 <OS_SemClr+0x18>)
*/

void  OS_SemClr (OS_SEM  *p_sem)
{
    p_sem->Type    = OS_OBJ_TYPE_NONE;                      /* Mark the data structure as a NONE                      */
    p_sem->Ctr     = (OS_SEM_CTR)0;                         /* Set semaphore value                                    */
 8006284:	2300      	movs	r3, #0
    p_sem->TS      = (CPU_TS    )0;                         /* Clear the time stamp                                   */
    p_sem->NamePtr = (CPU_CHAR *)((void *)"?SEM");
 8006286:	e880 0006 	stmia.w	r0, {r1, r2}
*/

void  OS_SemClr (OS_SEM  *p_sem)
{
    p_sem->Type    = OS_OBJ_TYPE_NONE;                      /* Mark the data structure as a NONE                      */
    p_sem->Ctr     = (OS_SEM_CTR)0;                         /* Set semaphore value                                    */
 800628a:	6203      	str	r3, [r0, #32]
    p_sem->TS      = (CPU_TS    )0;                         /* Clear the time stamp                                   */
 800628c:	6243      	str	r3, [r0, #36]	; 0x24
    p_sem->NamePtr = (CPU_CHAR *)((void *)"?SEM");
    OS_PendListInit(&p_sem->PendList);                      /* Initialize the waiting list                            */
 800628e:	3008      	adds	r0, #8
 8006290:	f7fd be64 	b.w	8003f5c <OS_PendListInit>
 8006294:	454e4f4e 	.word	0x454e4f4e
 8006298:	08016670 	.word	0x08016670

0800629c <OS_SemDbgListAdd>:
#if OS_CFG_DBG_EN > 0u
void  OS_SemDbgListAdd (OS_SEM  *p_sem)
{
    p_sem->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
    p_sem->DbgPrevPtr               = (OS_SEM   *)0;
    if (OSSemDbgListPtr == (OS_SEM *)0) {
 800629c:	4a06      	ldr	r2, [pc, #24]	; (80062b8 <OS_SemDbgListAdd+0x1c>)
*/


#if OS_CFG_DBG_EN > 0u
void  OS_SemDbgListAdd (OS_SEM  *p_sem)
{
 800629e:	b410      	push	{r4}
    p_sem->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
    p_sem->DbgPrevPtr               = (OS_SEM   *)0;
    if (OSSemDbgListPtr == (OS_SEM *)0) {
 80062a0:	6813      	ldr	r3, [r2, #0]


#if OS_CFG_DBG_EN > 0u
void  OS_SemDbgListAdd (OS_SEM  *p_sem)
{
    p_sem->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
 80062a2:	4c06      	ldr	r4, [pc, #24]	; (80062bc <OS_SemDbgListAdd+0x20>)
    p_sem->DbgPrevPtr               = (OS_SEM   *)0;
 80062a4:	2100      	movs	r1, #0


#if OS_CFG_DBG_EN > 0u
void  OS_SemDbgListAdd (OS_SEM  *p_sem)
{
    p_sem->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
 80062a6:	61c4      	str	r4, [r0, #28]
    p_sem->DbgPrevPtr               = (OS_SEM   *)0;
 80062a8:	6141      	str	r1, [r0, #20]
    if (OSSemDbgListPtr == (OS_SEM *)0) {
        p_sem->DbgNextPtr           = (OS_SEM   *)0;
 80062aa:	6183      	str	r3, [r0, #24]
#if OS_CFG_DBG_EN > 0u
void  OS_SemDbgListAdd (OS_SEM  *p_sem)
{
    p_sem->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
    p_sem->DbgPrevPtr               = (OS_SEM   *)0;
    if (OSSemDbgListPtr == (OS_SEM *)0) {
 80062ac:	b103      	cbz	r3, 80062b0 <OS_SemDbgListAdd+0x14>
        p_sem->DbgNextPtr           = (OS_SEM   *)0;
    } else {
        p_sem->DbgNextPtr           =  OSSemDbgListPtr;
        OSSemDbgListPtr->DbgPrevPtr =  p_sem;
 80062ae:	6158      	str	r0, [r3, #20]
    }
    OSSemDbgListPtr                 =  p_sem;
 80062b0:	6010      	str	r0, [r2, #0]
}
 80062b2:	bc10      	pop	{r4}
 80062b4:	4770      	bx	lr
 80062b6:	bf00      	nop
 80062b8:	2000ec80 	.word	0x2000ec80
 80062bc:	080182f0 	.word	0x080182f0

080062c0 <OS_SemDbgListRemove>:
{
    OS_SEM  *p_sem_next;
    OS_SEM  *p_sem_prev;


    p_sem_prev = p_sem->DbgPrevPtr;
 80062c0:	6942      	ldr	r2, [r0, #20]
    p_sem_next = p_sem->DbgNextPtr;
 80062c2:	6983      	ldr	r3, [r0, #24]

    if (p_sem_prev == (OS_SEM *)0) {
 80062c4:	b132      	cbz	r2, 80062d4 <OS_SemDbgListRemove+0x14>
        if (p_sem_next != (OS_SEM *)0) {
            p_sem_next->DbgPrevPtr = (OS_SEM *)0;
        }
        p_sem->DbgNextPtr = (OS_SEM *)0;

    } else if (p_sem_next == (OS_SEM *)0) {
 80062c6:	b163      	cbz	r3, 80062e2 <OS_SemDbgListRemove+0x22>
        p_sem->DbgPrevPtr      = (OS_SEM *)0;

    } else {
        p_sem_prev->DbgNextPtr =  p_sem_next;
        p_sem_next->DbgPrevPtr =  p_sem_prev;
        p_sem->DbgNextPtr      = (OS_SEM *)0;
 80062c8:	2100      	movs	r1, #0
    } else if (p_sem_next == (OS_SEM *)0) {
        p_sem_prev->DbgNextPtr = (OS_SEM *)0;
        p_sem->DbgPrevPtr      = (OS_SEM *)0;

    } else {
        p_sem_prev->DbgNextPtr =  p_sem_next;
 80062ca:	6193      	str	r3, [r2, #24]
        p_sem_next->DbgPrevPtr =  p_sem_prev;
 80062cc:	615a      	str	r2, [r3, #20]
        p_sem->DbgNextPtr      = (OS_SEM *)0;
 80062ce:	6181      	str	r1, [r0, #24]
        p_sem->DbgPrevPtr      = (OS_SEM *)0;
 80062d0:	6141      	str	r1, [r0, #20]
 80062d2:	4770      	bx	lr

    p_sem_prev = p_sem->DbgPrevPtr;
    p_sem_next = p_sem->DbgNextPtr;

    if (p_sem_prev == (OS_SEM *)0) {
        OSSemDbgListPtr = p_sem_next;
 80062d4:	4904      	ldr	r1, [pc, #16]	; (80062e8 <OS_SemDbgListRemove+0x28>)
 80062d6:	600b      	str	r3, [r1, #0]
        if (p_sem_next != (OS_SEM *)0) {
 80062d8:	b103      	cbz	r3, 80062dc <OS_SemDbgListRemove+0x1c>
            p_sem_next->DbgPrevPtr = (OS_SEM *)0;
 80062da:	615a      	str	r2, [r3, #20]
        }
        p_sem->DbgNextPtr = (OS_SEM *)0;
 80062dc:	2300      	movs	r3, #0
 80062de:	6183      	str	r3, [r0, #24]
 80062e0:	4770      	bx	lr

    } else if (p_sem_next == (OS_SEM *)0) {
        p_sem_prev->DbgNextPtr = (OS_SEM *)0;
 80062e2:	6193      	str	r3, [r2, #24]
        p_sem->DbgPrevPtr      = (OS_SEM *)0;
 80062e4:	6143      	str	r3, [r0, #20]
 80062e6:	4770      	bx	lr
 80062e8:	2000ec80 	.word	0x2000ec80

080062ec <OS_SemInit>:
        return;
    }
#endif

#if OS_CFG_DBG_EN > 0u
    OSSemDbgListPtr = (OS_SEM *)0;
 80062ec:	4903      	ldr	r1, [pc, #12]	; (80062fc <OS_SemInit+0x10>)
#endif

    OSSemQty        = (OS_OBJ_QTY)0;
 80062ee:	4a04      	ldr	r2, [pc, #16]	; (8006300 <OS_SemInit+0x14>)
        return;
    }
#endif

#if OS_CFG_DBG_EN > 0u
    OSSemDbgListPtr = (OS_SEM *)0;
 80062f0:	2300      	movs	r3, #0
 80062f2:	600b      	str	r3, [r1, #0]
#endif

    OSSemQty        = (OS_OBJ_QTY)0;
 80062f4:	8013      	strh	r3, [r2, #0]
   *p_err           = OS_ERR_NONE;
 80062f6:	8003      	strh	r3, [r0, #0]
 80062f8:	4770      	bx	lr
 80062fa:	bf00      	nop
 80062fc:	2000ec80 	.word	0x2000ec80
 8006300:	2000ef20 	.word	0x2000ef20

08006304 <OS_SemPost>:

OS_SEM_CTR  OS_SemPost (OS_SEM  *p_sem,
                        OS_OPT   opt,
                        CPU_TS   ts,
                        OS_ERR  *p_err)
{
 8006304:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8006308:	4606      	mov	r6, r0
 800630a:	b082      	sub	sp, #8
 800630c:	4688      	mov	r8, r1
 800630e:	4617      	mov	r7, r2
 8006310:	4699      	mov	r9, r3
    OS_TCB        *p_tcb;
    CPU_SR_ALLOC();



    CPU_CRITICAL_ENTER();
 8006312:	f7fb fa2f 	bl	8001774 <CPU_SR_Save>
    p_pend_list = &p_sem->PendList;
    if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0) {         /* Any task waiting on semaphore?                         */
 8006316:	8a34      	ldrh	r4, [r6, #16]
 8006318:	b96c      	cbnz	r4, 8006336 <OS_SemPost+0x32>
                     return ((OS_SEM_CTR)0);
                 }
                 break;

            case 4u:
                 if (p_sem->Ctr == DEF_INT_32U_MAX_VAL) {
 800631a:	6a35      	ldr	r5, [r6, #32]
 800631c:	1c6b      	adds	r3, r5, #1
 800631e:	d02c      	beq.n	800637a <OS_SemPost+0x76>
                 break;

            default:
                 break;
        }
        p_sem->Ctr++;                                       /* No                                                     */
 8006320:	3501      	adds	r5, #1
 8006322:	6235      	str	r5, [r6, #32]
        ctr       = p_sem->Ctr;
        p_sem->TS = ts;                                     /* Save timestamp in semaphore control block              */
 8006324:	6277      	str	r7, [r6, #36]	; 0x24
        CPU_CRITICAL_EXIT();
 8006326:	f7fb fa29 	bl	800177c <CPU_SR_Restore>
    if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
        OSSched();                                          /* Run the scheduler                                      */
    }
   *p_err = OS_ERR_NONE;
    return (ctr);
}
 800632a:	4628      	mov	r0, r5
        }
        p_sem->Ctr++;                                       /* No                                                     */
        ctr       = p_sem->Ctr;
        p_sem->TS = ts;                                     /* Save timestamp in semaphore control block              */
        CPU_CRITICAL_EXIT();
       *p_err     = OS_ERR_NONE;
 800632c:	f8a9 4000 	strh.w	r4, [r9]
    if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
        OSSched();                                          /* Run the scheduler                                      */
    }
   *p_err = OS_ERR_NONE;
    return (ctr);
}
 8006330:	b002      	add	sp, #8
 8006332:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8006336:	4682      	mov	sl, r0

    OS_CRITICAL_ENTER_CPU_EXIT();
    if ((opt & OS_OPT_POST_ALL) != (OS_OPT)0) {             /* Post message to all tasks waiting?                     */
        cnt = p_pend_list->NbrEntries;                      /* Yes                                                    */
    } else {
        cnt = (OS_OBJ_QTY)1;                                /* No                                                     */
 8006338:	f418 7f00 	tst.w	r8, #512	; 0x200
    }
    p_pend_data = p_pend_list->HeadPtr;
 800633c:	68b5      	ldr	r5, [r6, #8]

    OS_CRITICAL_ENTER_CPU_EXIT();
    if ((opt & OS_OPT_POST_ALL) != (OS_OPT)0) {             /* Post message to all tasks waiting?                     */
        cnt = p_pend_list->NbrEntries;                      /* Yes                                                    */
    } else {
        cnt = (OS_OBJ_QTY)1;                                /* No                                                     */
 800633e:	bf08      	it	eq
 8006340:	2401      	moveq	r4, #1
    }
    p_pend_data = p_pend_list->HeadPtr;
    while (cnt > 0u) {
        p_tcb            = p_pend_data->TCBPtr;
        p_pend_data_next = p_pend_data->NextPtr;
        OS_Post((OS_PEND_OBJ *)((void *)p_sem),
 8006342:	2300      	movs	r3, #0
                p_tcb,
                (void      *)0,
                (OS_MSG_SIZE)0,
                ts);
        p_pend_data = p_pend_data_next;
        cnt--;
 8006344:	3c01      	subs	r4, #1
    } else {
        cnt = (OS_OBJ_QTY)1;                                /* No                                                     */
    }
    p_pend_data = p_pend_list->HeadPtr;
    while (cnt > 0u) {
        p_tcb            = p_pend_data->TCBPtr;
 8006346:	68a9      	ldr	r1, [r5, #8]
        p_pend_data_next = p_pend_data->NextPtr;
        OS_Post((OS_PEND_OBJ *)((void *)p_sem),
 8006348:	461a      	mov	r2, r3
        cnt = (OS_OBJ_QTY)1;                                /* No                                                     */
    }
    p_pend_data = p_pend_list->HeadPtr;
    while (cnt > 0u) {
        p_tcb            = p_pend_data->TCBPtr;
        p_pend_data_next = p_pend_data->NextPtr;
 800634a:	686d      	ldr	r5, [r5, #4]
        OS_Post((OS_PEND_OBJ *)((void *)p_sem),
 800634c:	4630      	mov	r0, r6
 800634e:	9700      	str	r7, [sp, #0]
                p_tcb,
                (void      *)0,
                (OS_MSG_SIZE)0,
                ts);
        p_pend_data = p_pend_data_next;
        cnt--;
 8006350:	b2a4      	uxth	r4, r4
    }
    p_pend_data = p_pend_list->HeadPtr;
    while (cnt > 0u) {
        p_tcb            = p_pend_data->TCBPtr;
        p_pend_data_next = p_pend_data->NextPtr;
        OS_Post((OS_PEND_OBJ *)((void *)p_sem),
 8006352:	f7fe f9c5 	bl	80046e0 <OS_Post>
        cnt = p_pend_list->NbrEntries;                      /* Yes                                                    */
    } else {
        cnt = (OS_OBJ_QTY)1;                                /* No                                                     */
    }
    p_pend_data = p_pend_list->HeadPtr;
    while (cnt > 0u) {
 8006356:	2c00      	cmp	r4, #0
 8006358:	d1f3      	bne.n	8006342 <OS_SemPost+0x3e>
                ts);
        p_pend_data = p_pend_data_next;
        cnt--;
    }
    ctr = p_sem->Ctr;
    OS_CRITICAL_EXIT_NO_SCHED();
 800635a:	4650      	mov	r0, sl
                (OS_MSG_SIZE)0,
                ts);
        p_pend_data = p_pend_data_next;
        cnt--;
    }
    ctr = p_sem->Ctr;
 800635c:	6a35      	ldr	r5, [r6, #32]
    OS_CRITICAL_EXIT_NO_SCHED();
 800635e:	f7fb fa0d 	bl	800177c <CPU_SR_Restore>
    if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
 8006362:	f418 4f00 	tst.w	r8, #32768	; 0x8000
 8006366:	d101      	bne.n	800636c <OS_SemPost+0x68>
        OSSched();                                          /* Run the scheduler                                      */
 8006368:	f7fd fbde 	bl	8003b28 <OSSched>
    }
   *p_err = OS_ERR_NONE;
    return (ctr);
}
 800636c:	4628      	mov	r0, r5
    ctr = p_sem->Ctr;
    OS_CRITICAL_EXIT_NO_SCHED();
    if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
        OSSched();                                          /* Run the scheduler                                      */
    }
   *p_err = OS_ERR_NONE;
 800636e:	2300      	movs	r3, #0
 8006370:	f8a9 3000 	strh.w	r3, [r9]
    return (ctr);
}
 8006374:	b002      	add	sp, #8
 8006376:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

            case 4u:
                 if (p_sem->Ctr == DEF_INT_32U_MAX_VAL) {
                     CPU_CRITICAL_EXIT();
                    *p_err = OS_ERR_SEM_OVF;
                     return ((OS_SEM_CTR)0);
 800637a:	4625      	mov	r5, r4
                 }
                 break;

            case 4u:
                 if (p_sem->Ctr == DEF_INT_32U_MAX_VAL) {
                     CPU_CRITICAL_EXIT();
 800637c:	f7fb f9fe 	bl	800177c <CPU_SR_Restore>
                    *p_err = OS_ERR_SEM_OVF;
 8006380:	f646 53c5 	movw	r3, #28101	; 0x6dc5
    if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
        OSSched();                                          /* Run the scheduler                                      */
    }
   *p_err = OS_ERR_NONE;
    return (ctr);
}
 8006384:	4628      	mov	r0, r5
                 break;

            case 4u:
                 if (p_sem->Ctr == DEF_INT_32U_MAX_VAL) {
                     CPU_CRITICAL_EXIT();
                    *p_err = OS_ERR_SEM_OVF;
 8006386:	f8a9 3000 	strh.w	r3, [r9]
    if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
        OSSched();                                          /* Run the scheduler                                      */
    }
   *p_err = OS_ERR_NONE;
    return (ctr);
}
 800638a:	b002      	add	sp, #8
 800638c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

08006390 <OSSemPost>:
*/

OS_SEM_CTR  OSSemPost (OS_SEM  *p_sem,
                       OS_OPT   opt,
                       OS_ERR  *p_err)
{
 8006390:	b570      	push	{r4, r5, r6, lr}
        return ((OS_SEM_CTR)0);
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
 8006392:	b330      	cbz	r0, 80063e2 <OSSemPost+0x52>
       *p_err  = OS_ERR_OBJ_PTR_NULL;
        return ((OS_SEM_CTR)0);
    }
    switch (opt) {                                          /* Validate 'opt'                                         */
 8006394:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8006398:	d00d      	beq.n	80063b6 <OSSemPost+0x26>
 800639a:	d90a      	bls.n	80063b2 <OSSemPost+0x22>
 800639c:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 80063a0:	d009      	beq.n	80063b6 <OSSemPost+0x26>
 80063a2:	f5b1 4f02 	cmp.w	r1, #33280	; 0x8200
 80063a6:	d006      	beq.n	80063b6 <OSSemPost+0x26>
        case OS_OPT_POST_1   | OS_OPT_POST_NO_SCHED:
        case OS_OPT_POST_ALL | OS_OPT_POST_NO_SCHED:
             break;

        default:
            *p_err =  OS_ERR_OPT_INVALID;
 80063a8:	f645 6325 	movw	r3, #24101	; 0x5e25
                     opt,
                     ts,
                     p_err);

    return (ctr);
}
 80063ac:	2000      	movs	r0, #0
        case OS_OPT_POST_1   | OS_OPT_POST_NO_SCHED:
        case OS_OPT_POST_ALL | OS_OPT_POST_NO_SCHED:
             break;

        default:
            *p_err =  OS_ERR_OPT_INVALID;
 80063ae:	8013      	strh	r3, [r2, #0]
                     opt,
                     ts,
                     p_err);

    return (ctr);
}
 80063b0:	bd70      	pop	{r4, r5, r6, pc}
#if OS_CFG_ARG_CHK_EN > 0u
    if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
       *p_err  = OS_ERR_OBJ_PTR_NULL;
        return ((OS_SEM_CTR)0);
    }
    switch (opt) {                                          /* Validate 'opt'                                         */
 80063b2:	2900      	cmp	r1, #0
 80063b4:	d1f8      	bne.n	80063a8 <OSSemPost+0x18>
             return ((OS_SEM_CTR)0u);
    }
#endif

#if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    if (p_sem->Type != OS_OBJ_TYPE_SEM) {                   /* Make sure semaphore was created                        */
 80063b6:	4b0d      	ldr	r3, [pc, #52]	; (80063ec <OSSemPost+0x5c>)
 80063b8:	6804      	ldr	r4, [r0, #0]
 80063ba:	429c      	cmp	r4, r3
 80063bc:	d004      	beq.n	80063c8 <OSSemPost+0x38>
       *p_err = OS_ERR_OBJ_TYPE;
 80063be:	f645 53c4 	movw	r3, #24004	; 0x5dc4
                     opt,
                     ts,
                     p_err);

    return (ctr);
}
 80063c2:	2000      	movs	r0, #0
    }
#endif

#if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    if (p_sem->Type != OS_OBJ_TYPE_SEM) {                   /* Make sure semaphore was created                        */
       *p_err = OS_ERR_OBJ_TYPE;
 80063c4:	8013      	strh	r3, [r2, #0]
                     opt,
                     ts,
                     p_err);

    return (ctr);
}
 80063c6:	bd70      	pop	{r4, r5, r6, pc}
 80063c8:	4616      	mov	r6, r2
 80063ca:	4605      	mov	r5, r0
 80063cc:	460c      	mov	r4, r1
       *p_err = OS_ERR_OBJ_TYPE;
        return ((OS_SEM_CTR)0);
    }
#endif

    ts = OS_TS_GET();                                       /* Get timestamp                                          */
 80063ce:	f7fa fbdd 	bl	8000b8c <CPU_TS_TmrRd>
                    (OS_ERR    *)p_err);
        return ((OS_SEM_CTR)0);
    }
#endif

    ctr = OS_SemPost(p_sem,                                 /* Post to semaphore                                      */
 80063d2:	4633      	mov	r3, r6
 80063d4:	4602      	mov	r2, r0
 80063d6:	4621      	mov	r1, r4
 80063d8:	4628      	mov	r0, r5
                     opt,
                     ts,
                     p_err);

    return (ctr);
}
 80063da:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
                    (OS_ERR    *)p_err);
        return ((OS_SEM_CTR)0);
    }
#endif

    ctr = OS_SemPost(p_sem,                                 /* Post to semaphore                                      */
 80063de:	f7ff bf91 	b.w	8006304 <OS_SemPost>
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
       *p_err  = OS_ERR_OBJ_PTR_NULL;
 80063e2:	f645 53c3 	movw	r3, #24003	; 0x5dc3
                     opt,
                     ts,
                     p_err);

    return (ctr);
}
 80063e6:	2000      	movs	r0, #0
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
       *p_err  = OS_ERR_OBJ_PTR_NULL;
 80063e8:	8013      	strh	r3, [r2, #0]
                     opt,
                     ts,
                     p_err);

    return (ctr);
}
 80063ea:	bd70      	pop	{r4, r5, r6, pc}
 80063ec:	414d4553 	.word	0x414d4553

080063f0 <OSStatReset>:
* Returns    : none
************************************************************************************************************************
*/

void  OSStatReset (OS_ERR  *p_err)
{
 80063f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80063f2:	4607      	mov	r7, r0
        OS_SAFETY_CRITICAL_EXCEPTION();
        return;
    }
#endif

    CPU_CRITICAL_ENTER();
 80063f4:	f7fb f9be 	bl	8001774 <CPU_SR_Save>
    OSIntQTaskTimeMax     = (CPU_TS    )0;                  /* Reset the task execution times                         */
    OSIntQNbrEntriesMax   = (OS_OBJ_QTY)0;                  /* Reset the queue maximum number of entries              */
#endif

#if OS_CFG_STAT_TASK_EN > 0u
    OSStatTaskCPUUsageMax = 0u;
 80063f8:	4b25      	ldr	r3, [pc, #148]	; (8006490 <OSStatReset+0xa0>)
 80063fa:	2500      	movs	r5, #0
#endif

    OSTickTaskTimeMax     = (CPU_TS)0;

#if OS_CFG_TMR_EN > 0u
    OSTmrTaskTimeMax      = (CPU_TS)0;
 80063fc:	4925      	ldr	r1, [pc, #148]	; (8006494 <OSStatReset+0xa4>)
#ifdef CPU_CFG_INT_DIS_MEAS_EN
    OSIntDisTimeMax       = (CPU_TS)0;                      /* Reset the maximum interrupt disable time               */
#endif

#if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
    OSSchedLockTimeMax    = (CPU_TS)0;                      /* Reset the maximum scheduler lock time                  */
 80063fe:	4a26      	ldr	r2, [pc, #152]	; (8006498 <OSStatReset+0xa8>)
#if OS_CFG_STAT_TASK_EN > 0u
    OSStatTaskCPUUsageMax = 0u;
    OSStatTaskTimeMax     = (CPU_TS)0;
#endif

    OSTickTaskTimeMax     = (CPU_TS)0;
 8006400:	4c26      	ldr	r4, [pc, #152]	; (800649c <OSStatReset+0xac>)
    OSIntQTaskTimeMax     = (CPU_TS    )0;                  /* Reset the task execution times                         */
    OSIntQNbrEntriesMax   = (OS_OBJ_QTY)0;                  /* Reset the queue maximum number of entries              */
#endif

#if OS_CFG_STAT_TASK_EN > 0u
    OSStatTaskCPUUsageMax = 0u;
 8006402:	801d      	strh	r5, [r3, #0]
    OSStatTaskTimeMax     = (CPU_TS)0;
 8006404:	4e26      	ldr	r6, [pc, #152]	; (80064a0 <OSStatReset+0xb0>)
#if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
    OSSchedLockTimeMax    = (CPU_TS)0;                      /* Reset the maximum scheduler lock time                  */
#endif

#if OS_MSG_EN > 0u
    OSMsgPool.NbrUsedMax  = 0u;
 8006406:	4b27      	ldr	r3, [pc, #156]	; (80064a4 <OSStatReset+0xb4>)
#if OS_CFG_STAT_TASK_EN > 0u
    OSStatTaskCPUUsageMax = 0u;
    OSStatTaskTimeMax     = (CPU_TS)0;
#endif

    OSTickTaskTimeMax     = (CPU_TS)0;
 8006408:	6025      	str	r5, [r4, #0]
#if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
    OSSchedLockTimeMax    = (CPU_TS)0;                      /* Reset the maximum scheduler lock time                  */
#endif

#if OS_MSG_EN > 0u
    OSMsgPool.NbrUsedMax  = 0u;
 800640a:	811d      	strh	r5, [r3, #8]
#endif

    OSTickTaskTimeMax     = (CPU_TS)0;

#if OS_CFG_TMR_EN > 0u
    OSTmrTaskTimeMax      = (CPU_TS)0;
 800640c:	600d      	str	r5, [r1, #0]
#ifdef CPU_CFG_INT_DIS_MEAS_EN
    OSIntDisTimeMax       = (CPU_TS)0;                      /* Reset the maximum interrupt disable time               */
#endif

#if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
    OSSchedLockTimeMax    = (CPU_TS)0;                      /* Reset the maximum scheduler lock time                  */
 800640e:	6015      	str	r5, [r2, #0]
    OSIntQNbrEntriesMax   = (OS_OBJ_QTY)0;                  /* Reset the queue maximum number of entries              */
#endif

#if OS_CFG_STAT_TASK_EN > 0u
    OSStatTaskCPUUsageMax = 0u;
    OSStatTaskTimeMax     = (CPU_TS)0;
 8006410:	6035      	str	r5, [r6, #0]
#endif

#if OS_MSG_EN > 0u
    OSMsgPool.NbrUsedMax  = 0u;
#endif
    CPU_CRITICAL_EXIT();
 8006412:	f7fb f9b3 	bl	800177c <CPU_SR_Restore>

#if OS_CFG_DBG_EN > 0u
    CPU_CRITICAL_ENTER();
 8006416:	f7fb f9ad 	bl	8001774 <CPU_SR_Save>
    p_tcb = OSTaskDbgListPtr;
 800641a:	4b23      	ldr	r3, [pc, #140]	; (80064a8 <OSStatReset+0xb8>)
 800641c:	681c      	ldr	r4, [r3, #0]
    CPU_CRITICAL_EXIT();
 800641e:	f7fb f9ad 	bl	800177c <CPU_SR_Restore>
    while (p_tcb != (OS_TCB *)0) {                          /* Reset per-Task statistics                              */
 8006422:	b1f4      	cbz	r4, 8006462 <OSStatReset+0x72>
        CPU_CRITICAL_ENTER();
 8006424:	f7fb f9a6 	bl	8001774 <CPU_SR_Save>
#ifdef CPU_CFG_INT_DIS_MEAS_EN
        p_tcb->IntDisTimeMax    = (CPU_TS      )0;
#endif

#if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
        p_tcb->SchedLockTimeMax = (CPU_TS      )0;
 8006428:	f8c4 50b4 	str.w	r5, [r4, #180]	; 0xb4
#endif

#if OS_CFG_TASK_PROFILE_EN > 0u
#if OS_CFG_TASK_Q_EN > 0u
        p_tcb->MsgQPendTimeMax  = (CPU_TS      )0;
 800642c:	67a5      	str	r5, [r4, #120]	; 0x78
#endif
        p_tcb->SemPendTimeMax   = (CPU_TS      )0;
 800642e:	f8c4 50a8 	str.w	r5, [r4, #168]	; 0xa8
        p_tcb->CtxSwCtr         = (OS_CTR      )0;
 8006432:	f8c4 5090 	str.w	r5, [r4, #144]	; 0x90
        p_tcb->CPUUsage         = (OS_CPU_USAGE)0;
 8006436:	f8a4 508c 	strh.w	r5, [r4, #140]	; 0x8c
        p_tcb->CPUUsageMax      = (OS_CPU_USAGE)0;
 800643a:	f8a4 508e 	strh.w	r5, [r4, #142]	; 0x8e
        p_tcb->CyclesTotal      = (OS_CYCLES   )0;
 800643e:	f8c4 509c 	str.w	r5, [r4, #156]	; 0x9c
        p_tcb->CyclesTotalPrev  = (OS_CYCLES   )0;
 8006442:	f8c4 50a0 	str.w	r5, [r4, #160]	; 0xa0
#if OS_CFG_DBG_EN > 0u
    CPU_CRITICAL_ENTER();
    p_tcb = OSTaskDbgListPtr;
    CPU_CRITICAL_EXIT();
    while (p_tcb != (OS_TCB *)0) {                          /* Reset per-Task statistics                              */
        CPU_CRITICAL_ENTER();
 8006446:	4606      	mov	r6, r0
        p_tcb->CtxSwCtr         = (OS_CTR      )0;
        p_tcb->CPUUsage         = (OS_CPU_USAGE)0;
        p_tcb->CPUUsageMax      = (OS_CPU_USAGE)0;
        p_tcb->CyclesTotal      = (OS_CYCLES   )0;
        p_tcb->CyclesTotalPrev  = (OS_CYCLES   )0;
        p_tcb->CyclesStart      =  OS_TS_GET();
 8006448:	f7fa fba0 	bl	8000b8c <CPU_TS_TmrRd>
#endif

#if OS_CFG_TASK_Q_EN > 0u
        p_msg_q                 = &p_tcb->MsgQ;
        p_msg_q->NbrEntriesMax  = (OS_MSG_QTY  )0;
 800644c:	f8a4 5070 	strh.w	r5, [r4, #112]	; 0x70
        p_tcb->CtxSwCtr         = (OS_CTR      )0;
        p_tcb->CPUUsage         = (OS_CPU_USAGE)0;
        p_tcb->CPUUsageMax      = (OS_CPU_USAGE)0;
        p_tcb->CyclesTotal      = (OS_CYCLES   )0;
        p_tcb->CyclesTotalPrev  = (OS_CYCLES   )0;
        p_tcb->CyclesStart      =  OS_TS_GET();
 8006450:	f8c4 0098 	str.w	r0, [r4, #152]	; 0x98

#if OS_CFG_TASK_Q_EN > 0u
        p_msg_q                 = &p_tcb->MsgQ;
        p_msg_q->NbrEntriesMax  = (OS_MSG_QTY  )0;
#endif
        p_tcb                   = p_tcb->DbgNextPtr;
 8006454:	f8d4 40bc 	ldr.w	r4, [r4, #188]	; 0xbc
        CPU_CRITICAL_EXIT();
 8006458:	4630      	mov	r0, r6
 800645a:	f7fb f98f 	bl	800177c <CPU_SR_Restore>

#if OS_CFG_DBG_EN > 0u
    CPU_CRITICAL_ENTER();
    p_tcb = OSTaskDbgListPtr;
    CPU_CRITICAL_EXIT();
    while (p_tcb != (OS_TCB *)0) {                          /* Reset per-Task statistics                              */
 800645e:	2c00      	cmp	r4, #0
 8006460:	d1e0      	bne.n	8006424 <OSStatReset+0x34>
        CPU_CRITICAL_EXIT();
    }
#endif

#if (OS_CFG_Q_EN > 0u) && (OS_CFG_DBG_EN > 0u)
    CPU_CRITICAL_ENTER();
 8006462:	f7fb f987 	bl	8001774 <CPU_SR_Save>
    p_q = OSQDbgListPtr;
 8006466:	4b11      	ldr	r3, [pc, #68]	; (80064ac <OSStatReset+0xbc>)
    CPU_CRITICAL_EXIT();
    while (p_q != (OS_Q *)0) {                              /* Reset message queues statistics                        */
        CPU_CRITICAL_ENTER();
        p_msg_q                = &p_q->MsgQ;
        p_msg_q->NbrEntriesMax = (OS_MSG_QTY)0;
 8006468:	2500      	movs	r5, #0
    }
#endif

#if (OS_CFG_Q_EN > 0u) && (OS_CFG_DBG_EN > 0u)
    CPU_CRITICAL_ENTER();
    p_q = OSQDbgListPtr;
 800646a:	681c      	ldr	r4, [r3, #0]
    CPU_CRITICAL_EXIT();
 800646c:	f7fb f986 	bl	800177c <CPU_SR_Restore>
    while (p_q != (OS_Q *)0) {                              /* Reset message queues statistics                        */
 8006470:	b13c      	cbz	r4, 8006482 <OSStatReset+0x92>
        CPU_CRITICAL_ENTER();
 8006472:	f7fb f97f 	bl	8001774 <CPU_SR_Save>
        p_msg_q                = &p_q->MsgQ;
        p_msg_q->NbrEntriesMax = (OS_MSG_QTY)0;
 8006476:	85a5      	strh	r5, [r4, #44]	; 0x2c
        p_q                    = p_q->DbgNextPtr;
 8006478:	69a4      	ldr	r4, [r4, #24]
        CPU_CRITICAL_EXIT();
 800647a:	f7fb f97f 	bl	800177c <CPU_SR_Restore>

#if (OS_CFG_Q_EN > 0u) && (OS_CFG_DBG_EN > 0u)
    CPU_CRITICAL_ENTER();
    p_q = OSQDbgListPtr;
    CPU_CRITICAL_EXIT();
    while (p_q != (OS_Q *)0) {                              /* Reset message queues statistics                        */
 800647e:	2c00      	cmp	r4, #0
 8006480:	d1f7      	bne.n	8006472 <OSStatReset+0x82>
        p_q                    = p_q->DbgNextPtr;
        CPU_CRITICAL_EXIT();
    }
#endif

    OS_TickListResetPeak();                                 /* Reset tick wheel statistics                            */
 8006482:	f001 fa33 	bl	80078ec <OS_TickListResetPeak>

#if OS_CFG_TMR_EN > 0u
    OS_TmrResetPeak();
 8006486:	f001 fe2b 	bl	80080e0 <OS_TmrResetPeak>
#endif


   *p_err = OS_ERR_NONE;
 800648a:	2300      	movs	r3, #0
 800648c:	803b      	strh	r3, [r7, #0]
}
 800648e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8006490:	2000ed5e 	.word	0x2000ed5e
 8006494:	2000ed70 	.word	0x2000ed70
 8006498:	2000ef54 	.word	0x2000ef54
 800649c:	2000f028 	.word	0x2000f028
 80064a0:	2000e97c 	.word	0x2000e97c
 80064a4:	2000ee4c 	.word	0x2000ee4c
 80064a8:	2000ed6c 	.word	0x2000ed6c
 80064ac:	2000ef1c 	.word	0x2000ef1c

080064b0 <OS_StatTask>:
*              4) This function is INTERNAL to uC/OS-III and your application should not call it.
************************************************************************************************************************
*/

void  OS_StatTask (void  *p_arg)
{
 80064b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    CPU_SR_ALLOC();



    p_arg = p_arg;                                          /* Prevent compiler warning for not using 'p_arg'         */
    while (OSStatTaskRdy != DEF_TRUE) {
 80064b4:	4d7f      	ldr	r5, [pc, #508]	; (80066b4 <OS_StatTask+0x204>)
*              4) This function is INTERNAL to uC/OS-III and your application should not call it.
************************************************************************************************************************
*/

void  OS_StatTask (void  *p_arg)
{
 80064b6:	b085      	sub	sp, #20
    CPU_SR_ALLOC();



    p_arg = p_arg;                                          /* Prevent compiler warning for not using 'p_arg'         */
    while (OSStatTaskRdy != DEF_TRUE) {
 80064b8:	782b      	ldrb	r3, [r5, #0]
 80064ba:	f10d 070e 	add.w	r7, sp, #14
 80064be:	2b01      	cmp	r3, #1
 80064c0:	4b7d      	ldr	r3, [pc, #500]	; (80066b8 <OS_StatTask+0x208>)
 80064c2:	681c      	ldr	r4, [r3, #0]
 80064c4:	d008      	beq.n	80064d8 <OS_StatTask+0x28>
 80064c6:	0066      	lsls	r6, r4, #1
        OSTimeDly(2u * OSCfg_StatTaskRate_Hz,               /* Wait until statistic task is ready                     */
 80064c8:	463a      	mov	r2, r7
 80064ca:	2100      	movs	r1, #0
 80064cc:	4630      	mov	r0, r6
 80064ce:	f001 facb 	bl	8007a68 <OSTimeDly>
    CPU_SR_ALLOC();



    p_arg = p_arg;                                          /* Prevent compiler warning for not using 'p_arg'         */
    while (OSStatTaskRdy != DEF_TRUE) {
 80064d2:	782b      	ldrb	r3, [r5, #0]
 80064d4:	2b01      	cmp	r3, #1
 80064d6:	d1f7      	bne.n	80064c8 <OS_StatTask+0x18>
        OSTimeDly(2u * OSCfg_StatTaskRate_Hz,               /* Wait until statistic task is ready                     */
                  OS_OPT_TIME_DLY,
                  &err);
    }
    OSStatReset(&err);                                      /* Reset statistics                                       */
 80064d8:	4638      	mov	r0, r7
 80064da:	f7ff ff89 	bl	80063f0 <OSStatReset>

    dly = (OS_TICK)0;                                       /* Compute statistic task sleep delay                     */
    if (OSCfg_TickRate_Hz > OSCfg_StatTaskRate_Hz) {
 80064de:	4b77      	ldr	r3, [pc, #476]	; (80066bc <OS_StatTask+0x20c>)
 80064e0:	681b      	ldr	r3, [r3, #0]
 80064e2:	42a3      	cmp	r3, r4
 80064e4:	d903      	bls.n	80064ee <OS_StatTask+0x3e>
        dly = (OS_TICK)(OSCfg_TickRate_Hz / OSCfg_StatTaskRate_Hz);
 80064e6:	fbb3 f2f4 	udiv	r2, r3, r4
 80064ea:	9201      	str	r2, [sp, #4]
    }
    if (dly == (OS_TICK)0) {
 80064ec:	b922      	cbnz	r2, 80064f8 <OS_StatTask+0x48>
        dly =  (OS_TICK)(OSCfg_TickRate_Hz / (OS_RATE_HZ)10);
 80064ee:	4a74      	ldr	r2, [pc, #464]	; (80066c0 <OS_StatTask+0x210>)
 80064f0:	fba2 2303 	umull	r2, r3, r2, r3
 80064f4:	08db      	lsrs	r3, r3, #3
 80064f6:	9301      	str	r3, [sp, #4]
 80064f8:	f8df b1f4 	ldr.w	fp, [pc, #500]	; 80066f0 <OS_StatTask+0x240>
 80064fc:	f8df a1ec 	ldr.w	sl, [pc, #492]	; 80066ec <OS_StatTask+0x23c>
        OSIntDisTimeMax = CPU_IntDisMeasMaxGet();
#endif

        CPU_CRITICAL_ENTER();                               /* ----------------- OVERALL CPU USAGE ------------------ */
        OSStatTaskCtrRun   = OSStatTaskCtr;                 /* Obtain the of the stat counter for the past .1 second  */
        OSStatTaskCtr      = (OS_TICK)0;                    /* Reset the stat counter for the next .1 second          */
 8006500:	2600      	movs	r6, #0
    if (dly == (OS_TICK)0) {
        dly =  (OS_TICK)(OSCfg_TickRate_Hz / (OS_RATE_HZ)10);
    }

    while (DEF_ON) {
        ts_start        = OS_TS_GET();
 8006502:	f7fa fb43 	bl	8000b8c <CPU_TS_TmrRd>
 8006506:	9000      	str	r0, [sp, #0]
#ifdef  CPU_CFG_INT_DIS_MEAS_EN
        OSIntDisTimeMax = CPU_IntDisMeasMaxGet();
#endif

        CPU_CRITICAL_ENTER();                               /* ----------------- OVERALL CPU USAGE ------------------ */
 8006508:	f7fb f934 	bl	8001774 <CPU_SR_Save>
        OSStatTaskCtrRun   = OSStatTaskCtr;                 /* Obtain the of the stat counter for the past .1 second  */
 800650c:	f8db 3000 	ldr.w	r3, [fp]
 8006510:	4a6c      	ldr	r2, [pc, #432]	; (80066c4 <OS_StatTask+0x214>)
        OSStatTaskCtr      = (OS_TICK)0;                    /* Reset the stat counter for the next .1 second          */
 8006512:	f8cb 6000 	str.w	r6, [fp]
#ifdef  CPU_CFG_INT_DIS_MEAS_EN
        OSIntDisTimeMax = CPU_IntDisMeasMaxGet();
#endif

        CPU_CRITICAL_ENTER();                               /* ----------------- OVERALL CPU USAGE ------------------ */
        OSStatTaskCtrRun   = OSStatTaskCtr;                 /* Obtain the of the stat counter for the past .1 second  */
 8006516:	6013      	str	r3, [r2, #0]
        OSStatTaskCtr      = (OS_TICK)0;                    /* Reset the stat counter for the next .1 second          */
        CPU_CRITICAL_EXIT();
 8006518:	f7fb f930 	bl	800177c <CPU_SR_Restore>

        if (OSStatTaskCtrMax > OSStatTaskCtrRun) {          /* Compute CPU Usage with best resolution                 */
 800651c:	4b6a      	ldr	r3, [pc, #424]	; (80066c8 <OS_StatTask+0x218>)
 800651e:	681a      	ldr	r2, [r3, #0]
 8006520:	4b68      	ldr	r3, [pc, #416]	; (80066c4 <OS_StatTask+0x214>)
 8006522:	681b      	ldr	r3, [r3, #0]
 8006524:	429a      	cmp	r2, r3
 8006526:	f240 80a4 	bls.w	8006672 <OS_StatTask+0x1c2>
            if (OSStatTaskCtrMax < 400000u) {                                        /*            1 to       400,000 */
 800652a:	4968      	ldr	r1, [pc, #416]	; (80066cc <OS_StatTask+0x21c>)
 800652c:	428a      	cmp	r2, r1
 800652e:	f240 80a5 	bls.w	800667c <OS_StatTask+0x1cc>
                ctr_mult = 10000u;
                ctr_div  =     1u;
            } else if (OSStatTaskCtrMax <   4000000u) {                              /*      400,000 to     4,000,000 */
 8006532:	4967      	ldr	r1, [pc, #412]	; (80066d0 <OS_StatTask+0x220>)
 8006534:	428a      	cmp	r2, r1
 8006536:	f240 80ae 	bls.w	8006696 <OS_StatTask+0x1e6>
                ctr_mult =  1000u;
                ctr_div  =    10u;
            } else if (OSStatTaskCtrMax <  40000000u) {                              /*    4,000,000 to    40,000,000 */
 800653a:	4966      	ldr	r1, [pc, #408]	; (80066d4 <OS_StatTask+0x224>)
 800653c:	428a      	cmp	r2, r1
 800653e:	f240 80b2 	bls.w	80066a6 <OS_StatTask+0x1f6>
                ctr_mult =   100u;
                ctr_div  =   100u;
            } else if (OSStatTaskCtrMax < 400000000u) {                              /*   40,000,000 to   400,000,000 */
                ctr_mult =    10u;
                ctr_div  =  1000u;
 8006542:	4865      	ldr	r0, [pc, #404]	; (80066d8 <OS_StatTask+0x228>)
 8006544:	f242 7110 	movw	r1, #10000	; 0x2710
 8006548:	4282      	cmp	r2, r0
 800654a:	bf96      	itet	ls
 800654c:	f44f 717a 	movls.w	r1, #1000	; 0x3e8
 8006550:	2001      	movhi	r0, #1
 8006552:	200a      	movls	r0, #10
            } else {                                                                 /*  400,000,000 and up           */
                ctr_mult =     1u;
                ctr_div  = 10000u;
            }
            ctr_max            = OSStatTaskCtrMax / ctr_div;
            OSStatTaskCPUUsage = (OS_CPU_USAGE)((OS_TICK)10000u - ctr_mult * OSStatTaskCtrRun / ctr_max);
 8006554:	fbb2 f2f1 	udiv	r2, r2, r1
 8006558:	fb03 f300 	mul.w	r3, r3, r0
 800655c:	fbb3 f3f2 	udiv	r3, r3, r2
            if (OSStatTaskCPUUsageMax < OSStatTaskCPUUsage) {
 8006560:	4a5e      	ldr	r2, [pc, #376]	; (80066dc <OS_StatTask+0x22c>)
            } else {                                                                 /*  400,000,000 and up           */
                ctr_mult =     1u;
                ctr_div  = 10000u;
            }
            ctr_max            = OSStatTaskCtrMax / ctr_div;
            OSStatTaskCPUUsage = (OS_CPU_USAGE)((OS_TICK)10000u - ctr_mult * OSStatTaskCtrRun / ctr_max);
 8006562:	f5c3 531c 	rsb	r3, r3, #9984	; 0x2700
 8006566:	3310      	adds	r3, #16
            if (OSStatTaskCPUUsageMax < OSStatTaskCPUUsage) {
 8006568:	8812      	ldrh	r2, [r2, #0]
            } else {                                                                 /*  400,000,000 and up           */
                ctr_mult =     1u;
                ctr_div  = 10000u;
            }
            ctr_max            = OSStatTaskCtrMax / ctr_div;
            OSStatTaskCPUUsage = (OS_CPU_USAGE)((OS_TICK)10000u - ctr_mult * OSStatTaskCtrRun / ctr_max);
 800656a:	b29b      	uxth	r3, r3
 800656c:	495c      	ldr	r1, [pc, #368]	; (80066e0 <OS_StatTask+0x230>)
            if (OSStatTaskCPUUsageMax < OSStatTaskCPUUsage) {
 800656e:	429a      	cmp	r2, r3
            } else {                                                                 /*  400,000,000 and up           */
                ctr_mult =     1u;
                ctr_div  = 10000u;
            }
            ctr_max            = OSStatTaskCtrMax / ctr_div;
            OSStatTaskCPUUsage = (OS_CPU_USAGE)((OS_TICK)10000u - ctr_mult * OSStatTaskCtrRun / ctr_max);
 8006570:	800b      	strh	r3, [r1, #0]
            if (OSStatTaskCPUUsageMax < OSStatTaskCPUUsage) {
 8006572:	495a      	ldr	r1, [pc, #360]	; (80066dc <OS_StatTask+0x22c>)
 8006574:	d200      	bcs.n	8006578 <OS_StatTask+0xc8>
                OSStatTaskCPUUsageMax = OSStatTaskCPUUsage;
 8006576:	800b      	strh	r3, [r1, #0]
            }
        } else {
            OSStatTaskCPUUsage = (OS_CPU_USAGE)10000u;
        }

        OSStatTaskHook();                                   /* Invoke user definable hook                             */
 8006578:	f7fe f9a4 	bl	80048c4 <OSStatTaskHook>

#if OS_CFG_DBG_EN > 0u
#if OS_CFG_TASK_PROFILE_EN > 0u
        cycles_total = (OS_CYCLES)0;

        CPU_CRITICAL_ENTER();
 800657c:	f7fb f8fa 	bl	8001774 <CPU_SR_Save>
        p_tcb = OSTaskDbgListPtr;
 8006580:	4b58      	ldr	r3, [pc, #352]	; (80066e4 <OS_StatTask+0x234>)
        CPU_CRITICAL_EXIT();
        while (p_tcb != (OS_TCB *)0) {                      /* ----------------- TOTAL CYCLES COUNT ----------------- */
 8006582:	2400      	movs	r4, #0
#if OS_CFG_DBG_EN > 0u
#if OS_CFG_TASK_PROFILE_EN > 0u
        cycles_total = (OS_CYCLES)0;

        CPU_CRITICAL_ENTER();
        p_tcb = OSTaskDbgListPtr;
 8006584:	681d      	ldr	r5, [r3, #0]
        CPU_CRITICAL_EXIT();
 8006586:	f7fb f8f9 	bl	800177c <CPU_SR_Restore>
        while (p_tcb != (OS_TCB *)0) {                      /* ----------------- TOTAL CYCLES COUNT ----------------- */
 800658a:	2d00      	cmp	r5, #0
 800658c:	d06d      	beq.n	800666a <OS_StatTask+0x1ba>
            OS_CRITICAL_ENTER();
 800658e:	f7fb f8f1 	bl	8001774 <CPU_SR_Save>
            p_tcb->CyclesTotalPrev =  p_tcb->CyclesTotal;   /* Save accumulated # cycles into a temp variable         */
 8006592:	f8d5 309c 	ldr.w	r3, [r5, #156]	; 0x9c
            p_tcb->CyclesTotal     = (OS_CYCLES)0;          /* Reset total cycles for task for next run               */
 8006596:	f8c5 609c 	str.w	r6, [r5, #156]	; 0x9c
        CPU_CRITICAL_ENTER();
        p_tcb = OSTaskDbgListPtr;
        CPU_CRITICAL_EXIT();
        while (p_tcb != (OS_TCB *)0) {                      /* ----------------- TOTAL CYCLES COUNT ----------------- */
            OS_CRITICAL_ENTER();
            p_tcb->CyclesTotalPrev =  p_tcb->CyclesTotal;   /* Save accumulated # cycles into a temp variable         */
 800659a:	f8c5 30a0 	str.w	r3, [r5, #160]	; 0xa0
            p_tcb->CyclesTotal     = (OS_CYCLES)0;          /* Reset total cycles for task for next run               */
            OS_CRITICAL_EXIT();
 800659e:	f7fb f8ed 	bl	800177c <CPU_SR_Restore>

            cycles_total          += p_tcb->CyclesTotalPrev;/* Perform sum of all task # cycles                       */
 80065a2:	f8d5 30a0 	ldr.w	r3, [r5, #160]	; 0xa0
 80065a6:	441c      	add	r4, r3

            CPU_CRITICAL_ENTER();
 80065a8:	f7fb f8e4 	bl	8001774 <CPU_SR_Save>
            p_tcb                  = p_tcb->DbgNextPtr;
 80065ac:	f8d5 50bc 	ldr.w	r5, [r5, #188]	; 0xbc
            CPU_CRITICAL_EXIT();
 80065b0:	f7fb f8e4 	bl	800177c <CPU_SR_Restore>
        cycles_total = (OS_CYCLES)0;

        CPU_CRITICAL_ENTER();
        p_tcb = OSTaskDbgListPtr;
        CPU_CRITICAL_EXIT();
        while (p_tcb != (OS_TCB *)0) {                      /* ----------------- TOTAL CYCLES COUNT ----------------- */
 80065b4:	2d00      	cmp	r5, #0
 80065b6:	d1ea      	bne.n	800658e <OS_StatTask+0xde>
#endif


#if OS_CFG_TASK_PROFILE_EN > 0u
                                                            /* ------------- INDIVIDUAL TASK CPU USAGE -------------- */
        if (cycles_total > (OS_CYCLES)0u) {                                          /* 'cycles_total' scaling ...    */
 80065b8:	2c00      	cmp	r4, #0
 80065ba:	d056      	beq.n	800666a <OS_StatTask+0x1ba>
            if (cycles_total < 400000u) {                                            /*            1 to       400,000 */
 80065bc:	4b43      	ldr	r3, [pc, #268]	; (80066cc <OS_StatTask+0x21c>)
 80065be:	429c      	cmp	r4, r3
 80065c0:	d960      	bls.n	8006684 <OS_StatTask+0x1d4>
                cycles_mult = 10000u;
                cycles_div  =     1u;
            } else if (cycles_total <   4000000u) {                                  /*      400,000 to     4,000,000 */
 80065c2:	4b43      	ldr	r3, [pc, #268]	; (80066d0 <OS_StatTask+0x220>)
 80065c4:	429c      	cmp	r4, r3
 80065c6:	d96a      	bls.n	800669e <OS_StatTask+0x1ee>
                cycles_mult =  1000u;
                cycles_div  =    10u;
            } else if (cycles_total <  40000000u) {                                  /*    4,000,000 to    40,000,000 */
 80065c8:	4b42      	ldr	r3, [pc, #264]	; (80066d4 <OS_StatTask+0x224>)
 80065ca:	429c      	cmp	r4, r3
 80065cc:	d96e      	bls.n	80066ac <OS_StatTask+0x1fc>
                cycles_mult =   100u;
                cycles_div  =   100u;
            } else if (cycles_total < 400000000u) {                                  /*   40,000,000 to   400,000,000 */
                cycles_mult =    10u;
 80065ce:	4b42      	ldr	r3, [pc, #264]	; (80066d8 <OS_StatTask+0x228>)
 80065d0:	f242 7510 	movw	r5, #10000	; 0x2710
 80065d4:	429c      	cmp	r4, r3
 80065d6:	bf8e      	itee	hi
 80065d8:	f04f 0801 	movhi.w	r8, #1
 80065dc:	f04f 080a 	movls.w	r8, #10
 80065e0:	f44f 757a 	movls.w	r5, #1000	; 0x3e8
                cycles_div  =  1000u;
            } else {                                                                 /*  400,000,000 and up           */
                cycles_mult =     1u;
                cycles_div  = 10000u;
            }
            cycles_max  = cycles_total / cycles_div;
 80065e4:	fbb4 f5f5 	udiv	r5, r4, r5
        } else {
            cycles_mult = 0u;
            cycles_max  = 1u;
        }
#endif
        CPU_CRITICAL_ENTER();
 80065e8:	f7fb f8c4 	bl	8001774 <CPU_SR_Save>
        p_tcb = OSTaskDbgListPtr;
 80065ec:	4b3d      	ldr	r3, [pc, #244]	; (80066e4 <OS_StatTask+0x234>)
 80065ee:	f242 7910 	movw	r9, #10000	; 0x2710
 80065f2:	681c      	ldr	r4, [r3, #0]
        CPU_CRITICAL_EXIT();
 80065f4:	f7fb f8c2 	bl	800177c <CPU_SR_Restore>
        while (p_tcb != (OS_TCB *)0) {
 80065f8:	b314      	cbz	r4, 8006640 <OS_StatTask+0x190>
#if OS_CFG_TASK_PROFILE_EN > 0u                             /* Compute execution time of each task                    */
            usage = (OS_CPU_USAGE)(cycles_mult * p_tcb->CyclesTotalPrev / cycles_max);
 80065fa:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
            if (usage > 10000u) {
                usage = 10000u;
            }
            p_tcb->CPUUsage = usage;
            if (p_tcb->CPUUsageMax < usage) {               /* Detect peak CPU usage                                  */
 80065fe:	f8b4 c08e 	ldrh.w	ip, [r4, #142]	; 0x8e
        CPU_CRITICAL_ENTER();
        p_tcb = OSTaskDbgListPtr;
        CPU_CRITICAL_EXIT();
        while (p_tcb != (OS_TCB *)0) {
#if OS_CFG_TASK_PROFILE_EN > 0u                             /* Compute execution time of each task                    */
            usage = (OS_CPU_USAGE)(cycles_mult * p_tcb->CyclesTotalPrev / cycles_max);
 8006602:	fb03 fe08 	mul.w	lr, r3, r8
 8006606:	fbbe fef5 	udiv	lr, lr, r5
 800660a:	fa1f fe8e 	uxth.w	lr, lr
 800660e:	45ce      	cmp	lr, r9
 8006610:	bf28      	it	cs
 8006612:	46ce      	movcs	lr, r9
            if (usage > 10000u) {
                usage = 10000u;
            }
            p_tcb->CPUUsage = usage;
            if (p_tcb->CPUUsageMax < usage) {               /* Detect peak CPU usage                                  */
 8006614:	45f4      	cmp	ip, lr
                p_tcb->CPUUsageMax = usage;
 8006616:	bf38      	it	cc
 8006618:	f8a4 e08e 	strhcc.w	lr, [r4, #142]	; 0x8e
            }
#endif

#if OS_CFG_STAT_TASK_STK_CHK_EN > 0u
            OSTaskStkChk( p_tcb,                            /* Compute stack usage of active tasks only               */
 800661c:	f104 02ac 	add.w	r2, r4, #172	; 0xac
 8006620:	f104 01b0 	add.w	r1, r4, #176	; 0xb0
 8006624:	4620      	mov	r0, r4
#if OS_CFG_TASK_PROFILE_EN > 0u                             /* Compute execution time of each task                    */
            usage = (OS_CPU_USAGE)(cycles_mult * p_tcb->CyclesTotalPrev / cycles_max);
            if (usage > 10000u) {
                usage = 10000u;
            }
            p_tcb->CPUUsage = usage;
 8006626:	f8a4 e08c 	strh.w	lr, [r4, #140]	; 0x8c
                p_tcb->CPUUsageMax = usage;
            }
#endif

#if OS_CFG_STAT_TASK_STK_CHK_EN > 0u
            OSTaskStkChk( p_tcb,                            /* Compute stack usage of active tasks only               */
 800662a:	463b      	mov	r3, r7
 800662c:	f000 fbd4 	bl	8006dd8 <OSTaskStkChk>
                         &p_tcb->StkFree,
                         &p_tcb->StkUsed,
                         &err);
#endif

            CPU_CRITICAL_ENTER();
 8006630:	f7fb f8a0 	bl	8001774 <CPU_SR_Save>
            p_tcb = p_tcb->DbgNextPtr;
 8006634:	f8d4 40bc 	ldr.w	r4, [r4, #188]	; 0xbc
            CPU_CRITICAL_EXIT();
 8006638:	f7fb f8a0 	bl	800177c <CPU_SR_Restore>
        }
#endif
        CPU_CRITICAL_ENTER();
        p_tcb = OSTaskDbgListPtr;
        CPU_CRITICAL_EXIT();
        while (p_tcb != (OS_TCB *)0) {
 800663c:	2c00      	cmp	r4, #0
 800663e:	d1dc      	bne.n	80065fa <OS_StatTask+0x14a>
            p_tcb = p_tcb->DbgNextPtr;
            CPU_CRITICAL_EXIT();
        }
#endif

        if (OSStatResetFlag == DEF_TRUE) {                  /* Check if need to reset statistics                      */
 8006640:	4b29      	ldr	r3, [pc, #164]	; (80066e8 <OS_StatTask+0x238>)
 8006642:	4a29      	ldr	r2, [pc, #164]	; (80066e8 <OS_StatTask+0x238>)
 8006644:	781b      	ldrb	r3, [r3, #0]
 8006646:	2b01      	cmp	r3, #1
 8006648:	d020      	beq.n	800668c <OS_StatTask+0x1dc>
            OSStatResetFlag  = DEF_FALSE;
            OSStatReset(&err);
        }

        ts_end = OS_TS_GET() - ts_start;                    /* Measure execution time of statistic task               */
 800664a:	f7fa fa9f 	bl	8000b8c <CPU_TS_TmrRd>
 800664e:	9a00      	ldr	r2, [sp, #0]
        if (OSStatTaskTimeMax < ts_end) {
 8006650:	f8da 3000 	ldr.w	r3, [sl]
        if (OSStatResetFlag == DEF_TRUE) {                  /* Check if need to reset statistics                      */
            OSStatResetFlag  = DEF_FALSE;
            OSStatReset(&err);
        }

        ts_end = OS_TS_GET() - ts_start;                    /* Measure execution time of statistic task               */
 8006654:	1a80      	subs	r0, r0, r2
        if (OSStatTaskTimeMax < ts_end) {
 8006656:	4a25      	ldr	r2, [pc, #148]	; (80066ec <OS_StatTask+0x23c>)
 8006658:	4298      	cmp	r0, r3
            OSStatTaskTimeMax = ts_end;
 800665a:	bf88      	it	hi
 800665c:	6010      	strhi	r0, [r2, #0]
        }

        OSTimeDly(dly,
 800665e:	2100      	movs	r1, #0
 8006660:	463a      	mov	r2, r7
 8006662:	9801      	ldr	r0, [sp, #4]
 8006664:	f001 fa00 	bl	8007a68 <OSTimeDly>
                  OS_OPT_TIME_DLY,
                  &err);
    }
 8006668:	e74b      	b.n	8006502 <OS_StatTask+0x52>
                cycles_div  = 10000u;
            }
            cycles_max  = cycles_total / cycles_div;
        } else {
            cycles_mult = 0u;
            cycles_max  = 1u;
 800666a:	2501      	movs	r5, #1
                cycles_mult =     1u;
                cycles_div  = 10000u;
            }
            cycles_max  = cycles_total / cycles_div;
        } else {
            cycles_mult = 0u;
 800666c:	f04f 0800 	mov.w	r8, #0
 8006670:	e7ba      	b.n	80065e8 <OS_StatTask+0x138>
            OSStatTaskCPUUsage = (OS_CPU_USAGE)((OS_TICK)10000u - ctr_mult * OSStatTaskCtrRun / ctr_max);
            if (OSStatTaskCPUUsageMax < OSStatTaskCPUUsage) {
                OSStatTaskCPUUsageMax = OSStatTaskCPUUsage;
            }
        } else {
            OSStatTaskCPUUsage = (OS_CPU_USAGE)10000u;
 8006672:	f242 7310 	movw	r3, #10000	; 0x2710
 8006676:	4a1a      	ldr	r2, [pc, #104]	; (80066e0 <OS_StatTask+0x230>)
 8006678:	8013      	strh	r3, [r2, #0]
 800667a:	e77d      	b.n	8006578 <OS_StatTask+0xc8>
        CPU_CRITICAL_EXIT();

        if (OSStatTaskCtrMax > OSStatTaskCtrRun) {          /* Compute CPU Usage with best resolution                 */
            if (OSStatTaskCtrMax < 400000u) {                                        /*            1 to       400,000 */
                ctr_mult = 10000u;
                ctr_div  =     1u;
 800667c:	2101      	movs	r1, #1
        OSStatTaskCtr      = (OS_TICK)0;                    /* Reset the stat counter for the next .1 second          */
        CPU_CRITICAL_EXIT();

        if (OSStatTaskCtrMax > OSStatTaskCtrRun) {          /* Compute CPU Usage with best resolution                 */
            if (OSStatTaskCtrMax < 400000u) {                                        /*            1 to       400,000 */
                ctr_mult = 10000u;
 800667e:	f242 7010 	movw	r0, #10000	; 0x2710
 8006682:	e767      	b.n	8006554 <OS_StatTask+0xa4>

#if OS_CFG_TASK_PROFILE_EN > 0u
                                                            /* ------------- INDIVIDUAL TASK CPU USAGE -------------- */
        if (cycles_total > (OS_CYCLES)0u) {                                          /* 'cycles_total' scaling ...    */
            if (cycles_total < 400000u) {                                            /*            1 to       400,000 */
                cycles_mult = 10000u;
 8006684:	f242 7810 	movw	r8, #10000	; 0x2710
                cycles_div  =     1u;
 8006688:	2501      	movs	r5, #1
 800668a:	e7ab      	b.n	80065e4 <OS_StatTask+0x134>
        }
#endif

        if (OSStatResetFlag == DEF_TRUE) {                  /* Check if need to reset statistics                      */
            OSStatResetFlag  = DEF_FALSE;
            OSStatReset(&err);
 800668c:	4638      	mov	r0, r7
            CPU_CRITICAL_EXIT();
        }
#endif

        if (OSStatResetFlag == DEF_TRUE) {                  /* Check if need to reset statistics                      */
            OSStatResetFlag  = DEF_FALSE;
 800668e:	7016      	strb	r6, [r2, #0]
            OSStatReset(&err);
 8006690:	f7ff feae 	bl	80063f0 <OSStatReset>
 8006694:	e7d9      	b.n	800664a <OS_StatTask+0x19a>
            if (OSStatTaskCtrMax < 400000u) {                                        /*            1 to       400,000 */
                ctr_mult = 10000u;
                ctr_div  =     1u;
            } else if (OSStatTaskCtrMax <   4000000u) {                              /*      400,000 to     4,000,000 */
                ctr_mult =  1000u;
                ctr_div  =    10u;
 8006696:	210a      	movs	r1, #10
        if (OSStatTaskCtrMax > OSStatTaskCtrRun) {          /* Compute CPU Usage with best resolution                 */
            if (OSStatTaskCtrMax < 400000u) {                                        /*            1 to       400,000 */
                ctr_mult = 10000u;
                ctr_div  =     1u;
            } else if (OSStatTaskCtrMax <   4000000u) {                              /*      400,000 to     4,000,000 */
                ctr_mult =  1000u;
 8006698:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800669c:	e75a      	b.n	8006554 <OS_StatTask+0xa4>
        if (cycles_total > (OS_CYCLES)0u) {                                          /* 'cycles_total' scaling ...    */
            if (cycles_total < 400000u) {                                            /*            1 to       400,000 */
                cycles_mult = 10000u;
                cycles_div  =     1u;
            } else if (cycles_total <   4000000u) {                                  /*      400,000 to     4,000,000 */
                cycles_mult =  1000u;
 800669e:	f44f 787a 	mov.w	r8, #1000	; 0x3e8
                cycles_div  =    10u;
 80066a2:	250a      	movs	r5, #10
 80066a4:	e79e      	b.n	80065e4 <OS_StatTask+0x134>
            } else if (OSStatTaskCtrMax <   4000000u) {                              /*      400,000 to     4,000,000 */
                ctr_mult =  1000u;
                ctr_div  =    10u;
            } else if (OSStatTaskCtrMax <  40000000u) {                              /*    4,000,000 to    40,000,000 */
                ctr_mult =   100u;
                ctr_div  =   100u;
 80066a6:	2164      	movs	r1, #100	; 0x64
                ctr_div  =     1u;
            } else if (OSStatTaskCtrMax <   4000000u) {                              /*      400,000 to     4,000,000 */
                ctr_mult =  1000u;
                ctr_div  =    10u;
            } else if (OSStatTaskCtrMax <  40000000u) {                              /*    4,000,000 to    40,000,000 */
                ctr_mult =   100u;
 80066a8:	4608      	mov	r0, r1
 80066aa:	e753      	b.n	8006554 <OS_StatTask+0xa4>
                cycles_div  =     1u;
            } else if (cycles_total <   4000000u) {                                  /*      400,000 to     4,000,000 */
                cycles_mult =  1000u;
                cycles_div  =    10u;
            } else if (cycles_total <  40000000u) {                                  /*    4,000,000 to    40,000,000 */
                cycles_mult =   100u;
 80066ac:	f04f 0864 	mov.w	r8, #100	; 0x64
                cycles_div  =   100u;
 80066b0:	4645      	mov	r5, r8
 80066b2:	e797      	b.n	80065e4 <OS_StatTask+0x134>
 80066b4:	2000ec7d 	.word	0x2000ec7d
 80066b8:	080160e4 	.word	0x080160e4
 80066bc:	080160cc 	.word	0x080160cc
 80066c0:	cccccccd 	.word	0xcccccccd
 80066c4:	2000ef44 	.word	0x2000ef44
 80066c8:	2000ef30 	.word	0x2000ef30
 80066cc:	00061a7f 	.word	0x00061a7f
 80066d0:	003d08ff 	.word	0x003d08ff
 80066d4:	026259ff 	.word	0x026259ff
 80066d8:	17d783ff 	.word	0x17d783ff
 80066dc:	2000ed5e 	.word	0x2000ed5e
 80066e0:	2000ed7c 	.word	0x2000ed7c
 80066e4:	2000ed6c 	.word	0x2000ed6c
 80066e8:	2000ef58 	.word	0x2000ef58
 80066ec:	2000e97c 	.word	0x2000e97c
 80066f0:	2000e980 	.word	0x2000e980

080066f4 <OSStatTaskCPUUsageInit>:
* Returns    : none
************************************************************************************************************************
*/

void  OSStatTaskCPUUsageInit (OS_ERR  *p_err)
{
 80066f4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80066f6:	b083      	sub	sp, #12
        return;
    }
#endif

#if (OS_CFG_TMR_EN > 0u)
    OSTaskSuspend(&OSTmrTaskTCB, &err);
 80066f8:	f10d 0106 	add.w	r1, sp, #6
* Returns    : none
************************************************************************************************************************
*/

void  OSStatTaskCPUUsageInit (OS_ERR  *p_err)
{
 80066fc:	4604      	mov	r4, r0
        return;
    }
#endif

#if (OS_CFG_TMR_EN > 0u)
    OSTaskSuspend(&OSTmrTaskTCB, &err);
 80066fe:	4822      	ldr	r0, [pc, #136]	; (8006788 <OSStatTaskCPUUsageInit+0x94>)
 8006700:	f000 ffc2 	bl	8007688 <OSTaskSuspend>
    if (err != OS_ERR_NONE) {
 8006704:	f8bd 1006 	ldrh.w	r1, [sp, #6]
 8006708:	b111      	cbz	r1, 8006710 <OSStatTaskCPUUsageInit+0x1c>
       *p_err = err;
 800670a:	8021      	strh	r1, [r4, #0]

    OSStatTaskCtrMax  = OSStatTaskCtr;                      /* Store maximum idle counter count                       */
    OSStatTaskRdy     = OS_STATE_RDY;
    CPU_CRITICAL_EXIT();
   *p_err             = OS_ERR_NONE;
}
 800670c:	b003      	add	sp, #12
 800670e:	bdf0      	pop	{r4, r5, r6, r7, pc}
       *p_err = err;
        return;
    }
#endif

    OSTimeDly((OS_TICK )2,                                  /* Synchronize with clock tick                            */
 8006710:	f10d 0206 	add.w	r2, sp, #6
 8006714:	2002      	movs	r0, #2
 8006716:	f001 f9a7 	bl	8007a68 <OSTimeDly>
              (OS_OPT  )OS_OPT_TIME_DLY,
              (OS_ERR *)&err);
    if (err != OS_ERR_NONE) {
 800671a:	f8bd 5006 	ldrh.w	r5, [sp, #6]
 800671e:	b115      	cbz	r5, 8006726 <OSStatTaskCPUUsageInit+0x32>
    OSStatTaskTimeMax = (CPU_TS)0;

    OSStatTaskCtrMax  = OSStatTaskCtr;                      /* Store maximum idle counter count                       */
    OSStatTaskRdy     = OS_STATE_RDY;
    CPU_CRITICAL_EXIT();
   *p_err             = OS_ERR_NONE;
 8006720:	8025      	strh	r5, [r4, #0]
}
 8006722:	b003      	add	sp, #12
 8006724:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (err != OS_ERR_NONE) {
       *p_err = err;
        return;
    }
    CPU_CRITICAL_ENTER();
    OSStatTaskCtr = (OS_TICK)0;                             /* Clear idle counter                                     */
 8006726:	4e19      	ldr	r6, [pc, #100]	; (800678c <OSStatTaskCPUUsageInit+0x98>)
              (OS_ERR *)&err);
    if (err != OS_ERR_NONE) {
       *p_err = err;
        return;
    }
    CPU_CRITICAL_ENTER();
 8006728:	f7fb f824 	bl	8001774 <CPU_SR_Save>
    OSStatTaskCtr = (OS_TICK)0;                             /* Clear idle counter                                     */
 800672c:	6035      	str	r5, [r6, #0]
    CPU_CRITICAL_EXIT();
 800672e:	f7fb f825 	bl	800177c <CPU_SR_Restore>

    dly = (OS_TICK)0;
    if (OSCfg_TickRate_Hz > OSCfg_StatTaskRate_Hz) {
 8006732:	4b17      	ldr	r3, [pc, #92]	; (8006790 <OSStatTaskCPUUsageInit+0x9c>)
 8006734:	4a17      	ldr	r2, [pc, #92]	; (8006794 <OSStatTaskCPUUsageInit+0xa0>)
 8006736:	681b      	ldr	r3, [r3, #0]
 8006738:	6810      	ldr	r0, [r2, #0]
 800673a:	4283      	cmp	r3, r0
 800673c:	d81e      	bhi.n	800677c <OSStatTaskCPUUsageInit+0x88>
        dly = (OS_TICK)(OSCfg_TickRate_Hz / OSCfg_StatTaskRate_Hz);
    }
    if (dly == (OS_TICK)0) {
        dly =  (OS_TICK)(OSCfg_TickRate_Hz / (OS_RATE_HZ)10);
 800673e:	4816      	ldr	r0, [pc, #88]	; (8006798 <OSStatTaskCPUUsageInit+0xa4>)
 8006740:	fba0 3003 	umull	r3, r0, r0, r3
 8006744:	08c0      	lsrs	r0, r0, #3
    }

    OSTimeDly(dly,                                          /* Determine MAX. idle counter value                      */
 8006746:	f10d 0206 	add.w	r2, sp, #6
 800674a:	2100      	movs	r1, #0
 800674c:	f001 f98c 	bl	8007a68 <OSTimeDly>
              OS_OPT_TIME_DLY,
              &err);

#if (OS_CFG_TMR_EN > 0u)
    OSTaskResume(&OSTmrTaskTCB, &err);
 8006750:	f10d 0106 	add.w	r1, sp, #6
 8006754:	480c      	ldr	r0, [pc, #48]	; (8006788 <OSStatTaskCPUUsageInit+0x94>)
 8006756:	f000 fe81 	bl	800745c <OSTaskResume>
    if (err != OS_ERR_NONE) {
 800675a:	f8bd 5006 	ldrh.w	r5, [sp, #6]
 800675e:	2d00      	cmp	r5, #0
 8006760:	d1de      	bne.n	8006720 <OSStatTaskCPUUsageInit+0x2c>
       *p_err = err;
        return;
    }
#endif

    CPU_CRITICAL_ENTER();
 8006762:	f7fb f807 	bl	8001774 <CPU_SR_Save>
    OSStatTaskTimeMax = (CPU_TS)0;

    OSStatTaskCtrMax  = OSStatTaskCtr;                      /* Store maximum idle counter count                       */
 8006766:	6837      	ldr	r7, [r6, #0]
        return;
    }
#endif

    CPU_CRITICAL_ENTER();
    OSStatTaskTimeMax = (CPU_TS)0;
 8006768:	490c      	ldr	r1, [pc, #48]	; (800679c <OSStatTaskCPUUsageInit+0xa8>)

    OSStatTaskCtrMax  = OSStatTaskCtr;                      /* Store maximum idle counter count                       */
 800676a:	4e0d      	ldr	r6, [pc, #52]	; (80067a0 <OSStatTaskCPUUsageInit+0xac>)
    OSStatTaskRdy     = OS_STATE_RDY;
 800676c:	4b0d      	ldr	r3, [pc, #52]	; (80067a4 <OSStatTaskCPUUsageInit+0xb0>)
 800676e:	2201      	movs	r2, #1
#endif

    CPU_CRITICAL_ENTER();
    OSStatTaskTimeMax = (CPU_TS)0;

    OSStatTaskCtrMax  = OSStatTaskCtr;                      /* Store maximum idle counter count                       */
 8006770:	6037      	str	r7, [r6, #0]
        return;
    }
#endif

    CPU_CRITICAL_ENTER();
    OSStatTaskTimeMax = (CPU_TS)0;
 8006772:	600d      	str	r5, [r1, #0]

    OSStatTaskCtrMax  = OSStatTaskCtr;                      /* Store maximum idle counter count                       */
    OSStatTaskRdy     = OS_STATE_RDY;
 8006774:	701a      	strb	r2, [r3, #0]
    CPU_CRITICAL_EXIT();
 8006776:	f7fb f801 	bl	800177c <CPU_SR_Restore>
 800677a:	e7d1      	b.n	8006720 <OSStatTaskCPUUsageInit+0x2c>
    OSStatTaskCtr = (OS_TICK)0;                             /* Clear idle counter                                     */
    CPU_CRITICAL_EXIT();

    dly = (OS_TICK)0;
    if (OSCfg_TickRate_Hz > OSCfg_StatTaskRate_Hz) {
        dly = (OS_TICK)(OSCfg_TickRate_Hz / OSCfg_StatTaskRate_Hz);
 800677c:	fbb3 f0f0 	udiv	r0, r3, r0
    }
    if (dly == (OS_TICK)0) {
 8006780:	2800      	cmp	r0, #0
 8006782:	d1e0      	bne.n	8006746 <OSStatTaskCPUUsageInit+0x52>
 8006784:	e7db      	b.n	800673e <OSStatTaskCPUUsageInit+0x4a>
 8006786:	bf00      	nop
 8006788:	2000ed88 	.word	0x2000ed88
 800678c:	2000e980 	.word	0x2000e980
 8006790:	080160cc 	.word	0x080160cc
 8006794:	080160e4 	.word	0x080160e4
 8006798:	cccccccd 	.word	0xcccccccd
 800679c:	2000e97c 	.word	0x2000e97c
 80067a0:	2000ef30 	.word	0x2000ef30
 80067a4:	2000ec7d 	.word	0x2000ec7d

080067a8 <OS_StatTaskInit>:
* Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
************************************************************************************************************************
*/

void  OS_StatTaskInit (OS_ERR  *p_err)
{
 80067a8:	b5f0      	push	{r4, r5, r6, r7, lr}
    OSStatTaskCtrMax = (OS_TICK)0;
    OSStatTaskRdy    = OS_STATE_NOT_RDY;                    /* Statistic task is not ready                            */
    OSStatResetFlag  = DEF_FALSE;

                                                            /* ---------------- CREATE THE STAT TASK ---------------- */
    if (OSCfg_StatTaskStkBasePtr == (CPU_STK *)0) {
 80067aa:	4b1e      	ldr	r3, [pc, #120]	; (8006824 <OS_StatTaskInit+0x7c>)
        OS_SAFETY_CRITICAL_EXCEPTION();
        return;
    }
#endif

    OSStatTaskCtr    = (OS_TICK)0;
 80067ac:	4f1e      	ldr	r7, [pc, #120]	; (8006828 <OS_StatTaskInit+0x80>)
    OSStatTaskCtrMax = (OS_TICK)0;
    OSStatTaskRdy    = OS_STATE_NOT_RDY;                    /* Statistic task is not ready                            */
    OSStatResetFlag  = DEF_FALSE;

                                                            /* ---------------- CREATE THE STAT TASK ---------------- */
    if (OSCfg_StatTaskStkBasePtr == (CPU_STK *)0) {
 80067ae:	681a      	ldr	r2, [r3, #0]
        return;
    }
#endif

    OSStatTaskCtr    = (OS_TICK)0;
    OSStatTaskCtrRun = (OS_TICK)0;
 80067b0:	4e1e      	ldr	r6, [pc, #120]	; (800682c <OS_StatTaskInit+0x84>)
    OSStatTaskCtrMax = (OS_TICK)0;
 80067b2:	4d1f      	ldr	r5, [pc, #124]	; (8006830 <OS_StatTaskInit+0x88>)
    OSStatTaskRdy    = OS_STATE_NOT_RDY;                    /* Statistic task is not ready                            */
 80067b4:	4c1f      	ldr	r4, [pc, #124]	; (8006834 <OS_StatTaskInit+0x8c>)
    OSStatResetFlag  = DEF_FALSE;
 80067b6:	4920      	ldr	r1, [pc, #128]	; (8006838 <OS_StatTaskInit+0x90>)
        OS_SAFETY_CRITICAL_EXCEPTION();
        return;
    }
#endif

    OSStatTaskCtr    = (OS_TICK)0;
 80067b8:	2300      	movs	r3, #0
* Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
************************************************************************************************************************
*/

void  OS_StatTaskInit (OS_ERR  *p_err)
{
 80067ba:	b08b      	sub	sp, #44	; 0x2c
        OS_SAFETY_CRITICAL_EXCEPTION();
        return;
    }
#endif

    OSStatTaskCtr    = (OS_TICK)0;
 80067bc:	603b      	str	r3, [r7, #0]
    OSStatTaskCtrRun = (OS_TICK)0;
 80067be:	6033      	str	r3, [r6, #0]
    OSStatTaskCtrMax = (OS_TICK)0;
 80067c0:	602b      	str	r3, [r5, #0]
    OSStatTaskRdy    = OS_STATE_NOT_RDY;                    /* Statistic task is not ready                            */
 80067c2:	7023      	strb	r3, [r4, #0]
    OSStatResetFlag  = DEF_FALSE;
 80067c4:	700b      	strb	r3, [r1, #0]

                                                            /* ---------------- CREATE THE STAT TASK ---------------- */
    if (OSCfg_StatTaskStkBasePtr == (CPU_STK *)0) {
 80067c6:	2a00      	cmp	r2, #0
 80067c8:	d026      	beq.n	8006818 <OS_StatTaskInit+0x70>
       *p_err = OS_ERR_STAT_STK_INVALID;
        return;
    }

    if (OSCfg_StatTaskStkSize < OSCfg_StkSizeMin) {
 80067ca:	491c      	ldr	r1, [pc, #112]	; (800683c <OS_StatTaskInit+0x94>)
 80067cc:	4c1c      	ldr	r4, [pc, #112]	; (8006840 <OS_StatTaskInit+0x98>)
 80067ce:	6809      	ldr	r1, [r1, #0]
 80067d0:	6824      	ldr	r4, [r4, #0]
 80067d2:	42a1      	cmp	r1, r4
 80067d4:	d31b      	bcc.n	800680e <OS_StatTaskInit+0x66>
       *p_err = OS_ERR_STAT_STK_SIZE_INVALID;
        return;
    }

    if (OSCfg_StatTaskPrio >= (OS_CFG_PRIO_MAX - 1u)) {
 80067d6:	4c1b      	ldr	r4, [pc, #108]	; (8006844 <OS_StatTaskInit+0x9c>)
 80067d8:	7824      	ldrb	r4, [r4, #0]
 80067da:	2c3d      	cmp	r4, #61	; 0x3d
 80067dc:	d904      	bls.n	80067e8 <OS_StatTaskInit+0x40>
       *p_err = OS_ERR_STAT_PRIO_INVALID;
 80067de:	f646 632a 	movw	r3, #28202	; 0x6e2a
 80067e2:	8003      	strh	r3, [r0, #0]
                 (OS_MSG_QTY  )0,
                 (OS_TICK     )0,
                 (void       *)0,
                 (OS_OPT      )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR),
                 (OS_ERR     *)p_err);
}
 80067e4:	b00b      	add	sp, #44	; 0x2c
 80067e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (OSCfg_StatTaskPrio >= (OS_CFG_PRIO_MAX - 1u)) {
       *p_err = OS_ERR_STAT_PRIO_INVALID;
        return;
    }

    OSTaskCreate((OS_TCB     *)&OSStatTaskTCB,
 80067e8:	4e17      	ldr	r6, [pc, #92]	; (8006848 <OS_StatTaskInit+0xa0>)
 80067ea:	2503      	movs	r5, #3
 80067ec:	6836      	ldr	r6, [r6, #0]
 80067ee:	9008      	str	r0, [sp, #32]
 80067f0:	9103      	str	r1, [sp, #12]
 80067f2:	9201      	str	r2, [sp, #4]
 80067f4:	9306      	str	r3, [sp, #24]
 80067f6:	9305      	str	r3, [sp, #20]
 80067f8:	9304      	str	r3, [sp, #16]
 80067fa:	9400      	str	r4, [sp, #0]
 80067fc:	9602      	str	r6, [sp, #8]
 80067fe:	9507      	str	r5, [sp, #28]
 8006800:	4a12      	ldr	r2, [pc, #72]	; (800684c <OS_StatTaskInit+0xa4>)
 8006802:	4913      	ldr	r1, [pc, #76]	; (8006850 <OS_StatTaskInit+0xa8>)
 8006804:	4813      	ldr	r0, [pc, #76]	; (8006854 <OS_StatTaskInit+0xac>)
 8006806:	f000 fc01 	bl	800700c <OSTaskCreate>
                 (OS_MSG_QTY  )0,
                 (OS_TICK     )0,
                 (void       *)0,
                 (OS_OPT      )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR),
                 (OS_ERR     *)p_err);
}
 800680a:	b00b      	add	sp, #44	; 0x2c
 800680c:	bdf0      	pop	{r4, r5, r6, r7, pc}
       *p_err = OS_ERR_STAT_STK_INVALID;
        return;
    }

    if (OSCfg_StatTaskStkSize < OSCfg_StkSizeMin) {
       *p_err = OS_ERR_STAT_STK_SIZE_INVALID;
 800680e:	f646 632c 	movw	r3, #28204	; 0x6e2c
 8006812:	8003      	strh	r3, [r0, #0]
                 (OS_MSG_QTY  )0,
                 (OS_TICK     )0,
                 (void       *)0,
                 (OS_OPT      )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR),
                 (OS_ERR     *)p_err);
}
 8006814:	b00b      	add	sp, #44	; 0x2c
 8006816:	bdf0      	pop	{r4, r5, r6, r7, pc}
    OSStatTaskRdy    = OS_STATE_NOT_RDY;                    /* Statistic task is not ready                            */
    OSStatResetFlag  = DEF_FALSE;

                                                            /* ---------------- CREATE THE STAT TASK ---------------- */
    if (OSCfg_StatTaskStkBasePtr == (CPU_STK *)0) {
       *p_err = OS_ERR_STAT_STK_INVALID;
 8006818:	f646 632b 	movw	r3, #28203	; 0x6e2b
 800681c:	8003      	strh	r3, [r0, #0]
                 (OS_MSG_QTY  )0,
                 (OS_TICK     )0,
                 (void       *)0,
                 (OS_OPT      )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR),
                 (OS_ERR     *)p_err);
}
 800681e:	b00b      	add	sp, #44	; 0x2c
 8006820:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8006822:	bf00      	nop
 8006824:	080160e0 	.word	0x080160e0
 8006828:	2000e980 	.word	0x2000e980
 800682c:	2000ef44 	.word	0x2000ef44
 8006830:	2000ef30 	.word	0x2000ef30
 8006834:	2000ec7d 	.word	0x2000ec7d
 8006838:	2000ef58 	.word	0x2000ef58
 800683c:	080160d8 	.word	0x080160d8
 8006840:	080160d0 	.word	0x080160d0
 8006844:	080160e8 	.word	0x080160e8
 8006848:	080160dc 	.word	0x080160dc
 800684c:	080064b1 	.word	0x080064b1
 8006850:	08016678 	.word	0x08016678
 8006854:	2000ef60 	.word	0x2000ef60

08006858 <OSTaskChangePrio>:

#if OS_CFG_TASK_CHANGE_PRIO_EN > 0u
void  OSTaskChangePrio (OS_TCB   *p_tcb,
                        OS_PRIO   prio_new,
                        OS_ERR   *p_err)
{
 8006858:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
        return;
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* ---------- CANNOT CREATE A TASK FROM AN ISR ---------- */
 800685c:	4b30      	ldr	r3, [pc, #192]	; (8006920 <OSTaskChangePrio+0xc8>)

#if OS_CFG_TASK_CHANGE_PRIO_EN > 0u
void  OSTaskChangePrio (OS_TCB   *p_tcb,
                        OS_PRIO   prio_new,
                        OS_ERR   *p_err)
{
 800685e:	4615      	mov	r5, r2
        return;
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* ---------- CANNOT CREATE A TASK FROM AN ISR ---------- */
 8006860:	781b      	ldrb	r3, [r3, #0]
 8006862:	bb93      	cbnz	r3, 80068ca <OSTaskChangePrio+0x72>
       *p_err = OS_ERR_PRIO_INVALID;
        return;
    }
#endif

    if (prio_new >= (OS_CFG_PRIO_MAX - 1u)) {               /* Cannot set to Idle Task priority                       */
 8006864:	293d      	cmp	r1, #61	; 0x3d
 8006866:	460f      	mov	r7, r1
 8006868:	d822      	bhi.n	80068b0 <OSTaskChangePrio+0x58>
 800686a:	4606      	mov	r6, r0
        CPU_CRITICAL_ENTER();
        p_tcb = OSTCBCurPtr;
        CPU_CRITICAL_EXIT();
        self  = DEF_TRUE;
    } else {
        self  = DEF_FALSE;
 800686c:	461c      	mov	r4, r3
    if (prio_new >= (OS_CFG_PRIO_MAX - 1u)) {               /* Cannot set to Idle Task priority                       */
       *p_err = OS_ERR_PRIO_INVALID;
        return;
    }

    if (p_tcb == (OS_TCB *)0) {                             /* See if want to change priority of 'self'               */
 800686e:	2800      	cmp	r0, #0
 8006870:	d04b      	beq.n	800690a <OSTaskChangePrio+0xb2>
        self  = DEF_TRUE;
    } else {
        self  = DEF_FALSE;
    }

    OS_CRITICAL_ENTER();
 8006872:	f7fa ff7f 	bl	8001774 <CPU_SR_Save>
    switch (p_tcb->TaskState) {
 8006876:	f896 3036 	ldrb.w	r3, [r6, #54]	; 0x36
        self  = DEF_TRUE;
    } else {
        self  = DEF_FALSE;
    }

    OS_CRITICAL_ENTER();
 800687a:	4680      	mov	r8, r0
 800687c:	2b07      	cmp	r3, #7
 800687e:	d81c      	bhi.n	80068ba <OSTaskChangePrio+0x62>
 8006880:	2201      	movs	r2, #1
 8006882:	fa02 f103 	lsl.w	r1, r2, r3
 8006886:	f011 0fcc 	tst.w	r1, #204	; 0xcc
 800688a:	d12e      	bne.n	80068ea <OSTaskChangePrio+0x92>
 800688c:	f011 0f32 	tst.w	r1, #50	; 0x32
 8006890:	d120      	bne.n	80068d4 <OSTaskChangePrio+0x7c>
 8006892:	b993      	cbnz	r3, 80068ba <OSTaskChangePrio+0x62>
    switch (p_tcb->TaskState) {
        case OS_TASK_STATE_RDY:
             OS_RdyListRemove(p_tcb);                       /* Remove from current priority                           */
 8006894:	4630      	mov	r0, r6
 8006896:	f7fd fd59 	bl	800434c <OS_RdyListRemove>
             p_tcb->Prio = prio_new;                        /* Set new task priority                                  */
             OS_PrioInsert(p_tcb->Prio);
 800689a:	4638      	mov	r0, r7

    OS_CRITICAL_ENTER();
    switch (p_tcb->TaskState) {
        case OS_TASK_STATE_RDY:
             OS_RdyListRemove(p_tcb);                       /* Remove from current priority                           */
             p_tcb->Prio = prio_new;                        /* Set new task priority                                  */
 800689c:	f886 7037 	strb.w	r7, [r6, #55]	; 0x37
             OS_PrioInsert(p_tcb->Prio);
 80068a0:	f7fe ff8a 	bl	80057b8 <OS_PrioInsert>
             if (self == DEF_TRUE) {
 80068a4:	2c01      	cmp	r4, #1
                 OS_RdyListInsertHead(p_tcb);
 80068a6:	4630      	mov	r0, r6
    switch (p_tcb->TaskState) {
        case OS_TASK_STATE_RDY:
             OS_RdyListRemove(p_tcb);                       /* Remove from current priority                           */
             p_tcb->Prio = prio_new;                        /* Set new task priority                                  */
             OS_PrioInsert(p_tcb->Prio);
             if (self == DEF_TRUE) {
 80068a8:	d037      	beq.n	800691a <OSTaskChangePrio+0xc2>
                 OS_RdyListInsertHead(p_tcb);
             } else {
                 OS_RdyListInsertTail(p_tcb);
 80068aa:	f7fd fcbd 	bl	8004228 <OS_RdyListInsertTail>
 80068ae:	e013      	b.n	80068d8 <OSTaskChangePrio+0x80>
        return;
    }
#endif

    if (prio_new >= (OS_CFG_PRIO_MAX - 1u)) {               /* Cannot set to Idle Task priority                       */
       *p_err = OS_ERR_PRIO_INVALID;
 80068b0:	f246 2373 	movw	r3, #25203	; 0x6273
 80068b4:	8013      	strh	r3, [r2, #0]
        return;
 80068b6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                      break;
            }
             break;

        default:
             OS_CRITICAL_EXIT();
 80068ba:	4640      	mov	r0, r8
 80068bc:	f7fa ff5e 	bl	800177c <CPU_SR_Restore>
            *p_err = OS_ERR_STATE_INVALID;
 80068c0:	f646 632d 	movw	r3, #28205	; 0x6e2d
 80068c4:	802b      	strh	r3, [r5, #0]
             return;
 80068c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* ---------- CANNOT CREATE A TASK FROM AN ISR ---------- */
       *p_err = OS_ERR_TASK_CHANGE_PRIO_ISR;
 80068ca:	f247 1349 	movw	r3, #29001	; 0x7149
 80068ce:	8013      	strh	r3, [r2, #0]
        return;
 80068d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
             switch (p_tcb->PendOn) {                       /* What to do depends on what we are pending on           */
                 case OS_TASK_PEND_ON_TASK_Q:               /* Nothing to do except change the priority in the OS_TCB */
                 case OS_TASK_PEND_ON_TASK_SEM:
                 case OS_TASK_PEND_ON_FLAG:
                      p_tcb->Prio = prio_new;               /* Set new task priority                                  */
 80068d4:	f886 7037 	strb.w	r7, [r6, #55]	; 0x37
             OS_CRITICAL_EXIT();
            *p_err = OS_ERR_STATE_INVALID;
             return;
    }

    OS_CRITICAL_EXIT_NO_SCHED();
 80068d8:	4640      	mov	r0, r8
 80068da:	f7fa ff4f 	bl	800177c <CPU_SR_Restore>

    OSSched();                                              /* Run highest priority task ready                        */
 80068de:	f7fd f923 	bl	8003b28 <OSSched>

   *p_err = OS_ERR_NONE;
 80068e2:	2300      	movs	r3, #0
 80068e4:	802b      	strh	r3, [r5, #0]
 80068e6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

        case OS_TASK_STATE_PEND:
        case OS_TASK_STATE_PEND_TIMEOUT:
        case OS_TASK_STATE_PEND_SUSPENDED:
        case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
             switch (p_tcb->PendOn) {                       /* What to do depends on what we are pending on           */
 80068ea:	f896 3034 	ldrb.w	r3, [r6, #52]	; 0x34
 80068ee:	2b07      	cmp	r3, #7
 80068f0:	d8f2      	bhi.n	80068d8 <OSTaskChangePrio+0x80>
 80068f2:	409a      	lsls	r2, r3
 80068f4:	f012 0f86 	tst.w	r2, #134	; 0x86
 80068f8:	d1ec      	bne.n	80068d4 <OSTaskChangePrio+0x7c>
 80068fa:	f012 0f78 	tst.w	r2, #120	; 0x78
 80068fe:	d0eb      	beq.n	80068d8 <OSTaskChangePrio+0x80>

                 case OS_TASK_PEND_ON_MUTEX:
                 case OS_TASK_PEND_ON_MULTI:
                 case OS_TASK_PEND_ON_Q:
                 case OS_TASK_PEND_ON_SEM:
                      OS_PendListChangePrio(p_tcb,
 8006900:	4639      	mov	r1, r7
 8006902:	4630      	mov	r0, r6
 8006904:	f7fd fb70 	bl	8003fe8 <OS_PendListChangePrio>
                                            prio_new);
                      break;
 8006908:	e7e6      	b.n	80068d8 <OSTaskChangePrio+0x80>
       *p_err = OS_ERR_PRIO_INVALID;
        return;
    }

    if (p_tcb == (OS_TCB *)0) {                             /* See if want to change priority of 'self'               */
        CPU_CRITICAL_ENTER();
 800690a:	f7fa ff33 	bl	8001774 <CPU_SR_Save>
        p_tcb = OSTCBCurPtr;
 800690e:	4b05      	ldr	r3, [pc, #20]	; (8006924 <OSTaskChangePrio+0xcc>)
        CPU_CRITICAL_EXIT();
        self  = DEF_TRUE;
 8006910:	2401      	movs	r4, #1
        return;
    }

    if (p_tcb == (OS_TCB *)0) {                             /* See if want to change priority of 'self'               */
        CPU_CRITICAL_ENTER();
        p_tcb = OSTCBCurPtr;
 8006912:	681e      	ldr	r6, [r3, #0]
        CPU_CRITICAL_EXIT();
 8006914:	f7fa ff32 	bl	800177c <CPU_SR_Restore>
 8006918:	e7ab      	b.n	8006872 <OSTaskChangePrio+0x1a>
        case OS_TASK_STATE_RDY:
             OS_RdyListRemove(p_tcb);                       /* Remove from current priority                           */
             p_tcb->Prio = prio_new;                        /* Set new task priority                                  */
             OS_PrioInsert(p_tcb->Prio);
             if (self == DEF_TRUE) {
                 OS_RdyListInsertHead(p_tcb);
 800691a:	f7fd fc67 	bl	80041ec <OS_RdyListInsertHead>
 800691e:	e7db      	b.n	80068d8 <OSTaskChangePrio+0x80>
 8006920:	2000ed84 	.word	0x2000ed84
 8006924:	2000ed58 	.word	0x2000ed58

08006928 <OSTaskQFlush>:
*/

#if OS_CFG_TASK_Q_EN > 0u
OS_MSG_QTY  OSTaskQFlush (OS_TCB  *p_tcb,
                          OS_ERR  *p_err)
{
 8006928:	b570      	push	{r4, r5, r6, lr}
        return ((OS_MSG_QTY)0);
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't flush a message queue from an ISR                */
 800692a:	4b10      	ldr	r3, [pc, #64]	; (800696c <OSTaskQFlush+0x44>)
*/

#if OS_CFG_TASK_Q_EN > 0u
OS_MSG_QTY  OSTaskQFlush (OS_TCB  *p_tcb,
                          OS_ERR  *p_err)
{
 800692c:	460d      	mov	r5, r1
        return ((OS_MSG_QTY)0);
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't flush a message queue from an ISR                */
 800692e:	781b      	ldrb	r3, [r3, #0]
 8006930:	b983      	cbnz	r3, 8006954 <OSTaskQFlush+0x2c>
 8006932:	4604      	mov	r4, r0
       *p_err = OS_ERR_FLUSH_ISR;
        return ((OS_MSG_QTY)0);
    }
#endif

    if (p_tcb == (OS_TCB *)0) {                             /* Flush message queue of calling task?                   */
 8006934:	b198      	cbz	r0, 800695e <OSTaskQFlush+0x36>
        CPU_CRITICAL_ENTER();
        p_tcb = OSTCBCurPtr;
        CPU_CRITICAL_EXIT();
    }

    OS_CRITICAL_ENTER();
 8006936:	f7fa ff1d 	bl	8001774 <CPU_SR_Save>
 800693a:	4606      	mov	r6, r0
    entries = OS_MsgQFreeAll(&p_tcb->MsgQ);                 /* Return all OS_MSGs to the OS_MSG pool                  */
 800693c:	f104 0064 	add.w	r0, r4, #100	; 0x64
 8006940:	f7fe fc52 	bl	80051e8 <OS_MsgQFreeAll>
 8006944:	4604      	mov	r4, r0
    OS_CRITICAL_EXIT();
 8006946:	4630      	mov	r0, r6
 8006948:	f7fa ff18 	bl	800177c <CPU_SR_Restore>
   *p_err   = OS_ERR_NONE;
 800694c:	2300      	movs	r3, #0
    return (entries);
 800694e:	4620      	mov	r0, r4
    }

    OS_CRITICAL_ENTER();
    entries = OS_MsgQFreeAll(&p_tcb->MsgQ);                 /* Return all OS_MSGs to the OS_MSG pool                  */
    OS_CRITICAL_EXIT();
   *p_err   = OS_ERR_NONE;
 8006950:	802b      	strh	r3, [r5, #0]
    return (entries);
}
 8006952:	bd70      	pop	{r4, r5, r6, pc}
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't flush a message queue from an ISR                */
       *p_err = OS_ERR_FLUSH_ISR;
 8006954:	f44f 536c 	mov.w	r3, #15104	; 0x3b00
 8006958:	800b      	strh	r3, [r1, #0]
        return ((OS_MSG_QTY)0);
 800695a:	2000      	movs	r0, #0
 800695c:	bd70      	pop	{r4, r5, r6, pc}
    }
#endif

    if (p_tcb == (OS_TCB *)0) {                             /* Flush message queue of calling task?                   */
        CPU_CRITICAL_ENTER();
 800695e:	f7fa ff09 	bl	8001774 <CPU_SR_Save>
        p_tcb = OSTCBCurPtr;
 8006962:	4b03      	ldr	r3, [pc, #12]	; (8006970 <OSTaskQFlush+0x48>)
 8006964:	681c      	ldr	r4, [r3, #0]
        CPU_CRITICAL_EXIT();
 8006966:	f7fa ff09 	bl	800177c <CPU_SR_Restore>
 800696a:	e7e4      	b.n	8006936 <OSTaskQFlush+0xe>
 800696c:	2000ed84 	.word	0x2000ed84
 8006970:	2000ed58 	.word	0x2000ed58

08006974 <OSTaskQPend>:
void  *OSTaskQPend (OS_TICK       timeout,
                    OS_OPT        opt,
                    OS_MSG_SIZE  *p_msg_size,
                    CPU_TS       *p_ts,
                    OS_ERR       *p_err)
{
 8006974:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
        return ((void *)0);
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't Pend from an ISR                                 */
 8006978:	4c63      	ldr	r4, [pc, #396]	; (8006b08 <OSTaskQPend+0x194>)
void  *OSTaskQPend (OS_TICK       timeout,
                    OS_OPT        opt,
                    OS_MSG_SIZE  *p_msg_size,
                    CPU_TS       *p_ts,
                    OS_ERR       *p_err)
{
 800697a:	9f0a      	ldr	r7, [sp, #40]	; 0x28
        return ((void *)0);
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't Pend from an ISR                                 */
 800697c:	7824      	ldrb	r4, [r4, #0]
 800697e:	2c00      	cmp	r4, #0
 8006980:	f040 80a3 	bne.w	8006aca <OSTaskQPend+0x156>
        return ((void *)0);
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u                                  /* ---------------- VALIDATE ARGUMENTS ------------------ */
    if (p_msg_size == (OS_MSG_SIZE *)0) {                   /* User must supply a valid destination for msg size      */
 8006984:	2a00      	cmp	r2, #0
 8006986:	f000 80af 	beq.w	8006ae8 <OSTaskQPend+0x174>
       *p_err = OS_ERR_PTR_INVALID;
        return ((void *)0);
    }
    switch (opt) {                                          /* User must supply a valid option                        */
 800698a:	b111      	cbz	r1, 8006992 <OSTaskQPend+0x1e>
 800698c:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 8006990:	d168      	bne.n	8006a64 <OSTaskQPend+0xf0>
 8006992:	461d      	mov	r5, r3
 8006994:	4691      	mov	r9, r2
 8006996:	460e      	mov	r6, r1
 8006998:	4680      	mov	r8, r0
            *p_err = OS_ERR_OPT_INVALID;
             return ((void *)0);
    }
#endif

    if (p_ts != (CPU_TS *)0) {
 800699a:	2b00      	cmp	r3, #0
 800699c:	d068      	beq.n	8006a70 <OSTaskQPend+0xfc>
       *p_ts  = (CPU_TS  )0;                                /* Initialize the returned timestamp                      */
 800699e:	2300      	movs	r3, #0
 80069a0:	602b      	str	r3, [r5, #0]
    }

    CPU_CRITICAL_ENTER();
 80069a2:	f7fa fee7 	bl	8001774 <CPU_SR_Save>
    p_msg_q = &OSTCBCurPtr->MsgQ;                           /* Any message waiting in the message queue?              */
 80069a6:	f8df a168 	ldr.w	sl, [pc, #360]	; 8006b10 <OSTaskQPend+0x19c>

    if (p_ts != (CPU_TS *)0) {
       *p_ts  = (CPU_TS  )0;                                /* Initialize the returned timestamp                      */
    }

    CPU_CRITICAL_ENTER();
 80069aa:	4683      	mov	fp, r0
    p_msg_q = &OSTCBCurPtr->MsgQ;                           /* Any message waiting in the message queue?              */
 80069ac:	f8da 0000 	ldr.w	r0, [sl]
    p_void  = OS_MsgQGet(p_msg_q,
 80069b0:	463b      	mov	r3, r7
 80069b2:	3064      	adds	r0, #100	; 0x64
 80069b4:	462a      	mov	r2, r5
 80069b6:	4649      	mov	r1, r9
 80069b8:	f7fe fc38 	bl	800522c <OS_MsgQGet>
                         p_msg_size,
                         p_ts,
                         p_err);
    if (*p_err == OS_ERR_NONE) {
 80069bc:	883b      	ldrh	r3, [r7, #0]
       *p_ts  = (CPU_TS  )0;                                /* Initialize the returned timestamp                      */
    }

    CPU_CRITICAL_ENTER();
    p_msg_q = &OSTCBCurPtr->MsgQ;                           /* Any message waiting in the message queue?              */
    p_void  = OS_MsgQGet(p_msg_q,
 80069be:	4604      	mov	r4, r0
                         p_msg_size,
                         p_ts,
                         p_err);
    if (*p_err == OS_ERR_NONE) {
 80069c0:	b373      	cbz	r3, 8006a20 <OSTaskQPend+0xac>
#endif
        CPU_CRITICAL_EXIT();
        return (p_void);                                    /* Yes, Return oldest message received                    */
    }

    if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {    /* Caller wants to block if not available?                */
 80069c2:	0433      	lsls	r3, r6, #16
 80069c4:	f100 8096 	bmi.w	8006af4 <OSTaskQPend+0x180>
       *p_err = OS_ERR_PEND_WOULD_BLOCK;                    /* No                                                     */
        CPU_CRITICAL_EXIT();
        return ((void *)0);
    } else {                                                /* Yes                                                    */
        if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /*     Can't block when the scheduler is locked           */
 80069c8:	4b50      	ldr	r3, [pc, #320]	; (8006b0c <OSTaskQPend+0x198>)
 80069ca:	781c      	ldrb	r4, [r3, #0]
 80069cc:	2c00      	cmp	r4, #0
 80069ce:	f040 8082 	bne.w	8006ad6 <OSTaskQPend+0x162>
            return ((void *)0);
        }
    }
                                                            /* Lock the scheduler/re-enable interrupts                */
    OS_CRITICAL_ENTER_CPU_EXIT();
    OS_Pend((OS_PEND_DATA *)0,                              /* Block task pending on Message                          */
 80069d2:	4643      	mov	r3, r8
 80069d4:	2202      	movs	r2, #2
 80069d6:	4621      	mov	r1, r4
 80069d8:	4620      	mov	r0, r4
 80069da:	f7fd fd55 	bl	8004488 <OS_Pend>
            (OS_PEND_OBJ  *)0,
            (OS_STATE      )OS_TASK_PEND_ON_TASK_Q,
            (OS_TICK       )timeout);
    OS_CRITICAL_EXIT_NO_SCHED();
 80069de:	4658      	mov	r0, fp
 80069e0:	f7fa fecc 	bl	800177c <CPU_SR_Restore>

    OSSched();                                              /* Find the next highest priority task ready to run       */
 80069e4:	f7fd f8a0 	bl	8003b28 <OSSched>

    CPU_CRITICAL_ENTER();
 80069e8:	f7fa fec4 	bl	8001774 <CPU_SR_Save>
    switch (OSTCBCurPtr->PendStatus) {
 80069ec:	f8da 3000 	ldr.w	r3, [sl]
            (OS_TICK       )timeout);
    OS_CRITICAL_EXIT_NO_SCHED();

    OSSched();                                              /* Find the next highest priority task ready to run       */

    CPU_CRITICAL_ENTER();
 80069f0:	4606      	mov	r6, r0
    switch (OSTCBCurPtr->PendStatus) {
 80069f2:	f893 2035 	ldrb.w	r2, [r3, #53]	; 0x35
 80069f6:	f8df 8118 	ldr.w	r8, [pc, #280]	; 8006b10 <OSTaskQPend+0x19c>
 80069fa:	2a00      	cmp	r2, #0
 80069fc:	d04a      	beq.n	8006a94 <OSTaskQPend+0x120>
 80069fe:	2a01      	cmp	r2, #1
 8006a00:	d022      	beq.n	8006a48 <OSTaskQPend+0xd4>
             break;

        case OS_STATUS_PEND_TIMEOUT:                        /* Indicate that we didn't get event within TO            */
        default:
             p_void     = (void      *)0;
            *p_msg_size = (OS_MSG_SIZE)0;
 8006a02:	f8a9 4000 	strh.w	r4, [r9]
             if (p_ts  != (CPU_TS *)0) {
 8006a06:	b10d      	cbz	r5, 8006a0c <OSTaskQPend+0x98>
                *p_ts   =  OSTCBCurPtr->TS;
 8006a08:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8006a0a:	602b      	str	r3, [r5, #0]
             }
            *p_err      =  OS_ERR_TIMEOUT;
 8006a0c:	f247 23d9 	movw	r3, #29401	; 0x72d9
             break;
    }
    CPU_CRITICAL_EXIT();
 8006a10:	4630      	mov	r0, r6
            *p_err      =  OS_ERR_PEND_ABORT;
             break;

        case OS_STATUS_PEND_TIMEOUT:                        /* Indicate that we didn't get event within TO            */
        default:
             p_void     = (void      *)0;
 8006a12:	2400      	movs	r4, #0
            *p_msg_size = (OS_MSG_SIZE)0;
             if (p_ts  != (CPU_TS *)0) {
                *p_ts   =  OSTCBCurPtr->TS;
             }
            *p_err      =  OS_ERR_TIMEOUT;
 8006a14:	803b      	strh	r3, [r7, #0]
             break;
    }
    CPU_CRITICAL_EXIT();
 8006a16:	f7fa feb1 	bl	800177c <CPU_SR_Restore>
    return (p_void);                                        /* Return received message                                */
 8006a1a:	4620      	mov	r0, r4
 8006a1c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
                         p_ts,
                         p_err);
    if (*p_err == OS_ERR_NONE) {
#if OS_CFG_TASK_PROFILE_EN > 0u
        if (p_ts != (CPU_TS *)0) {
            OSTCBCurPtr->MsgQPendTime = OS_TS_GET() - *p_ts;
 8006a20:	f8da 6000 	ldr.w	r6, [sl]
 8006a24:	f7fa f8b2 	bl	8000b8c <CPU_TS_TmrRd>
 8006a28:	682b      	ldr	r3, [r5, #0]
            if (OSTCBCurPtr->MsgQPendTimeMax < OSTCBCurPtr->MsgQPendTime) {
 8006a2a:	f8da 2000 	ldr.w	r2, [sl]
                         p_ts,
                         p_err);
    if (*p_err == OS_ERR_NONE) {
#if OS_CFG_TASK_PROFILE_EN > 0u
        if (p_ts != (CPU_TS *)0) {
            OSTCBCurPtr->MsgQPendTime = OS_TS_GET() - *p_ts;
 8006a2e:	1ac0      	subs	r0, r0, r3
 8006a30:	6770      	str	r0, [r6, #116]	; 0x74
            if (OSTCBCurPtr->MsgQPendTimeMax < OSTCBCurPtr->MsgQPendTime) {
 8006a32:	6f53      	ldr	r3, [r2, #116]	; 0x74
 8006a34:	6f91      	ldr	r1, [r2, #120]	; 0x78
 8006a36:	4299      	cmp	r1, r3
                OSTCBCurPtr->MsgQPendTimeMax = OSTCBCurPtr->MsgQPendTime;
 8006a38:	bf38      	it	cc
 8006a3a:	6793      	strcc	r3, [r2, #120]	; 0x78
            }
        }
#endif
        CPU_CRITICAL_EXIT();
 8006a3c:	4658      	mov	r0, fp
 8006a3e:	f7fa fe9d 	bl	800177c <CPU_SR_Restore>
        return (p_void);                                    /* Yes, Return oldest message received                    */
 8006a42:	4620      	mov	r0, r4
 8006a44:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
            *p_err = OS_ERR_NONE;
             break;

        case OS_STATUS_PEND_ABORT:                          /* Indicate that we aborted                               */
             p_void     = (void      *)0;
            *p_msg_size = (OS_MSG_SIZE)0;
 8006a48:	f8a9 4000 	strh.w	r4, [r9]
             if (p_ts  != (CPU_TS *)0) {
 8006a4c:	b105      	cbz	r5, 8006a50 <OSTaskQPend+0xdc>
                *p_ts   = (CPU_TS  )0;
 8006a4e:	602c      	str	r4, [r5, #0]
             }
            *p_err      =  OS_ERR_PEND_ABORT;
 8006a50:	f246 13a9 	movw	r3, #25001	; 0x61a9
                *p_ts   =  OSTCBCurPtr->TS;
             }
            *p_err      =  OS_ERR_TIMEOUT;
             break;
    }
    CPU_CRITICAL_EXIT();
 8006a54:	4630      	mov	r0, r6
             }
            *p_err = OS_ERR_NONE;
             break;

        case OS_STATUS_PEND_ABORT:                          /* Indicate that we aborted                               */
             p_void     = (void      *)0;
 8006a56:	2400      	movs	r4, #0
            *p_msg_size = (OS_MSG_SIZE)0;
             if (p_ts  != (CPU_TS *)0) {
                *p_ts   = (CPU_TS  )0;
             }
            *p_err      =  OS_ERR_PEND_ABORT;
 8006a58:	803b      	strh	r3, [r7, #0]
                *p_ts   =  OSTCBCurPtr->TS;
             }
            *p_err      =  OS_ERR_TIMEOUT;
             break;
    }
    CPU_CRITICAL_EXIT();
 8006a5a:	f7fa fe8f 	bl	800177c <CPU_SR_Restore>
    return (p_void);                                        /* Return received message                                */
 8006a5e:	4620      	mov	r0, r4
 8006a60:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        case OS_OPT_PEND_BLOCKING:
        case OS_OPT_PEND_NON_BLOCKING:
             break;

        default:
            *p_err = OS_ERR_OPT_INVALID;
 8006a64:	f645 6325 	movw	r3, #24101	; 0x5e25
             return ((void *)0);
 8006a68:	4620      	mov	r0, r4
        case OS_OPT_PEND_BLOCKING:
        case OS_OPT_PEND_NON_BLOCKING:
             break;

        default:
            *p_err = OS_ERR_OPT_INVALID;
 8006a6a:	803b      	strh	r3, [r7, #0]
             return ((void *)0);
 8006a6c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

    if (p_ts != (CPU_TS *)0) {
       *p_ts  = (CPU_TS  )0;                                /* Initialize the returned timestamp                      */
    }

    CPU_CRITICAL_ENTER();
 8006a70:	f7fa fe80 	bl	8001774 <CPU_SR_Save>
    p_msg_q = &OSTCBCurPtr->MsgQ;                           /* Any message waiting in the message queue?              */
 8006a74:	f8df a098 	ldr.w	sl, [pc, #152]	; 8006b10 <OSTaskQPend+0x19c>

    if (p_ts != (CPU_TS *)0) {
       *p_ts  = (CPU_TS  )0;                                /* Initialize the returned timestamp                      */
    }

    CPU_CRITICAL_ENTER();
 8006a78:	4683      	mov	fp, r0
    p_msg_q = &OSTCBCurPtr->MsgQ;                           /* Any message waiting in the message queue?              */
 8006a7a:	f8da 0000 	ldr.w	r0, [sl]
    p_void  = OS_MsgQGet(p_msg_q,
 8006a7e:	463b      	mov	r3, r7
 8006a80:	3064      	adds	r0, #100	; 0x64
 8006a82:	462a      	mov	r2, r5
 8006a84:	4649      	mov	r1, r9
 8006a86:	f7fe fbd1 	bl	800522c <OS_MsgQGet>
                         p_msg_size,
                         p_ts,
                         p_err);
    if (*p_err == OS_ERR_NONE) {
 8006a8a:	883b      	ldrh	r3, [r7, #0]
       *p_ts  = (CPU_TS  )0;                                /* Initialize the returned timestamp                      */
    }

    CPU_CRITICAL_ENTER();
    p_msg_q = &OSTCBCurPtr->MsgQ;                           /* Any message waiting in the message queue?              */
    p_void  = OS_MsgQGet(p_msg_q,
 8006a8c:	4604      	mov	r4, r0
                         p_msg_size,
                         p_ts,
                         p_err);
    if (*p_err == OS_ERR_NONE) {
 8006a8e:	2b00      	cmp	r3, #0
 8006a90:	d0d4      	beq.n	8006a3c <OSTaskQPend+0xc8>
 8006a92:	e796      	b.n	80069c2 <OSTaskQPend+0x4e>

    CPU_CRITICAL_ENTER();
    switch (OSTCBCurPtr->PendStatus) {
        case OS_STATUS_PEND_OK:                             /* Extract message from TCB (Put there by Post)           */
             p_void      = OSTCBCurPtr->MsgPtr;
            *p_msg_size  = OSTCBCurPtr->MsgSize;
 8006a94:	f8b3 2060 	ldrh.w	r2, [r3, #96]	; 0x60
    OSSched();                                              /* Find the next highest priority task ready to run       */

    CPU_CRITICAL_ENTER();
    switch (OSTCBCurPtr->PendStatus) {
        case OS_STATUS_PEND_OK:                             /* Extract message from TCB (Put there by Post)           */
             p_void      = OSTCBCurPtr->MsgPtr;
 8006a98:	6ddc      	ldr	r4, [r3, #92]	; 0x5c
            *p_msg_size  = OSTCBCurPtr->MsgSize;
 8006a9a:	f8a9 2000 	strh.w	r2, [r9]
             if (p_ts != (CPU_TS *)0) {
 8006a9e:	b165      	cbz	r5, 8006aba <OSTaskQPend+0x146>
                *p_ts  = OSTCBCurPtr->TS;
 8006aa0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8006aa2:	602b      	str	r3, [r5, #0]
#if OS_CFG_TASK_PROFILE_EN > 0u
                OSTCBCurPtr->MsgQPendTime = OS_TS_GET() - OSTCBCurPtr->TS;
 8006aa4:	f7fa f872 	bl	8000b8c <CPU_TS_TmrRd>
 8006aa8:	f8d8 2000 	ldr.w	r2, [r8]
 8006aac:	6c13      	ldr	r3, [r2, #64]	; 0x40
                if (OSTCBCurPtr->MsgQPendTimeMax < OSTCBCurPtr->MsgQPendTime) {
 8006aae:	6f91      	ldr	r1, [r2, #120]	; 0x78
             p_void      = OSTCBCurPtr->MsgPtr;
            *p_msg_size  = OSTCBCurPtr->MsgSize;
             if (p_ts != (CPU_TS *)0) {
                *p_ts  = OSTCBCurPtr->TS;
#if OS_CFG_TASK_PROFILE_EN > 0u
                OSTCBCurPtr->MsgQPendTime = OS_TS_GET() - OSTCBCurPtr->TS;
 8006ab0:	1ac0      	subs	r0, r0, r3
                if (OSTCBCurPtr->MsgQPendTimeMax < OSTCBCurPtr->MsgQPendTime) {
 8006ab2:	4288      	cmp	r0, r1
             p_void      = OSTCBCurPtr->MsgPtr;
            *p_msg_size  = OSTCBCurPtr->MsgSize;
             if (p_ts != (CPU_TS *)0) {
                *p_ts  = OSTCBCurPtr->TS;
#if OS_CFG_TASK_PROFILE_EN > 0u
                OSTCBCurPtr->MsgQPendTime = OS_TS_GET() - OSTCBCurPtr->TS;
 8006ab4:	6750      	str	r0, [r2, #116]	; 0x74
                if (OSTCBCurPtr->MsgQPendTimeMax < OSTCBCurPtr->MsgQPendTime) {
                    OSTCBCurPtr->MsgQPendTimeMax = OSTCBCurPtr->MsgQPendTime;
 8006ab6:	bf88      	it	hi
 8006ab8:	6790      	strhi	r0, [r2, #120]	; 0x78
                }
#endif
             }
            *p_err = OS_ERR_NONE;
 8006aba:	2300      	movs	r3, #0
                *p_ts   =  OSTCBCurPtr->TS;
             }
            *p_err      =  OS_ERR_TIMEOUT;
             break;
    }
    CPU_CRITICAL_EXIT();
 8006abc:	4630      	mov	r0, r6
                if (OSTCBCurPtr->MsgQPendTimeMax < OSTCBCurPtr->MsgQPendTime) {
                    OSTCBCurPtr->MsgQPendTimeMax = OSTCBCurPtr->MsgQPendTime;
                }
#endif
             }
            *p_err = OS_ERR_NONE;
 8006abe:	803b      	strh	r3, [r7, #0]
                *p_ts   =  OSTCBCurPtr->TS;
             }
            *p_err      =  OS_ERR_TIMEOUT;
             break;
    }
    CPU_CRITICAL_EXIT();
 8006ac0:	f7fa fe5c 	bl	800177c <CPU_SR_Restore>
    return (p_void);                                        /* Return received message                                */
 8006ac4:	4620      	mov	r0, r4
 8006ac6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't Pend from an ISR                                 */
       *p_err = OS_ERR_PEND_ISR;
 8006aca:	f246 13ae 	movw	r3, #25006	; 0x61ae
        return ((void *)0);
 8006ace:	2000      	movs	r0, #0
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't Pend from an ISR                                 */
       *p_err = OS_ERR_PEND_ISR;
 8006ad0:	803b      	strh	r3, [r7, #0]
        return ((void *)0);
 8006ad2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
       *p_err = OS_ERR_PEND_WOULD_BLOCK;                    /* No                                                     */
        CPU_CRITICAL_EXIT();
        return ((void *)0);
    } else {                                                /* Yes                                                    */
        if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /*     Can't block when the scheduler is locked           */
            CPU_CRITICAL_EXIT();
 8006ad6:	4658      	mov	r0, fp
 8006ad8:	f7fa fe50 	bl	800177c <CPU_SR_Restore>
           *p_err = OS_ERR_SCHED_LOCKED;
 8006adc:	f646 5363 	movw	r3, #28003	; 0x6d63
            return ((void *)0);
 8006ae0:	2000      	movs	r0, #0
        CPU_CRITICAL_EXIT();
        return ((void *)0);
    } else {                                                /* Yes                                                    */
        if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /*     Can't block when the scheduler is locked           */
            CPU_CRITICAL_EXIT();
           *p_err = OS_ERR_SCHED_LOCKED;
 8006ae2:	803b      	strh	r3, [r7, #0]
            return ((void *)0);
 8006ae4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u                                  /* ---------------- VALIDATE ARGUMENTS ------------------ */
    if (p_msg_size == (OS_MSG_SIZE *)0) {                   /* User must supply a valid destination for msg size      */
       *p_err = OS_ERR_PTR_INVALID;
 8006ae8:	f246 23d5 	movw	r3, #25301	; 0x62d5
        return ((void *)0);
 8006aec:	4610      	mov	r0, r2
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u                                  /* ---------------- VALIDATE ARGUMENTS ------------------ */
    if (p_msg_size == (OS_MSG_SIZE *)0) {                   /* User must supply a valid destination for msg size      */
       *p_err = OS_ERR_PTR_INVALID;
 8006aee:	803b      	strh	r3, [r7, #0]
        return ((void *)0);
 8006af0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        CPU_CRITICAL_EXIT();
        return (p_void);                                    /* Yes, Return oldest message received                    */
    }

    if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {    /* Caller wants to block if not available?                */
       *p_err = OS_ERR_PEND_WOULD_BLOCK;                    /* No                                                     */
 8006af4:	f246 13b0 	movw	r3, #25008	; 0x61b0
        CPU_CRITICAL_EXIT();
 8006af8:	4658      	mov	r0, fp
        CPU_CRITICAL_EXIT();
        return (p_void);                                    /* Yes, Return oldest message received                    */
    }

    if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {    /* Caller wants to block if not available?                */
       *p_err = OS_ERR_PEND_WOULD_BLOCK;                    /* No                                                     */
 8006afa:	803b      	strh	r3, [r7, #0]
        CPU_CRITICAL_EXIT();
 8006afc:	f7fa fe3e 	bl	800177c <CPU_SR_Restore>
        return ((void *)0);
 8006b00:	2000      	movs	r0, #0
 8006b02:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8006b06:	bf00      	nop
 8006b08:	2000ed84 	.word	0x2000ed84
 8006b0c:	2000e974 	.word	0x2000e974
 8006b10:	2000ed58 	.word	0x2000ed58

08006b14 <OSTaskRegGet>:

#if OS_CFG_TASK_REG_TBL_SIZE > 0u
OS_REG  OSTaskRegGet (OS_TCB     *p_tcb,
                      OS_REG_ID   id,
                      OS_ERR     *p_err)
{
 8006b14:	b538      	push	{r3, r4, r5, lr}
 8006b16:	4615      	mov	r5, r2
        return ((OS_REG)0);
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (id >= OS_CFG_TASK_REG_TBL_SIZE) {
 8006b18:	b121      	cbz	r1, 8006b24 <OSTaskRegGet+0x10>
       *p_err = OS_ERR_REG_ID_INVALID;
 8006b1a:	f646 1379 	movw	r3, #27001	; 0x6979
        return ((OS_REG)0);
 8006b1e:	2000      	movs	r0, #0
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (id >= OS_CFG_TASK_REG_TBL_SIZE) {
       *p_err = OS_ERR_REG_ID_INVALID;
 8006b20:	8013      	strh	r3, [r2, #0]
        return ((OS_REG)0);
 8006b22:	bd38      	pop	{r3, r4, r5, pc}
 8006b24:	4604      	mov	r4, r0
    }
#endif

    CPU_CRITICAL_ENTER();
 8006b26:	f7fa fe25 	bl	8001774 <CPU_SR_Save>
    if (p_tcb == (OS_TCB *)0) {
 8006b2a:	b134      	cbz	r4, 8006b3a <OSTaskRegGet+0x26>
        p_tcb = OSTCBCurPtr;
    }
    value = p_tcb->RegTbl[id];
 8006b2c:	6fe4      	ldr	r4, [r4, #124]	; 0x7c
    CPU_CRITICAL_EXIT();
 8006b2e:	f7fa fe25 	bl	800177c <CPU_SR_Restore>
   *p_err = OS_ERR_NONE;
 8006b32:	2300      	movs	r3, #0
    return ((OS_REG)value);
 8006b34:	4620      	mov	r0, r4
    if (p_tcb == (OS_TCB *)0) {
        p_tcb = OSTCBCurPtr;
    }
    value = p_tcb->RegTbl[id];
    CPU_CRITICAL_EXIT();
   *p_err = OS_ERR_NONE;
 8006b36:	802b      	strh	r3, [r5, #0]
    return ((OS_REG)value);
}
 8006b38:	bd38      	pop	{r3, r4, r5, pc}
    }
#endif

    CPU_CRITICAL_ENTER();
    if (p_tcb == (OS_TCB *)0) {
        p_tcb = OSTCBCurPtr;
 8006b3a:	4b01      	ldr	r3, [pc, #4]	; (8006b40 <OSTaskRegGet+0x2c>)
 8006b3c:	681c      	ldr	r4, [r3, #0]
 8006b3e:	e7f5      	b.n	8006b2c <OSTaskRegGet+0x18>
 8006b40:	2000ed58 	.word	0x2000ed58

08006b44 <OSTaskRegGetID>:
************************************************************************************************************************
*/

#if OS_CFG_TASK_REG_TBL_SIZE > 0u
OS_REG_ID  OSTaskRegGetID (OS_ERR  *p_err)
{
 8006b44:	b538      	push	{r3, r4, r5, lr}
 8006b46:	4605      	mov	r5, r0
        OS_SAFETY_CRITICAL_EXCEPTION();
        return ((OS_REG_ID)OS_CFG_TASK_REG_TBL_SIZE);
    }
#endif

    CPU_CRITICAL_ENTER();
 8006b48:	f7fa fe14 	bl	8001774 <CPU_SR_Save>
    if (OSTaskRegNextAvailID >= OS_CFG_TASK_REG_TBL_SIZE) {       /* See if we exceeded the number of IDs available   */
 8006b4c:	4b08      	ldr	r3, [pc, #32]	; (8006b70 <OSTaskRegGetID+0x2c>)
 8006b4e:	781c      	ldrb	r4, [r3, #0]
 8006b50:	b934      	cbnz	r4, 8006b60 <OSTaskRegGetID+0x1c>
        CPU_CRITICAL_EXIT();
        return ((OS_REG_ID)OS_CFG_TASK_REG_TBL_SIZE);
    }
     
    id    = OSTaskRegNextAvailID;								  /* Assign the next available ID                     */
    OSTaskRegNextAvailID++;										  /* Increment available ID for next request          */
 8006b52:	2201      	movs	r2, #1
 8006b54:	701a      	strb	r2, [r3, #0]
    CPU_CRITICAL_EXIT();
 8006b56:	f7fa fe11 	bl	800177c <CPU_SR_Restore>
   *p_err = OS_ERR_NONE;
 8006b5a:	802c      	strh	r4, [r5, #0]
    return (id);
}
 8006b5c:	4620      	mov	r0, r4
 8006b5e:	bd38      	pop	{r3, r4, r5, pc}
    }
#endif

    CPU_CRITICAL_ENTER();
    if (OSTaskRegNextAvailID >= OS_CFG_TASK_REG_TBL_SIZE) {       /* See if we exceeded the number of IDs available   */
       *p_err = OS_ERR_NO_MORE_ID_AVAIL;                          /* Yes, cannot allocate more task register IDs      */
 8006b60:	f645 13da 	movw	r3, #23002	; 0x59da
        CPU_CRITICAL_EXIT();
        return ((OS_REG_ID)OS_CFG_TASK_REG_TBL_SIZE);
 8006b64:	2401      	movs	r4, #1
    }
#endif

    CPU_CRITICAL_ENTER();
    if (OSTaskRegNextAvailID >= OS_CFG_TASK_REG_TBL_SIZE) {       /* See if we exceeded the number of IDs available   */
       *p_err = OS_ERR_NO_MORE_ID_AVAIL;                          /* Yes, cannot allocate more task register IDs      */
 8006b66:	802b      	strh	r3, [r5, #0]
        CPU_CRITICAL_EXIT();
 8006b68:	f7fa fe08 	bl	800177c <CPU_SR_Restore>
    id    = OSTaskRegNextAvailID;								  /* Assign the next available ID                     */
    OSTaskRegNextAvailID++;										  /* Increment available ID for next request          */
    CPU_CRITICAL_EXIT();
   *p_err = OS_ERR_NONE;
    return (id);
}
 8006b6c:	4620      	mov	r0, r4
 8006b6e:	bd38      	pop	{r3, r4, r5, pc}
 8006b70:	2000e984 	.word	0x2000e984

08006b74 <OSTaskRegSet>:
#if OS_CFG_TASK_REG_TBL_SIZE > 0u
void  OSTaskRegSet (OS_TCB     *p_tcb,
                    OS_REG_ID   id,
                    OS_REG      value,
                    OS_ERR     *p_err)
{
 8006b74:	b570      	push	{r4, r5, r6, lr}
 8006b76:	461c      	mov	r4, r3
        return;
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (id >= OS_CFG_TASK_REG_TBL_SIZE) {
 8006b78:	b119      	cbz	r1, 8006b82 <OSTaskRegSet+0xe>
       *p_err = OS_ERR_REG_ID_INVALID;
 8006b7a:	f646 1379 	movw	r3, #27001	; 0x6979
 8006b7e:	8023      	strh	r3, [r4, #0]
        return;
 8006b80:	bd70      	pop	{r4, r5, r6, pc}
 8006b82:	4605      	mov	r5, r0
 8006b84:	4616      	mov	r6, r2
    }
#endif

    CPU_CRITICAL_ENTER();
 8006b86:	f7fa fdf5 	bl	8001774 <CPU_SR_Save>
    if (p_tcb == (OS_TCB *)0) {
 8006b8a:	b12d      	cbz	r5, 8006b98 <OSTaskRegSet+0x24>
        p_tcb = OSTCBCurPtr;
    }
    p_tcb->RegTbl[id] = value;
 8006b8c:	67ee      	str	r6, [r5, #124]	; 0x7c
    CPU_CRITICAL_EXIT();
 8006b8e:	f7fa fdf5 	bl	800177c <CPU_SR_Restore>
   *p_err             = OS_ERR_NONE;
 8006b92:	2300      	movs	r3, #0
 8006b94:	8023      	strh	r3, [r4, #0]
 8006b96:	bd70      	pop	{r4, r5, r6, pc}
    }
#endif

    CPU_CRITICAL_ENTER();
    if (p_tcb == (OS_TCB *)0) {
        p_tcb = OSTCBCurPtr;
 8006b98:	4b01      	ldr	r3, [pc, #4]	; (8006ba0 <OSTaskRegSet+0x2c>)
 8006b9a:	681d      	ldr	r5, [r3, #0]
 8006b9c:	e7f6      	b.n	8006b8c <OSTaskRegSet+0x18>
 8006b9e:	bf00      	nop
 8006ba0:	2000ed58 	.word	0x2000ed58

08006ba4 <OSTaskSemPend>:

OS_SEM_CTR  OSTaskSemPend (OS_TICK   timeout,
                           OS_OPT    opt,
                           CPU_TS   *p_ts,
                           OS_ERR   *p_err)
{
 8006ba4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
        return ((OS_SEM_CTR)0);
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
 8006ba8:	4c53      	ldr	r4, [pc, #332]	; (8006cf8 <OSTaskSemPend+0x154>)
 8006baa:	7824      	ldrb	r4, [r4, #0]
 8006bac:	2c00      	cmp	r4, #0
 8006bae:	d140      	bne.n	8006c32 <OSTaskSemPend+0x8e>
        return ((OS_SEM_CTR)0);
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    switch (opt) {                                          /* Validate 'opt'                                         */
 8006bb0:	b141      	cbz	r1, 8006bc4 <OSTaskSemPend+0x20>
 8006bb2:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 8006bb6:	d005      	beq.n	8006bc4 <OSTaskSemPend+0x20>
        case OS_OPT_PEND_BLOCKING:
        case OS_OPT_PEND_NON_BLOCKING:
             break;

        default:
            *p_err = OS_ERR_OPT_INVALID;
 8006bb8:	f645 6225 	movw	r2, #24101	; 0x5e25
 8006bbc:	801a      	strh	r2, [r3, #0]
             break;
    }
    ctr = OSTCBCurPtr->SemCtr;
    CPU_CRITICAL_EXIT();
    return (ctr);
}
 8006bbe:	4620      	mov	r0, r4
 8006bc0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8006bc4:	461d      	mov	r5, r3
 8006bc6:	4617      	mov	r7, r2
 8006bc8:	4688      	mov	r8, r1
 8006bca:	4682      	mov	sl, r0
            *p_err = OS_ERR_OPT_INVALID;
             return ((OS_SEM_CTR)0);
    }
#endif

    if (p_ts != (CPU_TS *)0) {
 8006bcc:	2a00      	cmp	r2, #0
 8006bce:	d059      	beq.n	8006c84 <OSTaskSemPend+0xe0>
       *p_ts  = (CPU_TS  )0;                                /* Initialize the returned timestamp                      */
 8006bd0:	2300      	movs	r3, #0
 8006bd2:	6013      	str	r3, [r2, #0]
    }

    CPU_CRITICAL_ENTER();
 8006bd4:	f7fa fdce 	bl	8001774 <CPU_SR_Save>
    if (OSTCBCurPtr->SemCtr > (OS_SEM_CTR)0) {              /* See if task already been signaled                      */
 8006bd8:	f8df 9124 	ldr.w	r9, [pc, #292]	; 8006d00 <OSTaskSemPend+0x15c>

    if (p_ts != (CPU_TS *)0) {
       *p_ts  = (CPU_TS  )0;                                /* Initialize the returned timestamp                      */
    }

    CPU_CRITICAL_ENTER();
 8006bdc:	4606      	mov	r6, r0
    if (OSTCBCurPtr->SemCtr > (OS_SEM_CTR)0) {              /* See if task already been signaled                      */
 8006bde:	f8d9 3000 	ldr.w	r3, [r9]
 8006be2:	6c5c      	ldr	r4, [r3, #68]	; 0x44
 8006be4:	bb64      	cbnz	r4, 8006c40 <OSTaskSemPend+0x9c>
        CPU_CRITICAL_EXIT();
       *p_err = OS_ERR_NONE;
        return (ctr);
    }

    if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {    /* Caller wants to block if not available?                */
 8006be6:	f418 4f00 	tst.w	r8, #32768	; 0x8000
 8006bea:	d17d      	bne.n	8006ce8 <OSTaskSemPend+0x144>
        CPU_CRITICAL_EXIT();
       *p_err = OS_ERR_PEND_WOULD_BLOCK;                    /* No                                                     */
        return ((OS_SEM_CTR)0);
    } else {                                                /* Yes                                                    */
        if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /* Can't pend when the scheduler is locked                */
 8006bec:	4b43      	ldr	r3, [pc, #268]	; (8006cfc <OSTaskSemPend+0x158>)
 8006bee:	781c      	ldrb	r4, [r3, #0]
 8006bf0:	2c00      	cmp	r4, #0
 8006bf2:	d13f      	bne.n	8006c74 <OSTaskSemPend+0xd0>
            return ((OS_SEM_CTR)0);
        }
    }
                                                            /* Lock the scheduler/re-enable interrupts                */
    OS_CRITICAL_ENTER_CPU_EXIT();                           
    OS_Pend((OS_PEND_DATA *)0,                              /* Block task pending on Signal                           */
 8006bf4:	4653      	mov	r3, sl
 8006bf6:	2207      	movs	r2, #7
 8006bf8:	4621      	mov	r1, r4
 8006bfa:	4620      	mov	r0, r4
 8006bfc:	f7fd fc44 	bl	8004488 <OS_Pend>
            (OS_PEND_OBJ  *)0,
            (OS_STATE      )OS_TASK_PEND_ON_TASK_SEM,
            (OS_TICK       )timeout);
    OS_CRITICAL_EXIT_NO_SCHED();
 8006c00:	4630      	mov	r0, r6
 8006c02:	f7fa fdbb 	bl	800177c <CPU_SR_Restore>

    OSSched();                                              /* Find next highest priority task ready to run           */
 8006c06:	f7fc ff8f 	bl	8003b28 <OSSched>

    CPU_CRITICAL_ENTER();
 8006c0a:	f7fa fdb3 	bl	8001774 <CPU_SR_Save>
    switch (OSTCBCurPtr->PendStatus) {                      /* See if we timed-out or aborted                         */
 8006c0e:	f8d9 3000 	ldr.w	r3, [r9]
            (OS_TICK       )timeout);
    OS_CRITICAL_EXIT_NO_SCHED();

    OSSched();                                              /* Find next highest priority task ready to run           */

    CPU_CRITICAL_ENTER();
 8006c12:	4606      	mov	r6, r0
    switch (OSTCBCurPtr->PendStatus) {                      /* See if we timed-out or aborted                         */
 8006c14:	f893 2035 	ldrb.w	r2, [r3, #53]	; 0x35
 8006c18:	f8df 80e4 	ldr.w	r8, [pc, #228]	; 8006d00 <OSTaskSemPend+0x15c>
 8006c1c:	2a01      	cmp	r2, #1
 8006c1e:	d05c      	beq.n	8006cda <OSTaskSemPend+0x136>
 8006c20:	d347      	bcc.n	8006cb2 <OSTaskSemPend+0x10e>
 8006c22:	2a03      	cmp	r2, #3
 8006c24:	d13b      	bne.n	8006c9e <OSTaskSemPend+0xfa>
             }
            *p_err = OS_ERR_PEND_ABORT;                     /* Indicate that we aborted                               */
             break;

        case OS_STATUS_PEND_TIMEOUT:
             if (p_ts != (CPU_TS *)0) {
 8006c26:	b107      	cbz	r7, 8006c2a <OSTaskSemPend+0x86>
                *p_ts  = (CPU_TS  )0;
 8006c28:	603c      	str	r4, [r7, #0]
             }
            *p_err = OS_ERR_TIMEOUT;                        /* Indicate that we didn't get event within TO            */
 8006c2a:	f247 22d9 	movw	r2, #29401	; 0x72d9
 8006c2e:	802a      	strh	r2, [r5, #0]
             break;
 8006c30:	e038      	b.n	8006ca4 <OSTaskSemPend+0x100>
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
       *p_err = OS_ERR_PEND_ISR;
 8006c32:	f246 12ae 	movw	r2, #25006	; 0x61ae
        return ((OS_SEM_CTR)0);
 8006c36:	2400      	movs	r4, #0
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
       *p_err = OS_ERR_PEND_ISR;
 8006c38:	801a      	strh	r2, [r3, #0]
             break;
    }
    ctr = OSTCBCurPtr->SemCtr;
    CPU_CRITICAL_EXIT();
    return (ctr);
}
 8006c3a:	4620      	mov	r0, r4
 8006c3c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    CPU_CRITICAL_ENTER();
    if (OSTCBCurPtr->SemCtr > (OS_SEM_CTR)0) {              /* See if task already been signaled                      */
        OSTCBCurPtr->SemCtr--;
        ctr    = OSTCBCurPtr->SemCtr;
        if (p_ts != (CPU_TS *)0) {
           *p_ts  = OSTCBCurPtr->TS;
 8006c40:	6c1a      	ldr	r2, [r3, #64]	; 0x40
       *p_ts  = (CPU_TS  )0;                                /* Initialize the returned timestamp                      */
    }

    CPU_CRITICAL_ENTER();
    if (OSTCBCurPtr->SemCtr > (OS_SEM_CTR)0) {              /* See if task already been signaled                      */
        OSTCBCurPtr->SemCtr--;
 8006c42:	3c01      	subs	r4, #1
 8006c44:	645c      	str	r4, [r3, #68]	; 0x44
        ctr    = OSTCBCurPtr->SemCtr;
        if (p_ts != (CPU_TS *)0) {
           *p_ts  = OSTCBCurPtr->TS;
 8006c46:	603a      	str	r2, [r7, #0]
        }
#if OS_CFG_TASK_PROFILE_EN > 0u
        OSTCBCurPtr->SemPendTime = OS_TS_GET() - OSTCBCurPtr->TS;
 8006c48:	f7f9 ffa0 	bl	8000b8c <CPU_TS_TmrRd>
 8006c4c:	f8d9 2000 	ldr.w	r2, [r9]
 8006c50:	6c13      	ldr	r3, [r2, #64]	; 0x40
        if (OSTCBCurPtr->SemPendTimeMax < OSTCBCurPtr->SemPendTime) {
 8006c52:	f8d2 10a8 	ldr.w	r1, [r2, #168]	; 0xa8
        ctr    = OSTCBCurPtr->SemCtr;
        if (p_ts != (CPU_TS *)0) {
           *p_ts  = OSTCBCurPtr->TS;
        }
#if OS_CFG_TASK_PROFILE_EN > 0u
        OSTCBCurPtr->SemPendTime = OS_TS_GET() - OSTCBCurPtr->TS;
 8006c56:	1ac0      	subs	r0, r0, r3
        if (OSTCBCurPtr->SemPendTimeMax < OSTCBCurPtr->SemPendTime) {
 8006c58:	4288      	cmp	r0, r1
        ctr    = OSTCBCurPtr->SemCtr;
        if (p_ts != (CPU_TS *)0) {
           *p_ts  = OSTCBCurPtr->TS;
        }
#if OS_CFG_TASK_PROFILE_EN > 0u
        OSTCBCurPtr->SemPendTime = OS_TS_GET() - OSTCBCurPtr->TS;
 8006c5a:	f8c2 00a4 	str.w	r0, [r2, #164]	; 0xa4
        if (OSTCBCurPtr->SemPendTimeMax < OSTCBCurPtr->SemPendTime) {
            OSTCBCurPtr->SemPendTimeMax = OSTCBCurPtr->SemPendTime;
 8006c5e:	bf88      	it	hi
 8006c60:	f8c2 00a8 	strhi.w	r0, [r2, #168]	; 0xa8
        }
#endif
        CPU_CRITICAL_EXIT();
 8006c64:	4630      	mov	r0, r6
 8006c66:	f7fa fd89 	bl	800177c <CPU_SR_Restore>
       *p_err = OS_ERR_NONE;
 8006c6a:	2300      	movs	r3, #0
 8006c6c:	802b      	strh	r3, [r5, #0]
             break;
    }
    ctr = OSTCBCurPtr->SemCtr;
    CPU_CRITICAL_EXIT();
    return (ctr);
}
 8006c6e:	4620      	mov	r0, r4
 8006c70:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        CPU_CRITICAL_EXIT();
       *p_err = OS_ERR_PEND_WOULD_BLOCK;                    /* No                                                     */
        return ((OS_SEM_CTR)0);
    } else {                                                /* Yes                                                    */
        if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /* Can't pend when the scheduler is locked                */
            CPU_CRITICAL_EXIT();
 8006c74:	4630      	mov	r0, r6
 8006c76:	f7fa fd81 	bl	800177c <CPU_SR_Restore>
           *p_err = OS_ERR_SCHED_LOCKED;
 8006c7a:	f646 5363 	movw	r3, #28003	; 0x6d63
            return ((OS_SEM_CTR)0);
 8006c7e:	2400      	movs	r4, #0
       *p_err = OS_ERR_PEND_WOULD_BLOCK;                    /* No                                                     */
        return ((OS_SEM_CTR)0);
    } else {                                                /* Yes                                                    */
        if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /* Can't pend when the scheduler is locked                */
            CPU_CRITICAL_EXIT();
           *p_err = OS_ERR_SCHED_LOCKED;
 8006c80:	802b      	strh	r3, [r5, #0]
            return ((OS_SEM_CTR)0);
 8006c82:	e79c      	b.n	8006bbe <OSTaskSemPend+0x1a>

    if (p_ts != (CPU_TS *)0) {
       *p_ts  = (CPU_TS  )0;                                /* Initialize the returned timestamp                      */
    }

    CPU_CRITICAL_ENTER();
 8006c84:	f7fa fd76 	bl	8001774 <CPU_SR_Save>
    if (OSTCBCurPtr->SemCtr > (OS_SEM_CTR)0) {              /* See if task already been signaled                      */
 8006c88:	f8df 9074 	ldr.w	r9, [pc, #116]	; 8006d00 <OSTaskSemPend+0x15c>

    if (p_ts != (CPU_TS *)0) {
       *p_ts  = (CPU_TS  )0;                                /* Initialize the returned timestamp                      */
    }

    CPU_CRITICAL_ENTER();
 8006c8c:	4606      	mov	r6, r0
    if (OSTCBCurPtr->SemCtr > (OS_SEM_CTR)0) {              /* See if task already been signaled                      */
 8006c8e:	f8d9 3000 	ldr.w	r3, [r9]
 8006c92:	6c5c      	ldr	r4, [r3, #68]	; 0x44
 8006c94:	2c00      	cmp	r4, #0
 8006c96:	d0a6      	beq.n	8006be6 <OSTaskSemPend+0x42>
        OSTCBCurPtr->SemCtr--;
 8006c98:	3c01      	subs	r4, #1
 8006c9a:	645c      	str	r4, [r3, #68]	; 0x44
 8006c9c:	e7d4      	b.n	8006c48 <OSTaskSemPend+0xa4>
             }
            *p_err = OS_ERR_TIMEOUT;                        /* Indicate that we didn't get event within TO            */
             break;

        default:
            *p_err = OS_ERR_STATUS_INVALID;
 8006c9e:	f646 622e 	movw	r2, #28206	; 0x6e2e
 8006ca2:	802a      	strh	r2, [r5, #0]
             break;
    }
    ctr = OSTCBCurPtr->SemCtr;
 8006ca4:	6c5c      	ldr	r4, [r3, #68]	; 0x44
    CPU_CRITICAL_EXIT();
 8006ca6:	4630      	mov	r0, r6
 8006ca8:	f7fa fd68 	bl	800177c <CPU_SR_Restore>
    return (ctr);
}
 8006cac:	4620      	mov	r0, r4
 8006cae:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    OSSched();                                              /* Find next highest priority task ready to run           */

    CPU_CRITICAL_ENTER();
    switch (OSTCBCurPtr->PendStatus) {                      /* See if we timed-out or aborted                         */
        case OS_STATUS_PEND_OK:
             if (p_ts != (CPU_TS *)0) {
 8006cb2:	b17f      	cbz	r7, 8006cd4 <OSTaskSemPend+0x130>
                *p_ts                    =  OSTCBCurPtr->TS;
 8006cb4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8006cb6:	603b      	str	r3, [r7, #0]
#if OS_CFG_TASK_PROFILE_EN > 0u
                OSTCBCurPtr->SemPendTime = OS_TS_GET() - OSTCBCurPtr->TS;
 8006cb8:	f7f9 ff68 	bl	8000b8c <CPU_TS_TmrRd>
 8006cbc:	f8d8 3000 	ldr.w	r3, [r8]
 8006cc0:	6c1a      	ldr	r2, [r3, #64]	; 0x40
                if (OSTCBCurPtr->SemPendTimeMax < OSTCBCurPtr->SemPendTime) {
 8006cc2:	f8d3 10a8 	ldr.w	r1, [r3, #168]	; 0xa8
    switch (OSTCBCurPtr->PendStatus) {                      /* See if we timed-out or aborted                         */
        case OS_STATUS_PEND_OK:
             if (p_ts != (CPU_TS *)0) {
                *p_ts                    =  OSTCBCurPtr->TS;
#if OS_CFG_TASK_PROFILE_EN > 0u
                OSTCBCurPtr->SemPendTime = OS_TS_GET() - OSTCBCurPtr->TS;
 8006cc6:	1a80      	subs	r0, r0, r2
                if (OSTCBCurPtr->SemPendTimeMax < OSTCBCurPtr->SemPendTime) {
 8006cc8:	4288      	cmp	r0, r1
    switch (OSTCBCurPtr->PendStatus) {                      /* See if we timed-out or aborted                         */
        case OS_STATUS_PEND_OK:
             if (p_ts != (CPU_TS *)0) {
                *p_ts                    =  OSTCBCurPtr->TS;
#if OS_CFG_TASK_PROFILE_EN > 0u
                OSTCBCurPtr->SemPendTime = OS_TS_GET() - OSTCBCurPtr->TS;
 8006cca:	f8c3 00a4 	str.w	r0, [r3, #164]	; 0xa4
                if (OSTCBCurPtr->SemPendTimeMax < OSTCBCurPtr->SemPendTime) {
                    OSTCBCurPtr->SemPendTimeMax = OSTCBCurPtr->SemPendTime;
 8006cce:	bf88      	it	hi
 8006cd0:	f8c3 00a8 	strhi.w	r0, [r3, #168]	; 0xa8
                }
#endif
             }
            *p_err = OS_ERR_NONE;
 8006cd4:	2200      	movs	r2, #0
 8006cd6:	802a      	strh	r2, [r5, #0]
             break;
 8006cd8:	e7e4      	b.n	8006ca4 <OSTaskSemPend+0x100>

        case OS_STATUS_PEND_ABORT:
             if (p_ts != (CPU_TS *)0) {
 8006cda:	b10f      	cbz	r7, 8006ce0 <OSTaskSemPend+0x13c>
                *p_ts  =  OSTCBCurPtr->TS;
 8006cdc:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8006cde:	603a      	str	r2, [r7, #0]
             }
            *p_err = OS_ERR_PEND_ABORT;                     /* Indicate that we aborted                               */
 8006ce0:	f246 12a9 	movw	r2, #25001	; 0x61a9
 8006ce4:	802a      	strh	r2, [r5, #0]
             break;
 8006ce6:	e7dd      	b.n	8006ca4 <OSTaskSemPend+0x100>
       *p_err = OS_ERR_NONE;
        return (ctr);
    }

    if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {    /* Caller wants to block if not available?                */
        CPU_CRITICAL_EXIT();
 8006ce8:	4630      	mov	r0, r6
 8006cea:	f7fa fd47 	bl	800177c <CPU_SR_Restore>
       *p_err = OS_ERR_PEND_WOULD_BLOCK;                    /* No                                                     */
 8006cee:	f246 13b0 	movw	r3, #25008	; 0x61b0
        return ((OS_SEM_CTR)0);
 8006cf2:	2400      	movs	r4, #0
        return (ctr);
    }

    if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {    /* Caller wants to block if not available?                */
        CPU_CRITICAL_EXIT();
       *p_err = OS_ERR_PEND_WOULD_BLOCK;                    /* No                                                     */
 8006cf4:	802b      	strh	r3, [r5, #0]
        return ((OS_SEM_CTR)0);
 8006cf6:	e762      	b.n	8006bbe <OSTaskSemPend+0x1a>
 8006cf8:	2000ed84 	.word	0x2000ed84
 8006cfc:	2000e974 	.word	0x2000e974
 8006d00:	2000ed58 	.word	0x2000ed58

08006d04 <OSTaskSemPendAbort>:

#if OS_CFG_TASK_SEM_PEND_ABORT_EN > 0u
CPU_BOOLEAN  OSTaskSemPendAbort (OS_TCB  *p_tcb,
                                 OS_OPT   opt,
                                 OS_ERR  *p_err)
{
 8006d04:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        return (DEF_FALSE);
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from ISR ...                             */
 8006d06:	4b23      	ldr	r3, [pc, #140]	; (8006d94 <OSTaskSemPendAbort+0x90>)
 8006d08:	781c      	ldrb	r4, [r3, #0]
 8006d0a:	b9f4      	cbnz	r4, 8006d4a <OSTaskSemPendAbort+0x46>
        return (DEF_FALSE);
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    switch (opt) {                                          /* Validate 'opt'                                         */
 8006d0c:	b139      	cbz	r1, 8006d1e <OSTaskSemPendAbort+0x1a>
 8006d0e:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 8006d12:	d004      	beq.n	8006d1e <OSTaskSemPendAbort+0x1a>
        case OS_OPT_POST_NONE:
        case OS_OPT_POST_NO_SCHED:
             break;

        default:
            *p_err =  OS_ERR_OPT_INVALID;
 8006d14:	f645 6325 	movw	r3, #24101	; 0x5e25
 8006d18:	8013      	strh	r3, [r2, #0]
    if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
        OSSched();                                          /* Run the scheduler                                      */
    }
   *p_err = OS_ERR_NONE;
    return (DEF_TRUE);
}
 8006d1a:	4620      	mov	r0, r4
 8006d1c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8006d1e:	4617      	mov	r7, r2
 8006d20:	460d      	mov	r5, r1
 8006d22:	4606      	mov	r6, r0
            *p_err =  OS_ERR_OPT_INVALID;
             return (DEF_FALSE);
    }
#endif

    CPU_CRITICAL_ENTER();
 8006d24:	f7fa fd26 	bl	8001774 <CPU_SR_Save>
 8006d28:	4602      	mov	r2, r0
    if ((p_tcb == (OS_TCB *)0) ||                           /* Pend abort self?                                       */
 8006d2a:	b35e      	cbz	r6, 8006d84 <OSTaskSemPendAbort+0x80>
        (p_tcb == OSTCBCurPtr)) {
 8006d2c:	4b1a      	ldr	r3, [pc, #104]	; (8006d98 <OSTaskSemPendAbort+0x94>)
             return (DEF_FALSE);
    }
#endif

    CPU_CRITICAL_ENTER();
    if ((p_tcb == (OS_TCB *)0) ||                           /* Pend abort self?                                       */
 8006d2e:	681b      	ldr	r3, [r3, #0]
 8006d30:	429e      	cmp	r6, r3
 8006d32:	d027      	beq.n	8006d84 <OSTaskSemPendAbort+0x80>
        CPU_CRITICAL_EXIT();                                /* ... doesn't make sense!                                */
       *p_err = OS_ERR_PEND_ABORT_SELF;
        return (DEF_FALSE);
    }

    if (p_tcb->PendOn != OS_TASK_PEND_ON_TASK_SEM) {        /* Is task waiting for a signal?                          */
 8006d34:	f896 3034 	ldrb.w	r3, [r6, #52]	; 0x34
 8006d38:	2b07      	cmp	r3, #7
 8006d3a:	d00c      	beq.n	8006d56 <OSTaskSemPendAbort+0x52>
        CPU_CRITICAL_EXIT();
 8006d3c:	f7fa fd1e 	bl	800177c <CPU_SR_Restore>
       *p_err = OS_ERR_PEND_ABORT_NONE;
 8006d40:	f246 13ab 	movw	r3, #25003	; 0x61ab
    if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
        OSSched();                                          /* Run the scheduler                                      */
    }
   *p_err = OS_ERR_NONE;
    return (DEF_TRUE);
}
 8006d44:	4620      	mov	r0, r4
        return (DEF_FALSE);
    }

    if (p_tcb->PendOn != OS_TASK_PEND_ON_TASK_SEM) {        /* Is task waiting for a signal?                          */
        CPU_CRITICAL_EXIT();
       *p_err = OS_ERR_PEND_ABORT_NONE;
 8006d46:	803b      	strh	r3, [r7, #0]
    if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
        OSSched();                                          /* Run the scheduler                                      */
    }
   *p_err = OS_ERR_NONE;
    return (DEF_TRUE);
}
 8006d48:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from ISR ...                             */
       *p_err = OS_ERR_PEND_ABORT_ISR;                      /* ... can't Pend Abort from an ISR                       */
 8006d4a:	f246 13aa 	movw	r3, #25002	; 0x61aa
        return (DEF_FALSE);
 8006d4e:	2400      	movs	r4, #0
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from ISR ...                             */
       *p_err = OS_ERR_PEND_ABORT_ISR;                      /* ... can't Pend Abort from an ISR                       */
 8006d50:	8013      	strh	r3, [r2, #0]
    if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
        OSSched();                                          /* Run the scheduler                                      */
    }
   *p_err = OS_ERR_NONE;
    return (DEF_TRUE);
}
 8006d52:	4620      	mov	r0, r4
 8006d54:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (p_tcb->PendOn != OS_TASK_PEND_ON_TASK_SEM) {        /* Is task waiting for a signal?                          */
        CPU_CRITICAL_EXIT();
       *p_err = OS_ERR_PEND_ABORT_NONE;
        return (DEF_FALSE);
    }
    CPU_CRITICAL_EXIT();
 8006d56:	f7fa fd11 	bl	800177c <CPU_SR_Restore>

    OS_CRITICAL_ENTER();
 8006d5a:	f7fa fd0b 	bl	8001774 <CPU_SR_Save>
 8006d5e:	4604      	mov	r4, r0
    ts = OS_TS_GET();
 8006d60:	f7f9 ff14 	bl	8000b8c <CPU_TS_TmrRd>
    OS_PendAbort((OS_PEND_OBJ *)0,
 8006d64:	4631      	mov	r1, r6
 8006d66:	4602      	mov	r2, r0
 8006d68:	2000      	movs	r0, #0
 8006d6a:	f7fd fbe9 	bl	8004540 <OS_PendAbort>
                 p_tcb,
                 ts);
    OS_CRITICAL_EXIT_NO_SCHED();
 8006d6e:	4620      	mov	r0, r4
 8006d70:	f7fa fd04 	bl	800177c <CPU_SR_Restore>
    if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
 8006d74:	042b      	lsls	r3, r5, #16
 8006d76:	d401      	bmi.n	8006d7c <OSTaskSemPendAbort+0x78>
        OSSched();                                          /* Run the scheduler                                      */
 8006d78:	f7fc fed6 	bl	8003b28 <OSSched>
    }
   *p_err = OS_ERR_NONE;
 8006d7c:	2300      	movs	r3, #0
 8006d7e:	803b      	strh	r3, [r7, #0]
    return (DEF_TRUE);
 8006d80:	2401      	movs	r4, #1
 8006d82:	e7ca      	b.n	8006d1a <OSTaskSemPendAbort+0x16>
#endif

    CPU_CRITICAL_ENTER();
    if ((p_tcb == (OS_TCB *)0) ||                           /* Pend abort self?                                       */
        (p_tcb == OSTCBCurPtr)) {
        CPU_CRITICAL_EXIT();                                /* ... doesn't make sense!                                */
 8006d84:	4610      	mov	r0, r2
 8006d86:	f7fa fcf9 	bl	800177c <CPU_SR_Restore>
       *p_err = OS_ERR_PEND_ABORT_SELF;
 8006d8a:	f246 13ac 	movw	r3, #25004	; 0x61ac
 8006d8e:	803b      	strh	r3, [r7, #0]
        return (DEF_FALSE);
 8006d90:	e7c3      	b.n	8006d1a <OSTaskSemPendAbort+0x16>
 8006d92:	bf00      	nop
 8006d94:	2000ed84 	.word	0x2000ed84
 8006d98:	2000ed58 	.word	0x2000ed58

08006d9c <OSTaskSemSet>:
*/

OS_SEM_CTR  OSTaskSemSet (OS_TCB      *p_tcb,
                          OS_SEM_CTR   cnt,
                          OS_ERR      *p_err)
{
 8006d9c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
        return ((OS_SEM_CTR)0);
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
 8006d9e:	4b0c      	ldr	r3, [pc, #48]	; (8006dd0 <OSTaskSemSet+0x34>)
*/

OS_SEM_CTR  OSTaskSemSet (OS_TCB      *p_tcb,
                          OS_SEM_CTR   cnt,
                          OS_ERR      *p_err)
{
 8006da0:	4616      	mov	r6, r2
        return ((OS_SEM_CTR)0);
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
 8006da2:	781b      	ldrb	r3, [r3, #0]
 8006da4:	b123      	cbz	r3, 8006db0 <OSTaskSemSet+0x14>
       *p_err = OS_ERR_SET_ISR;
 8006da6:	f646 53c6 	movw	r3, #28102	; 0x6dc6
        return ((OS_SEM_CTR)0);
 8006daa:	2000      	movs	r0, #0
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
       *p_err = OS_ERR_SET_ISR;
 8006dac:	8013      	strh	r3, [r2, #0]
        return ((OS_SEM_CTR)0);
 8006dae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8006db0:	4605      	mov	r5, r0
 8006db2:	460f      	mov	r7, r1
    }
#endif

    CPU_CRITICAL_ENTER();
 8006db4:	f7fa fcde 	bl	8001774 <CPU_SR_Save>
    if (p_tcb == (OS_TCB *)0) {
 8006db8:	b13d      	cbz	r5, 8006dca <OSTaskSemSet+0x2e>
        p_tcb = OSTCBCurPtr;
    }
    ctr           = p_tcb->SemCtr;
 8006dba:	6c6c      	ldr	r4, [r5, #68]	; 0x44
    p_tcb->SemCtr = (OS_SEM_CTR)cnt;
 8006dbc:	646f      	str	r7, [r5, #68]	; 0x44
    CPU_CRITICAL_EXIT();
 8006dbe:	f7fa fcdd 	bl	800177c <CPU_SR_Restore>
   *p_err         =  OS_ERR_NONE;
 8006dc2:	2300      	movs	r3, #0
    return (ctr);
 8006dc4:	4620      	mov	r0, r4
        p_tcb = OSTCBCurPtr;
    }
    ctr           = p_tcb->SemCtr;
    p_tcb->SemCtr = (OS_SEM_CTR)cnt;
    CPU_CRITICAL_EXIT();
   *p_err         =  OS_ERR_NONE;
 8006dc6:	8033      	strh	r3, [r6, #0]
    return (ctr);
}
 8006dc8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    }
#endif

    CPU_CRITICAL_ENTER();
    if (p_tcb == (OS_TCB *)0) {
        p_tcb = OSTCBCurPtr;
 8006dca:	4b02      	ldr	r3, [pc, #8]	; (8006dd4 <OSTaskSemSet+0x38>)
 8006dcc:	681d      	ldr	r5, [r3, #0]
 8006dce:	e7f4      	b.n	8006dba <OSTaskSemSet+0x1e>
 8006dd0:	2000ed84 	.word	0x2000ed84
 8006dd4:	2000ed58 	.word	0x2000ed58

08006dd8 <OSTaskStkChk>:
#if OS_CFG_STAT_TASK_STK_CHK_EN > 0u
void  OSTaskStkChk (OS_TCB        *p_tcb,
                    CPU_STK_SIZE  *p_free,
                    CPU_STK_SIZE  *p_used,
                    OS_ERR        *p_err)
{
 8006dd8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
        return;
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to check stack from ISR                  */
 8006ddc:	4c26      	ldr	r4, [pc, #152]	; (8006e78 <OSTaskStkChk+0xa0>)
#if OS_CFG_STAT_TASK_STK_CHK_EN > 0u
void  OSTaskStkChk (OS_TCB        *p_tcb,
                    CPU_STK_SIZE  *p_free,
                    CPU_STK_SIZE  *p_used,
                    OS_ERR        *p_err)
{
 8006dde:	4606      	mov	r6, r0
        return;
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to check stack from ISR                  */
 8006de0:	7820      	ldrb	r0, [r4, #0]
#if OS_CFG_STAT_TASK_STK_CHK_EN > 0u
void  OSTaskStkChk (OS_TCB        *p_tcb,
                    CPU_STK_SIZE  *p_free,
                    CPU_STK_SIZE  *p_used,
                    OS_ERR        *p_err)
{
 8006de2:	4698      	mov	r8, r3
        return;
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to check stack from ISR                  */
 8006de4:	bb00      	cbnz	r0, 8006e28 <OSTaskStkChk+0x50>
 8006de6:	460f      	mov	r7, r1
        return;
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_free == (CPU_STK_SIZE*)0) {                       /* User must specify valid destinations for the sizes     */
 8006de8:	b321      	cbz	r1, 8006e34 <OSTaskStkChk+0x5c>
 8006dea:	4691      	mov	r9, r2
       *p_err  = OS_ERR_PTR_INVALID;
        return;
    }

    if (p_used == (CPU_STK_SIZE*)0) {
 8006dec:	b312      	cbz	r2, 8006e34 <OSTaskStkChk+0x5c>
       *p_err  = OS_ERR_PTR_INVALID;
        return;
    }
#endif

    CPU_CRITICAL_ENTER();
 8006dee:	f7fa fcc1 	bl	8001774 <CPU_SR_Save>
    if (p_tcb == (OS_TCB *)0) {                             /* Check the stack of the current task?                   */
 8006df2:	b386      	cbz	r6, 8006e56 <OSTaskStkChk+0x7e>
        p_tcb = OSTCBCurPtr;                                /* Yes                                                    */
    }

    if (p_tcb->StkPtr == (CPU_STK*)0) {                     /* Make sure task exist                                   */
 8006df4:	6834      	ldr	r4, [r6, #0]
 8006df6:	b39c      	cbz	r4, 8006e60 <OSTaskStkChk+0x88>
       *p_used = (CPU_STK_SIZE)0;
       *p_err  =  OS_ERR_TASK_NOT_EXIST;
        return;
    }

    if ((p_tcb->Opt & OS_OPT_TASK_STK_CHK) == (OS_OPT)0) {  /* Make sure stack checking option is set                 */
 8006df8:	8fb3      	ldrh	r3, [r6, #60]	; 0x3c
 8006dfa:	f013 0401 	ands.w	r4, r3, #1
 8006dfe:	d01f      	beq.n	8006e40 <OSTaskStkChk+0x68>
       *p_free = (CPU_STK_SIZE)0;
       *p_used = (CPU_STK_SIZE)0;
       *p_err  =  OS_ERR_TASK_OPT;
        return;
    }
    CPU_CRITICAL_EXIT();
 8006e00:	f7fa fcbc 	bl	800177c <CPU_SR_Restore>

    free_stk  = 0u;
#if CPU_CFG_STK_GROWTH == CPU_STK_GROWTH_HI_TO_LO
    p_stk = p_tcb->StkBasePtr;                              /* Start at the lowest memory and go up                   */
 8006e04:	6a74      	ldr	r4, [r6, #36]	; 0x24
    while (*p_stk == (CPU_STK)0) {                          /* Compute the number of zero entries on the stk          */
 8006e06:	6820      	ldr	r0, [r4, #0]
 8006e08:	bb40      	cbnz	r0, 8006e5c <OSTaskStkChk+0x84>
 8006e0a:	f854 5f04 	ldr.w	r5, [r4, #4]!
        p_stk++;
        free_stk++;
 8006e0e:	3001      	adds	r0, #1
    CPU_CRITICAL_EXIT();

    free_stk  = 0u;
#if CPU_CFG_STK_GROWTH == CPU_STK_GROWTH_HI_TO_LO
    p_stk = p_tcb->StkBasePtr;                              /* Start at the lowest memory and go up                   */
    while (*p_stk == (CPU_STK)0) {                          /* Compute the number of zero entries on the stk          */
 8006e10:	2d00      	cmp	r5, #0
 8006e12:	d0fa      	beq.n	8006e0a <OSTaskStkChk+0x32>
    while (*p_stk == (CPU_STK)0) {
        free_stk++;
        p_stk--;
    }
#endif
   *p_free = free_stk;
 8006e14:	6038      	str	r0, [r7, #0]
   *p_used = (p_tcb->StkSize - free_stk);                   /* Compute number of entries used on the stack            */
 8006e16:	6bb3      	ldr	r3, [r6, #56]	; 0x38
   *p_err  = OS_ERR_NONE;
 8006e18:	2200      	movs	r2, #0
        free_stk++;
        p_stk--;
    }
#endif
   *p_free = free_stk;
   *p_used = (p_tcb->StkSize - free_stk);                   /* Compute number of entries used on the stack            */
 8006e1a:	1a18      	subs	r0, r3, r0
 8006e1c:	f8c9 0000 	str.w	r0, [r9]
   *p_err  = OS_ERR_NONE;
 8006e20:	f8a8 2000 	strh.w	r2, [r8]
 8006e24:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to check stack from ISR                  */
       *p_err = OS_ERR_TASK_STK_CHK_ISR;
 8006e28:	f247 1359 	movw	r3, #29017	; 0x7159
 8006e2c:	f8a8 3000 	strh.w	r3, [r8]
        return;
 8006e30:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_free == (CPU_STK_SIZE*)0) {                       /* User must specify valid destinations for the sizes     */
       *p_err  = OS_ERR_PTR_INVALID;
 8006e34:	f246 23d5 	movw	r3, #25301	; 0x62d5
 8006e38:	f8a8 3000 	strh.w	r3, [r8]
        return;
 8006e3c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
       *p_err  =  OS_ERR_TASK_NOT_EXIST;
        return;
    }

    if ((p_tcb->Opt & OS_OPT_TASK_STK_CHK) == (OS_OPT)0) {  /* Make sure stack checking option is set                 */
        CPU_CRITICAL_EXIT();
 8006e40:	f7fa fc9c 	bl	800177c <CPU_SR_Restore>
       *p_free = (CPU_STK_SIZE)0;
       *p_used = (CPU_STK_SIZE)0;
       *p_err  =  OS_ERR_TASK_OPT;
 8006e44:	f247 1354 	movw	r3, #29012	; 0x7154
        return;
    }

    if ((p_tcb->Opt & OS_OPT_TASK_STK_CHK) == (OS_OPT)0) {  /* Make sure stack checking option is set                 */
        CPU_CRITICAL_EXIT();
       *p_free = (CPU_STK_SIZE)0;
 8006e48:	603c      	str	r4, [r7, #0]
       *p_used = (CPU_STK_SIZE)0;
 8006e4a:	f8c9 4000 	str.w	r4, [r9]
       *p_err  =  OS_ERR_TASK_OPT;
 8006e4e:	f8a8 3000 	strh.w	r3, [r8]
        return;
 8006e52:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    }
#endif

    CPU_CRITICAL_ENTER();
    if (p_tcb == (OS_TCB *)0) {                             /* Check the stack of the current task?                   */
        p_tcb = OSTCBCurPtr;                                /* Yes                                                    */
 8006e56:	4b09      	ldr	r3, [pc, #36]	; (8006e7c <OSTaskStkChk+0xa4>)
 8006e58:	681e      	ldr	r6, [r3, #0]
 8006e5a:	e7cb      	b.n	8006df4 <OSTaskStkChk+0x1c>
       *p_err  =  OS_ERR_TASK_OPT;
        return;
    }
    CPU_CRITICAL_EXIT();

    free_stk  = 0u;
 8006e5c:	2000      	movs	r0, #0
 8006e5e:	e7d9      	b.n	8006e14 <OSTaskStkChk+0x3c>
    if (p_tcb == (OS_TCB *)0) {                             /* Check the stack of the current task?                   */
        p_tcb = OSTCBCurPtr;                                /* Yes                                                    */
    }

    if (p_tcb->StkPtr == (CPU_STK*)0) {                     /* Make sure task exist                                   */
        CPU_CRITICAL_EXIT();
 8006e60:	f7fa fc8c 	bl	800177c <CPU_SR_Restore>
       *p_free = (CPU_STK_SIZE)0;
       *p_used = (CPU_STK_SIZE)0;
       *p_err  =  OS_ERR_TASK_NOT_EXIST;
 8006e64:	f247 1352 	movw	r3, #29010	; 0x7152
        p_tcb = OSTCBCurPtr;                                /* Yes                                                    */
    }

    if (p_tcb->StkPtr == (CPU_STK*)0) {                     /* Make sure task exist                                   */
        CPU_CRITICAL_EXIT();
       *p_free = (CPU_STK_SIZE)0;
 8006e68:	603c      	str	r4, [r7, #0]
       *p_used = (CPU_STK_SIZE)0;
 8006e6a:	f8c9 4000 	str.w	r4, [r9]
       *p_err  =  OS_ERR_TASK_NOT_EXIST;
 8006e6e:	f8a8 3000 	strh.w	r3, [r8]
        return;
 8006e72:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8006e76:	bf00      	nop
 8006e78:	2000ed84 	.word	0x2000ed84
 8006e7c:	2000ed58 	.word	0x2000ed58

08006e80 <OSTaskTimeQuantaSet>:

#if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
void  OSTaskTimeQuantaSet (OS_TCB   *p_tcb,
                           OS_TICK   time_quanta,
                           OS_ERR   *p_err)
{
 8006e80:	b570      	push	{r4, r5, r6, lr}
        return;
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't call this function from an ISR                   */
 8006e82:	4b11      	ldr	r3, [pc, #68]	; (8006ec8 <OSTaskTimeQuantaSet+0x48>)

#if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
void  OSTaskTimeQuantaSet (OS_TCB   *p_tcb,
                           OS_TICK   time_quanta,
                           OS_ERR   *p_err)
{
 8006e84:	4615      	mov	r5, r2
        return;
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't call this function from an ISR                   */
 8006e86:	781b      	ldrb	r3, [r3, #0]
 8006e88:	b11b      	cbz	r3, 8006e92 <OSTaskTimeQuantaSet+0x12>
       *p_err = OS_ERR_SET_ISR;
 8006e8a:	f646 53c6 	movw	r3, #28102	; 0x6dc6
 8006e8e:	8013      	strh	r3, [r2, #0]
        return;
 8006e90:	bd70      	pop	{r4, r5, r6, pc}
 8006e92:	4604      	mov	r4, r0
 8006e94:	460e      	mov	r6, r1
    }
#endif

    CPU_CRITICAL_ENTER();
 8006e96:	f7fa fc6d 	bl	8001774 <CPU_SR_Save>
    if (p_tcb == (OS_TCB *)0) {
 8006e9a:	b17c      	cbz	r4, 8006ebc <OSTaskTimeQuantaSet+0x3c>
        p_tcb = OSTCBCurPtr;
    }

    if (time_quanta == 0u) {
 8006e9c:	b156      	cbz	r6, 8006eb4 <OSTaskTimeQuantaSet+0x34>
        p_tcb->TimeQuanta    = OSSchedRoundRobinDfltTimeQuanta;
    } else {
        p_tcb->TimeQuanta    = time_quanta;
 8006e9e:	4633      	mov	r3, r6
 8006ea0:	6566      	str	r6, [r4, #84]	; 0x54
    }
    if (p_tcb->TimeQuanta > p_tcb->TimeQuantaCtr) {
 8006ea2:	6da2      	ldr	r2, [r4, #88]	; 0x58
 8006ea4:	429a      	cmp	r2, r3
        p_tcb->TimeQuantaCtr = p_tcb->TimeQuanta;
 8006ea6:	bf38      	it	cc
 8006ea8:	65a3      	strcc	r3, [r4, #88]	; 0x58
    }
    CPU_CRITICAL_EXIT();
 8006eaa:	f7fa fc67 	bl	800177c <CPU_SR_Restore>
   *p_err = OS_ERR_NONE;
 8006eae:	2300      	movs	r3, #0
 8006eb0:	802b      	strh	r3, [r5, #0]
 8006eb2:	bd70      	pop	{r4, r5, r6, pc}
    if (p_tcb == (OS_TCB *)0) {
        p_tcb = OSTCBCurPtr;
    }

    if (time_quanta == 0u) {
        p_tcb->TimeQuanta    = OSSchedRoundRobinDfltTimeQuanta;
 8006eb4:	4b05      	ldr	r3, [pc, #20]	; (8006ecc <OSTaskTimeQuantaSet+0x4c>)
 8006eb6:	681b      	ldr	r3, [r3, #0]
 8006eb8:	6563      	str	r3, [r4, #84]	; 0x54
 8006eba:	e7f2      	b.n	8006ea2 <OSTaskTimeQuantaSet+0x22>
    }
#endif

    CPU_CRITICAL_ENTER();
    if (p_tcb == (OS_TCB *)0) {
        p_tcb = OSTCBCurPtr;
 8006ebc:	4b04      	ldr	r3, [pc, #16]	; (8006ed0 <OSTaskTimeQuantaSet+0x50>)
 8006ebe:	681c      	ldr	r4, [r3, #0]
    }

    if (time_quanta == 0u) {
 8006ec0:	2e00      	cmp	r6, #0
 8006ec2:	d1ec      	bne.n	8006e9e <OSTaskTimeQuantaSet+0x1e>
 8006ec4:	e7f6      	b.n	8006eb4 <OSTaskTimeQuantaSet+0x34>
 8006ec6:	bf00      	nop
 8006ec8:	2000ed84 	.word	0x2000ed84
 8006ecc:	2000ef28 	.word	0x2000ef28
 8006ed0:	2000ed58 	.word	0x2000ed58

08006ed4 <OS_TaskDbgListAdd>:

#if OS_CFG_DBG_EN > 0u
void  OS_TaskDbgListAdd (OS_TCB  *p_tcb)
{
    p_tcb->DbgPrevPtr                = (OS_TCB *)0;
    if (OSTaskDbgListPtr == (OS_TCB *)0) {
 8006ed4:	4a05      	ldr	r2, [pc, #20]	; (8006eec <OS_TaskDbgListAdd+0x18>)
*/

#if OS_CFG_DBG_EN > 0u
void  OS_TaskDbgListAdd (OS_TCB  *p_tcb)
{
    p_tcb->DbgPrevPtr                = (OS_TCB *)0;
 8006ed6:	2100      	movs	r1, #0
    if (OSTaskDbgListPtr == (OS_TCB *)0) {
 8006ed8:	6813      	ldr	r3, [r2, #0]
*/

#if OS_CFG_DBG_EN > 0u
void  OS_TaskDbgListAdd (OS_TCB  *p_tcb)
{
    p_tcb->DbgPrevPtr                = (OS_TCB *)0;
 8006eda:	f8c0 10b8 	str.w	r1, [r0, #184]	; 0xb8
    if (OSTaskDbgListPtr == (OS_TCB *)0) {
        p_tcb->DbgNextPtr            = (OS_TCB *)0;
 8006ede:	f8c0 30bc 	str.w	r3, [r0, #188]	; 0xbc

#if OS_CFG_DBG_EN > 0u
void  OS_TaskDbgListAdd (OS_TCB  *p_tcb)
{
    p_tcb->DbgPrevPtr                = (OS_TCB *)0;
    if (OSTaskDbgListPtr == (OS_TCB *)0) {
 8006ee2:	b10b      	cbz	r3, 8006ee8 <OS_TaskDbgListAdd+0x14>
        p_tcb->DbgNextPtr            = (OS_TCB *)0;
    } else {
        p_tcb->DbgNextPtr            =  OSTaskDbgListPtr;
        OSTaskDbgListPtr->DbgPrevPtr =  p_tcb;
 8006ee4:	f8c3 00b8 	str.w	r0, [r3, #184]	; 0xb8
    }
    OSTaskDbgListPtr                 =  p_tcb;
 8006ee8:	6010      	str	r0, [r2, #0]
 8006eea:	4770      	bx	lr
 8006eec:	2000ed6c 	.word	0x2000ed6c

08006ef0 <OS_TaskDbgListRemove>:
{
    OS_TCB  *p_tcb_next;
    OS_TCB  *p_tcb_prev;


    p_tcb_prev = p_tcb->DbgPrevPtr;
 8006ef0:	f8d0 20b8 	ldr.w	r2, [r0, #184]	; 0xb8
    p_tcb_next = p_tcb->DbgNextPtr;
 8006ef4:	f8d0 30bc 	ldr.w	r3, [r0, #188]	; 0xbc

    if (p_tcb_prev == (OS_TCB *)0) {
 8006ef8:	b152      	cbz	r2, 8006f10 <OS_TaskDbgListRemove+0x20>
        if (p_tcb_next != (OS_TCB *)0) {
            p_tcb_next->DbgPrevPtr = (OS_TCB *)0;
        }
        p_tcb->DbgNextPtr = (OS_TCB *)0;

    } else if (p_tcb_next == (OS_TCB *)0) {
 8006efa:	b193      	cbz	r3, 8006f22 <OS_TaskDbgListRemove+0x32>
        p_tcb->DbgPrevPtr      = (OS_TCB *)0;

    } else {
        p_tcb_prev->DbgNextPtr =  p_tcb_next;
        p_tcb_next->DbgPrevPtr =  p_tcb_prev;
        p_tcb->DbgNextPtr      = (OS_TCB *)0;
 8006efc:	2100      	movs	r1, #0
    } else if (p_tcb_next == (OS_TCB *)0) {
        p_tcb_prev->DbgNextPtr = (OS_TCB *)0;
        p_tcb->DbgPrevPtr      = (OS_TCB *)0;

    } else {
        p_tcb_prev->DbgNextPtr =  p_tcb_next;
 8006efe:	f8c2 30bc 	str.w	r3, [r2, #188]	; 0xbc
        p_tcb_next->DbgPrevPtr =  p_tcb_prev;
 8006f02:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
        p_tcb->DbgNextPtr      = (OS_TCB *)0;
 8006f06:	f8c0 10bc 	str.w	r1, [r0, #188]	; 0xbc
        p_tcb->DbgPrevPtr      = (OS_TCB *)0;
 8006f0a:	f8c0 10b8 	str.w	r1, [r0, #184]	; 0xb8
 8006f0e:	4770      	bx	lr

    p_tcb_prev = p_tcb->DbgPrevPtr;
    p_tcb_next = p_tcb->DbgNextPtr;

    if (p_tcb_prev == (OS_TCB *)0) {
        OSTaskDbgListPtr = p_tcb_next;
 8006f10:	4906      	ldr	r1, [pc, #24]	; (8006f2c <OS_TaskDbgListRemove+0x3c>)
 8006f12:	600b      	str	r3, [r1, #0]
        if (p_tcb_next != (OS_TCB *)0) {
 8006f14:	b10b      	cbz	r3, 8006f1a <OS_TaskDbgListRemove+0x2a>
            p_tcb_next->DbgPrevPtr = (OS_TCB *)0;
 8006f16:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
        }
        p_tcb->DbgNextPtr = (OS_TCB *)0;
 8006f1a:	2300      	movs	r3, #0
 8006f1c:	f8c0 30bc 	str.w	r3, [r0, #188]	; 0xbc
 8006f20:	4770      	bx	lr

    } else if (p_tcb_next == (OS_TCB *)0) {
        p_tcb_prev->DbgNextPtr = (OS_TCB *)0;
 8006f22:	f8c2 30bc 	str.w	r3, [r2, #188]	; 0xbc
        p_tcb->DbgPrevPtr      = (OS_TCB *)0;
 8006f26:	f8c0 30b8 	str.w	r3, [r0, #184]	; 0xb8
 8006f2a:	4770      	bx	lr
 8006f2c:	2000ed6c 	.word	0x2000ed6c

08006f30 <OS_TaskInit>:
* Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
************************************************************************************************************************
*/

void  OS_TaskInit (OS_ERR  *p_err)
{
 8006f30:	b410      	push	{r4}

#if OS_CFG_DBG_EN > 0u
    OSTaskDbgListPtr = (OS_TCB      *)0;
#endif

    OSTaskQty        = (OS_OBJ_QTY   )0;                    /* Clear the number of tasks                              */
 8006f32:	4905      	ldr	r1, [pc, #20]	; (8006f48 <OS_TaskInit+0x18>)
        return;
    }
#endif

#if OS_CFG_DBG_EN > 0u
    OSTaskDbgListPtr = (OS_TCB      *)0;
 8006f34:	4c05      	ldr	r4, [pc, #20]	; (8006f4c <OS_TaskInit+0x1c>)
#endif

    OSTaskQty        = (OS_OBJ_QTY   )0;                    /* Clear the number of tasks                              */
    OSTaskCtxSwCtr   = (OS_CTX_SW_CTR)0;                    /* Clear the context switch counter                       */
 8006f36:	4a06      	ldr	r2, [pc, #24]	; (8006f50 <OS_TaskInit+0x20>)
        return;
    }
#endif

#if OS_CFG_DBG_EN > 0u
    OSTaskDbgListPtr = (OS_TCB      *)0;
 8006f38:	2300      	movs	r3, #0
 8006f3a:	6023      	str	r3, [r4, #0]
#endif

    OSTaskQty        = (OS_OBJ_QTY   )0;                    /* Clear the number of tasks                              */
 8006f3c:	800b      	strh	r3, [r1, #0]
    OSTaskCtxSwCtr   = (OS_CTX_SW_CTR)0;                    /* Clear the context switch counter                       */
 8006f3e:	6013      	str	r3, [r2, #0]

   *p_err            = OS_ERR_NONE;
}
 8006f40:	bc10      	pop	{r4}
#endif

    OSTaskQty        = (OS_OBJ_QTY   )0;                    /* Clear the number of tasks                              */
    OSTaskCtxSwCtr   = (OS_CTX_SW_CTR)0;                    /* Clear the context switch counter                       */

   *p_err            = OS_ERR_NONE;
 8006f42:	8003      	strh	r3, [r0, #0]
}
 8006f44:	4770      	bx	lr
 8006f46:	bf00      	nop
 8006f48:	2000ed86 	.word	0x2000ed86
 8006f4c:	2000ed6c 	.word	0x2000ed6c
 8006f50:	2000ed80 	.word	0x2000ed80

08006f54 <OS_TaskInitTCB>:
* Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
************************************************************************************************************************
*/

void  OS_TaskInitTCB (OS_TCB  *p_tcb)
{
 8006f54:	b538      	push	{r3, r4, r5, lr}
 8006f56:	4604      	mov	r4, r0

    p_tcb->TickNextPtr        = (OS_TCB        *)0;
    p_tcb->TickPrevPtr        = (OS_TCB        *)0;
    p_tcb->TickSpokePtr       = (OS_TICK_SPOKE *)0;

    p_tcb->NamePtr            = (CPU_CHAR      *)((void *)"?Task");
 8006f58:	4b2a      	ldr	r3, [pc, #168]	; (8007004 <OS_TaskInitTCB+0xb0>)
#if OS_CFG_TASK_PROFILE_EN > 0u
    CPU_TS      ts;
#endif


    p_tcb->StkPtr             = (CPU_STK       *)0;
 8006f5a:	2500      	movs	r5, #0

    p_tcb->TickNextPtr        = (OS_TCB        *)0;
    p_tcb->TickPrevPtr        = (OS_TCB        *)0;
    p_tcb->TickSpokePtr       = (OS_TICK_SPOKE *)0;

    p_tcb->NamePtr            = (CPU_CHAR      *)((void *)"?Task");
 8006f5c:	6203      	str	r3, [r0, #32]
#if OS_CFG_TASK_PROFILE_EN > 0u
    CPU_TS      ts;
#endif


    p_tcb->StkPtr             = (CPU_STK       *)0;
 8006f5e:	6005      	str	r5, [r0, #0]
    p_tcb->StkLimitPtr        = (CPU_STK       *)0;
 8006f60:	6085      	str	r5, [r0, #8]

    p_tcb->ExtPtr             = (void          *)0;
 8006f62:	6045      	str	r5, [r0, #4]

    p_tcb->NextPtr            = (OS_TCB        *)0;
 8006f64:	60c5      	str	r5, [r0, #12]
    p_tcb->PrevPtr            = (OS_TCB        *)0;
 8006f66:	6105      	str	r5, [r0, #16]

    p_tcb->TickNextPtr        = (OS_TCB        *)0;
 8006f68:	6145      	str	r5, [r0, #20]
    p_tcb->TickPrevPtr        = (OS_TCB        *)0;
 8006f6a:	6185      	str	r5, [r0, #24]
    p_tcb->TickSpokePtr       = (OS_TICK_SPOKE *)0;
 8006f6c:	61c5      	str	r5, [r0, #28]

    p_tcb->NamePtr            = (CPU_CHAR      *)((void *)"?Task");

    p_tcb->StkBasePtr         = (CPU_STK       *)0;
 8006f6e:	6245      	str	r5, [r0, #36]	; 0x24

    p_tcb->TaskEntryAddr      = (OS_TASK_PTR    )0;
 8006f70:	6285      	str	r5, [r0, #40]	; 0x28
    p_tcb->TaskEntryArg       = (void          *)0;
 8006f72:	62c5      	str	r5, [r0, #44]	; 0x2c

#if (OS_CFG_PEND_MULTI_EN > 0u)
    p_tcb->PendDataTblPtr     = (OS_PEND_DATA  *)0;
 8006f74:	6305      	str	r5, [r0, #48]	; 0x30
    p_tcb->PendDataTblEntries = (OS_OBJ_QTY     )0u;
 8006f76:	87c5      	strh	r5, [r0, #62]	; 0x3e
#endif

    p_tcb->TS                 = (CPU_TS         )0u;
 8006f78:	6405      	str	r5, [r0, #64]	; 0x40

#if (OS_MSG_EN > 0u)
    p_tcb->MsgPtr             = (void          *)0;
 8006f7a:	65c5      	str	r5, [r0, #92]	; 0x5c
    p_tcb->MsgSize            = (OS_MSG_SIZE    )0u;
 8006f7c:	f8a0 5060 	strh.w	r5, [r0, #96]	; 0x60
#endif

#if OS_CFG_TASK_Q_EN > 0u
    OS_MsgQInit(&p_tcb->MsgQ,
 8006f80:	4629      	mov	r1, r5
 8006f82:	3064      	adds	r0, #100	; 0x64
 8006f84:	f7fe f94a 	bl	800521c <OS_MsgQInit>
    p_tcb->StkUsed            = (CPU_STK_SIZE   )0u;
#endif

    p_tcb->Opt                = (OS_OPT         )0u;

    p_tcb->TickCtrPrev        = (OS_TICK        )OS_TICK_TH_INIT;
 8006f88:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 8006f8c:	64a3      	str	r3, [r4, #72]	; 0x48

#if OS_CFG_TASK_Q_EN > 0u
    OS_MsgQInit(&p_tcb->MsgQ,
                (OS_MSG_QTY)0u);
#if OS_CFG_TASK_PROFILE_EN > 0u
    p_tcb->MsgQPendTime       = (CPU_TS         )0u;
 8006f8e:	6765      	str	r5, [r4, #116]	; 0x74
    p_tcb->MsgQPendTimeMax    = (CPU_TS         )0u;
 8006f90:	67a5      	str	r5, [r4, #120]	; 0x78
#endif
#endif

#if OS_CFG_FLAG_EN > 0u
    p_tcb->FlagsPend          = (OS_FLAGS       )0u;
 8006f92:	f8c4 5080 	str.w	r5, [r4, #128]	; 0x80
    p_tcb->FlagsOpt           = (OS_OPT         )0u;
 8006f96:	f8a4 5088 	strh.w	r5, [r4, #136]	; 0x88
    p_tcb->FlagsRdy           = (OS_FLAGS       )0u;
 8006f9a:	f8c4 5084 	str.w	r5, [r4, #132]	; 0x84
#endif

#if OS_CFG_TASK_REG_TBL_SIZE > 0u
    for (reg_id = 0u; reg_id < OS_CFG_TASK_REG_TBL_SIZE; reg_id++) {
        p_tcb->RegTbl[reg_id] = (OS_REG)0u;
 8006f9e:	67e5      	str	r5, [r4, #124]	; 0x7c
    for (id = 0u; id < OS_CFG_TLS_TBL_SIZE; id++) {
        p_tcb->TLS_Tbl[id]    = (OS_TLS)0;
    }
#endif

    p_tcb->SemCtr             = (OS_SEM_CTR     )0u;
 8006fa0:	6465      	str	r5, [r4, #68]	; 0x44
#if OS_CFG_TASK_PROFILE_EN > 0u
    p_tcb->SemPendTime        = (CPU_TS         )0u;
 8006fa2:	f8c4 50a4 	str.w	r5, [r4, #164]	; 0xa4
    p_tcb->SemPendTimeMax     = (CPU_TS         )0u;
 8006fa6:	f8c4 50a8 	str.w	r5, [r4, #168]	; 0xa8
#endif

    p_tcb->StkSize            = (CPU_STK_SIZE   )0u;
 8006faa:	63a5      	str	r5, [r4, #56]	; 0x38


#if OS_CFG_TASK_SUSPEND_EN > 0u
    p_tcb->SuspendCtr         = (OS_NESTING_CTR )0u;
 8006fac:	f884 508a 	strb.w	r5, [r4, #138]	; 0x8a
#endif

#if OS_CFG_STAT_TASK_STK_CHK_EN > 0u
    p_tcb->StkFree            = (CPU_STK_SIZE   )0u;
 8006fb0:	f8c4 50b0 	str.w	r5, [r4, #176]	; 0xb0
    p_tcb->StkUsed            = (CPU_STK_SIZE   )0u;
 8006fb4:	f8c4 50ac 	str.w	r5, [r4, #172]	; 0xac
#endif

    p_tcb->Opt                = (OS_OPT         )0u;
 8006fb8:	87a5      	strh	r5, [r4, #60]	; 0x3c

    p_tcb->TickCtrPrev        = (OS_TICK        )OS_TICK_TH_INIT;
    p_tcb->TickCtrMatch       = (OS_TICK        )0u;
 8006fba:	64e5      	str	r5, [r4, #76]	; 0x4c
    p_tcb->TickRemain         = (OS_TICK        )0u;
 8006fbc:	6525      	str	r5, [r4, #80]	; 0x50

    p_tcb->TimeQuanta         = (OS_TICK        )0u;
 8006fbe:	6565      	str	r5, [r4, #84]	; 0x54
    p_tcb->TimeQuantaCtr      = (OS_TICK        )0u;
 8006fc0:	65a5      	str	r5, [r4, #88]	; 0x58

#if OS_CFG_TASK_PROFILE_EN > 0u
    p_tcb->CPUUsage           = (OS_CPU_USAGE   )0u;
 8006fc2:	f8a4 508c 	strh.w	r5, [r4, #140]	; 0x8c
    p_tcb->CPUUsageMax        = (OS_CPU_USAGE   )0u;
 8006fc6:	f8a4 508e 	strh.w	r5, [r4, #142]	; 0x8e
    p_tcb->CtxSwCtr           = (OS_CTX_SW_CTR  )0u;
 8006fca:	f8c4 5090 	str.w	r5, [r4, #144]	; 0x90
    p_tcb->CyclesDelta        = (CPU_TS         )0u;
 8006fce:	f8c4 5094 	str.w	r5, [r4, #148]	; 0x94
    ts                        = OS_TS_GET();                /* Read the current timestamp and save                    */
 8006fd2:	f7f9 fddb 	bl	8000b8c <CPU_TS_TmrRd>
    p_tcb->Prio               = (OS_PRIO        )OS_PRIO_INIT;

#if OS_CFG_DBG_EN > 0u
    p_tcb->DbgPrevPtr         = (OS_TCB        *)0;
    p_tcb->DbgNextPtr         = (OS_TCB        *)0;
    p_tcb->DbgNamePtr         = (CPU_CHAR      *)((void *)" ");
 8006fd6:	4b0c      	ldr	r3, [pc, #48]	; (8007008 <OS_TaskInitTCB+0xb4>)

    p_tcb->PendOn             = (OS_STATE       )OS_TASK_PEND_ON_NOTHING;
    p_tcb->PendStatus         = (OS_STATUS      )OS_STATUS_PEND_OK;
    p_tcb->TaskState          = (OS_STATE       )OS_TASK_STATE_RDY;

    p_tcb->Prio               = (OS_PRIO        )OS_PRIO_INIT;
 8006fd8:	223f      	movs	r2, #63	; 0x3f
#endif
#if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
    p_tcb->SchedLockTimeMax   = (CPU_TS         )0u;
#endif

    p_tcb->PendOn             = (OS_STATE       )OS_TASK_PEND_ON_NOTHING;
 8006fda:	f884 5034 	strb.w	r5, [r4, #52]	; 0x34
    p_tcb->PendStatus         = (OS_STATUS      )OS_STATUS_PEND_OK;
 8006fde:	f884 5035 	strb.w	r5, [r4, #53]	; 0x35
    p_tcb->TaskState          = (OS_STATE       )OS_TASK_STATE_RDY;
 8006fe2:	f884 5036 	strb.w	r5, [r4, #54]	; 0x36

    p_tcb->Prio               = (OS_PRIO        )OS_PRIO_INIT;
 8006fe6:	f884 2037 	strb.w	r2, [r4, #55]	; 0x37
    p_tcb->CPUUsage           = (OS_CPU_USAGE   )0u;
    p_tcb->CPUUsageMax        = (OS_CPU_USAGE   )0u;
    p_tcb->CtxSwCtr           = (OS_CTX_SW_CTR  )0u;
    p_tcb->CyclesDelta        = (CPU_TS         )0u;
    ts                        = OS_TS_GET();                /* Read the current timestamp and save                    */
    p_tcb->CyclesStart        = ts;
 8006fea:	f8c4 0098 	str.w	r0, [r4, #152]	; 0x98
    p_tcb->CyclesTotal        = (OS_CYCLES      )0u;
 8006fee:	f8c4 509c 	str.w	r5, [r4, #156]	; 0x9c
#endif
#ifdef CPU_CFG_INT_DIS_MEAS_EN
    p_tcb->IntDisTimeMax      = (CPU_TS         )0u;
#endif
#if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
    p_tcb->SchedLockTimeMax   = (CPU_TS         )0u;
 8006ff2:	f8c4 50b4 	str.w	r5, [r4, #180]	; 0xb4
    p_tcb->TaskState          = (OS_STATE       )OS_TASK_STATE_RDY;

    p_tcb->Prio               = (OS_PRIO        )OS_PRIO_INIT;

#if OS_CFG_DBG_EN > 0u
    p_tcb->DbgPrevPtr         = (OS_TCB        *)0;
 8006ff6:	f8c4 50b8 	str.w	r5, [r4, #184]	; 0xb8
    p_tcb->DbgNextPtr         = (OS_TCB        *)0;
 8006ffa:	f8c4 50bc 	str.w	r5, [r4, #188]	; 0xbc
    p_tcb->DbgNamePtr         = (CPU_CHAR      *)((void *)" ");
 8006ffe:	f8c4 30c0 	str.w	r3, [r4, #192]	; 0xc0
 8007002:	bd38      	pop	{r3, r4, r5, pc}
 8007004:	0801668c 	.word	0x0801668c
 8007008:	080182f0 	.word	0x080182f0

0800700c <OSTaskCreate>:
                    OS_MSG_QTY     q_size,
                    OS_TICK        time_quanta,
                    void          *p_ext,
                    OS_OPT         opt,
                    OS_ERR        *p_err)
{
 800700c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        return;
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* ---------- CANNOT CREATE A TASK FROM AN ISR ---------- */
 8007010:	4c5d      	ldr	r4, [pc, #372]	; (8007188 <OSTaskCreate+0x17c>)
                    OS_MSG_QTY     q_size,
                    OS_TICK        time_quanta,
                    void          *p_ext,
                    OS_OPT         opt,
                    OS_ERR        *p_err)
{
 8007012:	b089      	sub	sp, #36	; 0x24
 8007014:	9e18      	ldr	r6, [sp, #96]	; 0x60
        return;
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* ---------- CANNOT CREATE A TASK FROM AN ISR ---------- */
 8007016:	7825      	ldrb	r5, [r4, #0]
                    OS_MSG_QTY     q_size,
                    OS_TICK        time_quanta,
                    void          *p_ext,
                    OS_OPT         opt,
                    OS_ERR        *p_err)
{
 8007018:	469e      	mov	lr, r3
 800701a:	9603      	str	r6, [sp, #12]
 800701c:	f89d 8048 	ldrb.w	r8, [sp, #72]	; 0x48
 8007020:	9f13      	ldr	r7, [sp, #76]	; 0x4c
 8007022:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8007024:	9c15      	ldr	r4, [sp, #84]	; 0x54
 8007026:	f8bd b058 	ldrh.w	fp, [sp, #88]	; 0x58
 800702a:	f8dd a05c 	ldr.w	sl, [sp, #92]	; 0x5c
 800702e:	f8bd 9064 	ldrh.w	r9, [sp, #100]	; 0x64
 8007032:	9e1a      	ldr	r6, [sp, #104]	; 0x68
        return;
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* ---------- CANNOT CREATE A TASK FROM AN ISR ---------- */
 8007034:	2d00      	cmp	r5, #0
 8007036:	d175      	bne.n	8007124 <OSTaskCreate+0x118>
        return;
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u                                  /* ---------------- VALIDATE ARGUMENTS ------------------ */
    if (p_tcb == (OS_TCB *)0) {                             /* User must supply a valid OS_TCB                        */
 8007038:	2800      	cmp	r0, #0
 800703a:	f000 8092 	beq.w	8007162 <OSTaskCreate+0x156>
       *p_err = OS_ERR_TCB_INVALID;
        return;
    }
    if (p_task == (OS_TASK_PTR)0) {                         /* User must supply a valid task                          */
 800703e:	2a00      	cmp	r2, #0
 8007040:	d07c      	beq.n	800713c <OSTaskCreate+0x130>
       *p_err = OS_ERR_TASK_INVALID;
        return;
    }
    if (p_stk_base == (CPU_STK *)0) {                       /* User must supply a valid stack base address            */
 8007042:	2f00      	cmp	r7, #0
 8007044:	f000 8095 	beq.w	8007172 <OSTaskCreate+0x166>
       *p_err = OS_ERR_STK_INVALID;
        return;
    }
    if (stk_size < OSCfg_StkSizeMin) {                      /* User must supply a valid minimum stack size            */
 8007048:	4d50      	ldr	r5, [pc, #320]	; (800718c <OSTaskCreate+0x180>)
 800704a:	682d      	ldr	r5, [r5, #0]
 800704c:	42a5      	cmp	r5, r4
 800704e:	d879      	bhi.n	8007144 <OSTaskCreate+0x138>
       *p_err = OS_ERR_STK_SIZE_INVALID;
        return;
    }
    if (stk_limit >= stk_size) {                            /* User must supply a valid stack limit                   */
 8007050:	429c      	cmp	r4, r3
 8007052:	d96d      	bls.n	8007130 <OSTaskCreate+0x124>
       *p_err = OS_ERR_STK_LIMIT_INVALID;
        return;
    }
    if (prio >= OS_CFG_PRIO_MAX) {                          /* Priority must be within 0 and OS_CFG_PRIO_MAX-1        */
 8007054:	f1b8 0f3e 	cmp.w	r8, #62	; 0x3e
 8007058:	d87d      	bhi.n	8007156 <OSTaskCreate+0x14a>
            return;
        }
    }
#endif

    if (prio == (OS_CFG_PRIO_MAX - 1u)) {
 800705a:	d079      	beq.n	8007150 <OSTaskCreate+0x144>
 800705c:	9307      	str	r3, [sp, #28]
 800705e:	9204      	str	r2, [sp, #16]
 8007060:	9106      	str	r1, [sp, #24]
 8007062:	f8cd e014 	str.w	lr, [sp, #20]
 8007066:	4605      	mov	r5, r0
           *p_err = OS_ERR_PRIO_INVALID;                    /* Not allowed to use same priority as idle task          */
            return;
        }
    }

    OS_TaskInitTCB(p_tcb);                                  /* Initialize the TCB to default values                   */
 8007068:	f7ff ff74 	bl	8006f54 <OS_TaskInitTCB>

   *p_err = OS_ERR_NONE;
                                                            /* --------------- CLEAR THE TASK'S STACK --------------- */
    if ((opt & OS_OPT_TASK_STK_CHK) != (OS_OPT)0) {         /* See if stack checking has been enabled                 */
        if ((opt & OS_OPT_TASK_STK_CLR) != (OS_OPT)0) {     /* See if stack needs to be cleared                       */
 800706c:	f009 0103 	and.w	r1, r9, #3
        }
    }

    OS_TaskInitTCB(p_tcb);                                  /* Initialize the TCB to default values                   */

   *p_err = OS_ERR_NONE;
 8007070:	2200      	movs	r2, #0
                                                            /* --------------- CLEAR THE TASK'S STACK --------------- */
    if ((opt & OS_OPT_TASK_STK_CHK) != (OS_OPT)0) {         /* See if stack checking has been enabled                 */
        if ((opt & OS_OPT_TASK_STK_CLR) != (OS_OPT)0) {     /* See if stack needs to be cleared                       */
 8007072:	2903      	cmp	r1, #3
        }
    }

    OS_TaskInitTCB(p_tcb);                                  /* Initialize the TCB to default values                   */

   *p_err = OS_ERR_NONE;
 8007074:	8032      	strh	r2, [r6, #0]
                                                            /* --------------- CLEAR THE TASK'S STACK --------------- */
    if ((opt & OS_OPT_TASK_STK_CHK) != (OS_OPT)0) {         /* See if stack checking has been enabled                 */
        if ((opt & OS_OPT_TASK_STK_CLR) != (OS_OPT)0) {     /* See if stack needs to be cleared                       */
 8007076:	9b07      	ldr	r3, [sp, #28]
 8007078:	d107      	bne.n	800708a <OSTaskCreate+0x7e>
            p_sp = p_stk_base;
            for (i = 0u; i < stk_size; i++) {               /* Stack grows from HIGH to LOW memory                    */
 800707a:	b134      	cbz	r4, 800708a <OSTaskCreate+0x7e>
 800707c:	4639      	mov	r1, r7
               *p_sp = (CPU_STK)0;                          /* Clear from bottom of stack and up!                     */
 800707e:	4610      	mov	r0, r2
   *p_err = OS_ERR_NONE;
                                                            /* --------------- CLEAR THE TASK'S STACK --------------- */
    if ((opt & OS_OPT_TASK_STK_CHK) != (OS_OPT)0) {         /* See if stack checking has been enabled                 */
        if ((opt & OS_OPT_TASK_STK_CLR) != (OS_OPT)0) {     /* See if stack needs to be cleared                       */
            p_sp = p_stk_base;
            for (i = 0u; i < stk_size; i++) {               /* Stack grows from HIGH to LOW memory                    */
 8007080:	3201      	adds	r2, #1
 8007082:	4294      	cmp	r4, r2
               *p_sp = (CPU_STK)0;                          /* Clear from bottom of stack and up!                     */
 8007084:	f841 0b04 	str.w	r0, [r1], #4
   *p_err = OS_ERR_NONE;
                                                            /* --------------- CLEAR THE TASK'S STACK --------------- */
    if ((opt & OS_OPT_TASK_STK_CHK) != (OS_OPT)0) {         /* See if stack checking has been enabled                 */
        if ((opt & OS_OPT_TASK_STK_CLR) != (OS_OPT)0) {     /* See if stack needs to be cleared                       */
            p_sp = p_stk_base;
            for (i = 0u; i < stk_size; i++) {               /* Stack grows from HIGH to LOW memory                    */
 8007088:	d1fa      	bne.n	8007080 <OSTaskCreate+0x74>
            }
        }
    }
                                                            /* ------- INITIALIZE THE STACK FRAME OF THE TASK ------- */
#if (CPU_CFG_STK_GROWTH == CPU_STK_GROWTH_HI_TO_LO)
    p_stk_limit = p_stk_base + stk_limit;
 800708a:	eb07 0683 	add.w	r6, r7, r3, lsl #2
#else
    p_stk_limit = p_stk_base + (stk_size - 1u) - stk_limit;
#endif

    p_sp = OSTaskStkInit(p_task,
 800708e:	4633      	mov	r3, r6
 8007090:	e88d 0210 	stmia.w	sp, {r4, r9}
 8007094:	463a      	mov	r2, r7
 8007096:	9905      	ldr	r1, [sp, #20]
 8007098:	9804      	ldr	r0, [sp, #16]
 800709a:	f7fd fc33 	bl	8004904 <OSTaskStkInit>
                         p_stk_limit,
                         stk_size,
                         opt);

                                                            /* -------------- INITIALIZE THE TCB FIELDS ------------- */
    p_tcb->TaskEntryAddr = p_task;                          /* Save task entry point address                          */
 800709e:	9b04      	ldr	r3, [sp, #16]
    p_tcb->NamePtr       = p_name;                          /* Save task name                                         */

    p_tcb->Prio          = prio;                            /* Save the task's priority                               */

    p_tcb->StkPtr        = p_sp;                            /* Save the new top-of-stack pointer                      */
    p_tcb->StkLimitPtr   = p_stk_limit;                     /* Save the stack limit pointer                           */
 80070a0:	60ae      	str	r6, [r5, #8]
                         p_stk_limit,
                         stk_size,
                         opt);

                                                            /* -------------- INITIALIZE THE TCB FIELDS ------------- */
    p_tcb->TaskEntryAddr = p_task;                          /* Save task entry point address                          */
 80070a2:	62ab      	str	r3, [r5, #40]	; 0x28
    p_tcb->TaskEntryArg  = p_arg;                           /* Save task entry argument                               */
 80070a4:	9b05      	ldr	r3, [sp, #20]

    p_tcb->NamePtr       = p_name;                          /* Save task name                                         */

    p_tcb->Prio          = prio;                            /* Save the task's priority                               */

    p_tcb->StkPtr        = p_sp;                            /* Save the new top-of-stack pointer                      */
 80070a6:	6028      	str	r0, [r5, #0]
                         stk_size,
                         opt);

                                                            /* -------------- INITIALIZE THE TCB FIELDS ------------- */
    p_tcb->TaskEntryAddr = p_task;                          /* Save task entry point address                          */
    p_tcb->TaskEntryArg  = p_arg;                           /* Save task entry argument                               */
 80070a8:	62eb      	str	r3, [r5, #44]	; 0x2c

    p_tcb->NamePtr       = p_name;                          /* Save task name                                         */
 80070aa:	9b06      	ldr	r3, [sp, #24]

    p_tcb->Prio          = prio;                            /* Save the task's priority                               */
 80070ac:	f885 8037 	strb.w	r8, [r5, #55]	; 0x37

                                                            /* -------------- INITIALIZE THE TCB FIELDS ------------- */
    p_tcb->TaskEntryAddr = p_task;                          /* Save task entry point address                          */
    p_tcb->TaskEntryArg  = p_arg;                           /* Save task entry argument                               */

    p_tcb->NamePtr       = p_name;                          /* Save task name                                         */
 80070b0:	622b      	str	r3, [r5, #32]
    p_tcb->Prio          = prio;                            /* Save the task's priority                               */

    p_tcb->StkPtr        = p_sp;                            /* Save the new top-of-stack pointer                      */
    p_tcb->StkLimitPtr   = p_stk_limit;                     /* Save the stack limit pointer                           */

    p_tcb->TimeQuanta    = time_quanta;                     /* Save the #ticks for time slice (0 means not sliced)    */
 80070b2:	f8c5 a054 	str.w	sl, [r5, #84]	; 0x54
#if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
    if (time_quanta == (OS_TICK)0) {
 80070b6:	f1ba 0f00 	cmp.w	sl, #0
 80070ba:	d056      	beq.n	800716a <OSTaskCreate+0x15e>
        p_tcb->TimeQuantaCtr = OSSchedRoundRobinDfltTimeQuanta;
    } else {
        p_tcb->TimeQuantaCtr = time_quanta;
 80070bc:	f8c5 a058 	str.w	sl, [r5, #88]	; 0x58
    }
#endif
    p_tcb->ExtPtr        = p_ext;                           /* Save pointer to TCB extension                          */
 80070c0:	9b03      	ldr	r3, [sp, #12]
    p_tcb->StkSize       = stk_size;                        /* Save the stack size (in number of CPU_STK elements)    */
    p_tcb->Opt           = opt;                             /* Save task options                                      */

#if OS_CFG_TASK_REG_TBL_SIZE > 0u
    for (reg_nbr = 0u; reg_nbr < OS_CFG_TASK_REG_TBL_SIZE; reg_nbr++) {
        p_tcb->RegTbl[reg_nbr] = (OS_REG)0;
 80070c2:	2600      	movs	r6, #0
        p_tcb->TimeQuantaCtr = OSSchedRoundRobinDfltTimeQuanta;
    } else {
        p_tcb->TimeQuantaCtr = time_quanta;
    }
#endif
    p_tcb->ExtPtr        = p_ext;                           /* Save pointer to TCB extension                          */
 80070c4:	606b      	str	r3, [r5, #4]
        p_tcb->RegTbl[reg_nbr] = (OS_REG)0;
    }
#endif

#if OS_CFG_TASK_Q_EN > 0u
    OS_MsgQInit(&p_tcb->MsgQ,                               /* Initialize the task's message queue                    */
 80070c6:	4659      	mov	r1, fp
        p_tcb->TimeQuantaCtr = time_quanta;
    }
#endif
    p_tcb->ExtPtr        = p_ext;                           /* Save pointer to TCB extension                          */
    p_tcb->StkBasePtr    = p_stk_base;                      /* Save pointer to the base address of the stack          */
    p_tcb->StkSize       = stk_size;                        /* Save the stack size (in number of CPU_STK elements)    */
 80070c8:	63ac      	str	r4, [r5, #56]	; 0x38
        p_tcb->RegTbl[reg_nbr] = (OS_REG)0;
    }
#endif

#if OS_CFG_TASK_Q_EN > 0u
    OS_MsgQInit(&p_tcb->MsgQ,                               /* Initialize the task's message queue                    */
 80070ca:	f105 0064 	add.w	r0, r5, #100	; 0x64
    } else {
        p_tcb->TimeQuantaCtr = time_quanta;
    }
#endif
    p_tcb->ExtPtr        = p_ext;                           /* Save pointer to TCB extension                          */
    p_tcb->StkBasePtr    = p_stk_base;                      /* Save pointer to the base address of the stack          */
 80070ce:	626f      	str	r7, [r5, #36]	; 0x24
    p_tcb->StkSize       = stk_size;                        /* Save the stack size (in number of CPU_STK elements)    */
    p_tcb->Opt           = opt;                             /* Save task options                                      */
 80070d0:	f8a5 903c 	strh.w	r9, [r5, #60]	; 0x3c

#if OS_CFG_TASK_REG_TBL_SIZE > 0u
    for (reg_nbr = 0u; reg_nbr < OS_CFG_TASK_REG_TBL_SIZE; reg_nbr++) {
        p_tcb->RegTbl[reg_nbr] = (OS_REG)0;
 80070d4:	67ee      	str	r6, [r5, #124]	; 0x7c
    }
#endif

#if OS_CFG_TASK_Q_EN > 0u
    OS_MsgQInit(&p_tcb->MsgQ,                               /* Initialize the task's message queue                    */
 80070d6:	f7fe f8a1 	bl	800521c <OS_MsgQInit>
                q_size);
#else
    (void)&q_size;
#endif

    OSTaskCreateHook(p_tcb);                                /* Call user defined hook                                 */
 80070da:	4628      	mov	r0, r5
 80070dc:	f7fd fbfa 	bl	80048d4 <OSTaskCreateHook>
        p_tcb->TLS_Tbl[id] = (OS_TLS)0;
    }
    OS_TLS_TaskCreate(p_tcb);                               /* Call TLS hook                                          */
#endif
                                                            /* --------------- ADD TASK TO READY LIST --------------- */
    OS_CRITICAL_ENTER();
 80070e0:	f7fa fb48 	bl	8001774 <CPU_SR_Save>
 80070e4:	4604      	mov	r4, r0
    OS_PrioInsert(p_tcb->Prio);
 80070e6:	f895 0037 	ldrb.w	r0, [r5, #55]	; 0x37
 80070ea:	f7fe fb65 	bl	80057b8 <OS_PrioInsert>
    OS_RdyListInsertTail(p_tcb);
 80070ee:	4628      	mov	r0, r5
 80070f0:	f7fd f89a 	bl	8004228 <OS_RdyListInsertTail>

#if OS_CFG_DBG_EN > 0u
void  OS_TaskDbgListAdd (OS_TCB  *p_tcb)
{
    p_tcb->DbgPrevPtr                = (OS_TCB *)0;
    if (OSTaskDbgListPtr == (OS_TCB *)0) {
 80070f4:	4926      	ldr	r1, [pc, #152]	; (8007190 <OSTaskCreate+0x184>)
*/

#if OS_CFG_DBG_EN > 0u
void  OS_TaskDbgListAdd (OS_TCB  *p_tcb)
{
    p_tcb->DbgPrevPtr                = (OS_TCB *)0;
 80070f6:	f8c5 60b8 	str.w	r6, [r5, #184]	; 0xb8
    if (OSTaskDbgListPtr == (OS_TCB *)0) {
 80070fa:	680b      	ldr	r3, [r1, #0]
        p_tcb->DbgNextPtr            = (OS_TCB *)0;
 80070fc:	f8c5 30bc 	str.w	r3, [r5, #188]	; 0xbc

#if OS_CFG_DBG_EN > 0u
void  OS_TaskDbgListAdd (OS_TCB  *p_tcb)
{
    p_tcb->DbgPrevPtr                = (OS_TCB *)0;
    if (OSTaskDbgListPtr == (OS_TCB *)0) {
 8007100:	b10b      	cbz	r3, 8007106 <OSTaskCreate+0xfa>
        p_tcb->DbgNextPtr            = (OS_TCB *)0;
    } else {
        p_tcb->DbgNextPtr            =  OSTaskDbgListPtr;
        OSTaskDbgListPtr->DbgPrevPtr =  p_tcb;
 8007102:	f8c3 50b8 	str.w	r5, [r3, #184]	; 0xb8

#if OS_CFG_DBG_EN > 0u
    OS_TaskDbgListAdd(p_tcb);
#endif

    OSTaskQty++;                                            /* Increment the #tasks counter                           */
 8007106:	4a23      	ldr	r2, [pc, #140]	; (8007194 <OSTaskCreate+0x188>)

    if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Return if multitasking has not started                 */
 8007108:	4823      	ldr	r0, [pc, #140]	; (8007198 <OSTaskCreate+0x18c>)

#if OS_CFG_DBG_EN > 0u
    OS_TaskDbgListAdd(p_tcb);
#endif

    OSTaskQty++;                                            /* Increment the #tasks counter                           */
 800710a:	8813      	ldrh	r3, [r2, #0]

    if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Return if multitasking has not started                 */
 800710c:	7800      	ldrb	r0, [r0, #0]

#if OS_CFG_DBG_EN > 0u
    OS_TaskDbgListAdd(p_tcb);
#endif

    OSTaskQty++;                                            /* Increment the #tasks counter                           */
 800710e:	3301      	adds	r3, #1

    if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Return if multitasking has not started                 */
 8007110:	2801      	cmp	r0, #1
        p_tcb->DbgNextPtr            = (OS_TCB *)0;
    } else {
        p_tcb->DbgNextPtr            =  OSTaskDbgListPtr;
        OSTaskDbgListPtr->DbgPrevPtr =  p_tcb;
    }
    OSTaskDbgListPtr                 =  p_tcb;
 8007112:	600d      	str	r5, [r1, #0]

#if OS_CFG_DBG_EN > 0u
    OS_TaskDbgListAdd(p_tcb);
#endif

    OSTaskQty++;                                            /* Increment the #tasks counter                           */
 8007114:	8013      	strh	r3, [r2, #0]

    if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Return if multitasking has not started                 */
        OS_CRITICAL_EXIT();
 8007116:	4620      	mov	r0, r4
    OS_TaskDbgListAdd(p_tcb);
#endif

    OSTaskQty++;                                            /* Increment the #tasks counter                           */

    if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Return if multitasking has not started                 */
 8007118:	d02f      	beq.n	800717a <OSTaskCreate+0x16e>
    }

    OS_CRITICAL_EXIT_NO_SCHED();

    OSSched();
}
 800711a:	b009      	add	sp, #36	; 0x24
 800711c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#endif

    OSTaskQty++;                                            /* Increment the #tasks counter                           */

    if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Return if multitasking has not started                 */
        OS_CRITICAL_EXIT();
 8007120:	f7fa bb2c 	b.w	800177c <CPU_SR_Restore>
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* ---------- CANNOT CREATE A TASK FROM AN ISR ---------- */
       *p_err = OS_ERR_TASK_CREATE_ISR;
 8007124:	f247 134a 	movw	r3, #29002	; 0x714a
 8007128:	8033      	strh	r3, [r6, #0]
    }

    OS_CRITICAL_EXIT_NO_SCHED();

    OSSched();
}
 800712a:	b009      	add	sp, #36	; 0x24
 800712c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (stk_size < OSCfg_StkSizeMin) {                      /* User must supply a valid minimum stack size            */
       *p_err = OS_ERR_STK_SIZE_INVALID;
        return;
    }
    if (stk_limit >= stk_size) {                            /* User must supply a valid stack limit                   */
       *p_err = OS_ERR_STK_LIMIT_INVALID;
 8007130:	f646 6331 	movw	r3, #28209	; 0x6e31
 8007134:	8033      	strh	r3, [r6, #0]
    }

    OS_CRITICAL_EXIT_NO_SCHED();

    OSSched();
}
 8007136:	b009      	add	sp, #36	; 0x24
 8007138:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (p_tcb == (OS_TCB *)0) {                             /* User must supply a valid OS_TCB                        */
       *p_err = OS_ERR_TCB_INVALID;
        return;
    }
    if (p_task == (OS_TASK_PTR)0) {                         /* User must supply a valid task                          */
       *p_err = OS_ERR_TASK_INVALID;
 800713c:	f247 134f 	movw	r3, #29007	; 0x714f
 8007140:	8033      	strh	r3, [r6, #0]
        return;
 8007142:	e7f2      	b.n	800712a <OSTaskCreate+0x11e>
    if (p_stk_base == (CPU_STK *)0) {                       /* User must supply a valid stack base address            */
       *p_err = OS_ERR_STK_INVALID;
        return;
    }
    if (stk_size < OSCfg_StkSizeMin) {                      /* User must supply a valid minimum stack size            */
       *p_err = OS_ERR_STK_SIZE_INVALID;
 8007144:	f646 6330 	movw	r3, #28208	; 0x6e30
 8007148:	8033      	strh	r3, [r6, #0]
    }

    OS_CRITICAL_EXIT_NO_SCHED();

    OSSched();
}
 800714a:	b009      	add	sp, #36	; 0x24
 800714c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        }
    }
#endif

    if (prio == (OS_CFG_PRIO_MAX - 1u)) {
        if (p_tcb != &OSIdleTaskTCB) {
 8007150:	4d12      	ldr	r5, [pc, #72]	; (800719c <OSTaskCreate+0x190>)
 8007152:	42a8      	cmp	r0, r5
 8007154:	d082      	beq.n	800705c <OSTaskCreate+0x50>
    if (stk_limit >= stk_size) {                            /* User must supply a valid stack limit                   */
       *p_err = OS_ERR_STK_LIMIT_INVALID;
        return;
    }
    if (prio >= OS_CFG_PRIO_MAX) {                          /* Priority must be within 0 and OS_CFG_PRIO_MAX-1        */
       *p_err = OS_ERR_PRIO_INVALID;
 8007156:	f246 2373 	movw	r3, #25203	; 0x6273
 800715a:	8033      	strh	r3, [r6, #0]
    }

    OS_CRITICAL_EXIT_NO_SCHED();

    OSSched();
}
 800715c:	b009      	add	sp, #36	; 0x24
 800715e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u                                  /* ---------------- VALIDATE ARGUMENTS ------------------ */
    if (p_tcb == (OS_TCB *)0) {                             /* User must supply a valid OS_TCB                        */
       *p_err = OS_ERR_TCB_INVALID;
 8007162:	f247 13ad 	movw	r3, #29101	; 0x71ad
 8007166:	8033      	strh	r3, [r6, #0]
        return;
 8007168:	e7df      	b.n	800712a <OSTaskCreate+0x11e>
    p_tcb->StkLimitPtr   = p_stk_limit;                     /* Save the stack limit pointer                           */

    p_tcb->TimeQuanta    = time_quanta;                     /* Save the #ticks for time slice (0 means not sliced)    */
#if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
    if (time_quanta == (OS_TICK)0) {
        p_tcb->TimeQuantaCtr = OSSchedRoundRobinDfltTimeQuanta;
 800716a:	4b0d      	ldr	r3, [pc, #52]	; (80071a0 <OSTaskCreate+0x194>)
 800716c:	681b      	ldr	r3, [r3, #0]
 800716e:	65ab      	str	r3, [r5, #88]	; 0x58
 8007170:	e7a6      	b.n	80070c0 <OSTaskCreate+0xb4>
    if (p_task == (OS_TASK_PTR)0) {                         /* User must supply a valid task                          */
       *p_err = OS_ERR_TASK_INVALID;
        return;
    }
    if (p_stk_base == (CPU_STK *)0) {                       /* User must supply a valid stack base address            */
       *p_err = OS_ERR_STK_INVALID;
 8007172:	f646 632f 	movw	r3, #28207	; 0x6e2f
 8007176:	8033      	strh	r3, [r6, #0]
        return;
 8007178:	e7d7      	b.n	800712a <OSTaskCreate+0x11e>
    if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Return if multitasking has not started                 */
        OS_CRITICAL_EXIT();
        return;
    }

    OS_CRITICAL_EXIT_NO_SCHED();
 800717a:	f7fa faff 	bl	800177c <CPU_SR_Restore>

    OSSched();
}
 800717e:	b009      	add	sp, #36	; 0x24
 8007180:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        return;
    }

    OS_CRITICAL_EXIT_NO_SCHED();

    OSSched();
 8007184:	f7fc bcd0 	b.w	8003b28 <OSSched>
 8007188:	2000ed84 	.word	0x2000ed84
 800718c:	080160d0 	.word	0x080160d0
 8007190:	2000ed6c 	.word	0x2000ed6c
 8007194:	2000ed86 	.word	0x2000ed86
 8007198:	2000e985 	.word	0x2000e985
 800719c:	2000ee58 	.word	0x2000ee58
 80071a0:	2000ef28 	.word	0x2000ef28

080071a4 <OSTaskDel.part.0>:
*                 accessed by another task.
************************************************************************************************************************
*/

#if OS_CFG_TASK_DEL_EN > 0u
void  OSTaskDel (OS_TCB  *p_tcb,
 80071a4:	b570      	push	{r4, r5, r6, lr}
 80071a6:	460d      	mov	r5, r1
 80071a8:	4604      	mov	r4, r0
       *p_err = OS_ERR_TASK_DEL_INVALID;
        return;
    }
#endif

    if (p_tcb == (OS_TCB *)0) {                             /* Delete 'Self'?                                         */
 80071aa:	2800      	cmp	r0, #0
 80071ac:	d063      	beq.n	8007276 <OSTaskDel.part.0+0xd2>
        CPU_CRITICAL_ENTER();
        p_tcb  = OSTCBCurPtr;                               /* Yes.                                                   */
        CPU_CRITICAL_EXIT();
    }

    OS_CRITICAL_ENTER();
 80071ae:	f7fa fae1 	bl	8001774 <CPU_SR_Save>
    switch (p_tcb->TaskState) {
 80071b2:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
        CPU_CRITICAL_ENTER();
        p_tcb  = OSTCBCurPtr;                               /* Yes.                                                   */
        CPU_CRITICAL_EXIT();
    }

    OS_CRITICAL_ENTER();
 80071b6:	4606      	mov	r6, r0
    switch (p_tcb->TaskState) {
 80071b8:	2b07      	cmp	r3, #7
 80071ba:	d848      	bhi.n	800724e <OSTaskDel.part.0+0xaa>
 80071bc:	e8df f003 	tbb	[pc, r3]
 80071c0:	32320443 	.word	0x32320443
 80071c4:	32320407 	.word	0x32320407
        case OS_TASK_STATE_SUSPENDED:
             break;

        case OS_TASK_STATE_DLY:                             /* Task is only delayed, not on any wait list             */
        case OS_TASK_STATE_DLY_SUSPENDED:
             OS_TickListRemove(p_tcb);
 80071c8:	4620      	mov	r0, r4
 80071ca:	f000 fb73 	bl	80078b4 <OS_TickListRemove>
           *p_err = OS_ERR_STATE_INVALID;
            return;
    }

#if OS_CFG_TASK_Q_EN > 0u
    (void)OS_MsgQFreeAll(&p_tcb->MsgQ);                     /* Free task's message queue messages                     */
 80071ce:	f104 0064 	add.w	r0, r4, #100	; 0x64
 80071d2:	f7fe f809 	bl	80051e8 <OS_MsgQFreeAll>
#endif

    OSTaskDelHook(p_tcb);                                   /* Call user defined hook                                 */
 80071d6:	4620      	mov	r0, r4
 80071d8:	f7fd fb84 	bl	80048e4 <OSTaskDelHook>
{
    OS_TCB  *p_tcb_next;
    OS_TCB  *p_tcb_prev;


    p_tcb_prev = p_tcb->DbgPrevPtr;
 80071dc:	f8d4 20b8 	ldr.w	r2, [r4, #184]	; 0xb8
    p_tcb_next = p_tcb->DbgNextPtr;
 80071e0:	f8d4 30bc 	ldr.w	r3, [r4, #188]	; 0xbc

    if (p_tcb_prev == (OS_TCB *)0) {
 80071e4:	2a00      	cmp	r2, #0
 80071e6:	d038      	beq.n	800725a <OSTaskDel.part.0+0xb6>
        if (p_tcb_next != (OS_TCB *)0) {
            p_tcb_next->DbgPrevPtr = (OS_TCB *)0;
        }
        p_tcb->DbgNextPtr = (OS_TCB *)0;

    } else if (p_tcb_next == (OS_TCB *)0) {
 80071e8:	2b00      	cmp	r3, #0
 80071ea:	d03f      	beq.n	800726c <OSTaskDel.part.0+0xc8>
        p_tcb->DbgPrevPtr      = (OS_TCB *)0;

    } else {
        p_tcb_prev->DbgNextPtr =  p_tcb_next;
        p_tcb_next->DbgPrevPtr =  p_tcb_prev;
        p_tcb->DbgNextPtr      = (OS_TCB *)0;
 80071ec:	2100      	movs	r1, #0
    } else if (p_tcb_next == (OS_TCB *)0) {
        p_tcb_prev->DbgNextPtr = (OS_TCB *)0;
        p_tcb->DbgPrevPtr      = (OS_TCB *)0;

    } else {
        p_tcb_prev->DbgNextPtr =  p_tcb_next;
 80071ee:	f8c2 30bc 	str.w	r3, [r2, #188]	; 0xbc
        p_tcb_next->DbgPrevPtr =  p_tcb_prev;
 80071f2:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
        p_tcb->DbgNextPtr      = (OS_TCB *)0;
 80071f6:	f8c4 10bc 	str.w	r1, [r4, #188]	; 0xbc
        p_tcb->DbgPrevPtr      = (OS_TCB *)0;
 80071fa:	f8c4 10b8 	str.w	r1, [r4, #184]	; 0xb8
#endif

#if OS_CFG_DBG_EN > 0u
    OS_TaskDbgListRemove(p_tcb);
#endif
    OSTaskQty--;                                            /* One less task being managed                            */
 80071fe:	4a21      	ldr	r2, [pc, #132]	; (8007284 <OSTaskDel.part.0+0xe0>)

    OS_TaskInitTCB(p_tcb);                                  /* Initialize the TCB to default values                   */
 8007200:	4620      	mov	r0, r4
#endif

#if OS_CFG_DBG_EN > 0u
    OS_TaskDbgListRemove(p_tcb);
#endif
    OSTaskQty--;                                            /* One less task being managed                            */
 8007202:	8813      	ldrh	r3, [r2, #0]
 8007204:	3b01      	subs	r3, #1
 8007206:	8013      	strh	r3, [r2, #0]

    OS_TaskInitTCB(p_tcb);                                  /* Initialize the TCB to default values                   */
 8007208:	f7ff fea4 	bl	8006f54 <OS_TaskInitTCB>
    p_tcb->TaskState = (OS_STATE)OS_TASK_STATE_DEL;         /* Indicate that the task was deleted                     */
 800720c:	23ff      	movs	r3, #255	; 0xff
 800720e:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36

    OS_CRITICAL_EXIT_NO_SCHED();
 8007212:	4630      	mov	r0, r6
 8007214:	f7fa fab2 	bl	800177c <CPU_SR_Restore>

   *p_err = OS_ERR_NONE;                                    /* See Note #1.                                           */
 8007218:	2300      	movs	r3, #0
 800721a:	802b      	strh	r3, [r5, #0]

    OSSched();                                              /* Find new highest priority task                         */
}
 800721c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

    OS_CRITICAL_EXIT_NO_SCHED();

   *p_err = OS_ERR_NONE;                                    /* See Note #1.                                           */

    OSSched();                                              /* Find new highest priority task                         */
 8007220:	f7fc bc82 	b.w	8003b28 <OSSched>

        case OS_TASK_STATE_PEND:
        case OS_TASK_STATE_PEND_SUSPENDED:
        case OS_TASK_STATE_PEND_TIMEOUT:
        case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
             OS_TickListRemove(p_tcb);
 8007224:	4620      	mov	r0, r4
 8007226:	f000 fb45 	bl	80078b4 <OS_TickListRemove>
             switch (p_tcb->PendOn) {                       /* See what we are pending on                             */
 800722a:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
 800722e:	2b06      	cmp	r3, #6
 8007230:	d8cd      	bhi.n	80071ce <OSTaskDel.part.0+0x2a>
 8007232:	2201      	movs	r2, #1
 8007234:	fa02 f303 	lsl.w	r3, r2, r3
 8007238:	f013 0f7a 	tst.w	r3, #122	; 0x7a
 800723c:	d0c7      	beq.n	80071ce <OSTaskDel.part.0+0x2a>
                 case OS_TASK_PEND_ON_FLAG:                 /* Remove from wait list                                  */
                 case OS_TASK_PEND_ON_MULTI:
                 case OS_TASK_PEND_ON_MUTEX:
                 case OS_TASK_PEND_ON_Q:
                 case OS_TASK_PEND_ON_SEM:
                      OS_PendListRemove(p_tcb);
 800723e:	4620      	mov	r0, r4
 8007240:	f7fc ff00 	bl	8004044 <OS_PendListRemove>
 8007244:	e7c3      	b.n	80071ce <OSTaskDel.part.0+0x2a>
    }

    OS_CRITICAL_ENTER();
    switch (p_tcb->TaskState) {
        case OS_TASK_STATE_RDY:
             OS_RdyListRemove(p_tcb);
 8007246:	4620      	mov	r0, r4
 8007248:	f7fd f880 	bl	800434c <OS_RdyListRemove>
 800724c:	e7bf      	b.n	80071ce <OSTaskDel.part.0+0x2a>
                      break;
             }
             break;

        default:
            OS_CRITICAL_EXIT();
 800724e:	f7fa fa95 	bl	800177c <CPU_SR_Restore>
           *p_err = OS_ERR_STATE_INVALID;
 8007252:	f646 632d 	movw	r3, #28205	; 0x6e2d
 8007256:	802b      	strh	r3, [r5, #0]
 8007258:	bd70      	pop	{r4, r5, r6, pc}

    p_tcb_prev = p_tcb->DbgPrevPtr;
    p_tcb_next = p_tcb->DbgNextPtr;

    if (p_tcb_prev == (OS_TCB *)0) {
        OSTaskDbgListPtr = p_tcb_next;
 800725a:	490b      	ldr	r1, [pc, #44]	; (8007288 <OSTaskDel.part.0+0xe4>)
 800725c:	600b      	str	r3, [r1, #0]
        if (p_tcb_next != (OS_TCB *)0) {
 800725e:	b10b      	cbz	r3, 8007264 <OSTaskDel.part.0+0xc0>
            p_tcb_next->DbgPrevPtr = (OS_TCB *)0;
 8007260:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
        }
        p_tcb->DbgNextPtr = (OS_TCB *)0;
 8007264:	2300      	movs	r3, #0
 8007266:	f8c4 30bc 	str.w	r3, [r4, #188]	; 0xbc
 800726a:	e7c8      	b.n	80071fe <OSTaskDel.part.0+0x5a>

    } else if (p_tcb_next == (OS_TCB *)0) {
        p_tcb_prev->DbgNextPtr = (OS_TCB *)0;
 800726c:	f8c2 30bc 	str.w	r3, [r2, #188]	; 0xbc
        p_tcb->DbgPrevPtr      = (OS_TCB *)0;
 8007270:	f8c4 30b8 	str.w	r3, [r4, #184]	; 0xb8
 8007274:	e7c3      	b.n	80071fe <OSTaskDel.part.0+0x5a>
        return;
    }
#endif

    if (p_tcb == (OS_TCB *)0) {                             /* Delete 'Self'?                                         */
        CPU_CRITICAL_ENTER();
 8007276:	f7fa fa7d 	bl	8001774 <CPU_SR_Save>
        p_tcb  = OSTCBCurPtr;                               /* Yes.                                                   */
 800727a:	4b04      	ldr	r3, [pc, #16]	; (800728c <OSTaskDel.part.0+0xe8>)
 800727c:	681c      	ldr	r4, [r3, #0]
        CPU_CRITICAL_EXIT();
 800727e:	f7fa fa7d 	bl	800177c <CPU_SR_Restore>
 8007282:	e794      	b.n	80071ae <OSTaskDel.part.0+0xa>
 8007284:	2000ed86 	.word	0x2000ed86
 8007288:	2000ed6c 	.word	0x2000ed6c
 800728c:	2000ed58 	.word	0x2000ed58

08007290 <OSTaskDel>:
*/

#if OS_CFG_TASK_DEL_EN > 0u
void  OSTaskDel (OS_TCB  *p_tcb,
                 OS_ERR  *p_err)
{
 8007290:	b410      	push	{r4}
        return;
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to delete from ISR                       */
 8007292:	4b08      	ldr	r3, [pc, #32]	; (80072b4 <OSTaskDel+0x24>)
 8007294:	781b      	ldrb	r3, [r3, #0]
 8007296:	b923      	cbnz	r3, 80072a2 <OSTaskDel+0x12>
       *p_err = OS_ERR_TASK_DEL_ISR;
        return;
    }
#endif

    if (p_tcb == &OSIdleTaskTCB) {                          /* Not allowed to delete the idle task                    */
 8007298:	4b07      	ldr	r3, [pc, #28]	; (80072b8 <OSTaskDel+0x28>)
 800729a:	4298      	cmp	r0, r3
 800729c:	d006      	beq.n	80072ac <OSTaskDel+0x1c>
    OS_CRITICAL_EXIT_NO_SCHED();

   *p_err = OS_ERR_NONE;                                    /* See Note #1.                                           */

    OSSched();                                              /* Find new highest priority task                         */
}
 800729e:	bc10      	pop	{r4}
 80072a0:	e780      	b.n	80071a4 <OSTaskDel.part.0>
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to delete from ISR                       */
       *p_err = OS_ERR_TASK_DEL_ISR;
 80072a2:	f247 134e 	movw	r3, #29006	; 0x714e
 80072a6:	800b      	strh	r3, [r1, #0]
    OS_CRITICAL_EXIT_NO_SCHED();

   *p_err = OS_ERR_NONE;                                    /* See Note #1.                                           */

    OSSched();                                              /* Find new highest priority task                         */
}
 80072a8:	bc10      	pop	{r4}
 80072aa:	4770      	bx	lr
        return;
    }
#endif

    if (p_tcb == &OSIdleTaskTCB) {                          /* Not allowed to delete the idle task                    */
       *p_err = OS_ERR_TASK_DEL_IDLE;
 80072ac:	f247 134c 	movw	r3, #29004	; 0x714c
 80072b0:	800b      	strh	r3, [r1, #0]
        return;
 80072b2:	e7f9      	b.n	80072a8 <OSTaskDel+0x18>
 80072b4:	2000ed84 	.word	0x2000ed84
 80072b8:	2000ee58 	.word	0x2000ee58

080072bc <OS_TaskQPost>:
                    void         *p_void,
                    OS_MSG_SIZE   msg_size,
                    OS_OPT        opt,
                    CPU_TS        ts,
                    OS_ERR       *p_err)
{
 80072bc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80072c0:	b082      	sub	sp, #8
 80072c2:	4604      	mov	r4, r0
 80072c4:	460f      	mov	r7, r1
 80072c6:	4690      	mov	r8, r2
 80072c8:	4699      	mov	r9, r3
 80072ca:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
 80072ce:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
    CPU_SR_ALLOC();



    OS_CRITICAL_ENTER();
 80072d0:	f7fa fa50 	bl	8001774 <CPU_SR_Save>
 80072d4:	4606      	mov	r6, r0
    if (p_tcb == (OS_TCB *)0) {                             /* Post msg to 'self'?                                    */
 80072d6:	2c00      	cmp	r4, #0
 80072d8:	d03d      	beq.n	8007356 <OS_TaskQPost+0x9a>
        p_tcb = OSTCBCurPtr;
    }
   *p_err  = OS_ERR_NONE;                                   /* Assume we won't have any errors                        */
 80072da:	2000      	movs	r0, #0
 80072dc:	8028      	strh	r0, [r5, #0]
    switch (p_tcb->TaskState) {
 80072de:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
 80072e2:	2b07      	cmp	r3, #7
 80072e4:	d808      	bhi.n	80072f8 <OS_TaskQPost+0x3c>
 80072e6:	2201      	movs	r2, #1
 80072e8:	fa02 f303 	lsl.w	r3, r2, r3
 80072ec:	f013 0fcc 	tst.w	r3, #204	; 0xcc
 80072f0:	d10b      	bne.n	800730a <OS_TaskQPost+0x4e>
 80072f2:	f013 0f33 	tst.w	r3, #51	; 0x33
 80072f6:	d10c      	bne.n	8007312 <OS_TaskQPost+0x56>
                 OS_CRITICAL_EXIT();
             }
             break;

        default:
             OS_CRITICAL_EXIT();
 80072f8:	4630      	mov	r0, r6
 80072fa:	f7fa fa3f 	bl	800177c <CPU_SR_Restore>
            *p_err = OS_ERR_STATE_INVALID;
 80072fe:	f646 632d 	movw	r3, #28205	; 0x6e2d
 8007302:	802b      	strh	r3, [r5, #0]
             break;
    }
}
 8007304:	b002      	add	sp, #8
 8007306:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

        case OS_TASK_STATE_PEND:
        case OS_TASK_STATE_PEND_TIMEOUT:
        case OS_TASK_STATE_PEND_SUSPENDED:
        case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
             if (p_tcb->PendOn == OS_TASK_PEND_ON_TASK_Q) { /* Is task waiting for a message to be sent to it?        */
 800730a:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
 800730e:	2b02      	cmp	r3, #2
 8007310:	d00f      	beq.n	8007332 <OS_TaskQPost+0x76>
                 OS_CRITICAL_EXIT_NO_SCHED();
                 if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0u) {
                     OSSched();                             /* Run the scheduler                                      */
                 }
             } else {
                 OS_MsgQPut(&p_tcb->MsgQ,                   /* No,  Task is pending on something else ...             */
 8007312:	f104 0064 	add.w	r0, r4, #100	; 0x64
 8007316:	9501      	str	r5, [sp, #4]
 8007318:	f8cd a000 	str.w	sl, [sp]
 800731c:	464b      	mov	r3, r9
 800731e:	4642      	mov	r2, r8
 8007320:	4639      	mov	r1, r7
 8007322:	f7fd ffb1 	bl	8005288 <OS_MsgQPut>
                            p_void,                         /*      ... Deposit the message in the task's queue       */
                            msg_size,
                            opt,
                            ts,
                            p_err);
                 OS_CRITICAL_EXIT();
 8007326:	4630      	mov	r0, r6
        default:
             OS_CRITICAL_EXIT();
            *p_err = OS_ERR_STATE_INVALID;
             break;
    }
}
 8007328:	b002      	add	sp, #8
 800732a:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
                            p_void,                         /*      ... Deposit the message in the task's queue       */
                            msg_size,
                            opt,
                            ts,
                            p_err);
                 OS_CRITICAL_EXIT();
 800732e:	f7fa ba25 	b.w	800177c <CPU_SR_Restore>
        case OS_TASK_STATE_PEND:
        case OS_TASK_STATE_PEND_TIMEOUT:
        case OS_TASK_STATE_PEND_SUSPENDED:
        case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
             if (p_tcb->PendOn == OS_TASK_PEND_ON_TASK_Q) { /* Is task waiting for a message to be sent to it?        */
                 OS_Post((OS_PEND_OBJ *)0,
 8007332:	4643      	mov	r3, r8
 8007334:	463a      	mov	r2, r7
 8007336:	4621      	mov	r1, r4
 8007338:	f8cd a000 	str.w	sl, [sp]
 800733c:	f7fd f9d0 	bl	80046e0 <OS_Post>
                         p_tcb,
                         p_void,
                         msg_size,
                         ts);
                 OS_CRITICAL_EXIT_NO_SCHED();
 8007340:	4630      	mov	r0, r6
 8007342:	f7fa fa1b 	bl	800177c <CPU_SR_Restore>
                 if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0u) {
 8007346:	f419 4f00 	tst.w	r9, #32768	; 0x8000
 800734a:	d1db      	bne.n	8007304 <OS_TaskQPost+0x48>
        default:
             OS_CRITICAL_EXIT();
            *p_err = OS_ERR_STATE_INVALID;
             break;
    }
}
 800734c:	b002      	add	sp, #8
 800734e:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
                         p_void,
                         msg_size,
                         ts);
                 OS_CRITICAL_EXIT_NO_SCHED();
                 if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0u) {
                     OSSched();                             /* Run the scheduler                                      */
 8007352:	f7fc bbe9 	b.w	8003b28 <OSSched>



    OS_CRITICAL_ENTER();
    if (p_tcb == (OS_TCB *)0) {                             /* Post msg to 'self'?                                    */
        p_tcb = OSTCBCurPtr;
 8007356:	4b01      	ldr	r3, [pc, #4]	; (800735c <OS_TaskQPost+0xa0>)
 8007358:	681c      	ldr	r4, [r3, #0]
 800735a:	e7be      	b.n	80072da <OS_TaskQPost+0x1e>
 800735c:	2000ed58 	.word	0x2000ed58

08007360 <OSTaskQPost>:
void  OSTaskQPost (OS_TCB       *p_tcb,
                   void         *p_void,
                   OS_MSG_SIZE   msg_size,
                   OS_OPT        opt,
                   OS_ERR       *p_err)
{
 8007360:	b5f0      	push	{r4, r5, r6, r7, lr}
        return;
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u                                  /* ---------------- VALIDATE ARGUMENTS ------------------ */
    switch (opt) {                                          /* User must supply a valid option                        */
 8007362:	2b10      	cmp	r3, #16
void  OSTaskQPost (OS_TCB       *p_tcb,
                   void         *p_void,
                   OS_MSG_SIZE   msg_size,
                   OS_OPT        opt,
                   OS_ERR       *p_err)
{
 8007364:	b083      	sub	sp, #12
        return;
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u                                  /* ---------------- VALIDATE ARGUMENTS ------------------ */
    switch (opt) {                                          /* User must supply a valid option                        */
 8007366:	d00f      	beq.n	8007388 <OSTaskQPost+0x28>
 8007368:	d90c      	bls.n	8007384 <OSTaskQPost+0x24>
 800736a:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800736e:	d00b      	beq.n	8007388 <OSTaskQPost+0x28>
 8007370:	f248 0410 	movw	r4, #32784	; 0x8010
 8007374:	42a3      	cmp	r3, r4
 8007376:	d007      	beq.n	8007388 <OSTaskQPost+0x28>
        case OS_OPT_POST_FIFO | OS_OPT_POST_NO_SCHED:
        case OS_OPT_POST_LIFO | OS_OPT_POST_NO_SCHED:
             break;

        default:
            *p_err = OS_ERR_OPT_INVALID;
 8007378:	f645 6325 	movw	r3, #24101	; 0x5e25
 800737c:	9a08      	ldr	r2, [sp, #32]
 800737e:	8013      	strh	r3, [r2, #0]
                 p_void,
                 msg_size,
                 opt,
                 ts,
                 p_err);
}
 8007380:	b003      	add	sp, #12
 8007382:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return;
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u                                  /* ---------------- VALIDATE ARGUMENTS ------------------ */
    switch (opt) {                                          /* User must supply a valid option                        */
 8007384:	2b00      	cmp	r3, #0
 8007386:	d1f7      	bne.n	8007378 <OSTaskQPost+0x18>
 8007388:	461c      	mov	r4, r3
 800738a:	4617      	mov	r7, r2
 800738c:	460e      	mov	r6, r1
 800738e:	4605      	mov	r5, r0
            *p_err = OS_ERR_OPT_INVALID;
             return;
    }
#endif

    ts = OS_TS_GET();                                       /* Get timestamp                                          */
 8007390:	f7f9 fbfc 	bl	8000b8c <CPU_TS_TmrRd>
                    (OS_ERR    *)p_err);
        return;
    }
#endif

    OS_TaskQPost(p_tcb,
 8007394:	9b08      	ldr	r3, [sp, #32]
 8007396:	463a      	mov	r2, r7
 8007398:	e88d 0009 	stmia.w	sp, {r0, r3}
 800739c:	4631      	mov	r1, r6
 800739e:	4623      	mov	r3, r4
 80073a0:	4628      	mov	r0, r5
 80073a2:	f7ff ff8b 	bl	80072bc <OS_TaskQPost>
                 p_void,
                 msg_size,
                 opt,
                 ts,
                 p_err);
}
 80073a6:	b003      	add	sp, #12
 80073a8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80073aa:	bf00      	nop

080073ac <OS_TaskResume>:
*/

#if OS_CFG_TASK_SUSPEND_EN > 0u
void  OS_TaskResume (OS_TCB  *p_tcb,
                     OS_ERR  *p_err)
{
 80073ac:	b570      	push	{r4, r5, r6, lr}
 80073ae:	460d      	mov	r5, r1
 80073b0:	4604      	mov	r4, r0
    CPU_SR_ALLOC();


    CPU_CRITICAL_ENTER();
 80073b2:	f7fa f9df 	bl	8001774 <CPU_SR_Save>
   *p_err  = OS_ERR_NONE;
 80073b6:	2300      	movs	r3, #0
 80073b8:	802b      	strh	r3, [r5, #0]
    switch (p_tcb->TaskState) {
 80073ba:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
                     OS_ERR  *p_err)
{
    CPU_SR_ALLOC();


    CPU_CRITICAL_ENTER();
 80073be:	4606      	mov	r6, r0
   *p_err  = OS_ERR_NONE;
    switch (p_tcb->TaskState) {
 80073c0:	2b07      	cmp	r3, #7
 80073c2:	d845      	bhi.n	8007450 <OS_TaskResume+0xa4>
 80073c4:	e8df f003 	tbb	[pc, r3]
 80073c8:	15151515 	.word	0x15151515
 80073cc:	04382c1e 	.word	0x04382c1e
             }
             CPU_CRITICAL_EXIT();
             break;

        case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
             p_tcb->SuspendCtr--;
 80073d0:	f894 308a 	ldrb.w	r3, [r4, #138]	; 0x8a
 80073d4:	3b01      	subs	r3, #1
 80073d6:	b2db      	uxtb	r3, r3
 80073d8:	f884 308a 	strb.w	r3, [r4, #138]	; 0x8a
             if (p_tcb->SuspendCtr == (OS_NESTING_CTR)0) {
 80073dc:	b913      	cbnz	r3, 80073e4 <OS_TaskResume+0x38>
                 p_tcb->TaskState = OS_TASK_STATE_PEND_TIMEOUT;
 80073de:	2303      	movs	r3, #3
 80073e0:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
             }
             CPU_CRITICAL_EXIT();
 80073e4:	4630      	mov	r0, r6
 80073e6:	f7fa f9c9 	bl	800177c <CPU_SR_Restore>
            *p_err = OS_ERR_STATE_INVALID;
             return;
    }

    OSSched();
}
 80073ea:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
             CPU_CRITICAL_EXIT();
            *p_err = OS_ERR_STATE_INVALID;
             return;
    }

    OSSched();
 80073ee:	f7fc bb9b 	b.w	8003b28 <OSSched>
    switch (p_tcb->TaskState) {
        case OS_TASK_STATE_RDY:
        case OS_TASK_STATE_DLY:
        case OS_TASK_STATE_PEND:
        case OS_TASK_STATE_PEND_TIMEOUT:
             CPU_CRITICAL_EXIT();
 80073f2:	f7fa f9c3 	bl	800177c <CPU_SR_Restore>
            *p_err = OS_ERR_TASK_NOT_SUSPENDED;
 80073f6:	f247 1353 	movw	r3, #29011	; 0x7153
 80073fa:	802b      	strh	r3, [r5, #0]
            *p_err = OS_ERR_STATE_INVALID;
             return;
    }

    OSSched();
}
 80073fc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
             CPU_CRITICAL_EXIT();
            *p_err = OS_ERR_STATE_INVALID;
             return;
    }

    OSSched();
 8007400:	f7fc bb92 	b.w	8003b28 <OSSched>
            *p_err = OS_ERR_TASK_NOT_SUSPENDED;
             break;

        case OS_TASK_STATE_SUSPENDED:
             OS_CRITICAL_ENTER_CPU_EXIT();
             p_tcb->SuspendCtr--;
 8007404:	f894 308a 	ldrb.w	r3, [r4, #138]	; 0x8a
 8007408:	3b01      	subs	r3, #1
 800740a:	b2db      	uxtb	r3, r3
 800740c:	f884 308a 	strb.w	r3, [r4, #138]	; 0x8a
             if (p_tcb->SuspendCtr == (OS_NESTING_CTR)0) {
 8007410:	2b00      	cmp	r3, #0
 8007412:	d1e7      	bne.n	80073e4 <OS_TaskResume+0x38>
                 p_tcb->TaskState = OS_TASK_STATE_RDY;
 8007414:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
                 OS_TaskRdy(p_tcb);
 8007418:	4620      	mov	r0, r4
 800741a:	f7fd f883 	bl	8004524 <OS_TaskRdy>
 800741e:	e7e1      	b.n	80073e4 <OS_TaskResume+0x38>
             }
             OS_CRITICAL_EXIT_NO_SCHED();
             break;

        case OS_TASK_STATE_DLY_SUSPENDED:
             p_tcb->SuspendCtr--;
 8007420:	f894 308a 	ldrb.w	r3, [r4, #138]	; 0x8a
 8007424:	3b01      	subs	r3, #1
 8007426:	b2db      	uxtb	r3, r3
 8007428:	f884 308a 	strb.w	r3, [r4, #138]	; 0x8a
             if (p_tcb->SuspendCtr == (OS_NESTING_CTR)0) {
 800742c:	2b00      	cmp	r3, #0
 800742e:	d1d9      	bne.n	80073e4 <OS_TaskResume+0x38>
                 p_tcb->TaskState = OS_TASK_STATE_DLY;
 8007430:	2301      	movs	r3, #1
 8007432:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
 8007436:	e7d5      	b.n	80073e4 <OS_TaskResume+0x38>
             }
             CPU_CRITICAL_EXIT();
             break;

        case OS_TASK_STATE_PEND_SUSPENDED:
             p_tcb->SuspendCtr--;
 8007438:	f894 308a 	ldrb.w	r3, [r4, #138]	; 0x8a
 800743c:	3b01      	subs	r3, #1
 800743e:	b2db      	uxtb	r3, r3
 8007440:	f884 308a 	strb.w	r3, [r4, #138]	; 0x8a
             if (p_tcb->SuspendCtr == (OS_NESTING_CTR)0) {
 8007444:	2b00      	cmp	r3, #0
 8007446:	d1cd      	bne.n	80073e4 <OS_TaskResume+0x38>
                 p_tcb->TaskState = OS_TASK_STATE_PEND;
 8007448:	2302      	movs	r3, #2
 800744a:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
 800744e:	e7c9      	b.n	80073e4 <OS_TaskResume+0x38>
             }
             CPU_CRITICAL_EXIT();
             break;

        default:
             CPU_CRITICAL_EXIT();
 8007450:	f7fa f994 	bl	800177c <CPU_SR_Restore>
            *p_err = OS_ERR_STATE_INVALID;
 8007454:	f646 632d 	movw	r3, #28205	; 0x6e2d
 8007458:	802b      	strh	r3, [r5, #0]
             return;
 800745a:	bd70      	pop	{r4, r5, r6, pc}

0800745c <OSTaskResume>:
*/

#if OS_CFG_TASK_SUSPEND_EN > 0u
void  OSTaskResume (OS_TCB  *p_tcb,
                    OS_ERR  *p_err)
{
 800745c:	b538      	push	{r3, r4, r5, lr}
    }
#endif

#if (OS_CFG_ISR_POST_DEFERRED_EN   == 0u) && \
    (OS_CFG_CALLED_FROM_ISR_CHK_EN >  0u)
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
 800745e:	4b10      	ldr	r3, [pc, #64]	; (80074a0 <OSTaskResume+0x44>)
 8007460:	781b      	ldrb	r3, [r3, #0]
 8007462:	b11b      	cbz	r3, 800746c <OSTaskResume+0x10>
       *p_err = OS_ERR_TASK_RESUME_ISR;
 8007464:	f247 1355 	movw	r3, #29013	; 0x7155
 8007468:	800b      	strh	r3, [r1, #0]
        return;
 800746a:	bd38      	pop	{r3, r4, r5, pc}
 800746c:	460d      	mov	r5, r1
 800746e:	4604      	mov	r4, r0
    }
#endif


    CPU_CRITICAL_ENTER();
 8007470:	f7fa f980 	bl	8001774 <CPU_SR_Save>
 8007474:	4602      	mov	r2, r0
#if OS_CFG_ARG_CHK_EN > 0u
    if ((p_tcb == (OS_TCB *)0) ||                           /* We cannot resume 'self'                                */
 8007476:	b15c      	cbz	r4, 8007490 <OSTaskResume+0x34>
        (p_tcb == OSTCBCurPtr)) {
 8007478:	4b0a      	ldr	r3, [pc, #40]	; (80074a4 <OSTaskResume+0x48>)
#endif


    CPU_CRITICAL_ENTER();
#if OS_CFG_ARG_CHK_EN > 0u
    if ((p_tcb == (OS_TCB *)0) ||                           /* We cannot resume 'self'                                */
 800747a:	681b      	ldr	r3, [r3, #0]
 800747c:	429c      	cmp	r4, r3
 800747e:	d007      	beq.n	8007490 <OSTaskResume+0x34>
        CPU_CRITICAL_EXIT();
       *p_err  = OS_ERR_TASK_RESUME_SELF;
        return;
    }
#endif
    CPU_CRITICAL_EXIT();
 8007480:	f7fa f97c 	bl	800177c <CPU_SR_Restore>
                    (OS_ERR    *)p_err);
        return;
    }
#endif

    OS_TaskResume(p_tcb, p_err);
 8007484:	4629      	mov	r1, r5
 8007486:	4620      	mov	r0, r4
}
 8007488:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
                    (OS_ERR    *)p_err);
        return;
    }
#endif

    OS_TaskResume(p_tcb, p_err);
 800748c:	f7ff bf8e 	b.w	80073ac <OS_TaskResume>

    CPU_CRITICAL_ENTER();
#if OS_CFG_ARG_CHK_EN > 0u
    if ((p_tcb == (OS_TCB *)0) ||                           /* We cannot resume 'self'                                */
        (p_tcb == OSTCBCurPtr)) {
        CPU_CRITICAL_EXIT();
 8007490:	4610      	mov	r0, r2
 8007492:	f7fa f973 	bl	800177c <CPU_SR_Restore>
       *p_err  = OS_ERR_TASK_RESUME_SELF;
 8007496:	f247 1357 	movw	r3, #29015	; 0x7157
 800749a:	802b      	strh	r3, [r5, #0]
        return;
 800749c:	bd38      	pop	{r3, r4, r5, pc}
 800749e:	bf00      	nop
 80074a0:	2000ed84 	.word	0x2000ed84
 80074a4:	2000ed58 	.word	0x2000ed58

080074a8 <OS_TaskReturn>:
* Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
************************************************************************************************************************
*/

void  OS_TaskReturn (void)
{
 80074a8:	b500      	push	{lr}
    OS_ERR  err;



    OSTaskReturnHook(OSTCBCurPtr);                          /* Call hook to let user decide on what to do             */
 80074aa:	4b07      	ldr	r3, [pc, #28]	; (80074c8 <OS_TaskReturn+0x20>)
* Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
************************************************************************************************************************
*/

void  OS_TaskReturn (void)
{
 80074ac:	b083      	sub	sp, #12
    OS_ERR  err;



    OSTaskReturnHook(OSTCBCurPtr);                          /* Call hook to let user decide on what to do             */
 80074ae:	6818      	ldr	r0, [r3, #0]
 80074b0:	f7fd fa20 	bl	80048f4 <OSTaskReturnHook>
        return;
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to delete from ISR                       */
 80074b4:	4b05      	ldr	r3, [pc, #20]	; (80074cc <OS_TaskReturn+0x24>)
 80074b6:	7818      	ldrb	r0, [r3, #0]
 80074b8:	b918      	cbnz	r0, 80074c2 <OS_TaskReturn+0x1a>
 80074ba:	f10d 0106 	add.w	r1, sp, #6
 80074be:	f7ff fe71 	bl	80071a4 <OSTaskDel.part.0>
        OSTimeDly((OS_TICK )OSCfg_TickRate_Hz,
                  (OS_OPT  )OS_OPT_TIME_DLY,
                  (OS_ERR *)&err);
    }
#endif
}
 80074c2:	b003      	add	sp, #12
 80074c4:	f85d fb04 	ldr.w	pc, [sp], #4
 80074c8:	2000ed58 	.word	0x2000ed58
 80074cc:	2000ed84 	.word	0x2000ed84

080074d0 <OS_TaskSemPost>:

OS_SEM_CTR  OS_TaskSemPost (OS_TCB  *p_tcb,
                            OS_OPT   opt,
                            CPU_TS   ts,
                            OS_ERR  *p_err)
{
 80074d0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80074d4:	b082      	sub	sp, #8
 80074d6:	4604      	mov	r4, r0
 80074d8:	4688      	mov	r8, r1
 80074da:	4692      	mov	sl, r2
 80074dc:	461e      	mov	r6, r3
    OS_SEM_CTR  ctr;
    CPU_SR_ALLOC();



    OS_CRITICAL_ENTER();
 80074de:	f7fa f949 	bl	8001774 <CPU_SR_Save>
 80074e2:	4607      	mov	r7, r0
    if (p_tcb == (OS_TCB *)0) {                             /* Post signal to 'self'?                                 */
 80074e4:	2c00      	cmp	r4, #0
 80074e6:	d03d      	beq.n	8007564 <OS_TaskSemPost+0x94>
        p_tcb = OSTCBCurPtr;
    }
    p_tcb->TS = ts;
   *p_err     = OS_ERR_NONE;                                /* Assume we won't have any errors                        */
 80074e8:	f04f 0900 	mov.w	r9, #0

    OS_CRITICAL_ENTER();
    if (p_tcb == (OS_TCB *)0) {                             /* Post signal to 'self'?                                 */
        p_tcb = OSTCBCurPtr;
    }
    p_tcb->TS = ts;
 80074ec:	f8c4 a040 	str.w	sl, [r4, #64]	; 0x40
   *p_err     = OS_ERR_NONE;                                /* Assume we won't have any errors                        */
 80074f0:	f8a6 9000 	strh.w	r9, [r6]
    switch (p_tcb->TaskState) {
 80074f4:	f894 0036 	ldrb.w	r0, [r4, #54]	; 0x36
 80074f8:	2807      	cmp	r0, #7
 80074fa:	d817      	bhi.n	800752c <OS_TaskSemPost+0x5c>
 80074fc:	2101      	movs	r1, #1
 80074fe:	4081      	lsls	r1, r0
 8007500:	f011 05cc 	ands.w	r5, r1, #204	; 0xcc
 8007504:	d00f      	beq.n	8007526 <OS_TaskSemPost+0x56>

        case OS_TASK_STATE_PEND:
        case OS_TASK_STATE_PEND_TIMEOUT:
        case OS_TASK_STATE_PEND_SUSPENDED:
        case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
             if (p_tcb->PendOn == OS_TASK_PEND_ON_TASK_SEM) {   /* Is task signaled waiting for a signal?             */
 8007506:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
 800750a:	2b07      	cmp	r3, #7
 800750c:	d034      	beq.n	8007578 <OS_TaskSemPost+0xa8>
                              return ((OS_SEM_CTR)0);
                          }
                          break;

                     case 4u:
                          if (p_tcb->SemCtr == DEF_INT_32U_MAX_VAL) {
 800750e:	6c65      	ldr	r5, [r4, #68]	; 0x44
 8007510:	1c6b      	adds	r3, r5, #1
 8007512:	d01f      	beq.n	8007554 <OS_TaskSemPost+0x84>
                          break;

                     default:
                          break;
                 }
                 p_tcb->SemCtr++;                           /* No,  Task signaled is NOT pending on semaphore ...     */
 8007514:	3501      	adds	r5, #1
                 ctr = p_tcb->SemCtr;                       /*      ... it must be waiting on something else          */
                 OS_CRITICAL_EXIT();
 8007516:	4638      	mov	r0, r7
                          break;

                     default:
                          break;
                 }
                 p_tcb->SemCtr++;                           /* No,  Task signaled is NOT pending on semaphore ...     */
 8007518:	6465      	str	r5, [r4, #68]	; 0x44
                 ctr = p_tcb->SemCtr;                       /*      ... it must be waiting on something else          */
                 OS_CRITICAL_EXIT();
 800751a:	f7fa f92f 	bl	800177c <CPU_SR_Restore>
            *p_err = OS_ERR_STATE_INVALID;
             ctr   = (OS_SEM_CTR)0;
             break;
    }
    return (ctr);
}
 800751e:	4628      	mov	r0, r5
 8007520:	b002      	add	sp, #8
 8007522:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8007526:	f011 0f33 	tst.w	r1, #51	; 0x33
 800752a:	d10a      	bne.n	8007542 <OS_TaskSemPost+0x72>
                 OS_CRITICAL_EXIT();
             }
             break;

        default:
             OS_CRITICAL_EXIT();
 800752c:	4638      	mov	r0, r7
 800752e:	f7fa f925 	bl	800177c <CPU_SR_Restore>
            *p_err = OS_ERR_STATE_INVALID;
 8007532:	f646 632d 	movw	r3, #28205	; 0x6e2d
             ctr   = (OS_SEM_CTR)0;
 8007536:	2500      	movs	r5, #0
             }
             break;

        default:
             OS_CRITICAL_EXIT();
            *p_err = OS_ERR_STATE_INVALID;
 8007538:	8033      	strh	r3, [r6, #0]
             ctr   = (OS_SEM_CTR)0;
             break;
    }
    return (ctr);
}
 800753a:	4628      	mov	r0, r5
 800753c:	b002      	add	sp, #8
 800753e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                          return ((OS_SEM_CTR)0);
                      }
                      break;

                 case 4u:
                      if (p_tcb->SemCtr == DEF_INT_32U_MAX_VAL) {
 8007542:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8007544:	1c5a      	adds	r2, r3, #1
 8007546:	d010      	beq.n	800756a <OS_TaskSemPost+0x9a>
                      break;

                 default:
                      break;
             }
             p_tcb->SemCtr++;                               /* Task signaled is not pending on anything               */
 8007548:	1c5d      	adds	r5, r3, #1
 800754a:	6465      	str	r5, [r4, #68]	; 0x44
             ctr = p_tcb->SemCtr;
             OS_CRITICAL_EXIT();
 800754c:	4638      	mov	r0, r7
 800754e:	f7fa f915 	bl	800177c <CPU_SR_Restore>
             break;
 8007552:	e7f2      	b.n	800753a <OS_TaskSemPost+0x6a>
                          }
                          break;

                     case 4u:
                          if (p_tcb->SemCtr == DEF_INT_32U_MAX_VAL) {
                              OS_CRITICAL_EXIT();
 8007554:	4638      	mov	r0, r7
 8007556:	f7fa f911 	bl	800177c <CPU_SR_Restore>
                             *p_err = OS_ERR_SEM_OVF;
 800755a:	f646 53c5 	movw	r3, #28101	; 0x6dc5
                              return ((OS_SEM_CTR)0);
 800755e:	464d      	mov	r5, r9
                          break;

                     case 4u:
                          if (p_tcb->SemCtr == DEF_INT_32U_MAX_VAL) {
                              OS_CRITICAL_EXIT();
                             *p_err = OS_ERR_SEM_OVF;
 8007560:	8033      	strh	r3, [r6, #0]
                              return ((OS_SEM_CTR)0);
 8007562:	e7ea      	b.n	800753a <OS_TaskSemPost+0x6a>



    OS_CRITICAL_ENTER();
    if (p_tcb == (OS_TCB *)0) {                             /* Post signal to 'self'?                                 */
        p_tcb = OSTCBCurPtr;
 8007564:	4b0d      	ldr	r3, [pc, #52]	; (800759c <OS_TaskSemPost+0xcc>)
 8007566:	681c      	ldr	r4, [r3, #0]
 8007568:	e7be      	b.n	80074e8 <OS_TaskSemPost+0x18>
                      }
                      break;

                 case 4u:
                      if (p_tcb->SemCtr == DEF_INT_32U_MAX_VAL) {
                          OS_CRITICAL_EXIT();
 800756a:	4638      	mov	r0, r7
 800756c:	f7fa f906 	bl	800177c <CPU_SR_Restore>
                         *p_err = OS_ERR_SEM_OVF;
 8007570:	f646 53c5 	movw	r3, #28101	; 0x6dc5
 8007574:	8033      	strh	r3, [r6, #0]
                          return ((OS_SEM_CTR)0);
 8007576:	e7e0      	b.n	800753a <OS_TaskSemPost+0x6a>
        case OS_TASK_STATE_PEND:
        case OS_TASK_STATE_PEND_TIMEOUT:
        case OS_TASK_STATE_PEND_SUSPENDED:
        case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
             if (p_tcb->PendOn == OS_TASK_PEND_ON_TASK_SEM) {   /* Is task signaled waiting for a signal?             */
                 OS_Post((OS_PEND_OBJ *)0,                      /*      Task is pending on signal                     */
 8007578:	464b      	mov	r3, r9
 800757a:	464a      	mov	r2, r9
 800757c:	4648      	mov	r0, r9
 800757e:	4621      	mov	r1, r4
 8007580:	f8cd a000 	str.w	sl, [sp]
 8007584:	f7fd f8ac 	bl	80046e0 <OS_Post>
                         (OS_TCB      *)p_tcb,
                         (void        *)0,
                         (OS_MSG_SIZE  )0u,
                         (CPU_TS       )ts);
                 ctr = p_tcb->SemCtr;
                 OS_CRITICAL_EXIT_NO_SCHED();
 8007588:	4638      	mov	r0, r7
                 OS_Post((OS_PEND_OBJ *)0,                      /*      Task is pending on signal                     */
                         (OS_TCB      *)p_tcb,
                         (void        *)0,
                         (OS_MSG_SIZE  )0u,
                         (CPU_TS       )ts);
                 ctr = p_tcb->SemCtr;
 800758a:	6c65      	ldr	r5, [r4, #68]	; 0x44
                 OS_CRITICAL_EXIT_NO_SCHED();
 800758c:	f7fa f8f6 	bl	800177c <CPU_SR_Restore>
                 if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
 8007590:	f418 4f00 	tst.w	r8, #32768	; 0x8000
 8007594:	d1d1      	bne.n	800753a <OS_TaskSemPost+0x6a>
                     OSSched();                                 /* Run the scheduler                                  */
 8007596:	f7fc fac7 	bl	8003b28 <OSSched>
 800759a:	e7ce      	b.n	800753a <OS_TaskSemPost+0x6a>
 800759c:	2000ed58 	.word	0x2000ed58

080075a0 <OSTaskSemPost>:
*/

OS_SEM_CTR  OSTaskSemPost (OS_TCB  *p_tcb,
                           OS_OPT   opt,
                           OS_ERR  *p_err)
{
 80075a0:	b570      	push	{r4, r5, r6, lr}
        return ((OS_SEM_CTR)0);
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    switch (opt) {                                          /* Validate 'opt'                                         */
 80075a2:	b139      	cbz	r1, 80075b4 <OSTaskSemPost+0x14>
 80075a4:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 80075a8:	d004      	beq.n	80075b4 <OSTaskSemPost+0x14>
        case OS_OPT_POST_NONE:
        case OS_OPT_POST_NO_SCHED:
             break;

        default:
            *p_err =  OS_ERR_OPT_INVALID;
 80075aa:	f645 6325 	movw	r3, #24101	; 0x5e25
                         opt,
                         ts,
                         p_err);

    return (ctr);
}
 80075ae:	2000      	movs	r0, #0
        case OS_OPT_POST_NONE:
        case OS_OPT_POST_NO_SCHED:
             break;

        default:
            *p_err =  OS_ERR_OPT_INVALID;
 80075b0:	8013      	strh	r3, [r2, #0]
                         opt,
                         ts,
                         p_err);

    return (ctr);
}
 80075b2:	bd70      	pop	{r4, r5, r6, pc}
 80075b4:	4615      	mov	r5, r2
 80075b6:	460c      	mov	r4, r1
 80075b8:	4606      	mov	r6, r0
            *p_err =  OS_ERR_OPT_INVALID;
             return ((OS_SEM_CTR)0u);
    }
#endif

    ts = OS_TS_GET();                                       /* Get timestamp                                          */
 80075ba:	f7f9 fae7 	bl	8000b8c <CPU_TS_TmrRd>
                    (OS_ERR    *)p_err);
        return ((OS_SEM_CTR)0);
    }
#endif

    ctr = OS_TaskSemPost(p_tcb,
 80075be:	462b      	mov	r3, r5
 80075c0:	4602      	mov	r2, r0
 80075c2:	4621      	mov	r1, r4
 80075c4:	4630      	mov	r0, r6
                         opt,
                         ts,
                         p_err);

    return (ctr);
}
 80075c6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
                    (OS_ERR    *)p_err);
        return ((OS_SEM_CTR)0);
    }
#endif

    ctr = OS_TaskSemPost(p_tcb,
 80075ca:	f7ff bf81 	b.w	80074d0 <OS_TaskSemPost>
 80075ce:	bf00      	nop

080075d0 <OS_TaskSuspend>:
*/

#if OS_CFG_TASK_SUSPEND_EN > 0u
void   OS_TaskSuspend (OS_TCB  *p_tcb,
                       OS_ERR  *p_err)
{
 80075d0:	b570      	push	{r4, r5, r6, lr}
 80075d2:	4604      	mov	r4, r0
 80075d4:	460d      	mov	r5, r1
    CPU_SR_ALLOC();



    CPU_CRITICAL_ENTER();
 80075d6:	f7fa f8cd 	bl	8001774 <CPU_SR_Save>
    if (p_tcb == (OS_TCB *)0) {                             /* See if specified to suspend self                       */
        p_tcb = OSTCBCurPtr;
 80075da:	4b29      	ldr	r3, [pc, #164]	; (8007680 <OS_TaskSuspend+0xb0>)
{
    CPU_SR_ALLOC();



    CPU_CRITICAL_ENTER();
 80075dc:	4606      	mov	r6, r0
    if (p_tcb == (OS_TCB *)0) {                             /* See if specified to suspend self                       */
 80075de:	2c00      	cmp	r4, #0
 80075e0:	d042      	beq.n	8007668 <OS_TaskSuspend+0x98>
        p_tcb = OSTCBCurPtr;
    }

    if (p_tcb == OSTCBCurPtr) {
 80075e2:	681b      	ldr	r3, [r3, #0]
 80075e4:	429c      	cmp	r4, r3
 80075e6:	d040      	beq.n	800766a <OS_TaskSuspend+0x9a>
           *p_err = OS_ERR_SCHED_LOCKED;
            return;
        }
    }

   *p_err = OS_ERR_NONE;
 80075e8:	2300      	movs	r3, #0
 80075ea:	802b      	strh	r3, [r5, #0]
    switch (p_tcb->TaskState) {
 80075ec:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
 80075f0:	2b07      	cmp	r3, #7
 80075f2:	d832      	bhi.n	800765a <OS_TaskSuspend+0x8a>
 80075f4:	e8df f003 	tbb	[pc, r3]
 80075f8:	2f2d2010 	.word	0x2f2d2010
 80075fc:	04040404 	.word	0x04040404

        case OS_TASK_STATE_SUSPENDED:
        case OS_TASK_STATE_DLY_SUSPENDED:
        case OS_TASK_STATE_PEND_SUSPENDED:
        case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
             p_tcb->SuspendCtr++;
 8007600:	f894 308a 	ldrb.w	r3, [r4, #138]	; 0x8a
             CPU_CRITICAL_EXIT();
 8007604:	4630      	mov	r0, r6

        case OS_TASK_STATE_SUSPENDED:
        case OS_TASK_STATE_DLY_SUSPENDED:
        case OS_TASK_STATE_PEND_SUSPENDED:
        case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
             p_tcb->SuspendCtr++;
 8007606:	3301      	adds	r3, #1
 8007608:	f884 308a 	strb.w	r3, [r4, #138]	; 0x8a
             CPU_CRITICAL_EXIT();
 800760c:	f7fa f8b6 	bl	800177c <CPU_SR_Restore>
            *p_err = OS_ERR_STATE_INVALID;
             return;
    }

    OSSched();
}
 8007610:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
             CPU_CRITICAL_EXIT();
            *p_err = OS_ERR_STATE_INVALID;
             return;
    }

    OSSched();
 8007614:	f7fc ba88 	b.w	8003b28 <OSSched>

   *p_err = OS_ERR_NONE;
    switch (p_tcb->TaskState) {
        case OS_TASK_STATE_RDY:
             OS_CRITICAL_ENTER_CPU_EXIT();
             p_tcb->TaskState  =  OS_TASK_STATE_SUSPENDED;
 8007618:	2204      	movs	r2, #4
             p_tcb->SuspendCtr = (OS_NESTING_CTR)1;
 800761a:	2301      	movs	r3, #1

   *p_err = OS_ERR_NONE;
    switch (p_tcb->TaskState) {
        case OS_TASK_STATE_RDY:
             OS_CRITICAL_ENTER_CPU_EXIT();
             p_tcb->TaskState  =  OS_TASK_STATE_SUSPENDED;
 800761c:	f884 2036 	strb.w	r2, [r4, #54]	; 0x36
             p_tcb->SuspendCtr = (OS_NESTING_CTR)1;
 8007620:	f884 308a 	strb.w	r3, [r4, #138]	; 0x8a
             OS_RdyListRemove(p_tcb);
 8007624:	4620      	mov	r0, r4
 8007626:	f7fc fe91 	bl	800434c <OS_RdyListRemove>
             OS_CRITICAL_EXIT_NO_SCHED();
 800762a:	4630      	mov	r0, r6
 800762c:	f7fa f8a6 	bl	800177c <CPU_SR_Restore>
            *p_err = OS_ERR_STATE_INVALID;
             return;
    }

    OSSched();
}
 8007630:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
             CPU_CRITICAL_EXIT();
            *p_err = OS_ERR_STATE_INVALID;
             return;
    }

    OSSched();
 8007634:	f7fc ba78 	b.w	8003b28 <OSSched>
             OS_RdyListRemove(p_tcb);
             OS_CRITICAL_EXIT_NO_SCHED();
             break;

        case OS_TASK_STATE_DLY:
             p_tcb->TaskState  = OS_TASK_STATE_DLY_SUSPENDED;
 8007638:	2205      	movs	r2, #5
             CPU_CRITICAL_EXIT();
             break;

        case OS_TASK_STATE_PEND_TIMEOUT:
             p_tcb->TaskState  = OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED;
             p_tcb->SuspendCtr = (OS_NESTING_CTR)1;
 800763a:	2301      	movs	r3, #1
             CPU_CRITICAL_EXIT();
 800763c:	4630      	mov	r0, r6
             p_tcb->SuspendCtr = (OS_NESTING_CTR)1;
             CPU_CRITICAL_EXIT();
             break;

        case OS_TASK_STATE_PEND_TIMEOUT:
             p_tcb->TaskState  = OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED;
 800763e:	f884 2036 	strb.w	r2, [r4, #54]	; 0x36
             p_tcb->SuspendCtr = (OS_NESTING_CTR)1;
 8007642:	f884 308a 	strb.w	r3, [r4, #138]	; 0x8a
             CPU_CRITICAL_EXIT();
 8007646:	f7fa f899 	bl	800177c <CPU_SR_Restore>
            *p_err = OS_ERR_STATE_INVALID;
             return;
    }

    OSSched();
}
 800764a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
             CPU_CRITICAL_EXIT();
            *p_err = OS_ERR_STATE_INVALID;
             return;
    }

    OSSched();
 800764e:	f7fc ba6b 	b.w	8003b28 <OSSched>
             p_tcb->SuspendCtr = (OS_NESTING_CTR)1;
             CPU_CRITICAL_EXIT();
             break;

        case OS_TASK_STATE_PEND:
             p_tcb->TaskState  = OS_TASK_STATE_PEND_SUSPENDED;
 8007652:	2206      	movs	r2, #6
 8007654:	e7f1      	b.n	800763a <OS_TaskSuspend+0x6a>
             p_tcb->SuspendCtr = (OS_NESTING_CTR)1;
             CPU_CRITICAL_EXIT();
             break;

        case OS_TASK_STATE_PEND_TIMEOUT:
             p_tcb->TaskState  = OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED;
 8007656:	2207      	movs	r2, #7
 8007658:	e7ef      	b.n	800763a <OS_TaskSuspend+0x6a>
             p_tcb->SuspendCtr++;
             CPU_CRITICAL_EXIT();
             break;

        default:
             CPU_CRITICAL_EXIT();
 800765a:	4630      	mov	r0, r6
 800765c:	f7fa f88e 	bl	800177c <CPU_SR_Restore>
            *p_err = OS_ERR_STATE_INVALID;
 8007660:	f646 632d 	movw	r3, #28205	; 0x6e2d
 8007664:	802b      	strh	r3, [r5, #0]
             return;
 8007666:	bd70      	pop	{r4, r5, r6, pc}



    CPU_CRITICAL_ENTER();
    if (p_tcb == (OS_TCB *)0) {                             /* See if specified to suspend self                       */
        p_tcb = OSTCBCurPtr;
 8007668:	681c      	ldr	r4, [r3, #0]
    }

    if (p_tcb == OSTCBCurPtr) {
        if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /* Can't suspend when the scheduler is locked             */
 800766a:	4b06      	ldr	r3, [pc, #24]	; (8007684 <OS_TaskSuspend+0xb4>)
 800766c:	781b      	ldrb	r3, [r3, #0]
 800766e:	2b00      	cmp	r3, #0
 8007670:	d0ba      	beq.n	80075e8 <OS_TaskSuspend+0x18>
            CPU_CRITICAL_EXIT();
 8007672:	4630      	mov	r0, r6
 8007674:	f7fa f882 	bl	800177c <CPU_SR_Restore>
           *p_err = OS_ERR_SCHED_LOCKED;
 8007678:	f646 5363 	movw	r3, #28003	; 0x6d63
 800767c:	802b      	strh	r3, [r5, #0]
            return;
 800767e:	bd70      	pop	{r4, r5, r6, pc}
 8007680:	2000ed58 	.word	0x2000ed58
 8007684:	2000e974 	.word	0x2000e974

08007688 <OSTaskSuspend>:
*/

#if OS_CFG_TASK_SUSPEND_EN > 0u
void   OSTaskSuspend (OS_TCB  *p_tcb,
                      OS_ERR  *p_err)
{
 8007688:	b410      	push	{r4}
    }
#endif

#if (OS_CFG_ISR_POST_DEFERRED_EN   == 0u) && \
    (OS_CFG_CALLED_FROM_ISR_CHK_EN >  0u)
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
 800768a:	4b09      	ldr	r3, [pc, #36]	; (80076b0 <OSTaskSuspend+0x28>)
 800768c:	781b      	ldrb	r3, [r3, #0]
 800768e:	b92b      	cbnz	r3, 800769c <OSTaskSuspend+0x14>
       *p_err = OS_ERR_TASK_SUSPEND_ISR;
        return;
    }
#endif

    if (p_tcb == &OSIdleTaskTCB) {                          /* Make sure not suspending the idle task                 */
 8007690:	4b08      	ldr	r3, [pc, #32]	; (80076b4 <OSTaskSuspend+0x2c>)
 8007692:	4298      	cmp	r0, r3
 8007694:	d007      	beq.n	80076a6 <OSTaskSuspend+0x1e>
        return;
    }
#endif

    OS_TaskSuspend(p_tcb, p_err);
}
 8007696:	bc10      	pop	{r4}
                    (OS_ERR    *)p_err);
        return;
    }
#endif

    OS_TaskSuspend(p_tcb, p_err);
 8007698:	f7ff bf9a 	b.w	80075d0 <OS_TaskSuspend>
#endif

#if (OS_CFG_ISR_POST_DEFERRED_EN   == 0u) && \
    (OS_CFG_CALLED_FROM_ISR_CHK_EN >  0u)
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
       *p_err = OS_ERR_TASK_SUSPEND_ISR;
 800769c:	f247 135d 	movw	r3, #29021	; 0x715d
        return;
    }
#endif

    OS_TaskSuspend(p_tcb, p_err);
}
 80076a0:	bc10      	pop	{r4}
#endif

#if (OS_CFG_ISR_POST_DEFERRED_EN   == 0u) && \
    (OS_CFG_CALLED_FROM_ISR_CHK_EN >  0u)
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
       *p_err = OS_ERR_TASK_SUSPEND_ISR;
 80076a2:	800b      	strh	r3, [r1, #0]
        return;
    }
#endif

    OS_TaskSuspend(p_tcb, p_err);
}
 80076a4:	4770      	bx	lr
        return;
    }
#endif

    if (p_tcb == &OSIdleTaskTCB) {                          /* Make sure not suspending the idle task                 */
       *p_err = OS_ERR_TASK_SUSPEND_IDLE;
 80076a6:	f247 135b 	movw	r3, #29019	; 0x715b
        return;
    }
#endif

    OS_TaskSuspend(p_tcb, p_err);
}
 80076aa:	bc10      	pop	{r4}
        return;
    }
#endif

    if (p_tcb == &OSIdleTaskTCB) {                          /* Make sure not suspending the idle task                 */
       *p_err = OS_ERR_TASK_SUSPEND_IDLE;
 80076ac:	800b      	strh	r3, [r1, #0]
        return;
    }
#endif

    OS_TaskSuspend(p_tcb, p_err);
}
 80076ae:	4770      	bx	lr
 80076b0:	2000ed84 	.word	0x2000ed84
 80076b4:	2000ee58 	.word	0x2000ee58

080076b8 <OS_TickTaskInit>:
* Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
************************************************************************************************************************
*/

void  OS_TickTaskInit (OS_ERR  *p_err)
{
 80076b8:	b570      	push	{r4, r5, r6, lr}
    OS_TICK_SPOKE_IX   i;
    OS_TICK_SPOKE     *p_spoke;



    for (i = 0u; i < OSCfg_TickWheelSize; i++) {
 80076ba:	4b23      	ldr	r3, [pc, #140]	; (8007748 <OS_TickTaskInit+0x90>)
        OS_SAFETY_CRITICAL_EXCEPTION();
        return;
    }
#endif

    OSTickCtr         = (OS_TICK)0u;                        /* Clear the tick counter                                 */
 80076bc:	4923      	ldr	r1, [pc, #140]	; (800774c <OS_TickTaskInit+0x94>)
    OS_TICK_SPOKE_IX   i;
    OS_TICK_SPOKE     *p_spoke;



    for (i = 0u; i < OSCfg_TickWheelSize; i++) {
 80076be:	881d      	ldrh	r5, [r3, #0]
    }
#endif

    OSTickCtr         = (OS_TICK)0u;                        /* Clear the tick counter                                 */

    OSTickTaskTimeMax = (CPU_TS)0u;
 80076c0:	4a23      	ldr	r2, [pc, #140]	; (8007750 <OS_TickTaskInit+0x98>)
        OS_SAFETY_CRITICAL_EXCEPTION();
        return;
    }
#endif

    OSTickCtr         = (OS_TICK)0u;                        /* Clear the tick counter                                 */
 80076c2:	2300      	movs	r3, #0
* Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
************************************************************************************************************************
*/

void  OS_TickTaskInit (OS_ERR  *p_err)
{
 80076c4:	b08a      	sub	sp, #40	; 0x28
        OS_SAFETY_CRITICAL_EXCEPTION();
        return;
    }
#endif

    OSTickCtr         = (OS_TICK)0u;                        /* Clear the tick counter                                 */
 80076c6:	600b      	str	r3, [r1, #0]

    OSTickTaskTimeMax = (CPU_TS)0u;
 80076c8:	6013      	str	r3, [r2, #0]
    OS_TICK_SPOKE_IX   i;
    OS_TICK_SPOKE     *p_spoke;



    for (i = 0u; i < OSCfg_TickWheelSize; i++) {
 80076ca:	b165      	cbz	r5, 80076e6 <OS_TickTaskInit+0x2e>
 80076cc:	4e21      	ldr	r6, [pc, #132]	; (8007754 <OS_TickTaskInit+0x9c>)
        p_spoke                = (OS_TICK_SPOKE *)&OSCfg_TickWheel[i];
        p_spoke->FirstPtr      = (OS_TCB        *)0;
 80076ce:	4619      	mov	r1, r3
 80076d0:	4632      	mov	r2, r6
 80076d2:	f846 1033 	str.w	r1, [r6, r3, lsl #3]
 80076d6:	3301      	adds	r3, #1
    OS_TICK_SPOKE_IX   i;
    OS_TICK_SPOKE     *p_spoke;



    for (i = 0u; i < OSCfg_TickWheelSize; i++) {
 80076d8:	b29c      	uxth	r4, r3
 80076da:	42a5      	cmp	r5, r4
        p_spoke                = (OS_TICK_SPOKE *)&OSCfg_TickWheel[i];
        p_spoke->FirstPtr      = (OS_TCB        *)0;
        p_spoke->NbrEntries    = (OS_OBJ_QTY     )0u;
 80076dc:	8091      	strh	r1, [r2, #4]
        p_spoke->NbrEntriesMax = (OS_OBJ_QTY     )0u;
 80076de:	80d1      	strh	r1, [r2, #6]
 80076e0:	f102 0208 	add.w	r2, r2, #8
    OS_TICK_SPOKE_IX   i;
    OS_TICK_SPOKE     *p_spoke;



    for (i = 0u; i < OSCfg_TickWheelSize; i++) {
 80076e4:	d8f5      	bhi.n	80076d2 <OS_TickTaskInit+0x1a>


    OS_TickListInit();                                      /* Initialize the tick list data structures               */

                                                            /* ---------------- CREATE THE TICK TASK ---------------- */
    if (OSCfg_TickTaskStkBasePtr == (CPU_STK *)0) {
 80076e6:	4b1c      	ldr	r3, [pc, #112]	; (8007758 <OS_TickTaskInit+0xa0>)
 80076e8:	681a      	ldr	r2, [r3, #0]
 80076ea:	2a00      	cmp	r2, #0
 80076ec:	d027      	beq.n	800773e <OS_TickTaskInit+0x86>
       *p_err = OS_ERR_TICK_STK_INVALID;
        return;
    }

    if (OSCfg_TickTaskStkSize < OSCfg_StkSizeMin) {
 80076ee:	491b      	ldr	r1, [pc, #108]	; (800775c <OS_TickTaskInit+0xa4>)
 80076f0:	4b1b      	ldr	r3, [pc, #108]	; (8007760 <OS_TickTaskInit+0xa8>)
 80076f2:	6809      	ldr	r1, [r1, #0]
 80076f4:	681b      	ldr	r3, [r3, #0]
 80076f6:	4299      	cmp	r1, r3
 80076f8:	d31c      	bcc.n	8007734 <OS_TickTaskInit+0x7c>
       *p_err = OS_ERR_TICK_STK_SIZE_INVALID;
        return;
    }

    if (OSCfg_TickTaskPrio >= (OS_CFG_PRIO_MAX - 1u)) {     /* Only one task at the 'Idle Task' priority              */
 80076fa:	4b1a      	ldr	r3, [pc, #104]	; (8007764 <OS_TickTaskInit+0xac>)
 80076fc:	781c      	ldrb	r4, [r3, #0]
 80076fe:	2c3d      	cmp	r4, #61	; 0x3d
 8007700:	d904      	bls.n	800770c <OS_TickTaskInit+0x54>
       *p_err = OS_ERR_TICK_PRIO_INVALID;
 8007702:	f247 2311 	movw	r3, #29201	; 0x7211
 8007706:	8003      	strh	r3, [r0, #0]
                 (OS_MSG_QTY  )0u,
                 (OS_TICK     )0u,
                 (void       *)0,
                 (OS_OPT      )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR | OS_OPT_TASK_NO_TLS),
                 (OS_ERR     *)p_err);
}
 8007708:	b00a      	add	sp, #40	; 0x28
 800770a:	bd70      	pop	{r4, r5, r6, pc}
    if (OSCfg_TickTaskPrio >= (OS_CFG_PRIO_MAX - 1u)) {     /* Only one task at the 'Idle Task' priority              */
       *p_err = OS_ERR_TICK_PRIO_INVALID;
        return;
    }

    OSTaskCreate((OS_TCB     *)&OSTickTaskTCB,
 800770c:	4b16      	ldr	r3, [pc, #88]	; (8007768 <OS_TickTaskInit+0xb0>)
 800770e:	250b      	movs	r5, #11
 8007710:	681e      	ldr	r6, [r3, #0]
 8007712:	2300      	movs	r3, #0
 8007714:	9008      	str	r0, [sp, #32]
 8007716:	9103      	str	r1, [sp, #12]
 8007718:	9201      	str	r2, [sp, #4]
 800771a:	9400      	str	r4, [sp, #0]
 800771c:	9602      	str	r6, [sp, #8]
 800771e:	9507      	str	r5, [sp, #28]
 8007720:	9306      	str	r3, [sp, #24]
 8007722:	9305      	str	r3, [sp, #20]
 8007724:	9304      	str	r3, [sp, #16]
 8007726:	4a11      	ldr	r2, [pc, #68]	; (800776c <OS_TickTaskInit+0xb4>)
 8007728:	4911      	ldr	r1, [pc, #68]	; (8007770 <OS_TickTaskInit+0xb8>)
 800772a:	4812      	ldr	r0, [pc, #72]	; (8007774 <OS_TickTaskInit+0xbc>)
 800772c:	f7ff fc6e 	bl	800700c <OSTaskCreate>
                 (OS_MSG_QTY  )0u,
                 (OS_TICK     )0u,
                 (void       *)0,
                 (OS_OPT      )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR | OS_OPT_TASK_NO_TLS),
                 (OS_ERR     *)p_err);
}
 8007730:	b00a      	add	sp, #40	; 0x28
 8007732:	bd70      	pop	{r4, r5, r6, pc}
       *p_err = OS_ERR_TICK_STK_INVALID;
        return;
    }

    if (OSCfg_TickTaskStkSize < OSCfg_StkSizeMin) {
       *p_err = OS_ERR_TICK_STK_SIZE_INVALID;
 8007734:	f247 2313 	movw	r3, #29203	; 0x7213
 8007738:	8003      	strh	r3, [r0, #0]
                 (OS_MSG_QTY  )0u,
                 (OS_TICK     )0u,
                 (void       *)0,
                 (OS_OPT      )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR | OS_OPT_TASK_NO_TLS),
                 (OS_ERR     *)p_err);
}
 800773a:	b00a      	add	sp, #40	; 0x28
 800773c:	bd70      	pop	{r4, r5, r6, pc}

    OS_TickListInit();                                      /* Initialize the tick list data structures               */

                                                            /* ---------------- CREATE THE TICK TASK ---------------- */
    if (OSCfg_TickTaskStkBasePtr == (CPU_STK *)0) {
       *p_err = OS_ERR_TICK_STK_INVALID;
 800773e:	f247 2312 	movw	r3, #29202	; 0x7212
 8007742:	8003      	strh	r3, [r0, #0]
                 (OS_MSG_QTY  )0u,
                 (OS_TICK     )0u,
                 (void       *)0,
                 (OS_OPT      )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR | OS_OPT_TASK_NO_TLS),
                 (OS_ERR     *)p_err);
}
 8007744:	b00a      	add	sp, #40	; 0x28
 8007746:	bd70      	pop	{r4, r5, r6, pc}
 8007748:	080160b4 	.word	0x080160b4
 800774c:	2000ef34 	.word	0x2000ef34
 8007750:	2000f028 	.word	0x2000f028
 8007754:	2000db48 	.word	0x2000db48
 8007758:	080160c4 	.word	0x080160c4
 800775c:	080160bc 	.word	0x080160bc
 8007760:	080160d0 	.word	0x080160d0
 8007764:	080160c8 	.word	0x080160c8
 8007768:	080160c0 	.word	0x080160c0
 800776c:	08007a3d 	.word	0x08007a3d
 8007770:	08016694 	.word	0x08016694
 8007774:	2000ec8c 	.word	0x2000ec8c

08007778 <OS_TickListInit>:
    OS_TICK_SPOKE_IX   i;
    OS_TICK_SPOKE     *p_spoke;



    for (i = 0u; i < OSCfg_TickWheelSize; i++) {
 8007778:	4b09      	ldr	r3, [pc, #36]	; (80077a0 <OS_TickListInit+0x28>)
* Note(s)    : This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
************************************************************************************************************************
*/

void  OS_TickListInit (void)
{
 800777a:	b430      	push	{r4, r5}
    OS_TICK_SPOKE_IX   i;
    OS_TICK_SPOKE     *p_spoke;



    for (i = 0u; i < OSCfg_TickWheelSize; i++) {
 800777c:	881c      	ldrh	r4, [r3, #0]
 800777e:	b16c      	cbz	r4, 800779c <OS_TickListInit+0x24>
 8007780:	4d08      	ldr	r5, [pc, #32]	; (80077a4 <OS_TickListInit+0x2c>)
 8007782:	2300      	movs	r3, #0
 8007784:	462a      	mov	r2, r5
        p_spoke                = (OS_TICK_SPOKE *)&OSCfg_TickWheel[i];
        p_spoke->FirstPtr      = (OS_TCB        *)0;
 8007786:	4619      	mov	r1, r3
 8007788:	f845 1033 	str.w	r1, [r5, r3, lsl #3]
 800778c:	3301      	adds	r3, #1
    OS_TICK_SPOKE_IX   i;
    OS_TICK_SPOKE     *p_spoke;



    for (i = 0u; i < OSCfg_TickWheelSize; i++) {
 800778e:	b298      	uxth	r0, r3
 8007790:	4284      	cmp	r4, r0
        p_spoke                = (OS_TICK_SPOKE *)&OSCfg_TickWheel[i];
        p_spoke->FirstPtr      = (OS_TCB        *)0;
        p_spoke->NbrEntries    = (OS_OBJ_QTY     )0u;
 8007792:	8091      	strh	r1, [r2, #4]
        p_spoke->NbrEntriesMax = (OS_OBJ_QTY     )0u;
 8007794:	80d1      	strh	r1, [r2, #6]
 8007796:	f102 0208 	add.w	r2, r2, #8
    OS_TICK_SPOKE_IX   i;
    OS_TICK_SPOKE     *p_spoke;



    for (i = 0u; i < OSCfg_TickWheelSize; i++) {
 800779a:	d8f5      	bhi.n	8007788 <OS_TickListInit+0x10>
        p_spoke                = (OS_TICK_SPOKE *)&OSCfg_TickWheel[i];
        p_spoke->FirstPtr      = (OS_TCB        *)0;
        p_spoke->NbrEntries    = (OS_OBJ_QTY     )0u;
        p_spoke->NbrEntriesMax = (OS_OBJ_QTY     )0u;
    }
}
 800779c:	bc30      	pop	{r4, r5}
 800779e:	4770      	bx	lr
 80077a0:	080160b4 	.word	0x080160b4
 80077a4:	2000db48 	.word	0x2000db48

080077a8 <OS_TickListInsert>:
    OS_TCB            *p_tcb1;
    OS_TICK_SPOKE_IX   spoke;



    if (opt == OS_OPT_TIME_MATCH) {                              /* Task time is absolute.                            */
 80077a8:	2a04      	cmp	r2, #4

void  OS_TickListInsert (OS_TCB   *p_tcb,
                         OS_TICK   time,
                         OS_OPT    opt,
                         OS_ERR   *p_err)
{
 80077aa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80077ae:	4698      	mov	r8, r3
    OS_TCB            *p_tcb1;
    OS_TICK_SPOKE_IX   spoke;



    if (opt == OS_OPT_TIME_MATCH) {                              /* Task time is absolute.                            */
 80077b0:	d02c      	beq.n	800780c <OS_TickListInsert+0x64>
            return;
        }
        p_tcb->TickCtrMatch = time;
        p_tcb->TickRemain   = tick_delta + 1u;

    } else if (time > (OS_TICK)0u) {
 80077b2:	b391      	cbz	r1, 800781a <OS_TickListInsert+0x72>
        if (opt == OS_OPT_TIME_PERIODIC) {                       /* Task time is periodic.                            */
 80077b4:	2a08      	cmp	r2, #8
            tick_next  = p_tcb->TickCtrPrev + time;
            tick_delta = tick_next - OSTickCtr - 1u;
 80077b6:	4d3c      	ldr	r5, [pc, #240]	; (80078a8 <OS_TickListInsert+0x100>)
        }
        p_tcb->TickCtrMatch = time;
        p_tcb->TickRemain   = tick_delta + 1u;

    } else if (time > (OS_TICK)0u) {
        if (opt == OS_OPT_TIME_PERIODIC) {                       /* Task time is periodic.                            */
 80077b8:	d065      	beq.n	8007886 <OS_TickListInsert+0xde>
            }
            p_tcb->TickRemain   = p_tcb->TickCtrMatch - OSTickCtr;
            p_tcb->TickCtrPrev  = p_tcb->TickCtrMatch;

        } else {                                                 /* Task time is relative to current.                 */
            p_tcb->TickCtrMatch = OSTickCtr + time;
 80077ba:	682a      	ldr	r2, [r5, #0]
            p_tcb->TickRemain   = time;
 80077bc:	6501      	str	r1, [r0, #80]	; 0x50
            }
            p_tcb->TickRemain   = p_tcb->TickCtrMatch - OSTickCtr;
            p_tcb->TickCtrPrev  = p_tcb->TickCtrMatch;

        } else {                                                 /* Task time is relative to current.                 */
            p_tcb->TickCtrMatch = OSTickCtr + time;
 80077be:	4411      	add	r1, r2
 80077c0:	64c1      	str	r1, [r0, #76]	; 0x4c
       *p_err               =  OS_ERR_TIME_ZERO_DLY;             /* ... do NOT delay.                                 */
        return;
    }


    spoke   = (OS_TICK_SPOKE_IX)(p_tcb->TickCtrMatch % OSCfg_TickWheelSize);
 80077c2:	4a3a      	ldr	r2, [pc, #232]	; (80078ac <OS_TickListInsert+0x104>)
    p_spoke = &OSCfg_TickWheel[spoke];
 80077c4:	4f3a      	ldr	r7, [pc, #232]	; (80078b0 <OS_TickListInsert+0x108>)
 80077c6:	f8b2 c000 	ldrh.w	ip, [r2]
 80077ca:	fbb1 f2fc 	udiv	r2, r1, ip
 80077ce:	fb0c 1112 	mls	r1, ip, r2, r1
 80077d2:	fa1f fc81 	uxth.w	ip, r1
 80077d6:	ea4f 06cc 	mov.w	r6, ip, lsl #3
 80077da:	eb07 0e06 	add.w	lr, r7, r6

    if (p_spoke->NbrEntries == (OS_OBJ_QTY)0u) {                 /* First entry in the spoke                          */
 80077de:	f8be 4004 	ldrh.w	r4, [lr, #4]
 80077e2:	bb24      	cbnz	r4, 800782e <OS_TickListInsert+0x86>
        p_tcb->TickNextPtr   = (OS_TCB   *)0;
        p_tcb->TickPrevPtr   = (OS_TCB   *)0;
        p_spoke->FirstPtr    =  p_tcb;
        p_spoke->NbrEntries  = (OS_OBJ_QTY)1u;
 80077e4:	2101      	movs	r1, #1
 80077e6:	460a      	mov	r2, r1

    spoke   = (OS_TICK_SPOKE_IX)(p_tcb->TickCtrMatch % OSCfg_TickWheelSize);
    p_spoke = &OSCfg_TickWheel[spoke];

    if (p_spoke->NbrEntries == (OS_OBJ_QTY)0u) {                 /* First entry in the spoke                          */
        p_tcb->TickNextPtr   = (OS_TCB   *)0;
 80077e8:	6144      	str	r4, [r0, #20]
        p_tcb->TickPrevPtr   = (OS_TCB   *)0;
 80077ea:	6184      	str	r4, [r0, #24]
        p_spoke->FirstPtr    =  p_tcb;
 80077ec:	f847 003c 	str.w	r0, [r7, ip, lsl #3]
        p_spoke->NbrEntries  = (OS_OBJ_QTY)1u;
 80077f0:	f8ae 1004 	strh.w	r1, [lr, #4]
                p_tcb1 = (OS_TCB *)0;                            /* Break loop                                        */
            }
        }
        p_spoke->NbrEntries++;
    }
    if (p_spoke->NbrEntriesMax < p_spoke->NbrEntries) {          /* Keep track of maximum # of entries in each spoke  */
 80077f4:	443e      	add	r6, r7
 80077f6:	88f1      	ldrh	r1, [r6, #6]
 80077f8:	4291      	cmp	r1, r2
        p_spoke->NbrEntriesMax = p_spoke->NbrEntries;
 80077fa:	bf38      	it	cc
 80077fc:	80f2      	strhcc	r2, [r6, #6]
    }
    p_tcb->TickSpokePtr = p_spoke;                               /* Link back to tick spoke                           */
   *p_err               = OS_ERR_NONE;
 80077fe:	2200      	movs	r2, #0
        p_spoke->NbrEntries++;
    }
    if (p_spoke->NbrEntriesMax < p_spoke->NbrEntries) {          /* Keep track of maximum # of entries in each spoke  */
        p_spoke->NbrEntriesMax = p_spoke->NbrEntries;
    }
    p_tcb->TickSpokePtr = p_spoke;                               /* Link back to tick spoke                           */
 8007800:	f8c0 e01c 	str.w	lr, [r0, #28]
   *p_err               = OS_ERR_NONE;
 8007804:	f8a8 2000 	strh.w	r2, [r8]
 8007808:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    OS_TICK_SPOKE_IX   spoke;



    if (opt == OS_OPT_TIME_MATCH) {                              /* Task time is absolute.                            */
        tick_delta = time - OSTickCtr - 1u;
 800780c:	4d26      	ldr	r5, [pc, #152]	; (80078a8 <OS_TickListInsert+0x100>)
 800780e:	682a      	ldr	r2, [r5, #0]
 8007810:	1a8a      	subs	r2, r1, r2
        if (tick_delta > OS_TICK_TH_RDY) {                       /* If delay already occurred, ...                    */
 8007812:	1e54      	subs	r4, r2, #1
 8007814:	f514 3f80 	cmn.w	r4, #65536	; 0x10000
 8007818:	d932      	bls.n	8007880 <OS_TickListInsert+0xd8>
            p_tcb->TickCtrMatch = (OS_TICK        )0u;
            p_tcb->TickRemain   = (OS_TICK        )0u;
            p_tcb->TickSpokePtr = (OS_TICK_SPOKE *)0;
           *p_err               =  OS_ERR_TIME_ZERO_DLY;         /* ... do NOT delay.                                 */
 800781a:	f247 217e 	movw	r1, #29310	; 0x727e


    if (opt == OS_OPT_TIME_MATCH) {                              /* Task time is absolute.                            */
        tick_delta = time - OSTickCtr - 1u;
        if (tick_delta > OS_TICK_TH_RDY) {                       /* If delay already occurred, ...                    */
            p_tcb->TickCtrMatch = (OS_TICK        )0u;
 800781e:	2200      	movs	r2, #0
 8007820:	64c2      	str	r2, [r0, #76]	; 0x4c
            p_tcb->TickRemain   = (OS_TICK        )0u;
 8007822:	6502      	str	r2, [r0, #80]	; 0x50
            p_tcb->TickSpokePtr = (OS_TICK_SPOKE *)0;
 8007824:	61c2      	str	r2, [r0, #28]
           *p_err               =  OS_ERR_TIME_ZERO_DLY;         /* ... do NOT delay.                                 */
 8007826:	f8a8 1000 	strh.w	r1, [r8]
            return;
 800782a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        p_tcb->TickNextPtr   = (OS_TCB   *)0;
        p_tcb->TickPrevPtr   = (OS_TCB   *)0;
        p_spoke->FirstPtr    =  p_tcb;
        p_spoke->NbrEntries  = (OS_OBJ_QTY)1u;
    } else {
        p_tcb1     = p_spoke->FirstPtr;                          /* Point to current first TCB in the list            */
 800782e:	f857 103c 	ldr.w	r1, [r7, ip, lsl #3]
        while (p_tcb1 != (OS_TCB *)0) {
 8007832:	b181      	cbz	r1, 8007856 <OS_TickListInsert+0xae>
 8007834:	682d      	ldr	r5, [r5, #0]
            p_tcb1->TickRemain = p_tcb1->TickCtrMatch            /* Compute time remaining of current TCB in list     */
                               - OSTickCtr;
 8007836:	6cca      	ldr	r2, [r1, #76]	; 0x4c
 8007838:	1b52      	subs	r2, r2, r5
        p_spoke->FirstPtr    =  p_tcb;
        p_spoke->NbrEntries  = (OS_OBJ_QTY)1u;
    } else {
        p_tcb1     = p_spoke->FirstPtr;                          /* Point to current first TCB in the list            */
        while (p_tcb1 != (OS_TCB *)0) {
            p_tcb1->TickRemain = p_tcb1->TickCtrMatch            /* Compute time remaining of current TCB in list     */
 800783a:	650a      	str	r2, [r1, #80]	; 0x50
                               - OSTickCtr;
            if (p_tcb->TickRemain > p_tcb1->TickRemain) {        /* Do we need to insert AFTER current TCB in list?   */
 800783c:	6d03      	ldr	r3, [r0, #80]	; 0x50
 800783e:	429a      	cmp	r2, r3
 8007840:	d203      	bcs.n	800784a <OS_TickListInsert+0xa2>
                if (p_tcb1->TickNextPtr != (OS_TCB *)0) {        /* Yes, are we pointing at the last TCB in the list? */
 8007842:	694a      	ldr	r2, [r1, #20]
 8007844:	b162      	cbz	r2, 8007860 <OS_TickListInsert+0xb8>
 8007846:	4611      	mov	r1, r2
 8007848:	e7f5      	b.n	8007836 <OS_TickListInsert+0x8e>
                    p_tcb->TickPrevPtr   =  p_tcb1;
                    p_tcb1->TickNextPtr  =  p_tcb;               /* Yes, TCB to add is now new last entry in the list */
                    p_tcb1               = (OS_TCB *)0;          /* Break loop                                        */
                }
            } else {                                             /* Insert before the current TCB                     */
                if (p_tcb1->TickPrevPtr == (OS_TCB *)0) {        /* Are we inserting before the first TCB?            */
 800784a:	698a      	ldr	r2, [r1, #24]
                    p_tcb->TickPrevPtr   = (OS_TCB *)0;
                    p_tcb->TickNextPtr   =  p_tcb1;
 800784c:	6141      	str	r1, [r0, #20]
                    p_tcb1->TickNextPtr  =  p_tcb;               /* Yes, TCB to add is now new last entry in the list */
                    p_tcb1               = (OS_TCB *)0;          /* Break loop                                        */
                }
            } else {                                             /* Insert before the current TCB                     */
                if (p_tcb1->TickPrevPtr == (OS_TCB *)0) {        /* Are we inserting before the first TCB?            */
                    p_tcb->TickPrevPtr   = (OS_TCB *)0;
 800784e:	6182      	str	r2, [r0, #24]
                    p_tcb->TickPrevPtr   =  p_tcb1;
                    p_tcb1->TickNextPtr  =  p_tcb;               /* Yes, TCB to add is now new last entry in the list */
                    p_tcb1               = (OS_TCB *)0;          /* Break loop                                        */
                }
            } else {                                             /* Insert before the current TCB                     */
                if (p_tcb1->TickPrevPtr == (OS_TCB *)0) {        /* Are we inserting before the first TCB?            */
 8007850:	b172      	cbz	r2, 8007870 <OS_TickListInsert+0xc8>
                    p_spoke->FirstPtr    =  p_tcb;
                } else {                                         /* Insert in between 2 TCBs already in the list      */
                    p_tcb0               =  p_tcb1->TickPrevPtr;
                    p_tcb->TickPrevPtr   =  p_tcb0;
                    p_tcb->TickNextPtr   =  p_tcb1;
                    p_tcb0->TickNextPtr  =  p_tcb;
 8007852:	6150      	str	r0, [r2, #20]
                    p_tcb1->TickPrevPtr  =  p_tcb;
 8007854:	6188      	str	r0, [r1, #24]
                }
                p_tcb1 = (OS_TCB *)0;                            /* Break loop                                        */
            }
        }
        p_spoke->NbrEntries++;
 8007856:	1c62      	adds	r2, r4, #1
 8007858:	b292      	uxth	r2, r2
 800785a:	19b9      	adds	r1, r7, r6
 800785c:	808a      	strh	r2, [r1, #4]
 800785e:	e7c9      	b.n	80077f4 <OS_TickListInsert+0x4c>
                               - OSTickCtr;
            if (p_tcb->TickRemain > p_tcb1->TickRemain) {        /* Do we need to insert AFTER current TCB in list?   */
                if (p_tcb1->TickNextPtr != (OS_TCB *)0) {        /* Yes, are we pointing at the last TCB in the list? */
                    p_tcb1               =  p_tcb1->TickNextPtr; /* No,  Point to next TCB in the list                */
                } else {
                    p_tcb->TickNextPtr   = (OS_TCB *)0;
 8007860:	6142      	str	r2, [r0, #20]
                    p_tcb1->TickPrevPtr  =  p_tcb;
                }
                p_tcb1 = (OS_TCB *)0;                            /* Break loop                                        */
            }
        }
        p_spoke->NbrEntries++;
 8007862:	1c62      	adds	r2, r4, #1
            if (p_tcb->TickRemain > p_tcb1->TickRemain) {        /* Do we need to insert AFTER current TCB in list?   */
                if (p_tcb1->TickNextPtr != (OS_TCB *)0) {        /* Yes, are we pointing at the last TCB in the list? */
                    p_tcb1               =  p_tcb1->TickNextPtr; /* No,  Point to next TCB in the list                */
                } else {
                    p_tcb->TickNextPtr   = (OS_TCB *)0;
                    p_tcb->TickPrevPtr   =  p_tcb1;
 8007864:	6181      	str	r1, [r0, #24]
                    p_tcb1->TickPrevPtr  =  p_tcb;
                }
                p_tcb1 = (OS_TCB *)0;                            /* Break loop                                        */
            }
        }
        p_spoke->NbrEntries++;
 8007866:	b292      	uxth	r2, r2
                if (p_tcb1->TickNextPtr != (OS_TCB *)0) {        /* Yes, are we pointing at the last TCB in the list? */
                    p_tcb1               =  p_tcb1->TickNextPtr; /* No,  Point to next TCB in the list                */
                } else {
                    p_tcb->TickNextPtr   = (OS_TCB *)0;
                    p_tcb->TickPrevPtr   =  p_tcb1;
                    p_tcb1->TickNextPtr  =  p_tcb;               /* Yes, TCB to add is now new last entry in the list */
 8007868:	6148      	str	r0, [r1, #20]
                    p_tcb1->TickPrevPtr  =  p_tcb;
                }
                p_tcb1 = (OS_TCB *)0;                            /* Break loop                                        */
            }
        }
        p_spoke->NbrEntries++;
 800786a:	19b9      	adds	r1, r7, r6
 800786c:	808a      	strh	r2, [r1, #4]
 800786e:	e7c1      	b.n	80077f4 <OS_TickListInsert+0x4c>
 8007870:	1c62      	adds	r2, r4, #1
                }
            } else {                                             /* Insert before the current TCB                     */
                if (p_tcb1->TickPrevPtr == (OS_TCB *)0) {        /* Are we inserting before the first TCB?            */
                    p_tcb->TickPrevPtr   = (OS_TCB *)0;
                    p_tcb->TickNextPtr   =  p_tcb1;
                    p_tcb1->TickPrevPtr  =  p_tcb;
 8007872:	6188      	str	r0, [r1, #24]
                    p_tcb1->TickPrevPtr  =  p_tcb;
                }
                p_tcb1 = (OS_TCB *)0;                            /* Break loop                                        */
            }
        }
        p_spoke->NbrEntries++;
 8007874:	b292      	uxth	r2, r2
 8007876:	19b9      	adds	r1, r7, r6
            } else {                                             /* Insert before the current TCB                     */
                if (p_tcb1->TickPrevPtr == (OS_TCB *)0) {        /* Are we inserting before the first TCB?            */
                    p_tcb->TickPrevPtr   = (OS_TCB *)0;
                    p_tcb->TickNextPtr   =  p_tcb1;
                    p_tcb1->TickPrevPtr  =  p_tcb;
                    p_spoke->FirstPtr    =  p_tcb;
 8007878:	f847 003c 	str.w	r0, [r7, ip, lsl #3]
                    p_tcb1->TickPrevPtr  =  p_tcb;
                }
                p_tcb1 = (OS_TCB *)0;                            /* Break loop                                        */
            }
        }
        p_spoke->NbrEntries++;
 800787c:	808a      	strh	r2, [r1, #4]
 800787e:	e7b9      	b.n	80077f4 <OS_TickListInsert+0x4c>
            p_tcb->TickRemain   = (OS_TICK        )0u;
            p_tcb->TickSpokePtr = (OS_TICK_SPOKE *)0;
           *p_err               =  OS_ERR_TIME_ZERO_DLY;         /* ... do NOT delay.                                 */
            return;
        }
        p_tcb->TickCtrMatch = time;
 8007880:	64c1      	str	r1, [r0, #76]	; 0x4c
        p_tcb->TickRemain   = tick_delta + 1u;
 8007882:	6502      	str	r2, [r0, #80]	; 0x50
 8007884:	e79d      	b.n	80077c2 <OS_TickListInsert+0x1a>

    } else if (time > (OS_TICK)0u) {
        if (opt == OS_OPT_TIME_PERIODIC) {                       /* Task time is periodic.                            */
            tick_next  = p_tcb->TickCtrPrev + time;
            tick_delta = tick_next - OSTickCtr - 1u;
 8007886:	682a      	ldr	r2, [r5, #0]
        p_tcb->TickCtrMatch = time;
        p_tcb->TickRemain   = tick_delta + 1u;

    } else if (time > (OS_TICK)0u) {
        if (opt == OS_OPT_TIME_PERIODIC) {                       /* Task time is periodic.                            */
            tick_next  = p_tcb->TickCtrPrev + time;
 8007888:	6c84      	ldr	r4, [r0, #72]	; 0x48
            tick_delta = tick_next - OSTickCtr - 1u;
            if (tick_delta < time) {                             /* If next periodic delay did NOT already occur, ... */
 800788a:	43d6      	mvns	r6, r2
        p_tcb->TickCtrMatch = time;
        p_tcb->TickRemain   = tick_delta + 1u;

    } else if (time > (OS_TICK)0u) {
        if (opt == OS_OPT_TIME_PERIODIC) {                       /* Task time is periodic.                            */
            tick_next  = p_tcb->TickCtrPrev + time;
 800788c:	440c      	add	r4, r1
            tick_delta = tick_next - OSTickCtr - 1u;
            if (tick_delta < time) {                             /* If next periodic delay did NOT already occur, ... */
 800788e:	4426      	add	r6, r4
 8007890:	42b1      	cmp	r1, r6
 8007892:	bf8c      	ite	hi
 8007894:	4621      	movhi	r1, r4
                p_tcb->TickCtrMatch = tick_next;                 /* ... set  next  periodic delay;                ... */
            } else {
                p_tcb->TickCtrMatch = OSTickCtr + time;          /* ... else reset periodic delay.                    */
 8007896:	1889      	addls	r1, r1, r2
            }
            p_tcb->TickRemain   = p_tcb->TickCtrMatch - OSTickCtr;
 8007898:	eba1 0202 	sub.w	r2, r1, r2
    } else if (time > (OS_TICK)0u) {
        if (opt == OS_OPT_TIME_PERIODIC) {                       /* Task time is periodic.                            */
            tick_next  = p_tcb->TickCtrPrev + time;
            tick_delta = tick_next - OSTickCtr - 1u;
            if (tick_delta < time) {                             /* If next periodic delay did NOT already occur, ... */
                p_tcb->TickCtrMatch = tick_next;                 /* ... set  next  periodic delay;                ... */
 800789c:	bf8c      	ite	hi
 800789e:	64c4      	strhi	r4, [r0, #76]	; 0x4c
            } else {
                p_tcb->TickCtrMatch = OSTickCtr + time;          /* ... else reset periodic delay.                    */
 80078a0:	64c1      	strls	r1, [r0, #76]	; 0x4c
            }
            p_tcb->TickRemain   = p_tcb->TickCtrMatch - OSTickCtr;
 80078a2:	6502      	str	r2, [r0, #80]	; 0x50
            p_tcb->TickCtrPrev  = p_tcb->TickCtrMatch;
 80078a4:	6481      	str	r1, [r0, #72]	; 0x48
 80078a6:	e78c      	b.n	80077c2 <OS_TickListInsert+0x1a>
 80078a8:	2000ef34 	.word	0x2000ef34
 80078ac:	080160b4 	.word	0x080160b4
 80078b0:	2000db48 	.word	0x2000db48

080078b4 <OS_TickListRemove>:
    OS_TCB         *p_tcb1;
    OS_TCB         *p_tcb2;



    p_spoke = p_tcb->TickSpokePtr;
 80078b4:	69c3      	ldr	r3, [r0, #28]
    if (p_spoke != (OS_TICK_SPOKE *)0) {                              /* Confirm that task is in tick list            */
 80078b6:	b18b      	cbz	r3, 80078dc <OS_TickListRemove+0x28>
        p_tcb->TickRemain = (OS_TICK)0u;
        if (p_spoke->FirstPtr == p_tcb) {                             /* Is timer to remove at the beginning of list? */
 80078b8:	6819      	ldr	r1, [r3, #0]



    p_spoke = p_tcb->TickSpokePtr;
    if (p_spoke != (OS_TICK_SPOKE *)0) {                              /* Confirm that task is in tick list            */
        p_tcb->TickRemain = (OS_TICK)0u;
 80078ba:	2200      	movs	r2, #0
        if (p_spoke->FirstPtr == p_tcb) {                             /* Is timer to remove at the beginning of list? */
 80078bc:	4288      	cmp	r0, r1



    p_spoke = p_tcb->TickSpokePtr;
    if (p_spoke != (OS_TICK_SPOKE *)0) {                              /* Confirm that task is in tick list            */
        p_tcb->TickRemain = (OS_TICK)0u;
 80078be:	6502      	str	r2, [r0, #80]	; 0x50
        if (p_spoke->FirstPtr == p_tcb) {                             /* Is timer to remove at the beginning of list? */
 80078c0:	d00d      	beq.n	80078de <OS_TickListRemove+0x2a>
            p_spoke->FirstPtr = p_tcb1;
            if (p_tcb1 != (OS_TCB *)0) {
                p_tcb1->TickPrevPtr = (OS_TCB *)0;
            }
        } else {
            p_tcb1              = p_tcb->TickPrevPtr;                 /* No, remove timer from somewhere in the list  */
 80078c2:	6981      	ldr	r1, [r0, #24]
            p_tcb2              = p_tcb->TickNextPtr;
 80078c4:	6942      	ldr	r2, [r0, #20]
            p_tcb1->TickNextPtr = p_tcb2;
 80078c6:	614a      	str	r2, [r1, #20]
            if (p_tcb2 != (OS_TCB *)0) {
 80078c8:	b102      	cbz	r2, 80078cc <OS_TickListRemove+0x18>
                p_tcb2->TickPrevPtr = p_tcb1;
 80078ca:	6191      	str	r1, [r2, #24]
        }
        p_tcb->TickNextPtr  = (OS_TCB        *)0;
        p_tcb->TickPrevPtr  = (OS_TCB        *)0;
        p_tcb->TickSpokePtr = (OS_TICK_SPOKE *)0;
        p_tcb->TickCtrMatch = (OS_TICK        )0u;
        p_spoke->NbrEntries--;
 80078cc:	8899      	ldrh	r1, [r3, #4]
            p_tcb1->TickNextPtr = p_tcb2;
            if (p_tcb2 != (OS_TCB *)0) {
                p_tcb2->TickPrevPtr = p_tcb1;
            }
        }
        p_tcb->TickNextPtr  = (OS_TCB        *)0;
 80078ce:	2200      	movs	r2, #0
        p_tcb->TickPrevPtr  = (OS_TCB        *)0;
        p_tcb->TickSpokePtr = (OS_TICK_SPOKE *)0;
        p_tcb->TickCtrMatch = (OS_TICK        )0u;
        p_spoke->NbrEntries--;
 80078d0:	3901      	subs	r1, #1
            p_tcb1->TickNextPtr = p_tcb2;
            if (p_tcb2 != (OS_TCB *)0) {
                p_tcb2->TickPrevPtr = p_tcb1;
            }
        }
        p_tcb->TickNextPtr  = (OS_TCB        *)0;
 80078d2:	6142      	str	r2, [r0, #20]
        p_tcb->TickPrevPtr  = (OS_TCB        *)0;
 80078d4:	6182      	str	r2, [r0, #24]
        p_tcb->TickSpokePtr = (OS_TICK_SPOKE *)0;
 80078d6:	61c2      	str	r2, [r0, #28]
        p_tcb->TickCtrMatch = (OS_TICK        )0u;
 80078d8:	64c2      	str	r2, [r0, #76]	; 0x4c
        p_spoke->NbrEntries--;
 80078da:	8099      	strh	r1, [r3, #4]
 80078dc:	4770      	bx	lr

    p_spoke = p_tcb->TickSpokePtr;
    if (p_spoke != (OS_TICK_SPOKE *)0) {                              /* Confirm that task is in tick list            */
        p_tcb->TickRemain = (OS_TICK)0u;
        if (p_spoke->FirstPtr == p_tcb) {                             /* Is timer to remove at the beginning of list? */
            p_tcb1            = (OS_TCB *)p_tcb->TickNextPtr;         /* Yes                                          */
 80078de:	6941      	ldr	r1, [r0, #20]
            p_spoke->FirstPtr = p_tcb1;
 80078e0:	6019      	str	r1, [r3, #0]
            if (p_tcb1 != (OS_TCB *)0) {
 80078e2:	2900      	cmp	r1, #0
 80078e4:	d0f2      	beq.n	80078cc <OS_TickListRemove+0x18>
                p_tcb1->TickPrevPtr = (OS_TCB *)0;
 80078e6:	618a      	str	r2, [r1, #24]
 80078e8:	e7f0      	b.n	80078cc <OS_TickListRemove+0x18>
 80078ea:	bf00      	nop

080078ec <OS_TickListResetPeak>:
    OS_TICK_SPOKE_IX   i;
    OS_TICK_SPOKE     *p_spoke;



    for (i = 0u; i < OSCfg_TickWheelSize; i++) {
 80078ec:	4b07      	ldr	r3, [pc, #28]	; (800790c <OS_TickListResetPeak+0x20>)
 80078ee:	881b      	ldrh	r3, [r3, #0]
 80078f0:	b153      	cbz	r3, 8007908 <OS_TickListResetPeak+0x1c>
 80078f2:	1e5a      	subs	r2, r3, #1
 80078f4:	b292      	uxth	r2, r2
 80078f6:	4b06      	ldr	r3, [pc, #24]	; (8007910 <OS_TickListResetPeak+0x24>)
 80078f8:	3201      	adds	r2, #1
 80078fa:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
        p_spoke                = (OS_TICK_SPOKE *)&OSCfg_TickWheel[i];
        p_spoke->NbrEntriesMax = (OS_OBJ_QTY     )0u;
 80078fe:	2100      	movs	r1, #0
 8007900:	80d9      	strh	r1, [r3, #6]
 8007902:	3308      	adds	r3, #8
    OS_TICK_SPOKE_IX   i;
    OS_TICK_SPOKE     *p_spoke;



    for (i = 0u; i < OSCfg_TickWheelSize; i++) {
 8007904:	4293      	cmp	r3, r2
 8007906:	d1fb      	bne.n	8007900 <OS_TickListResetPeak+0x14>
 8007908:	4770      	bx	lr
 800790a:	bf00      	nop
 800790c:	080160b4 	.word	0x080160b4
 8007910:	2000db48 	.word	0x2000db48

08007914 <OS_TickListUpdate>:
* Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
************************************************************************************************************************
*/

void  OS_TickListUpdate (void)
{
 8007914:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    CPU_TS             ts_start;
    CPU_TS             ts_end;
    CPU_SR_ALLOC();


    OS_CRITICAL_ENTER();
 8007918:	f7f9 ff2c 	bl	8001774 <CPU_SR_Save>
 800791c:	4681      	mov	r9, r0
    ts_start = OS_TS_GET();
 800791e:	f7f9 f935 	bl	8000b8c <CPU_TS_TmrRd>
    OSTickCtr++;                                                       /* Keep track of the number of ticks           */
 8007922:	f8df a114 	ldr.w	sl, [pc, #276]	; 8007a38 <OS_TickListUpdate+0x124>
    spoke    = (OS_TICK_SPOKE_IX)(OSTickCtr % OSCfg_TickWheelSize);
 8007926:	4b41      	ldr	r3, [pc, #260]	; (8007a2c <OS_TickListUpdate+0x118>)
    CPU_SR_ALLOC();


    OS_CRITICAL_ENTER();
    ts_start = OS_TS_GET();
    OSTickCtr++;                                                       /* Keep track of the number of ticks           */
 8007928:	f8da 2000 	ldr.w	r2, [sl]
    spoke    = (OS_TICK_SPOKE_IX)(OSTickCtr % OSCfg_TickWheelSize);
    p_spoke  = &OSCfg_TickWheel[spoke];
    p_tcb    = p_spoke->FirstPtr;
 800792c:	8819      	ldrh	r1, [r3, #0]
    CPU_SR_ALLOC();


    OS_CRITICAL_ENTER();
    ts_start = OS_TS_GET();
    OSTickCtr++;                                                       /* Keep track of the number of ticks           */
 800792e:	3201      	adds	r2, #1
    spoke    = (OS_TICK_SPOKE_IX)(OSTickCtr % OSCfg_TickWheelSize);
    p_spoke  = &OSCfg_TickWheel[spoke];
    p_tcb    = p_spoke->FirstPtr;
 8007930:	fbb2 f3f1 	udiv	r3, r2, r1
    CPU_TS             ts_end;
    CPU_SR_ALLOC();


    OS_CRITICAL_ENTER();
    ts_start = OS_TS_GET();
 8007934:	4606      	mov	r6, r0
    OSTickCtr++;                                                       /* Keep track of the number of ticks           */
    spoke    = (OS_TICK_SPOKE_IX)(OSTickCtr % OSCfg_TickWheelSize);
    p_spoke  = &OSCfg_TickWheel[spoke];
    p_tcb    = p_spoke->FirstPtr;
 8007936:	fb01 2313 	mls	r3, r1, r3, r2
 800793a:	493d      	ldr	r1, [pc, #244]	; (8007a30 <OS_TickListUpdate+0x11c>)
 800793c:	b29b      	uxth	r3, r3
 800793e:	f851 4033 	ldr.w	r4, [r1, r3, lsl #3]
    CPU_SR_ALLOC();


    OS_CRITICAL_ENTER();
    ts_start = OS_TS_GET();
    OSTickCtr++;                                                       /* Keep track of the number of ticks           */
 8007942:	f8ca 2000 	str.w	r2, [sl]
                case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
                     p_tcb->TickRemain = p_tcb->TickCtrMatch           /* Compute time remaining of current TCB       */
                                       - OSTickCtr;
                     if (OSTickCtr == p_tcb->TickCtrMatch) {           /* Process each TCB that expires               */
#if (OS_MSG_EN > 0u)
                         p_tcb->MsgPtr     = (void      *)0;
 8007946:	f04f 0b00 	mov.w	fp, #0
                         p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
#endif
                         p_tcb->TS         = OS_TS_GET();
                         OS_PendListRemove(p_tcb);                     /* Remove from wait list                       */
                         OS_TickListRemove(p_tcb);                     /* Remove from current wheel spoke             */
                         p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;
 800794a:	f04f 0804 	mov.w	r8, #4
                         p_tcb->PendStatus = OS_STATUS_PEND_TIMEOUT;   /* Indicate pend timed out                     */
 800794e:	2703      	movs	r7, #3
    spoke    = (OS_TICK_SPOKE_IX)(OSTickCtr % OSCfg_TickWheelSize);
    p_spoke  = &OSCfg_TickWheel[spoke];
    p_tcb    = p_spoke->FirstPtr;
    done     = DEF_FALSE;
    while (done == DEF_FALSE) {
        if (p_tcb != (OS_TCB *)0) {
 8007950:	b374      	cbz	r4, 80079b0 <OS_TickListUpdate+0x9c>
            p_tcb_next = p_tcb->TickNextPtr;                           /* Point to next TCB to update                 */
            switch (p_tcb->TaskState) {
 8007952:	f894 3036 	ldrb.w	r3, [r4, #54]	; 0x36
    p_spoke  = &OSCfg_TickWheel[spoke];
    p_tcb    = p_spoke->FirstPtr;
    done     = DEF_FALSE;
    while (done == DEF_FALSE) {
        if (p_tcb != (OS_TCB *)0) {
            p_tcb_next = p_tcb->TickNextPtr;                           /* Point to next TCB to update                 */
 8007956:	6965      	ldr	r5, [r4, #20]
            switch (p_tcb->TaskState) {
 8007958:	3b01      	subs	r3, #1
 800795a:	2b06      	cmp	r3, #6
 800795c:	d81f      	bhi.n	800799e <OS_TickListUpdate+0x8a>
 800795e:	e8df f003 	tbb	[pc, r3]
 8007962:	1e34      	.short	0x1e34
 8007964:	1e201e04 	.word	0x1e201e04
 8007968:	42          	.byte	0x42
 8007969:	00          	.byte	0x00
                         done             = DEF_TRUE;                  /* Don't find a match, we're done!             */
                     }
                     break;

                case OS_TASK_STATE_PEND_TIMEOUT:
                     p_tcb->TickRemain = p_tcb->TickCtrMatch           /* Compute time remaining of current TCB       */
 800796a:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
                                       - OSTickCtr;
 800796c:	f8da 3000 	ldr.w	r3, [sl]
                         done             = DEF_TRUE;                  /* Don't find a match, we're done!             */
                     }
                     break;

                case OS_TASK_STATE_PEND_TIMEOUT:
                     p_tcb->TickRemain = p_tcb->TickCtrMatch           /* Compute time remaining of current TCB       */
 8007970:	1ad1      	subs	r1, r2, r3
                                       - OSTickCtr;
                     if (OSTickCtr == p_tcb->TickCtrMatch) {           /* Process each TCB that expires               */
 8007972:	429a      	cmp	r2, r3
                         done             = DEF_TRUE;                  /* Don't find a match, we're done!             */
                     }
                     break;

                case OS_TASK_STATE_PEND_TIMEOUT:
                     p_tcb->TickRemain = p_tcb->TickCtrMatch           /* Compute time remaining of current TCB       */
 8007974:	6521      	str	r1, [r4, #80]	; 0x50
                                       - OSTickCtr;
                     if (OSTickCtr == p_tcb->TickCtrMatch) {           /* Process each TCB that expires               */
 8007976:	d11b      	bne.n	80079b0 <OS_TickListUpdate+0x9c>
#if (OS_MSG_EN > 0u)
                         p_tcb->MsgPtr     = (void      *)0;
 8007978:	f8c4 b05c 	str.w	fp, [r4, #92]	; 0x5c
                         p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
 800797c:	f8a4 b060 	strh.w	fp, [r4, #96]	; 0x60
#endif
                         p_tcb->TS         = OS_TS_GET();
 8007980:	f7f9 f904 	bl	8000b8c <CPU_TS_TmrRd>
 8007984:	6420      	str	r0, [r4, #64]	; 0x40
                         OS_PendListRemove(p_tcb);                     /* Remove from wait list                       */
 8007986:	4620      	mov	r0, r4
 8007988:	f7fc fb5c 	bl	8004044 <OS_PendListRemove>
                         OS_TaskRdy(p_tcb);
 800798c:	4620      	mov	r0, r4
 800798e:	f7fc fdc9 	bl	8004524 <OS_TaskRdy>
                         p_tcb->TaskState  = OS_TASK_STATE_RDY;
 8007992:	f884 b036 	strb.w	fp, [r4, #54]	; 0x36
                         p_tcb->PendStatus = OS_STATUS_PEND_TIMEOUT;   /* Indicate pend timed out                     */
 8007996:	f884 7035 	strb.w	r7, [r4, #53]	; 0x35
                         p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;  /* Indicate no longer pending                  */
 800799a:	f884 b034 	strb.w	fp, [r4, #52]	; 0x34
* Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
************************************************************************************************************************
*/

void  OS_TickListUpdate (void)
{
 800799e:	462c      	mov	r4, r5
 80079a0:	e7d6      	b.n	8007950 <OS_TickListUpdate+0x3c>
                         done              = DEF_TRUE;                 /* Don't find a match, we're done!             */
                     }
                     break;

                case OS_TASK_STATE_DLY_SUSPENDED:
                     p_tcb->TickRemain = p_tcb->TickCtrMatch           /* Compute time remaining of current TCB       */
 80079a2:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
                                       - OSTickCtr;
 80079a4:	f8da 3000 	ldr.w	r3, [sl]
                         done              = DEF_TRUE;                 /* Don't find a match, we're done!             */
                     }
                     break;

                case OS_TASK_STATE_DLY_SUSPENDED:
                     p_tcb->TickRemain = p_tcb->TickCtrMatch           /* Compute time remaining of current TCB       */
 80079a8:	1ad1      	subs	r1, r2, r3
                                       - OSTickCtr;
                     if (OSTickCtr == p_tcb->TickCtrMatch) {           /* Process each TCB that expires               */
 80079aa:	429a      	cmp	r2, r3
                         done              = DEF_TRUE;                 /* Don't find a match, we're done!             */
                     }
                     break;

                case OS_TASK_STATE_DLY_SUSPENDED:
                     p_tcb->TickRemain = p_tcb->TickCtrMatch           /* Compute time remaining of current TCB       */
 80079ac:	6521      	str	r1, [r4, #80]	; 0x50
                                       - OSTickCtr;
                     if (OSTickCtr == p_tcb->TickCtrMatch) {           /* Process each TCB that expires               */
 80079ae:	d036      	beq.n	8007a1e <OS_TickListUpdate+0x10a>
            p_tcb = p_tcb_next;
        } else {
            done  = DEF_TRUE;
        }
    }
    ts_end = OS_TS_GET() - ts_start;                                   /* Measure execution time of tick task         */
 80079b0:	f7f9 f8ec 	bl	8000b8c <CPU_TS_TmrRd>
    if (OSTickTaskTimeMax < ts_end) {
 80079b4:	4b1f      	ldr	r3, [pc, #124]	; (8007a34 <OS_TickListUpdate+0x120>)
            p_tcb = p_tcb_next;
        } else {
            done  = DEF_TRUE;
        }
    }
    ts_end = OS_TS_GET() - ts_start;                                   /* Measure execution time of tick task         */
 80079b6:	1b80      	subs	r0, r0, r6
    if (OSTickTaskTimeMax < ts_end) {
 80079b8:	681a      	ldr	r2, [r3, #0]
 80079ba:	4290      	cmp	r0, r2
 80079bc:	d900      	bls.n	80079c0 <OS_TickListUpdate+0xac>
        OSTickTaskTimeMax = ts_end;
 80079be:	6018      	str	r0, [r3, #0]
    }
    OS_CRITICAL_EXIT();
 80079c0:	4648      	mov	r0, r9
}
 80079c2:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    }
    ts_end = OS_TS_GET() - ts_start;                                   /* Measure execution time of tick task         */
    if (OSTickTaskTimeMax < ts_end) {
        OSTickTaskTimeMax = ts_end;
    }
    OS_CRITICAL_EXIT();
 80079c6:	f7f9 bed9 	b.w	800177c <CPU_SR_Restore>
                case OS_TASK_STATE_SUSPENDED:
                case OS_TASK_STATE_PEND_SUSPENDED:
                     break;

                case OS_TASK_STATE_DLY:
                     p_tcb->TickRemain = p_tcb->TickCtrMatch           /* Compute time remaining of current TCB       */
 80079ca:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
                                       - OSTickCtr;
 80079cc:	f8da 3000 	ldr.w	r3, [sl]
                case OS_TASK_STATE_SUSPENDED:
                case OS_TASK_STATE_PEND_SUSPENDED:
                     break;

                case OS_TASK_STATE_DLY:
                     p_tcb->TickRemain = p_tcb->TickCtrMatch           /* Compute time remaining of current TCB       */
 80079d0:	1ad1      	subs	r1, r2, r3
                                       - OSTickCtr;
                     if (OSTickCtr == p_tcb->TickCtrMatch) {           /* Process each TCB that expires               */
 80079d2:	429a      	cmp	r2, r3
                case OS_TASK_STATE_SUSPENDED:
                case OS_TASK_STATE_PEND_SUSPENDED:
                     break;

                case OS_TASK_STATE_DLY:
                     p_tcb->TickRemain = p_tcb->TickCtrMatch           /* Compute time remaining of current TCB       */
 80079d4:	6521      	str	r1, [r4, #80]	; 0x50
                                       - OSTickCtr;
                     if (OSTickCtr == p_tcb->TickCtrMatch) {           /* Process each TCB that expires               */
 80079d6:	d1eb      	bne.n	80079b0 <OS_TickListUpdate+0x9c>
                         p_tcb->TaskState = OS_TASK_STATE_RDY;
 80079d8:	f884 b036 	strb.w	fp, [r4, #54]	; 0x36
                         OS_TaskRdy(p_tcb);                            /* Make task ready to run                      */
 80079dc:	4620      	mov	r0, r4
 80079de:	f7fc fda1 	bl	8004524 <OS_TaskRdy>
* Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
************************************************************************************************************************
*/

void  OS_TickListUpdate (void)
{
 80079e2:	462c      	mov	r4, r5
 80079e4:	e7b4      	b.n	8007950 <OS_TickListUpdate+0x3c>
                         done              = DEF_TRUE;                 /* Don't find a match, we're done!             */
                     }
                     break;

                case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
                     p_tcb->TickRemain = p_tcb->TickCtrMatch           /* Compute time remaining of current TCB       */
 80079e6:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
                                       - OSTickCtr;
 80079e8:	f8da 3000 	ldr.w	r3, [sl]
                         done              = DEF_TRUE;                 /* Don't find a match, we're done!             */
                     }
                     break;

                case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
                     p_tcb->TickRemain = p_tcb->TickCtrMatch           /* Compute time remaining of current TCB       */
 80079ec:	1ad1      	subs	r1, r2, r3
                                       - OSTickCtr;
                     if (OSTickCtr == p_tcb->TickCtrMatch) {           /* Process each TCB that expires               */
 80079ee:	429a      	cmp	r2, r3
                         done              = DEF_TRUE;                 /* Don't find a match, we're done!             */
                     }
                     break;

                case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
                     p_tcb->TickRemain = p_tcb->TickCtrMatch           /* Compute time remaining of current TCB       */
 80079f0:	6521      	str	r1, [r4, #80]	; 0x50
                                       - OSTickCtr;
                     if (OSTickCtr == p_tcb->TickCtrMatch) {           /* Process each TCB that expires               */
 80079f2:	d1dd      	bne.n	80079b0 <OS_TickListUpdate+0x9c>
#if (OS_MSG_EN > 0u)
                         p_tcb->MsgPtr     = (void      *)0;
 80079f4:	f8c4 b05c 	str.w	fp, [r4, #92]	; 0x5c
                         p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
 80079f8:	f8a4 b060 	strh.w	fp, [r4, #96]	; 0x60
#endif
                         p_tcb->TS         = OS_TS_GET();
 80079fc:	f7f9 f8c6 	bl	8000b8c <CPU_TS_TmrRd>
 8007a00:	6420      	str	r0, [r4, #64]	; 0x40
                         OS_PendListRemove(p_tcb);                     /* Remove from wait list                       */
 8007a02:	4620      	mov	r0, r4
 8007a04:	f7fc fb1e 	bl	8004044 <OS_PendListRemove>
                         OS_TickListRemove(p_tcb);                     /* Remove from current wheel spoke             */
 8007a08:	4620      	mov	r0, r4
 8007a0a:	f7ff ff53 	bl	80078b4 <OS_TickListRemove>
                         p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;
 8007a0e:	f884 8036 	strb.w	r8, [r4, #54]	; 0x36
                         p_tcb->PendStatus = OS_STATUS_PEND_TIMEOUT;   /* Indicate pend timed out                     */
 8007a12:	f884 7035 	strb.w	r7, [r4, #53]	; 0x35
                         p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;  /* Indicate no longer pending                  */
 8007a16:	f884 b034 	strb.w	fp, [r4, #52]	; 0x34
* Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
************************************************************************************************************************
*/

void  OS_TickListUpdate (void)
{
 8007a1a:	462c      	mov	r4, r5
 8007a1c:	e798      	b.n	8007950 <OS_TickListUpdate+0x3c>

                case OS_TASK_STATE_DLY_SUSPENDED:
                     p_tcb->TickRemain = p_tcb->TickCtrMatch           /* Compute time remaining of current TCB       */
                                       - OSTickCtr;
                     if (OSTickCtr == p_tcb->TickCtrMatch) {           /* Process each TCB that expires               */
                         p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;
 8007a1e:	f884 8036 	strb.w	r8, [r4, #54]	; 0x36
                         OS_TickListRemove(p_tcb);                     /* Remove from current wheel spoke             */
 8007a22:	4620      	mov	r0, r4
 8007a24:	f7ff ff46 	bl	80078b4 <OS_TickListRemove>
* Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
************************************************************************************************************************
*/

void  OS_TickListUpdate (void)
{
 8007a28:	462c      	mov	r4, r5
 8007a2a:	e791      	b.n	8007950 <OS_TickListUpdate+0x3c>
 8007a2c:	080160b4 	.word	0x080160b4
 8007a30:	2000db48 	.word	0x2000db48
 8007a34:	2000f028 	.word	0x2000f028
 8007a38:	2000ef34 	.word	0x2000ef34

08007a3c <OS_TickTask>:
* Note(s)    : This function is INTERNAL to uC/OS-III and your application should not call it.
************************************************************************************************************************
*/

void  OS_TickTask (void  *p_arg)
{
 8007a3c:	b510      	push	{r4, lr}
 8007a3e:	4c09      	ldr	r4, [pc, #36]	; (8007a64 <OS_TickTask+0x28>)
 8007a40:	b082      	sub	sp, #8


    p_arg = p_arg;                                          /* Prevent compiler warning                               */

    while (DEF_ON) {
        (void)OSTaskSemPend((OS_TICK  )0,
 8007a42:	2100      	movs	r1, #0
 8007a44:	f10d 0302 	add.w	r3, sp, #2
 8007a48:	4608      	mov	r0, r1
 8007a4a:	aa01      	add	r2, sp, #4
 8007a4c:	f7ff f8aa 	bl	8006ba4 <OSTaskSemPend>
                            (OS_OPT   )OS_OPT_PEND_BLOCKING,
                            (CPU_TS  *)&ts,
                            (OS_ERR  *)&err);               /* Wait for signal from tick interrupt                    */
        if (err == OS_ERR_NONE) {
 8007a50:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 8007a54:	2b00      	cmp	r3, #0
 8007a56:	d1f4      	bne.n	8007a42 <OS_TickTask+0x6>
            if (OSRunning == OS_STATE_OS_RUNNING) {
 8007a58:	7823      	ldrb	r3, [r4, #0]
 8007a5a:	2b01      	cmp	r3, #1
 8007a5c:	d1f1      	bne.n	8007a42 <OS_TickTask+0x6>
                OS_TickListUpdate();                        /* Update all tasks waiting for time                      */
 8007a5e:	f7ff ff59 	bl	8007914 <OS_TickListUpdate>
 8007a62:	e7ee      	b.n	8007a42 <OS_TickTask+0x6>
 8007a64:	2000e985 	.word	0x2000e985

08007a68 <OSTimeDly>:
*/

void  OSTimeDly (OS_TICK   dly,
                 OS_OPT    opt,
                 OS_ERR   *p_err)
{
 8007a68:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
        return;
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0u) {             /* Not allowed to call from an ISR                        */
 8007a6c:	4b22      	ldr	r3, [pc, #136]	; (8007af8 <OSTimeDly+0x90>)
 8007a6e:	781c      	ldrb	r4, [r3, #0]
 8007a70:	b984      	cbnz	r4, 8007a94 <OSTimeDly+0x2c>
       *p_err = OS_ERR_TIME_DLY_ISR;
        return;
    }
#endif

    if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0u) {       /* Can't delay when the scheduler is locked               */
 8007a72:	4b22      	ldr	r3, [pc, #136]	; (8007afc <OSTimeDly+0x94>)
 8007a74:	781b      	ldrb	r3, [r3, #0]
 8007a76:	b943      	cbnz	r3, 8007a8a <OSTimeDly+0x22>
       *p_err = OS_ERR_SCHED_LOCKED;
        return;
    }

    switch (opt) {
 8007a78:	2908      	cmp	r1, #8
 8007a7a:	d82e      	bhi.n	8007ada <OSTimeDly+0x72>
 8007a7c:	e8df f001 	tbb	[pc, r1]
 8007a80:	2d0f2d0f 	.word	0x2d0f2d0f
 8007a84:	2d2d2d10 	.word	0x2d2d2d10
 8007a88:	0f          	.byte	0x0f
 8007a89:	00          	.byte	0x00
        return;
    }
#endif

    if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0u) {       /* Can't delay when the scheduler is locked               */
       *p_err = OS_ERR_SCHED_LOCKED;
 8007a8a:	f646 5363 	movw	r3, #28003	; 0x6d63
 8007a8e:	8013      	strh	r3, [r2, #0]
        return;
 8007a90:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0u) {             /* Not allowed to call from an ISR                        */
       *p_err = OS_ERR_TIME_DLY_ISR;
 8007a94:	f247 2375 	movw	r3, #29301	; 0x7275
 8007a98:	8013      	strh	r3, [r2, #0]
        return;
 8007a9a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

    switch (opt) {
        case OS_OPT_TIME_DLY:
        case OS_OPT_TIME_TIMEOUT:
        case OS_OPT_TIME_PERIODIC:
             if (dly == (OS_TICK)0u) {                      /* 0 means no delay!                                      */
 8007a9e:	b330      	cbz	r0, 8007aee <OSTimeDly+0x86>
 8007aa0:	4615      	mov	r5, r2
 8007aa2:	460c      	mov	r4, r1
 8007aa4:	4606      	mov	r6, r0
        default:
            *p_err = OS_ERR_OPT_INVALID;
             return;
    }

    OS_CRITICAL_ENTER();
 8007aa6:	f7f9 fe65 	bl	8001774 <CPU_SR_Save>
    OSTCBCurPtr->TaskState = OS_TASK_STATE_DLY;
 8007aaa:	4f15      	ldr	r7, [pc, #84]	; (8007b00 <OSTimeDly+0x98>)
        default:
            *p_err = OS_ERR_OPT_INVALID;
             return;
    }

    OS_CRITICAL_ENTER();
 8007aac:	4680      	mov	r8, r0
    OSTCBCurPtr->TaskState = OS_TASK_STATE_DLY;
 8007aae:	6838      	ldr	r0, [r7, #0]
 8007ab0:	2301      	movs	r3, #1
    OS_TickListInsert(OSTCBCurPtr,
 8007ab2:	4622      	mov	r2, r4
            *p_err = OS_ERR_OPT_INVALID;
             return;
    }

    OS_CRITICAL_ENTER();
    OSTCBCurPtr->TaskState = OS_TASK_STATE_DLY;
 8007ab4:	f880 3036 	strb.w	r3, [r0, #54]	; 0x36
    OS_TickListInsert(OSTCBCurPtr,
 8007ab8:	4631      	mov	r1, r6
 8007aba:	462b      	mov	r3, r5
 8007abc:	f7ff fe74 	bl	80077a8 <OS_TickListInsert>
                      dly,
                      opt,
                      p_err);
    if (*p_err != OS_ERR_NONE) {
 8007ac0:	882c      	ldrh	r4, [r5, #0]
 8007ac2:	b97c      	cbnz	r4, 8007ae4 <OSTimeDly+0x7c>
         OS_CRITICAL_EXIT_NO_SCHED();
         return;
    }
    OS_RdyListRemove(OSTCBCurPtr);                          /* Remove current task from ready list                    */
 8007ac4:	6838      	ldr	r0, [r7, #0]
 8007ac6:	f7fc fc41 	bl	800434c <OS_RdyListRemove>
    OS_CRITICAL_EXIT_NO_SCHED();
 8007aca:	4640      	mov	r0, r8
 8007acc:	f7f9 fe56 	bl	800177c <CPU_SR_Restore>
    OSSched();                                              /* Find next task to run!                                 */
 8007ad0:	f7fc f82a 	bl	8003b28 <OSSched>
   *p_err = OS_ERR_NONE;
 8007ad4:	802c      	strh	r4, [r5, #0]
 8007ad6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

        case OS_OPT_TIME_MATCH:
             break;

        default:
            *p_err = OS_ERR_OPT_INVALID;
 8007ada:	f645 6325 	movw	r3, #24101	; 0x5e25
 8007ade:	8013      	strh	r3, [r2, #0]
             return;
 8007ae0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    OS_TickListInsert(OSTCBCurPtr,
                      dly,
                      opt,
                      p_err);
    if (*p_err != OS_ERR_NONE) {
         OS_CRITICAL_EXIT_NO_SCHED();
 8007ae4:	4640      	mov	r0, r8
    }
    OS_RdyListRemove(OSTCBCurPtr);                          /* Remove current task from ready list                    */
    OS_CRITICAL_EXIT_NO_SCHED();
    OSSched();                                              /* Find next task to run!                                 */
   *p_err = OS_ERR_NONE;
}
 8007ae6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    OS_TickListInsert(OSTCBCurPtr,
                      dly,
                      opt,
                      p_err);
    if (*p_err != OS_ERR_NONE) {
         OS_CRITICAL_EXIT_NO_SCHED();
 8007aea:	f7f9 be47 	b.w	800177c <CPU_SR_Restore>
    switch (opt) {
        case OS_OPT_TIME_DLY:
        case OS_OPT_TIME_TIMEOUT:
        case OS_OPT_TIME_PERIODIC:
             if (dly == (OS_TICK)0u) {                      /* 0 means no delay!                                      */
                *p_err = OS_ERR_TIME_ZERO_DLY;
 8007aee:	f247 237e 	movw	r3, #29310	; 0x727e
 8007af2:	8013      	strh	r3, [r2, #0]
                 return;
 8007af4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8007af8:	2000ed84 	.word	0x2000ed84
 8007afc:	2000e974 	.word	0x2000e974
 8007b00:	2000ed58 	.word	0x2000ed58

08007b04 <OSTimeDlyHMSM>:
                     CPU_INT16U   minutes,
                     CPU_INT16U   seconds,
                     CPU_INT32U   milli,
                     OS_OPT       opt,
                     OS_ERR      *p_err)
{
 8007b04:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
        return;
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0u) {             /* Not allowed to call from an ISR                        */
 8007b08:	4c46      	ldr	r4, [pc, #280]	; (8007c24 <OSTimeDlyHMSM+0x120>)
                     CPU_INT16U   minutes,
                     CPU_INT16U   seconds,
                     CPU_INT32U   milli,
                     OS_OPT       opt,
                     OS_ERR      *p_err)
{
 8007b0a:	f8bd 6018 	ldrh.w	r6, [sp, #24]
        return;
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0u) {             /* Not allowed to call from an ISR                        */
 8007b0e:	7825      	ldrb	r5, [r4, #0]
                     CPU_INT16U   minutes,
                     CPU_INT16U   seconds,
                     CPU_INT32U   milli,
                     OS_OPT       opt,
                     OS_ERR      *p_err)
{
 8007b10:	9c07      	ldr	r4, [sp, #28]
        return;
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0u) {             /* Not allowed to call from an ISR                        */
 8007b12:	2d00      	cmp	r5, #0
 8007b14:	d144      	bne.n	8007ba0 <OSTimeDlyHMSM+0x9c>
       *p_err = OS_ERR_TIME_DLY_ISR;
        return;
    }
#endif

    if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0u) {       /* Can't delay when the scheduler is locked               */
 8007b16:	4d44      	ldr	r5, [pc, #272]	; (8007c28 <OSTimeDlyHMSM+0x124>)
 8007b18:	782d      	ldrb	r5, [r5, #0]
 8007b1a:	b955      	cbnz	r5, 8007b32 <OSTimeDlyHMSM+0x2e>
       *p_err = OS_ERR_SCHED_LOCKED;
        return;
    }

    opt_time = opt & OS_OPT_TIME_MASK;                      /* Retrieve time options only.                            */
 8007b1c:	f006 050e 	and.w	r5, r6, #14
    switch (opt_time) {
 8007b20:	2d08      	cmp	r5, #8
 8007b22:	d838      	bhi.n	8007b96 <OSTimeDlyHMSM+0x92>
 8007b24:	e8df f005 	tbb	[pc, r5]
 8007b28:	370a370a 	.word	0x370a370a
 8007b2c:	3737370e 	.word	0x3737370e
 8007b30:	0a          	.byte	0x0a
 8007b31:	00          	.byte	0x00
        return;
    }
#endif

    if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0u) {       /* Can't delay when the scheduler is locked               */
       *p_err = OS_ERR_SCHED_LOCKED;
 8007b32:	f646 5363 	movw	r3, #28003	; 0x6d63
 8007b36:	8023      	strh	r3, [r4, #0]
        return;
 8007b38:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    opt_time = opt & OS_OPT_TIME_MASK;                      /* Retrieve time options only.                            */
    switch (opt_time) {
        case OS_OPT_TIME_DLY:
        case OS_OPT_TIME_TIMEOUT:
        case OS_OPT_TIME_PERIODIC:
             if (milli == (CPU_INT32U)0u) {                 /* Make sure we didn't specify a 0 delay                  */
 8007b3c:	b913      	cbnz	r3, 8007b44 <OSTimeDlyHMSM+0x40>
                 if (seconds == (CPU_INT16U)0u) {
 8007b3e:	b90a      	cbnz	r2, 8007b44 <OSTimeDlyHMSM+0x40>
                     if (minutes == (CPU_INT16U)0u) {
 8007b40:	b901      	cbnz	r1, 8007b44 <OSTimeDlyHMSM+0x40>
                         if (hours == (CPU_INT16U)0u) {
 8007b42:	b318      	cbz	r0, 8007b8c <OSTimeDlyHMSM+0x88>
             return;
    }

#if OS_CFG_ARG_CHK_EN > 0u                                  /* Validate arguments to be within range                  */
    opt_invalid = DEF_BIT_IS_SET_ANY(opt, ~OS_OPT_TIME_OPTS_MASK);
    if (opt_invalid == DEF_YES) {
 8007b44:	f026 071e 	bic.w	r7, r6, #30
 8007b48:	bb2f      	cbnz	r7, 8007b96 <OSTimeDlyHMSM+0x92>
       *p_err = OS_ERR_OPT_INVALID;
        return;
    }

    opt_non_strict = DEF_BIT_IS_SET(opt, OS_OPT_TIME_HMSM_NON_STRICT);
 8007b4a:	06f6      	lsls	r6, r6, #27
 8007b4c:	d52d      	bpl.n	8007baa <OSTimeDlyHMSM+0xa6>
         if (hours   > (CPU_INT16U)99u) {
            *p_err = OS_ERR_TIME_INVALID_HOURS;
             return;
         }
    } else {
         if (minutes > (CPU_INT16U)9999u) {
 8007b4e:	f242 760f 	movw	r6, #9999	; 0x270f
 8007b52:	42b1      	cmp	r1, r6
 8007b54:	d837      	bhi.n	8007bc6 <OSTimeDlyHMSM+0xc2>
            *p_err = OS_ERR_TIME_INVALID_MINUTES;
             return;
         }
         if (hours   > (CPU_INT16U)999u) {
 8007b56:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8007b5a:	d22f      	bcs.n	8007bbc <OSTimeDlyHMSM+0xb8>
    }
#endif

                                                            /* Compute the total number of clock ticks required..     */
                                                            /* .. (rounded to the nearest tick)                       */
    tick_rate = OSCfg_TickRate_Hz;
 8007b5c:	4e33      	ldr	r6, [pc, #204]	; (8007c2c <OSTimeDlyHMSM+0x128>)
    ticks     = ((OS_TICK)hours * (OS_TICK)3600u + (OS_TICK)minutes * (OS_TICK)60u + (OS_TICK)seconds) * tick_rate
 8007b5e:	ebc1 1701 	rsb	r7, r1, r1, lsl #4
    }
#endif

                                                            /* Compute the total number of clock ticks required..     */
                                                            /* .. (rounded to the nearest tick)                       */
    tick_rate = OSCfg_TickRate_Hz;
 8007b62:	6831      	ldr	r1, [r6, #0]
    ticks     = ((OS_TICK)hours * (OS_TICK)3600u + (OS_TICK)minutes * (OS_TICK)60u + (OS_TICK)seconds) * tick_rate
 8007b64:	f44f 76fa 	mov.w	r6, #500	; 0x1f4
 8007b68:	fbb6 f6f1 	udiv	r6, r6, r1
 8007b6c:	4433      	add	r3, r6
 8007b6e:	fb01 f303 	mul.w	r3, r1, r3
 8007b72:	4e2f      	ldr	r6, [pc, #188]	; (8007c30 <OSTimeDlyHMSM+0x12c>)
 8007b74:	eb02 0287 	add.w	r2, r2, r7, lsl #2
 8007b78:	fba6 6303 	umull	r6, r3, r6, r3
 8007b7c:	f44f 6761 	mov.w	r7, #3600	; 0xe10
 8007b80:	fb07 2000 	mla	r0, r7, r0, r2
 8007b84:	099b      	lsrs	r3, r3, #6
 8007b86:	fb01 3600 	mla	r6, r1, r0, r3
              + (tick_rate * ((OS_TICK)milli + (OS_TICK)500u / tick_rate)) / (OS_TICK)1000u;

    if (ticks > (OS_TICK)0u) {
 8007b8a:	bb5e      	cbnz	r6, 8007be4 <OSTimeDlyHMSM+0xe0>
        case OS_OPT_TIME_PERIODIC:
             if (milli == (CPU_INT32U)0u) {                 /* Make sure we didn't specify a 0 delay                  */
                 if (seconds == (CPU_INT16U)0u) {
                     if (minutes == (CPU_INT16U)0u) {
                         if (hours == (CPU_INT16U)0u) {
                            *p_err = OS_ERR_TIME_ZERO_DLY;
 8007b8c:	f247 237e 	movw	r3, #29310	; 0x727e
 8007b90:	8023      	strh	r3, [r4, #0]
                             return;
 8007b92:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }

#if OS_CFG_ARG_CHK_EN > 0u                                  /* Validate arguments to be within range                  */
    opt_invalid = DEF_BIT_IS_SET_ANY(opt, ~OS_OPT_TIME_OPTS_MASK);
    if (opt_invalid == DEF_YES) {
       *p_err = OS_ERR_OPT_INVALID;
 8007b96:	f645 6325 	movw	r3, #24101	; 0x5e25
 8007b9a:	8023      	strh	r3, [r4, #0]
        return;
 8007b9c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0u) {             /* Not allowed to call from an ISR                        */
       *p_err = OS_ERR_TIME_DLY_ISR;
 8007ba0:	f247 2375 	movw	r3, #29301	; 0x7275
 8007ba4:	8023      	strh	r3, [r4, #0]
        return;
 8007ba6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return;
    }

    opt_non_strict = DEF_BIT_IS_SET(opt, OS_OPT_TIME_HMSM_NON_STRICT);
    if (opt_non_strict != DEF_YES) {
         if (milli   > (CPU_INT32U)999u) {
 8007baa:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8007bae:	d214      	bcs.n	8007bda <OSTimeDlyHMSM+0xd6>
            *p_err = OS_ERR_TIME_INVALID_MILLISECONDS;
             return;
         }
         if (seconds > (CPU_INT16U)59u) {
 8007bb0:	2a3b      	cmp	r2, #59	; 0x3b
 8007bb2:	d80d      	bhi.n	8007bd0 <OSTimeDlyHMSM+0xcc>
            *p_err = OS_ERR_TIME_INVALID_SECONDS;
             return;
         }
         if (minutes > (CPU_INT16U)59u) {
 8007bb4:	293b      	cmp	r1, #59	; 0x3b
 8007bb6:	d806      	bhi.n	8007bc6 <OSTimeDlyHMSM+0xc2>
            *p_err = OS_ERR_TIME_INVALID_MINUTES;
             return;
         }
         if (hours   > (CPU_INT16U)99u) {
 8007bb8:	2863      	cmp	r0, #99	; 0x63
 8007bba:	d9cf      	bls.n	8007b5c <OSTimeDlyHMSM+0x58>
            *p_err = OS_ERR_TIME_INVALID_HOURS;
 8007bbc:	f247 2378 	movw	r3, #29304	; 0x7278
 8007bc0:	8023      	strh	r3, [r4, #0]
             return;
 8007bc2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
         if (seconds > (CPU_INT16U)59u) {
            *p_err = OS_ERR_TIME_INVALID_SECONDS;
             return;
         }
         if (minutes > (CPU_INT16U)59u) {
            *p_err = OS_ERR_TIME_INVALID_MINUTES;
 8007bc6:	f247 2379 	movw	r3, #29305	; 0x7279
 8007bca:	8023      	strh	r3, [r4, #0]
             return;
 8007bcc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
         if (milli   > (CPU_INT32U)999u) {
            *p_err = OS_ERR_TIME_INVALID_MILLISECONDS;
             return;
         }
         if (seconds > (CPU_INT16U)59u) {
            *p_err = OS_ERR_TIME_INVALID_SECONDS;
 8007bd0:	f247 237a 	movw	r3, #29306	; 0x727a
 8007bd4:	8023      	strh	r3, [r4, #0]
             return;
 8007bd6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }

    opt_non_strict = DEF_BIT_IS_SET(opt, OS_OPT_TIME_HMSM_NON_STRICT);
    if (opt_non_strict != DEF_YES) {
         if (milli   > (CPU_INT32U)999u) {
            *p_err = OS_ERR_TIME_INVALID_MILLISECONDS;
 8007bda:	f247 237b 	movw	r3, #29307	; 0x727b
 8007bde:	8023      	strh	r3, [r4, #0]
             return;
 8007be0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    tick_rate = OSCfg_TickRate_Hz;
    ticks     = ((OS_TICK)hours * (OS_TICK)3600u + (OS_TICK)minutes * (OS_TICK)60u + (OS_TICK)seconds) * tick_rate
              + (tick_rate * ((OS_TICK)milli + (OS_TICK)500u / tick_rate)) / (OS_TICK)1000u;

    if (ticks > (OS_TICK)0u) {
        OS_CRITICAL_ENTER();
 8007be4:	f7f9 fdc6 	bl	8001774 <CPU_SR_Save>
        OSTCBCurPtr->TaskState = OS_TASK_STATE_DLY;
 8007be8:	4f12      	ldr	r7, [pc, #72]	; (8007c34 <OSTimeDlyHMSM+0x130>)
    tick_rate = OSCfg_TickRate_Hz;
    ticks     = ((OS_TICK)hours * (OS_TICK)3600u + (OS_TICK)minutes * (OS_TICK)60u + (OS_TICK)seconds) * tick_rate
              + (tick_rate * ((OS_TICK)milli + (OS_TICK)500u / tick_rate)) / (OS_TICK)1000u;

    if (ticks > (OS_TICK)0u) {
        OS_CRITICAL_ENTER();
 8007bea:	4680      	mov	r8, r0
        OSTCBCurPtr->TaskState = OS_TASK_STATE_DLY;
 8007bec:	6838      	ldr	r0, [r7, #0]
 8007bee:	2301      	movs	r3, #1
        OS_TickListInsert(OSTCBCurPtr,
 8007bf0:	462a      	mov	r2, r5
    ticks     = ((OS_TICK)hours * (OS_TICK)3600u + (OS_TICK)minutes * (OS_TICK)60u + (OS_TICK)seconds) * tick_rate
              + (tick_rate * ((OS_TICK)milli + (OS_TICK)500u / tick_rate)) / (OS_TICK)1000u;

    if (ticks > (OS_TICK)0u) {
        OS_CRITICAL_ENTER();
        OSTCBCurPtr->TaskState = OS_TASK_STATE_DLY;
 8007bf2:	f880 3036 	strb.w	r3, [r0, #54]	; 0x36
        OS_TickListInsert(OSTCBCurPtr,
 8007bf6:	4631      	mov	r1, r6
 8007bf8:	4623      	mov	r3, r4
 8007bfa:	f7ff fdd5 	bl	80077a8 <OS_TickListInsert>
                          ticks,
                          opt_time,
                          p_err);
        if (*p_err != OS_ERR_NONE) {
 8007bfe:	8825      	ldrh	r5, [r4, #0]
 8007c00:	b125      	cbz	r5, 8007c0c <OSTimeDlyHMSM+0x108>
             OS_CRITICAL_EXIT_NO_SCHED();
 8007c02:	4640      	mov	r0, r8
        OSSched();                                          /* Find next task to run!                                 */
       *p_err = OS_ERR_NONE;
    } else {
       *p_err = OS_ERR_TIME_ZERO_DLY;
    }
}
 8007c04:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        OS_TickListInsert(OSTCBCurPtr,
                          ticks,
                          opt_time,
                          p_err);
        if (*p_err != OS_ERR_NONE) {
             OS_CRITICAL_EXIT_NO_SCHED();
 8007c08:	f7f9 bdb8 	b.w	800177c <CPU_SR_Restore>
             return;
        }
        OS_RdyListRemove(OSTCBCurPtr);                      /* Remove current task from ready list                    */
 8007c0c:	6838      	ldr	r0, [r7, #0]
 8007c0e:	f7fc fb9d 	bl	800434c <OS_RdyListRemove>
        OS_CRITICAL_EXIT_NO_SCHED();
 8007c12:	4640      	mov	r0, r8
 8007c14:	f7f9 fdb2 	bl	800177c <CPU_SR_Restore>
        OSSched();                                          /* Find next task to run!                                 */
 8007c18:	f7fb ff86 	bl	8003b28 <OSSched>
       *p_err = OS_ERR_NONE;
 8007c1c:	8025      	strh	r5, [r4, #0]
 8007c1e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8007c22:	bf00      	nop
 8007c24:	2000ed84 	.word	0x2000ed84
 8007c28:	2000e974 	.word	0x2000e974
 8007c2c:	080160cc 	.word	0x080160cc
 8007c30:	10624dd3 	.word	0x10624dd3
 8007c34:	2000ed58 	.word	0x2000ed58

08007c38 <OSTimeGet>:
* Returns    : The current value of OSTickCtr
************************************************************************************************************************
*/

OS_TICK  OSTimeGet (OS_ERR  *p_err)
{
 8007c38:	b538      	push	{r3, r4, r5, lr}
 8007c3a:	4604      	mov	r4, r0
        OS_SAFETY_CRITICAL_EXCEPTION();
        return ((OS_TICK)0);
    }
#endif

    CPU_CRITICAL_ENTER();
 8007c3c:	f7f9 fd9a 	bl	8001774 <CPU_SR_Save>
    ticks = OSTickCtr;
 8007c40:	4b03      	ldr	r3, [pc, #12]	; (8007c50 <OSTimeGet+0x18>)
 8007c42:	681d      	ldr	r5, [r3, #0]
    CPU_CRITICAL_EXIT();
 8007c44:	f7f9 fd9a 	bl	800177c <CPU_SR_Restore>
   *p_err = OS_ERR_NONE;
 8007c48:	2300      	movs	r3, #0
    return (ticks);
}
 8007c4a:	4628      	mov	r0, r5
#endif

    CPU_CRITICAL_ENTER();
    ticks = OSTickCtr;
    CPU_CRITICAL_EXIT();
   *p_err = OS_ERR_NONE;
 8007c4c:	8023      	strh	r3, [r4, #0]
    return (ticks);
}
 8007c4e:	bd38      	pop	{r3, r4, r5, pc}
 8007c50:	2000ef34 	.word	0x2000ef34

08007c54 <OSTimeSet>:
************************************************************************************************************************
*/

void  OSTimeSet (OS_TICK   ticks,
                 OS_ERR   *p_err)
{
 8007c54:	b538      	push	{r3, r4, r5, lr}
 8007c56:	4605      	mov	r5, r0
 8007c58:	460c      	mov	r4, r1
        OS_SAFETY_CRITICAL_EXCEPTION();
        return;
    }
#endif

    CPU_CRITICAL_ENTER();
 8007c5a:	f7f9 fd8b 	bl	8001774 <CPU_SR_Save>
    OSTickCtr = ticks;
 8007c5e:	4b03      	ldr	r3, [pc, #12]	; (8007c6c <OSTimeSet+0x18>)
 8007c60:	601d      	str	r5, [r3, #0]
    CPU_CRITICAL_EXIT();
 8007c62:	f7f9 fd8b 	bl	800177c <CPU_SR_Restore>
   *p_err     = OS_ERR_NONE;
 8007c66:	2300      	movs	r3, #0
 8007c68:	8023      	strh	r3, [r4, #0]
 8007c6a:	bd38      	pop	{r3, r4, r5, pc}
 8007c6c:	2000ef34 	.word	0x2000ef34

08007c70 <OSTimeTick>:
* Returns    : none
************************************************************************************************************************
*/

void  OSTimeTick (void)
{
 8007c70:	b510      	push	{r4, lr}
 8007c72:	b082      	sub	sp, #8
#if OS_CFG_ISR_POST_DEFERRED_EN > 0u
    CPU_TS  ts;
#endif


    OSTimeTickHook();                                       /* Call user definable hook                               */
 8007c74:	f7fc feb4 	bl	80049e0 <OSTimeTickHook>
                (CPU_TS     ) ts,
                (OS_ERR    *)&err);

#else

   (void)OSTaskSemPost((OS_TCB *)&OSTickTaskTCB,            /* Signal tick task                                       */
 8007c78:	2100      	movs	r1, #0
 8007c7a:	f10d 0206 	add.w	r2, sp, #6
 8007c7e:	480d      	ldr	r0, [pc, #52]	; (8007cb4 <OSTimeTick+0x44>)
 8007c80:	f7ff fc8e 	bl	80075a0 <OSTaskSemPost>
                       (OS_OPT  ) OS_OPT_POST_NONE,
                       (OS_ERR *)&err);


#if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
    OS_SchedRoundRobin(&OSRdyList[OSPrioCur]);
 8007c84:	4b0c      	ldr	r3, [pc, #48]	; (8007cb8 <OSTimeTick+0x48>)
 8007c86:	480d      	ldr	r0, [pc, #52]	; (8007cbc <OSTimeTick+0x4c>)
 8007c88:	781b      	ldrb	r3, [r3, #0]
 8007c8a:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8007c8e:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 8007c92:	f7fc fba7 	bl	80043e4 <OS_SchedRoundRobin>
#endif

#if OS_CFG_TMR_EN > 0u
    OSTmrUpdateCtr--;
 8007c96:	4b0a      	ldr	r3, [pc, #40]	; (8007cc0 <OSTimeTick+0x50>)
 8007c98:	6819      	ldr	r1, [r3, #0]
 8007c9a:	3901      	subs	r1, #1
 8007c9c:	6019      	str	r1, [r3, #0]
    if (OSTmrUpdateCtr == (OS_CTR)0u) {
 8007c9e:	b939      	cbnz	r1, 8007cb0 <OSTimeTick+0x40>
        OSTmrUpdateCtr = OSTmrUpdateCnt;
 8007ca0:	4808      	ldr	r0, [pc, #32]	; (8007cc4 <OSTimeTick+0x54>)
        OSTaskSemPost((OS_TCB *)&OSTmrTaskTCB,              /* Signal timer task                                      */
 8007ca2:	f10d 0206 	add.w	r2, sp, #6
#endif

#if OS_CFG_TMR_EN > 0u
    OSTmrUpdateCtr--;
    if (OSTmrUpdateCtr == (OS_CTR)0u) {
        OSTmrUpdateCtr = OSTmrUpdateCnt;
 8007ca6:	6804      	ldr	r4, [r0, #0]
        OSTaskSemPost((OS_TCB *)&OSTmrTaskTCB,              /* Signal timer task                                      */
 8007ca8:	4807      	ldr	r0, [pc, #28]	; (8007cc8 <OSTimeTick+0x58>)
#endif

#if OS_CFG_TMR_EN > 0u
    OSTmrUpdateCtr--;
    if (OSTmrUpdateCtr == (OS_CTR)0u) {
        OSTmrUpdateCtr = OSTmrUpdateCnt;
 8007caa:	601c      	str	r4, [r3, #0]
        OSTaskSemPost((OS_TCB *)&OSTmrTaskTCB,              /* Signal timer task                                      */
 8007cac:	f7ff fc78 	bl	80075a0 <OSTaskSemPost>
                      (OS_ERR *)&err);
    }
#endif

#endif
}
 8007cb0:	b002      	add	sp, #8
 8007cb2:	bd10      	pop	{r4, pc}
 8007cb4:	2000ec8c 	.word	0x2000ec8c
 8007cb8:	2000ec88 	.word	0x2000ec88
 8007cbc:	2000e988 	.word	0x2000e988
 8007cc0:	2000f038 	.word	0x2000f038
 8007cc4:	2000f02c 	.word	0x2000f02c
 8007cc8:	2000ed88 	.word	0x2000ed88

08007ccc <OSTmrCreate>:
                   OS_TICK               period,
                   OS_OPT                opt,
                   OS_TMR_CALLBACK_PTR   p_callback,
                   void                 *p_callback_arg,
                   OS_ERR               *p_err)
{
 8007ccc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
        return;
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to call from an ISR                      */
 8007cd0:	4d2d      	ldr	r5, [pc, #180]	; (8007d88 <OSTmrCreate+0xbc>)
                   OS_TICK               period,
                   OS_OPT                opt,
                   OS_TMR_CALLBACK_PTR   p_callback,
                   void                 *p_callback_arg,
                   OS_ERR               *p_err)
{
 8007cd2:	f8bd 6018 	ldrh.w	r6, [sp, #24]
        return;
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to call from an ISR                      */
 8007cd6:	782d      	ldrb	r5, [r5, #0]
 8007cd8:	2d00      	cmp	r5, #0
 8007cda:	d134      	bne.n	8007d46 <OSTmrCreate+0x7a>
        return;
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_tmr == (OS_TMR *)0) {                             /* Validate 'p_tmr'                                       */
 8007cdc:	2800      	cmp	r0, #0
 8007cde:	d04c      	beq.n	8007d7a <OSTmrCreate+0xae>
       *p_err = OS_ERR_OBJ_PTR_NULL;
        return;
    }

    switch (opt) {
 8007ce0:	2e01      	cmp	r6, #1
 8007ce2:	d03c      	beq.n	8007d5e <OSTmrCreate+0x92>
 8007ce4:	2e02      	cmp	r6, #2
 8007ce6:	d134      	bne.n	8007d52 <OSTmrCreate+0x86>
        case OS_OPT_TMR_PERIODIC:
             if (period == (OS_TICK)0) {
 8007ce8:	2b00      	cmp	r3, #0
 8007cea:	d040      	beq.n	8007d6e <OSTmrCreate+0xa2>
 8007cec:	4604      	mov	r4, r0
 8007cee:	4615      	mov	r5, r2
 8007cf0:	461f      	mov	r7, r3
 8007cf2:	4688      	mov	r8, r1
            *p_err = OS_ERR_OPT_INVALID;
             return;
    }
#endif

    OS_CRITICAL_ENTER();
 8007cf4:	f7f9 fd3e 	bl	8001774 <CPU_SR_Save>

#if OS_CFG_DBG_EN > 0u
void  OS_TmrDbgListAdd (OS_TMR  *p_tmr)
{
    p_tmr->DbgPrevPtr               = (OS_TMR *)0;
    if (OSTmrDbgListPtr == (OS_TMR *)0) {
 8007cf8:	4924      	ldr	r1, [pc, #144]	; (8007d8c <OSTmrCreate+0xc0>)
    p_tmr->NamePtr        = (CPU_CHAR          *)p_name;
    p_tmr->Dly            = (OS_TICK            )dly;
    p_tmr->Match          = (OS_TICK            )0;
    p_tmr->Remain         = (OS_TICK            )0;
    p_tmr->Period         = (OS_TICK            )period;
    p_tmr->Opt            = (OS_OPT             )opt;
 8007cfa:	8526      	strh	r6, [r4, #40]	; 0x28
    p_tmr->CallbackPtr    = (OS_TMR_CALLBACK_PTR)p_callback;
 8007cfc:	9e07      	ldr	r6, [sp, #28]

#if OS_CFG_DBG_EN > 0u
void  OS_TmrDbgListAdd (OS_TMR  *p_tmr)
{
    p_tmr->DbgPrevPtr               = (OS_TMR *)0;
    if (OSTmrDbgListPtr == (OS_TMR *)0) {
 8007cfe:	680a      	ldr	r2, [r1, #0]
    }
#endif

    OS_CRITICAL_ENTER();
    p_tmr->State          = (OS_STATE           )OS_TMR_STATE_STOPPED;     /* Initialize the timer fields             */
    p_tmr->Type           = (OS_OBJ_TYPE        )OS_OBJ_TYPE_TMR;
 8007d00:	f8df e090 	ldr.w	lr, [pc, #144]	; 8007d94 <OSTmrCreate+0xc8>
    p_tmr->Dly            = (OS_TICK            )dly;
    p_tmr->Match          = (OS_TICK            )0;
    p_tmr->Remain         = (OS_TICK            )0;
    p_tmr->Period         = (OS_TICK            )period;
    p_tmr->Opt            = (OS_OPT             )opt;
    p_tmr->CallbackPtr    = (OS_TMR_CALLBACK_PTR)p_callback;
 8007d04:	60a6      	str	r6, [r4, #8]
    p_tmr->CallbackPtrArg = (void              *)p_callback_arg;
 8007d06:	9e08      	ldr	r6, [sp, #32]
    OS_CRITICAL_ENTER();
    p_tmr->State          = (OS_STATE           )OS_TMR_STATE_STOPPED;     /* Initialize the timer fields             */
    p_tmr->Type           = (OS_OBJ_TYPE        )OS_OBJ_TYPE_TMR;
    p_tmr->NamePtr        = (CPU_CHAR          *)p_name;
    p_tmr->Dly            = (OS_TICK            )dly;
    p_tmr->Match          = (OS_TICK            )0;
 8007d08:	2300      	movs	r3, #0

    OS_CRITICAL_ENTER();
    p_tmr->State          = (OS_STATE           )OS_TMR_STATE_STOPPED;     /* Initialize the timer fields             */
    p_tmr->Type           = (OS_OBJ_TYPE        )OS_OBJ_TYPE_TMR;
    p_tmr->NamePtr        = (CPU_CHAR          *)p_name;
    p_tmr->Dly            = (OS_TICK            )dly;
 8007d0a:	6225      	str	r5, [r4, #32]
             return;
    }
#endif

    OS_CRITICAL_ENTER();
    p_tmr->State          = (OS_STATE           )OS_TMR_STATE_STOPPED;     /* Initialize the timer fields             */
 8007d0c:	2501      	movs	r5, #1
    p_tmr->Type           = (OS_OBJ_TYPE        )OS_OBJ_TYPE_TMR;
    p_tmr->NamePtr        = (CPU_CHAR          *)p_name;
 8007d0e:	f8c4 8004 	str.w	r8, [r4, #4]
    p_tmr->Dly            = (OS_TICK            )dly;
    p_tmr->Match          = (OS_TICK            )0;
    p_tmr->Remain         = (OS_TICK            )0;
    p_tmr->Period         = (OS_TICK            )period;
 8007d12:	6267      	str	r7, [r4, #36]	; 0x24
    p_tmr->Opt            = (OS_OPT             )opt;
    p_tmr->CallbackPtr    = (OS_TMR_CALLBACK_PTR)p_callback;
    p_tmr->CallbackPtrArg = (void              *)p_callback_arg;
 8007d14:	60e6      	str	r6, [r4, #12]
    }
#endif

    OS_CRITICAL_ENTER();
    p_tmr->State          = (OS_STATE           )OS_TMR_STATE_STOPPED;     /* Initialize the timer fields             */
    p_tmr->Type           = (OS_OBJ_TYPE        )OS_OBJ_TYPE_TMR;
 8007d16:	f8c4 e000 	str.w	lr, [r4]
             return;
    }
#endif

    OS_CRITICAL_ENTER();
    p_tmr->State          = (OS_STATE           )OS_TMR_STATE_STOPPED;     /* Initialize the timer fields             */
 8007d1a:	f884 502a 	strb.w	r5, [r4, #42]	; 0x2a
    p_tmr->Type           = (OS_OBJ_TYPE        )OS_OBJ_TYPE_TMR;
    p_tmr->NamePtr        = (CPU_CHAR          *)p_name;
    p_tmr->Dly            = (OS_TICK            )dly;
    p_tmr->Match          = (OS_TICK            )0;
 8007d1e:	61a3      	str	r3, [r4, #24]
    p_tmr->Remain         = (OS_TICK            )0;
 8007d20:	61e3      	str	r3, [r4, #28]
    p_tmr->Period         = (OS_TICK            )period;
    p_tmr->Opt            = (OS_OPT             )opt;
    p_tmr->CallbackPtr    = (OS_TMR_CALLBACK_PTR)p_callback;
    p_tmr->CallbackPtrArg = (void              *)p_callback_arg;
    p_tmr->NextPtr        = (OS_TMR            *)0;
 8007d22:	6123      	str	r3, [r4, #16]
    p_tmr->PrevPtr        = (OS_TMR            *)0;
 8007d24:	6163      	str	r3, [r4, #20]


#if OS_CFG_DBG_EN > 0u
void  OS_TmrDbgListAdd (OS_TMR  *p_tmr)
{
    p_tmr->DbgPrevPtr               = (OS_TMR *)0;
 8007d26:	62e3      	str	r3, [r4, #44]	; 0x2c
    if (OSTmrDbgListPtr == (OS_TMR *)0) {
        p_tmr->DbgNextPtr           = (OS_TMR *)0;
 8007d28:	6322      	str	r2, [r4, #48]	; 0x30

#if OS_CFG_DBG_EN > 0u
void  OS_TmrDbgListAdd (OS_TMR  *p_tmr)
{
    p_tmr->DbgPrevPtr               = (OS_TMR *)0;
    if (OSTmrDbgListPtr == (OS_TMR *)0) {
 8007d2a:	b102      	cbz	r2, 8007d2e <OSTmrCreate+0x62>
        p_tmr->DbgNextPtr           = (OS_TMR *)0;
    } else {
        p_tmr->DbgNextPtr           =  OSTmrDbgListPtr;
        OSTmrDbgListPtr->DbgPrevPtr =  p_tmr;
 8007d2c:	62d4      	str	r4, [r2, #44]	; 0x2c
    p_tmr->PrevPtr        = (OS_TMR            *)0;

#if OS_CFG_DBG_EN > 0u
    OS_TmrDbgListAdd(p_tmr);
#endif
    OSTmrQty++;                                             /* Keep track of the number of timers created             */
 8007d2e:	4a18      	ldr	r2, [pc, #96]	; (8007d90 <OSTmrCreate+0xc4>)
        p_tmr->DbgNextPtr           = (OS_TMR *)0;
    } else {
        p_tmr->DbgNextPtr           =  OSTmrDbgListPtr;
        OSTmrDbgListPtr->DbgPrevPtr =  p_tmr;
    }
    OSTmrDbgListPtr                 =  p_tmr;
 8007d30:	600c      	str	r4, [r1, #0]
    p_tmr->PrevPtr        = (OS_TMR            *)0;

#if OS_CFG_DBG_EN > 0u
    OS_TmrDbgListAdd(p_tmr);
#endif
    OSTmrQty++;                                             /* Keep track of the number of timers created             */
 8007d32:	8813      	ldrh	r3, [r2, #0]
 8007d34:	3301      	adds	r3, #1
 8007d36:	8013      	strh	r3, [r2, #0]

    OS_CRITICAL_EXIT_NO_SCHED();
 8007d38:	f7f9 fd20 	bl	800177c <CPU_SR_Restore>
   *p_err = OS_ERR_NONE;
 8007d3c:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8007d3e:	2300      	movs	r3, #0
 8007d40:	8013      	strh	r3, [r2, #0]
 8007d42:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to call from an ISR                      */
       *p_err = OS_ERR_TMR_ISR;
 8007d46:	f247 3343 	movw	r3, #29507	; 0x7343
 8007d4a:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8007d4c:	8013      	strh	r3, [r2, #0]
        return;
 8007d4e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                 return;
             }
             break;

        default:
            *p_err = OS_ERR_OPT_INVALID;
 8007d52:	f645 6325 	movw	r3, #24101	; 0x5e25
 8007d56:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8007d58:	8013      	strh	r3, [r2, #0]
             return;
 8007d5a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                 return;
             }
             break;

        case OS_OPT_TMR_ONE_SHOT:
             if (dly == (OS_TICK)0) {
 8007d5e:	2a00      	cmp	r2, #0
 8007d60:	d1c4      	bne.n	8007cec <OSTmrCreate+0x20>
                *p_err = OS_ERR_TMR_INVALID_DLY;
 8007d62:	f247 333f 	movw	r3, #29503	; 0x733f
 8007d66:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8007d68:	8013      	strh	r3, [r2, #0]
                 return;
 8007d6a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }

    switch (opt) {
        case OS_OPT_TMR_PERIODIC:
             if (period == (OS_TICK)0) {
                *p_err = OS_ERR_TMR_INVALID_PERIOD;
 8007d6e:	f247 3340 	movw	r3, #29504	; 0x7340
 8007d72:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8007d74:	8013      	strh	r3, [r2, #0]
                 return;
 8007d76:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_tmr == (OS_TMR *)0) {                             /* Validate 'p_tmr'                                       */
       *p_err = OS_ERR_OBJ_PTR_NULL;
 8007d7a:	f645 53c3 	movw	r3, #24003	; 0x5dc3
 8007d7e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8007d80:	8013      	strh	r3, [r2, #0]
        return;
 8007d82:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8007d86:	bf00      	nop
 8007d88:	2000ed84 	.word	0x2000ed84
 8007d8c:	2000f024 	.word	0x2000f024
 8007d90:	2000ef3c 	.word	0x2000ef3c
 8007d94:	20524d54 	.word	0x20524d54

08007d98 <OSTmrRemainGet>:
        return ((OS_TICK)0);
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to call from an ISR                      */
 8007d98:	4b2e      	ldr	r3, [pc, #184]	; (8007e54 <OSTmrRemainGet+0xbc>)
 8007d9a:	781b      	ldrb	r3, [r3, #0]
 8007d9c:	b963      	cbnz	r3, 8007db8 <OSTmrRemainGet+0x20>
        return ((OS_TICK)0);
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_tmr == (OS_TMR *)0) {
 8007d9e:	b1f0      	cbz	r0, 8007dde <OSTmrRemainGet+0x46>
************************************************************************************************************************
*/

OS_TICK  OSTmrRemainGet (OS_TMR  *p_tmr,
                         OS_ERR  *p_err)
{
 8007da0:	b570      	push	{r4, r5, r6, lr}
        return ((OS_TICK)0);
    }
#endif

#if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                   /* Make sure timer was created                            */
 8007da2:	4a2d      	ldr	r2, [pc, #180]	; (8007e58 <OSTmrRemainGet+0xc0>)
 8007da4:	6804      	ldr	r4, [r0, #0]
************************************************************************************************************************
*/

OS_TICK  OSTmrRemainGet (OS_TMR  *p_tmr,
                         OS_ERR  *p_err)
{
 8007da6:	b082      	sub	sp, #8
        return ((OS_TICK)0);
    }
#endif

#if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                   /* Make sure timer was created                            */
 8007da8:	4294      	cmp	r4, r2
 8007daa:	d00a      	beq.n	8007dc2 <OSTmrRemainGet+0x2a>
       *p_err = OS_ERR_OBJ_TYPE;
 8007dac:	f645 52c4 	movw	r2, #24004	; 0x5dc4
        return ((OS_TICK)0);
 8007db0:	4618      	mov	r0, r3
    }
#endif

#if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                   /* Make sure timer was created                            */
       *p_err = OS_ERR_OBJ_TYPE;
 8007db2:	800a      	strh	r2, [r1, #0]
            *p_err = OS_ERR_TMR_INVALID_STATE;
             remain = (OS_TICK)0;
             break;
    }
    return (remain);
}
 8007db4:	b002      	add	sp, #8
 8007db6:	bd70      	pop	{r4, r5, r6, pc}
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to call from an ISR                      */
       *p_err = OS_ERR_TMR_ISR;
 8007db8:	f247 3343 	movw	r3, #29507	; 0x7343
        return ((OS_TICK)0);
 8007dbc:	2000      	movs	r0, #0
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to call from an ISR                      */
       *p_err = OS_ERR_TMR_ISR;
 8007dbe:	800b      	strh	r3, [r1, #0]
            *p_err = OS_ERR_TMR_INVALID_STATE;
             remain = (OS_TICK)0;
             break;
    }
    return (remain);
}
 8007dc0:	4770      	bx	lr
 8007dc2:	4605      	mov	r5, r0
       *p_err = OS_ERR_OBJ_TYPE;
        return ((OS_TICK)0);
    }
#endif

    OSSchedLock(&err);
 8007dc4:	f10d 0006 	add.w	r0, sp, #6
 8007dc8:	460e      	mov	r6, r1
 8007dca:	f7fb feb9 	bl	8003b40 <OSSchedLock>
    switch (p_tmr->State) {
 8007dce:	f895 302a 	ldrb.w	r3, [r5, #42]	; 0x2a
 8007dd2:	2b03      	cmp	r3, #3
 8007dd4:	d831      	bhi.n	8007e3a <OSTmrRemainGet+0xa2>
 8007dd6:	e8df f003 	tbb	[pc, r3]
 8007dda:	1a27      	.short	0x1a27
 8007ddc:	060d      	.short	0x060d
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_tmr == (OS_TMR *)0) {
       *p_err = OS_ERR_TMR_INVALID;
 8007dde:	f247 3342 	movw	r3, #29506	; 0x7342
 8007de2:	800b      	strh	r3, [r1, #0]
        return ((OS_TICK)0);
 8007de4:	4770      	bx	lr
             OSSchedUnlock(&err);
            *p_err         = OS_ERR_NONE;
             break;

        case OS_TMR_STATE_COMPLETED:                        /* Only ONE-SHOT that timed out can be in this state      */
             OSSchedUnlock(&err);
 8007de6:	f10d 0006 	add.w	r0, sp, #6
 8007dea:	f7fb fedf 	bl	8003bac <OSSchedUnlock>
            *p_err  = OS_ERR_NONE;
 8007dee:	2000      	movs	r0, #0
 8007df0:	8030      	strh	r0, [r6, #0]
             remain = (OS_TICK)0;
             break;
 8007df2:	e7df      	b.n	8007db4 <OSTmrRemainGet+0x1c>

    OSSchedLock(&err);
    switch (p_tmr->State) {
        case OS_TMR_STATE_RUNNING:
             remain        = p_tmr->Match                   /* Determine how much time is left to timeout             */
                           - OSTmrTickCtr;
 8007df4:	4b19      	ldr	r3, [pc, #100]	; (8007e5c <OSTmrRemainGet+0xc4>)
#endif

    OSSchedLock(&err);
    switch (p_tmr->State) {
        case OS_TMR_STATE_RUNNING:
             remain        = p_tmr->Match                   /* Determine how much time is left to timeout             */
 8007df6:	69aa      	ldr	r2, [r5, #24]
 8007df8:	681c      	ldr	r4, [r3, #0]
                           - OSTmrTickCtr;
             p_tmr->Remain = remain;
             OSSchedUnlock(&err);
 8007dfa:	f10d 0006 	add.w	r0, sp, #6
#endif

    OSSchedLock(&err);
    switch (p_tmr->State) {
        case OS_TMR_STATE_RUNNING:
             remain        = p_tmr->Match                   /* Determine how much time is left to timeout             */
 8007dfe:	1b14      	subs	r4, r2, r4
                           - OSTmrTickCtr;
             p_tmr->Remain = remain;
 8007e00:	61ec      	str	r4, [r5, #28]
             OSSchedUnlock(&err);
 8007e02:	f7fb fed3 	bl	8003bac <OSSchedUnlock>
            *p_err         = OS_ERR_NONE;
 8007e06:	2300      	movs	r3, #0
#endif

    OSSchedLock(&err);
    switch (p_tmr->State) {
        case OS_TMR_STATE_RUNNING:
             remain        = p_tmr->Match                   /* Determine how much time is left to timeout             */
 8007e08:	4620      	mov	r0, r4
                           - OSTmrTickCtr;
             p_tmr->Remain = remain;
             OSSchedUnlock(&err);
            *p_err         = OS_ERR_NONE;
 8007e0a:	8033      	strh	r3, [r6, #0]
             break;
 8007e0c:	e7d2      	b.n	8007db4 <OSTmrRemainGet+0x1c>

        case OS_TMR_STATE_STOPPED:                          /* It's assumed that the timer has not started yet        */
             if (p_tmr->Opt == OS_OPT_TMR_PERIODIC) {
 8007e0e:	8d2b      	ldrh	r3, [r5, #40]	; 0x28
                 if (p_tmr->Dly == 0u) {
 8007e10:	6a2c      	ldr	r4, [r5, #32]
             OSSchedUnlock(&err);
            *p_err         = OS_ERR_NONE;
             break;

        case OS_TMR_STATE_STOPPED:                          /* It's assumed that the timer has not started yet        */
             if (p_tmr->Opt == OS_OPT_TMR_PERIODIC) {
 8007e12:	2b02      	cmp	r3, #2
 8007e14:	d01a      	beq.n	8007e4c <OSTmrRemainGet+0xb4>
                 }
             } else {
                 remain = p_tmr->Dly;
             }
             p_tmr->Remain = remain;
             OSSchedUnlock(&err);
 8007e16:	f10d 0006 	add.w	r0, sp, #6
                     remain = p_tmr->Dly;
                 }
             } else {
                 remain = p_tmr->Dly;
             }
             p_tmr->Remain = remain;
 8007e1a:	61ec      	str	r4, [r5, #28]
             OSSchedUnlock(&err);
 8007e1c:	f7fb fec6 	bl	8003bac <OSSchedUnlock>
            *p_err         = OS_ERR_NONE;
 8007e20:	2300      	movs	r3, #0
             break;
 8007e22:	4620      	mov	r0, r4
             } else {
                 remain = p_tmr->Dly;
             }
             p_tmr->Remain = remain;
             OSSchedUnlock(&err);
            *p_err         = OS_ERR_NONE;
 8007e24:	8033      	strh	r3, [r6, #0]
             break;
 8007e26:	e7c5      	b.n	8007db4 <OSTmrRemainGet+0x1c>
            *p_err  = OS_ERR_NONE;
             remain = (OS_TICK)0;
             break;

        case OS_TMR_STATE_UNUSED:
             OSSchedUnlock(&err);
 8007e28:	f10d 0006 	add.w	r0, sp, #6
 8007e2c:	f7fb febe 	bl	8003bac <OSSchedUnlock>
            *p_err  = OS_ERR_TMR_INACTIVE;
 8007e30:	f247 333d 	movw	r3, #29501	; 0x733d
             remain = (OS_TICK)0;
 8007e34:	2000      	movs	r0, #0
             remain = (OS_TICK)0;
             break;

        case OS_TMR_STATE_UNUSED:
             OSSchedUnlock(&err);
            *p_err  = OS_ERR_TMR_INACTIVE;
 8007e36:	8033      	strh	r3, [r6, #0]
             remain = (OS_TICK)0;
             break;
 8007e38:	e7bc      	b.n	8007db4 <OSTmrRemainGet+0x1c>

        default:
             OSSchedUnlock(&err);
 8007e3a:	f10d 0006 	add.w	r0, sp, #6
 8007e3e:	f7fb feb5 	bl	8003bac <OSSchedUnlock>
            *p_err = OS_ERR_TMR_INVALID_STATE;
 8007e42:	f247 3341 	movw	r3, #29505	; 0x7341
             remain = (OS_TICK)0;
 8007e46:	2000      	movs	r0, #0
             remain = (OS_TICK)0;
             break;

        default:
             OSSchedUnlock(&err);
            *p_err = OS_ERR_TMR_INVALID_STATE;
 8007e48:	8033      	strh	r3, [r6, #0]
             remain = (OS_TICK)0;
             break;
 8007e4a:	e7b3      	b.n	8007db4 <OSTmrRemainGet+0x1c>
            *p_err         = OS_ERR_NONE;
             break;

        case OS_TMR_STATE_STOPPED:                          /* It's assumed that the timer has not started yet        */
             if (p_tmr->Opt == OS_OPT_TMR_PERIODIC) {
                 if (p_tmr->Dly == 0u) {
 8007e4c:	2c00      	cmp	r4, #0
 8007e4e:	d1e2      	bne.n	8007e16 <OSTmrRemainGet+0x7e>
                     remain = p_tmr->Period;
 8007e50:	6a6c      	ldr	r4, [r5, #36]	; 0x24
 8007e52:	e7e0      	b.n	8007e16 <OSTmrRemainGet+0x7e>
 8007e54:	2000ed84 	.word	0x2000ed84
 8007e58:	20524d54 	.word	0x20524d54
 8007e5c:	2000ed50 	.word	0x2000ed50

08007e60 <OSTmrStateGet>:
************************************************************************************************************************
*/

OS_STATE  OSTmrStateGet (OS_TMR  *p_tmr,
                         OS_ERR  *p_err)
{
 8007e60:	b570      	push	{r4, r5, r6, lr}
        return (OS_TMR_STATE_UNUSED);
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to call from an ISR                      */
 8007e62:	4b14      	ldr	r3, [pc, #80]	; (8007eb4 <OSTmrStateGet+0x54>)
 8007e64:	781c      	ldrb	r4, [r3, #0]
 8007e66:	b94c      	cbnz	r4, 8007e7c <OSTmrStateGet+0x1c>
        return (OS_TMR_STATE_UNUSED);
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_tmr == (OS_TMR *)0) {
 8007e68:	b300      	cbz	r0, 8007eac <OSTmrStateGet+0x4c>
        return (OS_TMR_STATE_UNUSED);
    }
#endif

#if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                   /* Make sure timer was created                            */
 8007e6a:	4b13      	ldr	r3, [pc, #76]	; (8007eb8 <OSTmrStateGet+0x58>)
 8007e6c:	6802      	ldr	r2, [r0, #0]
 8007e6e:	429a      	cmp	r2, r3
 8007e70:	d00a      	beq.n	8007e88 <OSTmrStateGet+0x28>
       *p_err = OS_ERR_OBJ_TYPE;
 8007e72:	f645 53c4 	movw	r3, #24004	; 0x5dc4
 8007e76:	800b      	strh	r3, [r1, #0]
            *p_err = OS_ERR_TMR_INVALID_STATE;
             break;
    }
    CPU_CRITICAL_EXIT();
    return (state);
}
 8007e78:	4620      	mov	r0, r4
 8007e7a:	bd70      	pop	{r4, r5, r6, pc}
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to call from an ISR                      */
       *p_err = OS_ERR_TMR_ISR;
 8007e7c:	f247 3343 	movw	r3, #29507	; 0x7343
        return (OS_TMR_STATE_UNUSED);
 8007e80:	2400      	movs	r4, #0
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to call from an ISR                      */
       *p_err = OS_ERR_TMR_ISR;
 8007e82:	800b      	strh	r3, [r1, #0]
            *p_err = OS_ERR_TMR_INVALID_STATE;
             break;
    }
    CPU_CRITICAL_EXIT();
    return (state);
}
 8007e84:	4620      	mov	r0, r4
 8007e86:	bd70      	pop	{r4, r5, r6, pc}
 8007e88:	4605      	mov	r5, r0
 8007e8a:	460e      	mov	r6, r1
       *p_err = OS_ERR_OBJ_TYPE;
        return (OS_TMR_STATE_UNUSED);
    }
#endif

    CPU_CRITICAL_ENTER();
 8007e8c:	f7f9 fc72 	bl	8001774 <CPU_SR_Save>
    state = p_tmr->State;
 8007e90:	f895 502a 	ldrb.w	r5, [r5, #42]	; 0x2a
    switch (state) {
 8007e94:	2d03      	cmp	r5, #3
        case OS_TMR_STATE_RUNNING:
            *p_err = OS_ERR_NONE;
             break;

        default:
            *p_err = OS_ERR_TMR_INVALID_STATE;
 8007e96:	bf8c      	ite	hi
 8007e98:	f247 3341 	movwhi	r3, #29505	; 0x7341
    switch (state) {
        case OS_TMR_STATE_UNUSED:
        case OS_TMR_STATE_STOPPED:
        case OS_TMR_STATE_COMPLETED:
        case OS_TMR_STATE_RUNNING:
            *p_err = OS_ERR_NONE;
 8007e9c:	8034      	strhls	r4, [r6, #0]
        return (OS_TMR_STATE_UNUSED);
    }
#endif

    CPU_CRITICAL_ENTER();
    state = p_tmr->State;
 8007e9e:	462c      	mov	r4, r5
        case OS_TMR_STATE_RUNNING:
            *p_err = OS_ERR_NONE;
             break;

        default:
            *p_err = OS_ERR_TMR_INVALID_STATE;
 8007ea0:	bf88      	it	hi
 8007ea2:	8033      	strhhi	r3, [r6, #0]
             break;
    }
    CPU_CRITICAL_EXIT();
 8007ea4:	f7f9 fc6a 	bl	800177c <CPU_SR_Restore>
    return (state);
}
 8007ea8:	4620      	mov	r0, r4
 8007eaa:	bd70      	pop	{r4, r5, r6, pc}
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_tmr == (OS_TMR *)0) {
       *p_err = OS_ERR_TMR_INVALID;
 8007eac:	f247 3342 	movw	r3, #29506	; 0x7342
 8007eb0:	800b      	strh	r3, [r1, #0]
        return (OS_TMR_STATE_UNUSED);
 8007eb2:	e7e1      	b.n	8007e78 <OSTmrStateGet+0x18>
 8007eb4:	2000ed84 	.word	0x2000ed84
 8007eb8:	20524d54 	.word	0x20524d54

08007ebc <OS_TmrClr>:
*/

void  OS_TmrClr (OS_TMR  *p_tmr)
{
    p_tmr->State          = OS_TMR_STATE_UNUSED;            /* Clear timer fields                                     */
    p_tmr->Type           = OS_OBJ_TYPE_NONE;
 8007ebc:	4908      	ldr	r1, [pc, #32]	; (8007ee0 <OS_TmrClr+0x24>)
    p_tmr->NamePtr        = (CPU_CHAR          *)((void *)"?TMR");
 8007ebe:	4a09      	ldr	r2, [pc, #36]	; (8007ee4 <OS_TmrClr+0x28>)
************************************************************************************************************************
*/

void  OS_TmrClr (OS_TMR  *p_tmr)
{
    p_tmr->State          = OS_TMR_STATE_UNUSED;            /* Clear timer fields                                     */
 8007ec0:	2300      	movs	r3, #0
    p_tmr->Type           = OS_OBJ_TYPE_NONE;
    p_tmr->NamePtr        = (CPU_CHAR          *)((void *)"?TMR");
 8007ec2:	e880 0006 	stmia.w	r0, {r1, r2}
************************************************************************************************************************
*/

void  OS_TmrClr (OS_TMR  *p_tmr)
{
    p_tmr->State          = OS_TMR_STATE_UNUSED;            /* Clear timer fields                                     */
 8007ec6:	f880 302a 	strb.w	r3, [r0, #42]	; 0x2a
    p_tmr->Type           = OS_OBJ_TYPE_NONE;
    p_tmr->NamePtr        = (CPU_CHAR          *)((void *)"?TMR");
    p_tmr->Dly            = (OS_TICK            )0;
 8007eca:	6203      	str	r3, [r0, #32]
    p_tmr->Match          = (OS_TICK            )0;
 8007ecc:	6183      	str	r3, [r0, #24]
    p_tmr->Remain         = (OS_TICK            )0;
 8007ece:	61c3      	str	r3, [r0, #28]
    p_tmr->Period         = (OS_TICK            )0;
 8007ed0:	6243      	str	r3, [r0, #36]	; 0x24
    p_tmr->Opt            = (OS_OPT             )0;
 8007ed2:	8503      	strh	r3, [r0, #40]	; 0x28
    p_tmr->CallbackPtr    = (OS_TMR_CALLBACK_PTR)0;
 8007ed4:	6083      	str	r3, [r0, #8]
    p_tmr->CallbackPtrArg = (void              *)0;
 8007ed6:	60c3      	str	r3, [r0, #12]
    p_tmr->NextPtr        = (OS_TMR            *)0;
 8007ed8:	6103      	str	r3, [r0, #16]
    p_tmr->PrevPtr        = (OS_TMR            *)0;
 8007eda:	6143      	str	r3, [r0, #20]
 8007edc:	4770      	bx	lr
 8007ede:	bf00      	nop
 8007ee0:	454e4f4e 	.word	0x454e4f4e
 8007ee4:	080166a8 	.word	0x080166a8

08007ee8 <OS_TmrDbgListAdd>:

#if OS_CFG_DBG_EN > 0u
void  OS_TmrDbgListAdd (OS_TMR  *p_tmr)
{
    p_tmr->DbgPrevPtr               = (OS_TMR *)0;
    if (OSTmrDbgListPtr == (OS_TMR *)0) {
 8007ee8:	4a04      	ldr	r2, [pc, #16]	; (8007efc <OS_TmrDbgListAdd+0x14>)


#if OS_CFG_DBG_EN > 0u
void  OS_TmrDbgListAdd (OS_TMR  *p_tmr)
{
    p_tmr->DbgPrevPtr               = (OS_TMR *)0;
 8007eea:	2100      	movs	r1, #0
    if (OSTmrDbgListPtr == (OS_TMR *)0) {
 8007eec:	6813      	ldr	r3, [r2, #0]


#if OS_CFG_DBG_EN > 0u
void  OS_TmrDbgListAdd (OS_TMR  *p_tmr)
{
    p_tmr->DbgPrevPtr               = (OS_TMR *)0;
 8007eee:	62c1      	str	r1, [r0, #44]	; 0x2c
    if (OSTmrDbgListPtr == (OS_TMR *)0) {
        p_tmr->DbgNextPtr           = (OS_TMR *)0;
 8007ef0:	6303      	str	r3, [r0, #48]	; 0x30

#if OS_CFG_DBG_EN > 0u
void  OS_TmrDbgListAdd (OS_TMR  *p_tmr)
{
    p_tmr->DbgPrevPtr               = (OS_TMR *)0;
    if (OSTmrDbgListPtr == (OS_TMR *)0) {
 8007ef2:	b103      	cbz	r3, 8007ef6 <OS_TmrDbgListAdd+0xe>
        p_tmr->DbgNextPtr           = (OS_TMR *)0;
    } else {
        p_tmr->DbgNextPtr           =  OSTmrDbgListPtr;
        OSTmrDbgListPtr->DbgPrevPtr =  p_tmr;
 8007ef4:	62d8      	str	r0, [r3, #44]	; 0x2c
    }
    OSTmrDbgListPtr                 =  p_tmr;
 8007ef6:	6010      	str	r0, [r2, #0]
 8007ef8:	4770      	bx	lr
 8007efa:	bf00      	nop
 8007efc:	2000f024 	.word	0x2000f024

08007f00 <OS_TmrDbgListRemove>:
{
    OS_TMR  *p_tmr_next;
    OS_TMR  *p_tmr_prev;


    p_tmr_prev = p_tmr->DbgPrevPtr;
 8007f00:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
    p_tmr_next = p_tmr->DbgNextPtr;
 8007f02:	6b03      	ldr	r3, [r0, #48]	; 0x30

    if (p_tmr_prev == (OS_TMR *)0) {
 8007f04:	b132      	cbz	r2, 8007f14 <OS_TmrDbgListRemove+0x14>
        if (p_tmr_next != (OS_TMR *)0) {
            p_tmr_next->DbgPrevPtr = (OS_TMR *)0;
        }
        p_tmr->DbgNextPtr = (OS_TMR *)0;

    } else if (p_tmr_next == (OS_TMR *)0) {
 8007f06:	b163      	cbz	r3, 8007f22 <OS_TmrDbgListRemove+0x22>
        p_tmr->DbgPrevPtr      = (OS_TMR *)0;

    } else {
        p_tmr_prev->DbgNextPtr =  p_tmr_next;
        p_tmr_next->DbgPrevPtr =  p_tmr_prev;
        p_tmr->DbgNextPtr      = (OS_TMR *)0;
 8007f08:	2100      	movs	r1, #0
    } else if (p_tmr_next == (OS_TMR *)0) {
        p_tmr_prev->DbgNextPtr = (OS_TMR *)0;
        p_tmr->DbgPrevPtr      = (OS_TMR *)0;

    } else {
        p_tmr_prev->DbgNextPtr =  p_tmr_next;
 8007f0a:	6313      	str	r3, [r2, #48]	; 0x30
        p_tmr_next->DbgPrevPtr =  p_tmr_prev;
 8007f0c:	62da      	str	r2, [r3, #44]	; 0x2c
        p_tmr->DbgNextPtr      = (OS_TMR *)0;
 8007f0e:	6301      	str	r1, [r0, #48]	; 0x30
        p_tmr->DbgPrevPtr      = (OS_TMR *)0;
 8007f10:	62c1      	str	r1, [r0, #44]	; 0x2c
 8007f12:	4770      	bx	lr

    p_tmr_prev = p_tmr->DbgPrevPtr;
    p_tmr_next = p_tmr->DbgNextPtr;

    if (p_tmr_prev == (OS_TMR *)0) {
        OSTmrDbgListPtr = p_tmr_next;
 8007f14:	4904      	ldr	r1, [pc, #16]	; (8007f28 <OS_TmrDbgListRemove+0x28>)
 8007f16:	600b      	str	r3, [r1, #0]
        if (p_tmr_next != (OS_TMR *)0) {
 8007f18:	b103      	cbz	r3, 8007f1c <OS_TmrDbgListRemove+0x1c>
            p_tmr_next->DbgPrevPtr = (OS_TMR *)0;
 8007f1a:	62da      	str	r2, [r3, #44]	; 0x2c
        }
        p_tmr->DbgNextPtr = (OS_TMR *)0;
 8007f1c:	2300      	movs	r3, #0
 8007f1e:	6303      	str	r3, [r0, #48]	; 0x30
 8007f20:	4770      	bx	lr

    } else if (p_tmr_next == (OS_TMR *)0) {
        p_tmr_prev->DbgNextPtr = (OS_TMR *)0;
 8007f22:	6313      	str	r3, [r2, #48]	; 0x30
        p_tmr->DbgPrevPtr      = (OS_TMR *)0;
 8007f24:	62c3      	str	r3, [r0, #44]	; 0x2c
 8007f26:	4770      	bx	lr
 8007f28:	2000f024 	.word	0x2000f024

08007f2c <OS_TmrInit>:
* Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
************************************************************************************************************************
*/

void  OS_TmrInit (OS_ERR  *p_err)
{
 8007f2c:	b570      	push	{r4, r5, r6, lr}

#if OS_CFG_DBG_EN > 0u
    OSTmrDbgListPtr = (OS_TMR *)0;
#endif

    if (OSCfg_TmrTaskRate_Hz > (OS_RATE_HZ)0) {
 8007f2e:	4a2f      	ldr	r2, [pc, #188]	; (8007fec <OS_TmrInit+0xc0>)
        return;
    }
#endif

#if OS_CFG_DBG_EN > 0u
    OSTmrDbgListPtr = (OS_TMR *)0;
 8007f30:	4b2f      	ldr	r3, [pc, #188]	; (8007ff0 <OS_TmrInit+0xc4>)
#endif

    if (OSCfg_TmrTaskRate_Hz > (OS_RATE_HZ)0) {
 8007f32:	6812      	ldr	r2, [r2, #0]
        return;
    }
#endif

#if OS_CFG_DBG_EN > 0u
    OSTmrDbgListPtr = (OS_TMR *)0;
 8007f34:	2100      	movs	r1, #0
 8007f36:	6019      	str	r1, [r3, #0]
* Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
************************************************************************************************************************
*/

void  OS_TmrInit (OS_ERR  *p_err)
{
 8007f38:	b08a      	sub	sp, #40	; 0x28
#if OS_CFG_DBG_EN > 0u
    OSTmrDbgListPtr = (OS_TMR *)0;
#endif

    if (OSCfg_TmrTaskRate_Hz > (OS_RATE_HZ)0) {
        OSTmrUpdateCnt = OSCfg_TickRate_Hz / OSCfg_TmrTaskRate_Hz;
 8007f3a:	4b2e      	ldr	r3, [pc, #184]	; (8007ff4 <OS_TmrInit+0xc8>)

#if OS_CFG_DBG_EN > 0u
    OSTmrDbgListPtr = (OS_TMR *)0;
#endif

    if (OSCfg_TmrTaskRate_Hz > (OS_RATE_HZ)0) {
 8007f3c:	2a00      	cmp	r2, #0
 8007f3e:	d02e      	beq.n	8007f9e <OS_TmrInit+0x72>
        OSTmrUpdateCnt = OSCfg_TickRate_Hz / OSCfg_TmrTaskRate_Hz;
 8007f40:	681b      	ldr	r3, [r3, #0]
 8007f42:	492d      	ldr	r1, [pc, #180]	; (8007ff8 <OS_TmrInit+0xcc>)
 8007f44:	fbb3 f2f2 	udiv	r2, r3, r2
 8007f48:	600a      	str	r2, [r1, #0]

    OSTmrTickCtr     = (OS_TICK)0;

    OSTmrTaskTimeMax = (CPU_TS)0;

    for (i = 0u; i < OSCfg_TmrWheelSize; i++) {
 8007f4a:	4b2c      	ldr	r3, [pc, #176]	; (8007ffc <OS_TmrInit+0xd0>)
    if (OSCfg_TmrTaskRate_Hz > (OS_RATE_HZ)0) {
        OSTmrUpdateCnt = OSCfg_TickRate_Hz / OSCfg_TmrTaskRate_Hz;
    } else {
        OSTmrUpdateCnt = OSCfg_TickRate_Hz / (OS_RATE_HZ)10;
    }
    OSTmrUpdateCtr   = OSTmrUpdateCnt;
 8007f4c:	4e2c      	ldr	r6, [pc, #176]	; (8008000 <OS_TmrInit+0xd4>)

    OSTmrTickCtr     = (OS_TICK)0;

    OSTmrTaskTimeMax = (CPU_TS)0;

    for (i = 0u; i < OSCfg_TmrWheelSize; i++) {
 8007f4e:	881d      	ldrh	r5, [r3, #0]
    } else {
        OSTmrUpdateCnt = OSCfg_TickRate_Hz / (OS_RATE_HZ)10;
    }
    OSTmrUpdateCtr   = OSTmrUpdateCnt;

    OSTmrTickCtr     = (OS_TICK)0;
 8007f50:	4c2c      	ldr	r4, [pc, #176]	; (8008004 <OS_TmrInit+0xd8>)

    OSTmrTaskTimeMax = (CPU_TS)0;
 8007f52:	492d      	ldr	r1, [pc, #180]	; (8008008 <OS_TmrInit+0xdc>)
    } else {
        OSTmrUpdateCnt = OSCfg_TickRate_Hz / (OS_RATE_HZ)10;
    }
    OSTmrUpdateCtr   = OSTmrUpdateCnt;

    OSTmrTickCtr     = (OS_TICK)0;
 8007f54:	2300      	movs	r3, #0
    if (OSCfg_TmrTaskRate_Hz > (OS_RATE_HZ)0) {
        OSTmrUpdateCnt = OSCfg_TickRate_Hz / OSCfg_TmrTaskRate_Hz;
    } else {
        OSTmrUpdateCnt = OSCfg_TickRate_Hz / (OS_RATE_HZ)10;
    }
    OSTmrUpdateCtr   = OSTmrUpdateCnt;
 8007f56:	6032      	str	r2, [r6, #0]

    OSTmrTickCtr     = (OS_TICK)0;
 8007f58:	6023      	str	r3, [r4, #0]

    OSTmrTaskTimeMax = (CPU_TS)0;
 8007f5a:	600b      	str	r3, [r1, #0]

    for (i = 0u; i < OSCfg_TmrWheelSize; i++) {
 8007f5c:	b165      	cbz	r5, 8007f78 <OS_TmrInit+0x4c>
 8007f5e:	4e2b      	ldr	r6, [pc, #172]	; (800800c <OS_TmrInit+0xe0>)
        p_spoke                = &OSCfg_TmrWheel[i];
        p_spoke->NbrEntries    = (OS_OBJ_QTY)0;
 8007f60:	4619      	mov	r1, r3
 8007f62:	4632      	mov	r2, r6
 8007f64:	8091      	strh	r1, [r2, #4]
        p_spoke->NbrEntriesMax = (OS_OBJ_QTY)0;
 8007f66:	80d1      	strh	r1, [r2, #6]
        p_spoke->FirstPtr      = (OS_TMR   *)0;
 8007f68:	f846 1033 	str.w	r1, [r6, r3, lsl #3]
 8007f6c:	3301      	adds	r3, #1

    OSTmrTickCtr     = (OS_TICK)0;

    OSTmrTaskTimeMax = (CPU_TS)0;

    for (i = 0u; i < OSCfg_TmrWheelSize; i++) {
 8007f6e:	b29c      	uxth	r4, r3
 8007f70:	42a5      	cmp	r5, r4
 8007f72:	f102 0208 	add.w	r2, r2, #8
 8007f76:	d8f5      	bhi.n	8007f64 <OS_TmrInit+0x38>
        p_spoke->NbrEntriesMax = (OS_OBJ_QTY)0;
        p_spoke->FirstPtr      = (OS_TMR   *)0;
    }

                                                            /* ---------------- CREATE THE TIMER TASK --------------- */
    if (OSCfg_TmrTaskStkBasePtr == (CPU_STK*)0) {
 8007f78:	4b25      	ldr	r3, [pc, #148]	; (8008010 <OS_TmrInit+0xe4>)
 8007f7a:	681a      	ldr	r2, [r3, #0]
 8007f7c:	2a00      	cmp	r2, #0
 8007f7e:	d02f      	beq.n	8007fe0 <OS_TmrInit+0xb4>
       *p_err = OS_ERR_TMR_STK_INVALID;
        return;
    }

    if (OSCfg_TmrTaskStkSize < OSCfg_StkSizeMin) {
 8007f80:	4924      	ldr	r1, [pc, #144]	; (8008014 <OS_TmrInit+0xe8>)
 8007f82:	4b25      	ldr	r3, [pc, #148]	; (8008018 <OS_TmrInit+0xec>)
 8007f84:	6809      	ldr	r1, [r1, #0]
 8007f86:	681b      	ldr	r3, [r3, #0]
 8007f88:	4299      	cmp	r1, r3
 8007f8a:	d324      	bcc.n	8007fd6 <OS_TmrInit+0xaa>
       *p_err = OS_ERR_TMR_STK_SIZE_INVALID;
        return;
    }

    if (OSCfg_TmrTaskPrio >= (OS_CFG_PRIO_MAX - 1u)) {
 8007f8c:	4b23      	ldr	r3, [pc, #140]	; (800801c <OS_TmrInit+0xf0>)
 8007f8e:	781c      	ldrb	r4, [r3, #0]
 8007f90:	2c3d      	cmp	r4, #61	; 0x3d
 8007f92:	d90c      	bls.n	8007fae <OS_TmrInit+0x82>
       *p_err = OS_ERR_TMR_PRIO_INVALID;
 8007f94:	f247 3346 	movw	r3, #29510	; 0x7346
 8007f98:	8003      	strh	r3, [r0, #0]
                 (OS_MSG_QTY  )0,
                 (OS_TICK     )0,
                 (void       *)0,
                 (OS_OPT      )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR | OS_OPT_TASK_NO_TLS),
                 (OS_ERR     *)p_err);
}
 8007f9a:	b00a      	add	sp, #40	; 0x28
 8007f9c:	bd70      	pop	{r4, r5, r6, pc}
#endif

    if (OSCfg_TmrTaskRate_Hz > (OS_RATE_HZ)0) {
        OSTmrUpdateCnt = OSCfg_TickRate_Hz / OSCfg_TmrTaskRate_Hz;
    } else {
        OSTmrUpdateCnt = OSCfg_TickRate_Hz / (OS_RATE_HZ)10;
 8007f9e:	4a20      	ldr	r2, [pc, #128]	; (8008020 <OS_TmrInit+0xf4>)
 8007fa0:	681b      	ldr	r3, [r3, #0]
 8007fa2:	4915      	ldr	r1, [pc, #84]	; (8007ff8 <OS_TmrInit+0xcc>)
 8007fa4:	fba2 3203 	umull	r3, r2, r2, r3
 8007fa8:	08d2      	lsrs	r2, r2, #3
 8007faa:	600a      	str	r2, [r1, #0]
 8007fac:	e7cd      	b.n	8007f4a <OS_TmrInit+0x1e>
    if (OSCfg_TmrTaskPrio >= (OS_CFG_PRIO_MAX - 1u)) {
       *p_err = OS_ERR_TMR_PRIO_INVALID;
        return;
    }

    OSTaskCreate((OS_TCB     *)&OSTmrTaskTCB,
 8007fae:	4b1d      	ldr	r3, [pc, #116]	; (8008024 <OS_TmrInit+0xf8>)
 8007fb0:	250b      	movs	r5, #11
 8007fb2:	681e      	ldr	r6, [r3, #0]
 8007fb4:	2300      	movs	r3, #0
 8007fb6:	9008      	str	r0, [sp, #32]
 8007fb8:	9103      	str	r1, [sp, #12]
 8007fba:	9201      	str	r2, [sp, #4]
 8007fbc:	9400      	str	r4, [sp, #0]
 8007fbe:	9602      	str	r6, [sp, #8]
 8007fc0:	9507      	str	r5, [sp, #28]
 8007fc2:	9306      	str	r3, [sp, #24]
 8007fc4:	9305      	str	r3, [sp, #20]
 8007fc6:	9304      	str	r3, [sp, #16]
 8007fc8:	4a17      	ldr	r2, [pc, #92]	; (8008028 <OS_TmrInit+0xfc>)
 8007fca:	4918      	ldr	r1, [pc, #96]	; (800802c <OS_TmrInit+0x100>)
 8007fcc:	4818      	ldr	r0, [pc, #96]	; (8008030 <OS_TmrInit+0x104>)
 8007fce:	f7ff f81d 	bl	800700c <OSTaskCreate>
                 (OS_MSG_QTY  )0,
                 (OS_TICK     )0,
                 (void       *)0,
                 (OS_OPT      )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR | OS_OPT_TASK_NO_TLS),
                 (OS_ERR     *)p_err);
}
 8007fd2:	b00a      	add	sp, #40	; 0x28
 8007fd4:	bd70      	pop	{r4, r5, r6, pc}
       *p_err = OS_ERR_TMR_STK_INVALID;
        return;
    }

    if (OSCfg_TmrTaskStkSize < OSCfg_StkSizeMin) {
       *p_err = OS_ERR_TMR_STK_SIZE_INVALID;
 8007fd6:	f247 3348 	movw	r3, #29512	; 0x7348
 8007fda:	8003      	strh	r3, [r0, #0]
                 (OS_MSG_QTY  )0,
                 (OS_TICK     )0,
                 (void       *)0,
                 (OS_OPT      )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR | OS_OPT_TASK_NO_TLS),
                 (OS_ERR     *)p_err);
}
 8007fdc:	b00a      	add	sp, #40	; 0x28
 8007fde:	bd70      	pop	{r4, r5, r6, pc}
        p_spoke->FirstPtr      = (OS_TMR   *)0;
    }

                                                            /* ---------------- CREATE THE TIMER TASK --------------- */
    if (OSCfg_TmrTaskStkBasePtr == (CPU_STK*)0) {
       *p_err = OS_ERR_TMR_STK_INVALID;
 8007fe0:	f247 3347 	movw	r3, #29511	; 0x7347
 8007fe4:	8003      	strh	r3, [r0, #0]
                 (OS_MSG_QTY  )0,
                 (OS_TICK     )0,
                 (void       *)0,
                 (OS_OPT      )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR | OS_OPT_TASK_NO_TLS),
                 (OS_ERR     *)p_err);
}
 8007fe6:	b00a      	add	sp, #40	; 0x28
 8007fe8:	bd70      	pop	{r4, r5, r6, pc}
 8007fea:	bf00      	nop
 8007fec:	080160a8 	.word	0x080160a8
 8007ff0:	2000f024 	.word	0x2000f024
 8007ff4:	080160cc 	.word	0x080160cc
 8007ff8:	2000f02c 	.word	0x2000f02c
 8007ffc:	08016094 	.word	0x08016094
 8008000:	2000f038 	.word	0x2000f038
 8008004:	2000ed50 	.word	0x2000ed50
 8008008:	2000ed70 	.word	0x2000ed70
 800800c:	2000e0e8 	.word	0x2000e0e8
 8008010:	080160a4 	.word	0x080160a4
 8008014:	0801609c 	.word	0x0801609c
 8008018:	080160d0 	.word	0x080160d0
 800801c:	080160ac 	.word	0x080160ac
 8008020:	cccccccd 	.word	0xcccccccd
 8008024:	080160a0 	.word	0x080160a0
 8008028:	080082e5 	.word	0x080082e5
 800802c:	080166b0 	.word	0x080166b0
 8008030:	2000ed88 	.word	0x2000ed88

08008034 <OS_TmrLink>:
    OS_TMR           *p_tmr1;
    OS_TMR_SPOKE_IX   spoke;



    p_tmr->State = OS_TMR_STATE_RUNNING;
 8008034:	2302      	movs	r3, #2
    if (opt == OS_OPT_LINK_PERIODIC) {                      /* Determine when timer will expire                      */
 8008036:	2901      	cmp	r1, #1
************************************************************************************************************************
*/

void  OS_TmrLink (OS_TMR  *p_tmr,
                  OS_OPT   opt)
{
 8008038:	b4f0      	push	{r4, r5, r6, r7}
    OS_TMR           *p_tmr1;
    OS_TMR_SPOKE_IX   spoke;



    p_tmr->State = OS_TMR_STATE_RUNNING;
 800803a:	f880 302a 	strb.w	r3, [r0, #42]	; 0x2a
    if (opt == OS_OPT_LINK_PERIODIC) {                      /* Determine when timer will expire                      */
        p_tmr->Match = p_tmr->Period + OSTmrTickCtr;
 800803e:	4925      	ldr	r1, [pc, #148]	; (80080d4 <OS_TmrLink+0xa0>)
    OS_TMR_SPOKE_IX   spoke;



    p_tmr->State = OS_TMR_STATE_RUNNING;
    if (opt == OS_OPT_LINK_PERIODIC) {                      /* Determine when timer will expire                      */
 8008040:	d002      	beq.n	8008048 <OS_TmrLink+0x14>
        p_tmr->Match = p_tmr->Period + OSTmrTickCtr;
    } else {
        if (p_tmr->Dly == (OS_TICK)0) {
 8008042:	6a02      	ldr	r2, [r0, #32]
 8008044:	2a00      	cmp	r2, #0
 8008046:	d137      	bne.n	80080b8 <OS_TmrLink+0x84>



    p_tmr->State = OS_TMR_STATE_RUNNING;
    if (opt == OS_OPT_LINK_PERIODIC) {                      /* Determine when timer will expire                      */
        p_tmr->Match = p_tmr->Period + OSTmrTickCtr;
 8008048:	6a42      	ldr	r2, [r0, #36]	; 0x24
 800804a:	680b      	ldr	r3, [r1, #0]
 800804c:	4413      	add	r3, r2
 800804e:	6183      	str	r3, [r0, #24]
            p_tmr->Match = p_tmr->Period + OSTmrTickCtr;
        } else {
            p_tmr->Match = p_tmr->Dly    + OSTmrTickCtr;
        }
    }
    spoke  = (OS_TMR_SPOKE_IX)(p_tmr->Match % OSCfg_TmrWheelSize);
 8008050:	4a21      	ldr	r2, [pc, #132]	; (80080d8 <OS_TmrLink+0xa4>)
    p_spoke = &OSCfg_TmrWheel[spoke];

    if (p_spoke->FirstPtr ==  (OS_TMR *)0) {                /* Link into timer wheel                                  */
 8008052:	4d22      	ldr	r5, [pc, #136]	; (80080dc <OS_TmrLink+0xa8>)
        } else {
            p_tmr->Match = p_tmr->Dly    + OSTmrTickCtr;
        }
    }
    spoke  = (OS_TMR_SPOKE_IX)(p_tmr->Match % OSCfg_TmrWheelSize);
    p_spoke = &OSCfg_TmrWheel[spoke];
 8008054:	8814      	ldrh	r4, [r2, #0]
 8008056:	fbb3 f2f4 	udiv	r2, r3, r4
 800805a:	fb04 3412 	mls	r4, r4, r2, r3
 800805e:	b2a4      	uxth	r4, r4

    if (p_spoke->FirstPtr ==  (OS_TMR *)0) {                /* Link into timer wheel                                  */
 8008060:	f855 2034 	ldr.w	r2, [r5, r4, lsl #3]
 8008064:	2a00      	cmp	r2, #0
 8008066:	d02b      	beq.n	80080c0 <OS_TmrLink+0x8c>
        p_tmr->PrevPtr      = (OS_TMR *)0;
        p_spoke->FirstPtr   = p_tmr;
        p_spoke->NbrEntries = 1u;
    } else {
        p_tmr->Remain  = p_tmr->Match                       /* Compute remaining time for timer                       */
                       - OSTmrTickCtr;
 8008068:	680e      	ldr	r6, [r1, #0]
        p_tmr->NextPtr      = (OS_TMR *)0;
        p_tmr->PrevPtr      = (OS_TMR *)0;
        p_spoke->FirstPtr   = p_tmr;
        p_spoke->NbrEntries = 1u;
    } else {
        p_tmr->Remain  = p_tmr->Match                       /* Compute remaining time for timer                       */
 800806a:	1b9b      	subs	r3, r3, r6
 800806c:	61c3      	str	r3, [r0, #28]
                       - OSTmrTickCtr;
        p_tmr1         = p_spoke->FirstPtr;                 /* Point to current first timer in the list               */
        while (p_tmr1 != (OS_TMR *)0) {
            p_tmr1->Remain = p_tmr1->Match                  /* Compute time remaining of current timer in list        */
                           - OSTmrTickCtr;
 800806e:	6993      	ldr	r3, [r2, #24]
 8008070:	1b9b      	subs	r3, r3, r6
    } else {
        p_tmr->Remain  = p_tmr->Match                       /* Compute remaining time for timer                       */
                       - OSTmrTickCtr;
        p_tmr1         = p_spoke->FirstPtr;                 /* Point to current first timer in the list               */
        while (p_tmr1 != (OS_TMR *)0) {
            p_tmr1->Remain = p_tmr1->Match                  /* Compute time remaining of current timer in list        */
 8008072:	61d3      	str	r3, [r2, #28]
                           - OSTmrTickCtr;
            if (p_tmr->Remain > p_tmr1->Remain) {           /* Do we need to insert AFTER current timer in list?      */
 8008074:	69c1      	ldr	r1, [r0, #28]
 8008076:	428b      	cmp	r3, r1
 8008078:	d203      	bcs.n	8008082 <OS_TmrLink+0x4e>
                if (p_tmr1->NextPtr  != (OS_TMR *)0) {      /* Yes, are we pointing at the last timer in the list?    */
 800807a:	6913      	ldr	r3, [r2, #16]
 800807c:	b1c3      	cbz	r3, 80080b0 <OS_TmrLink+0x7c>
 800807e:	461a      	mov	r2, r3
 8008080:	e7f5      	b.n	800806e <OS_TmrLink+0x3a>
                    p_tmr->PrevPtr    =  p_tmr1;
                    p_tmr1->NextPtr   =  p_tmr;             /* Yes, timer to insert is now new last entry in the list */
                    p_tmr1            = (OS_TMR *)0;        /* Break loop                                             */
                }
            } else {                                        /* Insert before the current timer                        */
                if (p_tmr1->PrevPtr == (OS_TMR *)0) {       /* Are we inserting before the first timer?               */
 8008082:	6953      	ldr	r3, [r2, #20]
                    p_tmr->PrevPtr    = (OS_TMR *)0;
                    p_tmr->NextPtr    = p_tmr1;
 8008084:	6102      	str	r2, [r0, #16]
                    p_tmr1->NextPtr   =  p_tmr;             /* Yes, timer to insert is now new last entry in the list */
                    p_tmr1            = (OS_TMR *)0;        /* Break loop                                             */
                }
            } else {                                        /* Insert before the current timer                        */
                if (p_tmr1->PrevPtr == (OS_TMR *)0) {       /* Are we inserting before the first timer?               */
                    p_tmr->PrevPtr    = (OS_TMR *)0;
 8008086:	6143      	str	r3, [r0, #20]
                    p_tmr->PrevPtr    =  p_tmr1;
                    p_tmr1->NextPtr   =  p_tmr;             /* Yes, timer to insert is now new last entry in the list */
                    p_tmr1            = (OS_TMR *)0;        /* Break loop                                             */
                }
            } else {                                        /* Insert before the current timer                        */
                if (p_tmr1->PrevPtr == (OS_TMR *)0) {       /* Are we inserting before the first timer?               */
 8008088:	b173      	cbz	r3, 80080a8 <OS_TmrLink+0x74>
                    p_spoke->FirstPtr = p_tmr;
                } else {                                    /* Insert in between 2 timers already in the list         */
                    p_tmr0            = p_tmr1->PrevPtr;
                    p_tmr->PrevPtr    = p_tmr0;
                    p_tmr->NextPtr    = p_tmr1;
                    p_tmr0->NextPtr   = p_tmr;
 800808a:	6118      	str	r0, [r3, #16]
                    p_tmr1->PrevPtr   = p_tmr;
 800808c:	6150      	str	r0, [r2, #20]
                }
                p_tmr1 = (OS_TMR *)0;                       /* Break loop                                             */
            }
        }
        p_spoke->NbrEntries++;
 800808e:	00e1      	lsls	r1, r4, #3
 8008090:	186a      	adds	r2, r5, r1
 8008092:	8893      	ldrh	r3, [r2, #4]
 8008094:	3301      	adds	r3, #1
 8008096:	b29b      	uxth	r3, r3
 8008098:	8093      	strh	r3, [r2, #4]
    }
    if (p_spoke->NbrEntriesMax < p_spoke->NbrEntries) {     /* Keep track of maximum number of entries in each spoke  */
 800809a:	4429      	add	r1, r5
 800809c:	88ca      	ldrh	r2, [r1, #6]
 800809e:	429a      	cmp	r2, r3
 80080a0:	d200      	bcs.n	80080a4 <OS_TmrLink+0x70>
        p_spoke->NbrEntriesMax = p_spoke->NbrEntries;
 80080a2:	80cb      	strh	r3, [r1, #6]
    }
}
 80080a4:	bcf0      	pop	{r4, r5, r6, r7}
 80080a6:	4770      	bx	lr
                }
            } else {                                        /* Insert before the current timer                        */
                if (p_tmr1->PrevPtr == (OS_TMR *)0) {       /* Are we inserting before the first timer?               */
                    p_tmr->PrevPtr    = (OS_TMR *)0;
                    p_tmr->NextPtr    = p_tmr1;
                    p_tmr1->PrevPtr   = p_tmr;
 80080a8:	6150      	str	r0, [r2, #20]
                    p_spoke->FirstPtr = p_tmr;
 80080aa:	f845 0034 	str.w	r0, [r5, r4, lsl #3]
 80080ae:	e7ee      	b.n	800808e <OS_TmrLink+0x5a>
                           - OSTmrTickCtr;
            if (p_tmr->Remain > p_tmr1->Remain) {           /* Do we need to insert AFTER current timer in list?      */
                if (p_tmr1->NextPtr  != (OS_TMR *)0) {      /* Yes, are we pointing at the last timer in the list?    */
                    p_tmr1            = p_tmr1->NextPtr;    /* No,  Point to next timer in the list                   */
                } else {
                    p_tmr->NextPtr    = (OS_TMR *)0;
 80080b0:	6103      	str	r3, [r0, #16]
                    p_tmr->PrevPtr    =  p_tmr1;
 80080b2:	6142      	str	r2, [r0, #20]
                    p_tmr1->NextPtr   =  p_tmr;             /* Yes, timer to insert is now new last entry in the list */
 80080b4:	6110      	str	r0, [r2, #16]
 80080b6:	e7ea      	b.n	800808e <OS_TmrLink+0x5a>
        p_tmr->Match = p_tmr->Period + OSTmrTickCtr;
    } else {
        if (p_tmr->Dly == (OS_TICK)0) {
            p_tmr->Match = p_tmr->Period + OSTmrTickCtr;
        } else {
            p_tmr->Match = p_tmr->Dly    + OSTmrTickCtr;
 80080b8:	680b      	ldr	r3, [r1, #0]
 80080ba:	4413      	add	r3, r2
 80080bc:	6183      	str	r3, [r0, #24]
 80080be:	e7c7      	b.n	8008050 <OS_TmrLink+0x1c>

    if (p_spoke->FirstPtr ==  (OS_TMR *)0) {                /* Link into timer wheel                                  */
        p_tmr->NextPtr      = (OS_TMR *)0;
        p_tmr->PrevPtr      = (OS_TMR *)0;
        p_spoke->FirstPtr   = p_tmr;
        p_spoke->NbrEntries = 1u;
 80080c0:	00e1      	lsls	r1, r4, #3
 80080c2:	2601      	movs	r6, #1
 80080c4:	186f      	adds	r7, r5, r1
    }
    spoke  = (OS_TMR_SPOKE_IX)(p_tmr->Match % OSCfg_TmrWheelSize);
    p_spoke = &OSCfg_TmrWheel[spoke];

    if (p_spoke->FirstPtr ==  (OS_TMR *)0) {                /* Link into timer wheel                                  */
        p_tmr->NextPtr      = (OS_TMR *)0;
 80080c6:	6102      	str	r2, [r0, #16]
        p_tmr->PrevPtr      = (OS_TMR *)0;
 80080c8:	6142      	str	r2, [r0, #20]
 80080ca:	4633      	mov	r3, r6
        p_spoke->FirstPtr   = p_tmr;
 80080cc:	f845 0034 	str.w	r0, [r5, r4, lsl #3]
        p_spoke->NbrEntries = 1u;
 80080d0:	80be      	strh	r6, [r7, #4]
 80080d2:	e7e2      	b.n	800809a <OS_TmrLink+0x66>
 80080d4:	2000ed50 	.word	0x2000ed50
 80080d8:	08016094 	.word	0x08016094
 80080dc:	2000e0e8 	.word	0x2000e0e8

080080e0 <OS_TmrResetPeak>:
    OS_TMR_SPOKE     *p_spoke;
    OS_TMR_SPOKE_IX   i;



    for (i = 0u; i < OSCfg_TmrWheelSize; i++) {
 80080e0:	4b07      	ldr	r3, [pc, #28]	; (8008100 <OS_TmrResetPeak+0x20>)
 80080e2:	881b      	ldrh	r3, [r3, #0]
 80080e4:	b153      	cbz	r3, 80080fc <OS_TmrResetPeak+0x1c>
 80080e6:	1e5a      	subs	r2, r3, #1
 80080e8:	b292      	uxth	r2, r2
 80080ea:	4b06      	ldr	r3, [pc, #24]	; (8008104 <OS_TmrResetPeak+0x24>)
 80080ec:	3201      	adds	r2, #1
 80080ee:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
        p_spoke                = (OS_TMR_SPOKE *)&OSCfg_TmrWheel[i];
        p_spoke->NbrEntriesMax = (OS_OBJ_QTY    )0u;
 80080f2:	2100      	movs	r1, #0
 80080f4:	80d9      	strh	r1, [r3, #6]
 80080f6:	3308      	adds	r3, #8
    OS_TMR_SPOKE     *p_spoke;
    OS_TMR_SPOKE_IX   i;



    for (i = 0u; i < OSCfg_TmrWheelSize; i++) {
 80080f8:	4293      	cmp	r3, r2
 80080fa:	d1fb      	bne.n	80080f4 <OS_TmrResetPeak+0x14>
 80080fc:	4770      	bx	lr
 80080fe:	bf00      	nop
 8008100:	08016094 	.word	0x08016094
 8008104:	2000e0e8 	.word	0x2000e0e8

08008108 <OS_TmrUnlink>:
    OS_TMR          *p_tmr2;
    OS_TMR_SPOKE_IX  spoke;



    spoke   = (OS_TMR_SPOKE_IX)(p_tmr->Match % OSCfg_TmrWheelSize);
 8008108:	4b13      	ldr	r3, [pc, #76]	; (8008158 <OS_TmrUnlink+0x50>)
* Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
************************************************************************************************************************
*/

void  OS_TmrUnlink (OS_TMR  *p_tmr)
{
 800810a:	b410      	push	{r4}
    OS_TMR_SPOKE_IX  spoke;



    spoke   = (OS_TMR_SPOKE_IX)(p_tmr->Match % OSCfg_TmrWheelSize);
    p_spoke = &OSCfg_TmrWheel[spoke];
 800810c:	881b      	ldrh	r3, [r3, #0]
 800810e:	6984      	ldr	r4, [r0, #24]

    if (p_spoke->FirstPtr == p_tmr) {                       /* See if timer to remove is at the beginning of list     */
 8008110:	4912      	ldr	r1, [pc, #72]	; (800815c <OS_TmrUnlink+0x54>)
    OS_TMR_SPOKE_IX  spoke;



    spoke   = (OS_TMR_SPOKE_IX)(p_tmr->Match % OSCfg_TmrWheelSize);
    p_spoke = &OSCfg_TmrWheel[spoke];
 8008112:	fbb4 f2f3 	udiv	r2, r4, r3
 8008116:	fb03 4312 	mls	r3, r3, r2, r4
 800811a:	b29b      	uxth	r3, r3

    if (p_spoke->FirstPtr == p_tmr) {                       /* See if timer to remove is at the beginning of list     */
 800811c:	f851 2033 	ldr.w	r2, [r1, r3, lsl #3]
 8008120:	4290      	cmp	r0, r2
 8008122:	d011      	beq.n	8008148 <OS_TmrUnlink+0x40>
        p_spoke->FirstPtr = (OS_TMR *)p_tmr1;
        if (p_tmr1 != (OS_TMR *)0) {
            p_tmr1->PrevPtr = (OS_TMR *)0;
        }
    } else {
        p_tmr1          = (OS_TMR *)p_tmr->PrevPtr;         /* Remove timer from somewhere in the list                */
 8008124:	6944      	ldr	r4, [r0, #20]
        p_tmr2          = (OS_TMR *)p_tmr->NextPtr;
 8008126:	6902      	ldr	r2, [r0, #16]
        p_tmr1->NextPtr = p_tmr2;
 8008128:	6122      	str	r2, [r4, #16]
        if (p_tmr2 != (OS_TMR *)0) {
 800812a:	b102      	cbz	r2, 800812e <OS_TmrUnlink+0x26>
            p_tmr2->PrevPtr = (OS_TMR *)p_tmr1;
 800812c:	6154      	str	r4, [r2, #20]
        }
    }
    p_tmr->State   = OS_TMR_STATE_STOPPED;
    p_tmr->NextPtr = (OS_TMR *)0;
 800812e:	2200      	movs	r2, #0
        p_tmr1->NextPtr = p_tmr2;
        if (p_tmr2 != (OS_TMR *)0) {
            p_tmr2->PrevPtr = (OS_TMR *)p_tmr1;
        }
    }
    p_tmr->State   = OS_TMR_STATE_STOPPED;
 8008130:	2401      	movs	r4, #1
 8008132:	f880 402a 	strb.w	r4, [r0, #42]	; 0x2a
    p_tmr->NextPtr = (OS_TMR *)0;
    p_tmr->PrevPtr = (OS_TMR *)0;
    p_spoke->NbrEntries--;
 8008136:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
        if (p_tmr2 != (OS_TMR *)0) {
            p_tmr2->PrevPtr = (OS_TMR *)p_tmr1;
        }
    }
    p_tmr->State   = OS_TMR_STATE_STOPPED;
    p_tmr->NextPtr = (OS_TMR *)0;
 800813a:	6102      	str	r2, [r0, #16]
    p_tmr->PrevPtr = (OS_TMR *)0;
 800813c:	6142      	str	r2, [r0, #20]
    p_spoke->NbrEntries--;
 800813e:	889a      	ldrh	r2, [r3, #4]
}
 8008140:	bc10      	pop	{r4}
        }
    }
    p_tmr->State   = OS_TMR_STATE_STOPPED;
    p_tmr->NextPtr = (OS_TMR *)0;
    p_tmr->PrevPtr = (OS_TMR *)0;
    p_spoke->NbrEntries--;
 8008142:	3a01      	subs	r2, #1
 8008144:	809a      	strh	r2, [r3, #4]
}
 8008146:	4770      	bx	lr

    spoke   = (OS_TMR_SPOKE_IX)(p_tmr->Match % OSCfg_TmrWheelSize);
    p_spoke = &OSCfg_TmrWheel[spoke];

    if (p_spoke->FirstPtr == p_tmr) {                       /* See if timer to remove is at the beginning of list     */
        p_tmr1            = (OS_TMR *)p_tmr->NextPtr;
 8008148:	6902      	ldr	r2, [r0, #16]
        p_spoke->FirstPtr = (OS_TMR *)p_tmr1;
 800814a:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
        if (p_tmr1 != (OS_TMR *)0) {
 800814e:	2a00      	cmp	r2, #0
 8008150:	d0ed      	beq.n	800812e <OS_TmrUnlink+0x26>
            p_tmr1->PrevPtr = (OS_TMR *)0;
 8008152:	2400      	movs	r4, #0
 8008154:	6154      	str	r4, [r2, #20]
 8008156:	e7ea      	b.n	800812e <OS_TmrUnlink+0x26>
 8008158:	08016094 	.word	0x08016094
 800815c:	2000e0e8 	.word	0x2000e0e8

08008160 <OSTmrStart>:
************************************************************************************************************************
*/

CPU_BOOLEAN  OSTmrStart (OS_TMR  *p_tmr,
                         OS_ERR  *p_err)
{
 8008160:	b5f0      	push	{r4, r5, r6, r7, lr}
        return (DEF_FALSE);
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to call from an ISR                      */
 8008162:	4b24      	ldr	r3, [pc, #144]	; (80081f4 <OSTmrStart+0x94>)
************************************************************************************************************************
*/

CPU_BOOLEAN  OSTmrStart (OS_TMR  *p_tmr,
                         OS_ERR  *p_err)
{
 8008164:	b083      	sub	sp, #12
        return (DEF_FALSE);
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to call from an ISR                      */
 8008166:	781c      	ldrb	r4, [r3, #0]
 8008168:	b954      	cbnz	r4, 8008180 <OSTmrStart+0x20>
        return (DEF_FALSE);
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_tmr == (OS_TMR *)0) {
 800816a:	b368      	cbz	r0, 80081c8 <OSTmrStart+0x68>
        return (DEF_FALSE);
    }
#endif

#if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                   /* Make sure timer was created                            */
 800816c:	4b22      	ldr	r3, [pc, #136]	; (80081f8 <OSTmrStart+0x98>)
 800816e:	6802      	ldr	r2, [r0, #0]
 8008170:	429a      	cmp	r2, r3
 8008172:	d00c      	beq.n	800818e <OSTmrStart+0x2e>
       *p_err = OS_ERR_OBJ_TYPE;
 8008174:	f645 53c4 	movw	r3, #24004	; 0x5dc4
 8008178:	800b      	strh	r3, [r1, #0]
            *p_err = OS_ERR_TMR_INVALID_STATE;
             success = DEF_FALSE;
             break;
    }
    return (success);
}
 800817a:	4620      	mov	r0, r4
 800817c:	b003      	add	sp, #12
 800817e:	bdf0      	pop	{r4, r5, r6, r7, pc}
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to call from an ISR                      */
       *p_err = OS_ERR_TMR_ISR;
        return (DEF_FALSE);
 8008180:	2400      	movs	r4, #0
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to call from an ISR                      */
       *p_err = OS_ERR_TMR_ISR;
 8008182:	f247 3343 	movw	r3, #29507	; 0x7343
            *p_err = OS_ERR_TMR_INVALID_STATE;
             success = DEF_FALSE;
             break;
    }
    return (success);
}
 8008186:	4620      	mov	r0, r4
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to call from an ISR                      */
       *p_err = OS_ERR_TMR_ISR;
 8008188:	800b      	strh	r3, [r1, #0]
            *p_err = OS_ERR_TMR_INVALID_STATE;
             success = DEF_FALSE;
             break;
    }
    return (success);
}
 800818a:	b003      	add	sp, #12
 800818c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800818e:	4605      	mov	r5, r0
       *p_err = OS_ERR_OBJ_TYPE;
        return (DEF_FALSE);
    }
#endif

    OSSchedLock(&err);
 8008190:	f10d 0006 	add.w	r0, sp, #6
 8008194:	460e      	mov	r6, r1
 8008196:	f7fb fcd3 	bl	8003b40 <OSSchedLock>
    switch (p_tmr->State) {
 800819a:	f895 702a 	ldrb.w	r7, [r5, #42]	; 0x2a
 800819e:	2f03      	cmp	r7, #3
 80081a0:	d81f      	bhi.n	80081e2 <OSTmrStart+0x82>
 80081a2:	e8df f007 	tbb	[pc, r7]
 80081a6:	0515      	.short	0x0515
 80081a8:	0502      	.short	0x0502
        case OS_TMR_STATE_RUNNING:                          /* Restart the timer                                      */
             OS_TmrUnlink(p_tmr);                           /* ... Stop the timer                                     */
 80081aa:	4628      	mov	r0, r5
 80081ac:	f7ff ffac 	bl	8008108 <OS_TmrUnlink>
             success = DEF_TRUE;
             break;

        case OS_TMR_STATE_STOPPED:                          /* Start the timer                                        */
        case OS_TMR_STATE_COMPLETED:
             OS_TmrLink(p_tmr, OS_OPT_LINK_DLY);            /* ... Link timer to timer wheel (see Note #1).           */
 80081b0:	4628      	mov	r0, r5
 80081b2:	2100      	movs	r1, #0
 80081b4:	f7ff ff3e 	bl	8008034 <OS_TmrLink>
             OSSchedUnlock(&err);
 80081b8:	f10d 0006 	add.w	r0, sp, #6
 80081bc:	f7fb fcf6 	bl	8003bac <OSSchedUnlock>
            *p_err   = OS_ERR_NONE;
 80081c0:	2300      	movs	r3, #0
 80081c2:	8033      	strh	r3, [r6, #0]
             success = DEF_TRUE;
 80081c4:	2401      	movs	r4, #1
             break;
 80081c6:	e7d8      	b.n	800817a <OSTmrStart+0x1a>
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_tmr == (OS_TMR *)0) {
       *p_err = OS_ERR_TMR_INVALID;
 80081c8:	f247 3342 	movw	r3, #29506	; 0x7342
 80081cc:	800b      	strh	r3, [r1, #0]
        return (DEF_FALSE);
 80081ce:	e7d4      	b.n	800817a <OSTmrStart+0x1a>
            *p_err   = OS_ERR_NONE;
             success = DEF_TRUE;
             break;

        case OS_TMR_STATE_UNUSED:                           /* Timer not created                                      */
             OSSchedUnlock(&err);
 80081d0:	f10d 0006 	add.w	r0, sp, #6
 80081d4:	f7fb fcea 	bl	8003bac <OSSchedUnlock>
            *p_err   = OS_ERR_TMR_INACTIVE;
 80081d8:	f247 333d 	movw	r3, #29501	; 0x733d
             success = DEF_FALSE;
 80081dc:	463c      	mov	r4, r7
             success = DEF_TRUE;
             break;

        case OS_TMR_STATE_UNUSED:                           /* Timer not created                                      */
             OSSchedUnlock(&err);
            *p_err   = OS_ERR_TMR_INACTIVE;
 80081de:	8033      	strh	r3, [r6, #0]
             success = DEF_FALSE;
             break;
 80081e0:	e7cb      	b.n	800817a <OSTmrStart+0x1a>

        default:
             OSSchedUnlock(&err);
 80081e2:	f10d 0006 	add.w	r0, sp, #6
 80081e6:	f7fb fce1 	bl	8003bac <OSSchedUnlock>
            *p_err = OS_ERR_TMR_INVALID_STATE;
 80081ea:	f247 3341 	movw	r3, #29505	; 0x7341
 80081ee:	8033      	strh	r3, [r6, #0]
             success = DEF_FALSE;
             break;
 80081f0:	e7c3      	b.n	800817a <OSTmrStart+0x1a>
 80081f2:	bf00      	nop
 80081f4:	2000ed84 	.word	0x2000ed84
 80081f8:	20524d54 	.word	0x20524d54

080081fc <OSTmrStop>:

CPU_BOOLEAN  OSTmrStop (OS_TMR  *p_tmr,
                        OS_OPT   opt,
                        void    *p_callback_arg,
                        OS_ERR  *p_err)
{
 80081fc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
        return (DEF_FALSE);
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {                        /* See if trying to call from an ISR            */
 8008200:	4c36      	ldr	r4, [pc, #216]	; (80082dc <OSTmrStop+0xe0>)

CPU_BOOLEAN  OSTmrStop (OS_TMR  *p_tmr,
                        OS_OPT   opt,
                        void    *p_callback_arg,
                        OS_ERR  *p_err)
{
 8008202:	b083      	sub	sp, #12
        return (DEF_FALSE);
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {                        /* See if trying to call from an ISR            */
 8008204:	7824      	ldrb	r4, [r4, #0]
 8008206:	b95c      	cbnz	r4, 8008220 <OSTmrStop+0x24>
        return (DEF_FALSE);
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_tmr == (OS_TMR *)0) {
 8008208:	b318      	cbz	r0, 8008252 <OSTmrStop+0x56>
        return (DEF_FALSE);
    }
#endif

#if OS_CFG_OBJ_TYPE_CHK_EN > 0u
    if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                             /* Make sure timer was created                  */
 800820a:	4d35      	ldr	r5, [pc, #212]	; (80082e0 <OSTmrStop+0xe4>)
 800820c:	6806      	ldr	r6, [r0, #0]
 800820e:	42ae      	cmp	r6, r5
 8008210:	d00e      	beq.n	8008230 <OSTmrStop+0x34>
       *p_err = OS_ERR_OBJ_TYPE;
 8008212:	f645 52c4 	movw	r2, #24004	; 0x5dc4
 8008216:	801a      	strh	r2, [r3, #0]
            *p_err   = OS_ERR_TMR_INVALID_STATE;
             success = DEF_FALSE;
             break;
    }
    return (success);
}
 8008218:	4620      	mov	r0, r4
 800821a:	b003      	add	sp, #12
 800821c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {                        /* See if trying to call from an ISR            */
       *p_err = OS_ERR_TMR_ISR;
        return (DEF_FALSE);
 8008220:	2400      	movs	r4, #0
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {                        /* See if trying to call from an ISR            */
       *p_err = OS_ERR_TMR_ISR;
 8008222:	f247 3243 	movw	r2, #29507	; 0x7343
            *p_err   = OS_ERR_TMR_INVALID_STATE;
             success = DEF_FALSE;
             break;
    }
    return (success);
}
 8008226:	4620      	mov	r0, r4
    }
#endif

#if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
    if (OSIntNestingCtr > (OS_NESTING_CTR)0) {                        /* See if trying to call from an ISR            */
       *p_err = OS_ERR_TMR_ISR;
 8008228:	801a      	strh	r2, [r3, #0]
            *p_err   = OS_ERR_TMR_INVALID_STATE;
             success = DEF_FALSE;
             break;
    }
    return (success);
}
 800822a:	b003      	add	sp, #12
 800822c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8008230:	4605      	mov	r5, r0
       *p_err = OS_ERR_OBJ_TYPE;
        return (DEF_FALSE);
    }
#endif

    OSSchedLock(&err);
 8008232:	f10d 0006 	add.w	r0, sp, #6
 8008236:	461e      	mov	r6, r3
 8008238:	4690      	mov	r8, r2
 800823a:	460f      	mov	r7, r1
 800823c:	f7fb fc80 	bl	8003b40 <OSSchedLock>
    switch (p_tmr->State) {
 8008240:	f895 902a 	ldrb.w	r9, [r5, #42]	; 0x2a
 8008244:	f1b9 0f03 	cmp.w	r9, #3
 8008248:	d82b      	bhi.n	80082a2 <OSTmrStop+0xa6>
 800824a:	e8df f009 	tbb	[pc, r9]
 800824e:	1821      	.short	0x1821
 8008250:	1806      	.short	0x1806
    }
#endif

#if OS_CFG_ARG_CHK_EN > 0u
    if (p_tmr == (OS_TMR *)0) {
       *p_err = OS_ERR_TMR_INVALID;
 8008252:	f247 3242 	movw	r2, #29506	; 0x7342
 8008256:	801a      	strh	r2, [r3, #0]
        return (DEF_FALSE);
 8008258:	e7de      	b.n	8008218 <OSTmrStop+0x1c>
#endif

    OSSchedLock(&err);
    switch (p_tmr->State) {
        case OS_TMR_STATE_RUNNING:
             OS_TmrUnlink(p_tmr);                                     /* Remove from current wheel spoke              */
 800825a:	4628      	mov	r0, r5
 800825c:	f7ff ff54 	bl	8008108 <OS_TmrUnlink>
            *p_err = OS_ERR_NONE;
 8008260:	2300      	movs	r3, #0
             switch (opt) {
 8008262:	2f03      	cmp	r7, #3

    OSSchedLock(&err);
    switch (p_tmr->State) {
        case OS_TMR_STATE_RUNNING:
             OS_TmrUnlink(p_tmr);                                     /* Remove from current wheel spoke              */
            *p_err = OS_ERR_NONE;
 8008264:	8033      	strh	r3, [r6, #0]
             switch (opt) {
 8008266:	d024      	beq.n	80082b2 <OSTmrStop+0xb6>
 8008268:	2f04      	cmp	r7, #4
 800826a:	d02d      	beq.n	80082c8 <OSTmrStop+0xcc>
 800826c:	b337      	cbz	r7, 80082bc <OSTmrStop+0xc0>

                 case OS_OPT_TMR_NONE:
                      break;

                 default:
                     OSSchedUnlock(&err);
 800826e:	f10d 0006 	add.w	r0, sp, #6
 8008272:	f7fb fc9b 	bl	8003bac <OSSchedUnlock>
                    *p_err = OS_ERR_OPT_INVALID;
 8008276:	f645 6325 	movw	r3, #24101	; 0x5e25
 800827a:	8033      	strh	r3, [r6, #0]
                     return (DEF_FALSE);
 800827c:	e7cc      	b.n	8008218 <OSTmrStop+0x1c>
             success = DEF_TRUE;
             break;

        case OS_TMR_STATE_COMPLETED:                                  /* Timer has already completed the ONE-SHOT or  */
        case OS_TMR_STATE_STOPPED:                                    /* ... timer has not started yet.               */
             OSSchedUnlock(&err);
 800827e:	f10d 0006 	add.w	r0, sp, #6
 8008282:	f7fb fc93 	bl	8003bac <OSSchedUnlock>
            *p_err   = OS_ERR_TMR_STOPPED;
 8008286:	f247 3349 	movw	r3, #29513	; 0x7349
             success = DEF_TRUE;
 800828a:	2401      	movs	r4, #1
             break;

        case OS_TMR_STATE_COMPLETED:                                  /* Timer has already completed the ONE-SHOT or  */
        case OS_TMR_STATE_STOPPED:                                    /* ... timer has not started yet.               */
             OSSchedUnlock(&err);
            *p_err   = OS_ERR_TMR_STOPPED;
 800828c:	8033      	strh	r3, [r6, #0]
             success = DEF_TRUE;
             break;
 800828e:	e7c3      	b.n	8008218 <OSTmrStop+0x1c>

        case OS_TMR_STATE_UNUSED:                                     /* Timer was not created                        */
             OSSchedUnlock(&err);
 8008290:	f10d 0006 	add.w	r0, sp, #6
 8008294:	f7fb fc8a 	bl	8003bac <OSSchedUnlock>
            *p_err   = OS_ERR_TMR_INACTIVE;
 8008298:	f247 333d 	movw	r3, #29501	; 0x733d
             success = DEF_FALSE;
 800829c:	464c      	mov	r4, r9
             success = DEF_TRUE;
             break;

        case OS_TMR_STATE_UNUSED:                                     /* Timer was not created                        */
             OSSchedUnlock(&err);
            *p_err   = OS_ERR_TMR_INACTIVE;
 800829e:	8033      	strh	r3, [r6, #0]
             success = DEF_FALSE;
             break;
 80082a0:	e7ba      	b.n	8008218 <OSTmrStop+0x1c>

        default:
             OSSchedUnlock(&err);
 80082a2:	f10d 0006 	add.w	r0, sp, #6
 80082a6:	f7fb fc81 	bl	8003bac <OSSchedUnlock>
            *p_err   = OS_ERR_TMR_INVALID_STATE;
 80082aa:	f247 3341 	movw	r3, #29505	; 0x7341
 80082ae:	8033      	strh	r3, [r6, #0]
             success = DEF_FALSE;
             break;
 80082b0:	e7b2      	b.n	8008218 <OSTmrStop+0x1c>
        case OS_TMR_STATE_RUNNING:
             OS_TmrUnlink(p_tmr);                                     /* Remove from current wheel spoke              */
            *p_err = OS_ERR_NONE;
             switch (opt) {
                 case OS_OPT_TMR_CALLBACK:
                      p_fnct = p_tmr->CallbackPtr;                         /* Execute callback function ...           */
 80082b2:	68ab      	ldr	r3, [r5, #8]
                      if (p_fnct != (OS_TMR_CALLBACK_PTR)0) {              /* ... if available                        */
 80082b4:	b173      	cbz	r3, 80082d4 <OSTmrStop+0xd8>
                        (*p_fnct)((void *)p_tmr, p_tmr->CallbackPtrArg);   /* Use callback arg when timer was created */
 80082b6:	68e9      	ldr	r1, [r5, #12]
 80082b8:	4628      	mov	r0, r5
 80082ba:	4798      	blx	r3
                 default:
                     OSSchedUnlock(&err);
                    *p_err = OS_ERR_OPT_INVALID;
                     return (DEF_FALSE);
             }
             OSSchedUnlock(&err);
 80082bc:	f10d 0006 	add.w	r0, sp, #6
 80082c0:	f7fb fc74 	bl	8003bac <OSSchedUnlock>
             success = DEF_TRUE;
 80082c4:	2401      	movs	r4, #1
             break;
 80082c6:	e7a7      	b.n	8008218 <OSTmrStop+0x1c>
                         *p_err = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;

                 case OS_OPT_TMR_CALLBACK_ARG:
                      p_fnct = p_tmr->CallbackPtr;                    /* Execute callback function if available ...   */
 80082c8:	68ab      	ldr	r3, [r5, #8]
                      if (p_fnct != (OS_TMR_CALLBACK_PTR)0) {
 80082ca:	b11b      	cbz	r3, 80082d4 <OSTmrStop+0xd8>
                        (*p_fnct)((void *)p_tmr, p_callback_arg);     /* .. using the 'callback_arg' provided in call */
 80082cc:	4641      	mov	r1, r8
 80082ce:	4628      	mov	r0, r5
 80082d0:	4798      	blx	r3
 80082d2:	e7f3      	b.n	80082bc <OSTmrStop+0xc0>
                 case OS_OPT_TMR_CALLBACK:
                      p_fnct = p_tmr->CallbackPtr;                         /* Execute callback function ...           */
                      if (p_fnct != (OS_TMR_CALLBACK_PTR)0) {              /* ... if available                        */
                        (*p_fnct)((void *)p_tmr, p_tmr->CallbackPtrArg);   /* Use callback arg when timer was created */
                      } else {
                         *p_err = OS_ERR_TMR_NO_CALLBACK;
 80082d4:	f247 3344 	movw	r3, #29508	; 0x7344
 80082d8:	8033      	strh	r3, [r6, #0]
 80082da:	e7ef      	b.n	80082bc <OSTmrStop+0xc0>
 80082dc:	2000ed84 	.word	0x2000ed84
 80082e0:	20524d54 	.word	0x20524d54

080082e4 <OS_TmrTask>:
* Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
************************************************************************************************************************
*/

void  OS_TmrTask (void  *p_arg)
{
 80082e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80082e8:	4b25      	ldr	r3, [pc, #148]	; (8008380 <OS_TmrTask+0x9c>)
 80082ea:	f8df 809c 	ldr.w	r8, [pc, #156]	; 8008388 <OS_TmrTask+0xa4>
 80082ee:	881e      	ldrh	r6, [r3, #0]
 80082f0:	4c24      	ldr	r4, [pc, #144]	; (8008384 <OS_TmrTask+0xa0>)
 80082f2:	f8df 9098 	ldr.w	r9, [pc, #152]	; 800838c <OS_TmrTask+0xa8>
 80082f6:	b083      	sub	sp, #12
                    OS_TmrUnlink(p_tmr);                         /* Remove from current wheel spoke                   */
                    if (p_tmr->Opt == OS_OPT_TMR_PERIODIC) {
                        OS_TmrLink(p_tmr,
                                   OS_OPT_LINK_PERIODIC);        /* Recalculate new position of timer in wheel        */
                    } else {
                        p_tmr->State = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
 80082f8:	f04f 0a03 	mov.w	sl, #3



    p_arg = p_arg;                                               /* Not using 'p_arg', prevent compiler warning       */
    while (DEF_ON) {
        (void)OSTaskSemPend((OS_TICK )0,                         /* Wait for signal indicating time to update tmrs    */
 80082fc:	2100      	movs	r1, #0
 80082fe:	f10d 0302 	add.w	r3, sp, #2
 8008302:	aa01      	add	r2, sp, #4
 8008304:	4608      	mov	r0, r1
 8008306:	f7fe fc4d 	bl	8006ba4 <OSTaskSemPend>
                            (OS_OPT  )OS_OPT_PEND_BLOCKING,
                            (CPU_TS *)&ts,
                            (OS_ERR *)&err);

        OSSchedLock(&err);
 800830a:	f10d 0002 	add.w	r0, sp, #2
 800830e:	f7fb fc17 	bl	8003b40 <OSSchedLock>
        ts_start = OS_TS_GET();
 8008312:	f7f8 fc3b 	bl	8000b8c <CPU_TS_TmrRd>
        OSTmrTickCtr++;                                          /* Increment the current time                        */
 8008316:	6822      	ldr	r2, [r4, #0]
                            (OS_OPT  )OS_OPT_PEND_BLOCKING,
                            (CPU_TS *)&ts,
                            (OS_ERR *)&err);

        OSSchedLock(&err);
        ts_start = OS_TS_GET();
 8008318:	4605      	mov	r5, r0
        OSTmrTickCtr++;                                          /* Increment the current time                        */
 800831a:	3201      	adds	r2, #1
        spoke    = (OS_TMR_SPOKE_IX)(OSTmrTickCtr % OSCfg_TmrWheelSize);
        p_spoke  = &OSCfg_TmrWheel[spoke];
        p_tmr    = p_spoke->FirstPtr;
 800831c:	fbb2 f3f6 	udiv	r3, r2, r6
 8008320:	fb06 2313 	mls	r3, r6, r3, r2
 8008324:	b29b      	uxth	r3, r3
 8008326:	f859 7033 	ldr.w	r7, [r9, r3, lsl #3]
                            (CPU_TS *)&ts,
                            (OS_ERR *)&err);

        OSSchedLock(&err);
        ts_start = OS_TS_GET();
        OSTmrTickCtr++;                                          /* Increment the current time                        */
 800832a:	6022      	str	r2, [r4, #0]
        spoke    = (OS_TMR_SPOKE_IX)(OSTmrTickCtr % OSCfg_TmrWheelSize);
        p_spoke  = &OSCfg_TmrWheel[spoke];
        p_tmr    = p_spoke->FirstPtr;
        done     = DEF_FALSE;
        while (done == DEF_FALSE) {
            if (p_tmr != (OS_TMR *)0) {
 800832c:	b11f      	cbz	r7, 8008336 <OS_TmrTask+0x52>
                p_tmr_next = (OS_TMR *)p_tmr->NextPtr;           /* Point to next tmr to update because current ...   */
                                                                 /* ... timer could get unlinked from the wheel.      */
                if (OSTmrTickCtr == p_tmr->Match) {              /* Process each timer that expires                   */
 800832e:	69b9      	ldr	r1, [r7, #24]
 8008330:	6822      	ldr	r2, [r4, #0]
 8008332:	4291      	cmp	r1, r2
 8008334:	d00d      	beq.n	8008352 <OS_TmrTask+0x6e>
                }
            } else {
                done = DEF_TRUE;
            }
        }
        ts_end = OS_TS_GET() - ts_start;                         /* Measure execution time of timer task              */
 8008336:	f7f8 fc29 	bl	8000b8c <CPU_TS_TmrRd>
 800833a:	1b45      	subs	r5, r0, r5
        OSSchedUnlock(&err);
 800833c:	f10d 0002 	add.w	r0, sp, #2
 8008340:	f7fb fc34 	bl	8003bac <OSSchedUnlock>
        if (OSTmrTaskTimeMax < ts_end) {
 8008344:	f8d8 3000 	ldr.w	r3, [r8]
 8008348:	429d      	cmp	r5, r3
 800834a:	d9d7      	bls.n	80082fc <OS_TmrTask+0x18>
            OSTmrTaskTimeMax = ts_end;
 800834c:	4b0e      	ldr	r3, [pc, #56]	; (8008388 <OS_TmrTask+0xa4>)
 800834e:	601d      	str	r5, [r3, #0]
 8008350:	e7d4      	b.n	80082fc <OS_TmrTask+0x18>
        while (done == DEF_FALSE) {
            if (p_tmr != (OS_TMR *)0) {
                p_tmr_next = (OS_TMR *)p_tmr->NextPtr;           /* Point to next tmr to update because current ...   */
                                                                 /* ... timer could get unlinked from the wheel.      */
                if (OSTmrTickCtr == p_tmr->Match) {              /* Process each timer that expires                   */
                    OS_TmrUnlink(p_tmr);                         /* Remove from current wheel spoke                   */
 8008352:	4638      	mov	r0, r7
        p_spoke  = &OSCfg_TmrWheel[spoke];
        p_tmr    = p_spoke->FirstPtr;
        done     = DEF_FALSE;
        while (done == DEF_FALSE) {
            if (p_tmr != (OS_TMR *)0) {
                p_tmr_next = (OS_TMR *)p_tmr->NextPtr;           /* Point to next tmr to update because current ...   */
 8008354:	f8d7 b010 	ldr.w	fp, [r7, #16]
                                                                 /* ... timer could get unlinked from the wheel.      */
                if (OSTmrTickCtr == p_tmr->Match) {              /* Process each timer that expires                   */
                    OS_TmrUnlink(p_tmr);                         /* Remove from current wheel spoke                   */
 8008358:	f7ff fed6 	bl	8008108 <OS_TmrUnlink>
                    if (p_tmr->Opt == OS_OPT_TMR_PERIODIC) {
 800835c:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
 800835e:	2a02      	cmp	r2, #2
 8008360:	d008      	beq.n	8008374 <OS_TmrTask+0x90>
                        OS_TmrLink(p_tmr,
                                   OS_OPT_LINK_PERIODIC);        /* Recalculate new position of timer in wheel        */
                    } else {
                        p_tmr->State = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
 8008362:	f887 a02a 	strb.w	sl, [r7, #42]	; 0x2a
                    }
                    p_fnct = p_tmr->CallbackPtr;                 /* Execute callback function if available            */
 8008366:	68ba      	ldr	r2, [r7, #8]
                    if (p_fnct != (OS_TMR_CALLBACK_PTR)0) {
 8008368:	b112      	cbz	r2, 8008370 <OS_TmrTask+0x8c>
                        (*p_fnct)((void *)p_tmr,
 800836a:	68f9      	ldr	r1, [r7, #12]
 800836c:	4638      	mov	r0, r7
 800836e:	4790      	blx	r2
* Note(s)    : 1) This function is INTERNAL to uC/OS-III and your application MUST NOT call it.
************************************************************************************************************************
*/

void  OS_TmrTask (void  *p_arg)
{
 8008370:	465f      	mov	r7, fp
 8008372:	e7db      	b.n	800832c <OS_TmrTask+0x48>
                p_tmr_next = (OS_TMR *)p_tmr->NextPtr;           /* Point to next tmr to update because current ...   */
                                                                 /* ... timer could get unlinked from the wheel.      */
                if (OSTmrTickCtr == p_tmr->Match) {              /* Process each timer that expires                   */
                    OS_TmrUnlink(p_tmr);                         /* Remove from current wheel spoke                   */
                    if (p_tmr->Opt == OS_OPT_TMR_PERIODIC) {
                        OS_TmrLink(p_tmr,
 8008374:	2101      	movs	r1, #1
 8008376:	4638      	mov	r0, r7
 8008378:	f7ff fe5c 	bl	8008034 <OS_TmrLink>
 800837c:	e7f3      	b.n	8008366 <OS_TmrTask+0x82>
 800837e:	bf00      	nop
 8008380:	08016094 	.word	0x08016094
 8008384:	2000ed50 	.word	0x2000ed50
 8008388:	2000ed70 	.word	0x2000ed70
 800838c:	2000e0e8 	.word	0x2000e0e8

08008390 <EXTI_DeInit>:
  * @param  None
  * @retval None
  */
void EXTI_DeInit(void)
{
  EXTI->IMR = 0x00000000;
 8008390:	4b04      	ldr	r3, [pc, #16]	; (80083a4 <EXTI_DeInit+0x14>)
  EXTI->EMR = 0x00000000;
  EXTI->RTSR = 0x00000000;
  EXTI->FTSR = 0x00000000;
  EXTI->PR = 0x007FFFFF;
 8008392:	4905      	ldr	r1, [pc, #20]	; (80083a8 <EXTI_DeInit+0x18>)
  * @param  None
  * @retval None
  */
void EXTI_DeInit(void)
{
  EXTI->IMR = 0x00000000;
 8008394:	2200      	movs	r2, #0
 8008396:	601a      	str	r2, [r3, #0]
  EXTI->EMR = 0x00000000;
 8008398:	605a      	str	r2, [r3, #4]
  EXTI->RTSR = 0x00000000;
 800839a:	609a      	str	r2, [r3, #8]
  EXTI->FTSR = 0x00000000;
 800839c:	60da      	str	r2, [r3, #12]
  EXTI->PR = 0x007FFFFF;
 800839e:	6159      	str	r1, [r3, #20]
 80083a0:	4770      	bx	lr
 80083a2:	bf00      	nop
 80083a4:	40013c00 	.word	0x40013c00
 80083a8:	007fffff 	.word	0x007fffff

080083ac <EXTI_Init>:
  assert_param(IS_EXTI_LINE(EXTI_InitStruct->EXTI_Line));  
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));

  tmp = (uint32_t)EXTI_BASE;
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
 80083ac:	7983      	ldrb	r3, [r0, #6]
 80083ae:	b333      	cbz	r3, 80083fe <EXTI_Init+0x52>
  * @param  EXTI_InitStruct: pointer to a EXTI_InitTypeDef structure
  *         that contains the configuration information for the EXTI peripheral.
  * @retval None
  */
void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct)
{
 80083b0:	b470      	push	{r4, r5, r6}
  tmp = (uint32_t)EXTI_BASE;
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
  {
    /* Clear EXTI line configuration */
    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;
 80083b2:	6806      	ldr	r6, [r0, #0]
 80083b4:	4b1b      	ldr	r3, [pc, #108]	; (8008424 <EXTI_Init+0x78>)
 80083b6:	43f4      	mvns	r4, r6
 80083b8:	681d      	ldr	r5, [r3, #0]
    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;
    
    tmp += EXTI_InitStruct->EXTI_Mode;

    *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 80083ba:	7902      	ldrb	r2, [r0, #4]
  tmp = (uint32_t)EXTI_BASE;
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
  {
    /* Clear EXTI line configuration */
    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;
 80083bc:	4025      	ands	r5, r4
 80083be:	601d      	str	r5, [r3, #0]
    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;
 80083c0:	6859      	ldr	r1, [r3, #4]
    
    tmp += EXTI_InitStruct->EXTI_Mode;

    *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 80083c2:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
     
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
  {
    /* Clear EXTI line configuration */
    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;
    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;
 80083c6:	4021      	ands	r1, r4
 80083c8:	6059      	str	r1, [r3, #4]
    
    tmp += EXTI_InitStruct->EXTI_Mode;

    *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 80083ca:	f502 329e 	add.w	r2, r2, #80896	; 0x13c00
 80083ce:	6814      	ldr	r4, [r2, #0]
    /* Clear Rising Falling edge configuration */
    EXTI->RTSR &= ~EXTI_InitStruct->EXTI_Line;
    EXTI->FTSR &= ~EXTI_InitStruct->EXTI_Line;
    
    /* Select the trigger for the selected external interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
 80083d0:	7941      	ldrb	r1, [r0, #5]
    EXTI->IMR &= ~EXTI_InitStruct->EXTI_Line;
    EXTI->EMR &= ~EXTI_InitStruct->EXTI_Line;
    
    tmp += EXTI_InitStruct->EXTI_Mode;

    *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 80083d2:	4334      	orrs	r4, r6
 80083d4:	6014      	str	r4, [r2, #0]

    /* Clear Rising Falling edge configuration */
    EXTI->RTSR &= ~EXTI_InitStruct->EXTI_Line;
 80083d6:	6804      	ldr	r4, [r0, #0]
 80083d8:	6898      	ldr	r0, [r3, #8]
 80083da:	43e5      	mvns	r5, r4
 80083dc:	4028      	ands	r0, r5
 80083de:	6098      	str	r0, [r3, #8]
    EXTI->FTSR &= ~EXTI_InitStruct->EXTI_Line;
 80083e0:	68da      	ldr	r2, [r3, #12]
    
    /* Select the trigger for the selected external interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
 80083e2:	2910      	cmp	r1, #16

    *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;

    /* Clear Rising Falling edge configuration */
    EXTI->RTSR &= ~EXTI_InitStruct->EXTI_Line;
    EXTI->FTSR &= ~EXTI_InitStruct->EXTI_Line;
 80083e4:	ea02 0205 	and.w	r2, r2, r5
 80083e8:	60da      	str	r2, [r3, #12]
    
    /* Select the trigger for the selected external interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
 80083ea:	d013      	beq.n	8008414 <EXTI_Init+0x68>
    else
    {
      tmp = (uint32_t)EXTI_BASE;
      tmp += EXTI_InitStruct->EXTI_Trigger;

      *(__IO uint32_t *) tmp |= EXTI_InitStruct->EXTI_Line;
 80083ec:	f101 4380 	add.w	r3, r1, #1073741824	; 0x40000000
 80083f0:	f503 339e 	add.w	r3, r3, #80896	; 0x13c00
 80083f4:	681a      	ldr	r2, [r3, #0]
 80083f6:	4314      	orrs	r4, r2
 80083f8:	601c      	str	r4, [r3, #0]
    tmp += EXTI_InitStruct->EXTI_Mode;

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
  }
}
 80083fa:	bc70      	pop	{r4, r5, r6}
 80083fc:	4770      	bx	lr
  else
  {
    tmp += EXTI_InitStruct->EXTI_Mode;

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
 80083fe:	7903      	ldrb	r3, [r0, #4]
 8008400:	6801      	ldr	r1, [r0, #0]
 8008402:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8008406:	f503 339e 	add.w	r3, r3, #80896	; 0x13c00
 800840a:	681a      	ldr	r2, [r3, #0]
 800840c:	ea22 0201 	bic.w	r2, r2, r1
 8008410:	601a      	str	r2, [r3, #0]
  }
}
 8008412:	4770      	bx	lr
    
    /* Select the trigger for the selected external interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
    {
      /* Rising Falling edge */
      EXTI->RTSR |= EXTI_InitStruct->EXTI_Line;
 8008414:	689a      	ldr	r2, [r3, #8]
 8008416:	4322      	orrs	r2, r4
 8008418:	609a      	str	r2, [r3, #8]
      EXTI->FTSR |= EXTI_InitStruct->EXTI_Line;
 800841a:	68da      	ldr	r2, [r3, #12]
 800841c:	4314      	orrs	r4, r2
 800841e:	60dc      	str	r4, [r3, #12]
    tmp += EXTI_InitStruct->EXTI_Mode;

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~EXTI_InitStruct->EXTI_Line;
  }
}
 8008420:	bc70      	pop	{r4, r5, r6}
 8008422:	4770      	bx	lr
 8008424:	40013c00 	.word	0x40013c00

08008428 <EXTI_StructInit>:
  *         be initialized.
  * @retval None
  */
void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct)
{
  EXTI_InitStruct->EXTI_Line = EXTI_LINENONE;
 8008428:	2300      	movs	r3, #0
  EXTI_InitStruct->EXTI_Mode = EXTI_Mode_Interrupt;
  EXTI_InitStruct->EXTI_Trigger = EXTI_Trigger_Falling;
 800842a:	220c      	movs	r2, #12
 800842c:	7142      	strb	r2, [r0, #5]
  *         be initialized.
  * @retval None
  */
void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct)
{
  EXTI_InitStruct->EXTI_Line = EXTI_LINENONE;
 800842e:	6003      	str	r3, [r0, #0]
  EXTI_InitStruct->EXTI_Mode = EXTI_Mode_Interrupt;
 8008430:	7103      	strb	r3, [r0, #4]
  EXTI_InitStruct->EXTI_Trigger = EXTI_Trigger_Falling;
  EXTI_InitStruct->EXTI_LineCmd = DISABLE;
 8008432:	7183      	strb	r3, [r0, #6]
 8008434:	4770      	bx	lr
 8008436:	bf00      	nop

08008438 <EXTI_GenerateSWInterrupt>:
void EXTI_GenerateSWInterrupt(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
  
  EXTI->SWIER |= EXTI_Line;
 8008438:	4a02      	ldr	r2, [pc, #8]	; (8008444 <EXTI_GenerateSWInterrupt+0xc>)
 800843a:	6913      	ldr	r3, [r2, #16]
 800843c:	4318      	orrs	r0, r3
 800843e:	6110      	str	r0, [r2, #16]
 8008440:	4770      	bx	lr
 8008442:	bf00      	nop
 8008444:	40013c00 	.word	0x40013c00

08008448 <EXTI_GetFlagStatus>:
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
  
  if ((EXTI->PR & EXTI_Line) != (uint32_t)RESET)
 8008448:	4b03      	ldr	r3, [pc, #12]	; (8008458 <EXTI_GetFlagStatus+0x10>)
 800844a:	695b      	ldr	r3, [r3, #20]
  }
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
 800844c:	4203      	tst	r3, r0
}
 800844e:	bf14      	ite	ne
 8008450:	2001      	movne	r0, #1
 8008452:	2000      	moveq	r0, #0
 8008454:	4770      	bx	lr
 8008456:	bf00      	nop
 8008458:	40013c00 	.word	0x40013c00

0800845c <EXTI_ClearFlag>:
 800845c:	4b01      	ldr	r3, [pc, #4]	; (8008464 <EXTI_ClearFlag+0x8>)
 800845e:	6158      	str	r0, [r3, #20]
 8008460:	4770      	bx	lr
 8008462:	bf00      	nop
 8008464:	40013c00 	.word	0x40013c00

08008468 <EXTI_GetITStatus>:
  ITStatus bitstatus = RESET;
  uint32_t enablestatus = 0;
  /* Check the parameters */
  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
  
  enablestatus =  EXTI->IMR & EXTI_Line;
 8008468:	4b05      	ldr	r3, [pc, #20]	; (8008480 <EXTI_GetITStatus+0x18>)
 800846a:	681a      	ldr	r2, [r3, #0]
  if (((EXTI->PR & EXTI_Line) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
 800846c:	695b      	ldr	r3, [r3, #20]
 800846e:	4003      	ands	r3, r0
 8008470:	d004      	beq.n	800847c <EXTI_GetITStatus+0x14>
  {
    bitstatus = SET;
 8008472:	4202      	tst	r2, r0
 8008474:	bf14      	ite	ne
 8008476:	2001      	movne	r0, #1
 8008478:	2000      	moveq	r0, #0
 800847a:	4770      	bx	lr
  }
  else
  {
    bitstatus = RESET;
 800847c:	4618      	mov	r0, r3
  }
  return bitstatus;
}
 800847e:	4770      	bx	lr
 8008480:	40013c00 	.word	0x40013c00

08008484 <EXTI_ClearITPendingBit>:
void EXTI_ClearITPendingBit(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(EXTI_Line));
  
  EXTI->PR = EXTI_Line;
 8008484:	4b01      	ldr	r3, [pc, #4]	; (800848c <EXTI_ClearITPendingBit+0x8>)
 8008486:	6158      	str	r0, [r3, #20]
 8008488:	4770      	bx	lr
 800848a:	bf00      	nop
 800848c:	40013c00 	.word	0x40013c00

08008490 <FSMC_NORSRAMDeInit>:
{
  /* Check the parameter */
  assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
  
  /* FSMC_Bank1_NORSRAM1 */
  if(FSMC_Bank == FSMC_Bank1_NORSRAM1)
 8008490:	b170      	cbz	r0, 80084b0 <FSMC_NORSRAMDeInit+0x20>
    FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030DB;    
  }
  /* FSMC_Bank1_NORSRAM2,  FSMC_Bank1_NORSRAM3 or FSMC_Bank1_NORSRAM4 */
  else
  {   
    FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030D2; 
 8008492:	f243 02d2 	movw	r2, #12498	; 0x30d2
 8008496:	f04f 4320 	mov.w	r3, #2684354560	; 0xa0000000
 800849a:	f843 2020 	str.w	r2, [r3, r0, lsl #2]
 800849e:	0080      	lsls	r0, r0, #2
 80084a0:	f100 4020 	add.w	r0, r0, #2684354560	; 0xa0000000
  }
  FSMC_Bank1->BTCR[FSMC_Bank + 1] = 0x0FFFFFFF;
 80084a4:	f06f 4370 	mvn.w	r3, #4026531840	; 0xf0000000
 80084a8:	6043      	str	r3, [r0, #4]
  FSMC_Bank1E->BWTR[FSMC_Bank] = 0x0FFFFFFF;  
 80084aa:	f8c0 3104 	str.w	r3, [r0, #260]	; 0x104
 80084ae:	4770      	bx	lr
  assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
  
  /* FSMC_Bank1_NORSRAM1 */
  if(FSMC_Bank == FSMC_Bank1_NORSRAM1)
  {
    FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030DB;    
 80084b0:	f243 02db 	movw	r2, #12507	; 0x30db
 80084b4:	f04f 4320 	mov.w	r3, #2684354560	; 0xa0000000
 80084b8:	601a      	str	r2, [r3, #0]
 80084ba:	e7f0      	b.n	800849e <FSMC_NORSRAMDeInit+0xe>

080084bc <FSMC_NORSRAMInit>:
  *         that contains the configuration information for the FSMC NOR/SRAM 
  *         specified Banks.                       
  * @retval None
  */
void FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
{ 
 80084bc:	b4f0      	push	{r4, r5, r6, r7}
            FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity |
            FSMC_NORSRAMInitStruct->FSMC_WrapMode |
            FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive |
            FSMC_NORSRAMInitStruct->FSMC_WriteOperation |
            FSMC_NORSRAMInitStruct->FSMC_WaitSignal |
            FSMC_NORSRAMInitStruct->FSMC_ExtendedMode |
 80084be:	6843      	ldr	r3, [r0, #4]
  assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode)); 
  
  /* Bank1 NOR/SRAM control register configuration */ 
  FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
            (uint32_t)FSMC_NORSRAMInitStruct->FSMC_DataAddressMux |
            FSMC_NORSRAMInitStruct->FSMC_MemoryType |
 80084c0:	6885      	ldr	r5, [r0, #8]
            FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity |
            FSMC_NORSRAMInitStruct->FSMC_WrapMode |
            FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive |
            FSMC_NORSRAMInitStruct->FSMC_WriteOperation |
            FSMC_NORSRAMInitStruct->FSMC_WaitSignal |
            FSMC_NORSRAMInitStruct->FSMC_ExtendedMode |
 80084c2:	68c2      	ldr	r2, [r0, #12]
 80084c4:	ea45 0103 	orr.w	r1, r5, r3
 80084c8:	6903      	ldr	r3, [r0, #16]
 80084ca:	430a      	orrs	r2, r1
 80084cc:	6941      	ldr	r1, [r0, #20]
 80084ce:	4313      	orrs	r3, r2
 80084d0:	6982      	ldr	r2, [r0, #24]
 80084d2:	4319      	orrs	r1, r3
 80084d4:	69c3      	ldr	r3, [r0, #28]
 80084d6:	430a      	orrs	r2, r1
 80084d8:	6a01      	ldr	r1, [r0, #32]
 80084da:	4313      	orrs	r3, r2
 80084dc:	6a42      	ldr	r2, [r0, #36]	; 0x24
 80084de:	4319      	orrs	r1, r3
 80084e0:	6a83      	ldr	r3, [r0, #40]	; 0x28
 80084e2:	430a      	orrs	r2, r1
 80084e4:	6ac6      	ldr	r6, [r0, #44]	; 0x2c
 80084e6:	6804      	ldr	r4, [r0, #0]
 80084e8:	4313      	orrs	r3, r2
 80084ea:	6b02      	ldr	r2, [r0, #48]	; 0x30
 80084ec:	4333      	orrs	r3, r6
 80084ee:	00a4      	lsls	r4, r4, #2
 80084f0:	4313      	orrs	r3, r2
 80084f2:	f104 4420 	add.w	r4, r4, #2684354560	; 0xa0000000
            FSMC_NORSRAMInitStruct->FSMC_WriteBurst;
  if(FSMC_NORSRAMInitStruct->FSMC_MemoryType == FSMC_MemoryType_NOR)
 80084f6:	2d08      	cmp	r5, #8
  assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision));
  assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency));
  assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode)); 
  
  /* Bank1 NOR/SRAM control register configuration */ 
  FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
 80084f8:	6023      	str	r3, [r4, #0]
            FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive |
            FSMC_NORSRAMInitStruct->FSMC_WriteOperation |
            FSMC_NORSRAMInitStruct->FSMC_WaitSignal |
            FSMC_NORSRAMInitStruct->FSMC_ExtendedMode |
            FSMC_NORSRAMInitStruct->FSMC_WriteBurst;
  if(FSMC_NORSRAMInitStruct->FSMC_MemoryType == FSMC_MemoryType_NOR)
 80084fa:	d01d      	beq.n	8008538 <FSMC_NORSRAMInit+0x7c>
  {
    FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] |= (uint32_t)BCR_FACCEN_SET;
  }
  /* Bank1 NOR/SRAM timing register configuration */
  FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank+1] = 
            (uint32_t)FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime |
 80084fc:	6b45      	ldr	r5, [r0, #52]	; 0x34
            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency << 24) |
             FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode;
            
    
  /* Bank1 NOR/SRAM timing register for write configuration, if extended mode is used */
  if(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode == FSMC_ExtendedMode_Enable)
 80084fe:	f5b6 4f80 	cmp.w	r6, #16384	; 0x4000
            (uint32_t)FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime |
            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime << 4) |
            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime << 8) |
            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration << 16) |
            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision << 20) |
            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency << 24) |
 8008502:	6829      	ldr	r1, [r5, #0]
 8008504:	69ab      	ldr	r3, [r5, #24]
 8008506:	686f      	ldr	r7, [r5, #4]
 8008508:	ea43 0301 	orr.w	r3, r3, r1
 800850c:	68aa      	ldr	r2, [r5, #8]
 800850e:	ea43 1107 	orr.w	r1, r3, r7, lsl #4
 8008512:	68ef      	ldr	r7, [r5, #12]
 8008514:	ea41 2202 	orr.w	r2, r1, r2, lsl #8
 8008518:	692b      	ldr	r3, [r5, #16]
 800851a:	6969      	ldr	r1, [r5, #20]
 800851c:	ea42 4207 	orr.w	r2, r2, r7, lsl #16
 8008520:	ea42 5303 	orr.w	r3, r2, r3, lsl #20
 8008524:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
  if(FSMC_NORSRAMInitStruct->FSMC_MemoryType == FSMC_MemoryType_NOR)
  {
    FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] |= (uint32_t)BCR_FACCEN_SET;
  }
  /* Bank1 NOR/SRAM timing register configuration */
  FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank+1] = 
 8008528:	6063      	str	r3, [r4, #4]
            (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency << 24) |
             FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode;
            
    
  /* Bank1 NOR/SRAM timing register for write configuration, if extended mode is used */
  if(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode == FSMC_ExtendedMode_Enable)
 800852a:	d00a      	beq.n	8008542 <FSMC_NORSRAMInit+0x86>
              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency << 24) |
               FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode;
  }
  else
  {
    FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 0x0FFFFFFF;
 800852c:	f06f 4370 	mvn.w	r3, #4026531840	; 0xf0000000
 8008530:	f8c4 3104 	str.w	r3, [r4, #260]	; 0x104
  }
}
 8008534:	bcf0      	pop	{r4, r5, r6, r7}
 8008536:	4770      	bx	lr
            FSMC_NORSRAMInitStruct->FSMC_WaitSignal |
            FSMC_NORSRAMInitStruct->FSMC_ExtendedMode |
            FSMC_NORSRAMInitStruct->FSMC_WriteBurst;
  if(FSMC_NORSRAMInitStruct->FSMC_MemoryType == FSMC_MemoryType_NOR)
  {
    FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] |= (uint32_t)BCR_FACCEN_SET;
 8008538:	6823      	ldr	r3, [r4, #0]
 800853a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800853e:	6023      	str	r3, [r4, #0]
 8008540:	e7dc      	b.n	80084fc <FSMC_NORSRAMInit+0x40>
    assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime));
    assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision));
    assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency));
    assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode));
    FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
              (uint32_t)FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime |
 8008542:	6b80      	ldr	r0, [r0, #56]	; 0x38
              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime << 4 )|
              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime << 8) |
              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision << 20) |
              (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency << 24) |
 8008544:	6983      	ldr	r3, [r0, #24]
 8008546:	6801      	ldr	r1, [r0, #0]
 8008548:	6842      	ldr	r2, [r0, #4]
 800854a:	4319      	orrs	r1, r3
 800854c:	6885      	ldr	r5, [r0, #8]
 800854e:	ea41 1202 	orr.w	r2, r1, r2, lsl #4
 8008552:	6903      	ldr	r3, [r0, #16]
 8008554:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
 8008558:	6941      	ldr	r1, [r0, #20]
 800855a:	ea42 5303 	orr.w	r3, r2, r3, lsl #20
 800855e:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
    assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime));
    assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime));
    assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision));
    assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency));
    assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode));
    FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
 8008562:	f8c4 3104 	str.w	r3, [r4, #260]	; 0x104
  }
  else
  {
    FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 0x0FFFFFFF;
  }
}
 8008566:	bcf0      	pop	{r4, r5, r6, r7}
 8008568:	4770      	bx	lr
 800856a:	bf00      	nop

0800856c <FSMC_NORSRAMStructInit>:
  * @param  FSMC_NORSRAMInitStruct: pointer to a FSMC_NORSRAMInitTypeDef structure 
  *         which will be initialized.
  * @retval None
  */
void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
{  
 800856c:	b4f0      	push	{r4, r5, r6, r7}
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime = 0xFF;
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision = 0xF;
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency = 0xF;
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A; 
  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime = 0xF;
 800856e:	6b81      	ldr	r1, [r0, #56]	; 0x38
  FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
  FSMC_NORSRAMInitStruct->FSMC_WriteOperation = FSMC_WriteOperation_Enable;
  FSMC_NORSRAMInitStruct->FSMC_WaitSignal = FSMC_WaitSignal_Enable;
  FSMC_NORSRAMInitStruct->FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
  FSMC_NORSRAMInitStruct->FSMC_WriteBurst = FSMC_WriteBurst_Disable;
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime = 0xF;
 8008570:	6b44      	ldr	r4, [r0, #52]	; 0x34
  */
void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
{  
  /* Reset NOR/SRAM Init structure parameters values */
  FSMC_NORSRAMInitStruct->FSMC_Bank = FSMC_Bank1_NORSRAM1;
  FSMC_NORSRAMInitStruct->FSMC_DataAddressMux = FSMC_DataAddressMux_Enable;
 8008572:	2502      	movs	r5, #2
 8008574:	6045      	str	r5, [r0, #4]
  * @retval None
  */
void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
{  
  /* Reset NOR/SRAM Init structure parameters values */
  FSMC_NORSRAMInitStruct->FSMC_Bank = FSMC_Bank1_NORSRAM1;
 8008576:	2300      	movs	r3, #0
  FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
  FSMC_NORSRAMInitStruct->FSMC_WriteOperation = FSMC_WriteOperation_Enable;
  FSMC_NORSRAMInitStruct->FSMC_WaitSignal = FSMC_WaitSignal_Enable;
  FSMC_NORSRAMInitStruct->FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
  FSMC_NORSRAMInitStruct->FSMC_WriteBurst = FSMC_WriteBurst_Disable;
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime = 0xF;
 8008578:	220f      	movs	r2, #15
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime = 0xF;
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime = 0xFF;
 800857a:	25ff      	movs	r5, #255	; 0xff
  FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
  FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;
  FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
  FSMC_NORSRAMInitStruct->FSMC_WrapMode = FSMC_WrapMode_Disable;
  FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
  FSMC_NORSRAMInitStruct->FSMC_WriteOperation = FSMC_WriteOperation_Enable;
 800857c:	f44f 5780 	mov.w	r7, #4096	; 0x1000
  FSMC_NORSRAMInitStruct->FSMC_WaitSignal = FSMC_WaitSignal_Enable;
 8008580:	f44f 5600 	mov.w	r6, #8192	; 0x2000
  FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
  FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;
  FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
  FSMC_NORSRAMInitStruct->FSMC_WrapMode = FSMC_WrapMode_Disable;
  FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
  FSMC_NORSRAMInitStruct->FSMC_WriteOperation = FSMC_WriteOperation_Enable;
 8008584:	6247      	str	r7, [r0, #36]	; 0x24
  FSMC_NORSRAMInitStruct->FSMC_WaitSignal = FSMC_WaitSignal_Enable;
 8008586:	6286      	str	r6, [r0, #40]	; 0x28
  * @retval None
  */
void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
{  
  /* Reset NOR/SRAM Init structure parameters values */
  FSMC_NORSRAMInitStruct->FSMC_Bank = FSMC_Bank1_NORSRAM1;
 8008588:	6003      	str	r3, [r0, #0]
  FSMC_NORSRAMInitStruct->FSMC_DataAddressMux = FSMC_DataAddressMux_Enable;
  FSMC_NORSRAMInitStruct->FSMC_MemoryType = FSMC_MemoryType_SRAM;
 800858a:	6083      	str	r3, [r0, #8]
  FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
 800858c:	60c3      	str	r3, [r0, #12]
  FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
 800858e:	6103      	str	r3, [r0, #16]
  FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;
 8008590:	6143      	str	r3, [r0, #20]
  FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
 8008592:	6183      	str	r3, [r0, #24]
  FSMC_NORSRAMInitStruct->FSMC_WrapMode = FSMC_WrapMode_Disable;
 8008594:	61c3      	str	r3, [r0, #28]
  FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
 8008596:	6203      	str	r3, [r0, #32]
  FSMC_NORSRAMInitStruct->FSMC_WriteOperation = FSMC_WriteOperation_Enable;
  FSMC_NORSRAMInitStruct->FSMC_WaitSignal = FSMC_WaitSignal_Enable;
  FSMC_NORSRAMInitStruct->FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
 8008598:	62c3      	str	r3, [r0, #44]	; 0x2c
  FSMC_NORSRAMInitStruct->FSMC_WriteBurst = FSMC_WriteBurst_Disable;
 800859a:	6303      	str	r3, [r0, #48]	; 0x30
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime = 0xF;
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime = 0xFF;
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision = 0xF;
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency = 0xF;
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A; 
 800859c:	61a3      	str	r3, [r4, #24]
  FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
  FSMC_NORSRAMInitStruct->FSMC_WriteOperation = FSMC_WriteOperation_Enable;
  FSMC_NORSRAMInitStruct->FSMC_WaitSignal = FSMC_WaitSignal_Enable;
  FSMC_NORSRAMInitStruct->FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
  FSMC_NORSRAMInitStruct->FSMC_WriteBurst = FSMC_WriteBurst_Disable;
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime = 0xF;
 800859e:	6022      	str	r2, [r4, #0]
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime = 0xF;
 80085a0:	6062      	str	r2, [r4, #4]
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime = 0xFF;
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
 80085a2:	60e2      	str	r2, [r4, #12]
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision = 0xF;
 80085a4:	6122      	str	r2, [r4, #16]
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency = 0xF;
 80085a6:	6162      	str	r2, [r4, #20]
  FSMC_NORSRAMInitStruct->FSMC_WaitSignal = FSMC_WaitSignal_Enable;
  FSMC_NORSRAMInitStruct->FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
  FSMC_NORSRAMInitStruct->FSMC_WriteBurst = FSMC_WriteBurst_Disable;
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime = 0xF;
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime = 0xF;
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime = 0xFF;
 80085a8:	60a5      	str	r5, [r4, #8]
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision = 0xF;
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency = 0xF;
  FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A; 
  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime = 0xF;
 80085aa:	600a      	str	r2, [r1, #0]
  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime = 0xF;
 80085ac:	604a      	str	r2, [r1, #4]
  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime = 0xFF;
 80085ae:	608d      	str	r5, [r1, #8]
  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
 80085b0:	60ca      	str	r2, [r1, #12]
  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision = 0xF;
 80085b2:	610a      	str	r2, [r1, #16]
  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency = 0xF;
 80085b4:	614a      	str	r2, [r1, #20]
  FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A;
 80085b6:	618b      	str	r3, [r1, #24]
}
 80085b8:	bcf0      	pop	{r4, r5, r6, r7}
 80085ba:	4770      	bx	lr

080085bc <FSMC_NORSRAMCmd>:
  *            @arg FSMC_Bank1_NORSRAM4: FSMC Bank1 NOR/SRAM4 
  * @param  NewState: new state of the FSMC_Bank. This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void FSMC_NORSRAMCmd(uint32_t FSMC_Bank, FunctionalState NewState)
{
 80085bc:	0080      	lsls	r0, r0, #2
 80085be:	f100 4020 	add.w	r0, r0, #2684354560	; 0xa0000000
  assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80085c2:	b921      	cbnz	r1, 80085ce <FSMC_NORSRAMCmd+0x12>
    FSMC_Bank1->BTCR[FSMC_Bank] |= BCR_MBKEN_SET;
  }
  else
  {
    /* Disable the selected NOR/SRAM Bank by clearing the PBKEN bit in the BCRx register */
    FSMC_Bank1->BTCR[FSMC_Bank] &= BCR_MBKEN_RESET;
 80085c4:	6802      	ldr	r2, [r0, #0]
 80085c6:	4b04      	ldr	r3, [pc, #16]	; (80085d8 <FSMC_NORSRAMCmd+0x1c>)
 80085c8:	4013      	ands	r3, r2
 80085ca:	6003      	str	r3, [r0, #0]
 80085cc:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected NOR/SRAM Bank by setting the PBKEN bit in the BCRx register */
    FSMC_Bank1->BTCR[FSMC_Bank] |= BCR_MBKEN_SET;
 80085ce:	6803      	ldr	r3, [r0, #0]
 80085d0:	f043 0301 	orr.w	r3, r3, #1
 80085d4:	6003      	str	r3, [r0, #0]
 80085d6:	4770      	bx	lr
 80085d8:	000ffffe 	.word	0x000ffffe

080085dc <FSMC_NANDDeInit>:
void FSMC_NANDDeInit(uint32_t FSMC_Bank)
{
  /* Check the parameter */
  assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
  
  if(FSMC_Bank == FSMC_Bank2_NAND)
 80085dc:	2810      	cmp	r0, #16
  {
    /* Set the FSMC_Bank2 registers to their reset values */
    FSMC_Bank2->PCR2 = 0x00000018;
 80085de:	bf0c      	ite	eq
 80085e0:	4b05      	ldreq	r3, [pc, #20]	; (80085f8 <FSMC_NANDDeInit+0x1c>)
  }
  /* FSMC_Bank3_NAND */  
  else
  {
    /* Set the FSMC_Bank3 registers to their reset values */
    FSMC_Bank3->PCR3 = 0x00000018;
 80085e2:	4b06      	ldrne	r3, [pc, #24]	; (80085fc <FSMC_NANDDeInit+0x20>)
    FSMC_Bank3->SR3 = 0x00000040;
    FSMC_Bank3->PMEM3 = 0xFCFCFCFC;
 80085e4:	f04f 32fc 	mov.w	r2, #4244438268	; 0xfcfcfcfc
  }
  /* FSMC_Bank3_NAND */  
  else
  {
    /* Set the FSMC_Bank3 registers to their reset values */
    FSMC_Bank3->PCR3 = 0x00000018;
 80085e8:	2018      	movs	r0, #24
    FSMC_Bank3->SR3 = 0x00000040;
 80085ea:	2140      	movs	r1, #64	; 0x40
  }
  /* FSMC_Bank3_NAND */  
  else
  {
    /* Set the FSMC_Bank3 registers to their reset values */
    FSMC_Bank3->PCR3 = 0x00000018;
 80085ec:	6018      	str	r0, [r3, #0]
    FSMC_Bank3->SR3 = 0x00000040;
 80085ee:	6059      	str	r1, [r3, #4]
    FSMC_Bank3->PMEM3 = 0xFCFCFCFC;
 80085f0:	609a      	str	r2, [r3, #8]
    FSMC_Bank3->PATT3 = 0xFCFCFCFC; 
 80085f2:	60da      	str	r2, [r3, #12]
 80085f4:	4770      	bx	lr
 80085f6:	bf00      	nop
 80085f8:	a0000060 	.word	0xa0000060
 80085fc:	a0000080 	.word	0xa0000080

08008600 <FSMC_NANDInit>:
  * @param  FSMC_NANDInitStruct : pointer to a FSMC_NANDInitTypeDef structure that
  *         contains the configuration information for the FSMC NAND specified Banks.                       
  * @retval None
  */
void FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
{
 8008600:	b5f0      	push	{r4, r5, r6, r7, lr}
  assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
  assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
  assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
  
  /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */
  tmppcr = (uint32_t)FSMC_NANDInitStruct->FSMC_Waitfeature |
 8008602:	6883      	ldr	r3, [r0, #8]
 8008604:	6844      	ldr	r4, [r0, #4]
 8008606:	68c6      	ldr	r6, [r0, #12]
 8008608:	4323      	orrs	r3, r4
            FSMC_NANDInitStruct->FSMC_ECCPageSize |
            (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
            (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);
            
  /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
  tmppmem = (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
 800860a:	69c7      	ldr	r7, [r0, #28]
  assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
  assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
  assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
  
  /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */
  tmppcr = (uint32_t)FSMC_NANDInitStruct->FSMC_Waitfeature |
 800860c:	f043 0408 	orr.w	r4, r3, #8
 8008610:	6903      	ldr	r3, [r0, #16]
 8008612:	4326      	orrs	r6, r4
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
            
  /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
  tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
 8008614:	6a05      	ldr	r5, [r0, #32]
            FSMC_NANDInitStruct->FSMC_ECCPageSize |
            (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
            (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);
            
  /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
  tmppmem = (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
 8008616:	68b9      	ldr	r1, [r7, #8]
  assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
  assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
  assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
  
  /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */
  tmppcr = (uint32_t)FSMC_NANDInitStruct->FSMC_Waitfeature |
 8008618:	4333      	orrs	r3, r6
 800861a:	6946      	ldr	r6, [r0, #20]
            FSMC_NANDInitStruct->FSMC_ECCPageSize |
            (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
            (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);
            
  /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
  tmppmem = (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
 800861c:	687c      	ldr	r4, [r7, #4]
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
            
  /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
  tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
 800861e:	68aa      	ldr	r2, [r5, #8]
  assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
  assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
  assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
  
  /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */
  tmppcr = (uint32_t)FSMC_NANDInitStruct->FSMC_Waitfeature |
 8008620:	ea43 2346 	orr.w	r3, r3, r6, lsl #9
 8008624:	f8d0 e018 	ldr.w	lr, [r0, #24]
  tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
            (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
            (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
            (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);
  
  if(FSMC_NANDInitStruct->FSMC_Bank == FSMC_Bank2_NAND)
 8008628:	6806      	ldr	r6, [r0, #0]
            FSMC_NANDInitStruct->FSMC_ECCPageSize |
            (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
            (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);
            
  /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
  tmppmem = (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
 800862a:	0409      	lsls	r1, r1, #16
 800862c:	6838      	ldr	r0, [r7, #0]
 800862e:	ea41 2104 	orr.w	r1, r1, r4, lsl #8
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
            
  /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
  tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
 8008632:	686c      	ldr	r4, [r5, #4]
 8008634:	0412      	lsls	r2, r2, #16
            FSMC_NANDInitStruct->FSMC_ECCPageSize |
            (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
            (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);
            
  /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
  tmppmem = (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
 8008636:	4301      	orrs	r1, r0
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
            
  /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
  tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
 8008638:	6828      	ldr	r0, [r5, #0]
            FSMC_NANDInitStruct->FSMC_ECCPageSize |
            (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
            (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);
            
  /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
  tmppmem = (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
 800863a:	68ff      	ldr	r7, [r7, #12]
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
            
  /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
  tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
 800863c:	68ed      	ldr	r5, [r5, #12]
            (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
            (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
            (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);
  
  if(FSMC_NANDInitStruct->FSMC_Bank == FSMC_Bank2_NAND)
 800863e:	2e10      	cmp	r6, #16
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
            
  /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
  tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
 8008640:	ea42 2404 	orr.w	r4, r2, r4, lsl #8
 8008644:	ea44 0200 	orr.w	r2, r4, r0
            (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);
  
  if(FSMC_NANDInitStruct->FSMC_Bank == FSMC_Bank2_NAND)
  {
    /* FSMC_Bank2_NAND registers configuration */
    FSMC_Bank2->PCR2 = tmppcr;
 8008648:	bf0c      	ite	eq
 800864a:	4806      	ldreq	r0, [pc, #24]	; (8008664 <FSMC_NANDInit+0x64>)
    FSMC_Bank2->PATT2 = tmppatt;
  }
  else
  {
    /* FSMC_Bank3_NAND registers configuration */
    FSMC_Bank3->PCR3 = tmppcr;
 800864c:	4806      	ldrne	r0, [pc, #24]	; (8008668 <FSMC_NANDInit+0x68>)
  assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
  assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
  assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
  
  /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */
  tmppcr = (uint32_t)FSMC_NANDInitStruct->FSMC_Waitfeature |
 800864e:	ea43 334e 	orr.w	r3, r3, lr, lsl #13
            FSMC_NANDInitStruct->FSMC_ECCPageSize |
            (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
            (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);
            
  /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
  tmppmem = (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
 8008652:	ea41 6107 	orr.w	r1, r1, r7, lsl #24
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
            (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
            
  /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
  tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
 8008656:	ea42 6205 	orr.w	r2, r2, r5, lsl #24
    FSMC_Bank2->PATT2 = tmppatt;
  }
  else
  {
    /* FSMC_Bank3_NAND registers configuration */
    FSMC_Bank3->PCR3 = tmppcr;
 800865a:	6003      	str	r3, [r0, #0]
    FSMC_Bank3->PMEM3 = tmppmem;
 800865c:	6081      	str	r1, [r0, #8]
    FSMC_Bank3->PATT3 = tmppatt;
 800865e:	60c2      	str	r2, [r0, #12]
 8008660:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8008662:	bf00      	nop
 8008664:	a0000060 	.word	0xa0000060
 8008668:	a0000080 	.word	0xa0000080

0800866c <FSMC_NANDStructInit>:
  * @param  FSMC_NANDInitStruct: pointer to a FSMC_NANDInitTypeDef structure which
  *         will be initialized.
  * @retval None
  */
void FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
{ 
 800866c:	b430      	push	{r4, r5}
  FSMC_NANDInitStruct->FSMC_TARSetupTime = 0x0;
  FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
  FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
  FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
  FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
  FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
 800866e:	6a01      	ldr	r1, [r0, #32]
  FSMC_NANDInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
  FSMC_NANDInitStruct->FSMC_ECC = FSMC_ECC_Disable;
  FSMC_NANDInitStruct->FSMC_ECCPageSize = FSMC_ECCPageSize_256Bytes;
  FSMC_NANDInitStruct->FSMC_TCLRSetupTime = 0x0;
  FSMC_NANDInitStruct->FSMC_TARSetupTime = 0x0;
  FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
 8008670:	69c4      	ldr	r4, [r0, #28]
 8008672:	23fc      	movs	r3, #252	; 0xfc
  */
void FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
{ 
  /* Reset NAND Init structure parameters values */
  FSMC_NANDInitStruct->FSMC_Bank = FSMC_Bank2_NAND;
  FSMC_NANDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
 8008674:	2200      	movs	r2, #0
  * @retval None
  */
void FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
{ 
  /* Reset NAND Init structure parameters values */
  FSMC_NANDInitStruct->FSMC_Bank = FSMC_Bank2_NAND;
 8008676:	2510      	movs	r5, #16
 8008678:	6005      	str	r5, [r0, #0]
  FSMC_NANDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
 800867a:	6042      	str	r2, [r0, #4]
  FSMC_NANDInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
 800867c:	6082      	str	r2, [r0, #8]
  FSMC_NANDInitStruct->FSMC_ECC = FSMC_ECC_Disable;
 800867e:	60c2      	str	r2, [r0, #12]
  FSMC_NANDInitStruct->FSMC_ECCPageSize = FSMC_ECCPageSize_256Bytes;
 8008680:	6102      	str	r2, [r0, #16]
  FSMC_NANDInitStruct->FSMC_TCLRSetupTime = 0x0;
 8008682:	6142      	str	r2, [r0, #20]
  FSMC_NANDInitStruct->FSMC_TARSetupTime = 0x0;
 8008684:	6182      	str	r2, [r0, #24]
  FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
 8008686:	6023      	str	r3, [r4, #0]
  FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
 8008688:	6063      	str	r3, [r4, #4]
  FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
 800868a:	60a3      	str	r3, [r4, #8]
  FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
 800868c:	60e3      	str	r3, [r4, #12]
  FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
 800868e:	600b      	str	r3, [r1, #0]
  FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
 8008690:	604b      	str	r3, [r1, #4]
  FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
 8008692:	608b      	str	r3, [r1, #8]
  FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	  
 8008694:	60cb      	str	r3, [r1, #12]
}
 8008696:	bc30      	pop	{r4, r5}
 8008698:	4770      	bx	lr
 800869a:	bf00      	nop

0800869c <FSMC_NANDCmd>:
void FSMC_NANDCmd(uint32_t FSMC_Bank, FunctionalState NewState)
{
  assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800869c:	b141      	cbz	r1, 80086b0 <FSMC_NANDCmd+0x14>
  {
    /* Enable the selected NAND Bank by setting the PBKEN bit in the PCRx register */
    if(FSMC_Bank == FSMC_Bank2_NAND)
 800869e:	2810      	cmp	r0, #16
    {
      FSMC_Bank2->PCR2 |= PCR_PBKEN_SET;
 80086a0:	bf0c      	ite	eq
 80086a2:	4a08      	ldreq	r2, [pc, #32]	; (80086c4 <FSMC_NANDCmd+0x28>)
    }
    else
    {
      FSMC_Bank3->PCR3 |= PCR_PBKEN_SET;
 80086a4:	4a08      	ldrne	r2, [pc, #32]	; (80086c8 <FSMC_NANDCmd+0x2c>)
 80086a6:	6813      	ldr	r3, [r2, #0]
 80086a8:	f043 0304 	orr.w	r3, r3, #4
 80086ac:	6013      	str	r3, [r2, #0]
 80086ae:	4770      	bx	lr
    }
  }
  else
  {
    /* Disable the selected NAND Bank by clearing the PBKEN bit in the PCRx register */
    if(FSMC_Bank == FSMC_Bank2_NAND)
 80086b0:	2810      	cmp	r0, #16
    {
      FSMC_Bank2->PCR2 &= PCR_PBKEN_RESET;
 80086b2:	bf0c      	ite	eq
 80086b4:	4a03      	ldreq	r2, [pc, #12]	; (80086c4 <FSMC_NANDCmd+0x28>)
    }
    else
    {
      FSMC_Bank3->PCR3 &= PCR_PBKEN_RESET;
 80086b6:	4a04      	ldrne	r2, [pc, #16]	; (80086c8 <FSMC_NANDCmd+0x2c>)
 80086b8:	4b04      	ldr	r3, [pc, #16]	; (80086cc <FSMC_NANDCmd+0x30>)
 80086ba:	6811      	ldr	r1, [r2, #0]
 80086bc:	400b      	ands	r3, r1
 80086be:	6013      	str	r3, [r2, #0]
 80086c0:	4770      	bx	lr
 80086c2:	bf00      	nop
 80086c4:	a0000060 	.word	0xa0000060
 80086c8:	a0000080 	.word	0xa0000080
 80086cc:	000ffffb 	.word	0x000ffffb

080086d0 <FSMC_NANDECCCmd>:
void FSMC_NANDECCCmd(uint32_t FSMC_Bank, FunctionalState NewState)
{
  assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80086d0:	b141      	cbz	r1, 80086e4 <FSMC_NANDECCCmd+0x14>
  {
    /* Enable the selected NAND Bank ECC function by setting the ECCEN bit in the PCRx register */
    if(FSMC_Bank == FSMC_Bank2_NAND)
 80086d2:	2810      	cmp	r0, #16
    {
      FSMC_Bank2->PCR2 |= PCR_ECCEN_SET;
 80086d4:	bf0c      	ite	eq
 80086d6:	4a08      	ldreq	r2, [pc, #32]	; (80086f8 <FSMC_NANDECCCmd+0x28>)
    }
    else
    {
      FSMC_Bank3->PCR3 |= PCR_ECCEN_SET;
 80086d8:	4a08      	ldrne	r2, [pc, #32]	; (80086fc <FSMC_NANDECCCmd+0x2c>)
 80086da:	6813      	ldr	r3, [r2, #0]
 80086dc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80086e0:	6013      	str	r3, [r2, #0]
 80086e2:	4770      	bx	lr
    }
  }
  else
  {
    /* Disable the selected NAND Bank ECC function by clearing the ECCEN bit in the PCRx register */
    if(FSMC_Bank == FSMC_Bank2_NAND)
 80086e4:	2810      	cmp	r0, #16
    {
      FSMC_Bank2->PCR2 &= PCR_ECCEN_RESET;
 80086e6:	bf0c      	ite	eq
 80086e8:	4a03      	ldreq	r2, [pc, #12]	; (80086f8 <FSMC_NANDECCCmd+0x28>)
    }
    else
    {
      FSMC_Bank3->PCR3 &= PCR_ECCEN_RESET;
 80086ea:	4a04      	ldrne	r2, [pc, #16]	; (80086fc <FSMC_NANDECCCmd+0x2c>)
 80086ec:	4b04      	ldr	r3, [pc, #16]	; (8008700 <FSMC_NANDECCCmd+0x30>)
 80086ee:	6811      	ldr	r1, [r2, #0]
 80086f0:	400b      	ands	r3, r1
 80086f2:	6013      	str	r3, [r2, #0]
 80086f4:	4770      	bx	lr
 80086f6:	bf00      	nop
 80086f8:	a0000060 	.word	0xa0000060
 80086fc:	a0000080 	.word	0xa0000080
 8008700:	000fffbf 	.word	0x000fffbf

08008704 <FSMC_GetECC>:
  */
uint32_t FSMC_GetECC(uint32_t FSMC_Bank)
{
  uint32_t eccval = 0x00000000;
  
  if(FSMC_Bank == FSMC_Bank2_NAND)
 8008704:	2810      	cmp	r0, #16
  {
    /* Get the ECCR2 register value */
    eccval = FSMC_Bank2->ECCR2;
 8008706:	bf0c      	ite	eq
 8008708:	4b01      	ldreq	r3, [pc, #4]	; (8008710 <FSMC_GetECC+0xc>)
  }
  else
  {
    /* Get the ECCR3 register value */
    eccval = FSMC_Bank3->ECCR3;
 800870a:	4b02      	ldrne	r3, [pc, #8]	; (8008714 <FSMC_GetECC+0x10>)
 800870c:	6958      	ldr	r0, [r3, #20]
  }
  /* Return the error correction code value */
  return(eccval);
}
 800870e:	4770      	bx	lr
 8008710:	a0000060 	.word	0xa0000060
 8008714:	a0000080 	.word	0xa0000080

08008718 <FSMC_PCCARDDeInit>:
  * @retval None
  */
void FSMC_PCCARDDeInit(void)
{
  /* Set the FSMC_Bank4 registers to their reset values */
  FSMC_Bank4->PCR4 = 0x00000018; 
 8008718:	4b05      	ldr	r3, [pc, #20]	; (8008730 <FSMC_PCCARDDeInit+0x18>)
  FSMC_Bank4->SR4 = 0x00000000;	
  FSMC_Bank4->PMEM4 = 0xFCFCFCFC;
 800871a:	f04f 32fc 	mov.w	r2, #4244438268	; 0xfcfcfcfc
  * @retval None
  */
void FSMC_PCCARDDeInit(void)
{
  /* Set the FSMC_Bank4 registers to their reset values */
  FSMC_Bank4->PCR4 = 0x00000018; 
 800871e:	2018      	movs	r0, #24
  FSMC_Bank4->SR4 = 0x00000000;	
 8008720:	2100      	movs	r1, #0
  * @retval None
  */
void FSMC_PCCARDDeInit(void)
{
  /* Set the FSMC_Bank4 registers to their reset values */
  FSMC_Bank4->PCR4 = 0x00000018; 
 8008722:	6018      	str	r0, [r3, #0]
  FSMC_Bank4->SR4 = 0x00000000;	
 8008724:	6059      	str	r1, [r3, #4]
  FSMC_Bank4->PMEM4 = 0xFCFCFCFC;
 8008726:	609a      	str	r2, [r3, #8]
  FSMC_Bank4->PATT4 = 0xFCFCFCFC;
 8008728:	60da      	str	r2, [r3, #12]
  FSMC_Bank4->PIO4 = 0xFCFCFCFC;
 800872a:	611a      	str	r2, [r3, #16]
 800872c:	4770      	bx	lr
 800872e:	bf00      	nop
 8008730:	a00000a0 	.word	0xa00000a0

08008734 <FSMC_PCCARDInit>:
  assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime));
  
  /* Set the PCR4 register value according to FSMC_PCCARDInitStruct parameters */
  FSMC_Bank4->PCR4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_Waitfeature |
                     FSMC_MemoryDataWidth_16b |  
                     (FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime << 9) |
 8008734:	6803      	ldr	r3, [r0, #0]
 8008736:	6841      	ldr	r1, [r0, #4]
  * @param  FSMC_PCCARDInitStruct : pointer to a FSMC_PCCARDInitTypeDef structure
  *         that contains the configuration information for the FSMC PCCARD Bank.                       
  * @retval None
  */
void FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
{
 8008738:	b430      	push	{r4, r5}
  assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime));
  
  /* Set the PCR4 register value according to FSMC_PCCARDInitStruct parameters */
  FSMC_Bank4->PCR4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_Waitfeature |
                     FSMC_MemoryDataWidth_16b |  
                     (FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime << 9) |
 800873a:	f043 0210 	orr.w	r2, r3, #16
 800873e:	6884      	ldr	r4, [r0, #8]
 8008740:	ea42 2341 	orr.w	r3, r2, r1, lsl #9
  assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime));
  assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime));
  assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime));
  
  /* Set the PCR4 register value according to FSMC_PCCARDInitStruct parameters */
  FSMC_Bank4->PCR4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_Waitfeature |
 8008744:	4914      	ldr	r1, [pc, #80]	; (8008798 <FSMC_PCCARDInit+0x64>)
                     FSMC_MemoryDataWidth_16b |  
                     (FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime << 9) |
 8008746:	ea43 3344 	orr.w	r3, r3, r4, lsl #13
                     (FSMC_PCCARDInitStruct->FSMC_TARSetupTime << 13);
            
  /* Set PMEM4 register value according to FSMC_CommonSpaceTimingStructure parameters */
  FSMC_Bank4->PMEM4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
 800874a:	68c4      	ldr	r4, [r0, #12]
  assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime));
  assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime));
  assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime));
  
  /* Set the PCR4 register value according to FSMC_PCCARDInitStruct parameters */
  FSMC_Bank4->PCR4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_Waitfeature |
 800874c:	600b      	str	r3, [r1, #0]
                     (FSMC_PCCARDInitStruct->FSMC_TARSetupTime << 13);
            
  /* Set PMEM4 register value according to FSMC_CommonSpaceTimingStructure parameters */
  FSMC_Bank4->PMEM4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
 800874e:	68a2      	ldr	r2, [r4, #8]
 8008750:	6865      	ldr	r5, [r4, #4]
 8008752:	0413      	lsls	r3, r2, #16
 8008754:	6822      	ldr	r2, [r4, #0]
 8008756:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
 800875a:	68e4      	ldr	r4, [r4, #12]
 800875c:	4313      	orrs	r3, r2
 800875e:	ea43 6304 	orr.w	r3, r3, r4, lsl #24
                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
            
  /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */
  FSMC_Bank4->PATT4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
 8008762:	6904      	ldr	r4, [r0, #16]
                     FSMC_MemoryDataWidth_16b |  
                     (FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime << 9) |
                     (FSMC_PCCARDInitStruct->FSMC_TARSetupTime << 13);
            
  /* Set PMEM4 register value according to FSMC_CommonSpaceTimingStructure parameters */
  FSMC_Bank4->PMEM4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
 8008764:	608b      	str	r3, [r1, #8]
                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
            
  /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */
  FSMC_Bank4->PATT4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
 8008766:	68a2      	ldr	r2, [r4, #8]
 8008768:	6865      	ldr	r5, [r4, #4]
 800876a:	0413      	lsls	r3, r2, #16
 800876c:	6822      	ldr	r2, [r4, #0]
 800876e:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
 8008772:	68e4      	ldr	r4, [r4, #12]
 8008774:	4313      	orrs	r3, r2
                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);	
            
  /* Set PIO4 register value according to FSMC_IOSpaceTimingStructure parameters */
  FSMC_Bank4->PIO4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime |
 8008776:	6940      	ldr	r0, [r0, #20]
                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
            
  /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */
  FSMC_Bank4->PATT4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
 8008778:	ea43 6304 	orr.w	r3, r3, r4, lsl #24
                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
                      (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
            
  /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */
  FSMC_Bank4->PATT4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
 800877c:	60cb      	str	r3, [r1, #12]
                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);	
            
  /* Set PIO4 register value according to FSMC_IOSpaceTimingStructure parameters */
  FSMC_Bank4->PIO4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime |
                     (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
                     (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
 800877e:	6882      	ldr	r2, [r0, #8]
 8008780:	6844      	ldr	r4, [r0, #4]
 8008782:	0413      	lsls	r3, r2, #16
 8008784:	6802      	ldr	r2, [r0, #0]
 8008786:	ea43 2304 	orr.w	r3, r3, r4, lsl #8
 800878a:	68c0      	ldr	r0, [r0, #12]
 800878c:	4313      	orrs	r3, r2
 800878e:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
                      (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);	
            
  /* Set PIO4 register value according to FSMC_IOSpaceTimingStructure parameters */
  FSMC_Bank4->PIO4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime |
 8008792:	610b      	str	r3, [r1, #16]
                     (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
                     (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
                     (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime << 24);             
}
 8008794:	bc30      	pop	{r4, r5}
 8008796:	4770      	bx	lr
 8008798:	a00000a0 	.word	0xa00000a0

0800879c <FSMC_PCCARDStructInit>:
  * @param  FSMC_PCCARDInitStruct: pointer to a FSMC_PCCARDInitTypeDef structure
  *         which will be initialized.
  * @retval None
  */
void FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
{
 800879c:	b430      	push	{r4, r5}
  FSMC_PCCARDInitStruct->FSMC_TARSetupTime = 0x0;
  FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
  FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
  FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
  FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
  FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
 800879e:	6901      	ldr	r1, [r0, #16]
{
  /* Reset PCCARD Init structure parameters values */
  FSMC_PCCARDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
  FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime = 0x0;
  FSMC_PCCARDInitStruct->FSMC_TARSetupTime = 0x0;
  FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
 80087a0:	68c4      	ldr	r4, [r0, #12]
  FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
  FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
  FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
  FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
  FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	
  FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime = 0xFC;
 80087a2:	6942      	ldr	r2, [r0, #20]
{
  /* Reset PCCARD Init structure parameters values */
  FSMC_PCCARDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
  FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime = 0x0;
  FSMC_PCCARDInitStruct->FSMC_TARSetupTime = 0x0;
  FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
 80087a4:	23fc      	movs	r3, #252	; 0xfc
  * @retval None
  */
void FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
{
  /* Reset PCCARD Init structure parameters values */
  FSMC_PCCARDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
 80087a6:	2500      	movs	r5, #0
 80087a8:	6005      	str	r5, [r0, #0]
  FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime = 0x0;
 80087aa:	6045      	str	r5, [r0, #4]
  FSMC_PCCARDInitStruct->FSMC_TARSetupTime = 0x0;
 80087ac:	6085      	str	r5, [r0, #8]
  FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
 80087ae:	6023      	str	r3, [r4, #0]
  FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
 80087b0:	6063      	str	r3, [r4, #4]
  FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
 80087b2:	60a3      	str	r3, [r4, #8]
  FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
 80087b4:	60e3      	str	r3, [r4, #12]
  FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
 80087b6:	600b      	str	r3, [r1, #0]
  FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
 80087b8:	604b      	str	r3, [r1, #4]
  FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
 80087ba:	608b      	str	r3, [r1, #8]
  FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	
 80087bc:	60cb      	str	r3, [r1, #12]
  FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime = 0xFC;
  FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
  FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
  FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
}
 80087be:	bc30      	pop	{r4, r5}
  FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
  FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
  FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
  FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
  FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	
  FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime = 0xFC;
 80087c0:	6013      	str	r3, [r2, #0]
  FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
 80087c2:	6053      	str	r3, [r2, #4]
  FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
 80087c4:	6093      	str	r3, [r2, #8]
  FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
 80087c6:	60d3      	str	r3, [r2, #12]
}
 80087c8:	4770      	bx	lr
 80087ca:	bf00      	nop

080087cc <FSMC_PCCARDCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the PCCARD Bank by setting the PBKEN bit in the PCR4 register */
    FSMC_Bank4->PCR4 |= PCR_PBKEN_SET;
 80087cc:	4a05      	ldr	r2, [pc, #20]	; (80087e4 <FSMC_PCCARDCmd+0x18>)
  */
void FSMC_PCCARDCmd(FunctionalState NewState)
{
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80087ce:	b920      	cbnz	r0, 80087da <FSMC_PCCARDCmd+0xe>
    FSMC_Bank4->PCR4 |= PCR_PBKEN_SET;
  }
  else
  {
    /* Disable the PCCARD Bank by clearing the PBKEN bit in the PCR4 register */
    FSMC_Bank4->PCR4 &= PCR_PBKEN_RESET;
 80087d0:	6811      	ldr	r1, [r2, #0]
 80087d2:	4b05      	ldr	r3, [pc, #20]	; (80087e8 <FSMC_PCCARDCmd+0x1c>)
 80087d4:	400b      	ands	r3, r1
 80087d6:	6013      	str	r3, [r2, #0]
 80087d8:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the PCCARD Bank by setting the PBKEN bit in the PCR4 register */
    FSMC_Bank4->PCR4 |= PCR_PBKEN_SET;
 80087da:	6813      	ldr	r3, [r2, #0]
 80087dc:	f043 0304 	orr.w	r3, r3, #4
 80087e0:	6013      	str	r3, [r2, #0]
 80087e2:	4770      	bx	lr
 80087e4:	a00000a0 	.word	0xa00000a0
 80087e8:	000ffffb 	.word	0x000ffffb

080087ec <FSMC_ITConfig>:
{
  assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
  assert_param(IS_FSMC_IT(FSMC_IT));	
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80087ec:	b152      	cbz	r2, 8008804 <FSMC_ITConfig+0x18>
  {
    /* Enable the selected FSMC_Bank2 interrupts */
    if(FSMC_Bank == FSMC_Bank2_NAND)
 80087ee:	2810      	cmp	r0, #16
 80087f0:	d01a      	beq.n	8008828 <FSMC_ITConfig+0x3c>
    {
      FSMC_Bank2->SR2 |= FSMC_IT;
    }
    /* Enable the selected FSMC_Bank3 interrupts */
    else if (FSMC_Bank == FSMC_Bank3_NAND)
 80087f2:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
    {
      FSMC_Bank3->SR3 |= FSMC_IT;
 80087f6:	bf0c      	ite	eq
 80087f8:	4a0e      	ldreq	r2, [pc, #56]	; (8008834 <FSMC_ITConfig+0x48>)
    }
    /* Enable the selected FSMC_Bank4 interrupts */
    else
    {
      FSMC_Bank4->SR4 |= FSMC_IT;    
 80087fa:	4a0f      	ldrne	r2, [pc, #60]	; (8008838 <FSMC_ITConfig+0x4c>)
 80087fc:	6853      	ldr	r3, [r2, #4]
 80087fe:	4319      	orrs	r1, r3
 8008800:	6051      	str	r1, [r2, #4]
 8008802:	4770      	bx	lr
    }
  }
  else
  {
    /* Disable the selected FSMC_Bank2 interrupts */
    if(FSMC_Bank == FSMC_Bank2_NAND)
 8008804:	2810      	cmp	r0, #16
 8008806:	d009      	beq.n	800881c <FSMC_ITConfig+0x30>
    {
      
      FSMC_Bank2->SR2 &= (uint32_t)~FSMC_IT;
    }
    /* Disable the selected FSMC_Bank3 interrupts */
    else if (FSMC_Bank == FSMC_Bank3_NAND)
 8008808:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
    {
      FSMC_Bank3->SR3 &= (uint32_t)~FSMC_IT;
 800880c:	bf0c      	ite	eq
 800880e:	4a09      	ldreq	r2, [pc, #36]	; (8008834 <FSMC_ITConfig+0x48>)
    }
    /* Disable the selected FSMC_Bank4 interrupts */
    else
    {
      FSMC_Bank4->SR4 &= (uint32_t)~FSMC_IT;    
 8008810:	4a09      	ldrne	r2, [pc, #36]	; (8008838 <FSMC_ITConfig+0x4c>)
 8008812:	6853      	ldr	r3, [r2, #4]
 8008814:	ea23 0101 	bic.w	r1, r3, r1
 8008818:	6051      	str	r1, [r2, #4]
 800881a:	4770      	bx	lr
  {
    /* Disable the selected FSMC_Bank2 interrupts */
    if(FSMC_Bank == FSMC_Bank2_NAND)
    {
      
      FSMC_Bank2->SR2 &= (uint32_t)~FSMC_IT;
 800881c:	4a07      	ldr	r2, [pc, #28]	; (800883c <FSMC_ITConfig+0x50>)
 800881e:	6853      	ldr	r3, [r2, #4]
 8008820:	ea23 0101 	bic.w	r1, r3, r1
 8008824:	6051      	str	r1, [r2, #4]
 8008826:	4770      	bx	lr
  if (NewState != DISABLE)
  {
    /* Enable the selected FSMC_Bank2 interrupts */
    if(FSMC_Bank == FSMC_Bank2_NAND)
    {
      FSMC_Bank2->SR2 |= FSMC_IT;
 8008828:	4a04      	ldr	r2, [pc, #16]	; (800883c <FSMC_ITConfig+0x50>)
 800882a:	6853      	ldr	r3, [r2, #4]
 800882c:	4319      	orrs	r1, r3
 800882e:	6051      	str	r1, [r2, #4]
 8008830:	4770      	bx	lr
 8008832:	bf00      	nop
 8008834:	a0000080 	.word	0xa0000080
 8008838:	a00000a0 	.word	0xa00000a0
 800883c:	a0000060 	.word	0xa0000060

08008840 <FSMC_GetFlagStatus>:
  
  /* Check the parameters */
  assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
  assert_param(IS_FSMC_GET_FLAG(FSMC_FLAG));
  
  if(FSMC_Bank == FSMC_Bank2_NAND)
 8008840:	2810      	cmp	r0, #16
 8008842:	d00a      	beq.n	800885a <FSMC_GetFlagStatus+0x1a>
  {
    tmpsr = FSMC_Bank2->SR2;
  }  
  else if(FSMC_Bank == FSMC_Bank3_NAND)
 8008844:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
  {
    tmpsr = FSMC_Bank3->SR3;
 8008848:	bf0c      	ite	eq
 800884a:	4b05      	ldreq	r3, [pc, #20]	; (8008860 <FSMC_GetFlagStatus+0x20>)
  }
  /* FSMC_Bank4_PCCARD*/
  else
  {
    tmpsr = FSMC_Bank4->SR4;
 800884c:	4b05      	ldrne	r3, [pc, #20]	; (8008864 <FSMC_GetFlagStatus+0x24>)
 800884e:	685b      	ldr	r3, [r3, #4]
  else
  {
    bitstatus = RESET;
  }
  /* Return the flag status */
  return bitstatus;
 8008850:	420b      	tst	r3, r1
}
 8008852:	bf14      	ite	ne
 8008854:	2001      	movne	r0, #1
 8008856:	2000      	moveq	r0, #0
 8008858:	4770      	bx	lr
  assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
  assert_param(IS_FSMC_GET_FLAG(FSMC_FLAG));
  
  if(FSMC_Bank == FSMC_Bank2_NAND)
  {
    tmpsr = FSMC_Bank2->SR2;
 800885a:	4b03      	ldr	r3, [pc, #12]	; (8008868 <FSMC_GetFlagStatus+0x28>)
 800885c:	685b      	ldr	r3, [r3, #4]
 800885e:	e7f7      	b.n	8008850 <FSMC_GetFlagStatus+0x10>
 8008860:	a0000080 	.word	0xa0000080
 8008864:	a00000a0 	.word	0xa00000a0
 8008868:	a0000060 	.word	0xa0000060

0800886c <FSMC_ClearFlag>:
{
 /* Check the parameters */
  assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
  assert_param(IS_FSMC_CLEAR_FLAG(FSMC_FLAG)) ;
    
  if(FSMC_Bank == FSMC_Bank2_NAND)
 800886c:	2810      	cmp	r0, #16
 800886e:	d009      	beq.n	8008884 <FSMC_ClearFlag+0x18>
  {
    FSMC_Bank2->SR2 &= ~FSMC_FLAG; 
  }  
  else if(FSMC_Bank == FSMC_Bank3_NAND)
 8008870:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
  {
    FSMC_Bank3->SR3 &= ~FSMC_FLAG;
 8008874:	bf0c      	ite	eq
 8008876:	4a06      	ldreq	r2, [pc, #24]	; (8008890 <FSMC_ClearFlag+0x24>)
  }
  /* FSMC_Bank4_PCCARD*/
  else
  {
    FSMC_Bank4->SR4 &= ~FSMC_FLAG;
 8008878:	4a06      	ldrne	r2, [pc, #24]	; (8008894 <FSMC_ClearFlag+0x28>)
 800887a:	6853      	ldr	r3, [r2, #4]
 800887c:	ea23 0101 	bic.w	r1, r3, r1
 8008880:	6051      	str	r1, [r2, #4]
 8008882:	4770      	bx	lr
  assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
  assert_param(IS_FSMC_CLEAR_FLAG(FSMC_FLAG)) ;
    
  if(FSMC_Bank == FSMC_Bank2_NAND)
  {
    FSMC_Bank2->SR2 &= ~FSMC_FLAG; 
 8008884:	4a04      	ldr	r2, [pc, #16]	; (8008898 <FSMC_ClearFlag+0x2c>)
 8008886:	6853      	ldr	r3, [r2, #4]
 8008888:	ea23 0101 	bic.w	r1, r3, r1
 800888c:	6051      	str	r1, [r2, #4]
 800888e:	4770      	bx	lr
 8008890:	a0000080 	.word	0xa0000080
 8008894:	a00000a0 	.word	0xa00000a0
 8008898:	a0000060 	.word	0xa0000060

0800889c <FSMC_GetITStatus>:
  
  /* Check the parameters */
  assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
  assert_param(IS_FSMC_GET_IT(FSMC_IT));
  
  if(FSMC_Bank == FSMC_Bank2_NAND)
 800889c:	2810      	cmp	r0, #16
 800889e:	d00e      	beq.n	80088be <FSMC_GetITStatus+0x22>
  {
    tmpsr = FSMC_Bank2->SR2;
  }  
  else if(FSMC_Bank == FSMC_Bank3_NAND)
 80088a0:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
  {
    tmpsr = FSMC_Bank3->SR3;
 80088a4:	bf0c      	ite	eq
 80088a6:	4b07      	ldreq	r3, [pc, #28]	; (80088c4 <FSMC_GetITStatus+0x28>)
  }
  /* FSMC_Bank4_PCCARD*/
  else
  {
    tmpsr = FSMC_Bank4->SR4;
 80088a8:	4b07      	ldrne	r3, [pc, #28]	; (80088c8 <FSMC_GetITStatus+0x2c>)
 80088aa:	685b      	ldr	r3, [r3, #4]
  } 
  
  itstatus = tmpsr & FSMC_IT;
  
  itenable = tmpsr & (FSMC_IT >> 3);
  if ((itstatus != (uint32_t)RESET)  && (itenable != (uint32_t)RESET))
 80088ac:	ea13 0001 	ands.w	r0, r3, r1
 80088b0:	d004      	beq.n	80088bc <FSMC_GetITStatus+0x20>
  {
    bitstatus = SET;
 80088b2:	ea13 03d1 	ands.w	r3, r3, r1, lsr #3
 80088b6:	bf14      	ite	ne
 80088b8:	2001      	movne	r0, #1
 80088ba:	2000      	moveq	r0, #0
  else
  {
    bitstatus = RESET;
  }
  return bitstatus; 
}
 80088bc:	4770      	bx	lr
  assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
  assert_param(IS_FSMC_GET_IT(FSMC_IT));
  
  if(FSMC_Bank == FSMC_Bank2_NAND)
  {
    tmpsr = FSMC_Bank2->SR2;
 80088be:	4b03      	ldr	r3, [pc, #12]	; (80088cc <FSMC_GetITStatus+0x30>)
 80088c0:	685b      	ldr	r3, [r3, #4]
 80088c2:	e7f3      	b.n	80088ac <FSMC_GetITStatus+0x10>
 80088c4:	a0000080 	.word	0xa0000080
 80088c8:	a00000a0 	.word	0xa00000a0
 80088cc:	a0000060 	.word	0xa0000060

080088d0 <FSMC_ClearITPendingBit>:
{
  /* Check the parameters */
  assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
  assert_param(IS_FSMC_IT(FSMC_IT));
    
  if(FSMC_Bank == FSMC_Bank2_NAND)
 80088d0:	2810      	cmp	r0, #16
 80088d2:	d009      	beq.n	80088e8 <FSMC_ClearITPendingBit+0x18>
  {
    FSMC_Bank2->SR2 &= ~(FSMC_IT >> 3); 
  }  
  else if(FSMC_Bank == FSMC_Bank3_NAND)
 80088d4:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
  {
    FSMC_Bank3->SR3 &= ~(FSMC_IT >> 3);
 80088d8:	bf0c      	ite	eq
 80088da:	4a06      	ldreq	r2, [pc, #24]	; (80088f4 <FSMC_ClearITPendingBit+0x24>)
  }
  /* FSMC_Bank4_PCCARD*/
  else
  {
    FSMC_Bank4->SR4 &= ~(FSMC_IT >> 3);
 80088dc:	4a06      	ldrne	r2, [pc, #24]	; (80088f8 <FSMC_ClearITPendingBit+0x28>)
 80088de:	6853      	ldr	r3, [r2, #4]
 80088e0:	ea23 01d1 	bic.w	r1, r3, r1, lsr #3
 80088e4:	6051      	str	r1, [r2, #4]
 80088e6:	4770      	bx	lr
  assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
  assert_param(IS_FSMC_IT(FSMC_IT));
    
  if(FSMC_Bank == FSMC_Bank2_NAND)
  {
    FSMC_Bank2->SR2 &= ~(FSMC_IT >> 3); 
 80088e8:	4a04      	ldr	r2, [pc, #16]	; (80088fc <FSMC_ClearITPendingBit+0x2c>)
 80088ea:	6853      	ldr	r3, [r2, #4]
 80088ec:	ea23 01d1 	bic.w	r1, r3, r1, lsr #3
 80088f0:	6051      	str	r1, [r2, #4]
 80088f2:	4770      	bx	lr
 80088f4:	a0000080 	.word	0xa0000080
 80088f8:	a00000a0 	.word	0xa00000a0
 80088fc:	a0000060 	.word	0xa0000060

08008900 <GPIO_DeInit>:
  * @note   By default, The GPIO pins are configured in input floating mode (except JTAG pins).
  * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
  * @retval None
  */
void GPIO_DeInit(GPIO_TypeDef* GPIOx)
{
 8008900:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  if (GPIOx == GPIOA)
 8008902:	4b3c      	ldr	r3, [pc, #240]	; (80089f4 <GPIO_DeInit+0xf4>)
 8008904:	4298      	cmp	r0, r3
 8008906:	d024      	beq.n	8008952 <GPIO_DeInit+0x52>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, DISABLE);
  }
  else if (GPIOx == GPIOB)
 8008908:	4b3b      	ldr	r3, [pc, #236]	; (80089f8 <GPIO_DeInit+0xf8>)
 800890a:	4298      	cmp	r0, r3
 800890c:	d02b      	beq.n	8008966 <GPIO_DeInit+0x66>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, DISABLE);
  }
  else if (GPIOx == GPIOC)
 800890e:	4b3b      	ldr	r3, [pc, #236]	; (80089fc <GPIO_DeInit+0xfc>)
 8008910:	4298      	cmp	r0, r3
 8008912:	d032      	beq.n	800897a <GPIO_DeInit+0x7a>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, DISABLE);
  }
  else if (GPIOx == GPIOD)
 8008914:	4b3a      	ldr	r3, [pc, #232]	; (8008a00 <GPIO_DeInit+0x100>)
 8008916:	4298      	cmp	r0, r3
 8008918:	d039      	beq.n	800898e <GPIO_DeInit+0x8e>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, DISABLE);
  }
  else if (GPIOx == GPIOE)
 800891a:	4b3a      	ldr	r3, [pc, #232]	; (8008a04 <GPIO_DeInit+0x104>)
 800891c:	4298      	cmp	r0, r3
 800891e:	d040      	beq.n	80089a2 <GPIO_DeInit+0xa2>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, DISABLE);
  }
  else if (GPIOx == GPIOF)
 8008920:	4b39      	ldr	r3, [pc, #228]	; (8008a08 <GPIO_DeInit+0x108>)
 8008922:	4298      	cmp	r0, r3
 8008924:	d047      	beq.n	80089b6 <GPIO_DeInit+0xb6>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, DISABLE);
  }
  else if (GPIOx == GPIOG)
 8008926:	4b39      	ldr	r3, [pc, #228]	; (8008a0c <GPIO_DeInit+0x10c>)
 8008928:	4298      	cmp	r0, r3
 800892a:	d04e      	beq.n	80089ca <GPIO_DeInit+0xca>
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, DISABLE);
  }
  else if (GPIOx == GPIOH)
 800892c:	4b38      	ldr	r3, [pc, #224]	; (8008a10 <GPIO_DeInit+0x110>)
 800892e:	4298      	cmp	r0, r3
 8008930:	d055      	beq.n	80089de <GPIO_DeInit+0xde>
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, DISABLE);
  }
  else
  {
    if (GPIOx == GPIOI)
 8008932:	4b38      	ldr	r3, [pc, #224]	; (8008a14 <GPIO_DeInit+0x114>)
 8008934:	4298      	cmp	r0, r3
 8008936:	d000      	beq.n	800893a <GPIO_DeInit+0x3a>
 8008938:	bd08      	pop	{r3, pc}
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
 800893a:	2101      	movs	r1, #1
 800893c:	f44f 7080 	mov.w	r0, #256	; 0x100
 8008940:	f000 faa8 	bl	8008e94 <RCC_AHB1PeriphResetCmd>
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
    }
  }
}
 8008944:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  else
  {
    if (GPIOx == GPIOI)
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
 8008948:	2100      	movs	r1, #0
 800894a:	f44f 7080 	mov.w	r0, #256	; 0x100
 800894e:	f000 baa1 	b.w	8008e94 <RCC_AHB1PeriphResetCmd>
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  if (GPIOx == GPIOA)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, ENABLE);
 8008952:	2101      	movs	r1, #1
 8008954:	4608      	mov	r0, r1
 8008956:	f000 fa9d 	bl	8008e94 <RCC_AHB1PeriphResetCmd>
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
    }
  }
}
 800895a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  if (GPIOx == GPIOA)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, DISABLE);
 800895e:	2100      	movs	r1, #0
 8008960:	2001      	movs	r0, #1
 8008962:	f000 ba97 	b.w	8008e94 <RCC_AHB1PeriphResetCmd>
  }
  else if (GPIOx == GPIOB)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, ENABLE);
 8008966:	2101      	movs	r1, #1
 8008968:	2002      	movs	r0, #2
 800896a:	f000 fa93 	bl	8008e94 <RCC_AHB1PeriphResetCmd>
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
    }
  }
}
 800896e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, DISABLE);
  }
  else if (GPIOx == GPIOB)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, DISABLE);
 8008972:	2100      	movs	r1, #0
 8008974:	2002      	movs	r0, #2
 8008976:	f000 ba8d 	b.w	8008e94 <RCC_AHB1PeriphResetCmd>
  }
  else if (GPIOx == GPIOC)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, ENABLE);
 800897a:	2101      	movs	r1, #1
 800897c:	2004      	movs	r0, #4
 800897e:	f000 fa89 	bl	8008e94 <RCC_AHB1PeriphResetCmd>
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
    }
  }
}
 8008982:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, DISABLE);
  }
  else if (GPIOx == GPIOC)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, DISABLE);
 8008986:	2100      	movs	r1, #0
 8008988:	2004      	movs	r0, #4
 800898a:	f000 ba83 	b.w	8008e94 <RCC_AHB1PeriphResetCmd>
  }
  else if (GPIOx == GPIOD)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, ENABLE);
 800898e:	2101      	movs	r1, #1
 8008990:	2008      	movs	r0, #8
 8008992:	f000 fa7f 	bl	8008e94 <RCC_AHB1PeriphResetCmd>
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
    }
  }
}
 8008996:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, DISABLE);
  }
  else if (GPIOx == GPIOD)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, DISABLE);
 800899a:	2100      	movs	r1, #0
 800899c:	2008      	movs	r0, #8
 800899e:	f000 ba79 	b.w	8008e94 <RCC_AHB1PeriphResetCmd>
  }
  else if (GPIOx == GPIOE)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, ENABLE);
 80089a2:	2101      	movs	r1, #1
 80089a4:	2010      	movs	r0, #16
 80089a6:	f000 fa75 	bl	8008e94 <RCC_AHB1PeriphResetCmd>
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
    }
  }
}
 80089aa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, DISABLE);
  }
  else if (GPIOx == GPIOE)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, DISABLE);
 80089ae:	2100      	movs	r1, #0
 80089b0:	2010      	movs	r0, #16
 80089b2:	f000 ba6f 	b.w	8008e94 <RCC_AHB1PeriphResetCmd>
  }
  else if (GPIOx == GPIOF)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, ENABLE);
 80089b6:	2101      	movs	r1, #1
 80089b8:	2020      	movs	r0, #32
 80089ba:	f000 fa6b 	bl	8008e94 <RCC_AHB1PeriphResetCmd>
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
    }
  }
}
 80089be:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, DISABLE);
  }
  else if (GPIOx == GPIOF)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, DISABLE);
 80089c2:	2100      	movs	r1, #0
 80089c4:	2020      	movs	r0, #32
 80089c6:	f000 ba65 	b.w	8008e94 <RCC_AHB1PeriphResetCmd>
  }
  else if (GPIOx == GPIOG)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, ENABLE);
 80089ca:	2101      	movs	r1, #1
 80089cc:	2040      	movs	r0, #64	; 0x40
 80089ce:	f000 fa61 	bl	8008e94 <RCC_AHB1PeriphResetCmd>
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
    }
  }
}
 80089d2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, DISABLE);
  }
  else if (GPIOx == GPIOG)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, DISABLE);
 80089d6:	2100      	movs	r1, #0
 80089d8:	2040      	movs	r0, #64	; 0x40
 80089da:	f000 ba5b 	b.w	8008e94 <RCC_AHB1PeriphResetCmd>
  }
  else if (GPIOx == GPIOH)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, ENABLE);
 80089de:	2101      	movs	r1, #1
 80089e0:	2080      	movs	r0, #128	; 0x80
 80089e2:	f000 fa57 	bl	8008e94 <RCC_AHB1PeriphResetCmd>
    {
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
      RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
    }
  }
}
 80089e6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, DISABLE);
  }
  else if (GPIOx == GPIOH)
  {
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, ENABLE);
    RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, DISABLE);
 80089ea:	2100      	movs	r1, #0
 80089ec:	2080      	movs	r0, #128	; 0x80
 80089ee:	f000 ba51 	b.w	8008e94 <RCC_AHB1PeriphResetCmd>
 80089f2:	bf00      	nop
 80089f4:	40020000 	.word	0x40020000
 80089f8:	40020400 	.word	0x40020400
 80089fc:	40020800 	.word	0x40020800
 8008a00:	40020c00 	.word	0x40020c00
 8008a04:	40021000 	.word	0x40021000
 8008a08:	40021400 	.word	0x40021400
 8008a0c:	40021800 	.word	0x40021800
 8008a10:	40021c00 	.word	0x40021c00
 8008a14:	40022000 	.word	0x40022000

08008a18 <GPIO_Init>:
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 8008a18:	2200      	movs	r2, #0
 8008a1a:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8008a1e:	4613      	mov	r3, r2
 8008a20:	f8d1 e000 	ldr.w	lr, [r1]
  {
    pos = ((uint32_t)0x01) << pinpos;
 8008a24:	2701      	movs	r7, #1
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 8008a26:	f04f 0c03 	mov.w	ip, #3
 8008a2a:	e004      	b.n	8008a36 <GPIO_Init+0x1e>
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8008a2c:	3301      	adds	r3, #1
 8008a2e:	2b10      	cmp	r3, #16
 8008a30:	f102 0202 	add.w	r2, r2, #2
 8008a34:	d029      	beq.n	8008a8a <GPIO_Init+0x72>
  {
    pos = ((uint32_t)0x01) << pinpos;
 8008a36:	fa07 f403 	lsl.w	r4, r7, r3
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
 8008a3a:	ea34 050e 	bics.w	r5, r4, lr
 8008a3e:	d1f5      	bne.n	8008a2c <GPIO_Init+0x14>
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 8008a40:	fa0c f602 	lsl.w	r6, ip, r2
 8008a44:	43f6      	mvns	r6, r6
 8008a46:	f8d0 8000 	ldr.w	r8, [r0]
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 8008a4a:	790d      	ldrb	r5, [r1, #4]
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 8008a4c:	ea08 0806 	and.w	r8, r8, r6
 8008a50:	f8c0 8000 	str.w	r8, [r0]
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 8008a54:	f8d0 8000 	ldr.w	r8, [r0]
 8008a58:	fa05 f902 	lsl.w	r9, r5, r2

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 8008a5c:	3d01      	subs	r5, #1
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 8008a5e:	ea49 0808 	orr.w	r8, r9, r8

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 8008a62:	2d01      	cmp	r5, #1
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;

    if (currentpin == pos)
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 8008a64:	f8c0 8000 	str.w	r8, [r0]

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 8008a68:	d911      	bls.n	8008a8e <GPIO_Init+0x76>
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 8008a6a:	68c4      	ldr	r4, [r0, #12]
 8008a6c:	fa0c f502 	lsl.w	r5, ip, r2
 8008a70:	ea24 0405 	bic.w	r4, r4, r5
 8008a74:	60c4      	str	r4, [r0, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 8008a76:	79cc      	ldrb	r4, [r1, #7]
 8008a78:	68c5      	ldr	r5, [r0, #12]
 8008a7a:	4094      	lsls	r4, r2
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8008a7c:	3301      	adds	r3, #1
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 8008a7e:	432c      	orrs	r4, r5
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8008a80:	2b10      	cmp	r3, #16
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 8008a82:	60c4      	str	r4, [r0, #12]
 8008a84:	f102 0202 	add.w	r2, r2, #2
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* -------------------------Configure the port pins---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8008a88:	d1d5      	bne.n	8008a36 <GPIO_Init+0x1e>
      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
    }
  }
}
 8008a8a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 8008a8e:	f8d0 8008 	ldr.w	r8, [r0, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 8008a92:	794d      	ldrb	r5, [r1, #5]
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 8008a94:	ea06 0608 	and.w	r6, r6, r8
 8008a98:	6086      	str	r6, [r0, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 8008a9a:	6886      	ldr	r6, [r0, #8]
 8008a9c:	4095      	lsls	r5, r2
 8008a9e:	4335      	orrs	r5, r6
 8008aa0:	6085      	str	r5, [r0, #8]

        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration*/
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
 8008aa2:	6846      	ldr	r6, [r0, #4]
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 8008aa4:	798d      	ldrb	r5, [r1, #6]

        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration*/
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
 8008aa6:	ea26 0404 	bic.w	r4, r6, r4
 8008aaa:	6044      	str	r4, [r0, #4]
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 8008aac:	6846      	ldr	r6, [r0, #4]
 8008aae:	fa05 f403 	lsl.w	r4, r5, r3
 8008ab2:	b2a4      	uxth	r4, r4
 8008ab4:	4334      	orrs	r4, r6
 8008ab6:	6044      	str	r4, [r0, #4]
 8008ab8:	e7d7      	b.n	8008a6a <GPIO_Init+0x52>
 8008aba:	bf00      	nop

08008abc <GPIO_StructInit>:
  * @retval None
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
 8008abc:	f64f 72ff 	movw	r2, #65535	; 0xffff
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
 8008ac0:	2300      	movs	r3, #0
  * @retval None
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
 8008ac2:	6002      	str	r2, [r0, #0]
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
 8008ac4:	7103      	strb	r3, [r0, #4]
  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
 8008ac6:	7143      	strb	r3, [r0, #5]
  GPIO_InitStruct->GPIO_OType = GPIO_OType_PP;
 8008ac8:	7183      	strb	r3, [r0, #6]
  GPIO_InitStruct->GPIO_PuPd = GPIO_PuPd_NOPULL;
 8008aca:	71c3      	strb	r3, [r0, #7]
 8008acc:	4770      	bx	lr
 8008ace:	bf00      	nop

08008ad0 <GPIO_PinLockConfig>:
  * @param  GPIO_Pin: specifies the port bit to be locked.
  *          This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 8008ad0:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0x00010000;
 8008ad2:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8008ad6:	9301      	str	r3, [sp, #4]

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  tmp |= GPIO_Pin;
 8008ad8:	9b01      	ldr	r3, [sp, #4]
 8008ada:	430b      	orrs	r3, r1
 8008adc:	9301      	str	r3, [sp, #4]
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 8008ade:	9b01      	ldr	r3, [sp, #4]
 8008ae0:	61c3      	str	r3, [r0, #28]
  /* Reset LCKK bit */
  GPIOx->LCKR =  GPIO_Pin;
 8008ae2:	61c1      	str	r1, [r0, #28]
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 8008ae4:	9b01      	ldr	r3, [sp, #4]
 8008ae6:	61c3      	str	r3, [r0, #28]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
 8008ae8:	69c3      	ldr	r3, [r0, #28]
 8008aea:	9301      	str	r3, [sp, #4]
  /* Read LCKK bit*/
  tmp = GPIOx->LCKR;
 8008aec:	69c3      	ldr	r3, [r0, #28]
 8008aee:	9301      	str	r3, [sp, #4]
}
 8008af0:	b002      	add	sp, #8
 8008af2:	4770      	bx	lr

08008af4 <GPIO_ReadInputDataBit>:

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
 8008af4:	6903      	ldr	r3, [r0, #16]
  }
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
  }
  return bitstatus;
 8008af6:	4219      	tst	r1, r3
}
 8008af8:	bf14      	ite	ne
 8008afa:	2001      	movne	r0, #1
 8008afc:	2000      	moveq	r0, #0
 8008afe:	4770      	bx	lr

08008b00 <GPIO_ReadInputData>:
uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  return ((uint16_t)GPIOx->IDR);
 8008b00:	6900      	ldr	r0, [r0, #16]
}
 8008b02:	b280      	uxth	r0, r0
 8008b04:	4770      	bx	lr
 8008b06:	bf00      	nop

08008b08 <GPIO_ReadOutputDataBit>:

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->ODR & GPIO_Pin) != (uint32_t)Bit_RESET)
 8008b08:	6943      	ldr	r3, [r0, #20]
  }
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
  }
  return bitstatus;
 8008b0a:	4219      	tst	r1, r3
}
 8008b0c:	bf14      	ite	ne
 8008b0e:	2001      	movne	r0, #1
 8008b10:	2000      	moveq	r0, #0
 8008b12:	4770      	bx	lr

08008b14 <GPIO_ReadOutputData>:
uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  return ((uint16_t)GPIOx->ODR);
 8008b14:	6940      	ldr	r0, [r0, #20]
}
 8008b16:	b280      	uxth	r0, r0
 8008b18:	4770      	bx	lr
 8008b1a:	bf00      	nop

08008b1c <GPIO_SetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->BSRRL = GPIO_Pin;
 8008b1c:	8301      	strh	r1, [r0, #24]
 8008b1e:	4770      	bx	lr

08008b20 <GPIO_ResetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->BSRRH = GPIO_Pin;
 8008b20:	8341      	strh	r1, [r0, #26]
 8008b22:	4770      	bx	lr

08008b24 <GPIO_WriteBit>:
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_BIT_ACTION(BitVal));

  if (BitVal != Bit_RESET)
 8008b24:	b90a      	cbnz	r2, 8008b2a <GPIO_WriteBit+0x6>
  {
    GPIOx->BSRRL = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRRH = GPIO_Pin ;
 8008b26:	8341      	strh	r1, [r0, #26]
 8008b28:	4770      	bx	lr
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_BIT_ACTION(BitVal));

  if (BitVal != Bit_RESET)
  {
    GPIOx->BSRRL = GPIO_Pin;
 8008b2a:	8301      	strh	r1, [r0, #24]
 8008b2c:	4770      	bx	lr
 8008b2e:	bf00      	nop

08008b30 <GPIO_Write>:
void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  GPIOx->ODR = PortVal;
 8008b30:	6141      	str	r1, [r0, #20]
 8008b32:	4770      	bx	lr

08008b34 <GPIO_ToggleBits>:
void GPIO_ToggleBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  GPIOx->ODR ^= GPIO_Pin;
 8008b34:	6943      	ldr	r3, [r0, #20]
 8008b36:	4059      	eors	r1, r3
 8008b38:	6141      	str	r1, [r0, #20]
 8008b3a:	4770      	bx	lr

08008b3c <GPIO_PinAFConfig>:
  *            @arg GPIO_AF_DCMI: Connect DCMI pins to AF13
  *            @arg GPIO_AF_EVENTOUT: Connect EVENTOUT pins to AF15
  * @retval None
  */
void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF)
{
 8008b3c:	08cb      	lsrs	r3, r1, #3
 8008b3e:	eb00 0083 	add.w	r0, r0, r3, lsl #2
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 8008b42:	f001 0107 	and.w	r1, r1, #7
  *            @arg GPIO_AF_DCMI: Connect DCMI pins to AF13
  *            @arg GPIO_AF_EVENTOUT: Connect EVENTOUT pins to AF15
  * @retval None
  */
void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF)
{
 8008b46:	b410      	push	{r4}
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 8008b48:	0089      	lsls	r1, r1, #2
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 8008b4a:	6a04      	ldr	r4, [r0, #32]
 8008b4c:	230f      	movs	r3, #15
 8008b4e:	408b      	lsls	r3, r1
 8008b50:	ea24 0303 	bic.w	r3, r4, r3
 8008b54:	6203      	str	r3, [r0, #32]
  temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
 8008b56:	6a03      	ldr	r3, [r0, #32]
 8008b58:	408a      	lsls	r2, r1
 8008b5a:	ea42 0103 	orr.w	r1, r2, r3
  GPIOx->AFR[GPIO_PinSource >> 0x03] = temp_2;
 8008b5e:	6201      	str	r1, [r0, #32]
}
 8008b60:	bc10      	pop	{r4}
 8008b62:	4770      	bx	lr

08008b64 <RCC_DeInit>:
  * @retval None
  */
void RCC_DeInit(void)
{
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8008b64:	4b0a      	ldr	r3, [pc, #40]	; (8008b90 <RCC_DeInit+0x2c>)

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8008b66:	2100      	movs	r1, #0
  * @retval None
  */
void RCC_DeInit(void)
{
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8008b68:	681a      	ldr	r2, [r3, #0]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 8008b6a:	480a      	ldr	r0, [pc, #40]	; (8008b94 <RCC_DeInit+0x30>)
  * @retval None
  */
void RCC_DeInit(void)
{
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8008b6c:	f042 0201 	orr.w	r2, r2, #1
 8008b70:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8008b72:	6099      	str	r1, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8008b74:	681a      	ldr	r2, [r3, #0]
 8008b76:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 8008b7a:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8008b7e:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 8008b80:	6058      	str	r0, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8008b82:	681a      	ldr	r2, [r3, #0]
 8008b84:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8008b88:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 8008b8a:	60d9      	str	r1, [r3, #12]
 8008b8c:	4770      	bx	lr
 8008b8e:	bf00      	nop
 8008b90:	40023800 	.word	0x40023800
 8008b94:	24003010 	.word	0x24003010

08008b98 <RCC_HSEConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));

  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE_OFF;
 8008b98:	4b02      	ldr	r3, [pc, #8]	; (8008ba4 <RCC_HSEConfig+0xc>)
 8008b9a:	2200      	movs	r2, #0
 8008b9c:	701a      	strb	r2, [r3, #0]

  /* Set the new HSE configuration -------------------------------------------*/
  *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE;
 8008b9e:	7018      	strb	r0, [r3, #0]
 8008ba0:	4770      	bx	lr
 8008ba2:	bf00      	nop
 8008ba4:	40023802 	.word	0x40023802

08008ba8 <RCC_WaitForHSEStartUp>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: HSE oscillator is stable and ready to use
  *          - ERROR: HSE oscillator not yet ready
  */
ErrorStatus RCC_WaitForHSEStartUp(void)
{
 8008ba8:	b082      	sub	sp, #8
  __IO uint32_t startupcounter = 0;
 8008baa:	2300      	movs	r3, #0

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
  if (tmp == 1)               /* The flag to check is in CR register */
  {
    statusreg = RCC->CR;
 8008bac:	4a0a      	ldr	r2, [pc, #40]	; (8008bd8 <RCC_WaitForHSEStartUp+0x30>)
  *          - SUCCESS: HSE oscillator is stable and ready to use
  *          - ERROR: HSE oscillator not yet ready
  */
ErrorStatus RCC_WaitForHSEStartUp(void)
{
  __IO uint32_t startupcounter = 0;
 8008bae:	9301      	str	r3, [sp, #4]
 8008bb0:	e002      	b.n	8008bb8 <RCC_WaitForHSEStartUp+0x10>
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    hsestatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
    startupcounter++;
  } while((startupcounter != HSE_STARTUP_TIMEOUT) && (hsestatus == RESET));
 8008bb2:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 8008bb6:	d008      	beq.n	8008bca <RCC_WaitForHSEStartUp+0x22>

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
  if (tmp == 1)               /* The flag to check is in CR register */
  {
    statusreg = RCC->CR;
 8008bb8:	6813      	ldr	r3, [r2, #0]
    statusreg = RCC->CSR;
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_MASK;
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 8008bba:	f413 3f00 	tst.w	r3, #131072	; 0x20000
  FlagStatus hsestatus = RESET;
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    hsestatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
    startupcounter++;
 8008bbe:	9b01      	ldr	r3, [sp, #4]
 8008bc0:	f103 0301 	add.w	r3, r3, #1
 8008bc4:	9301      	str	r3, [sp, #4]
  } while((startupcounter != HSE_STARTUP_TIMEOUT) && (hsestatus == RESET));
 8008bc6:	9b01      	ldr	r3, [sp, #4]
    statusreg = RCC->CSR;
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_MASK;
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 8008bc8:	d0f3      	beq.n	8008bb2 <RCC_WaitForHSEStartUp+0xa>

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
  if (tmp == 1)               /* The flag to check is in CR register */
  {
    statusreg = RCC->CR;
 8008bca:	4b03      	ldr	r3, [pc, #12]	; (8008bd8 <RCC_WaitForHSEStartUp+0x30>)
 8008bcc:	6818      	ldr	r0, [r3, #0]
  }
  else
  {
    status = ERROR;
  }
  return (status);
 8008bce:	f3c0 4040 	ubfx	r0, r0, #17, #1
}
 8008bd2:	b002      	add	sp, #8
 8008bd4:	4770      	bx	lr
 8008bd6:	bf00      	nop
 8008bd8:	40023800 	.word	0x40023800

08008bdc <RCC_AdjustHSICalibrationValue>:
{
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));

  tmpreg = RCC->CR;
 8008bdc:	4a03      	ldr	r2, [pc, #12]	; (8008bec <RCC_AdjustHSICalibrationValue+0x10>)
 8008bde:	6813      	ldr	r3, [r2, #0]

  /* Clear HSITRIM[4:0] bits */
  tmpreg &= ~RCC_CR_HSITRIM;
 8008be0:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8

  /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
  tmpreg |= (uint32_t)HSICalibrationValue << 3;
 8008be4:	ea43 00c0 	orr.w	r0, r3, r0, lsl #3

  /* Store the new value */
  RCC->CR = tmpreg;
 8008be8:	6010      	str	r0, [r2, #0]
 8008bea:	4770      	bx	lr
 8008bec:	40023800 	.word	0x40023800

08008bf0 <RCC_HSICmd>:
void RCC_HSICmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
 8008bf0:	4b01      	ldr	r3, [pc, #4]	; (8008bf8 <RCC_HSICmd+0x8>)
 8008bf2:	6018      	str	r0, [r3, #0]
 8008bf4:	4770      	bx	lr
 8008bf6:	bf00      	nop
 8008bf8:	42470000 	.word	0x42470000

08008bfc <RCC_LSEConfig>:
  /* Check the parameters */
  assert_param(IS_RCC_LSE(RCC_LSE));

  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 8008bfc:	4b06      	ldr	r3, [pc, #24]	; (8008c18 <RCC_LSEConfig+0x1c>)
 8008bfe:	2200      	movs	r2, #0

  /* Reset LSEBYP bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;

  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch (RCC_LSE)
 8008c00:	2801      	cmp	r0, #1
  /* Check the parameters */
  assert_param(IS_RCC_LSE(RCC_LSE));

  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 8008c02:	701a      	strb	r2, [r3, #0]

  /* Reset LSEBYP bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 8008c04:	701a      	strb	r2, [r3, #0]

  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch (RCC_LSE)
 8008c06:	d005      	beq.n	8008c14 <RCC_LSEConfig+0x18>
 8008c08:	2804      	cmp	r0, #4
 8008c0a:	d102      	bne.n	8008c12 <RCC_LSEConfig+0x16>
      /* Set LSEON bit */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
      break;
    case RCC_LSE_Bypass:
      /* Set LSEBYP and LSEON bits */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
 8008c0c:	2205      	movs	r2, #5
 8008c0e:	701a      	strb	r2, [r3, #0]
 8008c10:	4770      	bx	lr
 8008c12:	4770      	bx	lr
  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch (RCC_LSE)
  {
    case RCC_LSE_ON:
      /* Set LSEON bit */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
 8008c14:	7018      	strb	r0, [r3, #0]
      break;
 8008c16:	4770      	bx	lr
 8008c18:	40023870 	.word	0x40023870

08008c1c <RCC_LSICmd>:
void RCC_LSICmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
 8008c1c:	4b01      	ldr	r3, [pc, #4]	; (8008c24 <RCC_LSICmd+0x8>)
 8008c1e:	6018      	str	r0, [r3, #0]
 8008c20:	4770      	bx	lr
 8008c22:	bf00      	nop
 8008c24:	42470e80 	.word	0x42470e80

08008c28 <RCC_PLLConfig>:
  *         correctly.
  *   
  * @retval None
  */
void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t PLLM, uint32_t PLLN, uint32_t PLLP, uint32_t PLLQ)
{
 8008c28:	b410      	push	{r4}
 8008c2a:	9c01      	ldr	r4, [sp, #4]
  assert_param(IS_RCC_PLLM_VALUE(PLLM));
  assert_param(IS_RCC_PLLN_VALUE(PLLN));
  assert_param(IS_RCC_PLLP_VALUE(PLLP));
  assert_param(IS_RCC_PLLQ_VALUE(PLLQ));

  RCC->PLLCFGR = PLLM | (PLLN << 6) | (((PLLP >> 1) -1) << 16) | (RCC_PLLSource) |
 8008c2c:	085b      	lsrs	r3, r3, #1
 8008c2e:	ea40 6004 	orr.w	r0, r0, r4, lsl #24
 8008c32:	4301      	orrs	r1, r0
 8008c34:	ea41 1082 	orr.w	r0, r1, r2, lsl #6
 8008c38:	3b01      	subs	r3, #1
 8008c3a:	4a03      	ldr	r2, [pc, #12]	; (8008c48 <RCC_PLLConfig+0x20>)
 8008c3c:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
 8008c40:	6050      	str	r0, [r2, #4]
                 (PLLQ << 24);
}
 8008c42:	bc10      	pop	{r4}
 8008c44:	4770      	bx	lr
 8008c46:	bf00      	nop
 8008c48:	40023800 	.word	0x40023800

08008c4c <RCC_PLLCmd>:
  */
void RCC_PLLCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
 8008c4c:	4b01      	ldr	r3, [pc, #4]	; (8008c54 <RCC_PLLCmd+0x8>)
 8008c4e:	6018      	str	r0, [r3, #0]
 8008c50:	4770      	bx	lr
 8008c52:	bf00      	nop
 8008c54:	42470060 	.word	0x42470060

08008c58 <RCC_PLLI2SConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_PLLI2SN_VALUE(PLLI2SN));
  assert_param(IS_RCC_PLLI2SR_VALUE(PLLI2SR));

  RCC->PLLI2SCFGR = (PLLI2SN << 6) | (PLLI2SR << 28);
 8008c58:	0709      	lsls	r1, r1, #28
 8008c5a:	4b03      	ldr	r3, [pc, #12]	; (8008c68 <RCC_PLLI2SConfig+0x10>)
 8008c5c:	ea41 1080 	orr.w	r0, r1, r0, lsl #6
 8008c60:	f8c3 0084 	str.w	r0, [r3, #132]	; 0x84
 8008c64:	4770      	bx	lr
 8008c66:	bf00      	nop
 8008c68:	40023800 	.word	0x40023800

08008c6c <RCC_PLLI2SCmd>:
  */
void RCC_PLLI2SCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_PLLI2SON_BB = (uint32_t)NewState;
 8008c6c:	4b01      	ldr	r3, [pc, #4]	; (8008c74 <RCC_PLLI2SCmd+0x8>)
 8008c6e:	6018      	str	r0, [r3, #0]
 8008c70:	4770      	bx	lr
 8008c72:	bf00      	nop
 8008c74:	42470068 	.word	0x42470068

08008c78 <RCC_ClockSecuritySystemCmd>:
  */
void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
 8008c78:	4b01      	ldr	r3, [pc, #4]	; (8008c80 <RCC_ClockSecuritySystemCmd+0x8>)
 8008c7a:	6018      	str	r0, [r3, #0]
 8008c7c:	4770      	bx	lr
 8008c7e:	bf00      	nop
 8008c80:	4247004c 	.word	0x4247004c

08008c84 <RCC_MCO1Config>:
  
  /* Check the parameters */
  assert_param(IS_RCC_MCO1SOURCE(RCC_MCO1Source));
  assert_param(IS_RCC_MCO1DIV(RCC_MCO1Div));  

  tmpreg = RCC->CFGR;
 8008c84:	4a03      	ldr	r2, [pc, #12]	; (8008c94 <RCC_MCO1Config+0x10>)
 8008c86:	6893      	ldr	r3, [r2, #8]
 8008c88:	f023 63ec 	bic.w	r3, r3, #123731968	; 0x7600000
 8008c8c:	4319      	orrs	r1, r3

  /* Clear MCO1[1:0] and MCO1PRE[2:0] bits */
  tmpreg &= CFGR_MCO1_RESET_MASK;

  /* Select MCO1 clock source and prescaler */
  tmpreg |= RCC_MCO1Source | RCC_MCO1Div;
 8008c8e:	4308      	orrs	r0, r1

  /* Store the new value */
  RCC->CFGR = tmpreg;  
 8008c90:	6090      	str	r0, [r2, #8]
 8008c92:	4770      	bx	lr
 8008c94:	40023800 	.word	0x40023800

08008c98 <RCC_MCO2Config>:
  
  /* Check the parameters */
  assert_param(IS_RCC_MCO2SOURCE(RCC_MCO2Source));
  assert_param(IS_RCC_MCO2DIV(RCC_MCO2Div));
  
  tmpreg = RCC->CFGR;
 8008c98:	4a03      	ldr	r2, [pc, #12]	; (8008ca8 <RCC_MCO2Config+0x10>)
 8008c9a:	6893      	ldr	r3, [r2, #8]
 8008c9c:	f023 4378 	bic.w	r3, r3, #4160749568	; 0xf8000000
 8008ca0:	4319      	orrs	r1, r3
  
  /* Clear MCO2 and MCO2PRE[2:0] bits */
  tmpreg &= CFGR_MCO2_RESET_MASK;

  /* Select MCO2 clock source and prescaler */
  tmpreg |= RCC_MCO2Source | RCC_MCO2Div;
 8008ca2:	4308      	orrs	r0, r1

  /* Store the new value */
  RCC->CFGR = tmpreg;  
 8008ca4:	6090      	str	r0, [r2, #8]
 8008ca6:	4770      	bx	lr
 8008ca8:	40023800 	.word	0x40023800

08008cac <RCC_SYSCLKConfig>:
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));

  tmpreg = RCC->CFGR;
 8008cac:	4a03      	ldr	r2, [pc, #12]	; (8008cbc <RCC_SYSCLKConfig+0x10>)
 8008cae:	6893      	ldr	r3, [r2, #8]

  /* Clear SW[1:0] bits */
  tmpreg &= ~RCC_CFGR_SW;
 8008cb0:	f023 0303 	bic.w	r3, r3, #3

  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
  tmpreg |= RCC_SYSCLKSource;
 8008cb4:	4318      	orrs	r0, r3

  /* Store the new value */
  RCC->CFGR = tmpreg;
 8008cb6:	6090      	str	r0, [r2, #8]
 8008cb8:	4770      	bx	lr
 8008cba:	bf00      	nop
 8008cbc:	40023800 	.word	0x40023800

08008cc0 <RCC_GetSYSCLKSource>:
  *              - 0x04: HSE used as system clock
  *              - 0x08: PLL used as system clock
  */
uint8_t RCC_GetSYSCLKSource(void)
{
  return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
 8008cc0:	4b02      	ldr	r3, [pc, #8]	; (8008ccc <RCC_GetSYSCLKSource+0xc>)
 8008cc2:	6898      	ldr	r0, [r3, #8]
}
 8008cc4:	f000 000c 	and.w	r0, r0, #12
 8008cc8:	4770      	bx	lr
 8008cca:	bf00      	nop
 8008ccc:	40023800 	.word	0x40023800

08008cd0 <RCC_HCLKConfig>:
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_HCLK(RCC_SYSCLK));

  tmpreg = RCC->CFGR;
 8008cd0:	4a03      	ldr	r2, [pc, #12]	; (8008ce0 <RCC_HCLKConfig+0x10>)
 8008cd2:	6893      	ldr	r3, [r2, #8]

  /* Clear HPRE[3:0] bits */
  tmpreg &= ~RCC_CFGR_HPRE;
 8008cd4:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0

  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
  tmpreg |= RCC_SYSCLK;
 8008cd8:	4318      	orrs	r0, r3

  /* Store the new value */
  RCC->CFGR = tmpreg;
 8008cda:	6090      	str	r0, [r2, #8]
 8008cdc:	4770      	bx	lr
 8008cde:	bf00      	nop
 8008ce0:	40023800 	.word	0x40023800

08008ce4 <RCC_PCLK1Config>:
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));

  tmpreg = RCC->CFGR;
 8008ce4:	4a03      	ldr	r2, [pc, #12]	; (8008cf4 <RCC_PCLK1Config+0x10>)
 8008ce6:	6893      	ldr	r3, [r2, #8]

  /* Clear PPRE1[2:0] bits */
  tmpreg &= ~RCC_CFGR_PPRE1;
 8008ce8:	f423 53e0 	bic.w	r3, r3, #7168	; 0x1c00

  /* Set PPRE1[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK;
 8008cec:	4318      	orrs	r0, r3

  /* Store the new value */
  RCC->CFGR = tmpreg;
 8008cee:	6090      	str	r0, [r2, #8]
 8008cf0:	4770      	bx	lr
 8008cf2:	bf00      	nop
 8008cf4:	40023800 	.word	0x40023800

08008cf8 <RCC_PCLK2Config>:
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));

  tmpreg = RCC->CFGR;
 8008cf8:	4a03      	ldr	r2, [pc, #12]	; (8008d08 <RCC_PCLK2Config+0x10>)
 8008cfa:	6893      	ldr	r3, [r2, #8]

  /* Clear PPRE2[2:0] bits */
  tmpreg &= ~RCC_CFGR_PPRE2;
 8008cfc:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000

  /* Set PPRE2[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK << 3;
 8008d00:	ea43 00c0 	orr.w	r0, r3, r0, lsl #3

  /* Store the new value */
  RCC->CFGR = tmpreg;
 8008d04:	6090      	str	r0, [r2, #8]
 8008d06:	4770      	bx	lr
 8008d08:	40023800 	.word	0x40023800

08008d0c <RCC_GetClocksFreq>:
  *         configuration based on this function will be incorrect.
  *    
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
 8008d0c:	b430      	push	{r4, r5}
  uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 8008d0e:	4d25      	ldr	r5, [pc, #148]	; (8008da4 <RCC_GetClocksFreq+0x98>)
 8008d10:	68ab      	ldr	r3, [r5, #8]

  switch (tmp)
 8008d12:	f003 030c 	and.w	r3, r3, #12
 8008d16:	2b04      	cmp	r3, #4
 8008d18:	d037      	beq.n	8008d8a <RCC_GetClocksFreq+0x7e>
 8008d1a:	2b08      	cmp	r3, #8
 8008d1c:	d01d      	beq.n	8008d5a <RCC_GetClocksFreq+0x4e>
 8008d1e:	b1cb      	cbz	r3, 8008d54 <RCC_GetClocksFreq+0x48>

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
      RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
      break;
    default:
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 8008d20:	4a21      	ldr	r2, [pc, #132]	; (8008da8 <RCC_GetClocksFreq+0x9c>)
      break;
 8008d22:	4613      	mov	r3, r2

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
      RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
      break;
    default:
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 8008d24:	6002      	str	r2, [r0, #0]
      break;
  }
  /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/

  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 8008d26:	4a1f      	ldr	r2, [pc, #124]	; (8008da4 <RCC_GetClocksFreq+0x98>)
  tmp = tmp >> 4;
  presc = APBAHBPrescTable[tmp];
 8008d28:	4920      	ldr	r1, [pc, #128]	; (8008dac <RCC_GetClocksFreq+0xa0>)
      break;
  }
  /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/

  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 8008d2a:	6894      	ldr	r4, [r2, #8]
  tmp = tmp >> 4;
 8008d2c:	f3c4 1403 	ubfx	r4, r4, #4, #4
  presc = APBAHBPrescTable[tmp];
 8008d30:	5d0c      	ldrb	r4, [r1, r4]
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 8008d32:	40e3      	lsrs	r3, r4
 8008d34:	6043      	str	r3, [r0, #4]

  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE1;
 8008d36:	6894      	ldr	r4, [r2, #8]
  tmp = tmp >> 10;
 8008d38:	f3c4 2482 	ubfx	r4, r4, #10, #3
  presc = APBAHBPrescTable[tmp];
 8008d3c:	5d0c      	ldrb	r4, [r1, r4]
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8008d3e:	fa23 f404 	lsr.w	r4, r3, r4
 8008d42:	6084      	str	r4, [r0, #8]

  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE2;
 8008d44:	6892      	ldr	r2, [r2, #8]
  tmp = tmp >> 13;
  presc = APBAHBPrescTable[tmp];
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
}
 8008d46:	bc30      	pop	{r4, r5}
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;

  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE2;
  tmp = tmp >> 13;
 8008d48:	f3c2 3242 	ubfx	r2, r2, #13, #3
  presc = APBAHBPrescTable[tmp];
 8008d4c:	5c8a      	ldrb	r2, [r1, r2]
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8008d4e:	40d3      	lsrs	r3, r2
 8008d50:	60c3      	str	r3, [r0, #12]
}
 8008d52:	4770      	bx	lr
  tmp = RCC->CFGR & RCC_CFGR_SWS;

  switch (tmp)
  {
    case 0x00:  /* HSI used as system clock source */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 8008d54:	4b14      	ldr	r3, [pc, #80]	; (8008da8 <RCC_GetClocksFreq+0x9c>)
 8008d56:	6003      	str	r3, [r0, #0]
      break;
 8008d58:	e7e5      	b.n	8008d26 <RCC_GetClocksFreq+0x1a>
    case 0x08:  /* PLL used as system clock  source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
         SYSCLK = PLL_VCO / PLLP
         */    
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
 8008d5a:	686b      	ldr	r3, [r5, #4]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8008d5c:	6869      	ldr	r1, [r5, #4]
      
      if (pllsource != 0)
 8008d5e:	025b      	lsls	r3, r3, #9

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
         SYSCLK = PLL_VCO / PLLP
         */    
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8008d60:	f001 023f 	and.w	r2, r1, #63	; 0x3f
      
      if (pllsource != 0)
 8008d64:	d414      	bmi.n	8008d90 <RCC_GetClocksFreq+0x84>
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
 8008d66:	4910      	ldr	r1, [pc, #64]	; (8008da8 <RCC_GetClocksFreq+0x9c>)
 8008d68:	686b      	ldr	r3, [r5, #4]
 8008d6a:	fbb1 f1f2 	udiv	r1, r1, r2
 8008d6e:	f3c3 1388 	ubfx	r3, r3, #6, #9
 8008d72:	fb01 f203 	mul.w	r2, r1, r3
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 8008d76:	4b0b      	ldr	r3, [pc, #44]	; (8008da4 <RCC_GetClocksFreq+0x98>)
 8008d78:	685b      	ldr	r3, [r3, #4]
      RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
 8008d7a:	f3c3 4301 	ubfx	r3, r3, #16, #2
 8008d7e:	3301      	adds	r3, #1
 8008d80:	005b      	lsls	r3, r3, #1
 8008d82:	fbb2 f3f3 	udiv	r3, r2, r3
 8008d86:	6003      	str	r3, [r0, #0]
      break;
 8008d88:	e7cd      	b.n	8008d26 <RCC_GetClocksFreq+0x1a>
  {
    case 0x00:  /* HSI used as system clock source */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
      break;
    case 0x04:  /* HSE used as system clock  source */
      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
 8008d8a:	4b09      	ldr	r3, [pc, #36]	; (8008db0 <RCC_GetClocksFreq+0xa4>)
 8008d8c:	6003      	str	r3, [r0, #0]
      break;
 8008d8e:	e7ca      	b.n	8008d26 <RCC_GetClocksFreq+0x1a>
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
      
      if (pllsource != 0)
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 8008d90:	4c07      	ldr	r4, [pc, #28]	; (8008db0 <RCC_GetClocksFreq+0xa4>)
 8008d92:	686b      	ldr	r3, [r5, #4]
 8008d94:	fbb4 f1f2 	udiv	r1, r4, r2
 8008d98:	f3c3 1388 	ubfx	r3, r3, #6, #9
 8008d9c:	fb01 f203 	mul.w	r2, r1, r3
 8008da0:	e7e9      	b.n	8008d76 <RCC_GetClocksFreq+0x6a>
 8008da2:	bf00      	nop
 8008da4:	40023800 	.word	0x40023800
 8008da8:	00f42400 	.word	0x00f42400
 8008dac:	20000014 	.word	0x20000014
 8008db0:	016e3600 	.word	0x016e3600

08008db4 <RCC_RTCCLKConfig>:
  uint32_t tmpreg = 0;

  /* Check the parameters */
  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));

  if ((RCC_RTCCLKSource & 0x00000300) == 0x00000300)
 8008db4:	f400 7340 	and.w	r3, r0, #768	; 0x300
 8008db8:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8008dbc:	d109      	bne.n	8008dd2 <RCC_RTCCLKConfig+0x1e>
  { /* If HSE is selected as RTC clock source, configure HSE division factor for RTC clock */
    tmpreg = RCC->CFGR;
 8008dbe:	4908      	ldr	r1, [pc, #32]	; (8008de0 <RCC_RTCCLKConfig+0x2c>)

    /* Clear RTCPRE[4:0] bits */
    tmpreg &= ~RCC_CFGR_RTCPRE;

    /* Configure HSE division factor for RTC clock */
    tmpreg |= (RCC_RTCCLKSource & 0xFFFFCFF);
 8008dc0:	f020 4270 	bic.w	r2, r0, #4026531840	; 0xf0000000
  /* Check the parameters */
  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));

  if ((RCC_RTCCLKSource & 0x00000300) == 0x00000300)
  { /* If HSE is selected as RTC clock source, configure HSE division factor for RTC clock */
    tmpreg = RCC->CFGR;
 8008dc4:	688b      	ldr	r3, [r1, #8]

    /* Clear RTCPRE[4:0] bits */
    tmpreg &= ~RCC_CFGR_RTCPRE;

    /* Configure HSE division factor for RTC clock */
    tmpreg |= (RCC_RTCCLKSource & 0xFFFFCFF);
 8008dc6:	f422 7240 	bic.w	r2, r2, #768	; 0x300
  if ((RCC_RTCCLKSource & 0x00000300) == 0x00000300)
  { /* If HSE is selected as RTC clock source, configure HSE division factor for RTC clock */
    tmpreg = RCC->CFGR;

    /* Clear RTCPRE[4:0] bits */
    tmpreg &= ~RCC_CFGR_RTCPRE;
 8008dca:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000

    /* Configure HSE division factor for RTC clock */
    tmpreg |= (RCC_RTCCLKSource & 0xFFFFCFF);
 8008dce:	4313      	orrs	r3, r2

    /* Store the new value */
    RCC->CFGR = tmpreg;
 8008dd0:	608b      	str	r3, [r1, #8]
  }
    
  /* Select the RTC clock source */
  RCC->BDCR |= (RCC_RTCCLKSource & 0x00000FFF);
 8008dd2:	4a03      	ldr	r2, [pc, #12]	; (8008de0 <RCC_RTCCLKConfig+0x2c>)
 8008dd4:	f3c0 000b 	ubfx	r0, r0, #0, #12
 8008dd8:	6f13      	ldr	r3, [r2, #112]	; 0x70
 8008dda:	4318      	orrs	r0, r3
 8008ddc:	6710      	str	r0, [r2, #112]	; 0x70
 8008dde:	4770      	bx	lr
 8008de0:	40023800 	.word	0x40023800

08008de4 <RCC_RTCCLKCmd>:
void RCC_RTCCLKCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
 8008de4:	4b01      	ldr	r3, [pc, #4]	; (8008dec <RCC_RTCCLKCmd+0x8>)
 8008de6:	6018      	str	r0, [r3, #0]
 8008de8:	4770      	bx	lr
 8008dea:	bf00      	nop
 8008dec:	42470e3c 	.word	0x42470e3c

08008df0 <RCC_BackupResetCmd>:
  */
void RCC_BackupResetCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
 8008df0:	4b01      	ldr	r3, [pc, #4]	; (8008df8 <RCC_BackupResetCmd+0x8>)
 8008df2:	6018      	str	r0, [r3, #0]
 8008df4:	4770      	bx	lr
 8008df6:	bf00      	nop
 8008df8:	42470e40 	.word	0x42470e40

08008dfc <RCC_I2SCLKConfig>:
void RCC_I2SCLKConfig(uint32_t RCC_I2SCLKSource)
{
  /* Check the parameters */
  assert_param(IS_RCC_I2SCLK_SOURCE(RCC_I2SCLKSource));

  *(__IO uint32_t *) CFGR_I2SSRC_BB = RCC_I2SCLKSource;
 8008dfc:	4b01      	ldr	r3, [pc, #4]	; (8008e04 <RCC_I2SCLKConfig+0x8>)
 8008dfe:	6018      	str	r0, [r3, #0]
 8008e00:	4770      	bx	lr
 8008e02:	bf00      	nop
 8008e04:	4247015c 	.word	0x4247015c

08008e08 <RCC_AHB1PeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));

  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008e08:	b929      	cbnz	r1, 8008e16 <RCC_AHB1PeriphClockCmd+0xe>
  {
    RCC->AHB1ENR |= RCC_AHB1Periph;
  }
  else
  {
    RCC->AHB1ENR &= ~RCC_AHB1Periph;
 8008e0a:	4a05      	ldr	r2, [pc, #20]	; (8008e20 <RCC_AHB1PeriphClockCmd+0x18>)
 8008e0c:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8008e0e:	ea23 0000 	bic.w	r0, r3, r0
 8008e12:	6310      	str	r0, [r2, #48]	; 0x30
 8008e14:	4770      	bx	lr
  assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));

  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->AHB1ENR |= RCC_AHB1Periph;
 8008e16:	4b02      	ldr	r3, [pc, #8]	; (8008e20 <RCC_AHB1PeriphClockCmd+0x18>)
 8008e18:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8008e1a:	4310      	orrs	r0, r2
 8008e1c:	6318      	str	r0, [r3, #48]	; 0x30
 8008e1e:	4770      	bx	lr
 8008e20:	40023800 	.word	0x40023800

08008e24 <RCC_AHB2PeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8008e24:	b929      	cbnz	r1, 8008e32 <RCC_AHB2PeriphClockCmd+0xe>
  {
    RCC->AHB2ENR |= RCC_AHB2Periph;
  }
  else
  {
    RCC->AHB2ENR &= ~RCC_AHB2Periph;
 8008e26:	4a05      	ldr	r2, [pc, #20]	; (8008e3c <RCC_AHB2PeriphClockCmd+0x18>)
 8008e28:	6b53      	ldr	r3, [r2, #52]	; 0x34
 8008e2a:	ea23 0000 	bic.w	r0, r3, r0
 8008e2e:	6350      	str	r0, [r2, #52]	; 0x34
 8008e30:	4770      	bx	lr
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB2ENR |= RCC_AHB2Periph;
 8008e32:	4b02      	ldr	r3, [pc, #8]	; (8008e3c <RCC_AHB2PeriphClockCmd+0x18>)
 8008e34:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8008e36:	4310      	orrs	r0, r2
 8008e38:	6358      	str	r0, [r3, #52]	; 0x34
 8008e3a:	4770      	bx	lr
 8008e3c:	40023800 	.word	0x40023800

08008e40 <RCC_AHB3PeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8008e40:	b929      	cbnz	r1, 8008e4e <RCC_AHB3PeriphClockCmd+0xe>
  {
    RCC->AHB3ENR |= RCC_AHB3Periph;
  }
  else
  {
    RCC->AHB3ENR &= ~RCC_AHB3Periph;
 8008e42:	4a05      	ldr	r2, [pc, #20]	; (8008e58 <RCC_AHB3PeriphClockCmd+0x18>)
 8008e44:	6b93      	ldr	r3, [r2, #56]	; 0x38
 8008e46:	ea23 0000 	bic.w	r0, r3, r0
 8008e4a:	6390      	str	r0, [r2, #56]	; 0x38
 8008e4c:	4770      	bx	lr
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB3ENR |= RCC_AHB3Periph;
 8008e4e:	4b02      	ldr	r3, [pc, #8]	; (8008e58 <RCC_AHB3PeriphClockCmd+0x18>)
 8008e50:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8008e52:	4310      	orrs	r0, r2
 8008e54:	6398      	str	r0, [r3, #56]	; 0x38
 8008e56:	4770      	bx	lr
 8008e58:	40023800 	.word	0x40023800

08008e5c <RCC_APB1PeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8008e5c:	b929      	cbnz	r1, 8008e6a <RCC_APB1PeriphClockCmd+0xe>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
 8008e5e:	4a05      	ldr	r2, [pc, #20]	; (8008e74 <RCC_APB1PeriphClockCmd+0x18>)
 8008e60:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8008e62:	ea23 0000 	bic.w	r0, r3, r0
 8008e66:	6410      	str	r0, [r2, #64]	; 0x40
 8008e68:	4770      	bx	lr
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 8008e6a:	4b02      	ldr	r3, [pc, #8]	; (8008e74 <RCC_APB1PeriphClockCmd+0x18>)
 8008e6c:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8008e6e:	4310      	orrs	r0, r2
 8008e70:	6418      	str	r0, [r3, #64]	; 0x40
 8008e72:	4770      	bx	lr
 8008e74:	40023800 	.word	0x40023800

08008e78 <RCC_APB2PeriphClockCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8008e78:	b929      	cbnz	r1, 8008e86 <RCC_APB2PeriphClockCmd+0xe>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
 8008e7a:	4a05      	ldr	r2, [pc, #20]	; (8008e90 <RCC_APB2PeriphClockCmd+0x18>)
 8008e7c:	6c53      	ldr	r3, [r2, #68]	; 0x44
 8008e7e:	ea23 0000 	bic.w	r0, r3, r0
 8008e82:	6450      	str	r0, [r2, #68]	; 0x44
 8008e84:	4770      	bx	lr
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 8008e86:	4b02      	ldr	r3, [pc, #8]	; (8008e90 <RCC_APB2PeriphClockCmd+0x18>)
 8008e88:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8008e8a:	4310      	orrs	r0, r2
 8008e8c:	6458      	str	r0, [r3, #68]	; 0x44
 8008e8e:	4770      	bx	lr
 8008e90:	40023800 	.word	0x40023800

08008e94 <RCC_AHB1PeriphResetCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_RESET_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8008e94:	b929      	cbnz	r1, 8008ea2 <RCC_AHB1PeriphResetCmd+0xe>
  {
    RCC->AHB1RSTR |= RCC_AHB1Periph;
  }
  else
  {
    RCC->AHB1RSTR &= ~RCC_AHB1Periph;
 8008e96:	4a05      	ldr	r2, [pc, #20]	; (8008eac <RCC_AHB1PeriphResetCmd+0x18>)
 8008e98:	6913      	ldr	r3, [r2, #16]
 8008e9a:	ea23 0000 	bic.w	r0, r3, r0
 8008e9e:	6110      	str	r0, [r2, #16]
 8008ea0:	4770      	bx	lr
  assert_param(IS_RCC_AHB1_RESET_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB1RSTR |= RCC_AHB1Periph;
 8008ea2:	4b02      	ldr	r3, [pc, #8]	; (8008eac <RCC_AHB1PeriphResetCmd+0x18>)
 8008ea4:	691a      	ldr	r2, [r3, #16]
 8008ea6:	4310      	orrs	r0, r2
 8008ea8:	6118      	str	r0, [r3, #16]
 8008eaa:	4770      	bx	lr
 8008eac:	40023800 	.word	0x40023800

08008eb0 <RCC_AHB2PeriphResetCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8008eb0:	b929      	cbnz	r1, 8008ebe <RCC_AHB2PeriphResetCmd+0xe>
  {
    RCC->AHB2RSTR |= RCC_AHB2Periph;
  }
  else
  {
    RCC->AHB2RSTR &= ~RCC_AHB2Periph;
 8008eb2:	4a05      	ldr	r2, [pc, #20]	; (8008ec8 <RCC_AHB2PeriphResetCmd+0x18>)
 8008eb4:	6953      	ldr	r3, [r2, #20]
 8008eb6:	ea23 0000 	bic.w	r0, r3, r0
 8008eba:	6150      	str	r0, [r2, #20]
 8008ebc:	4770      	bx	lr
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB2RSTR |= RCC_AHB2Periph;
 8008ebe:	4b02      	ldr	r3, [pc, #8]	; (8008ec8 <RCC_AHB2PeriphResetCmd+0x18>)
 8008ec0:	695a      	ldr	r2, [r3, #20]
 8008ec2:	4310      	orrs	r0, r2
 8008ec4:	6158      	str	r0, [r3, #20]
 8008ec6:	4770      	bx	lr
 8008ec8:	40023800 	.word	0x40023800

08008ecc <RCC_AHB3PeriphResetCmd>:
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8008ecc:	b929      	cbnz	r1, 8008eda <RCC_AHB3PeriphResetCmd+0xe>
  {
    RCC->AHB3RSTR |= RCC_AHB3Periph;
  }
  else
  {
    RCC->AHB3RSTR &= ~RCC_AHB3Periph;
 8008ece:	4a05      	ldr	r2, [pc, #20]	; (8008ee4 <RCC_AHB3PeriphResetCmd+0x18>)
 8008ed0:	6993      	ldr	r3, [r2, #24]
 8008ed2:	ea23 0000 	bic.w	r0, r3, r0
 8008ed6:	6190      	str	r0, [r2, #24]
 8008ed8:	4770      	bx	lr
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHB3RSTR |= RCC_AHB3Periph;
 8008eda:	4b02      	ldr	r3, [pc, #8]	; (8008ee4 <RCC_AHB3PeriphResetCmd+0x18>)
 8008edc:	699a      	ldr	r2, [r3, #24]
 8008ede:	4310      	orrs	r0, r2
 8008ee0:	6198      	str	r0, [r3, #24]
 8008ee2:	4770      	bx	lr
 8008ee4:	40023800 	.word	0x40023800

08008ee8 <RCC_APB1PeriphResetCmd>:
void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008ee8:	b929      	cbnz	r1, 8008ef6 <RCC_APB1PeriphResetCmd+0xe>
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
  }
  else
  {
    RCC->APB1RSTR &= ~RCC_APB1Periph;
 8008eea:	4a05      	ldr	r2, [pc, #20]	; (8008f00 <RCC_APB1PeriphResetCmd+0x18>)
 8008eec:	6a13      	ldr	r3, [r2, #32]
 8008eee:	ea23 0000 	bic.w	r0, r3, r0
 8008ef2:	6210      	str	r0, [r2, #32]
 8008ef4:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
 8008ef6:	4b02      	ldr	r3, [pc, #8]	; (8008f00 <RCC_APB1PeriphResetCmd+0x18>)
 8008ef8:	6a1a      	ldr	r2, [r3, #32]
 8008efa:	4310      	orrs	r0, r2
 8008efc:	6218      	str	r0, [r3, #32]
 8008efe:	4770      	bx	lr
 8008f00:	40023800 	.word	0x40023800

08008f04 <RCC_APB2PeriphResetCmd>:
void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008f04:	b929      	cbnz	r1, 8008f12 <RCC_APB2PeriphResetCmd+0xe>
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
  }
  else
  {
    RCC->APB2RSTR &= ~RCC_APB2Periph;
 8008f06:	4a05      	ldr	r2, [pc, #20]	; (8008f1c <RCC_APB2PeriphResetCmd+0x18>)
 8008f08:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8008f0a:	ea23 0000 	bic.w	r0, r3, r0
 8008f0e:	6250      	str	r0, [r2, #36]	; 0x24
 8008f10:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
 8008f12:	4b02      	ldr	r3, [pc, #8]	; (8008f1c <RCC_APB2PeriphResetCmd+0x18>)
 8008f14:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8008f16:	4310      	orrs	r0, r2
 8008f18:	6258      	str	r0, [r3, #36]	; 0x24
 8008f1a:	4770      	bx	lr
 8008f1c:	40023800 	.word	0x40023800

08008f20 <RCC_AHB1PeriphClockLPModeCmd>:
void RCC_AHB1PeriphClockLPModeCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_LPMODE_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008f20:	b929      	cbnz	r1, 8008f2e <RCC_AHB1PeriphClockLPModeCmd+0xe>
  {
    RCC->AHB1LPENR |= RCC_AHB1Periph;
  }
  else
  {
    RCC->AHB1LPENR &= ~RCC_AHB1Periph;
 8008f22:	4a05      	ldr	r2, [pc, #20]	; (8008f38 <RCC_AHB1PeriphClockLPModeCmd+0x18>)
 8008f24:	6d13      	ldr	r3, [r2, #80]	; 0x50
 8008f26:	ea23 0000 	bic.w	r0, r3, r0
 8008f2a:	6510      	str	r0, [r2, #80]	; 0x50
 8008f2c:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_LPMODE_PERIPH(RCC_AHB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->AHB1LPENR |= RCC_AHB1Periph;
 8008f2e:	4b02      	ldr	r3, [pc, #8]	; (8008f38 <RCC_AHB1PeriphClockLPModeCmd+0x18>)
 8008f30:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8008f32:	4310      	orrs	r0, r2
 8008f34:	6518      	str	r0, [r3, #80]	; 0x50
 8008f36:	4770      	bx	lr
 8008f38:	40023800 	.word	0x40023800

08008f3c <RCC_AHB2PeriphClockLPModeCmd>:
void RCC_AHB2PeriphClockLPModeCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008f3c:	b929      	cbnz	r1, 8008f4a <RCC_AHB2PeriphClockLPModeCmd+0xe>
  {
    RCC->AHB2LPENR |= RCC_AHB2Periph;
  }
  else
  {
    RCC->AHB2LPENR &= ~RCC_AHB2Periph;
 8008f3e:	4a05      	ldr	r2, [pc, #20]	; (8008f54 <RCC_AHB2PeriphClockLPModeCmd+0x18>)
 8008f40:	6d53      	ldr	r3, [r2, #84]	; 0x54
 8008f42:	ea23 0000 	bic.w	r0, r3, r0
 8008f46:	6550      	str	r0, [r2, #84]	; 0x54
 8008f48:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->AHB2LPENR |= RCC_AHB2Periph;
 8008f4a:	4b02      	ldr	r3, [pc, #8]	; (8008f54 <RCC_AHB2PeriphClockLPModeCmd+0x18>)
 8008f4c:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8008f4e:	4310      	orrs	r0, r2
 8008f50:	6558      	str	r0, [r3, #84]	; 0x54
 8008f52:	4770      	bx	lr
 8008f54:	40023800 	.word	0x40023800

08008f58 <RCC_AHB3PeriphClockLPModeCmd>:
void RCC_AHB3PeriphClockLPModeCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008f58:	b929      	cbnz	r1, 8008f66 <RCC_AHB3PeriphClockLPModeCmd+0xe>
  {
    RCC->AHB3LPENR |= RCC_AHB3Periph;
  }
  else
  {
    RCC->AHB3LPENR &= ~RCC_AHB3Periph;
 8008f5a:	4a05      	ldr	r2, [pc, #20]	; (8008f70 <RCC_AHB3PeriphClockLPModeCmd+0x18>)
 8008f5c:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8008f5e:	ea23 0000 	bic.w	r0, r3, r0
 8008f62:	6590      	str	r0, [r2, #88]	; 0x58
 8008f64:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->AHB3LPENR |= RCC_AHB3Periph;
 8008f66:	4b02      	ldr	r3, [pc, #8]	; (8008f70 <RCC_AHB3PeriphClockLPModeCmd+0x18>)
 8008f68:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8008f6a:	4310      	orrs	r0, r2
 8008f6c:	6598      	str	r0, [r3, #88]	; 0x58
 8008f6e:	4770      	bx	lr
 8008f70:	40023800 	.word	0x40023800

08008f74 <RCC_APB1PeriphClockLPModeCmd>:
void RCC_APB1PeriphClockLPModeCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008f74:	b929      	cbnz	r1, 8008f82 <RCC_APB1PeriphClockLPModeCmd+0xe>
  {
    RCC->APB1LPENR |= RCC_APB1Periph;
  }
  else
  {
    RCC->APB1LPENR &= ~RCC_APB1Periph;
 8008f76:	4a05      	ldr	r2, [pc, #20]	; (8008f8c <RCC_APB1PeriphClockLPModeCmd+0x18>)
 8008f78:	6e13      	ldr	r3, [r2, #96]	; 0x60
 8008f7a:	ea23 0000 	bic.w	r0, r3, r0
 8008f7e:	6610      	str	r0, [r2, #96]	; 0x60
 8008f80:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB1LPENR |= RCC_APB1Periph;
 8008f82:	4b02      	ldr	r3, [pc, #8]	; (8008f8c <RCC_APB1PeriphClockLPModeCmd+0x18>)
 8008f84:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8008f86:	4310      	orrs	r0, r2
 8008f88:	6618      	str	r0, [r3, #96]	; 0x60
 8008f8a:	4770      	bx	lr
 8008f8c:	40023800 	.word	0x40023800

08008f90 <RCC_APB2PeriphClockLPModeCmd>:
void RCC_APB2PeriphClockLPModeCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008f90:	b929      	cbnz	r1, 8008f9e <RCC_APB2PeriphClockLPModeCmd+0xe>
  {
    RCC->APB2LPENR |= RCC_APB2Periph;
  }
  else
  {
    RCC->APB2LPENR &= ~RCC_APB2Periph;
 8008f92:	4a05      	ldr	r2, [pc, #20]	; (8008fa8 <RCC_APB2PeriphClockLPModeCmd+0x18>)
 8008f94:	6e53      	ldr	r3, [r2, #100]	; 0x64
 8008f96:	ea23 0000 	bic.w	r0, r3, r0
 8008f9a:	6650      	str	r0, [r2, #100]	; 0x64
 8008f9c:	4770      	bx	lr
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    RCC->APB2LPENR |= RCC_APB2Periph;
 8008f9e:	4b02      	ldr	r3, [pc, #8]	; (8008fa8 <RCC_APB2PeriphClockLPModeCmd+0x18>)
 8008fa0:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 8008fa2:	4310      	orrs	r0, r2
 8008fa4:	6658      	str	r0, [r3, #100]	; 0x64
 8008fa6:	4770      	bx	lr
 8008fa8:	40023800 	.word	0x40023800

08008fac <RCC_ITConfig>:
void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_RCC_IT(RCC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8008fac:	b929      	cbnz	r1, 8008fba <RCC_ITConfig+0xe>
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
  }
  else
  {
    /* Perform Byte access to RCC_CIR[14:8] bits to disable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
 8008fae:	4a05      	ldr	r2, [pc, #20]	; (8008fc4 <RCC_ITConfig+0x18>)
 8008fb0:	7813      	ldrb	r3, [r2, #0]
 8008fb2:	ea23 0000 	bic.w	r0, r3, r0
 8008fb6:	7010      	strb	r0, [r2, #0]
 8008fb8:	4770      	bx	lr
  assert_param(IS_RCC_IT(RCC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Perform Byte access to RCC_CIR[14:8] bits to enable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
 8008fba:	4b02      	ldr	r3, [pc, #8]	; (8008fc4 <RCC_ITConfig+0x18>)
 8008fbc:	781a      	ldrb	r2, [r3, #0]
 8008fbe:	4310      	orrs	r0, r2
 8008fc0:	7018      	strb	r0, [r3, #0]
 8008fc2:	4770      	bx	lr
 8008fc4:	4002380d 	.word	0x4002380d

08008fc8 <RCC_GetFlagStatus>:

  /* Check the parameters */
  assert_param(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
 8008fc8:	0943      	lsrs	r3, r0, #5
  if (tmp == 1)               /* The flag to check is in CR register */
 8008fca:	2b01      	cmp	r3, #1
 8008fcc:	d00b      	beq.n	8008fe6 <RCC_GetFlagStatus+0x1e>
  {
    statusreg = RCC->CR;
  }
  else if (tmp == 2)          /* The flag to check is in BDCR register */
 8008fce:	2b02      	cmp	r3, #2
  {
    statusreg = RCC->BDCR;
 8008fd0:	4b09      	ldr	r3, [pc, #36]	; (8008ff8 <RCC_GetFlagStatus+0x30>)
  else
  {
    bitstatus = RESET;
  }
  /* Return the flag status */
  return bitstatus;
 8008fd2:	f000 001f 	and.w	r0, r0, #31
  {
    statusreg = RCC->CR;
  }
  else if (tmp == 2)          /* The flag to check is in BDCR register */
  {
    statusreg = RCC->BDCR;
 8008fd6:	bf0c      	ite	eq
 8008fd8:	6f1b      	ldreq	r3, [r3, #112]	; 0x70
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
 8008fda:	6f5b      	ldrne	r3, [r3, #116]	; 0x74
  else
  {
    bitstatus = RESET;
  }
  /* Return the flag status */
  return bitstatus;
 8008fdc:	fa23 f000 	lsr.w	r0, r3, r0
}
 8008fe0:	f000 0001 	and.w	r0, r0, #1
 8008fe4:	4770      	bx	lr

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
  if (tmp == 1)               /* The flag to check is in CR register */
  {
    statusreg = RCC->CR;
 8008fe6:	4b04      	ldr	r3, [pc, #16]	; (8008ff8 <RCC_GetFlagStatus+0x30>)
  else
  {
    bitstatus = RESET;
  }
  /* Return the flag status */
  return bitstatus;
 8008fe8:	f000 001f 	and.w	r0, r0, #31

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
  if (tmp == 1)               /* The flag to check is in CR register */
  {
    statusreg = RCC->CR;
 8008fec:	681b      	ldr	r3, [r3, #0]
  else
  {
    bitstatus = RESET;
  }
  /* Return the flag status */
  return bitstatus;
 8008fee:	fa23 f000 	lsr.w	r0, r3, r0
}
 8008ff2:	f000 0001 	and.w	r0, r0, #1
 8008ff6:	4770      	bx	lr
 8008ff8:	40023800 	.word	0x40023800

08008ffc <RCC_ClearFlag>:
  * @retval None
  */
void RCC_ClearFlag(void)
{
  /* Set RMVF bit to clear the reset flags */
  RCC->CSR |= RCC_CSR_RMVF;
 8008ffc:	4a02      	ldr	r2, [pc, #8]	; (8009008 <RCC_ClearFlag+0xc>)
 8008ffe:	6f53      	ldr	r3, [r2, #116]	; 0x74
 8009000:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8009004:	6753      	str	r3, [r2, #116]	; 0x74
 8009006:	4770      	bx	lr
 8009008:	40023800 	.word	0x40023800

0800900c <RCC_GetITStatus>:

  /* Check the parameters */
  assert_param(IS_RCC_GET_IT(RCC_IT));

  /* Check the status of the specified RCC interrupt */
  if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
 800900c:	4b03      	ldr	r3, [pc, #12]	; (800901c <RCC_GetITStatus+0x10>)
 800900e:	68db      	ldr	r3, [r3, #12]
  else
  {
    bitstatus = RESET;
  }
  /* Return the RCC_IT status */
  return  bitstatus;
 8009010:	4218      	tst	r0, r3
}
 8009012:	bf14      	ite	ne
 8009014:	2001      	movne	r0, #1
 8009016:	2000      	moveq	r0, #0
 8009018:	4770      	bx	lr
 800901a:	bf00      	nop
 800901c:	40023800 	.word	0x40023800

08009020 <RCC_ClearITPendingBit>:
  /* Check the parameters */
  assert_param(IS_RCC_CLEAR_IT(RCC_IT));

  /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
     pending bits */
  *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
 8009020:	4b01      	ldr	r3, [pc, #4]	; (8009028 <RCC_ClearITPendingBit+0x8>)
 8009022:	7018      	strb	r0, [r3, #0]
 8009024:	4770      	bx	lr
 8009026:	bf00      	nop
 8009028:	4002380e 	.word	0x4002380e

0800902c <USART_DeInit>:
  * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
  *         UART peripheral.
  * @retval None
  */
void USART_DeInit(USART_TypeDef* USARTx)
{
 800902c:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));

  if (USARTx == USART1)
 800902e:	4b2b      	ldr	r3, [pc, #172]	; (80090dc <USART_DeInit+0xb0>)
 8009030:	4298      	cmp	r0, r3
 8009032:	d019      	beq.n	8009068 <USART_DeInit+0x3c>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
  }
  else if (USARTx == USART2)
 8009034:	4b2a      	ldr	r3, [pc, #168]	; (80090e0 <USART_DeInit+0xb4>)
 8009036:	4298      	cmp	r0, r3
 8009038:	d020      	beq.n	800907c <USART_DeInit+0x50>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
  }
  else if (USARTx == USART3)
 800903a:	4b2a      	ldr	r3, [pc, #168]	; (80090e4 <USART_DeInit+0xb8>)
 800903c:	4298      	cmp	r0, r3
 800903e:	d029      	beq.n	8009094 <USART_DeInit+0x68>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
  }    
  else if (USARTx == UART4)
 8009040:	4b29      	ldr	r3, [pc, #164]	; (80090e8 <USART_DeInit+0xbc>)
 8009042:	4298      	cmp	r0, r3
 8009044:	d032      	beq.n	80090ac <USART_DeInit+0x80>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
  }
  else if (USARTx == UART5)
 8009046:	4b29      	ldr	r3, [pc, #164]	; (80090ec <USART_DeInit+0xc0>)
 8009048:	4298      	cmp	r0, r3
 800904a:	d03b      	beq.n	80090c4 <USART_DeInit+0x98>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
  }     
  else
  {
    if (USARTx == USART6)
 800904c:	4b28      	ldr	r3, [pc, #160]	; (80090f0 <USART_DeInit+0xc4>)
 800904e:	4298      	cmp	r0, r3
 8009050:	d000      	beq.n	8009054 <USART_DeInit+0x28>
 8009052:	bd08      	pop	{r3, pc}
    { 
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, ENABLE);
 8009054:	2101      	movs	r1, #1
 8009056:	2020      	movs	r0, #32
 8009058:	f7ff ff54 	bl	8008f04 <RCC_APB2PeriphResetCmd>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, DISABLE);
    }
  }
}
 800905c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  else
  {
    if (USARTx == USART6)
    { 
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, DISABLE);
 8009060:	2100      	movs	r1, #0
 8009062:	2020      	movs	r0, #32
 8009064:	f7ff bf4e 	b.w	8008f04 <RCC_APB2PeriphResetCmd>
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));

  if (USARTx == USART1)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
 8009068:	2101      	movs	r1, #1
 800906a:	2010      	movs	r0, #16
 800906c:	f7ff ff4a 	bl	8008f04 <RCC_APB2PeriphResetCmd>
    { 
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, DISABLE);
    }
  }
}
 8009070:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  assert_param(IS_USART_ALL_PERIPH(USARTx));

  if (USARTx == USART1)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
 8009074:	2100      	movs	r1, #0
 8009076:	2010      	movs	r0, #16
 8009078:	f7ff bf44 	b.w	8008f04 <RCC_APB2PeriphResetCmd>
  }
  else if (USARTx == USART2)
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
 800907c:	2101      	movs	r1, #1
 800907e:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 8009082:	f7ff ff31 	bl	8008ee8 <RCC_APB1PeriphResetCmd>
    { 
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, DISABLE);
    }
  }
}
 8009086:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
  }
  else if (USARTx == USART2)
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
 800908a:	2100      	movs	r1, #0
 800908c:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 8009090:	f7ff bf2a 	b.w	8008ee8 <RCC_APB1PeriphResetCmd>
  }
  else if (USARTx == USART3)
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
 8009094:	2101      	movs	r1, #1
 8009096:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 800909a:	f7ff ff25 	bl	8008ee8 <RCC_APB1PeriphResetCmd>
    { 
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, DISABLE);
    }
  }
}
 800909e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
  }
  else if (USARTx == USART3)
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
 80090a2:	2100      	movs	r1, #0
 80090a4:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 80090a8:	f7ff bf1e 	b.w	8008ee8 <RCC_APB1PeriphResetCmd>
  }    
  else if (USARTx == UART4)
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
 80090ac:	2101      	movs	r1, #1
 80090ae:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 80090b2:	f7ff ff19 	bl	8008ee8 <RCC_APB1PeriphResetCmd>
    { 
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, DISABLE);
    }
  }
}
 80090b6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
  }    
  else if (USARTx == UART4)
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
 80090ba:	2100      	movs	r1, #0
 80090bc:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 80090c0:	f7ff bf12 	b.w	8008ee8 <RCC_APB1PeriphResetCmd>
  }
  else if (USARTx == UART5)
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
 80090c4:	2101      	movs	r1, #1
 80090c6:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 80090ca:	f7ff ff0d 	bl	8008ee8 <RCC_APB1PeriphResetCmd>
    { 
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, DISABLE);
    }
  }
}
 80090ce:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
  }
  else if (USARTx == UART5)
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
 80090d2:	2100      	movs	r1, #0
 80090d4:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 80090d8:	f7ff bf06 	b.w	8008ee8 <RCC_APB1PeriphResetCmd>
 80090dc:	40011000 	.word	0x40011000
 80090e0:	40004400 	.word	0x40004400
 80090e4:	40004800 	.word	0x40004800
 80090e8:	40004c00 	.word	0x40004c00
 80090ec:	40005000 	.word	0x40005000
 80090f0:	40011400 	.word	0x40011400

080090f4 <USART_Init>:
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure that contains
  *         the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 80090f4:	b530      	push	{r4, r5, lr}
 80090f6:	4604      	mov	r4, r0
 80090f8:	460d      	mov	r5, r1
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
  }

/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 80090fa:	8a03      	ldrh	r3, [r0, #16]
  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit :
      Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
  
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;
 80090fc:	88ca      	ldrh	r2, [r1, #6]
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
  }

/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 80090fe:	b29b      	uxth	r3, r3

  /* Clear STOP[13:12] bits */
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
 8009100:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit :
      Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
  
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;
 8009104:	4313      	orrs	r3, r2
 8009106:	8203      	strh	r3, [r0, #16]

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
 8009108:	8982      	ldrh	r2, [r0, #12]
     Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
            USART_InitStruct->USART_Mode;

  /* Write to USART CR1 */
  USARTx->CR1 = (uint16_t)tmpreg;
 800910a:	890b      	ldrh	r3, [r1, #8]
 800910c:	8888      	ldrh	r0, [r1, #4]
 800910e:	8949      	ldrh	r1, [r1, #10]
 8009110:	4303      	orrs	r3, r0
  
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
 8009112:	b292      	uxth	r2, r2
     Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
            USART_InitStruct->USART_Mode;

  /* Write to USART CR1 */
  USARTx->CR1 = (uint16_t)tmpreg;
 8009114:	430b      	orrs	r3, r1

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;

  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
 8009116:	f422 52b0 	bic.w	r2, r2, #5632	; 0x1600
 800911a:	f022 020c 	bic.w	r2, r2, #12
     Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
            USART_InitStruct->USART_Mode;

  /* Write to USART CR1 */
  USARTx->CR1 = (uint16_t)tmpreg;
 800911e:	b29b      	uxth	r3, r3
 8009120:	4313      	orrs	r3, r2
 8009122:	81a3      	strh	r3, [r4, #12]

/*---------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = USARTx->CR3;
 8009124:	8aa3      	ldrh	r3, [r4, #20]
  /* Configure the USART HFC : 
      Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;

  /* Write to USART CR3 */
  USARTx->CR3 = (uint16_t)tmpreg;
 8009126:	89aa      	ldrh	r2, [r5, #12]

  /* Write to USART CR1 */
  USARTx->CR1 = (uint16_t)tmpreg;

/*---------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = USARTx->CR3;
 8009128:	b29b      	uxth	r3, r3

  /* Clear CTSE and RTSE bits */
  tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
 800912a:	f423 7340 	bic.w	r3, r3, #768	; 0x300
  /* Configure the USART HFC : 
      Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;

  /* Write to USART CR3 */
  USARTx->CR3 = (uint16_t)tmpreg;
 800912e:	4313      	orrs	r3, r2
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure that contains
  *         the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 8009130:	b085      	sub	sp, #20
  /* Configure the USART HFC : 
      Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;

  /* Write to USART CR3 */
  USARTx->CR3 = (uint16_t)tmpreg;
 8009132:	82a3      	strh	r3, [r4, #20]

/*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate */
  RCC_GetClocksFreq(&RCC_ClocksStatus);
 8009134:	4668      	mov	r0, sp
 8009136:	f7ff fde9 	bl	8008d0c <RCC_GetClocksFreq>

  if ((USARTx == USART1) || (USARTx == USART6))
 800913a:	4b1e      	ldr	r3, [pc, #120]	; (80091b4 <USART_Init+0xc0>)
 800913c:	429c      	cmp	r4, r3
 800913e:	d02a      	beq.n	8009196 <USART_Init+0xa2>
 8009140:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8009144:	429c      	cmp	r4, r3
 8009146:	d026      	beq.n	8009196 <USART_Init+0xa2>
  {
    apbclock = RCC_ClocksStatus.PCLK2_Frequency;
  }
  else
  {
    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
 8009148:	9a02      	ldr	r2, [sp, #8]
  }
  
  /* Determine the integer part */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 800914a:	89a3      	ldrh	r3, [r4, #12]
  {
    /* Integer part computing in case Oversampling mode is 8 Samples */
    integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
 800914c:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  {
    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
  }
  
  /* Determine the integer part */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 8009150:	f413 4f00 	tst.w	r3, #32768	; 0x8000
  {
    /* Integer part computing in case Oversampling mode is 8 Samples */
    integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
 8009154:	682b      	ldr	r3, [r5, #0]
  }
  else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
  {
    /* Integer part computing in case Oversampling mode is 16 Samples */
    integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
 8009156:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  
  /* Determine the integer part */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
  {
    /* Integer part computing in case Oversampling mode is 8 Samples */
    integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
 800915a:	bf14      	ite	ne
 800915c:	005b      	lslne	r3, r3, #1
  }
  else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
  {
    /* Integer part computing in case Oversampling mode is 16 Samples */
    integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
 800915e:	009b      	lsleq	r3, r3, #2
 8009160:	fbb2 f0f3 	udiv	r0, r2, r3
  }
  tmpreg = (integerdivider / 100) << 4;
 8009164:	4a14      	ldr	r2, [pc, #80]	; (80091b8 <USART_Init+0xc4>)

  /* Determine the fractional part */
  fractionaldivider = integerdivider - (100 * (tmpreg >> 4));

  /* Implement the fractional part in the register */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 8009166:	89a1      	ldrh	r1, [r4, #12]
  else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
  {
    /* Integer part computing in case Oversampling mode is 16 Samples */
    integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
  }
  tmpreg = (integerdivider / 100) << 4;
 8009168:	fba2 3500 	umull	r3, r5, r2, r0

  /* Determine the fractional part */
  fractionaldivider = integerdivider - (100 * (tmpreg >> 4));

  /* Implement the fractional part in the register */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 800916c:	0409      	lsls	r1, r1, #16
  else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
  {
    /* Integer part computing in case Oversampling mode is 16 Samples */
    integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
  }
  tmpreg = (integerdivider / 100) << 4;
 800916e:	ea4f 1555 	mov.w	r5, r5, lsr #5

  /* Determine the fractional part */
  fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
 8009172:	f04f 0364 	mov.w	r3, #100	; 0x64
 8009176:	fb05 0313 	mls	r3, r5, r3, r0
 800917a:	ea4f 1505 	mov.w	r5, r5, lsl #4

  /* Implement the fractional part in the register */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 800917e:	d40c      	bmi.n	800919a <USART_Init+0xa6>
  {
    tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
  }
  else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
  {
    tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
 8009180:	011b      	lsls	r3, r3, #4
 8009182:	3332      	adds	r3, #50	; 0x32
 8009184:	fba2 2303 	umull	r2, r3, r2, r3
 8009188:	f3c3 1343 	ubfx	r3, r3, #5, #4
 800918c:	432b      	orrs	r3, r5
  }
  
  /* Write to USART BRR register */
  USARTx->BRR = (uint16_t)tmpreg;
 800918e:	b29b      	uxth	r3, r3
 8009190:	8123      	strh	r3, [r4, #8]
}
 8009192:	b005      	add	sp, #20
 8009194:	bd30      	pop	{r4, r5, pc}
  /* Configure the USART Baud Rate */
  RCC_GetClocksFreq(&RCC_ClocksStatus);

  if ((USARTx == USART1) || (USARTx == USART6))
  {
    apbclock = RCC_ClocksStatus.PCLK2_Frequency;
 8009196:	9a03      	ldr	r2, [sp, #12]
 8009198:	e7d7      	b.n	800914a <USART_Init+0x56>
  fractionaldivider = integerdivider - (100 * (tmpreg >> 4));

  /* Implement the fractional part in the register */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
  {
    tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
 800919a:	00d9      	lsls	r1, r3, #3
 800919c:	3132      	adds	r1, #50	; 0x32
 800919e:	fba2 3101 	umull	r3, r1, r2, r1
 80091a2:	f3c1 1242 	ubfx	r2, r1, #5, #3
 80091a6:	ea42 0305 	orr.w	r3, r2, r5
  {
    tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
  }
  
  /* Write to USART BRR register */
  USARTx->BRR = (uint16_t)tmpreg;
 80091aa:	b29b      	uxth	r3, r3
 80091ac:	8123      	strh	r3, [r4, #8]
}
 80091ae:	b005      	add	sp, #20
 80091b0:	bd30      	pop	{r4, r5, pc}
 80091b2:	bf00      	nop
 80091b4:	40011000 	.word	0x40011000
 80091b8:	51eb851f 	.word	0x51eb851f

080091bc <USART_StructInit>:
  */
void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
{
  /* USART_InitStruct members default value */
  USART_InitStruct->USART_BaudRate = 9600;
  USART_InitStruct->USART_WordLength = USART_WordLength_8b;
 80091bc:	2300      	movs	r3, #0
  * @retval None
  */
void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
{
  /* USART_InitStruct members default value */
  USART_InitStruct->USART_BaudRate = 9600;
 80091be:	f44f 5116 	mov.w	r1, #9600	; 0x2580
  USART_InitStruct->USART_WordLength = USART_WordLength_8b;
  USART_InitStruct->USART_StopBits = USART_StopBits_1;
  USART_InitStruct->USART_Parity = USART_Parity_No ;
  USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 80091c2:	220c      	movs	r2, #12
  * @retval None
  */
void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
{
  /* USART_InitStruct members default value */
  USART_InitStruct->USART_BaudRate = 9600;
 80091c4:	6001      	str	r1, [r0, #0]
  USART_InitStruct->USART_WordLength = USART_WordLength_8b;
  USART_InitStruct->USART_StopBits = USART_StopBits_1;
  USART_InitStruct->USART_Parity = USART_Parity_No ;
  USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 80091c6:	8142      	strh	r2, [r0, #10]
  */
void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
{
  /* USART_InitStruct members default value */
  USART_InitStruct->USART_BaudRate = 9600;
  USART_InitStruct->USART_WordLength = USART_WordLength_8b;
 80091c8:	8083      	strh	r3, [r0, #4]
  USART_InitStruct->USART_StopBits = USART_StopBits_1;
 80091ca:	80c3      	strh	r3, [r0, #6]
  USART_InitStruct->USART_Parity = USART_Parity_No ;
 80091cc:	8103      	strh	r3, [r0, #8]
  USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
  USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
 80091ce:	8183      	strh	r3, [r0, #12]
 80091d0:	4770      	bx	lr
 80091d2:	bf00      	nop

080091d4 <USART_ClockInit>:
  /* Set CPHA bit according to USART_CPHA value */
  /* Set LBCL bit according to USART_LastBit value */
  tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
                 USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;
 80091d4:	884b      	ldrh	r3, [r1, #2]
 80091d6:	880a      	ldrh	r2, [r1, #0]
  *         contains the configuration information for the specified  USART peripheral.
  * @note   The Smart Card and Synchronous modes are not available for UART4 and UART5.    
  * @retval None
  */
void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
{
 80091d8:	b410      	push	{r4}
  /* Set CPHA bit according to USART_CPHA value */
  /* Set LBCL bit according to USART_LastBit value */
  tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
                 USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;
 80091da:	888c      	ldrh	r4, [r1, #4]
 80091dc:	431a      	orrs	r2, r3
 80091de:	88c9      	ldrh	r1, [r1, #6]
  assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
  assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
  assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
  
/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 80091e0:	8a03      	ldrh	r3, [r0, #16]
  /* Set CPHA bit according to USART_CPHA value */
  /* Set LBCL bit according to USART_LastBit value */
  tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
                 USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;
 80091e2:	4322      	orrs	r2, r4
 80091e4:	430a      	orrs	r2, r1
  assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
  assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
  assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
  
/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 80091e6:	b29b      	uxth	r3, r3
  /* Set CPHA bit according to USART_CPHA value */
  /* Set LBCL bit according to USART_LastBit value */
  tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
                 USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;
 80091e8:	b292      	uxth	r2, r2
  assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
  
/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
  /* Clear CLKEN, CPOL, CPHA and LBCL bits */
  tmpreg &= (uint32_t)~((uint32_t)CR2_CLOCK_CLEAR_MASK);
 80091ea:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
  /* Set CPHA bit according to USART_CPHA value */
  /* Set LBCL bit according to USART_LastBit value */
  tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
                 USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;
 80091ee:	4313      	orrs	r3, r2
 80091f0:	8203      	strh	r3, [r0, #16]
}
 80091f2:	bc10      	pop	{r4}
 80091f4:	4770      	bx	lr
 80091f6:	bf00      	nop

080091f8 <USART_ClockStructInit>:
  * @retval None
  */
void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
{
  /* USART_ClockInitStruct members default value */
  USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
 80091f8:	2300      	movs	r3, #0
 80091fa:	8003      	strh	r3, [r0, #0]
  USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
 80091fc:	8043      	strh	r3, [r0, #2]
  USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
 80091fe:	8083      	strh	r3, [r0, #4]
  USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
 8009200:	80c3      	strh	r3, [r0, #6]
 8009202:	4770      	bx	lr

08009204 <USART_Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected USART by setting the UE bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_UE;
 8009204:	8983      	ldrh	r3, [r0, #12]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8009206:	b929      	cbnz	r1, 8009214 <USART_Cmd+0x10>
    USARTx->CR1 |= USART_CR1_UE;
  }
  else
  {
    /* Disable the selected USART by clearing the UE bit in the CR1 register */
    USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_UE);
 8009208:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 800920c:	041b      	lsls	r3, r3, #16
 800920e:	0c1b      	lsrs	r3, r3, #16
 8009210:	8183      	strh	r3, [r0, #12]
 8009212:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected USART by setting the UE bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_UE;
 8009214:	b29b      	uxth	r3, r3
 8009216:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800921a:	8183      	strh	r3, [r0, #12]
 800921c:	4770      	bx	lr
 800921e:	bf00      	nop

08009220 <USART_SetPrescaler>:
{ 
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  
  /* Clear the USART prescaler */
  USARTx->GTPR &= USART_GTPR_GT;
 8009220:	8b03      	ldrh	r3, [r0, #24]
 8009222:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8009226:	8303      	strh	r3, [r0, #24]
  /* Set the USART prescaler */
  USARTx->GTPR |= USART_Prescaler;
 8009228:	8b03      	ldrh	r3, [r0, #24]
 800922a:	b29b      	uxth	r3, r3
 800922c:	4319      	orrs	r1, r3
 800922e:	8301      	strh	r1, [r0, #24]
 8009230:	4770      	bx	lr
 8009232:	bf00      	nop

08009234 <USART_OverSampling8Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_OVER8;
 8009234:	8983      	ldrh	r3, [r0, #12]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8009236:	b919      	cbnz	r1, 8009240 <USART_OverSampling8Cmd+0xc>
    USARTx->CR1 |= USART_CR1_OVER8;
  }
  else
  {
    /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
    USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_OVER8);
 8009238:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800923c:	8183      	strh	r3, [r0, #12]
 800923e:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_OVER8;
 8009240:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8009244:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8009248:	b29b      	uxth	r3, r3
 800924a:	8183      	strh	r3, [r0, #12]
 800924c:	4770      	bx	lr
 800924e:	bf00      	nop

08009250 <USART_OneBitMethodCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_ONEBIT;
 8009250:	8a83      	ldrh	r3, [r0, #20]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8009252:	b929      	cbnz	r1, 8009260 <USART_OneBitMethodCmd+0x10>
    USARTx->CR3 |= USART_CR3_ONEBIT;
  }
  else
  {
    /* Disable the one bit method by clearing the ONEBITE bit in the CR3 register */
    USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_ONEBIT);
 8009254:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8009258:	041b      	lsls	r3, r3, #16
 800925a:	0c1b      	lsrs	r3, r3, #16
 800925c:	8283      	strh	r3, [r0, #20]
 800925e:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_ONEBIT;
 8009260:	b29b      	uxth	r3, r3
 8009262:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8009266:	8283      	strh	r3, [r0, #20]
 8009268:	4770      	bx	lr
 800926a:	bf00      	nop

0800926c <USART_SendData>:
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DATA(Data)); 
    
  /* Transmit Data */
  USARTx->DR = (Data & (uint16_t)0x01FF);
 800926c:	f3c1 0108 	ubfx	r1, r1, #0, #9
 8009270:	8081      	strh	r1, [r0, #4]
 8009272:	4770      	bx	lr

08009274 <USART_ReceiveData>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  
  /* Receive Data */
  return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
 8009274:	8880      	ldrh	r0, [r0, #4]
}
 8009276:	f3c0 0008 	ubfx	r0, r0, #0, #9
 800927a:	4770      	bx	lr

0800927c <USART_SetAddress>:
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_ADDRESS(USART_Address)); 
    
  /* Clear the USART address */
  USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_ADD);
 800927c:	8a03      	ldrh	r3, [r0, #16]
 800927e:	f023 030f 	bic.w	r3, r3, #15
 8009282:	041b      	lsls	r3, r3, #16
 8009284:	0c1b      	lsrs	r3, r3, #16
 8009286:	8203      	strh	r3, [r0, #16]
  /* Set the USART address node */
  USARTx->CR2 |= USART_Address;
 8009288:	8a03      	ldrh	r3, [r0, #16]
 800928a:	b29b      	uxth	r3, r3
 800928c:	4319      	orrs	r1, r3
 800928e:	8201      	strh	r1, [r0, #16]
 8009290:	4770      	bx	lr
 8009292:	bf00      	nop

08009294 <USART_ReceiverWakeUpCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
  
  if (NewState != DISABLE)
  {
    /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_RWU;
 8009294:	8983      	ldrh	r3, [r0, #12]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
  
  if (NewState != DISABLE)
 8009296:	b929      	cbnz	r1, 80092a4 <USART_ReceiverWakeUpCmd+0x10>
    USARTx->CR1 |= USART_CR1_RWU;
  }
  else
  {
    /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
    USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_RWU);
 8009298:	f023 0302 	bic.w	r3, r3, #2
 800929c:	041b      	lsls	r3, r3, #16
 800929e:	0c1b      	lsrs	r3, r3, #16
 80092a0:	8183      	strh	r3, [r0, #12]
 80092a2:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
  
  if (NewState != DISABLE)
  {
    /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_RWU;
 80092a4:	b29b      	uxth	r3, r3
 80092a6:	f043 0302 	orr.w	r3, r3, #2
 80092aa:	8183      	strh	r3, [r0, #12]
 80092ac:	4770      	bx	lr
 80092ae:	bf00      	nop

080092b0 <USART_WakeUpConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_WAKEUP(USART_WakeUp));
  
  USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_WAKE);
 80092b0:	8983      	ldrh	r3, [r0, #12]
 80092b2:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80092b6:	041b      	lsls	r3, r3, #16
 80092b8:	0c1b      	lsrs	r3, r3, #16
 80092ba:	8183      	strh	r3, [r0, #12]
  USARTx->CR1 |= USART_WakeUp;
 80092bc:	8983      	ldrh	r3, [r0, #12]
 80092be:	b29b      	uxth	r3, r3
 80092c0:	4319      	orrs	r1, r3
 80092c2:	8181      	strh	r1, [r0, #12]
 80092c4:	4770      	bx	lr
 80092c6:	bf00      	nop

080092c8 <USART_LINBreakDetectLengthConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
  
  USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LBDL);
 80092c8:	8a03      	ldrh	r3, [r0, #16]
 80092ca:	f023 0320 	bic.w	r3, r3, #32
 80092ce:	041b      	lsls	r3, r3, #16
 80092d0:	0c1b      	lsrs	r3, r3, #16
 80092d2:	8203      	strh	r3, [r0, #16]
  USARTx->CR2 |= USART_LINBreakDetectLength;  
 80092d4:	8a03      	ldrh	r3, [r0, #16]
 80092d6:	b29b      	uxth	r3, r3
 80092d8:	4319      	orrs	r1, r3
 80092da:	8201      	strh	r1, [r0, #16]
 80092dc:	4770      	bx	lr
 80092de:	bf00      	nop

080092e0 <USART_LINCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
    USARTx->CR2 |= USART_CR2_LINEN;
 80092e0:	8a03      	ldrh	r3, [r0, #16]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80092e2:	b929      	cbnz	r1, 80092f0 <USART_LINCmd+0x10>
    USARTx->CR2 |= USART_CR2_LINEN;
  }
  else
  {
    /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
    USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LINEN);
 80092e4:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 80092e8:	041b      	lsls	r3, r3, #16
 80092ea:	0c1b      	lsrs	r3, r3, #16
 80092ec:	8203      	strh	r3, [r0, #16]
 80092ee:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
    USARTx->CR2 |= USART_CR2_LINEN;
 80092f0:	b29b      	uxth	r3, r3
 80092f2:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80092f6:	8203      	strh	r3, [r0, #16]
 80092f8:	4770      	bx	lr
 80092fa:	bf00      	nop

080092fc <USART_SendBreak>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  
  /* Send break characters */
  USARTx->CR1 |= USART_CR1_SBK;
 80092fc:	8983      	ldrh	r3, [r0, #12]
 80092fe:	b29b      	uxth	r3, r3
 8009300:	f043 0301 	orr.w	r3, r3, #1
 8009304:	8183      	strh	r3, [r0, #12]
 8009306:	4770      	bx	lr

08009308 <USART_HalfDuplexCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_HDSEL;
 8009308:	8a83      	ldrh	r3, [r0, #20]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800930a:	b929      	cbnz	r1, 8009318 <USART_HalfDuplexCmd+0x10>
    USARTx->CR3 |= USART_CR3_HDSEL;
  }
  else
  {
    /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
    USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_HDSEL);
 800930c:	f023 0308 	bic.w	r3, r3, #8
 8009310:	041b      	lsls	r3, r3, #16
 8009312:	0c1b      	lsrs	r3, r3, #16
 8009314:	8283      	strh	r3, [r0, #20]
 8009316:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_HDSEL;
 8009318:	b29b      	uxth	r3, r3
 800931a:	f043 0308 	orr.w	r3, r3, #8
 800931e:	8283      	strh	r3, [r0, #20]
 8009320:	4770      	bx	lr
 8009322:	bf00      	nop

08009324 <USART_SetGuardTime>:
{    
  /* Check the parameters */
  assert_param(IS_USART_1236_PERIPH(USARTx));
  
  /* Clear the USART Guard time */
  USARTx->GTPR &= USART_GTPR_PSC;
 8009324:	8b03      	ldrh	r3, [r0, #24]
 8009326:	b2db      	uxtb	r3, r3
 8009328:	8303      	strh	r3, [r0, #24]
  /* Set the USART guard time */
  USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
 800932a:	8b03      	ldrh	r3, [r0, #24]
 800932c:	b29b      	uxth	r3, r3
 800932e:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 8009332:	8301      	strh	r1, [r0, #24]
 8009334:	4770      	bx	lr
 8009336:	bf00      	nop

08009338 <USART_SmartCardCmd>:
  assert_param(IS_USART_1236_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the SC mode by setting the SCEN bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_SCEN;
 8009338:	8a83      	ldrh	r3, [r0, #20]
void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_USART_1236_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800933a:	b929      	cbnz	r1, 8009348 <USART_SmartCardCmd+0x10>
    USARTx->CR3 |= USART_CR3_SCEN;
  }
  else
  {
    /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
    USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_SCEN);
 800933c:	f023 0320 	bic.w	r3, r3, #32
 8009340:	041b      	lsls	r3, r3, #16
 8009342:	0c1b      	lsrs	r3, r3, #16
 8009344:	8283      	strh	r3, [r0, #20]
 8009346:	4770      	bx	lr
  assert_param(IS_USART_1236_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the SC mode by setting the SCEN bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_SCEN;
 8009348:	b29b      	uxth	r3, r3
 800934a:	f043 0320 	orr.w	r3, r3, #32
 800934e:	8283      	strh	r3, [r0, #20]
 8009350:	4770      	bx	lr
 8009352:	bf00      	nop

08009354 <USART_SmartCardNACKCmd>:
  assert_param(IS_USART_1236_PERIPH(USARTx)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_NACK;
 8009354:	8a83      	ldrh	r3, [r0, #20]
void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_USART_1236_PERIPH(USARTx)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8009356:	b929      	cbnz	r1, 8009364 <USART_SmartCardNACKCmd+0x10>
    USARTx->CR3 |= USART_CR3_NACK;
  }
  else
  {
    /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
    USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_NACK);
 8009358:	f023 0310 	bic.w	r3, r3, #16
 800935c:	041b      	lsls	r3, r3, #16
 800935e:	0c1b      	lsrs	r3, r3, #16
 8009360:	8283      	strh	r3, [r0, #20]
 8009362:	4770      	bx	lr
  assert_param(IS_USART_1236_PERIPH(USARTx)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_NACK;
 8009364:	b29b      	uxth	r3, r3
 8009366:	f043 0310 	orr.w	r3, r3, #16
 800936a:	8283      	strh	r3, [r0, #20]
 800936c:	4770      	bx	lr
 800936e:	bf00      	nop

08009370 <USART_IrDAConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
    
  USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IRLP);
 8009370:	8a83      	ldrh	r3, [r0, #20]
 8009372:	f023 0304 	bic.w	r3, r3, #4
 8009376:	041b      	lsls	r3, r3, #16
 8009378:	0c1b      	lsrs	r3, r3, #16
 800937a:	8283      	strh	r3, [r0, #20]
  USARTx->CR3 |= USART_IrDAMode;
 800937c:	8a83      	ldrh	r3, [r0, #20]
 800937e:	b29b      	uxth	r3, r3
 8009380:	4319      	orrs	r1, r3
 8009382:	8281      	strh	r1, [r0, #20]
 8009384:	4770      	bx	lr
 8009386:	bf00      	nop

08009388 <USART_IrDACmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  if (NewState != DISABLE)
  {
    /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_IREN;
 8009388:	8a83      	ldrh	r3, [r0, #20]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  if (NewState != DISABLE)
 800938a:	b929      	cbnz	r1, 8009398 <USART_IrDACmd+0x10>
    USARTx->CR3 |= USART_CR3_IREN;
  }
  else
  {
    /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
    USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IREN);
 800938c:	f023 0302 	bic.w	r3, r3, #2
 8009390:	041b      	lsls	r3, r3, #16
 8009392:	0c1b      	lsrs	r3, r3, #16
 8009394:	8283      	strh	r3, [r0, #20]
 8009396:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  if (NewState != DISABLE)
  {
    /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_IREN;
 8009398:	b29b      	uxth	r3, r3
 800939a:	f043 0302 	orr.w	r3, r3, #2
 800939e:	8283      	strh	r3, [r0, #20]
 80093a0:	4770      	bx	lr
 80093a2:	bf00      	nop

080093a4 <USART_DMACmd>:

  if (NewState != DISABLE)
  {
    /* Enable the DMA transfer for selected requests by setting the DMAT and/or
       DMAR bits in the USART CR3 register */
    USARTx->CR3 |= USART_DMAReq;
 80093a4:	8a83      	ldrh	r3, [r0, #20]
 80093a6:	b29b      	uxth	r3, r3
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DMAREQ(USART_DMAReq));  
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 

  if (NewState != DISABLE)
 80093a8:	b91a      	cbnz	r2, 80093b2 <USART_DMACmd+0xe>
  }
  else
  {
    /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
       DMAR bits in the USART CR3 register */
    USARTx->CR3 &= (uint16_t)~USART_DMAReq;
 80093aa:	ea23 0101 	bic.w	r1, r3, r1
 80093ae:	8281      	strh	r1, [r0, #20]
 80093b0:	4770      	bx	lr

  if (NewState != DISABLE)
  {
    /* Enable the DMA transfer for selected requests by setting the DMAT and/or
       DMAR bits in the USART CR3 register */
    USARTx->CR3 |= USART_DMAReq;
 80093b2:	4319      	orrs	r1, r3
 80093b4:	8281      	strh	r1, [r0, #20]
 80093b6:	4770      	bx	lr

080093b8 <USART_ITConfig>:
  * @param  NewState: new state of the specified USARTx interrupts.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
{
 80093b8:	b410      	push	{r4}
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);

  /* Get the interrupt position */
  itpos = USART_IT & IT_MASK;
  itmask = (((uint32_t)0x01) << itpos);
 80093ba:	f001 041f 	and.w	r4, r1, #31
  } 
    
  usartxbase = (uint32_t)USARTx;

  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
 80093be:	f3c1 1142 	ubfx	r1, r1, #5, #3

  /* Get the interrupt position */
  itpos = USART_IT & IT_MASK;
  itmask = (((uint32_t)0x01) << itpos);
 80093c2:	2301      	movs	r3, #1
    
  if (usartreg == 0x01) /* The IT is in CR1 register */
 80093c4:	2901      	cmp	r1, #1
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);

  /* Get the interrupt position */
  itpos = USART_IT & IT_MASK;
  itmask = (((uint32_t)0x01) << itpos);
 80093c6:	fa03 f304 	lsl.w	r3, r3, r4
    
  if (usartreg == 0x01) /* The IT is in CR1 register */
 80093ca:	d00f      	beq.n	80093ec <USART_ITConfig+0x34>
  {
    usartxbase += 0x0C;
  }
  else if (usartreg == 0x02) /* The IT is in CR2 register */
 80093cc:	2902      	cmp	r1, #2
  {
    usartxbase += 0x10;
 80093ce:	bf0c      	ite	eq
 80093d0:	3010      	addeq	r0, #16
  }
  else /* The IT is in CR3 register */
  {
    usartxbase += 0x14; 
 80093d2:	3014      	addne	r0, #20
  }
  if (NewState != DISABLE)
 80093d4:	b92a      	cbnz	r2, 80093e2 <USART_ITConfig+0x2a>
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
  }
  else
  {
    *(__IO uint32_t*)usartxbase &= ~itmask;
 80093d6:	6802      	ldr	r2, [r0, #0]
  }
}
 80093d8:	bc10      	pop	{r4}
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
  }
  else
  {
    *(__IO uint32_t*)usartxbase &= ~itmask;
 80093da:	ea22 0303 	bic.w	r3, r2, r3
 80093de:	6003      	str	r3, [r0, #0]
  }
}
 80093e0:	4770      	bx	lr
  {
    usartxbase += 0x14; 
  }
  if (NewState != DISABLE)
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
 80093e2:	6802      	ldr	r2, [r0, #0]
  }
  else
  {
    *(__IO uint32_t*)usartxbase &= ~itmask;
  }
}
 80093e4:	bc10      	pop	{r4}
  {
    usartxbase += 0x14; 
  }
  if (NewState != DISABLE)
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
 80093e6:	4313      	orrs	r3, r2
 80093e8:	6003      	str	r3, [r0, #0]
  }
  else
  {
    *(__IO uint32_t*)usartxbase &= ~itmask;
  }
}
 80093ea:	4770      	bx	lr
  itpos = USART_IT & IT_MASK;
  itmask = (((uint32_t)0x01) << itpos);
    
  if (usartreg == 0x01) /* The IT is in CR1 register */
  {
    usartxbase += 0x0C;
 80093ec:	300c      	adds	r0, #12
 80093ee:	e7f1      	b.n	80093d4 <USART_ITConfig+0x1c>

080093f0 <USART_GetFlagStatus>:
  if (USART_FLAG == USART_FLAG_CTS)
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
  } 
    
  if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
 80093f0:	8803      	ldrh	r3, [r0, #0]
  }
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
 80093f2:	4219      	tst	r1, r3
}
 80093f4:	bf14      	ite	ne
 80093f6:	2001      	movne	r0, #1
 80093f8:	2000      	moveq	r0, #0
 80093fa:	4770      	bx	lr

080093fc <USART_ClearFlag>:
  if ((USART_FLAG & USART_FLAG_CTS) == USART_FLAG_CTS)
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
  } 
       
  USARTx->SR = (uint16_t)~USART_FLAG;
 80093fc:	43c9      	mvns	r1, r1
 80093fe:	b289      	uxth	r1, r1
 8009400:	8001      	strh	r1, [r0, #0]
 8009402:	4770      	bx	lr

08009404 <USART_GetITStatus>:
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
  } 
    
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
 8009404:	f3c1 1242 	ubfx	r2, r1, #5, #3
  *            @arg USART_IT_FE:   Framing Error interrupt
  *            @arg USART_IT_PE:   Parity Error interrupt
  * @retval The new state of USART_IT (SET or RESET).
  */
ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
{
 8009408:	b410      	push	{r4}
    
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
  /* Get the interrupt position */
  itmask = USART_IT & IT_MASK;
  itmask = (uint32_t)0x01 << itmask;
 800940a:	2301      	movs	r3, #1
  } 
    
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
  /* Get the interrupt position */
  itmask = USART_IT & IT_MASK;
 800940c:	f001 041f 	and.w	r4, r1, #31
  itmask = (uint32_t)0x01 << itmask;
  
  if (usartreg == 0x01) /* The IT  is in CR1 register */
 8009410:	2a01      	cmp	r2, #1
    
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
  /* Get the interrupt position */
  itmask = USART_IT & IT_MASK;
  itmask = (uint32_t)0x01 << itmask;
 8009412:	fa03 f304 	lsl.w	r3, r3, r4
  
  if (usartreg == 0x01) /* The IT  is in CR1 register */
 8009416:	d015      	beq.n	8009444 <USART_GetITStatus+0x40>
  {
    itmask &= USARTx->CR1;
  }
  else if (usartreg == 0x02) /* The IT  is in CR2 register */
 8009418:	2a02      	cmp	r2, #2
  {
    itmask &= USARTx->CR2;
 800941a:	bf0c      	ite	eq
 800941c:	8a02      	ldrheq	r2, [r0, #16]
  }
  else /* The IT  is in CR3 register */
  {
    itmask &= USARTx->CR3;
 800941e:	8a82      	ldrhne	r2, [r0, #20]
 8009420:	b292      	uxth	r2, r2
 8009422:	4013      	ands	r3, r2
  }
  
  bitpos = USART_IT >> 0x08;
  bitpos = (uint32_t)0x01 << bitpos;
  bitpos &= USARTx->SR;
 8009424:	8802      	ldrh	r2, [r0, #0]
 8009426:	b292      	uxth	r2, r2
  if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
 8009428:	b14b      	cbz	r3, 800943e <USART_GetITStatus+0x3a>
  {
    itmask &= USARTx->CR3;
  }
  
  bitpos = USART_IT >> 0x08;
  bitpos = (uint32_t)0x01 << bitpos;
 800942a:	2301      	movs	r3, #1
  else /* The IT  is in CR3 register */
  {
    itmask &= USARTx->CR3;
  }
  
  bitpos = USART_IT >> 0x08;
 800942c:	0a09      	lsrs	r1, r1, #8
  bitpos = (uint32_t)0x01 << bitpos;
 800942e:	fa03 f101 	lsl.w	r1, r3, r1
  bitpos &= USARTx->SR;
  if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
  {
    bitstatus = SET;
 8009432:	420a      	tst	r2, r1
 8009434:	bf14      	ite	ne
 8009436:	4618      	movne	r0, r3
 8009438:	2000      	moveq	r0, #0
  {
    bitstatus = RESET;
  }
  
  return bitstatus;  
}
 800943a:	bc10      	pop	{r4}
 800943c:	4770      	bx	lr
  {
    bitstatus = SET;
  }
  else
  {
    bitstatus = RESET;
 800943e:	4618      	mov	r0, r3
  }
  
  return bitstatus;  
}
 8009440:	bc10      	pop	{r4}
 8009442:	4770      	bx	lr
  itmask = USART_IT & IT_MASK;
  itmask = (uint32_t)0x01 << itmask;
  
  if (usartreg == 0x01) /* The IT  is in CR1 register */
  {
    itmask &= USARTx->CR1;
 8009444:	8982      	ldrh	r2, [r0, #12]
 8009446:	b292      	uxth	r2, r2
 8009448:	4013      	ands	r3, r2
 800944a:	e7eb      	b.n	8009424 <USART_GetITStatus+0x20>

0800944c <USART_ClearITPendingBit>:
    assert_param(IS_USART_1236_PERIPH(USARTx));
  } 
    
  bitpos = USART_IT >> 0x08;
  itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
  USARTx->SR = (uint16_t)~itmask;
 800944c:	0a09      	lsrs	r1, r1, #8
 800944e:	2301      	movs	r3, #1
 8009450:	fa03 f101 	lsl.w	r1, r3, r1
 8009454:	43c9      	mvns	r1, r1
 8009456:	b289      	uxth	r1, r1
 8009458:	8001      	strh	r1, [r0, #0]
 800945a:	4770      	bx	lr

0800945c <tcp_accept_null>:
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
}
 800945c:	f06f 0009 	mvn.w	r0, #9
 8009460:	4770      	bx	lr
 8009462:	bf00      	nop

08009464 <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
 8009464:	b4f0      	push	{r4, r5, r6, r7}
  u8_t i;
  u16_t n = 0;
  struct tcp_pcb *pcb;
  
again:
  if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
 8009466:	f64f 76ff 	movw	r6, #65535	; 0xffff
 800946a:	4f13      	ldr	r7, [pc, #76]	; (80094b8 <tcp_new_port+0x54>)
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
 800946c:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8009470:	8838      	ldrh	r0, [r7, #0]
  u8_t i;
  u16_t n = 0;
  struct tcp_pcb *pcb;
  
again:
  if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
 8009472:	42b0      	cmp	r0, r6
 8009474:	4c11      	ldr	r4, [pc, #68]	; (80094bc <tcp_new_port+0x58>)
 8009476:	bf18      	it	ne
 8009478:	3001      	addne	r0, #1
 800947a:	4b11      	ldr	r3, [pc, #68]	; (80094c0 <tcp_new_port+0x5c>)
 800947c:	bf14      	ite	ne
 800947e:	b280      	uxthne	r0, r0
 8009480:	f44f 4040 	moveq.w	r0, #49152	; 0xc000
 8009484:	f104 050c 	add.w	r5, r4, #12
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
  }
  /* Check all PCB lists. */
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
    for(pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
 8009488:	681b      	ldr	r3, [r3, #0]
 800948a:	b913      	cbnz	r3, 8009492 <tcp_new_port+0x2e>
 800948c:	e00b      	b.n	80094a6 <tcp_new_port+0x42>
 800948e:	68db      	ldr	r3, [r3, #12]
 8009490:	b14b      	cbz	r3, 80094a6 <tcp_new_port+0x42>
      if (pcb->local_port == tcp_port) {
 8009492:	8b5a      	ldrh	r2, [r3, #26]
 8009494:	4282      	cmp	r2, r0
 8009496:	d1fa      	bne.n	800948e <tcp_new_port+0x2a>
 8009498:	3901      	subs	r1, #1
 800949a:	b289      	uxth	r1, r1
        if (++n > (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START)) {
 800949c:	2900      	cmp	r1, #0
 800949e:	d1e8      	bne.n	8009472 <tcp_new_port+0xe>
 80094a0:	8038      	strh	r0, [r7, #0]
          return 0;
 80094a2:	4608      	mov	r0, r1
 80094a4:	e002      	b.n	80094ac <tcp_new_port+0x48>
again:
  if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
    tcp_port = TCP_LOCAL_PORT_RANGE_START;
  }
  /* Check all PCB lists. */
  for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
 80094a6:	42a5      	cmp	r5, r4
 80094a8:	d102      	bne.n	80094b0 <tcp_new_port+0x4c>
 80094aa:	8038      	strh	r0, [r7, #0]
        goto again;
      }
    }
  }
  return tcp_port;
}
 80094ac:	bcf0      	pop	{r4, r5, r6, r7}
 80094ae:	4770      	bx	lr
 80094b0:	f854 3f04 	ldr.w	r3, [r4, #4]!
 80094b4:	e7e8      	b.n	8009488 <tcp_new_port+0x24>
 80094b6:	bf00      	nop
 80094b8:	20000024 	.word	0x20000024
 80094bc:	08016130 	.word	0x08016130
 80094c0:	2000f048 	.word	0x2000f048

080094c4 <tcp_init>:
/**
 * Initialize this module.
 */
void
tcp_init(void)
{
 80094c4:	4770      	bx	lr
 80094c6:	bf00      	nop

080094c8 <tcp_bind>:
 *         ERR_VAL if bind failed because the PCB is not in a valid state
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
 80094c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  int i;
  int max_pcb_list = NUM_TCP_PCB_LISTS;
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
 80094ca:	7e03      	ldrb	r3, [r0, #24]
 80094cc:	2b00      	cmp	r3, #0
 80094ce:	d132      	bne.n	8009536 <tcp_bind+0x6e>
 80094d0:	4606      	mov	r6, r0
 80094d2:	460d      	mov	r5, r1
  if (ip_get_option(pcb, SOF_REUSEADDR)) {
    max_pcb_list = NUM_TCP_PCB_LISTS_NO_TIME_WAIT;
  }
#endif /* SO_REUSE */

  if (port == 0) {
 80094d4:	b33a      	cbz	r2, 8009526 <tcp_bind+0x5e>
 80094d6:	491d      	ldr	r1, [pc, #116]	; (800954c <tcp_bind+0x84>)
 *         ERR_VAL if bind failed because the PCB is not in a valid state
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
 80094d8:	4b1d      	ldr	r3, [pc, #116]	; (8009550 <tcp_bind+0x88>)
 80094da:	f101 070c 	add.w	r7, r1, #12
    }
  }

  /* Check if the address already is in use (on all lists) */
  for (i = 0; i < max_pcb_list; i++) {
    for(cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
 80094de:	681b      	ldr	r3, [r3, #0]
 80094e0:	b913      	cbnz	r3, 80094e8 <tcp_bind+0x20>
 80094e2:	e00e      	b.n	8009502 <tcp_bind+0x3a>
 80094e4:	68db      	ldr	r3, [r3, #12]
 80094e6:	b163      	cbz	r3, 8009502 <tcp_bind+0x3a>
      if (cpcb->local_port == port) {
 80094e8:	8b5c      	ldrh	r4, [r3, #26]
 80094ea:	4294      	cmp	r4, r2
 80094ec:	d1fa      	bne.n	80094e4 <tcp_bind+0x1c>
           tcp_connect. */
        if (!ip_get_option(pcb, SOF_REUSEADDR) ||
            !ip_get_option(cpcb, SOF_REUSEADDR))
#endif /* SO_REUSE */
        {
          if (ip_addr_isany(&(cpcb->local_ip)) ||
 80094ee:	6818      	ldr	r0, [r3, #0]
 80094f0:	b120      	cbz	r0, 80094fc <tcp_bind+0x34>
 80094f2:	b11d      	cbz	r5, 80094fc <tcp_bind+0x34>
              ip_addr_isany(ipaddr) ||
 80094f4:	682c      	ldr	r4, [r5, #0]
 80094f6:	b10c      	cbz	r4, 80094fc <tcp_bind+0x34>
 80094f8:	42a0      	cmp	r0, r4
 80094fa:	d1f3      	bne.n	80094e4 <tcp_bind+0x1c>
              ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
            return ERR_USE;
 80094fc:	f06f 0007 	mvn.w	r0, #7
  }
  pcb->local_port = port;
  TCP_REG(&tcp_bound_pcbs, pcb);
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
}
 8009500:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      return ERR_BUF;
    }
  }

  /* Check if the address already is in use (on all lists) */
  for (i = 0; i < max_pcb_list; i++) {
 8009502:	42b9      	cmp	r1, r7
 8009504:	d10c      	bne.n	8009520 <tcp_bind+0x58>
        }
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
 8009506:	b115      	cbz	r5, 800950e <tcp_bind+0x46>
 8009508:	682b      	ldr	r3, [r5, #0]
 800950a:	b103      	cbz	r3, 800950e <tcp_bind+0x46>
    pcb->local_ip = *ipaddr;
 800950c:	6033      	str	r3, [r6, #0]
  }
  pcb->local_port = port;
  TCP_REG(&tcp_bound_pcbs, pcb);
 800950e:	4b11      	ldr	r3, [pc, #68]	; (8009554 <tcp_bind+0x8c>)
  }

  if (!ip_addr_isany(ipaddr)) {
    pcb->local_ip = *ipaddr;
  }
  pcb->local_port = port;
 8009510:	8372      	strh	r2, [r6, #26]
  TCP_REG(&tcp_bound_pcbs, pcb);
 8009512:	681a      	ldr	r2, [r3, #0]
 8009514:	601e      	str	r6, [r3, #0]
 8009516:	60f2      	str	r2, [r6, #12]
 8009518:	f002 f888 	bl	800b62c <tcp_timer_needed>
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
 800951c:	2000      	movs	r0, #0
 800951e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8009520:	f851 3f04 	ldr.w	r3, [r1, #4]!
 8009524:	e7db      	b.n	80094de <tcp_bind+0x16>
    max_pcb_list = NUM_TCP_PCB_LISTS_NO_TIME_WAIT;
  }
#endif /* SO_REUSE */

  if (port == 0) {
    port = tcp_new_port();
 8009526:	f7ff ff9d 	bl	8009464 <tcp_new_port>
    if (port == 0) {
 800952a:	4602      	mov	r2, r0
 800952c:	2800      	cmp	r0, #0
 800952e:	d1d2      	bne.n	80094d6 <tcp_bind+0xe>
      return ERR_BUF;
 8009530:	f06f 0001 	mvn.w	r0, #1
 8009534:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
{
  int i;
  int max_pcb_list = NUM_TCP_PCB_LISTS;
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
 8009536:	4b08      	ldr	r3, [pc, #32]	; (8009558 <tcp_bind+0x90>)
 8009538:	f240 12b7 	movw	r2, #439	; 0x1b7
 800953c:	4907      	ldr	r1, [pc, #28]	; (800955c <tcp_bind+0x94>)
 800953e:	4808      	ldr	r0, [pc, #32]	; (8009560 <tcp_bind+0x98>)
 8009540:	f00b fc1a 	bl	8014d78 <iprintf>
 8009544:	f06f 0005 	mvn.w	r0, #5
 8009548:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800954a:	bf00      	nop
 800954c:	08016130 	.word	0x08016130
 8009550:	2000f048 	.word	0x2000f048
 8009554:	2000f050 	.word	0x2000f050
 8009558:	080166c8 	.word	0x080166c8
 800955c:	080166d8 	.word	0x080166d8
 8009560:	0801660c 	.word	0x0801660c

08009564 <tcp_listen_with_backlog>:
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
 8009564:	b538      	push	{r3, r4, r5, lr}
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
 8009566:	7e03      	ldrb	r3, [r0, #24]
 8009568:	2b00      	cmp	r3, #0
 800956a:	d142      	bne.n	80095f2 <tcp_listen_with_backlog+0x8e>
 800956c:	4604      	mov	r4, r0
        }
      }
    }
  }
#endif /* SO_REUSE */
  lpcb = (struct tcp_pcb_listen *)memp_malloc(MEMP_TCP_PCB_LISTEN);
 800956e:	2003      	movs	r0, #3
 8009570:	f006 fb8e 	bl	800fc90 <memp_malloc>
  if (lpcb == NULL) {
 8009574:	4605      	mov	r5, r0
 8009576:	2800      	cmp	r0, #0
 8009578:	d042      	beq.n	8009600 <tcp_listen_with_backlog+0x9c>
    return NULL;
  }
  lpcb->callback_arg = pcb->callback_arg;
  lpcb->local_port = pcb->local_port;
 800957a:	8b62      	ldrh	r2, [r4, #26]
#endif /* SO_REUSE */
  lpcb = (struct tcp_pcb_listen *)memp_malloc(MEMP_TCP_PCB_LISTEN);
  if (lpcb == NULL) {
    return NULL;
  }
  lpcb->callback_arg = pcb->callback_arg;
 800957c:	6921      	ldr	r1, [r4, #16]
  lpcb->local_port = pcb->local_port;
  lpcb->state = LISTEN;
 800957e:	2301      	movs	r3, #1
  lpcb = (struct tcp_pcb_listen *)memp_malloc(MEMP_TCP_PCB_LISTEN);
  if (lpcb == NULL) {
    return NULL;
  }
  lpcb->callback_arg = pcb->callback_arg;
  lpcb->local_port = pcb->local_port;
 8009580:	8342      	strh	r2, [r0, #26]
#endif /* SO_REUSE */
  lpcb = (struct tcp_pcb_listen *)memp_malloc(MEMP_TCP_PCB_LISTEN);
  if (lpcb == NULL) {
    return NULL;
  }
  lpcb->callback_arg = pcb->callback_arg;
 8009582:	6101      	str	r1, [r0, #16]
  lpcb->local_port = pcb->local_port;
  lpcb->state = LISTEN;
 8009584:	7603      	strb	r3, [r0, #24]
  lpcb->prio = pcb->prio;
 8009586:	7e63      	ldrb	r3, [r4, #25]
 8009588:	7643      	strb	r3, [r0, #25]
  lpcb->so_options = pcb->so_options;
  ip_set_option(lpcb, SOF_ACCEPTCONN);
 800958a:	7a23      	ldrb	r3, [r4, #8]
 800958c:	f043 0302 	orr.w	r3, r3, #2
 8009590:	7203      	strb	r3, [r0, #8]
  lpcb->ttl = pcb->ttl;
 8009592:	7aa3      	ldrb	r3, [r4, #10]
 8009594:	7283      	strb	r3, [r0, #10]
  lpcb->tos = pcb->tos;
 8009596:	7a63      	ldrb	r3, [r4, #9]
 8009598:	7243      	strb	r3, [r0, #9]
  ip_addr_copy(lpcb->local_ip, pcb->local_ip);
 800959a:	6822      	ldr	r2, [r4, #0]
  if (pcb->local_port != 0) {
 800959c:	8b63      	ldrh	r3, [r4, #26]
  lpcb->prio = pcb->prio;
  lpcb->so_options = pcb->so_options;
  ip_set_option(lpcb, SOF_ACCEPTCONN);
  lpcb->ttl = pcb->ttl;
  lpcb->tos = pcb->tos;
  ip_addr_copy(lpcb->local_ip, pcb->local_ip);
 800959e:	6002      	str	r2, [r0, #0]
  if (pcb->local_port != 0) {
 80095a0:	b19b      	cbz	r3, 80095ca <tcp_listen_with_backlog+0x66>
    TCP_RMV(&tcp_bound_pcbs, pcb);
 80095a2:	4b1b      	ldr	r3, [pc, #108]	; (8009610 <tcp_listen_with_backlog+0xac>)
 80095a4:	681a      	ldr	r2, [r3, #0]
 80095a6:	4294      	cmp	r4, r2
 80095a8:	d02e      	beq.n	8009608 <tcp_listen_with_backlog+0xa4>
 80095aa:	491a      	ldr	r1, [pc, #104]	; (8009614 <tcp_listen_with_backlog+0xb0>)
 80095ac:	600a      	str	r2, [r1, #0]
 80095ae:	b152      	cbz	r2, 80095c6 <tcp_listen_with_backlog+0x62>
 80095b0:	68d3      	ldr	r3, [r2, #12]
 80095b2:	429c      	cmp	r4, r3
 80095b4:	d026      	beq.n	8009604 <tcp_listen_with_backlog+0xa0>
 80095b6:	b12b      	cbz	r3, 80095c4 <tcp_listen_with_backlog+0x60>
 80095b8:	68da      	ldr	r2, [r3, #12]
 80095ba:	4294      	cmp	r4, r2
 80095bc:	d013      	beq.n	80095e6 <tcp_listen_with_backlog+0x82>
 80095be:	4613      	mov	r3, r2
 80095c0:	2b00      	cmp	r3, #0
 80095c2:	d1f9      	bne.n	80095b8 <tcp_listen_with_backlog+0x54>
 80095c4:	600b      	str	r3, [r1, #0]
 80095c6:	2300      	movs	r3, #0
 80095c8:	60e3      	str	r3, [r4, #12]
  }
  memp_free(MEMP_TCP_PCB, pcb);
 80095ca:	4621      	mov	r1, r4
 80095cc:	2002      	movs	r0, #2
 80095ce:	f006 fb95 	bl	800fcfc <memp_free>
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.pcbs, (struct tcp_pcb *)lpcb);
 80095d2:	4b11      	ldr	r3, [pc, #68]	; (8009618 <tcp_listen_with_backlog+0xb4>)
  if (pcb->local_port != 0) {
    TCP_RMV(&tcp_bound_pcbs, pcb);
  }
  memp_free(MEMP_TCP_PCB, pcb);
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
 80095d4:	4911      	ldr	r1, [pc, #68]	; (800961c <tcp_listen_with_backlog+0xb8>)
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.pcbs, (struct tcp_pcb *)lpcb);
 80095d6:	681a      	ldr	r2, [r3, #0]
  if (pcb->local_port != 0) {
    TCP_RMV(&tcp_bound_pcbs, pcb);
  }
  memp_free(MEMP_TCP_PCB, pcb);
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
 80095d8:	6169      	str	r1, [r5, #20]
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.pcbs, (struct tcp_pcb *)lpcb);
 80095da:	60ea      	str	r2, [r5, #12]
 80095dc:	601d      	str	r5, [r3, #0]
 80095de:	f002 f825 	bl	800b62c <tcp_timer_needed>
  return (struct tcp_pcb *)lpcb;
 80095e2:	4628      	mov	r0, r5
 80095e4:	bd38      	pop	{r3, r4, r5, pc}
 80095e6:	600b      	str	r3, [r1, #0]
  ip_set_option(lpcb, SOF_ACCEPTCONN);
  lpcb->ttl = pcb->ttl;
  lpcb->tos = pcb->tos;
  ip_addr_copy(lpcb->local_ip, pcb->local_ip);
  if (pcb->local_port != 0) {
    TCP_RMV(&tcp_bound_pcbs, pcb);
 80095e8:	68e2      	ldr	r2, [r4, #12]
 80095ea:	60da      	str	r2, [r3, #12]
 80095ec:	2300      	movs	r3, #0
 80095ee:	60e3      	str	r3, [r4, #12]
 80095f0:	e7eb      	b.n	80095ca <tcp_listen_with_backlog+0x66>
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
 80095f2:	4b0b      	ldr	r3, [pc, #44]	; (8009620 <tcp_listen_with_backlog+0xbc>)
 80095f4:	f44f 7203 	mov.w	r2, #524	; 0x20c
 80095f8:	490a      	ldr	r1, [pc, #40]	; (8009624 <tcp_listen_with_backlog+0xc0>)
 80095fa:	480b      	ldr	r0, [pc, #44]	; (8009628 <tcp_listen_with_backlog+0xc4>)
 80095fc:	f00b fbbc 	bl	8014d78 <iprintf>
 8009600:	2000      	movs	r0, #0
 8009602:	bd38      	pop	{r3, r4, r5, pc}
  ip_set_option(lpcb, SOF_ACCEPTCONN);
  lpcb->ttl = pcb->ttl;
  lpcb->tos = pcb->tos;
  ip_addr_copy(lpcb->local_ip, pcb->local_ip);
  if (pcb->local_port != 0) {
    TCP_RMV(&tcp_bound_pcbs, pcb);
 8009604:	4613      	mov	r3, r2
 8009606:	e7ef      	b.n	80095e8 <tcp_listen_with_backlog+0x84>
 8009608:	68e2      	ldr	r2, [r4, #12]
 800960a:	601a      	str	r2, [r3, #0]
 800960c:	e7db      	b.n	80095c6 <tcp_listen_with_backlog+0x62>
 800960e:	bf00      	nop
 8009610:	2000f050 	.word	0x2000f050
 8009614:	2000f04c 	.word	0x2000f04c
 8009618:	2000f048 	.word	0x2000f048
 800961c:	0800945d 	.word	0x0800945d
 8009620:	080166c8 	.word	0x080166c8
 8009624:	08016700 	.word	0x08016700
 8009628:	0801660c 	.word	0x0801660c

0800962c <tcp_update_rcv_ann_wnd>:
 *
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
 800962c:	4603      	mov	r3, r0
 800962e:	b570      	push	{r4, r5, r6, lr}
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
 8009630:	f240 56b4 	movw	r6, #1460	; 0x5b4
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
 8009634:	8d84      	ldrh	r4, [r0, #44]	; 0x2c

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
 8009636:	6b01      	ldr	r1, [r0, #48]	; 0x30
 8009638:	8eda      	ldrh	r2, [r3, #54]	; 0x36
 * Returns how much extra window would be advertised if we sent an
 * update now.
 */
u32_t tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
{
  u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
 800963a:	6a85      	ldr	r5, [r0, #40]	; 0x28
 800963c:	1a60      	subs	r0, r4, r1

  if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
 800963e:	42b2      	cmp	r2, r6
 8009640:	4428      	add	r0, r5
 8009642:	bf94      	ite	ls
 8009644:	1a82      	subls	r2, r0, r2
 8009646:	1b82      	subhi	r2, r0, r6
 8009648:	2a00      	cmp	r2, #0
 800964a:	db01      	blt.n	8009650 <tcp_update_rcv_ann_wnd+0x24>
    /* we can advertise more window */
    pcb->rcv_ann_wnd = pcb->rcv_wnd;
 800964c:	85dc      	strh	r4, [r3, #46]	; 0x2e
    return new_right_edge - pcb->rcv_ann_right_edge;
 800964e:	bd70      	pop	{r4, r5, r6, pc}
  } else {
    if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
 8009650:	1a6a      	subs	r2, r5, r1
 8009652:	2a00      	cmp	r2, #0
 8009654:	dd02      	ble.n	800965c <tcp_update_rcv_ann_wnd+0x30>
      /* Can happen due to other end sending out of advertised window,
       * but within actual available (but not yet advertised) window */
      pcb->rcv_ann_wnd = 0;
 8009656:	2000      	movs	r0, #0
 8009658:	85d8      	strh	r0, [r3, #46]	; 0x2e
 800965a:	bd70      	pop	{r4, r5, r6, pc}
    } else {
      /* keep the right edge of window constant */
      u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
 800965c:	1b4d      	subs	r5, r1, r5
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
 800965e:	f5b5 3f80 	cmp.w	r5, #65536	; 0x10000
 8009662:	461c      	mov	r4, r3
 8009664:	d202      	bcs.n	800966c <tcp_update_rcv_ann_wnd+0x40>
      pcb->rcv_ann_wnd = (u16_t)new_rcv_ann_wnd;
 8009666:	85e5      	strh	r5, [r4, #46]	; 0x2e
    }
    return 0;
 8009668:	2000      	movs	r0, #0
  }
}
 800966a:	bd70      	pop	{r4, r5, r6, pc}
       * but within actual available (but not yet advertised) window */
      pcb->rcv_ann_wnd = 0;
    } else {
      /* keep the right edge of window constant */
      u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
      LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
 800966c:	4b03      	ldr	r3, [pc, #12]	; (800967c <tcp_update_rcv_ann_wnd+0x50>)
 800966e:	f240 2253 	movw	r2, #595	; 0x253
 8009672:	4903      	ldr	r1, [pc, #12]	; (8009680 <tcp_update_rcv_ann_wnd+0x54>)
 8009674:	4803      	ldr	r0, [pc, #12]	; (8009684 <tcp_update_rcv_ann_wnd+0x58>)
 8009676:	f00b fb7f 	bl	8014d78 <iprintf>
 800967a:	e7f4      	b.n	8009666 <tcp_update_rcv_ann_wnd+0x3a>
 800967c:	080166c8 	.word	0x080166c8
 8009680:	08016724 	.word	0x08016724
 8009684:	0801660c 	.word	0x0801660c

08009688 <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
 8009688:	b538      	push	{r3, r4, r5, lr}
  int wnd_inflation;

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
 800968a:	7e03      	ldrb	r3, [r0, #24]
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
 800968c:	4604      	mov	r4, r0
  int wnd_inflation;

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
 800968e:	2b01      	cmp	r3, #1
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
 8009690:	460d      	mov	r5, r1
  int wnd_inflation;

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
 8009692:	d027      	beq.n	80096e4 <tcp_recved+0x5c>
    pcb->state != LISTEN);
  LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
 8009694:	8da1      	ldrh	r1, [r4, #44]	; 0x2c
 8009696:	f5c1 437f 	rsb	r3, r1, #65280	; 0xff00
 800969a:	33ff      	adds	r3, #255	; 0xff
 800969c:	429d      	cmp	r5, r3
 800969e:	dc18      	bgt.n	80096d2 <tcp_recved+0x4a>
              len <= 0xffff - pcb->rcv_wnd );

  pcb->rcv_wnd += len;
  if (pcb->rcv_wnd > TCP_WND) {
 80096a0:	f640 3368 	movw	r3, #2920	; 0xb68
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
    pcb->state != LISTEN);
  LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
              len <= 0xffff - pcb->rcv_wnd );

  pcb->rcv_wnd += len;
 80096a4:	4429      	add	r1, r5
 80096a6:	b289      	uxth	r1, r1
  if (pcb->rcv_wnd > TCP_WND) {
 80096a8:	4299      	cmp	r1, r3
    pcb->rcv_wnd = TCP_WND;
 80096aa:	bf8c      	ite	hi
 80096ac:	85a3      	strhhi	r3, [r4, #44]	; 0x2c
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
    pcb->state != LISTEN);
  LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
              len <= 0xffff - pcb->rcv_wnd );

  pcb->rcv_wnd += len;
 80096ae:	85a1      	strhls	r1, [r4, #44]	; 0x2c
  if (pcb->rcv_wnd > TCP_WND) {
    pcb->rcv_wnd = TCP_WND;
  }

  wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
 80096b0:	4620      	mov	r0, r4
 80096b2:	f7ff ffbb 	bl	800962c <tcp_update_rcv_ann_wnd>

  /* If the change in the right edge of window is significant (default
   * watermark is TCP_WND/4), then send an explicit update now.
   * Otherwise wait for a packet to be sent in the normal course of
   * events (or more window to be available later) */
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
 80096b6:	f240 23d9 	movw	r3, #729	; 0x2d9
 80096ba:	4298      	cmp	r0, r3
 80096bc:	dc00      	bgt.n	80096c0 <tcp_recved+0x38>
 80096be:	bd38      	pop	{r3, r4, r5, pc}
    tcp_ack_now(pcb);
 80096c0:	7fa3      	ldrb	r3, [r4, #30]
    tcp_output(pcb);
 80096c2:	4620      	mov	r0, r4
  /* If the change in the right edge of window is significant (default
   * watermark is TCP_WND/4), then send an explicit update now.
   * Otherwise wait for a packet to be sent in the normal course of
   * events (or more window to be available later) */
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
    tcp_ack_now(pcb);
 80096c4:	f043 0302 	orr.w	r3, r3, #2
 80096c8:	77a3      	strb	r3, [r4, #30]
    tcp_output(pcb);
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
 80096ca:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   * watermark is TCP_WND/4), then send an explicit update now.
   * Otherwise wait for a packet to be sent in the normal course of
   * events (or more window to be available later) */
  if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
    tcp_ack_now(pcb);
    tcp_output(pcb);
 80096ce:	f001 bb47 	b.w	800ad60 <tcp_output>
  int wnd_inflation;

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
    pcb->state != LISTEN);
  LWIP_ASSERT("tcp_recved: len would wrap rcv_wnd\n",
 80096d2:	4908      	ldr	r1, [pc, #32]	; (80096f4 <tcp_recved+0x6c>)
 80096d4:	4b08      	ldr	r3, [pc, #32]	; (80096f8 <tcp_recved+0x70>)
 80096d6:	f240 226b 	movw	r2, #619	; 0x26b
 80096da:	4808      	ldr	r0, [pc, #32]	; (80096fc <tcp_recved+0x74>)
 80096dc:	f00b fb4c 	bl	8014d78 <iprintf>
 80096e0:	8da1      	ldrh	r1, [r4, #44]	; 0x2c
 80096e2:	e7dd      	b.n	80096a0 <tcp_recved+0x18>
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
  int wnd_inflation;

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
 80096e4:	4b04      	ldr	r3, [pc, #16]	; (80096f8 <tcp_recved+0x70>)
 80096e6:	f240 2269 	movw	r2, #617	; 0x269
 80096ea:	4905      	ldr	r1, [pc, #20]	; (8009700 <tcp_recved+0x78>)
 80096ec:	4803      	ldr	r0, [pc, #12]	; (80096fc <tcp_recved+0x74>)
 80096ee:	f00b fb43 	bl	8014d78 <iprintf>
 80096f2:	e7cf      	b.n	8009694 <tcp_recved+0xc>
 80096f4:	08016768 	.word	0x08016768
 80096f8:	080166c8 	.word	0x080166c8
 80096fc:	0801660c 	.word	0x0801660c
 8009700:	08016740 	.word	0x08016740

08009704 <tcp_connect>:
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, ip_addr_t *ipaddr, u16_t port,
      tcp_connected_fn connected)
{
 8009704:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8009706:	4604      	mov	r4, r0
  err_t ret;
  u32_t iss;
  u16_t old_local_port;

  LWIP_ERROR("tcp_connect: can only connect from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
 8009708:	7e00      	ldrb	r0, [r0, #24]
 800970a:	2800      	cmp	r0, #0
 800970c:	f040 8085 	bne.w	800981a <tcp_connect+0x116>
 8009710:	460d      	mov	r5, r1

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
 8009712:	2900      	cmp	r1, #0
 8009714:	f000 808b 	beq.w	800982e <tcp_connect+0x12a>
    pcb->remote_ip = *ipaddr;
 8009718:	6809      	ldr	r1, [r1, #0]
 800971a:	461f      	mov	r7, r3
    return ERR_VAL;
  }
  pcb->remote_port = port;

  /* check if we have a route to the remote host */
  if (ip_addr_isany(&(pcb->local_ip))) {
 800971c:	6823      	ldr	r3, [r4, #0]

  LWIP_ERROR("tcp_connect: can only connect from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
    pcb->remote_ip = *ipaddr;
 800971e:	6061      	str	r1, [r4, #4]
  } else {
    return ERR_VAL;
  }
  pcb->remote_port = port;
 8009720:	83a2      	strh	r2, [r4, #28]

  /* check if we have a route to the remote host */
  if (ip_addr_isany(&(pcb->local_ip))) {
 8009722:	b93b      	cbnz	r3, 8009734 <tcp_connect+0x30>
    /* no local IP address set, yet. */
    struct netif *netif = ip_route(&(pcb->remote_ip));
 8009724:	1d20      	adds	r0, r4, #4
 8009726:	f005 f953 	bl	800e9d0 <ip_route>
    if (netif == NULL) {
 800972a:	2800      	cmp	r0, #0
 800972c:	f000 8082 	beq.w	8009834 <tcp_connect+0x130>
      /* Don't even try to send a SYN packet if we have no route
         since that will fail. */
      return ERR_RTE;
    }
    /* Use the netif's IP address as local address. */
    ip_addr_copy(pcb->local_ip, netif->ip_addr);
 8009730:	6843      	ldr	r3, [r0, #4]
 8009732:	6023      	str	r3, [r4, #0]
  }

  old_local_port = pcb->local_port;
 8009734:	8b66      	ldrh	r6, [r4, #26]
  if (pcb->local_port == 0) {
 8009736:	2e00      	cmp	r6, #0
 8009738:	d052      	beq.n	80097e0 <tcp_connect+0xdc>
  iss = tcp_next_iss();
  pcb->rcv_nxt = 0;
  pcb->snd_nxt = iss;
  pcb->lastack = iss - 1;
  pcb->snd_lbb = iss - 1;
  pcb->rcv_wnd = TCP_WND;
 800973a:	f640 3268 	movw	r2, #2920	; 0xb68
u32_t
tcp_next_iss(void)
{
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
 800973e:	f8df e11c 	ldr.w	lr, [pc, #284]	; 800985c <tcp_connect+0x158>
 8009742:	4b3e      	ldr	r3, [pc, #248]	; (800983c <tcp_connect+0x138>)
 8009744:	f8de 1004 	ldr.w	r1, [lr, #4]
 8009748:	681b      	ldr	r3, [r3, #0]
tcp_eff_send_mss(u16_t sendmss, ip_addr_t *addr)
{
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
 800974a:	4628      	mov	r0, r5
u32_t
tcp_next_iss(void)
{
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
 800974c:	440b      	add	r3, r1
  }
#endif /* SO_REUSE */
  iss = tcp_next_iss();
  pcb->rcv_nxt = 0;
  pcb->snd_nxt = iss;
  pcb->lastack = iss - 1;
 800974e:	1e59      	subs	r1, r3, #1
 8009750:	64a1      	str	r1, [r4, #72]	; 0x48
  pcb->snd_lbb = iss - 1;
 8009752:	65e1      	str	r1, [r4, #92]	; 0x5c
  pcb->rcv_ann_wnd = TCP_WND;
  pcb->rcv_ann_right_edge = pcb->rcv_nxt;
  pcb->snd_wnd = TCP_WND;
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
 8009754:	f44f 7506 	mov.w	r5, #536	; 0x218
      }
    }
  }
#endif /* SO_REUSE */
  iss = tcp_next_iss();
  pcb->rcv_nxt = 0;
 8009758:	2100      	movs	r1, #0
  pcb->snd_nxt = iss;
 800975a:	6523      	str	r3, [r4, #80]	; 0x50
  pcb->lastack = iss - 1;
  pcb->snd_lbb = iss - 1;
  pcb->rcv_wnd = TCP_WND;
 800975c:	85a2      	strh	r2, [r4, #44]	; 0x2c
  pcb->rcv_ann_wnd = TCP_WND;
 800975e:	85e2      	strh	r2, [r4, #46]	; 0x2e
  pcb->rcv_ann_right_edge = pcb->rcv_nxt;
  pcb->snd_wnd = TCP_WND;
 8009760:	f8a4 2060 	strh.w	r2, [r4, #96]	; 0x60
      }
    }
  }
#endif /* SO_REUSE */
  iss = tcp_next_iss();
  pcb->rcv_nxt = 0;
 8009764:	62a1      	str	r1, [r4, #40]	; 0x28
  pcb->snd_nxt = iss;
  pcb->lastack = iss - 1;
  pcb->snd_lbb = iss - 1;
  pcb->rcv_wnd = TCP_WND;
  pcb->rcv_ann_wnd = TCP_WND;
  pcb->rcv_ann_right_edge = pcb->rcv_nxt;
 8009766:	6321      	str	r1, [r4, #48]	; 0x30
  pcb->snd_wnd = TCP_WND;
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
 8009768:	86e5      	strh	r5, [r4, #54]	; 0x36
u32_t
tcp_next_iss(void)
{
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
 800976a:	f8ce 3004 	str.w	r3, [lr, #4]
tcp_eff_send_mss(u16_t sendmss, ip_addr_t *addr)
{
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
 800976e:	f005 f92f 	bl	800e9d0 <ip_route>
  if ((outif != NULL) && (outif->mtu != 0)) {
 8009772:	b110      	cbz	r0, 800977a <tcp_connect+0x76>
 8009774:	8c03      	ldrh	r3, [r0, #32]
 8009776:	2b00      	cmp	r3, #0
 8009778:	d13a      	bne.n	80097f0 <tcp_connect+0xec>
 800977a:	462b      	mov	r3, r5
 800977c:	f241 42f0 	movw	r2, #5360	; 0x14f0
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
 8009780:	2101      	movs	r1, #1
 8009782:	f8a4 104c 	strh.w	r1, [r4, #76]	; 0x4c
  pcb->snd_wnd = TCP_WND;
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
 8009786:	86e3      	strh	r3, [r4, #54]	; 0x36
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
  pcb->ssthresh = pcb->mss * 10;
 8009788:	f8a4 204e 	strh.w	r2, [r4, #78]	; 0x4e
#if LWIP_CALLBACK_API
  pcb->connected = connected;
 800978c:	f8c4 7080 	str.w	r7, [r4, #128]	; 0x80
#else /* LWIP_CALLBACK_API */  
  LWIP_UNUSED_ARG(connected);
#endif /* LWIP_CALLBACK_API */

  /* Send a SYN together with the MSS option. */
  ret = tcp_enqueue_flags(pcb, TCP_SYN);
 8009790:	2102      	movs	r1, #2
 8009792:	4620      	mov	r0, r4
 8009794:	f001 f9e2 	bl	800ab5c <tcp_enqueue_flags>
  if (ret == ERR_OK) {
 8009798:	bb48      	cbnz	r0, 80097ee <tcp_connect+0xea>
    /* SYN segment was enqueued, changed the pcbs state now */
    pcb->state = SYN_SENT;
 800979a:	2302      	movs	r3, #2
 800979c:	7623      	strb	r3, [r4, #24]
    if (old_local_port != 0) {
 800979e:	b18e      	cbz	r6, 80097c4 <tcp_connect+0xc0>
      TCP_RMV(&tcp_bound_pcbs, pcb);
 80097a0:	4b27      	ldr	r3, [pc, #156]	; (8009840 <tcp_connect+0x13c>)
 80097a2:	681a      	ldr	r2, [r3, #0]
 80097a4:	4294      	cmp	r4, r2
 80097a6:	d035      	beq.n	8009814 <tcp_connect+0x110>
 80097a8:	4926      	ldr	r1, [pc, #152]	; (8009844 <tcp_connect+0x140>)
 80097aa:	600a      	str	r2, [r1, #0]
 80097ac:	b152      	cbz	r2, 80097c4 <tcp_connect+0xc0>
 80097ae:	68d3      	ldr	r3, [r2, #12]
 80097b0:	429c      	cmp	r4, r3
 80097b2:	d02d      	beq.n	8009810 <tcp_connect+0x10c>
 80097b4:	b12b      	cbz	r3, 80097c2 <tcp_connect+0xbe>
 80097b6:	68da      	ldr	r2, [r3, #12]
 80097b8:	4294      	cmp	r4, r2
 80097ba:	d025      	beq.n	8009808 <tcp_connect+0x104>
 80097bc:	4613      	mov	r3, r2
 80097be:	2b00      	cmp	r3, #0
 80097c0:	d1f9      	bne.n	80097b6 <tcp_connect+0xb2>
 80097c2:	600b      	str	r3, [r1, #0]
    }
    TCP_REG_ACTIVE(pcb);
 80097c4:	4b20      	ldr	r3, [pc, #128]	; (8009848 <tcp_connect+0x144>)
 80097c6:	681a      	ldr	r2, [r3, #0]
 80097c8:	601c      	str	r4, [r3, #0]
 80097ca:	60e2      	str	r2, [r4, #12]
 80097cc:	f001 ff2e 	bl	800b62c <tcp_timer_needed>
 80097d0:	4b1e      	ldr	r3, [pc, #120]	; (800984c <tcp_connect+0x148>)
 80097d2:	2201      	movs	r2, #1
    snmp_inc_tcpactiveopens();

    tcp_output(pcb);
 80097d4:	4620      	mov	r0, r4
    /* SYN segment was enqueued, changed the pcbs state now */
    pcb->state = SYN_SENT;
    if (old_local_port != 0) {
      TCP_RMV(&tcp_bound_pcbs, pcb);
    }
    TCP_REG_ACTIVE(pcb);
 80097d6:	701a      	strb	r2, [r3, #0]
    snmp_inc_tcpactiveopens();

    tcp_output(pcb);
 80097d8:	f001 fac2 	bl	800ad60 <tcp_output>
 80097dc:	2000      	movs	r0, #0
 80097de:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ip_addr_copy(pcb->local_ip, netif->ip_addr);
  }

  old_local_port = pcb->local_port;
  if (pcb->local_port == 0) {
    pcb->local_port = tcp_new_port();
 80097e0:	f7ff fe40 	bl	8009464 <tcp_new_port>
 80097e4:	8360      	strh	r0, [r4, #26]
    if (pcb->local_port == 0) {
 80097e6:	2800      	cmp	r0, #0
 80097e8:	d1a7      	bne.n	800973a <tcp_connect+0x36>
      return ERR_BUF;
 80097ea:	f06f 0001 	mvn.w	r0, #1
    snmp_inc_tcpactiveopens();

    tcp_output(pcb);
  }
  return ret;
}
 80097ee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * We correct for TCP options in tcp_write(), and don't support IP options.
     */
    sendmss = LWIP_MIN(sendmss, mss_s);
 80097f0:	3b28      	subs	r3, #40	; 0x28
 80097f2:	b29b      	uxth	r3, r3
 80097f4:	f5b3 7f06 	cmp.w	r3, #536	; 0x218
 80097f8:	bf28      	it	cs
 80097fa:	f44f 7306 	movcs.w	r3, #536	; 0x218
 80097fe:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 8009802:	0052      	lsls	r2, r2, #1
 8009804:	b292      	uxth	r2, r2
 8009806:	e7bb      	b.n	8009780 <tcp_connect+0x7c>
 8009808:	600b      	str	r3, [r1, #0]
  ret = tcp_enqueue_flags(pcb, TCP_SYN);
  if (ret == ERR_OK) {
    /* SYN segment was enqueued, changed the pcbs state now */
    pcb->state = SYN_SENT;
    if (old_local_port != 0) {
      TCP_RMV(&tcp_bound_pcbs, pcb);
 800980a:	68e2      	ldr	r2, [r4, #12]
 800980c:	60da      	str	r2, [r3, #12]
 800980e:	e7d9      	b.n	80097c4 <tcp_connect+0xc0>
 8009810:	4613      	mov	r3, r2
 8009812:	e7fa      	b.n	800980a <tcp_connect+0x106>
 8009814:	68e2      	ldr	r2, [r4, #12]
 8009816:	601a      	str	r2, [r3, #0]
 8009818:	e7d4      	b.n	80097c4 <tcp_connect+0xc0>
{
  err_t ret;
  u32_t iss;
  u16_t old_local_port;

  LWIP_ERROR("tcp_connect: can only connect from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
 800981a:	4b0d      	ldr	r3, [pc, #52]	; (8009850 <tcp_connect+0x14c>)
 800981c:	f240 22b3 	movw	r2, #691	; 0x2b3
 8009820:	490c      	ldr	r1, [pc, #48]	; (8009854 <tcp_connect+0x150>)
 8009822:	480d      	ldr	r0, [pc, #52]	; (8009858 <tcp_connect+0x154>)
 8009824:	f00b faa8 	bl	8014d78 <iprintf>
 8009828:	f06f 0008 	mvn.w	r0, #8
 800982c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
    pcb->remote_ip = *ipaddr;
  } else {
    return ERR_VAL;
 800982e:	f06f 0005 	mvn.w	r0, #5
 8009832:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    /* no local IP address set, yet. */
    struct netif *netif = ip_route(&(pcb->remote_ip));
    if (netif == NULL) {
      /* Don't even try to send a SYN packet if we have no route
         since that will fail. */
      return ERR_RTE;
 8009834:	f06f 0003 	mvn.w	r0, #3
 8009838:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800983a:	bf00      	nop
 800983c:	2000f044 	.word	0x2000f044
 8009840:	2000f050 	.word	0x2000f050
 8009844:	2000f04c 	.word	0x2000f04c
 8009848:	2000f040 	.word	0x2000f040
 800984c:	2000f03c 	.word	0x2000f03c
 8009850:	080166c8 	.word	0x080166c8
 8009854:	0801678c 	.word	0x0801678c
 8009858:	0801660c 	.word	0x0801660c
 800985c:	20000024 	.word	0x20000024

08009860 <tcp_seg_free>:
 * @param seg single tcp_seg to free
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
  if (seg != NULL) {
 8009860:	b158      	cbz	r0, 800987a <tcp_seg_free+0x1a>
 *
 * @param seg single tcp_seg to free
 */
void
tcp_seg_free(struct tcp_seg *seg)
{
 8009862:	b510      	push	{r4, lr}
 8009864:	4604      	mov	r4, r0
  if (seg != NULL) {
    if (seg->p != NULL) {
 8009866:	6840      	ldr	r0, [r0, #4]
 8009868:	b108      	cbz	r0, 800986e <tcp_seg_free+0xe>
      pbuf_free(seg->p);
 800986a:	f006 fbdd 	bl	8010028 <pbuf_free>
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
 800986e:	4621      	mov	r1, r4
  }
}
 8009870:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      pbuf_free(seg->p);
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
 8009874:	2004      	movs	r0, #4
 8009876:	f006 ba41 	b.w	800fcfc <memp_free>
 800987a:	4770      	bx	lr

0800987c <tcp_segs_free>:
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 800987c:	b138      	cbz	r0, 800988e <tcp_segs_free+0x12>
 *
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
 800987e:	b510      	push	{r4, lr}
  while (seg != NULL) {
    struct tcp_seg *next = seg->next;
 8009880:	6804      	ldr	r4, [r0, #0]
    tcp_seg_free(seg);
 8009882:	f7ff ffed 	bl	8009860 <tcp_seg_free>
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 8009886:	4620      	mov	r0, r4
 8009888:	2c00      	cmp	r4, #0
 800988a:	d1f9      	bne.n	8009880 <tcp_segs_free+0x4>
 800988c:	bd10      	pop	{r4, pc}
 800988e:	4770      	bx	lr

08009890 <tcp_pcb_purge.part.1>:
 * (pcb->ooseq, pcb->unsent and pcb->unacked are freed).
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
 8009890:	b538      	push	{r3, r4, r5, lr}
 8009892:	4605      	mov	r5, r0
      }
    }
#endif /* TCP_LISTEN_BACKLOG */


    if (pcb->refused_data != NULL) {
 8009894:	6f40      	ldr	r0, [r0, #116]	; 0x74
 8009896:	b118      	cbz	r0, 80098a0 <tcp_pcb_purge.part.1+0x10>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
 8009898:	f006 fbc6 	bl	8010028 <pbuf_free>
      pcb->refused_data = NULL;
 800989c:	2300      	movs	r3, #0
 800989e:	676b      	str	r3, [r5, #116]	; 0x74
    pcb->ooseq = NULL;
#endif /* TCP_QUEUE_OOSEQ */

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
 80098a0:	f64f 73ff 	movw	r3, #65535	; 0xffff

    tcp_segs_free(pcb->unsent);
 80098a4:	6ee8      	ldr	r0, [r5, #108]	; 0x6c
    pcb->ooseq = NULL;
#endif /* TCP_QUEUE_OOSEQ */

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
 80098a6:	86ab      	strh	r3, [r5, #52]	; 0x34
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 80098a8:	b128      	cbz	r0, 80098b6 <tcp_pcb_purge.part.1+0x26>
    struct tcp_seg *next = seg->next;
 80098aa:	6804      	ldr	r4, [r0, #0]
    tcp_seg_free(seg);
 80098ac:	f7ff ffd8 	bl	8009860 <tcp_seg_free>
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 80098b0:	4620      	mov	r0, r4
 80098b2:	2c00      	cmp	r4, #0
 80098b4:	d1f9      	bne.n	80098aa <tcp_pcb_purge.part.1+0x1a>
    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;

    tcp_segs_free(pcb->unsent);
    tcp_segs_free(pcb->unacked);
 80098b6:	6f28      	ldr	r0, [r5, #112]	; 0x70
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 80098b8:	b128      	cbz	r0, 80098c6 <tcp_pcb_purge.part.1+0x36>
    struct tcp_seg *next = seg->next;
 80098ba:	6804      	ldr	r4, [r0, #0]
    tcp_seg_free(seg);
 80098bc:	f7ff ffd0 	bl	8009860 <tcp_seg_free>
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 80098c0:	4620      	mov	r0, r4
 80098c2:	2c00      	cmp	r4, #0
 80098c4:	d1f9      	bne.n	80098ba <tcp_pcb_purge.part.1+0x2a>
       queue if it fires */
    pcb->rtime = -1;

    tcp_segs_free(pcb->unsent);
    tcp_segs_free(pcb->unacked);
    pcb->unacked = pcb->unsent = NULL;
 80098c6:	2300      	movs	r3, #0
 80098c8:	66eb      	str	r3, [r5, #108]	; 0x6c
 80098ca:	672b      	str	r3, [r5, #112]	; 0x70
#if TCP_OVERSIZE
    pcb->unsent_oversize = 0;
 80098cc:	f8a5 306a 	strh.w	r3, [r5, #106]	; 0x6a
 80098d0:	bd38      	pop	{r3, r4, r5, pc}
 80098d2:	bf00      	nop

080098d4 <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
 80098d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  u8_t pcb_reset;       /* flag if a RST should be sent when removing */
  err_t err;

  err = ERR_OK;

  ++tcp_ticks;
 80098d8:	4ebe      	ldr	r6, [pc, #760]	; (8009bd4 <tcp_slowtmr+0x300>)
  ++tcp_timer_ctr;
 80098da:	4dbf      	ldr	r5, [pc, #764]	; (8009bd8 <tcp_slowtmr+0x304>)
  u8_t pcb_reset;       /* flag if a RST should be sent when removing */
  err_t err;

  err = ERR_OK;

  ++tcp_ticks;
 80098dc:	6832      	ldr	r2, [r6, #0]
  ++tcp_timer_ctr;
 80098de:	782b      	ldrb	r3, [r5, #0]
  u8_t pcb_reset;       /* flag if a RST should be sent when removing */
  err_t err;

  err = ERR_OK;

  ++tcp_ticks;
 80098e0:	3201      	adds	r2, #1
  ++tcp_timer_ctr;
 80098e2:	3301      	adds	r3, #1
 80098e4:	f8df 831c 	ldr.w	r8, [pc, #796]	; 8009c04 <tcp_slowtmr+0x330>
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
 80098e8:	b085      	sub	sp, #20
  u8_t pcb_reset;       /* flag if a RST should be sent when removing */
  err_t err;

  err = ERR_OK;

  ++tcp_ticks;
 80098ea:	6032      	str	r2, [r6, #0]
  ++tcp_timer_ctr;
 80098ec:	702b      	strb	r3, [r5, #0]

tcp_slowtmr_start:
  /* Steps through all of the active PCBs. */
  prev = NULL;
  pcb = tcp_active_pcbs;
 80098ee:	f8d8 4000 	ldr.w	r4, [r8]
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
 80098f2:	2c00      	cmp	r4, #0
 80098f4:	f000 8097 	beq.w	8009a26 <tcp_slowtmr+0x152>
 80098f8:	2700      	movs	r7, #0
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
 80098fa:	7e23      	ldrb	r3, [r4, #24]
 80098fc:	2b00      	cmp	r3, #0
 80098fe:	f000 80f3 	beq.w	8009ae8 <tcp_slowtmr+0x214>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
 8009902:	2b01      	cmp	r3, #1
 8009904:	f000 80fb 	beq.w	8009afe <tcp_slowtmr+0x22a>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
 8009908:	2b0a      	cmp	r3, #10
 800990a:	f000 8103 	beq.w	8009b14 <tcp_slowtmr+0x240>
    if (pcb->last_timer == tcp_timer_ctr) {
 800990e:	782a      	ldrb	r2, [r5, #0]
 8009910:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
 8009914:	4293      	cmp	r3, r2
 8009916:	f000 810a 	beq.w	8009b2e <tcp_slowtmr+0x25a>
    pcb->last_timer = tcp_timer_ctr;

    pcb_remove = 0;
    pcb_reset = 0;

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
 800991a:	7e23      	ldrb	r3, [r4, #24]
    if (pcb->last_timer == tcp_timer_ctr) {
      /* skip this pcb, we have already processed it */
      pcb = pcb->next;
      continue;
    }
    pcb->last_timer = tcp_timer_ctr;
 800991c:	f884 2021 	strb.w	r2, [r4, #33]	; 0x21

    pcb_remove = 0;
    pcb_reset = 0;

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
 8009920:	2b02      	cmp	r3, #2
 8009922:	f894 1046 	ldrb.w	r1, [r4, #70]	; 0x46
 8009926:	f000 80ab 	beq.w	8009a80 <tcp_slowtmr+0x1ac>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
 800992a:	290c      	cmp	r1, #12
 800992c:	f000 81a1 	beq.w	8009c72 <tcp_slowtmr+0x39e>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
 8009930:	f894 0091 	ldrb.w	r0, [r4, #145]	; 0x91
 8009934:	2800      	cmp	r0, #0
 8009936:	f000 80ff 	beq.w	8009b38 <tcp_slowtmr+0x264>
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
 800993a:	49a8      	ldr	r1, [pc, #672]	; (8009bdc <tcp_slowtmr+0x308>)
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
 800993c:	f894 2090 	ldrb.w	r2, [r4, #144]	; 0x90
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
 8009940:	4401      	add	r1, r0
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
 8009942:	3201      	adds	r2, #1
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
 8009944:	7bc9      	ldrb	r1, [r1, #15]
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
 8009946:	b2d2      	uxtb	r2, r2
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
 8009948:	4291      	cmp	r1, r2
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
 800994a:	f884 2090 	strb.w	r2, [r4, #144]	; 0x90
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
 800994e:	f200 813e 	bhi.w	8009bce <tcp_slowtmr+0x2fa>
          pcb->persist_cnt = 0;
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
 8009952:	2806      	cmp	r0, #6
      if (pcb->persist_backoff > 0) {
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
          pcb->persist_cnt = 0;
 8009954:	f04f 0300 	mov.w	r3, #0
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
            pcb->persist_backoff++;
 8009958:	bf98      	it	ls
 800995a:	3001      	addls	r0, #1
      if (pcb->persist_backoff > 0) {
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
          pcb->persist_cnt = 0;
 800995c:	f884 3090 	strb.w	r3, [r4, #144]	; 0x90
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
            pcb->persist_backoff++;
 8009960:	bf98      	it	ls
 8009962:	f884 0091 	strbls.w	r0, [r4, #145]	; 0x91
          }
          tcp_zero_window_probe(pcb);
 8009966:	4620      	mov	r0, r4
 8009968:	f001 fc5e 	bl	800b228 <tcp_zero_window_probe>
 800996c:	7e23      	ldrb	r3, [r4, #24]
      pcb = pcb->next;
      continue;
    }
    pcb->last_timer = tcp_timer_ctr;

    pcb_remove = 0;
 800996e:	2200      	movs	r2, #0
          tcp_rexmit_rto(pcb);
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
 8009970:	2b06      	cmp	r3, #6
 8009972:	f000 811c 	beq.w	8009bae <tcp_slowtmr+0x2da>
        }
      }
    }

    /* Check if KEEPALIVE should be sent */
    if(ip_get_option(pcb, SOF_KEEPALIVE) &&
 8009976:	7a21      	ldrb	r1, [r4, #8]
 8009978:	0709      	lsls	r1, r1, #28
 800997a:	f140 8087 	bpl.w	8009a8c <tcp_slowtmr+0x1b8>
 800997e:	2b04      	cmp	r3, #4
 8009980:	d002      	beq.n	8009988 <tcp_slowtmr+0xb4>
       ((pcb->state == ESTABLISHED) ||
 8009982:	2b07      	cmp	r3, #7
 8009984:	f040 8082 	bne.w	8009a8c <tcp_slowtmr+0x1b8>
        (pcb->state == CLOSE_WAIT))) {
      if((u32_t)(tcp_ticks - pcb->tmr) >
 8009988:	6831      	ldr	r1, [r6, #0]
         (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL)
 800998a:	f8d4 c08c 	ldr.w	ip, [r4, #140]	; 0x8c

    /* Check if KEEPALIVE should be sent */
    if(ip_get_option(pcb, SOF_KEEPALIVE) &&
       ((pcb->state == ESTABLISHED) ||
        (pcb->state == CLOSE_WAIT))) {
      if((u32_t)(tcp_ticks - pcb->tmr) >
 800998e:	9103      	str	r1, [sp, #12]
 8009990:	4893      	ldr	r0, [pc, #588]	; (8009be0 <tcp_slowtmr+0x30c>)
 8009992:	f50c 2124 	add.w	r1, ip, #671744	; 0xa4000
 8009996:	f601 41b8 	addw	r1, r1, #3256	; 0xcb8
 800999a:	fba0 0e01 	umull	r0, lr, r0, r1
 800999e:	6a60      	ldr	r0, [r4, #36]	; 0x24
 80099a0:	9903      	ldr	r1, [sp, #12]
 80099a2:	ebc0 0901 	rsb	r9, r0, r1
 80099a6:	ebb9 1f5e 	cmp.w	r9, lr, lsr #5
 80099aa:	f240 8164 	bls.w	8009c76 <tcp_slowtmr+0x3a2>
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
                                ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
                                ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
        
        ++pcb_remove;
 80099ae:	3201      	adds	r2, #1
 80099b0:	b2d2      	uxtb	r2, r2
        ++pcb_reset;
 80099b2:	f04f 0a01 	mov.w	sl, #1
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
 80099b6:	2b03      	cmp	r3, #3
 80099b8:	d06c      	beq.n	8009a94 <tcp_slowtmr+0x1c0>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
 80099ba:	2b09      	cmp	r3, #9
 80099bc:	f040 8124 	bne.w	8009c08 <tcp_slowtmr+0x334>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 80099c0:	6833      	ldr	r3, [r6, #0]
 80099c2:	6a61      	ldr	r1, [r4, #36]	; 0x24
 80099c4:	1a5b      	subs	r3, r3, r1
 80099c6:	2bf0      	cmp	r3, #240	; 0xf0
 80099c8:	d969      	bls.n	8009a9e <tcp_slowtmr+0x1ca>
 80099ca:	4620      	mov	r0, r4
 80099cc:	f7ff ff60 	bl	8009890 <tcp_pcb_purge.part.1>
      tcp_err_fn err_fn;
      void *err_arg;
      tcp_pcb_purge(pcb);
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
 80099d0:	f8d8 3000 	ldr.w	r3, [r8]
      struct tcp_pcb *pcb2;
      tcp_err_fn err_fn;
      void *err_arg;
      tcp_pcb_purge(pcb);
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
 80099d4:	2f00      	cmp	r7, #0
 80099d6:	f000 8125 	beq.w	8009c24 <tcp_slowtmr+0x350>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
 80099da:	42a3      	cmp	r3, r4
 80099dc:	f000 8185 	beq.w	8009cea <tcp_slowtmr+0x416>
        prev->next = pcb->next;
 80099e0:	68e3      	ldr	r3, [r4, #12]
 80099e2:	60fb      	str	r3, [r7, #12]
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
        tcp_active_pcbs = pcb->next;
      }

      if (pcb_reset) {
 80099e4:	f1ba 0f00 	cmp.w	sl, #0
 80099e8:	f040 812c 	bne.w	8009c44 <tcp_slowtmr+0x370>
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
          pcb->local_port, pcb->remote_port);
      }

      err_fn = pcb->errf;
 80099ec:	f8d4 9088 	ldr.w	r9, [r4, #136]	; 0x88
      err_arg = pcb->callback_arg;
      pcb2 = pcb;
      pcb = pcb->next;
      memp_free(MEMP_TCP_PCB, pcb2);
 80099f0:	4621      	mov	r1, r4
 80099f2:	2002      	movs	r0, #2

      tcp_active_pcbs_changed = 0;
 80099f4:	f8df a1fc 	ldr.w	sl, [pc, #508]	; 8009bf4 <tcp_slowtmr+0x320>
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
          pcb->local_port, pcb->remote_port);
      }

      err_fn = pcb->errf;
      err_arg = pcb->callback_arg;
 80099f8:	f8d4 b010 	ldr.w	fp, [r4, #16]
      pcb2 = pcb;
      pcb = pcb->next;
 80099fc:	68e4      	ldr	r4, [r4, #12]
      memp_free(MEMP_TCP_PCB, pcb2);
 80099fe:	f006 f97d 	bl	800fcfc <memp_free>

      tcp_active_pcbs_changed = 0;
 8009a02:	2200      	movs	r2, #0
 8009a04:	f88a 2000 	strb.w	r2, [sl]
      TCP_EVENT_ERR(err_fn, err_arg, ERR_ABRT);
 8009a08:	f1b9 0f00 	cmp.w	r9, #0
 8009a0c:	d008      	beq.n	8009a20 <tcp_slowtmr+0x14c>
 8009a0e:	4658      	mov	r0, fp
 8009a10:	f06f 0109 	mvn.w	r1, #9
 8009a14:	47c8      	blx	r9
      if (tcp_active_pcbs_changed) {
 8009a16:	f89a 3000 	ldrb.w	r3, [sl]
 8009a1a:	2b00      	cmp	r3, #0
 8009a1c:	f47f af67 	bne.w	80098ee <tcp_slowtmr+0x1a>
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
 8009a20:	2c00      	cmp	r4, #0
 8009a22:	f47f af6a 	bne.w	80098fa <tcp_slowtmr+0x26>
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;
  pcb = tcp_tw_pcbs;
 8009a26:	4f6f      	ldr	r7, [pc, #444]	; (8009be4 <tcp_slowtmr+0x310>)
  while (pcb != NULL) {
 8009a28:	2500      	movs	r5, #0
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;
  pcb = tcp_tw_pcbs;
 8009a2a:	683c      	ldr	r4, [r7, #0]
  while (pcb != NULL) {
 8009a2c:	b32c      	cbz	r4, 8009a7a <tcp_slowtmr+0x1a6>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 8009a2e:	7e23      	ldrb	r3, [r4, #24]
 8009a30:	2b0a      	cmp	r3, #10
 8009a32:	f000 8112 	beq.w	8009c5a <tcp_slowtmr+0x386>
 8009a36:	4b6c      	ldr	r3, [pc, #432]	; (8009be8 <tcp_slowtmr+0x314>)
 8009a38:	f240 32ee 	movw	r2, #1006	; 0x3ee
 8009a3c:	496b      	ldr	r1, [pc, #428]	; (8009bec <tcp_slowtmr+0x318>)
 8009a3e:	486c      	ldr	r0, [pc, #432]	; (8009bf0 <tcp_slowtmr+0x31c>)
 8009a40:	f00b f99a 	bl	8014d78 <iprintf>
    pcb_remove = 0;

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 8009a44:	6833      	ldr	r3, [r6, #0]
 8009a46:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8009a48:	1a9b      	subs	r3, r3, r2
 8009a4a:	2bf0      	cmp	r3, #240	; 0xf0
 8009a4c:	f240 810b 	bls.w	8009c66 <tcp_slowtmr+0x392>
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
 8009a50:	7e23      	ldrb	r3, [r4, #24]
 8009a52:	2b01      	cmp	r3, #1
 8009a54:	f200 8129 	bhi.w	8009caa <tcp_slowtmr+0x3d6>
    if (pcb_remove) {
      struct tcp_pcb *pcb2;
      tcp_pcb_purge(pcb);
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
 8009a58:	683b      	ldr	r3, [r7, #0]
    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
      struct tcp_pcb *pcb2;
      tcp_pcb_purge(pcb);
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
 8009a5a:	2d00      	cmp	r5, #0
 8009a5c:	f000 812f 	beq.w	8009cbe <tcp_slowtmr+0x3ea>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
 8009a60:	429c      	cmp	r4, r3
 8009a62:	f000 814a 	beq.w	8009cfa <tcp_slowtmr+0x426>
        prev->next = pcb->next;
 8009a66:	68e3      	ldr	r3, [r4, #12]
 8009a68:	60eb      	str	r3, [r5, #12]
 8009a6a:	68e3      	ldr	r3, [r4, #12]
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
        tcp_tw_pcbs = pcb->next;
      }
      pcb2 = pcb;
      pcb = pcb->next;
      memp_free(MEMP_TCP_PCB, pcb2);
 8009a6c:	4621      	mov	r1, r4
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
        tcp_tw_pcbs = pcb->next;
      }
      pcb2 = pcb;
      pcb = pcb->next;
 8009a6e:	461c      	mov	r4, r3
      memp_free(MEMP_TCP_PCB, pcb2);
 8009a70:	2002      	movs	r0, #2
 8009a72:	f006 f943 	bl	800fcfc <memp_free>

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
 8009a76:	2c00      	cmp	r4, #0
 8009a78:	d1d9      	bne.n	8009a2e <tcp_slowtmr+0x15a>
    } else {
      prev = pcb;
      pcb = pcb->next;
    }
  }
}
 8009a7a:	b005      	add	sp, #20
 8009a7c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    pcb->last_timer = tcp_timer_ctr;

    pcb_remove = 0;
    pcb_reset = 0;

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
 8009a80:	2906      	cmp	r1, #6
 8009a82:	d002      	beq.n	8009a8a <tcp_slowtmr+0x1b6>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
 8009a84:	290c      	cmp	r1, #12
 8009a86:	f47f af53 	bne.w	8009930 <tcp_slowtmr+0x5c>
        }
      }
    }

    /* Check if KEEPALIVE should be sent */
    if(ip_get_option(pcb, SOF_KEEPALIVE) &&
 8009a8a:	2201      	movs	r2, #1
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
 8009a8c:	2b03      	cmp	r3, #3
      continue;
    }
    pcb->last_timer = tcp_timer_ctr;

    pcb_remove = 0;
    pcb_reset = 0;
 8009a8e:	f04f 0a00 	mov.w	sl, #0
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
 8009a92:	d192      	bne.n	80099ba <tcp_slowtmr+0xe6>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
 8009a94:	6833      	ldr	r3, [r6, #0]
 8009a96:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8009a98:	1a5b      	subs	r3, r3, r1
 8009a9a:	2b28      	cmp	r3, #40	; 0x28
 8009a9c:	d895      	bhi.n	80099ca <tcp_slowtmr+0xf6>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
 8009a9e:	2a00      	cmp	r2, #0
 8009aa0:	d193      	bne.n	80099ca <tcp_slowtmr+0xf6>
      /* get the 'next' element now and work with 'prev' below (in case of abort) */
      prev = pcb;
      pcb = pcb->next;

      /* We check if we should poll the connection. */
      ++prev->polltmr;
 8009aa2:	7fe3      	ldrb	r3, [r4, #31]
      if (prev->polltmr >= prev->pollinterval) {
 8009aa4:	f894 2020 	ldrb.w	r2, [r4, #32]
      /* get the 'next' element now and work with 'prev' below (in case of abort) */
      prev = pcb;
      pcb = pcb->next;

      /* We check if we should poll the connection. */
      ++prev->polltmr;
 8009aa8:	3301      	adds	r3, #1
 8009aaa:	b2db      	uxtb	r3, r3
      if (prev->polltmr >= prev->pollinterval) {
 8009aac:	429a      	cmp	r2, r3
      /* get the 'next' element now and work with 'prev' below (in case of abort) */
      prev = pcb;
      pcb = pcb->next;

      /* We check if we should poll the connection. */
      ++prev->polltmr;
 8009aae:	77e3      	strb	r3, [r4, #31]
        goto tcp_slowtmr_start;
      }
    } else {
      /* get the 'next' element now and work with 'prev' below (in case of abort) */
      prev = pcb;
      pcb = pcb->next;
 8009ab0:	f8d4 a00c 	ldr.w	sl, [r4, #12]

      /* We check if we should poll the connection. */
      ++prev->polltmr;
      if (prev->polltmr >= prev->pollinterval) {
 8009ab4:	d812      	bhi.n	8009adc <tcp_slowtmr+0x208>
        prev->polltmr = 0;
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        tcp_active_pcbs_changed = 0;
 8009ab6:	4f4f      	ldr	r7, [pc, #316]	; (8009bf4 <tcp_slowtmr+0x320>)
        TCP_EVENT_POLL(prev, err);
 8009ab8:	f8d4 2084 	ldr.w	r2, [r4, #132]	; 0x84
      pcb = pcb->next;

      /* We check if we should poll the connection. */
      ++prev->polltmr;
      if (prev->polltmr >= prev->pollinterval) {
        prev->polltmr = 0;
 8009abc:	2300      	movs	r3, #0
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        tcp_active_pcbs_changed = 0;
 8009abe:	703b      	strb	r3, [r7, #0]
      pcb = pcb->next;

      /* We check if we should poll the connection. */
      ++prev->polltmr;
      if (prev->polltmr >= prev->pollinterval) {
        prev->polltmr = 0;
 8009ac0:	77e3      	strb	r3, [r4, #31]
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        tcp_active_pcbs_changed = 0;
        TCP_EVENT_POLL(prev, err);
 8009ac2:	2a00      	cmp	r2, #0
 8009ac4:	f000 8108 	beq.w	8009cd8 <tcp_slowtmr+0x404>
 8009ac8:	4621      	mov	r1, r4
 8009aca:	6920      	ldr	r0, [r4, #16]
 8009acc:	4790      	blx	r2
        if (tcp_active_pcbs_changed) {
 8009ace:	783b      	ldrb	r3, [r7, #0]
 8009ad0:	2b00      	cmp	r3, #0
 8009ad2:	f47f af0c 	bne.w	80098ee <tcp_slowtmr+0x1a>
          goto tcp_slowtmr_start;
        }
        /* if err == ERR_ABRT, 'prev' is already deallocated */
        if (err == ERR_OK) {
 8009ad6:	2800      	cmp	r0, #0
 8009ad8:	f000 80fe 	beq.w	8009cd8 <tcp_slowtmr+0x404>
 8009adc:	4627      	mov	r7, r4
        goto tcp_slowtmr_start;
      }
    } else {
      /* get the 'next' element now and work with 'prev' below (in case of abort) */
      prev = pcb;
      pcb = pcb->next;
 8009ade:	4654      	mov	r4, sl
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
 8009ae0:	2c00      	cmp	r4, #0
 8009ae2:	f47f af0a 	bne.w	80098fa <tcp_slowtmr+0x26>
 8009ae6:	e79e      	b.n	8009a26 <tcp_slowtmr+0x152>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
 8009ae8:	4b3f      	ldr	r3, [pc, #252]	; (8009be8 <tcp_slowtmr+0x314>)
 8009aea:	f240 322a 	movw	r2, #810	; 0x32a
 8009aee:	4942      	ldr	r1, [pc, #264]	; (8009bf8 <tcp_slowtmr+0x324>)
 8009af0:	483f      	ldr	r0, [pc, #252]	; (8009bf0 <tcp_slowtmr+0x31c>)
 8009af2:	f00b f941 	bl	8014d78 <iprintf>
 8009af6:	7e23      	ldrb	r3, [r4, #24]
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
 8009af8:	2b01      	cmp	r3, #1
 8009afa:	f47f af05 	bne.w	8009908 <tcp_slowtmr+0x34>
 8009afe:	4b3a      	ldr	r3, [pc, #232]	; (8009be8 <tcp_slowtmr+0x314>)
 8009b00:	f240 322b 	movw	r2, #811	; 0x32b
 8009b04:	493d      	ldr	r1, [pc, #244]	; (8009bfc <tcp_slowtmr+0x328>)
 8009b06:	483a      	ldr	r0, [pc, #232]	; (8009bf0 <tcp_slowtmr+0x31c>)
 8009b08:	f00b f936 	bl	8014d78 <iprintf>
 8009b0c:	7e23      	ldrb	r3, [r4, #24]
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
 8009b0e:	2b0a      	cmp	r3, #10
 8009b10:	f47f aefd 	bne.w	800990e <tcp_slowtmr+0x3a>
 8009b14:	4b34      	ldr	r3, [pc, #208]	; (8009be8 <tcp_slowtmr+0x314>)
 8009b16:	f44f 724b 	mov.w	r2, #812	; 0x32c
 8009b1a:	4939      	ldr	r1, [pc, #228]	; (8009c00 <tcp_slowtmr+0x32c>)
 8009b1c:	4834      	ldr	r0, [pc, #208]	; (8009bf0 <tcp_slowtmr+0x31c>)
 8009b1e:	f00b f92b 	bl	8014d78 <iprintf>
    if (pcb->last_timer == tcp_timer_ctr) {
 8009b22:	782a      	ldrb	r2, [r5, #0]
 8009b24:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
 8009b28:	4293      	cmp	r3, r2
 8009b2a:	f47f aef6 	bne.w	800991a <tcp_slowtmr+0x46>
      /* skip this pcb, we have already processed it */
      pcb = pcb->next;
 8009b2e:	68e4      	ldr	r4, [r4, #12]
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
 8009b30:	2c00      	cmp	r4, #0
 8009b32:	f47f aee2 	bne.w	80098fa <tcp_slowtmr+0x26>
 8009b36:	e776      	b.n	8009a26 <tcp_slowtmr+0x152>
          }
          tcp_zero_window_probe(pcb);
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0) {
 8009b38:	f9b4 2034 	ldrsh.w	r2, [r4, #52]	; 0x34
 8009b3c:	2a00      	cmp	r2, #0
          ++pcb->rtime;
 8009b3e:	bfa4      	itt	ge
 8009b40:	3201      	addge	r2, #1
 8009b42:	86a2      	strhge	r2, [r4, #52]	; 0x34
        }

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
 8009b44:	6f22      	ldr	r2, [r4, #112]	; 0x70
 8009b46:	2a00      	cmp	r2, #0
 8009b48:	f43f af12 	beq.w	8009970 <tcp_slowtmr+0x9c>
 8009b4c:	f9b4 0034 	ldrsh.w	r0, [r4, #52]	; 0x34
 8009b50:	f9b4 2044 	ldrsh.w	r2, [r4, #68]	; 0x44
 8009b54:	4290      	cmp	r0, r2
 8009b56:	db3a      	blt.n	8009bce <tcp_slowtmr+0x2fa>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
 8009b58:	2b02      	cmp	r3, #2
 8009b5a:	d00b      	beq.n	8009b74 <tcp_slowtmr+0x2a0>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
 8009b5c:	4a1f      	ldr	r2, [pc, #124]	; (8009bdc <tcp_slowtmr+0x308>)
 8009b5e:	f9b4 3040 	ldrsh.w	r3, [r4, #64]	; 0x40
 8009b62:	4411      	add	r1, r2
 8009b64:	f9b4 2042 	ldrsh.w	r2, [r4, #66]	; 0x42
 8009b68:	7e09      	ldrb	r1, [r1, #24]
 8009b6a:	eb02 03e3 	add.w	r3, r2, r3, asr #3
 8009b6e:	408b      	lsls	r3, r1
 8009b70:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
          /* Reset the retransmission timer. */
          pcb->rtime = 0;

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
          pcb->ssthresh = eff_wnd >> 1;
 8009b74:	f8b4 304c 	ldrh.w	r3, [r4, #76]	; 0x4c
 8009b78:	f8b4 1060 	ldrh.w	r1, [r4, #96]	; 0x60
          if (pcb->ssthresh < (pcb->mss << 1)) {
 8009b7c:	8ee2      	ldrh	r2, [r4, #54]	; 0x36
          /* Reset the retransmission timer. */
          pcb->rtime = 0;

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
          pcb->ssthresh = eff_wnd >> 1;
 8009b7e:	428b      	cmp	r3, r1
 8009b80:	bf28      	it	cs
 8009b82:	460b      	movcs	r3, r1
          if (pcb->ssthresh < (pcb->mss << 1)) {
 8009b84:	0051      	lsls	r1, r2, #1
          /* Reset the retransmission timer. */
          pcb->rtime = 0;

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
          pcb->ssthresh = eff_wnd >> 1;
 8009b86:	085b      	lsrs	r3, r3, #1
          if (pcb->ssthresh < (pcb->mss << 1)) {
 8009b88:	428b      	cmp	r3, r1
          if (pcb->state != SYN_SENT) {
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
 8009b8a:	f04f 0000 	mov.w	r0, #0

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
          pcb->ssthresh = eff_wnd >> 1;
 8009b8e:	f8a4 304e 	strh.w	r3, [r4, #78]	; 0x4e
          if (pcb->state != SYN_SENT) {
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
 8009b92:	86a0      	strh	r0, [r4, #52]	; 0x34

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
          pcb->ssthresh = eff_wnd >> 1;
          if (pcb->ssthresh < (pcb->mss << 1)) {
            pcb->ssthresh = (pcb->mss << 1);
 8009b94:	bfb8      	it	lt
 8009b96:	f8a4 104e 	strhlt.w	r1, [r4, #78]	; 0x4e
          }
          pcb->cwnd = pcb->mss;
 8009b9a:	f8a4 204c 	strh.w	r2, [r4, #76]	; 0x4c
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
 8009b9e:	4620      	mov	r0, r4
 8009ba0:	f001 faae 	bl	800b100 <tcp_rexmit_rto>
 8009ba4:	7e23      	ldrb	r3, [r4, #24]
      pcb = pcb->next;
      continue;
    }
    pcb->last_timer = tcp_timer_ctr;

    pcb_remove = 0;
 8009ba6:	2200      	movs	r2, #0
          tcp_rexmit_rto(pcb);
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
 8009ba8:	2b06      	cmp	r3, #6
 8009baa:	f47f aee4 	bne.w	8009976 <tcp_slowtmr+0xa2>
      /* If this PCB is in FIN_WAIT_2 because of SHUT_WR don't let it time out. */
      if (pcb->flags & TF_RXCLOSED) {
 8009bae:	7fa3      	ldrb	r3, [r4, #30]
 8009bb0:	06d8      	lsls	r0, r3, #27
 8009bb2:	d506      	bpl.n	8009bc2 <tcp_slowtmr+0x2ee>
        /* PCB was fully closed (either through close() or SHUT_RDWR):
           normal FIN-WAIT timeout handling. */
        if ((u32_t)(tcp_ticks - pcb->tmr) >
 8009bb4:	6833      	ldr	r3, [r6, #0]
 8009bb6:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8009bb8:	1a5b      	subs	r3, r3, r1
 8009bba:	2b28      	cmp	r3, #40	; 0x28
 8009bbc:	d901      	bls.n	8009bc2 <tcp_slowtmr+0x2ee>
            TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
          ++pcb_remove;
 8009bbe:	3201      	adds	r2, #1
 8009bc0:	b2d2      	uxtb	r2, r2
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
 8009bc2:	2a00      	cmp	r2, #0
 8009bc4:	f43f af6d 	beq.w	8009aa2 <tcp_slowtmr+0x1ce>
      continue;
    }
    pcb->last_timer = tcp_timer_ctr;

    pcb_remove = 0;
    pcb_reset = 0;
 8009bc8:	f04f 0a00 	mov.w	sl, #0
 8009bcc:	e6fd      	b.n	80099ca <tcp_slowtmr+0xf6>
      pcb = pcb->next;
      continue;
    }
    pcb->last_timer = tcp_timer_ctr;

    pcb_remove = 0;
 8009bce:	2200      	movs	r2, #0
 8009bd0:	e6ce      	b.n	8009970 <tcp_slowtmr+0x9c>
 8009bd2:	bf00      	nop
 8009bd4:	2000f044 	.word	0x2000f044
 8009bd8:	200007a7 	.word	0x200007a7
 8009bdc:	08016130 	.word	0x08016130
 8009be0:	10624dd3 	.word	0x10624dd3
 8009be4:	2000f054 	.word	0x2000f054
 8009be8:	080166c8 	.word	0x080166c8
 8009bec:	0801689c 	.word	0x0801689c
 8009bf0:	0801660c 	.word	0x0801660c
 8009bf4:	2000f03c 	.word	0x2000f03c
 8009bf8:	080167bc 	.word	0x080167bc
 8009bfc:	080167e8 	.word	0x080167e8
 8009c00:	08016814 	.word	0x08016814
 8009c04:	2000f040 	.word	0x2000f040
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
 8009c08:	2a00      	cmp	r2, #0
 8009c0a:	f43f af4a 	beq.w	8009aa2 <tcp_slowtmr+0x1ce>
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
 8009c0e:	2b01      	cmp	r3, #1
 8009c10:	f67f aede 	bls.w	80099d0 <tcp_slowtmr+0xfc>
 8009c14:	2b0a      	cmp	r3, #10
 8009c16:	f47f aed8 	bne.w	80099ca <tcp_slowtmr+0xf6>
      tcp_err_fn err_fn;
      void *err_arg;
      tcp_pcb_purge(pcb);
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
 8009c1a:	f8d8 3000 	ldr.w	r3, [r8]
      struct tcp_pcb *pcb2;
      tcp_err_fn err_fn;
      void *err_arg;
      tcp_pcb_purge(pcb);
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
 8009c1e:	2f00      	cmp	r7, #0
 8009c20:	f47f aedb 	bne.w	80099da <tcp_slowtmr+0x106>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
        prev->next = pcb->next;
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
 8009c24:	42a3      	cmp	r3, r4
 8009c26:	d006      	beq.n	8009c36 <tcp_slowtmr+0x362>
 8009c28:	4b38      	ldr	r3, [pc, #224]	; (8009d0c <tcp_slowtmr+0x438>)
 8009c2a:	f240 32be 	movw	r2, #958	; 0x3be
 8009c2e:	4938      	ldr	r1, [pc, #224]	; (8009d10 <tcp_slowtmr+0x43c>)
 8009c30:	4838      	ldr	r0, [pc, #224]	; (8009d14 <tcp_slowtmr+0x440>)
 8009c32:	f00b f8a1 	bl	8014d78 <iprintf>
        tcp_active_pcbs = pcb->next;
 8009c36:	68e3      	ldr	r3, [r4, #12]
 8009c38:	f8c8 3000 	str.w	r3, [r8]
      }

      if (pcb_reset) {
 8009c3c:	f1ba 0f00 	cmp.w	sl, #0
 8009c40:	f43f aed4 	beq.w	80099ec <tcp_slowtmr+0x118>
        tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 8009c44:	8ba3      	ldrh	r3, [r4, #28]
 8009c46:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8009c48:	6d20      	ldr	r0, [r4, #80]	; 0x50
 8009c4a:	9301      	str	r3, [sp, #4]
 8009c4c:	8b63      	ldrh	r3, [r4, #26]
 8009c4e:	4622      	mov	r2, r4
 8009c50:	9300      	str	r3, [sp, #0]
 8009c52:	1d23      	adds	r3, r4, #4
 8009c54:	f001 f9f6 	bl	800b044 <tcp_rst>
 8009c58:	e6c8      	b.n	80099ec <tcp_slowtmr+0x118>
  while (pcb != NULL) {
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
    pcb_remove = 0;

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
 8009c5a:	6833      	ldr	r3, [r6, #0]
 8009c5c:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8009c5e:	1a9b      	subs	r3, r3, r2
 8009c60:	2bf0      	cmp	r3, #240	; 0xf0
 8009c62:	f63f aef9 	bhi.w	8009a58 <tcp_slowtmr+0x184>
      pcb2 = pcb;
      pcb = pcb->next;
      memp_free(MEMP_TCP_PCB, pcb2);
    } else {
      prev = pcb;
      pcb = pcb->next;
 8009c66:	4625      	mov	r5, r4
 8009c68:	68e4      	ldr	r4, [r4, #12]

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
 8009c6a:	2c00      	cmp	r4, #0
 8009c6c:	f47f aedf 	bne.w	8009a2e <tcp_slowtmr+0x15a>
 8009c70:	e703      	b.n	8009a7a <tcp_slowtmr+0x1a6>
    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
      ++pcb_remove;
 8009c72:	2201      	movs	r2, #1
 8009c74:	e67c      	b.n	8009970 <tcp_slowtmr+0x9c>
                                ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));
        
        ++pcb_remove;
        ++pcb_reset;
      }
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
 8009c76:	f894 e092 	ldrb.w	lr, [r4, #146]	; 0x92
 8009c7a:	4927      	ldr	r1, [pc, #156]	; (8009d18 <tcp_slowtmr+0x444>)
 8009c7c:	4827      	ldr	r0, [pc, #156]	; (8009d1c <tcp_slowtmr+0x448>)
 8009c7e:	fb01 c10e 	mla	r1, r1, lr, ip
 8009c82:	fba0 0101 	umull	r0, r1, r0, r1
 8009c86:	ebb9 1f51 	cmp.w	r9, r1, lsr #5
 8009c8a:	f67f aeff 	bls.w	8009a8c <tcp_slowtmr+0x1b8>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
              / TCP_SLOW_INTERVAL)
      {
        tcp_keepalive(pcb);
 8009c8e:	4620      	mov	r0, r4
 8009c90:	9203      	str	r2, [sp, #12]
 8009c92:	f001 fa9f 	bl	800b1d4 <tcp_keepalive>
        pcb->keep_cnt_sent++;
 8009c96:	f894 1092 	ldrb.w	r1, [r4, #146]	; 0x92
 8009c9a:	7e23      	ldrb	r3, [r4, #24]
 8009c9c:	3101      	adds	r1, #1
 8009c9e:	f884 1092 	strb.w	r1, [r4, #146]	; 0x92
      continue;
    }
    pcb->last_timer = tcp_timer_ctr;

    pcb_remove = 0;
    pcb_reset = 0;
 8009ca2:	f04f 0a00 	mov.w	sl, #0
 8009ca6:	9a03      	ldr	r2, [sp, #12]
 8009ca8:	e685      	b.n	80099b6 <tcp_slowtmr+0xe2>
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
 8009caa:	2b0a      	cmp	r3, #10
 8009cac:	f43f aed4 	beq.w	8009a58 <tcp_slowtmr+0x184>
 8009cb0:	4620      	mov	r0, r4
 8009cb2:	f7ff fded 	bl	8009890 <tcp_pcb_purge.part.1>
    if (pcb_remove) {
      struct tcp_pcb *pcb2;
      tcp_pcb_purge(pcb);
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
 8009cb6:	683b      	ldr	r3, [r7, #0]
    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
      struct tcp_pcb *pcb2;
      tcp_pcb_purge(pcb);
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
 8009cb8:	2d00      	cmp	r5, #0
 8009cba:	f47f aed1 	bne.w	8009a60 <tcp_slowtmr+0x18c>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
        prev->next = pcb->next;
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
 8009cbe:	429c      	cmp	r4, r3
 8009cc0:	d006      	beq.n	8009cd0 <tcp_slowtmr+0x3fc>
 8009cc2:	4b12      	ldr	r3, [pc, #72]	; (8009d0c <tcp_slowtmr+0x438>)
 8009cc4:	f240 4202 	movw	r2, #1026	; 0x402
 8009cc8:	4915      	ldr	r1, [pc, #84]	; (8009d20 <tcp_slowtmr+0x44c>)
 8009cca:	4812      	ldr	r0, [pc, #72]	; (8009d14 <tcp_slowtmr+0x440>)
 8009ccc:	f00b f854 	bl	8014d78 <iprintf>
        tcp_tw_pcbs = pcb->next;
 8009cd0:	68e2      	ldr	r2, [r4, #12]
 8009cd2:	4613      	mov	r3, r2
 8009cd4:	603a      	str	r2, [r7, #0]
 8009cd6:	e6c9      	b.n	8009a6c <tcp_slowtmr+0x198>
        if (tcp_active_pcbs_changed) {
          goto tcp_slowtmr_start;
        }
        /* if err == ERR_ABRT, 'prev' is already deallocated */
        if (err == ERR_OK) {
          tcp_output(prev);
 8009cd8:	4620      	mov	r0, r4
 8009cda:	4627      	mov	r7, r4
        goto tcp_slowtmr_start;
      }
    } else {
      /* get the 'next' element now and work with 'prev' below (in case of abort) */
      prev = pcb;
      pcb = pcb->next;
 8009cdc:	4654      	mov	r4, sl
        if (tcp_active_pcbs_changed) {
          goto tcp_slowtmr_start;
        }
        /* if err == ERR_ABRT, 'prev' is already deallocated */
        if (err == ERR_OK) {
          tcp_output(prev);
 8009cde:	f001 f83f 	bl	800ad60 <tcp_output>
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
 8009ce2:	2c00      	cmp	r4, #0
 8009ce4:	f47f ae09 	bne.w	80098fa <tcp_slowtmr+0x26>
 8009ce8:	e69d      	b.n	8009a26 <tcp_slowtmr+0x152>
      tcp_err_fn err_fn;
      void *err_arg;
      tcp_pcb_purge(pcb);
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
 8009cea:	4b08      	ldr	r3, [pc, #32]	; (8009d0c <tcp_slowtmr+0x438>)
 8009cec:	f240 32ba 	movw	r2, #954	; 0x3ba
 8009cf0:	490c      	ldr	r1, [pc, #48]	; (8009d24 <tcp_slowtmr+0x450>)
 8009cf2:	4808      	ldr	r0, [pc, #32]	; (8009d14 <tcp_slowtmr+0x440>)
 8009cf4:	f00b f840 	bl	8014d78 <iprintf>
 8009cf8:	e672      	b.n	80099e0 <tcp_slowtmr+0x10c>
    if (pcb_remove) {
      struct tcp_pcb *pcb2;
      tcp_pcb_purge(pcb);
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
 8009cfa:	4b04      	ldr	r3, [pc, #16]	; (8009d0c <tcp_slowtmr+0x438>)
 8009cfc:	f240 32fe 	movw	r2, #1022	; 0x3fe
 8009d00:	4909      	ldr	r1, [pc, #36]	; (8009d28 <tcp_slowtmr+0x454>)
 8009d02:	4804      	ldr	r0, [pc, #16]	; (8009d14 <tcp_slowtmr+0x440>)
 8009d04:	f00b f838 	bl	8014d78 <iprintf>
 8009d08:	e6ad      	b.n	8009a66 <tcp_slowtmr+0x192>
 8009d0a:	bf00      	nop
 8009d0c:	080166c8 	.word	0x080166c8
 8009d10:	08016870 	.word	0x08016870
 8009d14:	0801660c 	.word	0x0801660c
 8009d18:	000124f8 	.word	0x000124f8
 8009d1c:	10624dd3 	.word	0x10624dd3
 8009d20:	080168f4 	.word	0x080168f4
 8009d24:	08016844 	.word	0x08016844
 8009d28:	080168cc 	.word	0x080168cc

08009d2c <tcp_setprio>:
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  pcb->prio = prio;
 8009d2c:	7641      	strb	r1, [r0, #25]
 8009d2e:	4770      	bx	lr

08009d30 <tcp_arg>:
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{
  /* This function is allowed to be called for both listen pcbs and
     connection pcbs. */
  pcb->callback_arg = arg;
 8009d30:	6101      	str	r1, [r0, #16]
 8009d32:	4770      	bx	lr

08009d34 <tcp_recv>:
 * @param pcb tcp_pcb to set the recv callback
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
{
 8009d34:	b538      	push	{r3, r4, r5, lr}
  LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
 8009d36:	7e03      	ldrb	r3, [r0, #24]
 * @param pcb tcp_pcb to set the recv callback
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
{
 8009d38:	4604      	mov	r4, r0
  LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
 8009d3a:	2b01      	cmp	r3, #1
 * @param pcb tcp_pcb to set the recv callback
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
{
 8009d3c:	460d      	mov	r5, r1
  LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
 8009d3e:	d001      	beq.n	8009d44 <tcp_recv+0x10>
  pcb->recv = recv;
 8009d40:	67e5      	str	r5, [r4, #124]	; 0x7c
 8009d42:	bd38      	pop	{r3, r4, r5, pc}
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
{
  LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
 8009d44:	4b04      	ldr	r3, [pc, #16]	; (8009d58 <tcp_recv+0x24>)
 8009d46:	f240 5272 	movw	r2, #1394	; 0x572
 8009d4a:	4904      	ldr	r1, [pc, #16]	; (8009d5c <tcp_recv+0x28>)
 8009d4c:	4804      	ldr	r0, [pc, #16]	; (8009d60 <tcp_recv+0x2c>)
 8009d4e:	f00b f813 	bl	8014d78 <iprintf>
  pcb->recv = recv;
 8009d52:	67e5      	str	r5, [r4, #124]	; 0x7c
 8009d54:	bd38      	pop	{r3, r4, r5, pc}
 8009d56:	bf00      	nop
 8009d58:	080166c8 	.word	0x080166c8
 8009d5c:	0801691c 	.word	0x0801691c
 8009d60:	0801660c 	.word	0x0801660c

08009d64 <tcp_sent>:
 * @param pcb tcp_pcb to set the sent callback
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
{
 8009d64:	b538      	push	{r3, r4, r5, lr}
  LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
 8009d66:	7e03      	ldrb	r3, [r0, #24]
 * @param pcb tcp_pcb to set the sent callback
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
{
 8009d68:	4604      	mov	r4, r0
  LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
 8009d6a:	2b01      	cmp	r3, #1
 * @param pcb tcp_pcb to set the sent callback
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
{
 8009d6c:	460d      	mov	r5, r1
  LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
 8009d6e:	d001      	beq.n	8009d74 <tcp_sent+0x10>
  pcb->sent = sent;
 8009d70:	67a5      	str	r5, [r4, #120]	; 0x78
 8009d72:	bd38      	pop	{r3, r4, r5, pc}
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
{
  LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
 8009d74:	4b04      	ldr	r3, [pc, #16]	; (8009d88 <tcp_sent+0x24>)
 8009d76:	f44f 62b0 	mov.w	r2, #1408	; 0x580
 8009d7a:	4904      	ldr	r1, [pc, #16]	; (8009d8c <tcp_sent+0x28>)
 8009d7c:	4804      	ldr	r0, [pc, #16]	; (8009d90 <tcp_sent+0x2c>)
 8009d7e:	f00a fffb 	bl	8014d78 <iprintf>
  pcb->sent = sent;
 8009d82:	67a5      	str	r5, [r4, #120]	; 0x78
 8009d84:	bd38      	pop	{r3, r4, r5, pc}
 8009d86:	bf00      	nop
 8009d88:	080166c8 	.word	0x080166c8
 8009d8c:	08016944 	.word	0x08016944
 8009d90:	0801660c 	.word	0x0801660c

08009d94 <tcp_err>:
 * @param err callback function to call for this pcb when a fatal error
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
{
 8009d94:	b538      	push	{r3, r4, r5, lr}
  LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
 8009d96:	7e03      	ldrb	r3, [r0, #24]
 * @param err callback function to call for this pcb when a fatal error
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
{
 8009d98:	4604      	mov	r4, r0
  LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
 8009d9a:	2b01      	cmp	r3, #1
 * @param err callback function to call for this pcb when a fatal error
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
{
 8009d9c:	460d      	mov	r5, r1
  LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
 8009d9e:	d002      	beq.n	8009da6 <tcp_err+0x12>
  pcb->errf = err;
 8009da0:	f8c4 5088 	str.w	r5, [r4, #136]	; 0x88
 8009da4:	bd38      	pop	{r3, r4, r5, pc}
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
{
  LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
 8009da6:	4b05      	ldr	r3, [pc, #20]	; (8009dbc <tcp_err+0x28>)
 8009da8:	f240 528f 	movw	r2, #1423	; 0x58f
 8009dac:	4904      	ldr	r1, [pc, #16]	; (8009dc0 <tcp_err+0x2c>)
 8009dae:	4805      	ldr	r0, [pc, #20]	; (8009dc4 <tcp_err+0x30>)
 8009db0:	f00a ffe2 	bl	8014d78 <iprintf>
  pcb->errf = err;
 8009db4:	f8c4 5088 	str.w	r5, [r4, #136]	; 0x88
 8009db8:	bd38      	pop	{r3, r4, r5, pc}
 8009dba:	bf00      	nop
 8009dbc:	080166c8 	.word	0x080166c8
 8009dc0:	0801696c 	.word	0x0801696c
 8009dc4:	0801660c 	.word	0x0801660c

08009dc8 <tcp_accept>:
void
tcp_accept(struct tcp_pcb *pcb, tcp_accept_fn accept)
{
  /* This function is allowed to be called for both listen pcbs and
     connection pcbs. */
  pcb->accept = accept;
 8009dc8:	6141      	str	r1, [r0, #20]
 8009dca:	4770      	bx	lr

08009dcc <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
{
  LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
 8009dcc:	7e03      	ldrb	r3, [r0, #24]
 * timer interval, which is called twice a second.
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
{
 8009dce:	b570      	push	{r4, r5, r6, lr}
  LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
 8009dd0:	2b01      	cmp	r3, #1
 * timer interval, which is called twice a second.
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
{
 8009dd2:	4604      	mov	r4, r0
 8009dd4:	460e      	mov	r6, r1
 8009dd6:	4615      	mov	r5, r2
  LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
 8009dd8:	d004      	beq.n	8009de4 <tcp_poll+0x18>
#if LWIP_CALLBACK_API
  pcb->poll = poll;
#else /* LWIP_CALLBACK_API */  
  LWIP_UNUSED_ARG(poll);
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
 8009dda:	f884 5020 	strb.w	r5, [r4, #32]
void
tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
{
  LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
#if LWIP_CALLBACK_API
  pcb->poll = poll;
 8009dde:	f8c4 6084 	str.w	r6, [r4, #132]	; 0x84
#else /* LWIP_CALLBACK_API */  
  LWIP_UNUSED_ARG(poll);
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
 8009de2:	bd70      	pop	{r4, r5, r6, pc}
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
{
  LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
 8009de4:	4b05      	ldr	r3, [pc, #20]	; (8009dfc <tcp_poll+0x30>)
 8009de6:	f240 52ae 	movw	r2, #1454	; 0x5ae
 8009dea:	4905      	ldr	r1, [pc, #20]	; (8009e00 <tcp_poll+0x34>)
 8009dec:	4805      	ldr	r0, [pc, #20]	; (8009e04 <tcp_poll+0x38>)
 8009dee:	f00a ffc3 	bl	8014d78 <iprintf>
#if LWIP_CALLBACK_API
  pcb->poll = poll;
#else /* LWIP_CALLBACK_API */  
  LWIP_UNUSED_ARG(poll);
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
 8009df2:	f884 5020 	strb.w	r5, [r4, #32]
void
tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
{
  LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
#if LWIP_CALLBACK_API
  pcb->poll = poll;
 8009df6:	f8c4 6084 	str.w	r6, [r4, #132]	; 0x84
#else /* LWIP_CALLBACK_API */  
  LWIP_UNUSED_ARG(poll);
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
 8009dfa:	bd70      	pop	{r4, r5, r6, pc}
 8009dfc:	080166c8 	.word	0x080166c8
 8009e00:	08016994 	.word	0x08016994
 8009e04:	0801660c 	.word	0x0801660c

08009e08 <tcp_pcb_purge>:
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
 8009e08:	7e03      	ldrb	r3, [r0, #24]
 8009e0a:	2b01      	cmp	r3, #1
 8009e0c:	d902      	bls.n	8009e14 <tcp_pcb_purge+0xc>
 8009e0e:	2b0a      	cmp	r3, #10
 8009e10:	d000      	beq.n	8009e14 <tcp_pcb_purge+0xc>
 8009e12:	e53d      	b.n	8009890 <tcp_pcb_purge.part.1>
 8009e14:	4770      	bx	lr
 8009e16:	bf00      	nop

08009e18 <tcp_pcb_remove>:
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  TCP_RMV(pcblist, pcb);
 8009e18:	6802      	ldr	r2, [r0, #0]
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
 8009e1a:	b510      	push	{r4, lr}
  TCP_RMV(pcblist, pcb);
 8009e1c:	428a      	cmp	r2, r1
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
 8009e1e:	460c      	mov	r4, r1
  TCP_RMV(pcblist, pcb);
 8009e20:	d044      	beq.n	8009eac <tcp_pcb_remove+0x94>
 8009e22:	4925      	ldr	r1, [pc, #148]	; (8009eb8 <tcp_pcb_remove+0xa0>)
 8009e24:	600a      	str	r2, [r1, #0]
 8009e26:	b152      	cbz	r2, 8009e3e <tcp_pcb_remove+0x26>
 8009e28:	68d3      	ldr	r3, [r2, #12]
 8009e2a:	429c      	cmp	r4, r3
 8009e2c:	d041      	beq.n	8009eb2 <tcp_pcb_remove+0x9a>
 8009e2e:	b12b      	cbz	r3, 8009e3c <tcp_pcb_remove+0x24>
 8009e30:	68da      	ldr	r2, [r3, #12]
 8009e32:	4294      	cmp	r4, r2
 8009e34:	d02c      	beq.n	8009e90 <tcp_pcb_remove+0x78>
 8009e36:	4613      	mov	r3, r2
 8009e38:	2b00      	cmp	r3, #0
 8009e3a:	d1f9      	bne.n	8009e30 <tcp_pcb_remove+0x18>
 8009e3c:	600b      	str	r3, [r1, #0]
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
 8009e3e:	7e23      	ldrb	r3, [r4, #24]
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  TCP_RMV(pcblist, pcb);
 8009e40:	2200      	movs	r2, #0
 8009e42:	60e2      	str	r2, [r4, #12]
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
 8009e44:	b9bb      	cbnz	r3, 8009e76 <tcp_pcb_remove+0x5e>
  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
 8009e46:	7fa3      	ldrb	r3, [r4, #30]

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
     pcb->state != LISTEN &&
 8009e48:	07da      	lsls	r2, r3, #31
 8009e4a:	d425      	bmi.n	8009e98 <tcp_pcb_remove+0x80>
    pcb->flags |= TF_ACK_NOW;
    tcp_output(pcb);
  }

  if (pcb->state != LISTEN) {
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
 8009e4c:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8009e4e:	b133      	cbz	r3, 8009e5e <tcp_pcb_remove+0x46>
 8009e50:	4b1a      	ldr	r3, [pc, #104]	; (8009ebc <tcp_pcb_remove+0xa4>)
 8009e52:	f240 6211 	movw	r2, #1553	; 0x611
 8009e56:	491a      	ldr	r1, [pc, #104]	; (8009ec0 <tcp_pcb_remove+0xa8>)
 8009e58:	481a      	ldr	r0, [pc, #104]	; (8009ec4 <tcp_pcb_remove+0xac>)
 8009e5a:	f00a ff8d 	bl	8014d78 <iprintf>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
 8009e5e:	6f23      	ldr	r3, [r4, #112]	; 0x70
 8009e60:	b133      	cbz	r3, 8009e70 <tcp_pcb_remove+0x58>
 8009e62:	4b16      	ldr	r3, [pc, #88]	; (8009ebc <tcp_pcb_remove+0xa4>)
 8009e64:	f240 6212 	movw	r2, #1554	; 0x612
 8009e68:	4917      	ldr	r1, [pc, #92]	; (8009ec8 <tcp_pcb_remove+0xb0>)
 8009e6a:	4816      	ldr	r0, [pc, #88]	; (8009ec4 <tcp_pcb_remove+0xac>)
 8009e6c:	f00a ff84 	bl	8014d78 <iprintf>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
 8009e70:	2300      	movs	r3, #0
 8009e72:	7623      	strb	r3, [r4, #24]

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
 8009e74:	bd10      	pop	{r4, pc}
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
 8009e76:	2b0a      	cmp	r3, #10
 8009e78:	d0e8      	beq.n	8009e4c <tcp_pcb_remove+0x34>
     pcb->state != TIME_WAIT &&
 8009e7a:	2b01      	cmp	r3, #1
 8009e7c:	d0f8      	beq.n	8009e70 <tcp_pcb_remove+0x58>
 8009e7e:	4620      	mov	r0, r4
 8009e80:	f7ff fd06 	bl	8009890 <tcp_pcb_purge.part.1>
  TCP_RMV(pcblist, pcb);

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
 8009e84:	7e23      	ldrb	r3, [r4, #24]
 8009e86:	2b0a      	cmp	r3, #10
 8009e88:	d0e0      	beq.n	8009e4c <tcp_pcb_remove+0x34>
 8009e8a:	2b01      	cmp	r3, #1
 8009e8c:	d0f0      	beq.n	8009e70 <tcp_pcb_remove+0x58>
 8009e8e:	e7da      	b.n	8009e46 <tcp_pcb_remove+0x2e>
 8009e90:	600b      	str	r3, [r1, #0]
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  TCP_RMV(pcblist, pcb);
 8009e92:	68e2      	ldr	r2, [r4, #12]
 8009e94:	60da      	str	r2, [r3, #12]
 8009e96:	e7d2      	b.n	8009e3e <tcp_pcb_remove+0x26>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
 8009e98:	f043 0302 	orr.w	r3, r3, #2
 8009e9c:	77a3      	strb	r3, [r4, #30]
    tcp_output(pcb);
 8009e9e:	4620      	mov	r0, r4
 8009ea0:	f000 ff5e 	bl	800ad60 <tcp_output>
  }

  if (pcb->state != LISTEN) {
 8009ea4:	7e23      	ldrb	r3, [r4, #24]
 8009ea6:	2b01      	cmp	r3, #1
 8009ea8:	d1d0      	bne.n	8009e4c <tcp_pcb_remove+0x34>
 8009eaa:	e7e1      	b.n	8009e70 <tcp_pcb_remove+0x58>
 * @param pcb tcp_pcb to purge. The pcb itself is NOT deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  TCP_RMV(pcblist, pcb);
 8009eac:	68cb      	ldr	r3, [r1, #12]
 8009eae:	6003      	str	r3, [r0, #0]
 8009eb0:	e7c5      	b.n	8009e3e <tcp_pcb_remove+0x26>
 8009eb2:	4613      	mov	r3, r2
 8009eb4:	e7ed      	b.n	8009e92 <tcp_pcb_remove+0x7a>
 8009eb6:	bf00      	nop
 8009eb8:	2000f04c 	.word	0x2000f04c
 8009ebc:	080166c8 	.word	0x080166c8
 8009ec0:	080169b4 	.word	0x080169b4
 8009ec4:	0801660c 	.word	0x0801660c
 8009ec8:	080169cc 	.word	0x080169cc

08009ecc <tcp_close_shutdown>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
static err_t
tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
{
 8009ecc:	b530      	push	{r4, r5, lr}
  err_t err;

  if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
 8009ece:	7e03      	ldrb	r3, [r0, #24]
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
static err_t
tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
{
 8009ed0:	b083      	sub	sp, #12
 8009ed2:	4604      	mov	r4, r0
  err_t err;

  if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
 8009ed4:	b119      	cbz	r1, 8009ede <tcp_close_shutdown+0x12>
 8009ed6:	2b04      	cmp	r3, #4
 8009ed8:	d01d      	beq.n	8009f16 <tcp_close_shutdown+0x4a>
 8009eda:	2b07      	cmp	r3, #7
 8009edc:	d01b      	beq.n	8009f16 <tcp_close_shutdown+0x4a>
      }
      return ERR_OK;
    }
  }

  switch (pcb->state) {
 8009ede:	2b07      	cmp	r3, #7
 8009ee0:	d80e      	bhi.n	8009f00 <tcp_close_shutdown+0x34>
 8009ee2:	e8df f003 	tbb	[pc, r3]
 8009ee6:	5944      	.short	0x5944
 8009ee8:	0d101062 	.word	0x0d101062
 8009eec:	040d      	.short	0x040d
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
    }
    break;
  case CLOSE_WAIT:
    err = tcp_send_fin(pcb);
 8009eee:	4620      	mov	r0, r4
 8009ef0:	f000 fee4 	bl	800acbc <tcp_send_fin>
    if (err == ERR_OK) {
 8009ef4:	b928      	cbnz	r0, 8009f02 <tcp_close_shutdown+0x36>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
 8009ef6:	2309      	movs	r3, #9
 8009ef8:	7623      	strb	r3, [r4, #24]
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent and acked before close returns.
       This can only be valid for sequential APIs, not for the raw API. */
    tcp_output(pcb);
 8009efa:	4620      	mov	r0, r4
 8009efc:	f000 ff30 	bl	800ad60 <tcp_output>
 8009f00:	2000      	movs	r0, #0
  }
  return err;
}
 8009f02:	b003      	add	sp, #12
 8009f04:	bd30      	pop	{r4, r5, pc}
    memp_free(MEMP_TCP_PCB, pcb);
    pcb = NULL;
    snmp_inc_tcpattemptfails();
    break;
  case SYN_RCVD:
    err = tcp_send_fin(pcb);
 8009f06:	4620      	mov	r0, r4
 8009f08:	f000 fed8 	bl	800acbc <tcp_send_fin>
    if (err == ERR_OK) {
 8009f0c:	2800      	cmp	r0, #0
 8009f0e:	d1f8      	bne.n	8009f02 <tcp_close_shutdown+0x36>
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
 8009f10:	2305      	movs	r3, #5
 8009f12:	7623      	strb	r3, [r4, #24]
 8009f14:	e7f1      	b.n	8009efa <tcp_close_shutdown+0x2e>
tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
{
  err_t err;

  if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
    if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND)) {
 8009f16:	6f62      	ldr	r2, [r4, #116]	; 0x74
 8009f18:	2a00      	cmp	r2, #0
 8009f1a:	f000 8088 	beq.w	800a02e <tcp_close_shutdown+0x162>
      /* Not all data received by application, send RST to tell the remote
         side about this. */
      LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);
 8009f1e:	7fa3      	ldrb	r3, [r4, #30]
 8009f20:	06db      	lsls	r3, r3, #27
 8009f22:	d54e      	bpl.n	8009fc2 <tcp_close_shutdown+0xf6>

      /* don't call tcp_abort here: we must not deallocate the pcb since
         that might not be expected when calling tcp_close */
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
 8009f24:	8ba2      	ldrh	r2, [r4, #28]
 8009f26:	8b63      	ldrh	r3, [r4, #26]
 8009f28:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8009f2a:	6d20      	ldr	r0, [r4, #80]	; 0x50
 8009f2c:	9201      	str	r2, [sp, #4]
 8009f2e:	9300      	str	r3, [sp, #0]
 8009f30:	4622      	mov	r2, r4
 8009f32:	1d23      	adds	r3, r4, #4
 8009f34:	f001 f886 	bl	800b044 <tcp_rst>
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
 8009f38:	7e21      	ldrb	r1, [r4, #24]
 8009f3a:	2901      	cmp	r1, #1
 8009f3c:	d905      	bls.n	8009f4a <tcp_close_shutdown+0x7e>
 8009f3e:	290a      	cmp	r1, #10
 8009f40:	d003      	beq.n	8009f4a <tcp_close_shutdown+0x7e>
 8009f42:	4620      	mov	r0, r4
 8009f44:	f7ff fca4 	bl	8009890 <tcp_pcb_purge.part.1>
 8009f48:	7e21      	ldrb	r1, [r4, #24]
         that might not be expected when calling tcp_close */
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
        pcb->local_port, pcb->remote_port);

      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
 8009f4a:	4b3e      	ldr	r3, [pc, #248]	; (800a044 <tcp_close_shutdown+0x178>)
 8009f4c:	681a      	ldr	r2, [r3, #0]
 8009f4e:	4294      	cmp	r4, r2
 8009f50:	d064      	beq.n	800a01c <tcp_close_shutdown+0x150>
 8009f52:	483d      	ldr	r0, [pc, #244]	; (800a048 <tcp_close_shutdown+0x17c>)
 8009f54:	6002      	str	r2, [r0, #0]
 8009f56:	2a00      	cmp	r2, #0
 8009f58:	d03d      	beq.n	8009fd6 <tcp_close_shutdown+0x10a>
 8009f5a:	68d3      	ldr	r3, [r2, #12]
 8009f5c:	429c      	cmp	r4, r3
 8009f5e:	d060      	beq.n	800a022 <tcp_close_shutdown+0x156>
 8009f60:	2b00      	cmp	r3, #0
 8009f62:	d04f      	beq.n	800a004 <tcp_close_shutdown+0x138>
 8009f64:	68da      	ldr	r2, [r3, #12]
 8009f66:	4294      	cmp	r4, r2
 8009f68:	d032      	beq.n	8009fd0 <tcp_close_shutdown+0x104>
 8009f6a:	4613      	mov	r3, r2
 8009f6c:	e7f8      	b.n	8009f60 <tcp_close_shutdown+0x94>
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    if (pcb->local_port != 0) {
 8009f6e:	8b63      	ldrh	r3, [r4, #26]
 8009f70:	2b00      	cmp	r3, #0
 8009f72:	d042      	beq.n	8009ffa <tcp_close_shutdown+0x12e>
      TCP_RMV(&tcp_bound_pcbs, pcb);
 8009f74:	4b35      	ldr	r3, [pc, #212]	; (800a04c <tcp_close_shutdown+0x180>)
 8009f76:	681a      	ldr	r2, [r3, #0]
 8009f78:	4294      	cmp	r4, r2
 8009f7a:	d03a      	beq.n	8009ff2 <tcp_close_shutdown+0x126>
 8009f7c:	4832      	ldr	r0, [pc, #200]	; (800a048 <tcp_close_shutdown+0x17c>)
 8009f7e:	6002      	str	r2, [r0, #0]
 8009f80:	2a00      	cmp	r2, #0
 8009f82:	d038      	beq.n	8009ff6 <tcp_close_shutdown+0x12a>
 8009f84:	68d3      	ldr	r3, [r2, #12]
 8009f86:	42a3      	cmp	r3, r4
 8009f88:	d04d      	beq.n	800a026 <tcp_close_shutdown+0x15a>
 8009f8a:	2b00      	cmp	r3, #0
 8009f8c:	d056      	beq.n	800a03c <tcp_close_shutdown+0x170>
 8009f8e:	68da      	ldr	r2, [r3, #12]
 8009f90:	4294      	cmp	r4, r2
 8009f92:	d055      	beq.n	800a040 <tcp_close_shutdown+0x174>
 8009f94:	4613      	mov	r3, r2
 8009f96:	e7f8      	b.n	8009f8a <tcp_close_shutdown+0xbe>
    memp_free(MEMP_TCP_PCB, pcb);
    pcb = NULL;
    break;
  case LISTEN:
    err = ERR_OK;
    tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
 8009f98:	4621      	mov	r1, r4
 8009f9a:	482d      	ldr	r0, [pc, #180]	; (800a050 <tcp_close_shutdown+0x184>)
 8009f9c:	f7ff ff3c 	bl	8009e18 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
 8009fa0:	4621      	mov	r1, r4
 8009fa2:	2003      	movs	r0, #3
 8009fa4:	f005 feaa 	bl	800fcfc <memp_free>
    pcb = NULL;
    break;
 8009fa8:	e7aa      	b.n	8009f00 <tcp_close_shutdown+0x34>
  case SYN_SENT:
    err = ERR_OK;
    TCP_PCB_REMOVE_ACTIVE(pcb);
 8009faa:	4621      	mov	r1, r4
 8009fac:	4825      	ldr	r0, [pc, #148]	; (800a044 <tcp_close_shutdown+0x178>)
 8009fae:	f7ff ff33 	bl	8009e18 <tcp_pcb_remove>
 8009fb2:	4b28      	ldr	r3, [pc, #160]	; (800a054 <tcp_close_shutdown+0x188>)
 8009fb4:	2201      	movs	r2, #1
    memp_free(MEMP_TCP_PCB, pcb);
 8009fb6:	4621      	mov	r1, r4
 8009fb8:	2002      	movs	r0, #2
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
    pcb = NULL;
    break;
  case SYN_SENT:
    err = ERR_OK;
    TCP_PCB_REMOVE_ACTIVE(pcb);
 8009fba:	701a      	strb	r2, [r3, #0]
    memp_free(MEMP_TCP_PCB, pcb);
 8009fbc:	f005 fe9e 	bl	800fcfc <memp_free>
    pcb = NULL;
    snmp_inc_tcpattemptfails();
    break;
 8009fc0:	e79e      	b.n	8009f00 <tcp_close_shutdown+0x34>

  if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
    if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND)) {
      /* Not all data received by application, send RST to tell the remote
         side about this. */
      LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);
 8009fc2:	4b25      	ldr	r3, [pc, #148]	; (800a058 <tcp_close_shutdown+0x18c>)
 8009fc4:	22b2      	movs	r2, #178	; 0xb2
 8009fc6:	4925      	ldr	r1, [pc, #148]	; (800a05c <tcp_close_shutdown+0x190>)
 8009fc8:	4825      	ldr	r0, [pc, #148]	; (800a060 <tcp_close_shutdown+0x194>)
 8009fca:	f00a fed5 	bl	8014d78 <iprintf>
 8009fce:	e7a9      	b.n	8009f24 <tcp_close_shutdown+0x58>
 8009fd0:	6003      	str	r3, [r0, #0]
         that might not be expected when calling tcp_close */
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
        pcb->local_port, pcb->remote_port);

      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
 8009fd2:	68e2      	ldr	r2, [r4, #12]
 8009fd4:	60da      	str	r2, [r3, #12]
 8009fd6:	4b1f      	ldr	r3, [pc, #124]	; (800a054 <tcp_close_shutdown+0x188>)
 8009fd8:	2201      	movs	r2, #1
 8009fda:	2500      	movs	r5, #0
      if (pcb->state == ESTABLISHED) {
 8009fdc:	2904      	cmp	r1, #4
         that might not be expected when calling tcp_close */
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
        pcb->local_port, pcb->remote_port);

      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
 8009fde:	701a      	strb	r2, [r3, #0]
 8009fe0:	60e5      	str	r5, [r4, #12]
      if (pcb->state == ESTABLISHED) {
 8009fe2:	d011      	beq.n	800a008 <tcp_close_shutdown+0x13c>
        /* move to TIME_WAIT since we close actively */
        pcb->state = TIME_WAIT;
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        /* CLOSE_WAIT: deallocate the pcb since we already sent a RST for it */
        memp_free(MEMP_TCP_PCB, pcb);
 8009fe4:	4621      	mov	r1, r4
 8009fe6:	2002      	movs	r0, #2
 8009fe8:	f005 fe88 	bl	800fcfc <memp_free>
      }
      return ERR_OK;
 8009fec:	4628      	mov	r0, r5
       If SOF_LINGER is set, the data should be sent and acked before close returns.
       This can only be valid for sequential APIs, not for the raw API. */
    tcp_output(pcb);
  }
  return err;
}
 8009fee:	b003      	add	sp, #12
 8009ff0:	bd30      	pop	{r4, r5, pc}
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    if (pcb->local_port != 0) {
      TCP_RMV(&tcp_bound_pcbs, pcb);
 8009ff2:	68e2      	ldr	r2, [r4, #12]
 8009ff4:	601a      	str	r2, [r3, #0]
 8009ff6:	2300      	movs	r3, #0
 8009ff8:	60e3      	str	r3, [r4, #12]
    }
    memp_free(MEMP_TCP_PCB, pcb);
 8009ffa:	4621      	mov	r1, r4
 8009ffc:	2002      	movs	r0, #2
 8009ffe:	f005 fe7d 	bl	800fcfc <memp_free>
    pcb = NULL;
    break;
 800a002:	e77d      	b.n	8009f00 <tcp_close_shutdown+0x34>
 800a004:	6003      	str	r3, [r0, #0]
 800a006:	e7e6      	b.n	8009fd6 <tcp_close_shutdown+0x10a>
      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
      if (pcb->state == ESTABLISHED) {
        /* move to TIME_WAIT since we close actively */
        pcb->state = TIME_WAIT;
        TCP_REG(&tcp_tw_pcbs, pcb);
 800a008:	4b16      	ldr	r3, [pc, #88]	; (800a064 <tcp_close_shutdown+0x198>)

      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
      if (pcb->state == ESTABLISHED) {
        /* move to TIME_WAIT since we close actively */
        pcb->state = TIME_WAIT;
 800a00a:	210a      	movs	r1, #10
        TCP_REG(&tcp_tw_pcbs, pcb);
 800a00c:	681a      	ldr	r2, [r3, #0]

      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
      if (pcb->state == ESTABLISHED) {
        /* move to TIME_WAIT since we close actively */
        pcb->state = TIME_WAIT;
 800a00e:	7621      	strb	r1, [r4, #24]
        TCP_REG(&tcp_tw_pcbs, pcb);
 800a010:	60e2      	str	r2, [r4, #12]
 800a012:	601c      	str	r4, [r3, #0]
 800a014:	f001 fb0a 	bl	800b62c <tcp_timer_needed>
      } else {
        /* CLOSE_WAIT: deallocate the pcb since we already sent a RST for it */
        memp_free(MEMP_TCP_PCB, pcb);
      }
      return ERR_OK;
 800a018:	4628      	mov	r0, r5
 800a01a:	e772      	b.n	8009f02 <tcp_close_shutdown+0x36>
         that might not be expected when calling tcp_close */
      tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
        pcb->local_port, pcb->remote_port);

      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
 800a01c:	68e2      	ldr	r2, [r4, #12]
 800a01e:	601a      	str	r2, [r3, #0]
 800a020:	e7d9      	b.n	8009fd6 <tcp_close_shutdown+0x10a>
 800a022:	4613      	mov	r3, r2
 800a024:	e7d5      	b.n	8009fd2 <tcp_close_shutdown+0x106>
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    if (pcb->local_port != 0) {
      TCP_RMV(&tcp_bound_pcbs, pcb);
 800a026:	4613      	mov	r3, r2
 800a028:	68e2      	ldr	r2, [r4, #12]
 800a02a:	60da      	str	r2, [r3, #12]
 800a02c:	e7e3      	b.n	8009ff6 <tcp_close_shutdown+0x12a>
tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
{
  err_t err;

  if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
    if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND)) {
 800a02e:	f640 3268 	movw	r2, #2920	; 0xb68
 800a032:	8da1      	ldrh	r1, [r4, #44]	; 0x2c
 800a034:	4291      	cmp	r1, r2
 800a036:	f47f af72 	bne.w	8009f1e <tcp_close_shutdown+0x52>
 800a03a:	e750      	b.n	8009ede <tcp_close_shutdown+0x12>
 800a03c:	6003      	str	r3, [r0, #0]
 800a03e:	e7da      	b.n	8009ff6 <tcp_close_shutdown+0x12a>
 800a040:	6003      	str	r3, [r0, #0]
 800a042:	e7f1      	b.n	800a028 <tcp_close_shutdown+0x15c>
 800a044:	2000f040 	.word	0x2000f040
 800a048:	2000f04c 	.word	0x2000f04c
 800a04c:	2000f050 	.word	0x2000f050
 800a050:	2000f048 	.word	0x2000f048
 800a054:	2000f03c 	.word	0x2000f03c
 800a058:	080166c8 	.word	0x080166c8
 800a05c:	080169e8 	.word	0x080169e8
 800a060:	0801660c 	.word	0x0801660c
 800a064:	2000f054 	.word	0x2000f054

0800a068 <tcp_close>:
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  if (pcb->state != LISTEN) {
 800a068:	7e03      	ldrb	r3, [r0, #24]
 800a06a:	2b01      	cmp	r3, #1
 800a06c:	d003      	beq.n	800a076 <tcp_close+0xe>
    /* Set a flag not to receive any more data... */
    pcb->flags |= TF_RXCLOSED;
 800a06e:	7f83      	ldrb	r3, [r0, #30]
 800a070:	f043 0310 	orr.w	r3, r3, #16
 800a074:	7783      	strb	r3, [r0, #30]
  }
  /* ... and close */
  return tcp_close_shutdown(pcb, 1);
 800a076:	2101      	movs	r1, #1
 800a078:	e728      	b.n	8009ecc <tcp_close_shutdown>
 800a07a:	bf00      	nop

0800a07c <tcp_recv_null>:
 */
err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  LWIP_UNUSED_ARG(arg);
  if (p != NULL) {
 800a07c:	b152      	cbz	r2, 800a094 <tcp_recv_null+0x18>
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
 800a07e:	b510      	push	{r4, lr}
 800a080:	4614      	mov	r4, r2
 800a082:	4608      	mov	r0, r1
  LWIP_UNUSED_ARG(arg);
  if (p != NULL) {
    tcp_recved(pcb, p->tot_len);
 800a084:	8911      	ldrh	r1, [r2, #8]
 800a086:	f7ff faff 	bl	8009688 <tcp_recved>
    pbuf_free(p);
 800a08a:	4620      	mov	r0, r4
 800a08c:	f005 ffcc 	bl	8010028 <pbuf_free>
  } else if (err == ERR_OK) {
    return tcp_close(pcb);
  }
  return ERR_OK;
}
 800a090:	2000      	movs	r0, #0
 800a092:	bd10      	pop	{r4, pc}
{
  LWIP_UNUSED_ARG(arg);
  if (p != NULL) {
    tcp_recved(pcb, p->tot_len);
    pbuf_free(p);
  } else if (err == ERR_OK) {
 800a094:	b94b      	cbnz	r3, 800a0aa <tcp_recv_null+0x2e>
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  if (pcb->state != LISTEN) {
 800a096:	7e0b      	ldrb	r3, [r1, #24]
 800a098:	2b01      	cmp	r3, #1
 800a09a:	d003      	beq.n	800a0a4 <tcp_recv_null+0x28>
    /* Set a flag not to receive any more data... */
    pcb->flags |= TF_RXCLOSED;
 800a09c:	7f8b      	ldrb	r3, [r1, #30]
 800a09e:	f043 0310 	orr.w	r3, r3, #16
 800a0a2:	778b      	strb	r3, [r1, #30]
  }
  /* ... and close */
  return tcp_close_shutdown(pcb, 1);
 800a0a4:	4608      	mov	r0, r1
 800a0a6:	2101      	movs	r1, #1
 800a0a8:	e710      	b.n	8009ecc <tcp_close_shutdown>
    pbuf_free(p);
  } else if (err == ERR_OK) {
    return tcp_close(pcb);
  }
  return ERR_OK;
}
 800a0aa:	2000      	movs	r0, #0
 800a0ac:	4770      	bx	lr
 800a0ae:	bf00      	nop

0800a0b0 <tcp_process_refused_data>:
}

/** Pass pcb->refused_data to the recv callback */
err_t
tcp_process_refused_data(struct tcp_pcb *pcb)
{
 800a0b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  err_t err;
  u8_t refused_flags = pcb->refused_data->flags;
 800a0b2:	6f45      	ldr	r5, [r0, #116]	; 0x74
     closes the pcb */
  struct pbuf *refused_data = pcb->refused_data;
  pcb->refused_data = NULL;
  /* Notify again application with data previously received. */
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
  TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
 800a0b4:	6fc6      	ldr	r6, [r0, #124]	; 0x7c
  err_t err;
  u8_t refused_flags = pcb->refused_data->flags;
  /* set pcb->refused_data to NULL in case the callback frees it and then
     closes the pcb */
  struct pbuf *refused_data = pcb->refused_data;
  pcb->refused_data = NULL;
 800a0b6:	2300      	movs	r3, #0
/** Pass pcb->refused_data to the recv callback */
err_t
tcp_process_refused_data(struct tcp_pcb *pcb)
{
  err_t err;
  u8_t refused_flags = pcb->refused_data->flags;
 800a0b8:	7b6f      	ldrb	r7, [r5, #13]
}

/** Pass pcb->refused_data to the recv callback */
err_t
tcp_process_refused_data(struct tcp_pcb *pcb)
{
 800a0ba:	4604      	mov	r4, r0
  err_t err;
  u8_t refused_flags = pcb->refused_data->flags;
  /* set pcb->refused_data to NULL in case the callback frees it and then
     closes the pcb */
  struct pbuf *refused_data = pcb->refused_data;
  pcb->refused_data = NULL;
 800a0bc:	6743      	str	r3, [r0, #116]	; 0x74
  /* Notify again application with data previously received. */
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
  TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
 800a0be:	b1ee      	cbz	r6, 800a0fc <tcp_process_refused_data+0x4c>
 800a0c0:	4601      	mov	r1, r0
 800a0c2:	462a      	mov	r2, r5
 800a0c4:	6900      	ldr	r0, [r0, #16]
 800a0c6:	47b0      	blx	r6
  if (err == ERR_OK) {
 800a0c8:	b998      	cbnz	r0, 800a0f2 <tcp_process_refused_data+0x42>
    /* did refused_data include a FIN? */
    if (refused_flags & PBUF_FLAG_TCP_FIN) {
 800a0ca:	06bb      	lsls	r3, r7, #26
 800a0cc:	d50f      	bpl.n	800a0ee <tcp_process_refused_data+0x3e>
      /* correct rcv_wnd as the application won't call tcp_recved()
         for the FIN's seqno */
      if (pcb->rcv_wnd != TCP_WND) {
 800a0ce:	f640 3268 	movw	r2, #2920	; 0xb68
 800a0d2:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
        pcb->rcv_wnd++;
      }
      TCP_EVENT_CLOSED(pcb, err);
 800a0d4:	6fe5      	ldr	r5, [r4, #124]	; 0x7c
  if (err == ERR_OK) {
    /* did refused_data include a FIN? */
    if (refused_flags & PBUF_FLAG_TCP_FIN) {
      /* correct rcv_wnd as the application won't call tcp_recved()
         for the FIN's seqno */
      if (pcb->rcv_wnd != TCP_WND) {
 800a0d6:	4293      	cmp	r3, r2
        pcb->rcv_wnd++;
 800a0d8:	bf1c      	itt	ne
 800a0da:	3301      	addne	r3, #1
 800a0dc:	85a3      	strhne	r3, [r4, #44]	; 0x2c
      }
      TCP_EVENT_CLOSED(pcb, err);
 800a0de:	b135      	cbz	r5, 800a0ee <tcp_process_refused_data+0x3e>
 800a0e0:	2300      	movs	r3, #0
 800a0e2:	461a      	mov	r2, r3
 800a0e4:	4621      	mov	r1, r4
 800a0e6:	6920      	ldr	r0, [r4, #16]
 800a0e8:	47a8      	blx	r5
      if (err == ERR_ABRT) {
 800a0ea:	300a      	adds	r0, #10
 800a0ec:	d00d      	beq.n	800a10a <tcp_process_refused_data+0x5a>
    return ERR_ABRT;
  } else {
    /* data is still refused, pbuf is still valid (go on for ACK-only packets) */
    pcb->refused_data = refused_data;
  }
  return ERR_OK;
 800a0ee:	2000      	movs	r0, #0
}
 800a0f0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      TCP_EVENT_CLOSED(pcb, err);
      if (err == ERR_ABRT) {
        return ERR_ABRT;
      }
    }
  } else if (err == ERR_ABRT) {
 800a0f2:	300a      	adds	r0, #10
 800a0f4:	d009      	beq.n	800a10a <tcp_process_refused_data+0x5a>
       segment contains data). */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
    return ERR_ABRT;
  } else {
    /* data is still refused, pbuf is still valid (go on for ACK-only packets) */
    pcb->refused_data = refused_data;
 800a0f6:	6765      	str	r5, [r4, #116]	; 0x74
  }
  return ERR_OK;
 800a0f8:	2000      	movs	r0, #0
}
 800a0fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     closes the pcb */
  struct pbuf *refused_data = pcb->refused_data;
  pcb->refused_data = NULL;
  /* Notify again application with data previously received. */
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
  TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
 800a0fc:	4633      	mov	r3, r6
 800a0fe:	4630      	mov	r0, r6
 800a100:	462a      	mov	r2, r5
 800a102:	4621      	mov	r1, r4
 800a104:	f7ff ffba 	bl	800a07c <tcp_recv_null>
 800a108:	e7de      	b.n	800a0c8 <tcp_process_refused_data+0x18>
      if (pcb->rcv_wnd != TCP_WND) {
        pcb->rcv_wnd++;
      }
      TCP_EVENT_CLOSED(pcb, err);
      if (err == ERR_ABRT) {
        return ERR_ABRT;
 800a10a:	f06f 0009 	mvn.w	r0, #9
 800a10e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0800a110 <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
 800a110:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  struct tcp_pcb *pcb;

  ++tcp_timer_ctr;
 800a114:	4d17      	ldr	r5, [pc, #92]	; (800a174 <tcp_fasttmr+0x64>)
 800a116:	f8df 8064 	ldr.w	r8, [pc, #100]	; 800a17c <tcp_fasttmr+0x6c>
 800a11a:	782b      	ldrb	r3, [r5, #0]

      next = pcb->next;

      /* If there is data which was previously "refused" by upper layer */
      if (pcb->refused_data != NULL) {
        tcp_active_pcbs_changed = 0;
 800a11c:	4e16      	ldr	r6, [pc, #88]	; (800a178 <tcp_fasttmr+0x68>)
void
tcp_fasttmr(void)
{
  struct tcp_pcb *pcb;

  ++tcp_timer_ctr;
 800a11e:	3301      	adds	r3, #1
 800a120:	702b      	strb	r3, [r5, #0]

      next = pcb->next;

      /* If there is data which was previously "refused" by upper layer */
      if (pcb->refused_data != NULL) {
        tcp_active_pcbs_changed = 0;
 800a122:	2700      	movs	r7, #0
  struct tcp_pcb *pcb;

  ++tcp_timer_ctr;

tcp_fasttmr_start:
  pcb = tcp_active_pcbs;
 800a124:	f8d8 4000 	ldr.w	r4, [r8]

  while(pcb != NULL) {
 800a128:	b12c      	cbz	r4, 800a136 <tcp_fasttmr+0x26>
    if (pcb->last_timer != tcp_timer_ctr) {
 800a12a:	782b      	ldrb	r3, [r5, #0]
 800a12c:	f894 2021 	ldrb.w	r2, [r4, #33]	; 0x21
 800a130:	429a      	cmp	r2, r3
 800a132:	d102      	bne.n	800a13a <tcp_fasttmr+0x2a>
 800a134:	e7fe      	b.n	800a134 <tcp_fasttmr+0x24>
 800a136:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      struct tcp_pcb *next;
      pcb->last_timer = tcp_timer_ctr;
      /* send delayed ACKs */
      if (pcb->flags & TF_ACK_DELAY) {
 800a13a:	7fa2      	ldrb	r2, [r4, #30]
  pcb = tcp_active_pcbs;

  while(pcb != NULL) {
    if (pcb->last_timer != tcp_timer_ctr) {
      struct tcp_pcb *next;
      pcb->last_timer = tcp_timer_ctr;
 800a13c:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
      /* send delayed ACKs */
      if (pcb->flags & TF_ACK_DELAY) {
 800a140:	07d3      	lsls	r3, r2, #31
 800a142:	d40c      	bmi.n	800a15e <tcp_fasttmr+0x4e>
      }

      next = pcb->next;

      /* If there is data which was previously "refused" by upper layer */
      if (pcb->refused_data != NULL) {
 800a144:	6f63      	ldr	r3, [r4, #116]	; 0x74
        tcp_ack_now(pcb);
        tcp_output(pcb);
        pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
      }

      next = pcb->next;
 800a146:	f8d4 900c 	ldr.w	r9, [r4, #12]

      /* If there is data which was previously "refused" by upper layer */
      if (pcb->refused_data != NULL) {
 800a14a:	b133      	cbz	r3, 800a15a <tcp_fasttmr+0x4a>
        tcp_active_pcbs_changed = 0;
        tcp_process_refused_data(pcb);
 800a14c:	4620      	mov	r0, r4

      next = pcb->next;

      /* If there is data which was previously "refused" by upper layer */
      if (pcb->refused_data != NULL) {
        tcp_active_pcbs_changed = 0;
 800a14e:	7037      	strb	r7, [r6, #0]
        tcp_process_refused_data(pcb);
 800a150:	f7ff ffae 	bl	800a0b0 <tcp_process_refused_data>
        if (tcp_active_pcbs_changed) {
 800a154:	7833      	ldrb	r3, [r6, #0]
 800a156:	2b00      	cmp	r3, #0
 800a158:	d1e4      	bne.n	800a124 <tcp_fasttmr+0x14>
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
 800a15a:	464c      	mov	r4, r9
 800a15c:	e7e4      	b.n	800a128 <tcp_fasttmr+0x18>
      struct tcp_pcb *next;
      pcb->last_timer = tcp_timer_ctr;
      /* send delayed ACKs */
      if (pcb->flags & TF_ACK_DELAY) {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
        tcp_ack_now(pcb);
 800a15e:	f042 0202 	orr.w	r2, r2, #2
 800a162:	77a2      	strb	r2, [r4, #30]
        tcp_output(pcb);
 800a164:	4620      	mov	r0, r4
 800a166:	f000 fdfb 	bl	800ad60 <tcp_output>
        pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 800a16a:	7fa3      	ldrb	r3, [r4, #30]
 800a16c:	f023 0303 	bic.w	r3, r3, #3
 800a170:	77a3      	strb	r3, [r4, #30]
 800a172:	e7e7      	b.n	800a144 <tcp_fasttmr+0x34>
 800a174:	200007a7 	.word	0x200007a7
 800a178:	2000f03c 	.word	0x2000f03c
 800a17c:	2000f040 	.word	0x2000f040

0800a180 <tcp_tmr>:
/**
 * Called periodically to dispatch TCP timers.
 */
void
tcp_tmr(void)
{
 800a180:	b508      	push	{r3, lr}
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
 800a182:	f7ff ffc5 	bl	800a110 <tcp_fasttmr>

  if (++tcp_timer & 1) {
 800a186:	4a06      	ldr	r2, [pc, #24]	; (800a1a0 <tcp_tmr+0x20>)
 800a188:	7853      	ldrb	r3, [r2, #1]
 800a18a:	3301      	adds	r3, #1
 800a18c:	b2db      	uxtb	r3, r3
 800a18e:	7053      	strb	r3, [r2, #1]
 800a190:	07db      	lsls	r3, r3, #31
 800a192:	d400      	bmi.n	800a196 <tcp_tmr+0x16>
 800a194:	bd08      	pop	{r3, pc}
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
  }
}
 800a196:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  tcp_fasttmr();

  if (++tcp_timer & 1) {
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
 800a19a:	f7ff bb9b 	b.w	80098d4 <tcp_slowtmr>
 800a19e:	bf00      	nop
 800a1a0:	200007a7 	.word	0x200007a7

0800a1a4 <tcp_shutdown>:
 * @return ERR_OK if shutdown succeeded (or the PCB has already been shut down)
 *         another err_t on error.
 */
err_t
tcp_shutdown(struct tcp_pcb *pcb, int shut_rx, int shut_tx)
{
 800a1a4:	b538      	push	{r3, r4, r5, lr}
  if (pcb->state == LISTEN) {
 800a1a6:	7e04      	ldrb	r4, [r0, #24]
 800a1a8:	2c01      	cmp	r4, #1
 800a1aa:	d020      	beq.n	800a1ee <tcp_shutdown+0x4a>
    return ERR_CONN;
  }
  if (shut_rx) {
 800a1ac:	b171      	cbz	r1, 800a1cc <tcp_shutdown+0x28>
    /* shut down the receive side: set a flag not to receive any more data... */
    pcb->flags |= TF_RXCLOSED;
 800a1ae:	7f81      	ldrb	r1, [r0, #30]
 800a1b0:	4603      	mov	r3, r0
 800a1b2:	f041 0110 	orr.w	r1, r1, #16
 800a1b6:	7781      	strb	r1, [r0, #30]
    if (shut_tx) {
 800a1b8:	b9aa      	cbnz	r2, 800a1e6 <tcp_shutdown+0x42>
      /* shutting down the tx AND rx side is the same as closing for the raw API */
      return tcp_close_shutdown(pcb, 1);
    }
    /* ... and free buffered data */
    if (pcb->refused_data != NULL) {
 800a1ba:	6f40      	ldr	r0, [r0, #116]	; 0x74
 800a1bc:	b120      	cbz	r0, 800a1c8 <tcp_shutdown+0x24>
 800a1be:	4615      	mov	r5, r2
 800a1c0:	461c      	mov	r4, r3
      pbuf_free(pcb->refused_data);
 800a1c2:	f005 ff31 	bl	8010028 <pbuf_free>
      pcb->refused_data = NULL;
 800a1c6:	6765      	str	r5, [r4, #116]	; 0x74
      /* Not (yet?) connected, cannot shutdown the TX side as that would bring us
        into CLOSED state, where the PCB is deallocated. */
      return ERR_CONN;
    }
  }
  return ERR_OK;
 800a1c8:	2000      	movs	r0, #0
}
 800a1ca:	bd38      	pop	{r3, r4, r5, pc}
    if (pcb->refused_data != NULL) {
      pbuf_free(pcb->refused_data);
      pcb->refused_data = NULL;
    }
  }
  if (shut_tx) {
 800a1cc:	2a00      	cmp	r2, #0
 800a1ce:	d0fb      	beq.n	800a1c8 <tcp_shutdown+0x24>
 800a1d0:	2c07      	cmp	r4, #7
 800a1d2:	d80c      	bhi.n	800a1ee <tcp_shutdown+0x4a>
 800a1d4:	2301      	movs	r3, #1
 800a1d6:	fa03 f404 	lsl.w	r4, r3, r4
 800a1da:	f014 0f98 	tst.w	r4, #152	; 0x98
 800a1de:	d006      	beq.n	800a1ee <tcp_shutdown+0x4a>
        into CLOSED state, where the PCB is deallocated. */
      return ERR_CONN;
    }
  }
  return ERR_OK;
}
 800a1e0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
       Only close in these states as the others directly deallocate the PCB */
    switch (pcb->state) {
    case SYN_RCVD:
    case ESTABLISHED:
    case CLOSE_WAIT:
      return tcp_close_shutdown(pcb, shut_rx);
 800a1e4:	e672      	b.n	8009ecc <tcp_close_shutdown>
  if (shut_rx) {
    /* shut down the receive side: set a flag not to receive any more data... */
    pcb->flags |= TF_RXCLOSED;
    if (shut_tx) {
      /* shutting down the tx AND rx side is the same as closing for the raw API */
      return tcp_close_shutdown(pcb, 1);
 800a1e6:	2101      	movs	r1, #1
        into CLOSED state, where the PCB is deallocated. */
      return ERR_CONN;
    }
  }
  return ERR_OK;
}
 800a1e8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  if (shut_rx) {
    /* shut down the receive side: set a flag not to receive any more data... */
    pcb->flags |= TF_RXCLOSED;
    if (shut_tx) {
      /* shutting down the tx AND rx side is the same as closing for the raw API */
      return tcp_close_shutdown(pcb, 1);
 800a1ec:	e66e      	b.n	8009ecc <tcp_close_shutdown>
 */
err_t
tcp_shutdown(struct tcp_pcb *pcb, int shut_rx, int shut_tx)
{
  if (pcb->state == LISTEN) {
    return ERR_CONN;
 800a1ee:	f06f 000c 	mvn.w	r0, #12
 800a1f2:	bd38      	pop	{r3, r4, r5, pc}

0800a1f4 <tcp_abandon>:
 * @param pcb the tcp_pcb to abort
 * @param reset boolean to indicate whether a reset should be sent
 */
void
tcp_abandon(struct tcp_pcb *pcb, int reset)
{
 800a1f4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  tcp_err_fn errf;
#endif /* LWIP_CALLBACK_API */
  void *errf_arg;

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
 800a1f8:	7e03      	ldrb	r3, [r0, #24]
 * @param pcb the tcp_pcb to abort
 * @param reset boolean to indicate whether a reset should be sent
 */
void
tcp_abandon(struct tcp_pcb *pcb, int reset)
{
 800a1fa:	b082      	sub	sp, #8
  tcp_err_fn errf;
#endif /* LWIP_CALLBACK_API */
  void *errf_arg;

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
 800a1fc:	2b01      	cmp	r3, #1
 * @param pcb the tcp_pcb to abort
 * @param reset boolean to indicate whether a reset should be sent
 */
void
tcp_abandon(struct tcp_pcb *pcb, int reset)
{
 800a1fe:	4604      	mov	r4, r0
 800a200:	460e      	mov	r6, r1
  tcp_err_fn errf;
#endif /* LWIP_CALLBACK_API */
  void *errf_arg;

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
 800a202:	d04c      	beq.n	800a29e <tcp_abandon+0xaa>
    pcb->state != LISTEN);
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
 800a204:	2b0a      	cmp	r3, #10
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
 800a206:	4621      	mov	r1, r4
  LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
    pcb->state != LISTEN);
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
 800a208:	d03f      	beq.n	800a28a <tcp_abandon+0x96>
    ackno = pcb->rcv_nxt;
#if LWIP_CALLBACK_API
    errf = pcb->errf;
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
    TCP_PCB_REMOVE_ACTIVE(pcb);
 800a20a:	4829      	ldr	r0, [pc, #164]	; (800a2b0 <tcp_abandon+0xbc>)
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
    memp_free(MEMP_TCP_PCB, pcb);
  } else {
    seqno = pcb->snd_nxt;
 800a20c:	f8d4 8050 	ldr.w	r8, [r4, #80]	; 0x50
    ackno = pcb->rcv_nxt;
 800a210:	f8d4 9028 	ldr.w	r9, [r4, #40]	; 0x28
#if LWIP_CALLBACK_API
    errf = pcb->errf;
 800a214:	f8d4 5088 	ldr.w	r5, [r4, #136]	; 0x88
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
 800a218:	6927      	ldr	r7, [r4, #16]
    TCP_PCB_REMOVE_ACTIVE(pcb);
 800a21a:	f7ff fdfd 	bl	8009e18 <tcp_pcb_remove>
 800a21e:	4b25      	ldr	r3, [pc, #148]	; (800a2b4 <tcp_abandon+0xc0>)
    if (pcb->unacked != NULL) {
 800a220:	6f20      	ldr	r0, [r4, #112]	; 0x70
    ackno = pcb->rcv_nxt;
#if LWIP_CALLBACK_API
    errf = pcb->errf;
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
    TCP_PCB_REMOVE_ACTIVE(pcb);
 800a222:	2201      	movs	r2, #1
 800a224:	701a      	strb	r2, [r3, #0]
    if (pcb->unacked != NULL) {
 800a226:	b130      	cbz	r0, 800a236 <tcp_abandon+0x42>
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
    struct tcp_seg *next = seg->next;
 800a228:	f8d0 a000 	ldr.w	sl, [r0]
    tcp_seg_free(seg);
 800a22c:	f7ff fb18 	bl	8009860 <tcp_seg_free>
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 800a230:	4650      	mov	r0, sl
 800a232:	2800      	cmp	r0, #0
 800a234:	d1f8      	bne.n	800a228 <tcp_abandon+0x34>
    errf_arg = pcb->callback_arg;
    TCP_PCB_REMOVE_ACTIVE(pcb);
    if (pcb->unacked != NULL) {
      tcp_segs_free(pcb->unacked);
    }
    if (pcb->unsent != NULL) {
 800a236:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 800a238:	b130      	cbz	r0, 800a248 <tcp_abandon+0x54>
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
    struct tcp_seg *next = seg->next;
 800a23a:	f8d0 a000 	ldr.w	sl, [r0]
    tcp_seg_free(seg);
 800a23e:	f7ff fb0f 	bl	8009860 <tcp_seg_free>
 * @param seg tcp_seg list of TCP segments to free
 */
void
tcp_segs_free(struct tcp_seg *seg)
{
  while (seg != NULL) {
 800a242:	4650      	mov	r0, sl
 800a244:	2800      	cmp	r0, #0
 800a246:	d1f8      	bne.n	800a23a <tcp_abandon+0x46>
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
      tcp_segs_free(pcb->ooseq);
    }
#endif /* TCP_QUEUE_OOSEQ */
    if (reset) {
 800a248:	b966      	cbnz	r6, 800a264 <tcp_abandon+0x70>
      LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
      tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
    }
    memp_free(MEMP_TCP_PCB, pcb);
 800a24a:	4621      	mov	r1, r4
 800a24c:	2002      	movs	r0, #2
 800a24e:	f005 fd55 	bl	800fcfc <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
 800a252:	b1bd      	cbz	r5, 800a284 <tcp_abandon+0x90>
 800a254:	4638      	mov	r0, r7
 800a256:	462b      	mov	r3, r5
 800a258:	f06f 0109 	mvn.w	r1, #9
  }
}
 800a25c:	b002      	add	sp, #8
 800a25e:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    if (reset) {
      LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
      tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
    }
    memp_free(MEMP_TCP_PCB, pcb);
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
 800a262:	4718      	bx	r3
      tcp_segs_free(pcb->ooseq);
    }
#endif /* TCP_QUEUE_OOSEQ */
    if (reset) {
      LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
      tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
 800a264:	8ba2      	ldrh	r2, [r4, #28]
 800a266:	8b63      	ldrh	r3, [r4, #26]
 800a268:	4649      	mov	r1, r9
 800a26a:	4640      	mov	r0, r8
 800a26c:	9201      	str	r2, [sp, #4]
 800a26e:	9300      	str	r3, [sp, #0]
 800a270:	4622      	mov	r2, r4
 800a272:	1d23      	adds	r3, r4, #4
 800a274:	f000 fee6 	bl	800b044 <tcp_rst>
    }
    memp_free(MEMP_TCP_PCB, pcb);
 800a278:	4621      	mov	r1, r4
 800a27a:	2002      	movs	r0, #2
 800a27c:	f005 fd3e 	bl	800fcfc <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
 800a280:	2d00      	cmp	r5, #0
 800a282:	d1e7      	bne.n	800a254 <tcp_abandon+0x60>
  }
}
 800a284:	b002      	add	sp, #8
 800a286:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    pcb->state != LISTEN);
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
 800a28a:	480b      	ldr	r0, [pc, #44]	; (800a2b8 <tcp_abandon+0xc4>)
 800a28c:	f7ff fdc4 	bl	8009e18 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
 800a290:	4621      	mov	r1, r4
 800a292:	2002      	movs	r0, #2
      tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, pcb->local_port, pcb->remote_port);
    }
    memp_free(MEMP_TCP_PCB, pcb);
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  }
}
 800a294:	b002      	add	sp, #8
 800a296:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
    memp_free(MEMP_TCP_PCB, pcb);
 800a29a:	f005 bd2f 	b.w	800fcfc <memp_free>
  tcp_err_fn errf;
#endif /* LWIP_CALLBACK_API */
  void *errf_arg;

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
 800a29e:	4b07      	ldr	r3, [pc, #28]	; (800a2bc <tcp_abandon+0xc8>)
 800a2a0:	f240 126f 	movw	r2, #367	; 0x16f
 800a2a4:	4906      	ldr	r1, [pc, #24]	; (800a2c0 <tcp_abandon+0xcc>)
 800a2a6:	4807      	ldr	r0, [pc, #28]	; (800a2c4 <tcp_abandon+0xd0>)
 800a2a8:	f00a fd66 	bl	8014d78 <iprintf>
 800a2ac:	7e23      	ldrb	r3, [r4, #24]
 800a2ae:	e7a9      	b.n	800a204 <tcp_abandon+0x10>
 800a2b0:	2000f040 	.word	0x2000f040
 800a2b4:	2000f03c 	.word	0x2000f03c
 800a2b8:	2000f054 	.word	0x2000f054
 800a2bc:	080166c8 	.word	0x080166c8
 800a2c0:	08016a04 	.word	0x08016a04
 800a2c4:	0801660c 	.word	0x0801660c

0800a2c8 <tcp_abort>:
 * @param pcb the tcp pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
  tcp_abandon(pcb, 1);
 800a2c8:	2101      	movs	r1, #1
 800a2ca:	f7ff bf93 	b.w	800a1f4 <tcp_abandon>
 800a2ce:	bf00      	nop

0800a2d0 <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
 800a2d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800a2d4:	4605      	mov	r5, r0
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 800a2d6:	2002      	movs	r0, #2
 800a2d8:	f005 fcda 	bl	800fc90 <memp_malloc>
  if (pcb == NULL) {
 800a2dc:	4604      	mov	r4, r0
 800a2de:	2800      	cmp	r0, #0
 800a2e0:	d03f      	beq.n	800a362 <tcp_alloc+0x92>
      /* adjust err stats: timewait PCB was freed above */
      MEMP_STATS_DEC(err, MEMP_TCP_PCB);
    }
  }
  if (pcb != NULL) {
    memset(pcb, 0, sizeof(struct tcp_pcb));
 800a2e2:	2294      	movs	r2, #148	; 0x94
 800a2e4:	2100      	movs	r1, #0
 800a2e6:	4620      	mov	r0, r4
 800a2e8:	f00a fd3e 	bl	8014d68 <memset>
    pcb->prio = prio;
    pcb->snd_buf = TCP_SND_BUF;
    pcb->snd_queuelen = 0;
    pcb->rcv_wnd = TCP_WND;
 800a2ec:	f640 3268 	movw	r2, #2920	; 0xb68
    }
  }
  if (pcb != NULL) {
    memset(pcb, 0, sizeof(struct tcp_pcb));
    pcb->prio = prio;
    pcb->snd_buf = TCP_SND_BUF;
 800a2f0:	f241 6cd0 	movw	ip, #5840	; 0x16d0
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
    pcb->sa = 0;
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
    pcb->rtime = -1;
 800a2f4:	f64f 7eff 	movw	lr, #65535	; 0xffff
u32_t
tcp_next_iss(void)
{
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
 800a2f8:	4937      	ldr	r1, [pc, #220]	; (800a3d8 <tcp_alloc+0x108>)
    pcb->snd_wl2 = iss;
    pcb->snd_nxt = iss;
    pcb->lastack = iss;
    pcb->snd_lbb = iss;   
    pcb->tmr = tcp_ticks;
    pcb->last_timer = tcp_timer_ctr;
 800a2fa:	4b38      	ldr	r3, [pc, #224]	; (800a3dc <tcp_alloc+0x10c>)
u32_t
tcp_next_iss(void)
{
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
 800a2fc:	4838      	ldr	r0, [pc, #224]	; (800a3e0 <tcp_alloc+0x110>)
    pcb->snd_wl2 = iss;
    pcb->snd_nxt = iss;
    pcb->lastack = iss;
    pcb->snd_lbb = iss;   
    pcb->tmr = tcp_ticks;
    pcb->last_timer = tcp_timer_ctr;
 800a2fe:	f893 8000 	ldrb.w	r8, [r3]
u32_t
tcp_next_iss(void)
{
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
 800a302:	6800      	ldr	r0, [r0, #0]
 800a304:	684b      	ldr	r3, [r1, #4]
    pcb->last_timer = tcp_timer_ctr;

    pcb->polltmr = 0;

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
 800a306:	4f37      	ldr	r7, [pc, #220]	; (800a3e4 <tcp_alloc+0x114>)
u32_t
tcp_next_iss(void)
{
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
 800a308:	4403      	add	r3, r0
#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
 800a30a:	4e37      	ldr	r6, [pc, #220]	; (800a3e8 <tcp_alloc+0x118>)
u32_t
tcp_next_iss(void)
{
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
 800a30c:	604b      	str	r3, [r1, #4]
      MEMP_STATS_DEC(err, MEMP_TCP_PCB);
    }
  }
  if (pcb != NULL) {
    memset(pcb, 0, sizeof(struct tcp_pcb));
    pcb->prio = prio;
 800a30e:	7665      	strb	r5, [r4, #25]
    iss = tcp_next_iss();
    pcb->snd_wl2 = iss;
    pcb->snd_nxt = iss;
    pcb->lastack = iss;
    pcb->snd_lbb = iss;   
    pcb->tmr = tcp_ticks;
 800a310:	6260      	str	r0, [r4, #36]	; 0x24
    pcb->sa = 0;
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
    pcb->rtime = -1;
    pcb->cwnd = 1;
    iss = tcp_next_iss();
    pcb->snd_wl2 = iss;
 800a312:	65a3      	str	r3, [r4, #88]	; 0x58
    pcb->snd_nxt = iss;
 800a314:	6523      	str	r3, [r4, #80]	; 0x50
    pcb->lastack = iss;
 800a316:	64a3      	str	r3, [r4, #72]	; 0x48
    pcb->snd_lbb = iss;   
 800a318:	65e3      	str	r3, [r4, #92]	; 0x5c
    pcb->snd_buf = TCP_SND_BUF;
    pcb->snd_queuelen = 0;
    pcb->rcv_wnd = TCP_WND;
    pcb->rcv_ann_wnd = TCP_WND;
    pcb->tos = 0;
    pcb->ttl = TCP_TTL;
 800a31a:	25ff      	movs	r5, #255	; 0xff
  }
  if (pcb != NULL) {
    memset(pcb, 0, sizeof(struct tcp_pcb));
    pcb->prio = prio;
    pcb->snd_buf = TCP_SND_BUF;
    pcb->snd_queuelen = 0;
 800a31c:	2300      	movs	r3, #0
    pcb->rcv_ann_wnd = TCP_WND;
    pcb->tos = 0;
    pcb->ttl = TCP_TTL;
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
 800a31e:	f44f 7006 	mov.w	r0, #536	; 0x218
  if (pcb != NULL) {
    memset(pcb, 0, sizeof(struct tcp_pcb));
    pcb->prio = prio;
    pcb->snd_buf = TCP_SND_BUF;
    pcb->snd_queuelen = 0;
    pcb->rcv_wnd = TCP_WND;
 800a322:	85a2      	strh	r2, [r4, #44]	; 0x2c
    pcb->rcv_ann_wnd = TCP_WND;
 800a324:	85e2      	strh	r2, [r4, #46]	; 0x2e
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
    pcb->sa = 0;
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
    pcb->rtime = -1;
    pcb->cwnd = 1;
 800a326:	2101      	movs	r1, #1
    pcb->tos = 0;
    pcb->ttl = TCP_TTL;
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
 800a328:	2206      	movs	r2, #6
    pcb->snd_wl2 = iss;
    pcb->snd_nxt = iss;
    pcb->lastack = iss;
    pcb->snd_lbb = iss;   
    pcb->tmr = tcp_ticks;
    pcb->last_timer = tcp_timer_ctr;
 800a32a:	f884 8021 	strb.w	r8, [r4, #33]	; 0x21
    }
  }
  if (pcb != NULL) {
    memset(pcb, 0, sizeof(struct tcp_pcb));
    pcb->prio = prio;
    pcb->snd_buf = TCP_SND_BUF;
 800a32e:	f8a4 c066 	strh.w	ip, [r4, #102]	; 0x66
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
    pcb->sa = 0;
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
    pcb->rtime = -1;
 800a332:	f8a4 e034 	strh.w	lr, [r4, #52]	; 0x34
    pcb->last_timer = tcp_timer_ctr;

    pcb->polltmr = 0;

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
 800a336:	67e7      	str	r7, [r4, #124]	; 0x7c
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
 800a338:	f8c4 608c 	str.w	r6, [r4, #140]	; 0x8c
  }
  if (pcb != NULL) {
    memset(pcb, 0, sizeof(struct tcp_pcb));
    pcb->prio = prio;
    pcb->snd_buf = TCP_SND_BUF;
    pcb->snd_queuelen = 0;
 800a33c:	f8a4 3068 	strh.w	r3, [r4, #104]	; 0x68
    pcb->rcv_wnd = TCP_WND;
    pcb->rcv_ann_wnd = TCP_WND;
    pcb->tos = 0;
 800a340:	7263      	strb	r3, [r4, #9]
    pcb->ttl = TCP_TTL;
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
    pcb->sa = 0;
 800a342:	f8a4 3040 	strh.w	r3, [r4, #64]	; 0x40
    pcb->lastack = iss;
    pcb->snd_lbb = iss;   
    pcb->tmr = tcp_ticks;
    pcb->last_timer = tcp_timer_ctr;

    pcb->polltmr = 0;
 800a346:	77e3      	strb	r3, [r4, #31]
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
 800a348:	f884 3092 	strb.w	r3, [r4, #146]	; 0x92
    pcb->snd_buf = TCP_SND_BUF;
    pcb->snd_queuelen = 0;
    pcb->rcv_wnd = TCP_WND;
    pcb->rcv_ann_wnd = TCP_WND;
    pcb->tos = 0;
    pcb->ttl = TCP_TTL;
 800a34c:	72a5      	strb	r5, [r4, #10]
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
 800a34e:	86e0      	strh	r0, [r4, #54]	; 0x36
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
 800a350:	f8a4 2044 	strh.w	r2, [r4, #68]	; 0x44
    pcb->sa = 0;
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
 800a354:	f8a4 2042 	strh.w	r2, [r4, #66]	; 0x42
    pcb->rtime = -1;
    pcb->cwnd = 1;
 800a358:	f8a4 104c 	strh.w	r1, [r4, #76]	; 0x4c
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
  }
  return pcb;
}
 800a35c:	4620      	mov	r0, r4
 800a35e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 800a362:	4b22      	ldr	r3, [pc, #136]	; (800a3ec <tcp_alloc+0x11c>)
 800a364:	6818      	ldr	r0, [r3, #0]
 800a366:	b188      	cbz	r0, 800a38c <tcp_alloc+0xbc>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 800a368:	4b1d      	ldr	r3, [pc, #116]	; (800a3e0 <tcp_alloc+0x110>)
 800a36a:	6a41      	ldr	r1, [r0, #36]	; 0x24
 800a36c:	681c      	ldr	r4, [r3, #0]
 800a36e:	4603      	mov	r3, r0
 800a370:	1a61      	subs	r1, r4, r1
 800a372:	e005      	b.n	800a380 <tcp_alloc+0xb0>
 800a374:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800a376:	1aa2      	subs	r2, r4, r2
 800a378:	428a      	cmp	r2, r1
 800a37a:	bf24      	itt	cs
 800a37c:	4611      	movcs	r1, r2
 800a37e:	4618      	movcs	r0, r3
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 800a380:	68db      	ldr	r3, [r3, #12]
 800a382:	2b00      	cmp	r3, #0
 800a384:	d1f6      	bne.n	800a374 <tcp_alloc+0xa4>
 * @param pcb the tcp pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
  tcp_abandon(pcb, 1);
 800a386:	2101      	movs	r1, #1
 800a388:	f7ff ff34 	bl	800a1f4 <tcp_abandon>
  if (pcb == NULL) {
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
    /* Try to allocate a tcp_pcb again. */
    pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 800a38c:	2002      	movs	r0, #2
 800a38e:	f005 fc7f 	bl	800fc90 <memp_malloc>
    if (pcb == NULL) {
 800a392:	4604      	mov	r4, r0
 800a394:	2800      	cmp	r0, #0
 800a396:	d1a4      	bne.n	800a2e2 <tcp_alloc+0x12>
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800a398:	4b15      	ldr	r3, [pc, #84]	; (800a3f0 <tcp_alloc+0x120>)
 800a39a:	681b      	ldr	r3, [r3, #0]
 800a39c:	b1ab      	cbz	r3, 800a3ca <tcp_alloc+0xfa>
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 800a39e:	4a10      	ldr	r2, [pc, #64]	; (800a3e0 <tcp_alloc+0x110>)
 800a3a0:	267f      	movs	r6, #127	; 0x7f
 800a3a2:	6817      	ldr	r7, [r2, #0]
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
 800a3a4:	7e5a      	ldrb	r2, [r3, #25]
 800a3a6:	4295      	cmp	r5, r2
 800a3a8:	d308      	bcc.n	800a3bc <tcp_alloc+0xec>
 800a3aa:	42b2      	cmp	r2, r6
 800a3ac:	d806      	bhi.n	800a3bc <tcp_alloc+0xec>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
 800a3ae:	6a59      	ldr	r1, [r3, #36]	; 0x24
 800a3b0:	1a79      	subs	r1, r7, r1
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
 800a3b2:	42a1      	cmp	r1, r4
 800a3b4:	d302      	bcc.n	800a3bc <tcp_alloc+0xec>
 800a3b6:	4616      	mov	r6, r2
 800a3b8:	460c      	mov	r4, r1
 800a3ba:	4618      	mov	r0, r3
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 800a3bc:	68db      	ldr	r3, [r3, #12]
 800a3be:	2b00      	cmp	r3, #0
 800a3c0:	d1f0      	bne.n	800a3a4 <tcp_alloc+0xd4>
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
    }
  }
  if (inactive != NULL) {
 800a3c2:	b110      	cbz	r0, 800a3ca <tcp_alloc+0xfa>
 * @param pcb the tcp pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
  tcp_abandon(pcb, 1);
 800a3c4:	2101      	movs	r1, #1
 800a3c6:	f7ff ff15 	bl	800a1f4 <tcp_abandon>
    if (pcb == NULL) {
      /* Try killing active connections with lower priority than the new one. */
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing connection with prio lower than %d\n", prio));
      tcp_kill_prio(prio);
      /* Try to allocate a tcp_pcb again. */
      pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
 800a3ca:	2002      	movs	r0, #2
 800a3cc:	f005 fc60 	bl	800fc90 <memp_malloc>
    if (pcb != NULL) {
      /* adjust err stats: timewait PCB was freed above */
      MEMP_STATS_DEC(err, MEMP_TCP_PCB);
    }
  }
  if (pcb != NULL) {
 800a3d0:	4604      	mov	r4, r0
 800a3d2:	2800      	cmp	r0, #0
 800a3d4:	d0c2      	beq.n	800a35c <tcp_alloc+0x8c>
 800a3d6:	e784      	b.n	800a2e2 <tcp_alloc+0x12>
 800a3d8:	20000024 	.word	0x20000024
 800a3dc:	200007a7 	.word	0x200007a7
 800a3e0:	2000f044 	.word	0x2000f044
 800a3e4:	0800a07d 	.word	0x0800a07d
 800a3e8:	006ddd00 	.word	0x006ddd00
 800a3ec:	2000f054 	.word	0x2000f054
 800a3f0:	2000f040 	.word	0x2000f040

0800a3f4 <tcp_new>:
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
  return tcp_alloc(TCP_PRIO_NORMAL);
 800a3f4:	2040      	movs	r0, #64	; 0x40
 800a3f6:	f7ff bf6b 	b.w	800a2d0 <tcp_alloc>
 800a3fa:	bf00      	nop

0800a3fc <tcp_next_iss>:
u32_t
tcp_next_iss(void)
{
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
 800a3fc:	4a03      	ldr	r2, [pc, #12]	; (800a40c <tcp_next_iss+0x10>)
 800a3fe:	4b04      	ldr	r3, [pc, #16]	; (800a410 <tcp_next_iss+0x14>)
 800a400:	6850      	ldr	r0, [r2, #4]
 800a402:	681b      	ldr	r3, [r3, #0]
 800a404:	4418      	add	r0, r3
 800a406:	6050      	str	r0, [r2, #4]
  return iss;
}
 800a408:	4770      	bx	lr
 800a40a:	bf00      	nop
 800a40c:	20000024 	.word	0x20000024
 800a410:	2000f044 	.word	0x2000f044

0800a414 <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, ip_addr_t *addr)
{
 800a414:	b510      	push	{r4, lr}
 800a416:	4604      	mov	r4, r0
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
 800a418:	4608      	mov	r0, r1
 800a41a:	f004 fad9 	bl	800e9d0 <ip_route>
  if ((outif != NULL) && (outif->mtu != 0)) {
 800a41e:	b130      	cbz	r0, 800a42e <tcp_eff_send_mss+0x1a>
 800a420:	8c03      	ldrh	r3, [r0, #32]
 800a422:	b123      	cbz	r3, 800a42e <tcp_eff_send_mss+0x1a>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * We correct for TCP options in tcp_write(), and don't support IP options.
     */
    sendmss = LWIP_MIN(sendmss, mss_s);
 800a424:	3b28      	subs	r3, #40	; 0x28
 800a426:	b29b      	uxth	r3, r3
 800a428:	429c      	cmp	r4, r3
 800a42a:	bf28      	it	cs
 800a42c:	461c      	movcs	r4, r3
  }
  return sendmss;
}
 800a42e:	4620      	mov	r0, r4
 800a430:	bd10      	pop	{r4, pc}
 800a432:	bf00      	nop

0800a434 <tcp_debug_state_str>:
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

const char*
tcp_debug_state_str(enum tcp_state s)
{
  return tcp_state_str[s];
 800a434:	4b02      	ldr	r3, [pc, #8]	; (800a440 <tcp_debug_state_str+0xc>)
 800a436:	eb03 0080 	add.w	r0, r3, r0, lsl #2
}
 800a43a:	6a80      	ldr	r0, [r0, #40]	; 0x28
 800a43c:	4770      	bx	lr
 800a43e:	bf00      	nop
 800a440:	08016130 	.word	0x08016130

0800a444 <tcp_pbuf_prealloc>:
#if TCP_OVERSIZE
static struct pbuf *
tcp_pbuf_prealloc(pbuf_layer layer, u16_t length, u16_t max_length,
                  u16_t *oversize, struct tcp_pcb *pcb, u8_t apiflags,
                  u8_t first_seg)
{
 800a444:	b570      	push	{r4, r5, r6, lr}
 800a446:	460d      	mov	r5, r1
  LWIP_UNUSED_ARG(apiflags);
  LWIP_UNUSED_ARG(first_seg);
  /* always create MSS-sized pbufs */
  alloc = max_length;
#else /* LWIP_NETIF_TX_SINGLE_PBUF */
  if (length < max_length) {
 800a448:	4295      	cmp	r5, r2
#if TCP_OVERSIZE
static struct pbuf *
tcp_pbuf_prealloc(pbuf_layer layer, u16_t length, u16_t max_length,
                  u16_t *oversize, struct tcp_pcb *pcb, u8_t apiflags,
                  u8_t first_seg)
{
 800a44a:	461e      	mov	r6, r3
 800a44c:	f89d 1018 	ldrb.w	r1, [sp, #24]
 800a450:	f89d 3014 	ldrb.w	r3, [sp, #20]
  LWIP_UNUSED_ARG(apiflags);
  LWIP_UNUSED_ARG(first_seg);
  /* always create MSS-sized pbufs */
  alloc = max_length;
#else /* LWIP_NETIF_TX_SINGLE_PBUF */
  if (length < max_length) {
 800a454:	d20e      	bcs.n	800a474 <tcp_pbuf_prealloc+0x30>
     *
     * Did the user set TCP_WRITE_FLAG_MORE?
     *
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
 800a456:	079c      	lsls	r4, r3, #30
 800a458:	d508      	bpl.n	800a46c <tcp_pbuf_prealloc+0x28>
        (!(pcb->flags & TF_NODELAY) &&
         (!first_seg ||
          pcb->unsent != NULL ||
          pcb->unacked != NULL))) {
      alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(length + TCP_OVERSIZE));
 800a45a:	f205 51b7 	addw	r1, r5, #1463	; 0x5b7
 800a45e:	f021 0103 	bic.w	r1, r1, #3
 800a462:	428a      	cmp	r2, r1
 800a464:	bfa8      	it	ge
 800a466:	460a      	movge	r2, r1
 800a468:	b291      	uxth	r1, r2
 800a46a:	e004      	b.n	800a476 <tcp_pbuf_prealloc+0x32>
     *
     * Did the user set TCP_WRITE_FLAG_MORE?
     *
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
 800a46c:	9b04      	ldr	r3, [sp, #16]
 800a46e:	7f9b      	ldrb	r3, [r3, #30]
 800a470:	065b      	lsls	r3, r3, #25
 800a472:	d515      	bpl.n	800a4a0 <tcp_pbuf_prealloc+0x5c>
 800a474:	4629      	mov	r1, r5
          pcb->unacked != NULL))) {
      alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(length + TCP_OVERSIZE));
    }
  }
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
  p = pbuf_alloc(layer, alloc, PBUF_RAM);
 800a476:	2200      	movs	r2, #0
 800a478:	f005 fe2e 	bl	80100d8 <pbuf_alloc>
  if (p == NULL) {
 800a47c:	4604      	mov	r4, r0
 800a47e:	b168      	cbz	r0, 800a49c <tcp_pbuf_prealloc+0x58>
    return NULL;
  }
  LWIP_ASSERT("need unchained pbuf", p->next == NULL);
 800a480:	6803      	ldr	r3, [r0, #0]
 800a482:	b133      	cbz	r3, 800a492 <tcp_pbuf_prealloc+0x4e>
 800a484:	4b0c      	ldr	r3, [pc, #48]	; (800a4b8 <tcp_pbuf_prealloc+0x74>)
 800a486:	f240 1203 	movw	r2, #259	; 0x103
 800a48a:	490c      	ldr	r1, [pc, #48]	; (800a4bc <tcp_pbuf_prealloc+0x78>)
 800a48c:	480c      	ldr	r0, [pc, #48]	; (800a4c0 <tcp_pbuf_prealloc+0x7c>)
 800a48e:	f00a fc73 	bl	8014d78 <iprintf>
  *oversize = p->len - length;
 800a492:	8963      	ldrh	r3, [r4, #10]
 800a494:	1b5b      	subs	r3, r3, r5
 800a496:	8033      	strh	r3, [r6, #0]
  /* trim p->len to the currently used size */
  p->len = p->tot_len = length;
 800a498:	8125      	strh	r5, [r4, #8]
 800a49a:	8165      	strh	r5, [r4, #10]
  return p;
}
 800a49c:	4620      	mov	r0, r4
 800a49e:	bd70      	pop	{r4, r5, r6, pc}
     * Did the user set TCP_WRITE_FLAG_MORE?
     *
     * Will the Nagle algorithm defer transmission of this segment?
     */
    if ((apiflags & TCP_WRITE_FLAG_MORE) ||
        (!(pcb->flags & TF_NODELAY) &&
 800a4a0:	2900      	cmp	r1, #0
 800a4a2:	d0da      	beq.n	800a45a <tcp_pbuf_prealloc+0x16>
         (!first_seg ||
 800a4a4:	9b04      	ldr	r3, [sp, #16]
 800a4a6:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800a4a8:	2b00      	cmp	r3, #0
 800a4aa:	d1d6      	bne.n	800a45a <tcp_pbuf_prealloc+0x16>
          pcb->unsent != NULL ||
 800a4ac:	9b04      	ldr	r3, [sp, #16]
 800a4ae:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800a4b0:	2b00      	cmp	r3, #0
 800a4b2:	d1d2      	bne.n	800a45a <tcp_pbuf_prealloc+0x16>
 800a4b4:	e7de      	b.n	800a474 <tcp_pbuf_prealloc+0x30>
 800a4b6:	bf00      	nop
 800a4b8:	08016aa0 	.word	0x08016aa0
 800a4bc:	08016ab4 	.word	0x08016ab4
 800a4c0:	0801660c 	.word	0x0801660c

0800a4c4 <tcp_create_segment.isra.0>:
 * @return a new tcp_seg pointing to p, or NULL.
 * The TCP header is filled in except ackno and wnd.
 * p is freed on failure.
 */
static struct tcp_seg *
tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
 800a4c4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800a4c8:	f89d 6024 	ldrb.w	r6, [sp, #36]	; 0x24
 800a4cc:	4681      	mov	r9, r0
{
  struct tcp_seg *seg;
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
 800a4ce:	f016 0501 	ands.w	r5, r6, #1
 800a4d2:	f006 0402 	and.w	r4, r6, #2

  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
 800a4d6:	f04f 0004 	mov.w	r0, #4
 */
static struct tcp_seg *
tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
{
  struct tcp_seg *seg;
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
 800a4da:	bf18      	it	ne
 800a4dc:	2504      	movne	r5, #4
 * @return a new tcp_seg pointing to p, or NULL.
 * The TCP header is filled in except ackno and wnd.
 * p is freed on failure.
 */
static struct tcp_seg *
tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
 800a4de:	468a      	mov	sl, r1
{
  struct tcp_seg *seg;
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
 800a4e0:	2c00      	cmp	r4, #0
 800a4e2:	bf14      	ite	ne
 800a4e4:	240c      	movne	r4, #12
 800a4e6:	2400      	moveq	r4, #0
 * @return a new tcp_seg pointing to p, or NULL.
 * The TCP header is filled in except ackno and wnd.
 * p is freed on failure.
 */
static struct tcp_seg *
tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
 800a4e8:	4690      	mov	r8, r2
 800a4ea:	461f      	mov	r7, r3
{
  struct tcp_seg *seg;
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);

  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
 800a4ec:	f005 fbd0 	bl	800fc90 <memp_malloc>
 */
static struct tcp_seg *
tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
{
  struct tcp_seg *seg;
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
 800a4f0:	4425      	add	r5, r4

  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
 800a4f2:	4604      	mov	r4, r0
 800a4f4:	2800      	cmp	r0, #0
 800a4f6:	d039      	beq.n	800a56c <tcp_create_segment.isra.0+0xa8>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
    pbuf_free(p);
    return NULL;
  }
  seg->flags = optflags;
 800a4f8:	7286      	strb	r6, [r0, #10]
  seg->next = NULL;
  seg->p = p;
  seg->len = p->tot_len - optlen;
 800a4fa:	f8b8 3008 	ldrh.w	r3, [r8, #8]
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
    pbuf_free(p);
    return NULL;
  }
  seg->flags = optflags;
  seg->next = NULL;
 800a4fe:	2600      	movs	r6, #0
  seg->p = p;
  seg->len = p->tot_len - optlen;
 800a500:	1b5b      	subs	r3, r3, r5
    pbuf_free(p);
    return NULL;
  }
  seg->flags = optflags;
  seg->next = NULL;
  seg->p = p;
 800a502:	f8c0 8004 	str.w	r8, [r0, #4]
  seg->len = p->tot_len - optlen;
 800a506:	8103      	strh	r3, [r0, #8]
  LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED",
              (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
#endif /* TCP_CHECKSUM_ON_COPY */

  /* build TCP header */
  if (pbuf_header(p, TCP_HLEN)) {
 800a508:	2114      	movs	r1, #20
 800a50a:	4640      	mov	r0, r8
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
    pbuf_free(p);
    return NULL;
  }
  seg->flags = optflags;
  seg->next = NULL;
 800a50c:	6026      	str	r6, [r4, #0]
  LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED",
              (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
#endif /* TCP_CHECKSUM_ON_COPY */

  /* build TCP header */
  if (pbuf_header(p, TCP_HLEN)) {
 800a50e:	f005 fd33 	bl	800ff78 <pbuf_header>
 800a512:	4680      	mov	r8, r0
 800a514:	bb30      	cbnz	r0, 800a564 <tcp_create_segment.isra.0+0xa0>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    TCP_STATS_INC(tcp.err);
    tcp_seg_free(seg);
    return NULL;
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
 800a516:	6863      	ldr	r3, [r4, #4]
  seg->tcphdr->src = htons(pcb->local_port);
 800a518:	f8b9 0000 	ldrh.w	r0, [r9]
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    TCP_STATS_INC(tcp.err);
    tcp_seg_free(seg);
    return NULL;
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
 800a51c:	685e      	ldr	r6, [r3, #4]
  seg->tcphdr->src = htons(pcb->local_port);
  seg->tcphdr->dest = htons(pcb->remote_port);
  seg->tcphdr->seqno = htonl(seqno);
  /* ackno is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
 800a51e:	f3c5 0587 	ubfx	r5, r5, #2, #8
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    TCP_STATS_INC(tcp.err);
    tcp_seg_free(seg);
    return NULL;
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
 800a522:	60e6      	str	r6, [r4, #12]
  seg->tcphdr->src = htons(pcb->local_port);
 800a524:	f003 fb38 	bl	800db98 <lwip_htons>
 800a528:	8030      	strh	r0, [r6, #0]
  seg->tcphdr->dest = htons(pcb->remote_port);
 800a52a:	f8ba 0000 	ldrh.w	r0, [sl]
 800a52e:	68e6      	ldr	r6, [r4, #12]
 800a530:	f003 fb32 	bl	800db98 <lwip_htons>
 800a534:	8070      	strh	r0, [r6, #2]
  seg->tcphdr->seqno = htonl(seqno);
 800a536:	9808      	ldr	r0, [sp, #32]
 800a538:	68e6      	ldr	r6, [r4, #12]
 800a53a:	f003 fb37 	bl	800dbac <lwip_htonl>
  /* ackno is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
 800a53e:	3505      	adds	r5, #5
 800a540:	ea47 3505 	orr.w	r5, r7, r5, lsl #12
 800a544:	b2ad      	uxth	r5, r5
    return NULL;
  }
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
  seg->tcphdr->src = htons(pcb->local_port);
  seg->tcphdr->dest = htons(pcb->remote_port);
  seg->tcphdr->seqno = htonl(seqno);
 800a546:	6070      	str	r0, [r6, #4]
  /* ackno is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
 800a548:	4628      	mov	r0, r5
 800a54a:	68e5      	ldr	r5, [r4, #12]
 800a54c:	f003 fb24 	bl	800db98 <lwip_htons>
  /* wnd and chksum are set in tcp_output */
  seg->tcphdr->urgp = 0;
 800a550:	4626      	mov	r6, r4
 800a552:	68e3      	ldr	r3, [r4, #12]
  seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
  seg->tcphdr->src = htons(pcb->local_port);
  seg->tcphdr->dest = htons(pcb->remote_port);
  seg->tcphdr->seqno = htonl(seqno);
  /* ackno is set in tcp_output */
  TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
 800a554:	81a8      	strh	r0, [r5, #12]
  /* wnd and chksum are set in tcp_output */
  seg->tcphdr->urgp = 0;
 800a556:	f883 8012 	strb.w	r8, [r3, #18]
 800a55a:	f883 8013 	strb.w	r8, [r3, #19]
  return seg;
} 
 800a55e:	4630      	mov	r0, r6
 800a560:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

  /* build TCP header */
  if (pbuf_header(p, TCP_HLEN)) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
    TCP_STATS_INC(tcp.err);
    tcp_seg_free(seg);
 800a564:	4620      	mov	r0, r4
 800a566:	f7ff f97b 	bl	8009860 <tcp_seg_free>
 800a56a:	e7f8      	b.n	800a55e <tcp_create_segment.isra.0+0x9a>
  struct tcp_seg *seg;
  u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);

  if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_create_segment: no memory.\n"));
    pbuf_free(p);
 800a56c:	4640      	mov	r0, r8
 800a56e:	f005 fd5b 	bl	8010028 <pbuf_free>
    return NULL;
 800a572:	4626      	mov	r6, r4
 800a574:	e7f3      	b.n	800a55e <tcp_create_segment.isra.0+0x9a>
 800a576:	bf00      	nop

0800a578 <tcp_output_alloc_header.constprop.1>:
static struct pbuf *
tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
                      u32_t seqno_be /* already in network byte order */)
{
  struct tcp_hdr *tcphdr;
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
 800a578:	3114      	adds	r1, #20
 * @param datalen length of tcp data to reserve in pbuf
 * @param seqno_be seqno in network byte order (big-endian)
 * @return pbuf with p->payload being the tcp_hdr
 */
static struct pbuf *
tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
 800a57a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
                      u32_t seqno_be /* already in network byte order */)
{
  struct tcp_hdr *tcphdr;
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
 800a57c:	b289      	uxth	r1, r1
 * @param datalen length of tcp data to reserve in pbuf
 * @param seqno_be seqno in network byte order (big-endian)
 * @return pbuf with p->payload being the tcp_hdr
 */
static struct pbuf *
tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
 800a57e:	4605      	mov	r5, r0
 800a580:	4617      	mov	r7, r2
                      u32_t seqno_be /* already in network byte order */)
{
  struct tcp_hdr *tcphdr;
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
 800a582:	2001      	movs	r0, #1
 800a584:	2200      	movs	r2, #0
 800a586:	f005 fda7 	bl	80100d8 <pbuf_alloc>
  if (p != NULL) {
 800a58a:	4606      	mov	r6, r0
 800a58c:	b310      	cbz	r0, 800a5d4 <tcp_output_alloc_header.constprop.1+0x5c>
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
 800a58e:	8943      	ldrh	r3, [r0, #10]
 800a590:	2b13      	cmp	r3, #19
 800a592:	dd21      	ble.n	800a5d8 <tcp_output_alloc_header.constprop.1+0x60>
                 (p->len >= TCP_HLEN + optlen));
    tcphdr = (struct tcp_hdr *)p->payload;
    tcphdr->src = htons(pcb->local_port);
 800a594:	8b68      	ldrh	r0, [r5, #26]
  struct tcp_hdr *tcphdr;
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
  if (p != NULL) {
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
                 (p->len >= TCP_HLEN + optlen));
    tcphdr = (struct tcp_hdr *)p->payload;
 800a596:	6874      	ldr	r4, [r6, #4]
    tcphdr->src = htons(pcb->local_port);
 800a598:	f003 fafe 	bl	800db98 <lwip_htons>
 800a59c:	8020      	strh	r0, [r4, #0]
    tcphdr->dest = htons(pcb->remote_port);
 800a59e:	8ba8      	ldrh	r0, [r5, #28]
 800a5a0:	f003 fafa 	bl	800db98 <lwip_htons>
    tcphdr->seqno = seqno_be;
 800a5a4:	6067      	str	r7, [r4, #4]
  if (p != NULL) {
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
                 (p->len >= TCP_HLEN + optlen));
    tcphdr = (struct tcp_hdr *)p->payload;
    tcphdr->src = htons(pcb->local_port);
    tcphdr->dest = htons(pcb->remote_port);
 800a5a6:	8060      	strh	r0, [r4, #2]
    tcphdr->seqno = seqno_be;
    tcphdr->ackno = htonl(pcb->rcv_nxt);
 800a5a8:	6aa8      	ldr	r0, [r5, #40]	; 0x28
 800a5aa:	f003 faff 	bl	800dbac <lwip_htonl>
 800a5ae:	60a0      	str	r0, [r4, #8]
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
 800a5b0:	f245 0010 	movw	r0, #20496	; 0x5010
 800a5b4:	f003 faf0 	bl	800db98 <lwip_htons>
 800a5b8:	81a0      	strh	r0, [r4, #12]
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
 800a5ba:	8de8      	ldrh	r0, [r5, #46]	; 0x2e
 800a5bc:	f003 faec 	bl	800db98 <lwip_htons>
    tcphdr->chksum = 0;
    tcphdr->urgp = 0;

    /* If we're sending a packet, update the announced right window edge */
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 800a5c0:	8dea      	ldrh	r2, [r5, #46]	; 0x2e
 800a5c2:	6aa9      	ldr	r1, [r5, #40]	; 0x28
    tcphdr->dest = htons(pcb->remote_port);
    tcphdr->seqno = seqno_be;
    tcphdr->ackno = htonl(pcb->rcv_nxt);
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
    tcphdr->chksum = 0;
 800a5c4:	2300      	movs	r3, #0
    tcphdr->urgp = 0;

    /* If we're sending a packet, update the announced right window edge */
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 800a5c6:	440a      	add	r2, r1
    tcphdr->src = htons(pcb->local_port);
    tcphdr->dest = htons(pcb->remote_port);
    tcphdr->seqno = seqno_be;
    tcphdr->ackno = htonl(pcb->rcv_nxt);
    TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
 800a5c8:	81e0      	strh	r0, [r4, #14]
    tcphdr->chksum = 0;
 800a5ca:	7423      	strb	r3, [r4, #16]
 800a5cc:	7463      	strb	r3, [r4, #17]
    tcphdr->urgp = 0;
 800a5ce:	74a3      	strb	r3, [r4, #18]
 800a5d0:	74e3      	strb	r3, [r4, #19]

    /* If we're sending a packet, update the announced right window edge */
    pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 800a5d2:	632a      	str	r2, [r5, #48]	; 0x30
  }
  return p;
}
 800a5d4:	4630      	mov	r0, r6
 800a5d6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                      u32_t seqno_be /* already in network byte order */)
{
  struct tcp_hdr *tcphdr;
  struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
  if (p != NULL) {
    LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
 800a5d8:	4b03      	ldr	r3, [pc, #12]	; (800a5e8 <tcp_output_alloc_header.constprop.1+0x70>)
 800a5da:	2265      	movs	r2, #101	; 0x65
 800a5dc:	4903      	ldr	r1, [pc, #12]	; (800a5ec <tcp_output_alloc_header.constprop.1+0x74>)
 800a5de:	4804      	ldr	r0, [pc, #16]	; (800a5f0 <tcp_output_alloc_header.constprop.1+0x78>)
 800a5e0:	f00a fbca 	bl	8014d78 <iprintf>
 800a5e4:	e7d6      	b.n	800a594 <tcp_output_alloc_header.constprop.1+0x1c>
 800a5e6:	bf00      	nop
 800a5e8:	08016aa0 	.word	0x08016aa0
 800a5ec:	08016ac8 	.word	0x08016ac8
 800a5f0:	0801660c 	.word	0x0801660c

0800a5f4 <tcp_write>:
 * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent,
 * @return ERR_OK if enqueued, another err_t on error
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
 800a5f4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800a5f8:	4607      	mov	r7, r0
  u8_t concat_chksum_swapped = 0;
  u16_t concat_chksummed = 0;
#endif /* TCP_CHECKSUM_ON_COPY */
  err_t err;
  /* don't allocate segments bigger than half the maximum window we ever received */
  u16_t mss_local = LWIP_MIN(pcb->mss, pcb->snd_wnd_max/2);
 800a5fa:	f8b0 0062 	ldrh.w	r0, [r0, #98]	; 0x62
 800a5fe:	8efd      	ldrh	r5, [r7, #54]	; 0x36
 800a600:	0840      	lsrs	r0, r0, #1
 * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent,
 * @return ERR_OK if enqueued, another err_t on error
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
 800a602:	b08f      	sub	sp, #60	; 0x3c
  u8_t concat_chksum_swapped = 0;
  u16_t concat_chksummed = 0;
#endif /* TCP_CHECKSUM_ON_COPY */
  err_t err;
  /* don't allocate segments bigger than half the maximum window we ever received */
  u16_t mss_local = LWIP_MIN(pcb->mss, pcb->snd_wnd_max/2);
 800a604:	42a8      	cmp	r0, r5
 * - TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent,
 * @return ERR_OK if enqueued, another err_t on error
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
 800a606:	9308      	str	r3, [sp, #32]
  u8_t concat_chksum_swapped = 0;
  u16_t concat_chksummed = 0;
#endif /* TCP_CHECKSUM_ON_COPY */
  err_t err;
  /* don't allocate segments bigger than half the maximum window we ever received */
  u16_t mss_local = LWIP_MIN(pcb->mss, pcb->snd_wnd_max/2);
 800a608:	4603      	mov	r3, r0
 800a60a:	bf28      	it	cs
 800a60c:	462b      	movcs	r3, r5
  u16_t pos = 0; /* position in 'arg' data */
  u16_t queuelen;
  u8_t optlen = 0;
  u8_t optflags = 0;
#if TCP_OVERSIZE
  u16_t oversize = 0;
 800a60e:	2400      	movs	r4, #0
  u8_t concat_chksum_swapped = 0;
  u16_t concat_chksummed = 0;
#endif /* TCP_CHECKSUM_ON_COPY */
  err_t err;
  /* don't allocate segments bigger than half the maximum window we ever received */
  u16_t mss_local = LWIP_MIN(pcb->mss, pcb->snd_wnd_max/2);
 800a610:	9304      	str	r3, [sp, #16]
  u16_t pos = 0; /* position in 'arg' data */
  u16_t queuelen;
  u8_t optlen = 0;
  u8_t optflags = 0;
#if TCP_OVERSIZE
  u16_t oversize = 0;
 800a612:	f8ad 4036 	strh.w	r4, [sp, #54]	; 0x36
  apiflags |= TCP_WRITE_FLAG_COPY;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)apiflags));
  LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)", 
 800a616:	9106      	str	r1, [sp, #24]
 800a618:	2900      	cmp	r1, #0
 800a61a:	f000 827b 	beq.w	800ab14 <tcp_write+0x520>
 */
static err_t
tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
{
  /* connection is in invalid state for data transmission? */
  if ((pcb->state != ESTABLISHED) &&
 800a61e:	7e3b      	ldrb	r3, [r7, #24]
 800a620:	4693      	mov	fp, r2
 800a622:	2b07      	cmp	r3, #7
 800a624:	d007      	beq.n	800a636 <tcp_write+0x42>
      (pcb->state != CLOSE_WAIT) &&
 800a626:	3b02      	subs	r3, #2
 800a628:	2b02      	cmp	r3, #2
 800a62a:	d904      	bls.n	800a636 <tcp_write+0x42>
      (pcb->state != SYN_SENT) &&
      (pcb->state != SYN_RCVD)) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
 800a62c:	f06f 000c 	mvn.w	r0, #12
    LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_write: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
}
 800a630:	b00f      	add	sp, #60	; 0x3c
 800a632:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      (pcb->state != CLOSE_WAIT) &&
      (pcb->state != SYN_SENT) &&
      (pcb->state != SYN_RCVD)) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  } else if (len == 0) {
 800a636:	f1bb 0f00 	cmp.w	fp, #0
 800a63a:	f000 811b 	beq.w	800a874 <tcp_write+0x280>
    return ERR_OK;
  }

  /* fail on too much data */
  if (len > pcb->snd_buf) {
 800a63e:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 800a642:	455b      	cmp	r3, fp
 800a644:	f0c0 820e 	bcc.w	800aa64 <tcp_write+0x470>
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  /* check for configured max queuelen and possible overflow */
  if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
 800a648:	f8b7 6068 	ldrh.w	r6, [r7, #104]	; 0x68
 800a64c:	2e17      	cmp	r6, #23
 800a64e:	f200 8209 	bhi.w	800aa64 <tcp_write+0x470>
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
  }
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
 800a652:	6f3b      	ldr	r3, [r7, #112]	; 0x70
      pcb->snd_queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
  }
  if (pcb->snd_queuelen != 0) {
 800a654:	2e00      	cmp	r6, #0
 800a656:	f000 80d8 	beq.w	800a80a <tcp_write+0x216>
    LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
 800a65a:	2b00      	cmp	r3, #0
 800a65c:	f000 81dd 	beq.w	800aa1a <tcp_write+0x426>
   *
   * pos records progress as data is segmented.
   */

  /* Find the tail of the unsent queue. */
  if (pcb->unsent != NULL) {
 800a660:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800a662:	9309      	str	r3, [sp, #36]	; 0x24
 800a664:	2b00      	cmp	r3, #0
 800a666:	f000 80e1 	beq.w	800a82c <tcp_write+0x238>
 800a66a:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800a66c:	e000      	b.n	800a670 <tcp_write+0x7c>
 800a66e:	461a      	mov	r2, r3
    u16_t space;
    u16_t unsent_optlen;

    /* @todo: this could be sped up by keeping last_unsent in the pcb */
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 800a670:	6813      	ldr	r3, [r2, #0]
 800a672:	2b00      	cmp	r3, #0
 800a674:	d1fb      	bne.n	800a66e <tcp_write+0x7a>
 800a676:	4611      	mov	r1, r2
 800a678:	9209      	str	r2, [sp, #36]	; 0x24
         last_unsent = last_unsent->next);

    /* Usable space at the end of the last unsent segment */
    unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
 800a67a:	7a92      	ldrb	r2, [r2, #10]
 800a67c:	4698      	mov	r8, r3
 800a67e:	f012 0f01 	tst.w	r2, #1
    space = mss_local - (last_unsent->len + unsent_optlen);
 800a682:	890b      	ldrh	r3, [r1, #8]
    /* @todo: this could be sped up by keeping last_unsent in the pcb */
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
         last_unsent = last_unsent->next);

    /* Usable space at the end of the last unsent segment */
    unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
 800a684:	bf0c      	ite	eq
 800a686:	2100      	moveq	r1, #0
 800a688:	2104      	movne	r1, #4
 800a68a:	f012 0f02 	tst.w	r2, #2
    space = mss_local - (last_unsent->len + unsent_optlen);
 800a68e:	9a04      	ldr	r2, [sp, #16]
    /* @todo: this could be sped up by keeping last_unsent in the pcb */
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
         last_unsent = last_unsent->next);

    /* Usable space at the end of the last unsent segment */
    unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
 800a690:	bf08      	it	eq
 800a692:	2400      	moveq	r4, #0
    space = mss_local - (last_unsent->len + unsent_optlen);
 800a694:	eba2 0303 	sub.w	r3, r2, r3
    /* @todo: this could be sped up by keeping last_unsent in the pcb */
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
         last_unsent = last_unsent->next);

    /* Usable space at the end of the last unsent segment */
    unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
 800a698:	bf18      	it	ne
 800a69a:	240c      	movne	r4, #12
    space = mss_local - (last_unsent->len + unsent_optlen);
 800a69c:	1a5b      	subs	r3, r3, r1
#if TCP_OVERSIZE_DBGCHECK
    /* check that pcb->unsent_oversize matches last_unsent->unsent_oversize */
    LWIP_ASSERT("unsent_oversize mismatch (pcb vs. last_unsent)",
                pcb->unsent_oversize == last_unsent->oversize_left);
#endif /* TCP_OVERSIZE_DBGCHECK */
    oversize = pcb->unsent_oversize;
 800a69e:	f8b7 206a 	ldrh.w	r2, [r7, #106]	; 0x6a
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
         last_unsent = last_unsent->next);

    /* Usable space at the end of the last unsent segment */
    unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
    space = mss_local - (last_unsent->len + unsent_optlen);
 800a6a2:	1b1c      	subs	r4, r3, r4
 800a6a4:	b2a4      	uxth	r4, r4
    /* check that pcb->unsent_oversize matches last_unsent->unsent_oversize */
    LWIP_ASSERT("unsent_oversize mismatch (pcb vs. last_unsent)",
                pcb->unsent_oversize == last_unsent->oversize_left);
#endif /* TCP_OVERSIZE_DBGCHECK */
    oversize = pcb->unsent_oversize;
    if (oversize > 0) {
 800a6a6:	2a00      	cmp	r2, #0
 800a6a8:	f040 80e7 	bne.w	800a87a <tcp_write+0x286>
#if TCP_OVERSIZE_DBGCHECK
    /* check that pcb->unsent_oversize matches last_unsent->unsent_oversize */
    LWIP_ASSERT("unsent_oversize mismatch (pcb vs. last_unsent)",
                pcb->unsent_oversize == last_unsent->oversize_left);
#endif /* TCP_OVERSIZE_DBGCHECK */
    oversize = pcb->unsent_oversize;
 800a6ac:	f8ad 8036 	strh.w	r8, [sp, #54]	; 0x36
     *
     * We don't extend segments containing SYN/FIN flags or options
     * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
     * the end.
     */
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
 800a6b0:	f1bb 0f00 	cmp.w	fp, #0
 800a6b4:	f000 81dd 	beq.w	800aa72 <tcp_write+0x47e>
 800a6b8:	920a      	str	r2, [sp, #40]	; 0x28
 800a6ba:	2c00      	cmp	r4, #0
 800a6bc:	f040 8109 	bne.w	800a8d2 <tcp_write+0x2de>
 800a6c0:	940b      	str	r4, [sp, #44]	; 0x2c
 800a6c2:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 800a6c4:	9b08      	ldr	r3, [sp, #32]
 800a6c6:	f04f 0800 	mov.w	r8, #0
 800a6ca:	f003 0301 	and.w	r3, r3, #1
 800a6ce:	46c2      	mov	sl, r8
 800a6d0:	9307      	str	r3, [sp, #28]
 800a6d2:	f8cd 8014 	str.w	r8, [sp, #20]
 800a6d6:	46b9      	mov	r9, r7
 800a6d8:	e044      	b.n	800a764 <tcp_write+0x170>
       * sent out on the link (as it has to be ACKed by the remote
       * party) we can safely use PBUF_ROM instead of PBUF_REF here.
       */
      struct pbuf *p2;
#if TCP_OVERSIZE
      LWIP_ASSERT("oversize == 0", oversize == 0);
 800a6da:	f8bd 3036 	ldrh.w	r3, [sp, #54]	; 0x36
 800a6de:	2b00      	cmp	r3, #0
 800a6e0:	f040 8167 	bne.w	800a9b2 <tcp_write+0x3be>
#endif /* TCP_OVERSIZE */
      if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
 800a6e4:	2201      	movs	r2, #1
 800a6e6:	4629      	mov	r1, r5
 800a6e8:	2000      	movs	r0, #0
 800a6ea:	f005 fcf5 	bl	80100d8 <pbuf_alloc>
 800a6ee:	4680      	mov	r8, r0
 800a6f0:	2800      	cmp	r0, #0
 800a6f2:	f000 8178 	beq.w	800a9e6 <tcp_write+0x3f2>
#if TCP_CHECKSUM_ON_COPY
      /* calculate the checksum of nocopy-data */
      chksum = ~inet_chksum((u8_t*)arg + pos, seglen);
#endif /* TCP_CHECKSUM_ON_COPY */
      /* reference the non-volatile payload data */
      p2->payload = (u8_t*)arg + pos;
 800a6f6:	9b06      	ldr	r3, [sp, #24]

      /* Second, allocate a pbuf for the headers. */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 800a6f8:	2200      	movs	r2, #0
#if TCP_CHECKSUM_ON_COPY
      /* calculate the checksum of nocopy-data */
      chksum = ~inet_chksum((u8_t*)arg + pos, seglen);
#endif /* TCP_CHECKSUM_ON_COPY */
      /* reference the non-volatile payload data */
      p2->payload = (u8_t*)arg + pos;
 800a6fa:	1919      	adds	r1, r3, r4
 800a6fc:	6041      	str	r1, [r0, #4]

      /* Second, allocate a pbuf for the headers. */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 800a6fe:	4611      	mov	r1, r2
 800a700:	4610      	mov	r0, r2
 800a702:	f005 fce9 	bl	80100d8 <pbuf_alloc>
 800a706:	4607      	mov	r7, r0
 800a708:	2800      	cmp	r0, #0
 800a70a:	f000 817b 	beq.w	800aa04 <tcp_write+0x410>
        pbuf_free(p2);
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: could not allocate memory for header pbuf\n"));
        goto memerr;
      }
      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(p/*header*/, p2/*data*/);
 800a70e:	4641      	mov	r1, r8
 800a710:	f005 fe48 	bl	80103a4 <pbuf_cat>
    }

    queuelen += pbuf_clen(p);
 800a714:	4638      	mov	r0, r7
 800a716:	f005 fe2d 	bl	8010374 <pbuf_clen>
 800a71a:	4430      	add	r0, r6
 800a71c:	b286      	uxth	r6, r0

    /* Now that there are more segments queued, we check again if the
     * length of the queue exceeds the configured maximum or
     * overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
 800a71e:	2e18      	cmp	r6, #24
 800a720:	d84f      	bhi.n	800a7c2 <tcp_write+0x1ce>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      pbuf_free(p);
      goto memerr;
    }

    if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
 800a722:	f8d9 205c 	ldr.w	r2, [r9, #92]	; 0x5c
 800a726:	2300      	movs	r3, #0
 800a728:	18a1      	adds	r1, r4, r2
 800a72a:	e88d 000a 	stmia.w	sp, {r1, r3}
 800a72e:	463a      	mov	r2, r7
 800a730:	f109 011c 	add.w	r1, r9, #28
 800a734:	f109 001a 	add.w	r0, r9, #26
 800a738:	f7ff fec4 	bl	800a4c4 <tcp_create_segment.isra.0>
 800a73c:	4607      	mov	r7, r0
 800a73e:	2800      	cmp	r0, #0
 800a740:	f000 8151 	beq.w	800a9e6 <tcp_write+0x3f2>
    seg->chksum_swapped = chksum_swapped;
    seg->flags |= TF_SEG_DATA_CHECKSUMMED;
#endif /* TCP_CHECKSUM_ON_COPY */

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
 800a744:	9b05      	ldr	r3, [sp, #20]
 800a746:	2b00      	cmp	r3, #0
 800a748:	f000 813b 	beq.w	800a9c2 <tcp_write+0x3ce>
      queue = seg;
    } else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
 800a74c:	f1ba 0f00 	cmp.w	sl, #0
 800a750:	f000 8141 	beq.w	800a9d6 <tcp_write+0x3e2>
      prev_seg->next = seg;
 800a754:	f8ca 7000 	str.w	r7, [sl]

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_write: queueing %"U32_F":%"U32_F"\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg)));

    pos += seglen;
 800a758:	442c      	add	r4, r5
 800a75a:	b2a4      	uxth	r4, r4
   * Phase 3: Create new segments.
   *
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
 800a75c:	45a3      	cmp	fp, r4
 800a75e:	f240 81e9 	bls.w	800ab34 <tcp_write+0x540>
 800a762:	46ba      	mov	sl, r7
    struct pbuf *p;
    u16_t left = len - pos;
    u16_t max_len = mss_local - optlen;
    u16_t seglen = left > max_len ? max_len : left;
 800a764:	9b04      	ldr	r3, [sp, #16]
 800a766:	ebc4 050b 	rsb	r5, r4, fp
 800a76a:	b2ad      	uxth	r5, r5
 800a76c:	429d      	cmp	r5, r3
 800a76e:	bf28      	it	cs
 800a770:	461d      	movcs	r5, r3
#if TCP_CHECKSUM_ON_COPY
    u16_t chksum = 0;
    u8_t chksum_swapped = 0;
#endif /* TCP_CHECKSUM_ON_COPY */

    if (apiflags & TCP_WRITE_FLAG_COPY) {
 800a772:	9b07      	ldr	r3, [sp, #28]
 800a774:	2b00      	cmp	r3, #0
 800a776:	d0b0      	beq.n	800a6da <tcp_write+0xe6>
      /* If copy is set, memory should be allocated and data copied
       * into pbuf */
      if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apiflags, queue == NULL)) == NULL) {
 800a778:	9b05      	ldr	r3, [sp, #20]
 800a77a:	9a08      	ldr	r2, [sp, #32]
 800a77c:	fab3 f383 	clz	r3, r3
 800a780:	095b      	lsrs	r3, r3, #5
 800a782:	9201      	str	r2, [sp, #4]
 800a784:	9302      	str	r3, [sp, #8]
 800a786:	f8cd 9000 	str.w	r9, [sp]
 800a78a:	f10d 0336 	add.w	r3, sp, #54	; 0x36
 800a78e:	9a04      	ldr	r2, [sp, #16]
 800a790:	4629      	mov	r1, r5
 800a792:	2000      	movs	r0, #0
 800a794:	f7ff fe56 	bl	800a444 <tcp_pbuf_prealloc>
 800a798:	4607      	mov	r7, r0
 800a79a:	2800      	cmp	r0, #0
 800a79c:	f000 8123 	beq.w	800a9e6 <tcp_write+0x3f2>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
 800a7a0:	8943      	ldrh	r3, [r0, #10]
 800a7a2:	42ab      	cmp	r3, r5
 800a7a4:	f0c0 810f 	bcc.w	800a9c6 <tcp_write+0x3d2>
                  (p->len >= seglen));
      TCP_DATA_COPY2((char *)p->payload + optlen, (u8_t*)arg + pos, seglen, &chksum, &chksum_swapped);
 800a7a8:	9b06      	ldr	r3, [sp, #24]
 800a7aa:	462a      	mov	r2, r5
 800a7ac:	1919      	adds	r1, r3, r4
 800a7ae:	6878      	ldr	r0, [r7, #4]
 800a7b0:	f00a facf 	bl	8014d52 <memcpy>
      }
      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(p/*header*/, p2/*data*/);
    }

    queuelen += pbuf_clen(p);
 800a7b4:	4638      	mov	r0, r7
 800a7b6:	f005 fddd 	bl	8010374 <pbuf_clen>
 800a7ba:	4430      	add	r0, r6
 800a7bc:	b286      	uxth	r6, r0

    /* Now that there are more segments queued, we check again if the
     * length of the queue exceeds the configured maximum or
     * overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
 800a7be:	2e18      	cmp	r6, #24
 800a7c0:	d9af      	bls.n	800a722 <tcp_write+0x12e>
 800a7c2:	464b      	mov	r3, r9
 800a7c4:	46b9      	mov	r9, r7
 800a7c6:	461f      	mov	r7, r3
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      pbuf_free(p);
 800a7c8:	4648      	mov	r0, r9
 800a7ca:	f8dd 8014 	ldr.w	r8, [sp, #20]
 800a7ce:	f005 fc2b 	bl	8010028 <pbuf_free>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
 800a7d2:	7fbb      	ldrb	r3, [r7, #30]
 800a7d4:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800a7d8:	77bb      	strb	r3, [r7, #30]
  TCP_STATS_INC(tcp.memerr);

  if (concat_p != NULL) {
 800a7da:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800a7dc:	2b00      	cmp	r3, #0
 800a7de:	f040 810d 	bne.w	800a9fc <tcp_write+0x408>
    pbuf_free(concat_p);
  }
  if (queue != NULL) {
 800a7e2:	f1b8 0f00 	cmp.w	r8, #0
 800a7e6:	d002      	beq.n	800a7ee <tcp_write+0x1fa>
    tcp_segs_free(queue);
 800a7e8:	4640      	mov	r0, r8
 800a7ea:	f7ff f847 	bl	800987c <tcp_segs_free>
  }
  if (pcb->snd_queuelen != 0) {
 800a7ee:	f8b7 3068 	ldrh.w	r3, [r7, #104]	; 0x68
 800a7f2:	b12b      	cbz	r3, 800a800 <tcp_write+0x20c>
    LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
 800a7f4:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800a7f6:	b91b      	cbnz	r3, 800a800 <tcp_write+0x20c>
 800a7f8:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800a7fa:	2b00      	cmp	r3, #0
 800a7fc:	f000 8155 	beq.w	800aaaa <tcp_write+0x4b6>
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_write: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
 800a800:	f04f 30ff 	mov.w	r0, #4294967295
}
 800a804:	b00f      	add	sp, #60	; 0x3c
 800a806:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  }
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
 800a80a:	2b00      	cmp	r3, #0
 800a80c:	f000 8087 	beq.w	800a91e <tcp_write+0x32a>
 800a810:	4bad      	ldr	r3, [pc, #692]	; (800aac8 <tcp_write+0x4d4>)
 800a812:	f44f 72a6 	mov.w	r2, #332	; 0x14c
 800a816:	49ad      	ldr	r1, [pc, #692]	; (800aacc <tcp_write+0x4d8>)
 800a818:	48ad      	ldr	r0, [pc, #692]	; (800aad0 <tcp_write+0x4dc>)
 800a81a:	f00a faad 	bl	8014d78 <iprintf>
   *
   * pos records progress as data is segmented.
   */

  /* Find the tail of the unsent queue. */
  if (pcb->unsent != NULL) {
 800a81e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800a820:	f8b7 6068 	ldrh.w	r6, [r7, #104]	; 0x68
 800a824:	9309      	str	r3, [sp, #36]	; 0x24
 800a826:	2b00      	cmp	r3, #0
 800a828:	f47f af1f 	bne.w	800a66a <tcp_write+0x76>
      pos += seglen;
      queuelen += pbuf_clen(concat_p);
    }
  } else {
#if TCP_OVERSIZE
    LWIP_ASSERT("unsent_oversize mismatch (pcb->unsent is NULL)",
 800a82c:	f8b7 306a 	ldrh.w	r3, [r7, #106]	; 0x6a
 800a830:	2b00      	cmp	r3, #0
 800a832:	f040 812e 	bne.w	800aa92 <tcp_write+0x49e>
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
  struct pbuf *concat_p = NULL;
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
  u16_t pos = 0; /* position in 'arg' data */
 800a836:	461c      	mov	r4, r3
  u16_t queuelen;
  u8_t optlen = 0;
  u8_t optflags = 0;
#if TCP_OVERSIZE
  u16_t oversize = 0;
  u16_t oversize_used = 0;
 800a838:	930a      	str	r3, [sp, #40]	; 0x28
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
  struct pbuf *concat_p = NULL;
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
 800a83a:	9309      	str	r3, [sp, #36]	; 0x24
 * @return ERR_OK if enqueued, another err_t on error
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
  struct pbuf *concat_p = NULL;
 800a83c:	930b      	str	r3, [sp, #44]	; 0x2c
   * Phase 3: Create new segments.
   *
   * The new segments are chained together in the local 'queue'
   * variable, ready to be appended to pcb->unsent.
   */
  while (pos < len) {
 800a83e:	45a3      	cmp	fp, r4
 800a840:	f63f af40 	bhi.w	800a6c4 <tcp_write+0xd0>
 800a844:	9c09      	ldr	r4, [sp, #36]	; 0x24
 800a846:	f04f 0800 	mov.w	r8, #0
  /*
   * Phase 1: If data has been added to the preallocated tail of
   * last_unsent, we update the length fields of the pbuf chain.
   */
#if TCP_OVERSIZE
  if (oversize_used > 0) {
 800a84a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800a84c:	2b00      	cmp	r3, #0
 800a84e:	d134      	bne.n	800a8ba <tcp_write+0x2c6>
    LWIP_ASSERT("last_unsent->oversize_left >= oversize_used",
                last_unsent->oversize_left >= oversize_used);
    last_unsent->oversize_left -= oversize_used;
#endif /* TCP_OVERSIZE_DBGCHECK */
  }
  pcb->unsent_oversize = oversize;
 800a850:	f8bd 3036 	ldrh.w	r3, [sp, #54]	; 0x36
 800a854:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a
#endif /* TCP_OVERSIZE */

  /*
   * Phase 2: concat_p can be concatenated onto last_unsent->p
   */
  if (concat_p != NULL) {
 800a858:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800a85a:	2b00      	cmp	r3, #0
 800a85c:	f000 8164 	beq.w	800ab28 <tcp_write+0x534>
    LWIP_ASSERT("tcp_write: cannot concatenate when pcb->unsent is empty",
 800a860:	2c00      	cmp	r4, #0
 800a862:	d17a      	bne.n	800a95a <tcp_write+0x366>
 800a864:	4b98      	ldr	r3, [pc, #608]	; (800aac8 <tcp_write+0x4d4>)
 800a866:	f240 228b 	movw	r2, #651	; 0x28b
 800a86a:	499a      	ldr	r1, [pc, #616]	; (800aad4 <tcp_write+0x4e0>)
 800a86c:	4898      	ldr	r0, [pc, #608]	; (800aad0 <tcp_write+0x4dc>)
 800a86e:	f00a fa83 	bl	8014d78 <iprintf>
 800a872:	e072      	b.n	800a95a <tcp_write+0x366>
 800a874:	f8b7 6068 	ldrh.w	r6, [r7, #104]	; 0x68
 800a878:	e6f2      	b.n	800a660 <tcp_write+0x6c>
#endif /* TCP_OVERSIZE_DBGCHECK */
    oversize = pcb->unsent_oversize;
    if (oversize > 0) {
      LWIP_ASSERT("inconsistent oversize vs. space", oversize_used <= space);
      seg = last_unsent;
      oversize_used = oversize < len ? oversize : len;
 800a87a:	4593      	cmp	fp, r2
 800a87c:	465b      	mov	r3, fp
 800a87e:	bf28      	it	cs
 800a880:	4613      	movcs	r3, r2
      pos += oversize_used;
      oversize -= oversize_used;
 800a882:	1ad2      	subs	r2, r2, r3
 800a884:	b292      	uxth	r2, r2
      space -= oversize_used;
 800a886:	1ae4      	subs	r4, r4, r3
#endif /* TCP_OVERSIZE_DBGCHECK */
    oversize = pcb->unsent_oversize;
    if (oversize > 0) {
      LWIP_ASSERT("inconsistent oversize vs. space", oversize_used <= space);
      seg = last_unsent;
      oversize_used = oversize < len ? oversize : len;
 800a888:	930a      	str	r3, [sp, #40]	; 0x28
      pos += oversize_used;
      oversize -= oversize_used;
 800a88a:	f8ad 2036 	strh.w	r2, [sp, #54]	; 0x36
      space -= oversize_used;
 800a88e:	b2a4      	uxth	r4, r4
    }
    /* now we are either finished or oversize is zero */
    LWIP_ASSERT("inconsistend oversize vs. len", (oversize == 0) || (pos == len));
 800a890:	b142      	cbz	r2, 800a8a4 <tcp_write+0x2b0>
 800a892:	459b      	cmp	fp, r3
 800a894:	d00a      	beq.n	800a8ac <tcp_write+0x2b8>
 800a896:	4b8c      	ldr	r3, [pc, #560]	; (800aac8 <tcp_write+0x4d4>)
 800a898:	f240 12c9 	movw	r2, #457	; 0x1c9
 800a89c:	498e      	ldr	r1, [pc, #568]	; (800aad8 <tcp_write+0x4e4>)
 800a89e:	488c      	ldr	r0, [pc, #560]	; (800aad0 <tcp_write+0x4dc>)
 800a8a0:	f00a fa6a 	bl	8014d78 <iprintf>
     *
     * We don't extend segments containing SYN/FIN flags or options
     * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
     * the end.
     */
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
 800a8a4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800a8a6:	459b      	cmp	fp, r3
 800a8a8:	f63f af07 	bhi.w	800a6ba <tcp_write+0xc6>
  /*
   * Phase 1: If data has been added to the preallocated tail of
   * last_unsent, we update the length fields of the pbuf chain.
   */
#if TCP_OVERSIZE
  if (oversize_used > 0) {
 800a8ac:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800a8ae:	2b00      	cmp	r3, #0
 800a8b0:	f000 8149 	beq.w	800ab46 <tcp_write+0x552>
 800a8b4:	2300      	movs	r3, #0
 800a8b6:	9c09      	ldr	r4, [sp, #36]	; 0x24
 800a8b8:	930b      	str	r3, [sp, #44]	; 0x2c
    struct pbuf *p;
    /* Bump tot_len of whole chain, len of tail */
    for (p = last_unsent->p; p; p = p->next) {
 800a8ba:	6865      	ldr	r5, [r4, #4]
 800a8bc:	2d00      	cmp	r5, #0
 800a8be:	d040      	beq.n	800a942 <tcp_write+0x34e>
 800a8c0:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
      p->tot_len += oversize_used;
 800a8c4:	892b      	ldrh	r3, [r5, #8]
      if (p->next == NULL) {
 800a8c6:	682a      	ldr	r2, [r5, #0]
#if TCP_OVERSIZE
  if (oversize_used > 0) {
    struct pbuf *p;
    /* Bump tot_len of whole chain, len of tail */
    for (p = last_unsent->p; p; p = p->next) {
      p->tot_len += oversize_used;
 800a8c8:	444b      	add	r3, r9
 800a8ca:	812b      	strh	r3, [r5, #8]
      if (p->next == NULL) {
 800a8cc:	b362      	cbz	r2, 800a928 <tcp_write+0x334>
  /*
   * Phase 1: If data has been added to the preallocated tail of
   * last_unsent, we update the length fields of the pbuf chain.
   */
#if TCP_OVERSIZE
  if (oversize_used > 0) {
 800a8ce:	4615      	mov	r5, r2
 800a8d0:	e7f8      	b.n	800a8c4 <tcp_write+0x2d0>
     *
     * We don't extend segments containing SYN/FIN flags or options
     * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
     * the end.
     */
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
 800a8d2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800a8d4:	891b      	ldrh	r3, [r3, #8]
 800a8d6:	2b00      	cmp	r3, #0
 800a8d8:	f000 809c 	beq.w	800aa14 <tcp_write+0x420>
      u16_t seglen = space < len - pos ? space : len - pos;
 800a8dc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
      seg = last_unsent;

      /* Create a pbuf with a copy or reference to seglen bytes. We
       * can use PBUF_RAW here since the data appears in the middle of
       * a segment. A header will never be prepended. */
      if (apiflags & TCP_WRITE_FLAG_COPY) {
 800a8de:	9a08      	ldr	r2, [sp, #32]
     * We don't extend segments containing SYN/FIN flags or options
     * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
     * the end.
     */
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
      u16_t seglen = space < len - pos ? space : len - pos;
 800a8e0:	ebc3 050b 	rsb	r5, r3, fp
 800a8e4:	42a5      	cmp	r5, r4
 800a8e6:	bfa8      	it	ge
 800a8e8:	4625      	movge	r5, r4
      seg = last_unsent;

      /* Create a pbuf with a copy or reference to seglen bytes. We
       * can use PBUF_RAW here since the data appears in the middle of
       * a segment. A header will never be prepended. */
      if (apiflags & TCP_WRITE_FLAG_COPY) {
 800a8ea:	07d3      	lsls	r3, r2, #31
     * We don't extend segments containing SYN/FIN flags or options
     * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
     * the end.
     */
    if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
      u16_t seglen = space < len - pos ? space : len - pos;
 800a8ec:	b2ad      	uxth	r5, r5
      seg = last_unsent;

      /* Create a pbuf with a copy or reference to seglen bytes. We
       * can use PBUF_RAW here since the data appears in the middle of
       * a segment. A header will never be prepended. */
      if (apiflags & TCP_WRITE_FLAG_COPY) {
 800a8ee:	f100 80a3 	bmi.w	800aa38 <tcp_write+0x444>
#if TCP_CHECKSUM_ON_COPY
        concat_chksummed += seglen;
#endif /* TCP_CHECKSUM_ON_COPY */
      } else {
        /* Data is not copied */
        if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
 800a8f2:	2201      	movs	r2, #1
 800a8f4:	4629      	mov	r1, r5
 800a8f6:	2003      	movs	r0, #3
 800a8f8:	f005 fbee 	bl	80100d8 <pbuf_alloc>
 800a8fc:	900b      	str	r0, [sp, #44]	; 0x2c
 800a8fe:	2800      	cmp	r0, #0
 800a900:	f000 80dd 	beq.w	800aabe <tcp_write+0x4ca>
        tcp_seg_add_chksum(~inet_chksum((u8_t*)arg + pos, seglen), seglen,
          &concat_chksum, &concat_chksum_swapped);
        concat_chksummed += seglen;
#endif /* TCP_CHECKSUM_ON_COPY */
        /* reference the non-volatile payload data */
        concat_p->payload = (u8_t*)arg + pos;
 800a904:	9b06      	ldr	r3, [sp, #24]
 800a906:	990a      	ldr	r1, [sp, #40]	; 0x28
 800a908:	440b      	add	r3, r1
 800a90a:	6043      	str	r3, [r0, #4]
      }

      pos += seglen;
 800a90c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
      queuelen += pbuf_clen(concat_p);
 800a90e:	980b      	ldr	r0, [sp, #44]	; 0x2c
#endif /* TCP_CHECKSUM_ON_COPY */
        /* reference the non-volatile payload data */
        concat_p->payload = (u8_t*)arg + pos;
      }

      pos += seglen;
 800a910:	18ec      	adds	r4, r5, r3
      queuelen += pbuf_clen(concat_p);
 800a912:	f005 fd2f 	bl	8010374 <pbuf_clen>
 800a916:	4430      	add	r0, r6
#endif /* TCP_CHECKSUM_ON_COPY */
        /* reference the non-volatile payload data */
        concat_p->payload = (u8_t*)arg + pos;
      }

      pos += seglen;
 800a918:	b2a4      	uxth	r4, r4
      queuelen += pbuf_clen(concat_p);
 800a91a:	b286      	uxth	r6, r0
 800a91c:	e78f      	b.n	800a83e <tcp_write+0x24a>
  }
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
 800a91e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800a920:	2b00      	cmp	r3, #0
 800a922:	f47f af75 	bne.w	800a810 <tcp_write+0x21c>
 800a926:	e781      	b.n	800a82c <tcp_write+0x238>
    struct pbuf *p;
    /* Bump tot_len of whole chain, len of tail */
    for (p = last_unsent->p; p; p = p->next) {
      p->tot_len += oversize_used;
      if (p->next == NULL) {
        TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
 800a928:	896b      	ldrh	r3, [r5, #10]
 800a92a:	6868      	ldr	r0, [r5, #4]
 800a92c:	464a      	mov	r2, r9
 800a92e:	4418      	add	r0, r3
 800a930:	9906      	ldr	r1, [sp, #24]
 800a932:	f00a fa0e 	bl	8014d52 <memcpy>
        p->len += oversize_used;
 800a936:	896b      	ldrh	r3, [r5, #10]
   */
#if TCP_OVERSIZE
  if (oversize_used > 0) {
    struct pbuf *p;
    /* Bump tot_len of whole chain, len of tail */
    for (p = last_unsent->p; p; p = p->next) {
 800a938:	682a      	ldr	r2, [r5, #0]
      p->tot_len += oversize_used;
      if (p->next == NULL) {
        TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
        p->len += oversize_used;
 800a93a:	444b      	add	r3, r9
 800a93c:	816b      	strh	r3, [r5, #10]
   */
#if TCP_OVERSIZE
  if (oversize_used > 0) {
    struct pbuf *p;
    /* Bump tot_len of whole chain, len of tail */
    for (p = last_unsent->p; p; p = p->next) {
 800a93e:	2a00      	cmp	r2, #0
 800a940:	d1c5      	bne.n	800a8ce <tcp_write+0x2da>
      if (p->next == NULL) {
        TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
        p->len += oversize_used;
      }
    }
    last_unsent->len += oversize_used;
 800a942:	8923      	ldrh	r3, [r4, #8]
 800a944:	990a      	ldr	r1, [sp, #40]	; 0x28
    LWIP_ASSERT("last_unsent->oversize_left >= oversize_used",
                last_unsent->oversize_left >= oversize_used);
    last_unsent->oversize_left -= oversize_used;
#endif /* TCP_OVERSIZE_DBGCHECK */
  }
  pcb->unsent_oversize = oversize;
 800a946:	f8bd 2036 	ldrh.w	r2, [sp, #54]	; 0x36
      if (p->next == NULL) {
        TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
        p->len += oversize_used;
      }
    }
    last_unsent->len += oversize_used;
 800a94a:	4419      	add	r1, r3
#endif /* TCP_OVERSIZE */

  /*
   * Phase 2: concat_p can be concatenated onto last_unsent->p
   */
  if (concat_p != NULL) {
 800a94c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
      if (p->next == NULL) {
        TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
        p->len += oversize_used;
      }
    }
    last_unsent->len += oversize_used;
 800a94e:	8121      	strh	r1, [r4, #8]
    LWIP_ASSERT("last_unsent->oversize_left >= oversize_used",
                last_unsent->oversize_left >= oversize_used);
    last_unsent->oversize_left -= oversize_used;
#endif /* TCP_OVERSIZE_DBGCHECK */
  }
  pcb->unsent_oversize = oversize;
 800a950:	f8a7 206a 	strh.w	r2, [r7, #106]	; 0x6a
#endif /* TCP_OVERSIZE */

  /*
   * Phase 2: concat_p can be concatenated onto last_unsent->p
   */
  if (concat_p != NULL) {
 800a954:	2b00      	cmp	r3, #0
 800a956:	f000 80e7 	beq.w	800ab28 <tcp_write+0x534>
    LWIP_ASSERT("tcp_write: cannot concatenate when pcb->unsent is empty",
      (last_unsent != NULL));
    pbuf_cat(last_unsent->p, concat_p);
 800a95a:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 800a95c:	6860      	ldr	r0, [r4, #4]
 800a95e:	4629      	mov	r1, r5
 800a960:	f005 fd20 	bl	80103a4 <pbuf_cat>
    last_unsent->len += concat_p->tot_len;
 800a964:	892b      	ldrh	r3, [r5, #8]
 800a966:	8922      	ldrh	r2, [r4, #8]
 800a968:	4413      	add	r3, r2
 800a96a:	8123      	strh	r3, [r4, #8]
   * is harmless
   */
  if (last_unsent == NULL) {
    pcb->unsent = queue;
  } else {
    last_unsent->next = queue;
 800a96c:	f8c4 8000 	str.w	r8, [r4]
  }

  /*
   * Finally update the pcb state.
   */
  pcb->snd_lbb += len;
 800a970:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
  pcb->snd_buf -= len;
 800a972:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
  }

  /*
   * Finally update the pcb state.
   */
  pcb->snd_lbb += len;
 800a976:	445a      	add	r2, fp
  pcb->snd_buf -= len;
 800a978:	ebcb 0b03 	rsb	fp, fp, r3
  pcb->snd_queuelen = queuelen;
 800a97c:	f8a7 6068 	strh.w	r6, [r7, #104]	; 0x68
  }

  /*
   * Finally update the pcb state.
   */
  pcb->snd_lbb += len;
 800a980:	65fa      	str	r2, [r7, #92]	; 0x5c
  pcb->snd_buf -= len;
 800a982:	f8a7 b066 	strh.w	fp, [r7, #102]	; 0x66
  pcb->snd_queuelen = queuelen;

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: %"S16_F" (after enqueued)\n",
    pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
 800a986:	b11e      	cbz	r6, 800a990 <tcp_write+0x39c>
    LWIP_ASSERT("tcp_write: valid queue length",
 800a988:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800a98a:	2b00      	cmp	r3, #0
 800a98c:	f000 80b6 	beq.w	800aafc <tcp_write+0x508>
                pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued. */
  if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
 800a990:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800a992:	2b00      	cmp	r3, #0
 800a994:	f000 80ae 	beq.w	800aaf4 <tcp_write+0x500>
 800a998:	68dd      	ldr	r5, [r3, #12]
 800a99a:	2d00      	cmp	r5, #0
 800a99c:	f000 80ac 	beq.w	800aaf8 <tcp_write+0x504>
 800a9a0:	9b08      	ldr	r3, [sp, #32]
 800a9a2:	f003 0302 	and.w	r3, r3, #2
 800a9a6:	f003 04ff 	and.w	r4, r3, #255	; 0xff
 800a9aa:	2b00      	cmp	r3, #0
 800a9ac:	d069      	beq.n	800aa82 <tcp_write+0x48e>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
 800a9ae:	2000      	movs	r0, #0
 800a9b0:	e63e      	b.n	800a630 <tcp_write+0x3c>
       * sent out on the link (as it has to be ACKed by the remote
       * party) we can safely use PBUF_ROM instead of PBUF_REF here.
       */
      struct pbuf *p2;
#if TCP_OVERSIZE
      LWIP_ASSERT("oversize == 0", oversize == 0);
 800a9b2:	4b45      	ldr	r3, [pc, #276]	; (800aac8 <tcp_write+0x4d4>)
 800a9b4:	f240 2226 	movw	r2, #550	; 0x226
 800a9b8:	4948      	ldr	r1, [pc, #288]	; (800aadc <tcp_write+0x4e8>)
 800a9ba:	4845      	ldr	r0, [pc, #276]	; (800aad0 <tcp_write+0x4dc>)
 800a9bc:	f00a f9dc 	bl	8014d78 <iprintf>
 800a9c0:	e690      	b.n	800a6e4 <tcp_write+0xf0>
 800a9c2:	9005      	str	r0, [sp, #20]
 800a9c4:	e6c8      	b.n	800a758 <tcp_write+0x164>
       * into pbuf */
      if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apiflags, queue == NULL)) == NULL) {
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
 800a9c6:	4b40      	ldr	r3, [pc, #256]	; (800aac8 <tcp_write+0x4d4>)
 800a9c8:	f44f 7207 	mov.w	r2, #540	; 0x21c
 800a9cc:	4944      	ldr	r1, [pc, #272]	; (800aae0 <tcp_write+0x4ec>)
 800a9ce:	4840      	ldr	r0, [pc, #256]	; (800aad0 <tcp_write+0x4dc>)
 800a9d0:	f00a f9d2 	bl	8014d78 <iprintf>
 800a9d4:	e6e8      	b.n	800a7a8 <tcp_write+0x1b4>
    /* first segment of to-be-queued data? */
    if (queue == NULL) {
      queue = seg;
    } else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
 800a9d6:	4b3c      	ldr	r3, [pc, #240]	; (800aac8 <tcp_write+0x4d4>)
 800a9d8:	f240 225b 	movw	r2, #603	; 0x25b
 800a9dc:	4941      	ldr	r1, [pc, #260]	; (800aae4 <tcp_write+0x4f0>)
 800a9de:	483c      	ldr	r0, [pc, #240]	; (800aad0 <tcp_write+0x4dc>)
 800a9e0:	f00a f9ca 	bl	8014d78 <iprintf>
 800a9e4:	e6b6      	b.n	800a754 <tcp_write+0x160>
 800a9e6:	464f      	mov	r7, r9
 800a9e8:	f8dd 8014 	ldr.w	r8, [sp, #20]
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
 800a9ec:	7fbb      	ldrb	r3, [r7, #30]
 800a9ee:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800a9f2:	77bb      	strb	r3, [r7, #30]
  TCP_STATS_INC(tcp.memerr);

  if (concat_p != NULL) {
 800a9f4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800a9f6:	2b00      	cmp	r3, #0
 800a9f8:	f43f aef3 	beq.w	800a7e2 <tcp_write+0x1ee>
    pbuf_free(concat_p);
 800a9fc:	4618      	mov	r0, r3
 800a9fe:	f005 fb13 	bl	8010028 <pbuf_free>
 800aa02:	e6ee      	b.n	800a7e2 <tcp_write+0x1ee>
 800aa04:	4643      	mov	r3, r8

      /* Second, allocate a pbuf for the headers. */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p2);
 800aa06:	4618      	mov	r0, r3
 800aa08:	f8dd 8014 	ldr.w	r8, [sp, #20]
 800aa0c:	464f      	mov	r7, r9
 800aa0e:	f005 fb0b 	bl	8010028 <pbuf_free>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: could not allocate memory for header pbuf\n"));
        goto memerr;
 800aa12:	e7eb      	b.n	800a9ec <tcp_write+0x3f8>
 800aa14:	930b      	str	r3, [sp, #44]	; 0x2c
 800aa16:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 800aa18:	e654      	b.n	800a6c4 <tcp_write+0xd0>
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
  }
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
 800aa1a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800aa1c:	9309      	str	r3, [sp, #36]	; 0x24
 800aa1e:	2b00      	cmp	r3, #0
 800aa20:	f47f ae23 	bne.w	800a66a <tcp_write+0x76>
 800aa24:	4b28      	ldr	r3, [pc, #160]	; (800aac8 <tcp_write+0x4d4>)
 800aa26:	f240 1249 	movw	r2, #329	; 0x149
 800aa2a:	492f      	ldr	r1, [pc, #188]	; (800aae8 <tcp_write+0x4f4>)
 800aa2c:	4828      	ldr	r0, [pc, #160]	; (800aad0 <tcp_write+0x4dc>)
 800aa2e:	f00a f9a3 	bl	8014d78 <iprintf>
 800aa32:	f8b7 6068 	ldrh.w	r6, [r7, #104]	; 0x68
 800aa36:	e613      	b.n	800a660 <tcp_write+0x6c>
      /* Create a pbuf with a copy or reference to seglen bytes. We
       * can use PBUF_RAW here since the data appears in the middle of
       * a segment. A header will never be prepended. */
      if (apiflags & TCP_WRITE_FLAG_COPY) {
        /* Data is copied */
        if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {
 800aa38:	2301      	movs	r3, #1
 800aa3a:	9201      	str	r2, [sp, #4]
 800aa3c:	9302      	str	r3, [sp, #8]
 800aa3e:	9700      	str	r7, [sp, #0]
 800aa40:	4622      	mov	r2, r4
 800aa42:	f10d 0336 	add.w	r3, sp, #54	; 0x36
 800aa46:	4629      	mov	r1, r5
 800aa48:	2003      	movs	r0, #3
 800aa4a:	f7ff fcfb 	bl	800a444 <tcp_pbuf_prealloc>
 800aa4e:	900b      	str	r0, [sp, #44]	; 0x2c
 800aa50:	2800      	cmp	r0, #0
 800aa52:	d034      	beq.n	800aabe <tcp_write+0x4ca>
          goto memerr;
        }
#if TCP_OVERSIZE_DBGCHECK
        last_unsent->oversize_left += oversize;
#endif /* TCP_OVERSIZE_DBGCHECK */
        TCP_DATA_COPY2(concat_p->payload, (u8_t*)arg + pos, seglen, &concat_chksum, &concat_chksum_swapped);
 800aa54:	9906      	ldr	r1, [sp, #24]
 800aa56:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800aa58:	462a      	mov	r2, r5
 800aa5a:	4419      	add	r1, r3
 800aa5c:	6840      	ldr	r0, [r0, #4]
 800aa5e:	f00a f978 	bl	8014d52 <memcpy>
 800aa62:	e753      	b.n	800a90c <tcp_write+0x318>

  /* fail on too much data */
  if (len > pcb->snd_buf) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_write: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n",
      len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
 800aa64:	7fbb      	ldrb	r3, [r7, #30]
    return ERR_MEM;
 800aa66:	f04f 30ff 	mov.w	r0, #4294967295

  /* fail on too much data */
  if (len > pcb->snd_buf) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_write: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n",
      len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
 800aa6a:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800aa6e:	77bb      	strb	r3, [r7, #30]
 800aa70:	e5de      	b.n	800a630 <tcp_write+0x3c>
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
  struct pbuf *concat_p = NULL;
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
 800aa72:	465b      	mov	r3, fp
    LWIP_ASSERT("last_unsent->oversize_left >= oversize_used",
                last_unsent->oversize_left >= oversize_used);
    last_unsent->oversize_left -= oversize_used;
#endif /* TCP_OVERSIZE_DBGCHECK */
  }
  pcb->unsent_oversize = oversize;
 800aa74:	f8bd 2036 	ldrh.w	r2, [sp, #54]	; 0x36
 800aa78:	9c09      	ldr	r4, [sp, #36]	; 0x24
 800aa7a:	f8a7 206a 	strh.w	r2, [r7, #106]	; 0x6a
 800aa7e:	9309      	str	r3, [sp, #36]	; 0x24
 800aa80:	e774      	b.n	800a96c <tcp_write+0x378>
                pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued. */
  if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
 800aa82:	2008      	movs	r0, #8
 800aa84:	89ae      	ldrh	r6, [r5, #12]
 800aa86:	f003 f887 	bl	800db98 <lwip_htons>
 800aa8a:	4330      	orrs	r0, r6
 800aa8c:	81a8      	strh	r0, [r5, #12]
  }

  return ERR_OK;
 800aa8e:	4620      	mov	r0, r4
 800aa90:	e5ce      	b.n	800a630 <tcp_write+0x3c>
  u16_t queuelen;
  u8_t optlen = 0;
  u8_t optflags = 0;
#if TCP_OVERSIZE
  u16_t oversize = 0;
  u16_t oversize_used = 0;
 800aa92:	2400      	movs	r4, #0
      pos += seglen;
      queuelen += pbuf_clen(concat_p);
    }
  } else {
#if TCP_OVERSIZE
    LWIP_ASSERT("unsent_oversize mismatch (pcb->unsent is NULL)",
 800aa94:	4b0c      	ldr	r3, [pc, #48]	; (800aac8 <tcp_write+0x4d4>)
 800aa96:	f44f 7200 	mov.w	r2, #512	; 0x200
 800aa9a:	4914      	ldr	r1, [pc, #80]	; (800aaec <tcp_write+0x4f8>)
 800aa9c:	480c      	ldr	r0, [pc, #48]	; (800aad0 <tcp_write+0x4dc>)
  u16_t queuelen;
  u8_t optlen = 0;
  u8_t optflags = 0;
#if TCP_OVERSIZE
  u16_t oversize = 0;
  u16_t oversize_used = 0;
 800aa9e:	940a      	str	r4, [sp, #40]	; 0x28
      pos += seglen;
      queuelen += pbuf_clen(concat_p);
    }
  } else {
#if TCP_OVERSIZE
    LWIP_ASSERT("unsent_oversize mismatch (pcb->unsent is NULL)",
 800aaa0:	f00a f96a 	bl	8014d78 <iprintf>
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
  struct pbuf *concat_p = NULL;
  struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
 800aaa4:	9409      	str	r4, [sp, #36]	; 0x24
 * @return ERR_OK if enqueued, another err_t on error
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
{
  struct pbuf *concat_p = NULL;
 800aaa6:	940b      	str	r4, [sp, #44]	; 0x2c
 800aaa8:	e6c9      	b.n	800a83e <tcp_write+0x24a>
  }
  if (queue != NULL) {
    tcp_segs_free(queue);
  }
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
 800aaaa:	4b07      	ldr	r3, [pc, #28]	; (800aac8 <tcp_write+0x4d4>)
 800aaac:	f240 22c1 	movw	r2, #705	; 0x2c1
 800aab0:	490f      	ldr	r1, [pc, #60]	; (800aaf0 <tcp_write+0x4fc>)
 800aab2:	4807      	ldr	r0, [pc, #28]	; (800aad0 <tcp_write+0x4dc>)
 800aab4:	f00a f960 	bl	8014d78 <iprintf>
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_write: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
 800aab8:	f04f 30ff 	mov.w	r0, #4294967295
 800aabc:	e5b8      	b.n	800a630 <tcp_write+0x3c>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
 800aabe:	7fbb      	ldrb	r3, [r7, #30]
 800aac0:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800aac4:	77bb      	strb	r3, [r7, #30]
 800aac6:	e692      	b.n	800a7ee <tcp_write+0x1fa>
 800aac8:	08016aa0 	.word	0x08016aa0
 800aacc:	08016b68 	.word	0x08016b68
 800aad0:	0801660c 	.word	0x0801660c
 800aad4:	08016c50 	.word	0x08016c50
 800aad8:	08016b9c 	.word	0x08016b9c
 800aadc:	08016c2c 	.word	0x08016c2c
 800aae0:	08016bec 	.word	0x08016bec
 800aae4:	08016c3c 	.word	0x08016c3c
 800aae8:	08016b2c 	.word	0x08016b2c
 800aaec:	08016bbc 	.word	0x08016bbc
 800aaf0:	08016c88 	.word	0x08016c88
  /* Set the PSH flag in the last segment that we enqueued. */
  if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
 800aaf4:	9809      	ldr	r0, [sp, #36]	; 0x24
 800aaf6:	e59b      	b.n	800a630 <tcp_write+0x3c>
 800aaf8:	4628      	mov	r0, r5
 800aafa:	e599      	b.n	800a630 <tcp_write+0x3c>
  pcb->snd_queuelen = queuelen;

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: %"S16_F" (after enqueued)\n",
    pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_write: valid queue length",
 800aafc:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 800aafe:	2b00      	cmp	r3, #0
 800ab00:	f47f af46 	bne.w	800a990 <tcp_write+0x39c>
 800ab04:	4b11      	ldr	r3, [pc, #68]	; (800ab4c <tcp_write+0x558>)
 800ab06:	f44f 722b 	mov.w	r2, #684	; 0x2ac
 800ab0a:	4911      	ldr	r1, [pc, #68]	; (800ab50 <tcp_write+0x55c>)
 800ab0c:	4811      	ldr	r0, [pc, #68]	; (800ab54 <tcp_write+0x560>)
 800ab0e:	f00a f933 	bl	8014d78 <iprintf>
 800ab12:	e73d      	b.n	800a990 <tcp_write+0x39c>
  apiflags |= TCP_WRITE_FLAG_COPY;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)apiflags));
  LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)", 
 800ab14:	4b0d      	ldr	r3, [pc, #52]	; (800ab4c <tcp_write+0x558>)
 800ab16:	f240 127f 	movw	r2, #383	; 0x17f
 800ab1a:	490f      	ldr	r1, [pc, #60]	; (800ab58 <tcp_write+0x564>)
 800ab1c:	480d      	ldr	r0, [pc, #52]	; (800ab54 <tcp_write+0x560>)
 800ab1e:	f00a f92b 	bl	8014d78 <iprintf>
 800ab22:	f06f 000d 	mvn.w	r0, #13
 800ab26:	e583      	b.n	800a630 <tcp_write+0x3c>

  /*
   * Phase 3: Append queue to pcb->unsent. Queue may be NULL, but that
   * is harmless
   */
  if (last_unsent == NULL) {
 800ab28:	2c00      	cmp	r4, #0
 800ab2a:	f47f af1f 	bne.w	800a96c <tcp_write+0x378>
    pcb->unsent = queue;
 800ab2e:	f8c7 806c 	str.w	r8, [r7, #108]	; 0x6c
 800ab32:	e71d      	b.n	800a970 <tcp_write+0x37c>
 800ab34:	464b      	mov	r3, r9
 800ab36:	46b9      	mov	r9, r7
 800ab38:	9c09      	ldr	r4, [sp, #36]	; 0x24
 800ab3a:	f8dd 8014 	ldr.w	r8, [sp, #20]
 800ab3e:	461f      	mov	r7, r3
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_write: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      pbuf_free(p);
      goto memerr;
    }

    if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
 800ab40:	f8cd 9024 	str.w	r9, [sp, #36]	; 0x24
 800ab44:	e681      	b.n	800a84a <tcp_write+0x256>
  /*
   * Phase 1: If data has been added to the preallocated tail of
   * last_unsent, we update the length fields of the pbuf chain.
   */
#if TCP_OVERSIZE
  if (oversize_used > 0) {
 800ab46:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800ab48:	e794      	b.n	800aa74 <tcp_write+0x480>
 800ab4a:	bf00      	nop
 800ab4c:	08016aa0 	.word	0x08016aa0
 800ab50:	08016c88 	.word	0x08016c88
 800ab54:	0801660c 	.word	0x0801660c
 800ab58:	08016af8 	.word	0x08016af8

0800ab5c <tcp_enqueue_flags>:
 * @param optdata pointer to TCP options, or NULL.
 * @param optlen length of TCP options in bytes.
 */
err_t
tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
{
 800ab5c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  u8_t optflags = 0;
  u8_t optlen = 0;

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
 800ab60:	f011 0703 	ands.w	r7, r1, #3
 * @param optdata pointer to TCP options, or NULL.
 * @param optlen length of TCP options in bytes.
 */
err_t
tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
{
 800ab64:	b083      	sub	sp, #12
 800ab66:	460e      	mov	r6, r1
 800ab68:	4604      	mov	r4, r0
  u8_t optflags = 0;
  u8_t optlen = 0;

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
 800ab6a:	d05e      	beq.n	800ac2a <tcp_enqueue_flags+0xce>
              (flags & (TCP_SYN | TCP_FIN)) != 0);

  /* check for configured max queuelen and possible overflow */
  if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
 800ab6c:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
 800ab70:	2b17      	cmp	r3, #23
 800ab72:	f200 808d 	bhi.w	800ac90 <tcp_enqueue_flags+0x134>
 800ab76:	f006 0302 	and.w	r3, r6, #2

  /* tcp_enqueue_flags is always called with either SYN or FIN in flags.
   * We need one available snd_buf byte to do that.
   * This means we can't send FIN while snd_buf==0. A better fix would be to
   * not include SYN and FIN sequence numbers in the snd_buf count. */
  if (pcb->snd_buf == 0) {
 800ab7a:	f8b4 2066 	ldrh.w	r2, [r4, #102]	; 0x66
err_t
tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
{
  struct pbuf *p;
  struct tcp_seg *seg;
  u8_t optflags = 0;
 800ab7e:	2b00      	cmp	r3, #0
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
  }

  if (flags & TCP_SYN) {
 800ab80:	f003 01ff 	and.w	r1, r3, #255	; 0xff
err_t
tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
{
  struct pbuf *p;
  struct tcp_seg *seg;
  u8_t optflags = 0;
 800ab84:	bf0e      	itee	eq
 800ab86:	4689      	moveq	r9, r1
 800ab88:	f04f 0901 	movne.w	r9, #1
 800ab8c:	2104      	movne	r1, #4

  /* tcp_enqueue_flags is always called with either SYN or FIN in flags.
   * We need one available snd_buf byte to do that.
   * This means we can't send FIN while snd_buf==0. A better fix would be to
   * not include SYN and FIN sequence numbers in the snd_buf count. */
  if (pcb->snd_buf == 0) {
 800ab8e:	2a00      	cmp	r2, #0
 800ab90:	d07b      	beq.n	800ac8a <tcp_enqueue_flags+0x12e>
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
  }

  /* Allocate pbuf with room for TCP header + options */
  if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
 800ab92:	2200      	movs	r2, #0
 800ab94:	b28d      	uxth	r5, r1
 800ab96:	4629      	mov	r1, r5
 800ab98:	4610      	mov	r0, r2
 800ab9a:	f005 fa9d 	bl	80100d8 <pbuf_alloc>
 800ab9e:	4680      	mov	r8, r0
 800aba0:	2800      	cmp	r0, #0
 800aba2:	d075      	beq.n	800ac90 <tcp_enqueue_flags+0x134>
    pcb->flags |= TF_NAGLEMEMERR;
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
 800aba4:	8943      	ldrh	r3, [r0, #10]
 800aba6:	42ab      	cmp	r3, r5
 800aba8:	d347      	bcc.n	800ac3a <tcp_enqueue_flags+0xde>
              (p->len >= optlen));

  /* Allocate memory for tcp_seg, and fill in fields. */
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
 800abaa:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 800abac:	4642      	mov	r2, r8
 800abae:	9300      	str	r3, [sp, #0]
 800abb0:	f8cd 9004 	str.w	r9, [sp, #4]
 800abb4:	4633      	mov	r3, r6
 800abb6:	f104 011c 	add.w	r1, r4, #28
 800abba:	f104 001a 	add.w	r0, r4, #26
 800abbe:	f7ff fc81 	bl	800a4c4 <tcp_create_segment.isra.0>
 800abc2:	4605      	mov	r5, r0
 800abc4:	2800      	cmp	r0, #0
 800abc6:	d063      	beq.n	800ac90 <tcp_enqueue_flags+0x134>
    pcb->flags |= TF_NAGLEMEMERR;
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("seg->tcphdr not aligned", ((mem_ptr_t)seg->tcphdr % MEM_ALIGNMENT) == 0);
 800abc8:	68c3      	ldr	r3, [r0, #12]
 800abca:	079a      	lsls	r2, r3, #30
 800abcc:	d149      	bne.n	800ac62 <tcp_enqueue_flags+0x106>
  LWIP_ASSERT("tcp_enqueue_flags: invalid segment length", seg->len == 0);
 800abce:	892b      	ldrh	r3, [r5, #8]
 800abd0:	2b00      	cmp	r3, #0
 800abd2:	d13a      	bne.n	800ac4a <tcp_enqueue_flags+0xee>
               ntohl(seg->tcphdr->seqno),
               ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
               (u16_t)flags));

  /* Now append seg to pcb->unsent queue */
  if (pcb->unsent == NULL) {
 800abd4:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 800abd6:	b90a      	cbnz	r2, 800abdc <tcp_enqueue_flags+0x80>
 800abd8:	e041      	b.n	800ac5e <tcp_enqueue_flags+0x102>
 800abda:	461a      	mov	r2, r3
    pcb->unsent = seg;
  } else {
    struct tcp_seg *useg;
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
 800abdc:	6813      	ldr	r3, [r2, #0]
 800abde:	2b00      	cmp	r3, #0
 800abe0:	d1fb      	bne.n	800abda <tcp_enqueue_flags+0x7e>
    useg->next = seg;
 800abe2:	6015      	str	r5, [r2, #0]
  }
#if TCP_OVERSIZE
  /* The new unsent tail has no space */
  pcb->unsent_oversize = 0;
 800abe4:	2300      	movs	r3, #0
 800abe6:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
#endif /* TCP_OVERSIZE */

  /* SYN and FIN bump the sequence number */
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
 800abea:	b13f      	cbz	r7, 800abfc <tcp_enqueue_flags+0xa0>
    pcb->snd_lbb++;
 800abec:	6de2      	ldr	r2, [r4, #92]	; 0x5c
    /* optlen does not influence snd_buf */
    pcb->snd_buf--;
 800abee:	f8b4 3066 	ldrh.w	r3, [r4, #102]	; 0x66
  pcb->unsent_oversize = 0;
#endif /* TCP_OVERSIZE */

  /* SYN and FIN bump the sequence number */
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
    pcb->snd_lbb++;
 800abf2:	3201      	adds	r2, #1
    /* optlen does not influence snd_buf */
    pcb->snd_buf--;
 800abf4:	3b01      	subs	r3, #1
  pcb->unsent_oversize = 0;
#endif /* TCP_OVERSIZE */

  /* SYN and FIN bump the sequence number */
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
    pcb->snd_lbb++;
 800abf6:	65e2      	str	r2, [r4, #92]	; 0x5c
    /* optlen does not influence snd_buf */
    pcb->snd_buf--;
 800abf8:	f8a4 3066 	strh.w	r3, [r4, #102]	; 0x66
  }
  if (flags & TCP_FIN) {
 800abfc:	07f3      	lsls	r3, r6, #31
 800abfe:	d40f      	bmi.n	800ac20 <tcp_enqueue_flags+0xc4>
    pcb->flags |= TF_FIN;
  }

  /* update number of segments on the queues */
  pcb->snd_queuelen += pbuf_clen(seg->p);
 800ac00:	6868      	ldr	r0, [r5, #4]
 800ac02:	f005 fbb7 	bl	8010374 <pbuf_clen>
 800ac06:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
 800ac0a:	4418      	add	r0, r3
 800ac0c:	b280      	uxth	r0, r0
 800ac0e:	f8a4 0068 	strh.w	r0, [r4, #104]	; 0x68
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
 800ac12:	b110      	cbz	r0, 800ac1a <tcp_enqueue_flags+0xbe>
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
 800ac14:	6f20      	ldr	r0, [r4, #112]	; 0x70
 800ac16:	b360      	cbz	r0, 800ac72 <tcp_enqueue_flags+0x116>
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  return ERR_OK;
 800ac18:	2000      	movs	r0, #0
}
 800ac1a:	b003      	add	sp, #12
 800ac1c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    pcb->snd_lbb++;
    /* optlen does not influence snd_buf */
    pcb->snd_buf--;
  }
  if (flags & TCP_FIN) {
    pcb->flags |= TF_FIN;
 800ac20:	7fa3      	ldrb	r3, [r4, #30]
 800ac22:	f043 0320 	orr.w	r3, r3, #32
 800ac26:	77a3      	strb	r3, [r4, #30]
 800ac28:	e7ea      	b.n	800ac00 <tcp_enqueue_flags+0xa4>
  u8_t optflags = 0;
  u8_t optlen = 0;

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
 800ac2a:	4b1d      	ldr	r3, [pc, #116]	; (800aca0 <tcp_enqueue_flags+0x144>)
 800ac2c:	f44f 7237 	mov.w	r2, #732	; 0x2dc
 800ac30:	491c      	ldr	r1, [pc, #112]	; (800aca4 <tcp_enqueue_flags+0x148>)
 800ac32:	481d      	ldr	r0, [pc, #116]	; (800aca8 <tcp_enqueue_flags+0x14c>)
 800ac34:	f00a f8a0 	bl	8014d78 <iprintf>
 800ac38:	e798      	b.n	800ab6c <tcp_enqueue_flags+0x10>
  if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
    pcb->flags |= TF_NAGLEMEMERR;
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
 800ac3a:	4b19      	ldr	r3, [pc, #100]	; (800aca0 <tcp_enqueue_flags+0x144>)
 800ac3c:	f240 3202 	movw	r2, #770	; 0x302
 800ac40:	491a      	ldr	r1, [pc, #104]	; (800acac <tcp_enqueue_flags+0x150>)
 800ac42:	4819      	ldr	r0, [pc, #100]	; (800aca8 <tcp_enqueue_flags+0x14c>)
 800ac44:	f00a f898 	bl	8014d78 <iprintf>
 800ac48:	e7af      	b.n	800abaa <tcp_enqueue_flags+0x4e>
    pcb->flags |= TF_NAGLEMEMERR;
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("seg->tcphdr not aligned", ((mem_ptr_t)seg->tcphdr % MEM_ALIGNMENT) == 0);
  LWIP_ASSERT("tcp_enqueue_flags: invalid segment length", seg->len == 0);
 800ac4a:	f240 320b 	movw	r2, #779	; 0x30b
 800ac4e:	4b14      	ldr	r3, [pc, #80]	; (800aca0 <tcp_enqueue_flags+0x144>)
 800ac50:	4917      	ldr	r1, [pc, #92]	; (800acb0 <tcp_enqueue_flags+0x154>)
 800ac52:	4815      	ldr	r0, [pc, #84]	; (800aca8 <tcp_enqueue_flags+0x14c>)
 800ac54:	f00a f890 	bl	8014d78 <iprintf>
               ntohl(seg->tcphdr->seqno),
               ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
               (u16_t)flags));

  /* Now append seg to pcb->unsent queue */
  if (pcb->unsent == NULL) {
 800ac58:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 800ac5a:	2a00      	cmp	r2, #0
 800ac5c:	d1be      	bne.n	800abdc <tcp_enqueue_flags+0x80>
    pcb->unsent = seg;
 800ac5e:	66e5      	str	r5, [r4, #108]	; 0x6c
 800ac60:	e7c0      	b.n	800abe4 <tcp_enqueue_flags+0x88>
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
    pcb->flags |= TF_NAGLEMEMERR;
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("seg->tcphdr not aligned", ((mem_ptr_t)seg->tcphdr % MEM_ALIGNMENT) == 0);
 800ac62:	4b0f      	ldr	r3, [pc, #60]	; (800aca0 <tcp_enqueue_flags+0x144>)
 800ac64:	f240 320a 	movw	r2, #778	; 0x30a
 800ac68:	4912      	ldr	r1, [pc, #72]	; (800acb4 <tcp_enqueue_flags+0x158>)
 800ac6a:	480f      	ldr	r0, [pc, #60]	; (800aca8 <tcp_enqueue_flags+0x14c>)
 800ac6c:	f00a f884 	bl	8014d78 <iprintf>
 800ac70:	e7ad      	b.n	800abce <tcp_enqueue_flags+0x72>

  /* update number of segments on the queues */
  pcb->snd_queuelen += pbuf_clen(seg->p);
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
 800ac72:	6ee4      	ldr	r4, [r4, #108]	; 0x6c
 800ac74:	2c00      	cmp	r4, #0
 800ac76:	d1d0      	bne.n	800ac1a <tcp_enqueue_flags+0xbe>
 800ac78:	4b09      	ldr	r3, [pc, #36]	; (800aca0 <tcp_enqueue_flags+0x144>)
 800ac7a:	f240 322f 	movw	r2, #815	; 0x32f
 800ac7e:	490e      	ldr	r1, [pc, #56]	; (800acb8 <tcp_enqueue_flags+0x15c>)
 800ac80:	4809      	ldr	r0, [pc, #36]	; (800aca8 <tcp_enqueue_flags+0x14c>)
 800ac82:	f00a f879 	bl	8014d78 <iprintf>
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  return ERR_OK;
 800ac86:	4620      	mov	r0, r4
 800ac88:	e7c7      	b.n	800ac1a <tcp_enqueue_flags+0xbe>
   * This means we can't send FIN while snd_buf==0. A better fix would be to
   * not include SYN and FIN sequence numbers in the snd_buf count. */
  if (pcb->snd_buf == 0) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue_flags: no send buffer available\n"));
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
 800ac8a:	f04f 30ff 	mov.w	r0, #4294967295
 800ac8e:	e7c4      	b.n	800ac1a <tcp_enqueue_flags+0xbe>
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
              (p->len >= optlen));

  /* Allocate memory for tcp_seg, and fill in fields. */
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
    pcb->flags |= TF_NAGLEMEMERR;
 800ac90:	7fa3      	ldrb	r3, [r4, #30]
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
 800ac92:	f04f 30ff 	mov.w	r0, #4294967295
  LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
              (p->len >= optlen));

  /* Allocate memory for tcp_seg, and fill in fields. */
  if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
    pcb->flags |= TF_NAGLEMEMERR;
 800ac96:	f063 037f 	orn	r3, r3, #127	; 0x7f
 800ac9a:	77a3      	strb	r3, [r4, #30]
    TCP_STATS_INC(tcp.memerr);
    return ERR_MEM;
 800ac9c:	e7bd      	b.n	800ac1a <tcp_enqueue_flags+0xbe>
 800ac9e:	bf00      	nop
 800aca0:	08016aa0 	.word	0x08016aa0
 800aca4:	08016ca8 	.word	0x08016ca8
 800aca8:	0801660c 	.word	0x0801660c
 800acac:	08016d00 	.word	0x08016d00
 800acb0:	08016d54 	.word	0x08016d54
 800acb4:	08016d3c 	.word	0x08016d3c
 800acb8:	08016d80 	.word	0x08016d80

0800acbc <tcp_send_fin>:
 * @param pcb the tcp_pcb over which to send a segment
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_fin(struct tcp_pcb *pcb)
{
 800acbc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  /* first, try to add the fin to the last unsent segment */
  if (pcb->unsent != NULL) {
 800acbe:	6ec4      	ldr	r4, [r0, #108]	; 0x6c
 * @param pcb the tcp_pcb over which to send a segment
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_fin(struct tcp_pcb *pcb)
{
 800acc0:	4605      	mov	r5, r0
  /* first, try to add the fin to the last unsent segment */
  if (pcb->unsent != NULL) {
 800acc2:	b90c      	cbnz	r4, 800acc8 <tcp_send_fin+0xc>
 800acc4:	e00a      	b.n	800acdc <tcp_send_fin+0x20>
 800acc6:	461c      	mov	r4, r3
    struct tcp_seg *last_unsent;
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
 800acc8:	6823      	ldr	r3, [r4, #0]
 800acca:	2b00      	cmp	r3, #0
 800accc:	d1fb      	bne.n	800acc6 <tcp_send_fin+0xa>
         last_unsent = last_unsent->next);

    if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
 800acce:	68e3      	ldr	r3, [r4, #12]
 800acd0:	8998      	ldrh	r0, [r3, #12]
 800acd2:	f002 ff65 	bl	800dba0 <lwip_ntohs>
 800acd6:	f010 0607 	ands.w	r6, r0, #7
 800acda:	d005      	beq.n	800ace8 <tcp_send_fin+0x2c>
      pcb->flags |= TF_FIN;
      return ERR_OK;
    }
  }
  /* no data, no length, flags, copy=1, no optdata */
  return tcp_enqueue_flags(pcb, TCP_FIN);
 800acdc:	4628      	mov	r0, r5
}
 800acde:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
      pcb->flags |= TF_FIN;
      return ERR_OK;
    }
  }
  /* no data, no length, flags, copy=1, no optdata */
  return tcp_enqueue_flags(pcb, TCP_FIN);
 800ace2:	2101      	movs	r1, #1
 800ace4:	f7ff bf3a 	b.w	800ab5c <tcp_enqueue_flags>
    for (last_unsent = pcb->unsent; last_unsent->next != NULL;
         last_unsent = last_unsent->next);

    if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
      /* no SYN/FIN/RST flag in the header, we can add the FIN flag */
      TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
 800ace8:	68e7      	ldr	r7, [r4, #12]
 800acea:	2001      	movs	r0, #1
 800acec:	89bc      	ldrh	r4, [r7, #12]
 800acee:	f002 ff53 	bl	800db98 <lwip_htons>
 800acf2:	4320      	orrs	r0, r4
 800acf4:	81b8      	strh	r0, [r7, #12]
      pcb->flags |= TF_FIN;
 800acf6:	7fab      	ldrb	r3, [r5, #30]
      return ERR_OK;
    }
  }
  /* no data, no length, flags, copy=1, no optdata */
  return tcp_enqueue_flags(pcb, TCP_FIN);
}
 800acf8:	4630      	mov	r0, r6
         last_unsent = last_unsent->next);

    if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
      /* no SYN/FIN/RST flag in the header, we can add the FIN flag */
      TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
      pcb->flags |= TF_FIN;
 800acfa:	f043 0320 	orr.w	r3, r3, #32
 800acfe:	77ab      	strb	r3, [r5, #30]
      return ERR_OK;
    }
  }
  /* no data, no length, flags, copy=1, no optdata */
  return tcp_enqueue_flags(pcb, TCP_FIN);
}
 800ad00:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800ad02:	bf00      	nop

0800ad04 <tcp_send_empty_ack>:
 *
 * @param pcb Protocol control block for the TCP connection to send the ACK
 */
err_t
tcp_send_empty_ack(struct tcp_pcb *pcb)
{
 800ad04:	b5f0      	push	{r4, r5, r6, r7, lr}
 800ad06:	4604      	mov	r4, r0
 800ad08:	b083      	sub	sp, #12
  if (pcb->flags & TF_TIMESTAMP) {
    optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
  }
#endif

  p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
 800ad0a:	6d00      	ldr	r0, [r0, #80]	; 0x50
 800ad0c:	f002 ff4e 	bl	800dbac <lwip_htonl>
 800ad10:	2100      	movs	r1, #0
 800ad12:	4602      	mov	r2, r0
 800ad14:	4620      	mov	r0, r4
 800ad16:	f7ff fc2f 	bl	800a578 <tcp_output_alloc_header.constprop.1>
  if (p == NULL) {
 800ad1a:	b1f0      	cbz	r0, 800ad5a <tcp_send_empty_ack+0x56>
  }
  tcphdr = (struct tcp_hdr *)p->payload;
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, 
              ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
  /* remove ACK flags from the PCB, as we send an empty ACK now */
  pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 800ad1c:	7fa3      	ldrb	r3, [r4, #30]
  p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
  if (p == NULL) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
    return ERR_BUF;
  }
  tcphdr = (struct tcp_hdr *)p->payload;
 800ad1e:	6847      	ldr	r7, [r0, #4]
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, 
              ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
  /* remove ACK flags from the PCB, as we send an empty ACK now */
  pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 800ad20:	f023 0303 	bic.w	r3, r3, #3
 800ad24:	77a3      	strb	r3, [r4, #30]
    tcp_build_timestamp_option(pcb, (u32_t *)(tcphdr + 1));
  }
#endif 

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
 800ad26:	8903      	ldrh	r3, [r0, #8]
 800ad28:	1d26      	adds	r6, r4, #4
 800ad2a:	9300      	str	r3, [sp, #0]
 800ad2c:	4632      	mov	r2, r6
 800ad2e:	2306      	movs	r3, #6
 800ad30:	4621      	mov	r1, r4
 800ad32:	4605      	mov	r5, r0
 800ad34:	f003 fd54 	bl	800e7e0 <inet_chksum_pseudo>
 800ad38:	8238      	strh	r0, [r7, #16]
#endif
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
 800ad3a:	7a61      	ldrb	r1, [r4, #9]
 800ad3c:	2006      	movs	r0, #6
 800ad3e:	7aa3      	ldrb	r3, [r4, #10]
 800ad40:	4632      	mov	r2, r6
 800ad42:	9100      	str	r1, [sp, #0]
 800ad44:	9001      	str	r0, [sp, #4]
 800ad46:	4621      	mov	r1, r4
 800ad48:	4628      	mov	r0, r5
 800ad4a:	f003 ffa9 	bl	800eca0 <ip_output>
      IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
  pbuf_free(p);
 800ad4e:	4628      	mov	r0, r5
 800ad50:	f005 f96a 	bl	8010028 <pbuf_free>

  return ERR_OK;
 800ad54:	2000      	movs	r0, #0
}
 800ad56:	b003      	add	sp, #12
 800ad58:	bdf0      	pop	{r4, r5, r6, r7, pc}
#endif

  p = tcp_output_alloc_header(pcb, optlen, 0, htonl(pcb->snd_nxt));
  if (p == NULL) {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
    return ERR_BUF;
 800ad5a:	f06f 0001 	mvn.w	r0, #1
 800ad5e:	e7fa      	b.n	800ad56 <tcp_send_empty_ack+0x52>

0800ad60 <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
 800ad60:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
#if TCP_CWND_DEBUG
  s16_t i = 0;
#endif /* TCP_CWND_DEBUG */

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_output for listen-pcbs",
 800ad64:	7e03      	ldrb	r3, [r0, #24]
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
 800ad66:	b083      	sub	sp, #12
#if TCP_CWND_DEBUG
  s16_t i = 0;
#endif /* TCP_CWND_DEBUG */

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_output for listen-pcbs",
 800ad68:	2b01      	cmp	r3, #1
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
 800ad6a:	4604      	mov	r4, r0
#if TCP_CWND_DEBUG
  s16_t i = 0;
#endif /* TCP_CWND_DEBUG */

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_output for listen-pcbs",
 800ad6c:	f000 8156 	beq.w	800b01c <tcp_output+0x2bc>

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
 800ad70:	4bae      	ldr	r3, [pc, #696]	; (800b02c <tcp_output+0x2cc>)
 800ad72:	681b      	ldr	r3, [r3, #0]
 800ad74:	429c      	cmp	r4, r3
 800ad76:	f000 80e5 	beq.w	800af44 <tcp_output+0x1e4>
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
 800ad7a:	f8b4 804c 	ldrh.w	r8, [r4, #76]	; 0x4c
 800ad7e:	f8b4 2060 	ldrh.w	r2, [r4, #96]	; 0x60
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
 800ad82:	7fa3      	ldrb	r3, [r4, #30]
     with. */
  if (tcp_input_pcb == pcb) {
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
 800ad84:	4590      	cmp	r8, r2
 800ad86:	bf28      	it	cs
 800ad88:	4690      	movcs	r8, r2
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
 800ad8a:	0799      	lsls	r1, r3, #30
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);

  seg = pcb->unsent;
 800ad8c:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
 800ad8e:	f140 80dd 	bpl.w	800af4c <tcp_output+0x1ec>
 800ad92:	2d00      	cmp	r5, #0
 800ad94:	f000 813c 	beq.w	800b010 <tcp_output+0x2b0>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
 800ad98:	68eb      	ldr	r3, [r5, #12]
 800ad9a:	6858      	ldr	r0, [r3, #4]
 800ad9c:	f002 ff04 	bl	800dba8 <lwip_ntohl>
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
 800ada0:	892b      	ldrh	r3, [r5, #8]
 800ada2:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 800ada4:	1a9b      	subs	r3, r3, r2
 800ada6:	4418      	add	r0, r3
 800ada8:	4580      	cmp	r8, r0
 800adaa:	f0c0 8131 	bcc.w	800b010 <tcp_output+0x2b0>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
     return tcp_send_empty_ack(pcb);
  }

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
 800adae:	6f27      	ldr	r7, [r4, #112]	; 0x70
  if (useg != NULL) {
 800adb0:	2f00      	cmp	r7, #0
 800adb2:	f000 80a7 	beq.w	800af04 <tcp_output+0x1a4>
    for (; useg->next != NULL; useg = useg->next);
 800adb6:	683b      	ldr	r3, [r7, #0]
 800adb8:	2b00      	cmp	r3, #0
 800adba:	f040 80ca 	bne.w	800af52 <tcp_output+0x1f2>
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
 800adbe:	2d00      	cmp	r5, #0
 800adc0:	f040 80a0 	bne.w	800af04 <tcp_output+0x1a4>
 800adc4:	e0b7      	b.n	800af36 <tcp_output+0x1d6>
     * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_write/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
 800adc6:	6f23      	ldr	r3, [r4, #112]	; 0x70
 800adc8:	b15b      	cbz	r3, 800ade2 <tcp_output+0x82>
 800adca:	7fa3      	ldrb	r3, [r4, #30]
 800adcc:	f013 0f44 	tst.w	r3, #68	; 0x44
 800add0:	d107      	bne.n	800ade2 <tcp_output+0x82>
 800add2:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 800add4:	2a00      	cmp	r2, #0
 800add6:	f000 810c 	beq.w	800aff2 <tcp_output+0x292>
 800adda:	6811      	ldr	r1, [r2, #0]
 800addc:	2900      	cmp	r1, #0
 800adde:	f000 8103 	beq.w	800afe8 <tcp_output+0x288>
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;

    if (pcb->state != SYN_SENT) {
 800ade2:	7e23      	ldrb	r3, [r4, #24]
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
 800ade4:	682a      	ldr	r2, [r5, #0]

    if (pcb->state != SYN_SENT) {
 800ade6:	2b02      	cmp	r3, #2
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
 800ade8:	66e2      	str	r2, [r4, #108]	; 0x6c

    if (pcb->state != SYN_SENT) {
 800adea:	d00d      	beq.n	800ae08 <tcp_output+0xa8>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
 800adec:	f8d5 900c 	ldr.w	r9, [r5, #12]
 800adf0:	2010      	movs	r0, #16
 800adf2:	f8b9 600c 	ldrh.w	r6, [r9, #12]
 800adf6:	f002 fecf 	bl	800db98 <lwip_htons>
 800adfa:	4330      	orrs	r0, r6
 800adfc:	f8a9 000c 	strh.w	r0, [r9, #12]
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
 800ae00:	7fa3      	ldrb	r3, [r4, #30]
 800ae02:	f023 0303 	bic.w	r3, r3, #3
 800ae06:	77a3      	strb	r3, [r4, #30]
  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
 800ae08:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 800ae0a:	68ee      	ldr	r6, [r5, #12]
 800ae0c:	f002 fece 	bl	800dbac <lwip_htonl>
 800ae10:	60b0      	str	r0, [r6, #8]

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
 800ae12:	8de0      	ldrh	r0, [r4, #46]	; 0x2e
 800ae14:	68ee      	ldr	r6, [r5, #12]
 800ae16:	f002 febf 	bl	800db98 <lwip_htons>

  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 800ae1a:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
 800ae1c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
 800ae1e:	81f0      	strh	r0, [r6, #14]

  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
 800ae20:	4413      	add	r3, r2
 800ae22:	6323      	str	r3, [r4, #48]	; 0x30

  /* Add any requested options.  NB MSS option is only set on SYN
     packets, so ignore it here */
  opts = (u32_t *)(void *)(seg->tcphdr + 1);
  if (seg->flags & TF_SEG_OPTS_MSS) {
 800ae24:	7aab      	ldrb	r3, [r5, #10]
    u16_t mss;
#if TCP_CALCULATE_EFF_SEND_MSS
    mss = tcp_eff_send_mss(TCP_MSS, &pcb->remote_ip);
 800ae26:	f104 0904 	add.w	r9, r4, #4
  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;

  /* Add any requested options.  NB MSS option is only set on SYN
     packets, so ignore it here */
  opts = (u32_t *)(void *)(seg->tcphdr + 1);
  if (seg->flags & TF_SEG_OPTS_MSS) {
 800ae2a:	07db      	lsls	r3, r3, #31
 800ae2c:	f100 8096 	bmi.w	800af5c <tcp_output+0x1fc>
  }
#endif

  /* Set retransmission timer running if it is not currently enabled 
     This must be set before checking the route. */
  if (pcb->rtime == -1) {
 800ae30:	f9b4 3034 	ldrsh.w	r3, [r4, #52]	; 0x34
 800ae34:	3301      	adds	r3, #1
 800ae36:	f000 80a1 	beq.w	800af7c <tcp_output+0x21c>
    pcb->rtime = 0;
  }

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
 800ae3a:	6823      	ldr	r3, [r4, #0]
 800ae3c:	b92b      	cbnz	r3, 800ae4a <tcp_output+0xea>
    netif = ip_route(&(pcb->remote_ip));
 800ae3e:	4648      	mov	r0, r9
 800ae40:	f003 fdc6 	bl	800e9d0 <ip_route>
    if (netif == NULL) {
 800ae44:	b330      	cbz	r0, 800ae94 <tcp_output+0x134>
      return;
    }
    ip_addr_copy(pcb->local_ip, netif->ip_addr);
 800ae46:	6843      	ldr	r3, [r0, #4]
 800ae48:	6023      	str	r3, [r4, #0]
  }

  if (pcb->rttest == 0) {
 800ae4a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800ae4c:	2b00      	cmp	r3, #0
 800ae4e:	f000 8098 	beq.w	800af82 <tcp_output+0x222>
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
 800ae52:	6868      	ldr	r0, [r5, #4]
 800ae54:	68ee      	ldr	r6, [r5, #12]
 800ae56:	6843      	ldr	r3, [r0, #4]

  seg->p->len -= len;
  seg->p->tot_len -= len;
 800ae58:	8902      	ldrh	r2, [r0, #8]
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
 800ae5a:	1af3      	subs	r3, r6, r3

  seg->p->len -= len;
 800ae5c:	8941      	ldrh	r1, [r0, #10]
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
 800ae5e:	b29b      	uxth	r3, r3

  seg->p->len -= len;
  seg->p->tot_len -= len;
 800ae60:	1ad2      	subs	r2, r2, r3
 800ae62:	b292      	uxth	r2, r2
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);

  seg->p->len -= len;
 800ae64:	1acb      	subs	r3, r1, r3
  seg->p->tot_len -= len;

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
 800ae66:	2100      	movs	r1, #0
  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);

  seg->p->len -= len;
  seg->p->tot_len -= len;

  seg->p->payload = seg->tcphdr;
 800ae68:	6046      	str	r6, [r0, #4]
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);

  seg->p->len -= len;
 800ae6a:	8143      	strh	r3, [r0, #10]
  seg->p->tot_len -= len;
 800ae6c:	8102      	strh	r2, [r0, #8]
      seg->tcphdr->chksum = chksum_slow;
    }
#endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
  }
#else /* TCP_CHECKSUM_ON_COPY */
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p, &(pcb->local_ip),
 800ae6e:	2306      	movs	r3, #6
  seg->p->len -= len;
  seg->p->tot_len -= len;

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
 800ae70:	7431      	strb	r1, [r6, #16]
 800ae72:	7471      	strb	r1, [r6, #17]
      seg->tcphdr->chksum = chksum_slow;
    }
#endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
  }
#else /* TCP_CHECKSUM_ON_COPY */
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p, &(pcb->local_ip),
 800ae74:	9200      	str	r2, [sp, #0]
 800ae76:	4621      	mov	r1, r4
 800ae78:	464a      	mov	r2, r9
 800ae7a:	f003 fcb1 	bl	800e7e0 <inet_chksum_pseudo>
 800ae7e:	8230      	strh	r0, [r6, #16]

#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP, &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
 800ae80:	7a66      	ldrb	r6, [r4, #9]
 800ae82:	2106      	movs	r1, #6
 800ae84:	7aa3      	ldrb	r3, [r4, #10]
 800ae86:	6868      	ldr	r0, [r5, #4]
 800ae88:	464a      	mov	r2, r9
 800ae8a:	9101      	str	r1, [sp, #4]
 800ae8c:	9600      	str	r6, [sp, #0]
 800ae8e:	4621      	mov	r1, r4
 800ae90:	f003 ff06 	bl	800eca0 <ip_output>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }

    tcp_output_segment(seg, pcb);
    snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
 800ae94:	68eb      	ldr	r3, [r5, #12]
 800ae96:	6858      	ldr	r0, [r3, #4]
 800ae98:	f002 fe86 	bl	800dba8 <lwip_ntohl>
 800ae9c:	68eb      	ldr	r3, [r5, #12]
 800ae9e:	4606      	mov	r6, r0
 800aea0:	8998      	ldrh	r0, [r3, #12]
 800aea2:	f8b5 9008 	ldrh.w	r9, [r5, #8]
 800aea6:	f002 fe7b 	bl	800dba0 <lwip_ntohs>
 800aeaa:	f010 0003 	ands.w	r0, r0, #3
 800aeae:	bf18      	it	ne
 800aeb0:	2001      	movne	r0, #1
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
 800aeb2:	6d23      	ldr	r3, [r4, #80]	; 0x50
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }

    tcp_output_segment(seg, pcb);
    snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
 800aeb4:	4448      	add	r0, r9
 800aeb6:	4430      	add	r0, r6
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
 800aeb8:	1a1b      	subs	r3, r3, r0
 800aeba:	2b00      	cmp	r3, #0
      pcb->snd_nxt = snd_nxt;
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
 800aebc:	68eb      	ldr	r3, [r5, #12]
    }

    tcp_output_segment(seg, pcb);
    snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
      pcb->snd_nxt = snd_nxt;
 800aebe:	bfb8      	it	lt
 800aec0:	6520      	strlt	r0, [r4, #80]	; 0x50
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
 800aec2:	8998      	ldrh	r0, [r3, #12]
 800aec4:	892e      	ldrh	r6, [r5, #8]
 800aec6:	f002 fe6b 	bl	800dba0 <lwip_ntohs>
 800aeca:	f010 0003 	ands.w	r0, r0, #3
 800aece:	bf18      	it	ne
 800aed0:	2001      	movne	r0, #1
 800aed2:	42f0      	cmn	r0, r6
 800aed4:	f000 8084 	beq.w	800afe0 <tcp_output+0x280>
      seg->next = NULL;
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
 800aed8:	6f23      	ldr	r3, [r4, #112]	; 0x70
    if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
      pcb->snd_nxt = snd_nxt;
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
      seg->next = NULL;
 800aeda:	2200      	movs	r2, #0
 800aedc:	602a      	str	r2, [r5, #0]
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
 800aede:	2b00      	cmp	r3, #0
 800aee0:	d058      	beq.n	800af94 <tcp_output+0x234>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
 800aee2:	68eb      	ldr	r3, [r5, #12]
 800aee4:	6858      	ldr	r0, [r3, #4]
 800aee6:	f002 fe5f 	bl	800dba8 <lwip_ntohl>
 800aeea:	68fb      	ldr	r3, [r7, #12]
 800aeec:	4606      	mov	r6, r0
 800aeee:	6858      	ldr	r0, [r3, #4]
 800aef0:	f002 fe5a 	bl	800dba8 <lwip_ntohl>
 800aef4:	1a30      	subs	r0, r6, r0
 800aef6:	2800      	cmp	r0, #0
 800aef8:	db56      	blt.n	800afa8 <tcp_output+0x248>
          }
          seg->next = (*cur_seg);
          (*cur_seg) = seg;
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
 800aefa:	603d      	str	r5, [r7, #0]
 800aefc:	462f      	mov	r7, r5
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
 800aefe:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
 800af00:	2d00      	cmp	r5, #0
 800af02:	d04c      	beq.n	800af9e <tcp_output+0x23e>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
 800af04:	68eb      	ldr	r3, [r5, #12]
 800af06:	6858      	ldr	r0, [r3, #4]
 800af08:	f002 fe4e 	bl	800dba8 <lwip_ntohl>
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
 800af0c:	892b      	ldrh	r3, [r5, #8]
 800af0e:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 800af10:	1a9b      	subs	r3, r3, r2
 800af12:	4418      	add	r0, r3
 800af14:	4580      	cmp	r8, r0
 800af16:	d30e      	bcc.n	800af36 <tcp_output+0x1d6>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
 800af18:	68eb      	ldr	r3, [r5, #12]
 800af1a:	8998      	ldrh	r0, [r3, #12]
 800af1c:	f002 fe40 	bl	800dba0 <lwip_ntohs>
 800af20:	0742      	lsls	r2, r0, #29
 800af22:	f57f af50 	bpl.w	800adc6 <tcp_output+0x66>
 800af26:	4b42      	ldr	r3, [pc, #264]	; (800b030 <tcp_output+0x2d0>)
 800af28:	f240 32c5 	movw	r2, #965	; 0x3c5
 800af2c:	4941      	ldr	r1, [pc, #260]	; (800b034 <tcp_output+0x2d4>)
 800af2e:	4842      	ldr	r0, [pc, #264]	; (800b038 <tcp_output+0x2d8>)
 800af30:	f009 ff22 	bl	8014d78 <iprintf>
 800af34:	e747      	b.n	800adc6 <tcp_output+0x66>
 800af36:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 800af38:	7fa3      	ldrb	r3, [r4, #30]
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }
#if TCP_OVERSIZE
  if (pcb->unsent == NULL) {
 800af3a:	2a00      	cmp	r2, #0
 800af3c:	d030      	beq.n	800afa0 <tcp_output+0x240>
    /* last unsent has been removed, reset unsent_oversize */
    pcb->unsent_oversize = 0;
  }
#endif /* TCP_OVERSIZE */

  pcb->flags &= ~TF_NAGLEMEMERR;
 800af3e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800af42:	77a3      	strb	r3, [r4, #30]
  return ERR_OK;
}
 800af44:	2000      	movs	r0, #0
 800af46:	b003      	add	sp, #12
 800af48:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
     return tcp_send_empty_ack(pcb);
  }

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
 800af4c:	6f27      	ldr	r7, [r4, #112]	; 0x70
  if (useg != NULL) {
 800af4e:	b90f      	cbnz	r7, 800af54 <tcp_output+0x1f4>
 800af50:	e735      	b.n	800adbe <tcp_output+0x5e>
 800af52:	461f      	mov	r7, r3
    for (; useg->next != NULL; useg = useg->next);
 800af54:	683b      	ldr	r3, [r7, #0]
 800af56:	2b00      	cmp	r3, #0
 800af58:	d1fb      	bne.n	800af52 <tcp_output+0x1f2>
 800af5a:	e730      	b.n	800adbe <tcp_output+0x5e>
     packets, so ignore it here */
  opts = (u32_t *)(void *)(seg->tcphdr + 1);
  if (seg->flags & TF_SEG_OPTS_MSS) {
    u16_t mss;
#if TCP_CALCULATE_EFF_SEND_MSS
    mss = tcp_eff_send_mss(TCP_MSS, &pcb->remote_ip);
 800af5c:	4649      	mov	r1, r9
 800af5e:	f240 50b4 	movw	r0, #1460	; 0x5b4

  pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;

  /* Add any requested options.  NB MSS option is only set on SYN
     packets, so ignore it here */
  opts = (u32_t *)(void *)(seg->tcphdr + 1);
 800af62:	68ee      	ldr	r6, [r5, #12]
  if (seg->flags & TF_SEG_OPTS_MSS) {
    u16_t mss;
#if TCP_CALCULATE_EFF_SEND_MSS
    mss = tcp_eff_send_mss(TCP_MSS, &pcb->remote_ip);
 800af64:	f7ff fa56 	bl	800a414 <tcp_eff_send_mss>
#else /* TCP_CALCULATE_EFF_SEND_MSS */
    mss = TCP_MSS;
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
    *opts = TCP_BUILD_MSS_OPTION(mss);
 800af68:	f040 7001 	orr.w	r0, r0, #33816576	; 0x2040000
 800af6c:	f002 fe1e 	bl	800dbac <lwip_htonl>
  }
#endif

  /* Set retransmission timer running if it is not currently enabled 
     This must be set before checking the route. */
  if (pcb->rtime == -1) {
 800af70:	f9b4 3034 	ldrsh.w	r3, [r4, #52]	; 0x34
#if TCP_CALCULATE_EFF_SEND_MSS
    mss = tcp_eff_send_mss(TCP_MSS, &pcb->remote_ip);
#else /* TCP_CALCULATE_EFF_SEND_MSS */
    mss = TCP_MSS;
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
    *opts = TCP_BUILD_MSS_OPTION(mss);
 800af74:	6170      	str	r0, [r6, #20]
  }
#endif

  /* Set retransmission timer running if it is not currently enabled 
     This must be set before checking the route. */
  if (pcb->rtime == -1) {
 800af76:	3301      	adds	r3, #1
 800af78:	f47f af5f 	bne.w	800ae3a <tcp_output+0xda>
    pcb->rtime = 0;
 800af7c:	2300      	movs	r3, #0
 800af7e:	86a3      	strh	r3, [r4, #52]	; 0x34
 800af80:	e75b      	b.n	800ae3a <tcp_output+0xda>
    }
    ip_addr_copy(pcb->local_ip, netif->ip_addr);
  }

  if (pcb->rttest == 0) {
    pcb->rttest = tcp_ticks;
 800af82:	4a2e      	ldr	r2, [pc, #184]	; (800b03c <tcp_output+0x2dc>)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
 800af84:	68eb      	ldr	r3, [r5, #12]
    }
    ip_addr_copy(pcb->local_ip, netif->ip_addr);
  }

  if (pcb->rttest == 0) {
    pcb->rttest = tcp_ticks;
 800af86:	6812      	ldr	r2, [r2, #0]
 800af88:	63a2      	str	r2, [r4, #56]	; 0x38
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
 800af8a:	6858      	ldr	r0, [r3, #4]
 800af8c:	f002 fe0c 	bl	800dba8 <lwip_ntohl>
 800af90:	63e0      	str	r0, [r4, #60]	; 0x3c
 800af92:	e75e      	b.n	800ae52 <tcp_output+0xf2>
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
      seg->next = NULL;
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
        pcb->unacked = seg;
 800af94:	6725      	str	r5, [r4, #112]	; 0x70
 800af96:	462f      	mov	r7, r5
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
 800af98:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
 800af9a:	2d00      	cmp	r5, #0
 800af9c:	d1b2      	bne.n	800af04 <tcp_output+0x1a4>
 800af9e:	7fa3      	ldrb	r3, [r4, #30]
    seg = pcb->unsent;
  }
#if TCP_OVERSIZE
  if (pcb->unsent == NULL) {
    /* last unsent has been removed, reset unsent_oversize */
    pcb->unsent_oversize = 0;
 800afa0:	2200      	movs	r2, #0
 800afa2:	f8a4 206a 	strh.w	r2, [r4, #106]	; 0x6a
 800afa6:	e7ca      	b.n	800af3e <tcp_output+0x1de>
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
          while (*cur_seg &&
 800afa8:	6f23      	ldr	r3, [r4, #112]	; 0x70
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
 800afaa:	f104 0970 	add.w	r9, r4, #112	; 0x70
          while (*cur_seg &&
 800afae:	b92b      	cbnz	r3, 800afbc <tcp_output+0x25c>
 800afb0:	e012      	b.n	800afd8 <tcp_output+0x278>
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
              cur_seg = &((*cur_seg)->next );
 800afb2:	f8d9 9000 	ldr.w	r9, [r9]
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
          while (*cur_seg &&
 800afb6:	f8d9 3000 	ldr.w	r3, [r9]
 800afba:	b16b      	cbz	r3, 800afd8 <tcp_output+0x278>
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
 800afbc:	68db      	ldr	r3, [r3, #12]
 800afbe:	6858      	ldr	r0, [r3, #4]
 800afc0:	f002 fdf2 	bl	800dba8 <lwip_ntohl>
 800afc4:	68eb      	ldr	r3, [r5, #12]
 800afc6:	4606      	mov	r6, r0
 800afc8:	6858      	ldr	r0, [r3, #4]
 800afca:	f002 fded 	bl	800dba8 <lwip_ntohl>
         * of the unacked queue, but rather somewhere before it. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))) {
          /* add segment to before tail of unacked list, keeping the list sorted */
          struct tcp_seg **cur_seg = &(pcb->unacked);
          while (*cur_seg &&
 800afce:	1a30      	subs	r0, r6, r0
 800afd0:	2800      	cmp	r0, #0
 800afd2:	dbee      	blt.n	800afb2 <tcp_output+0x252>
 800afd4:	f8d9 3000 	ldr.w	r3, [r9]
            TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
              cur_seg = &((*cur_seg)->next );
          }
          seg->next = (*cur_seg);
 800afd8:	602b      	str	r3, [r5, #0]
          (*cur_seg) = seg;
 800afda:	f8c9 5000 	str.w	r5, [r9]
 800afde:	e78e      	b.n	800aefe <tcp_output+0x19e>
          useg = useg->next;
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
 800afe0:	4628      	mov	r0, r5
 800afe2:	f7fe fc3d 	bl	8009860 <tcp_seg_free>
 800afe6:	e78a      	b.n	800aefe <tcp_output+0x19e>
     * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_write/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
 800afe8:	8910      	ldrh	r0, [r2, #8]
 800afea:	8ee1      	ldrh	r1, [r4, #54]	; 0x36
 800afec:	4288      	cmp	r0, r1
 800afee:	f4bf aef8 	bcs.w	800ade2 <tcp_output+0x82>
 800aff2:	f8b4 1066 	ldrh.w	r1, [r4, #102]	; 0x66
 800aff6:	2900      	cmp	r1, #0
 800aff8:	f43f aef3 	beq.w	800ade2 <tcp_output+0x82>
 800affc:	f8b4 1068 	ldrh.w	r1, [r4, #104]	; 0x68
 800b000:	2917      	cmp	r1, #23
 800b002:	f63f aeee 	bhi.w	800ade2 <tcp_output+0x82>
 800b006:	f013 0fa0 	tst.w	r3, #160	; 0xa0
 800b00a:	f47f aeea 	bne.w	800ade2 <tcp_output+0x82>
 800b00e:	e794      	b.n	800af3a <tcp_output+0x1da>
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
     return tcp_send_empty_ack(pcb);
 800b010:	4620      	mov	r0, r4
  }
#endif /* TCP_OVERSIZE */

  pcb->flags &= ~TF_NAGLEMEMERR;
  return ERR_OK;
}
 800b012:	b003      	add	sp, #12
 800b014:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
     return tcp_send_empty_ack(pcb);
 800b018:	f7ff be74 	b.w	800ad04 <tcp_send_empty_ack>
#if TCP_CWND_DEBUG
  s16_t i = 0;
#endif /* TCP_CWND_DEBUG */

  /* pcb->state LISTEN not allowed here */
  LWIP_ASSERT("don't call tcp_output for listen-pcbs",
 800b01c:	4b04      	ldr	r3, [pc, #16]	; (800b030 <tcp_output+0x2d0>)
 800b01e:	f44f 7263 	mov.w	r2, #908	; 0x38c
 800b022:	4907      	ldr	r1, [pc, #28]	; (800b040 <tcp_output+0x2e0>)
 800b024:	4804      	ldr	r0, [pc, #16]	; (800b038 <tcp_output+0x2d8>)
 800b026:	f009 fea7 	bl	8014d78 <iprintf>
 800b02a:	e6a1      	b.n	800ad70 <tcp_output+0x10>
 800b02c:	20016ff4 	.word	0x20016ff4
 800b030:	08016aa0 	.word	0x08016aa0
 800b034:	08016dd0 	.word	0x08016dd0
 800b038:	0801660c 	.word	0x0801660c
 800b03c:	2000f044 	.word	0x2000f044
 800b040:	08016da8 	.word	0x08016da8

0800b044 <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  ip_addr_t *local_ip, ip_addr_t *remote_ip,
  u16_t local_port, u16_t remote_port)
{
 800b044:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800b048:	4681      	mov	r9, r0
 800b04a:	b082      	sub	sp, #8
 800b04c:	460e      	mov	r6, r1
 800b04e:	4617      	mov	r7, r2
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
 800b050:	2114      	movs	r1, #20
 800b052:	2200      	movs	r2, #0
 800b054:	2001      	movs	r0, #1
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  ip_addr_t *local_ip, ip_addr_t *remote_ip,
  u16_t local_port, u16_t remote_port)
{
 800b056:	4698      	mov	r8, r3
 800b058:	f8bd 4028 	ldrh.w	r4, [sp, #40]	; 0x28
 800b05c:	f8bd a02c 	ldrh.w	sl, [sp, #44]	; 0x2c
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
 800b060:	f005 f83a 	bl	80100d8 <pbuf_alloc>
  if (p == NULL) {
 800b064:	2800      	cmp	r0, #0
 800b066:	d042      	beq.n	800b0ee <tcp_rst+0xaa>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
 800b068:	8943      	ldrh	r3, [r0, #10]
 800b06a:	4605      	mov	r5, r0
 800b06c:	2b13      	cmp	r3, #19
 800b06e:	d936      	bls.n	800b0de <tcp_rst+0x9a>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = (struct tcp_hdr *)p->payload;
  tcphdr->src = htons(local_port);
 800b070:	4620      	mov	r0, r4
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = (struct tcp_hdr *)p->payload;
 800b072:	686c      	ldr	r4, [r5, #4]
  tcphdr->src = htons(local_port);
 800b074:	f002 fd90 	bl	800db98 <lwip_htons>
 800b078:	8020      	strh	r0, [r4, #0]
  tcphdr->dest = htons(remote_port);
 800b07a:	4650      	mov	r0, sl
 800b07c:	f002 fd8c 	bl	800db98 <lwip_htons>
 800b080:	8060      	strh	r0, [r4, #2]
  tcphdr->seqno = htonl(seqno);
 800b082:	4648      	mov	r0, r9
 800b084:	f002 fd92 	bl	800dbac <lwip_htonl>
 800b088:	6060      	str	r0, [r4, #4]
  tcphdr->ackno = htonl(ackno);
 800b08a:	4630      	mov	r0, r6
 800b08c:	f002 fd8e 	bl	800dbac <lwip_htonl>
 800b090:	60a0      	str	r0, [r4, #8]
  TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
 800b092:	f245 0014 	movw	r0, #20500	; 0x5014
 800b096:	f002 fd7f 	bl	800db98 <lwip_htons>
  tcphdr->wnd = PP_HTONS(TCP_WND);
  tcphdr->chksum = 0;
  tcphdr->urgp = 0;

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
 800b09a:	892a      	ldrh	r2, [r5, #8]
  tcphdr->src = htons(local_port);
  tcphdr->dest = htons(remote_port);
  tcphdr->seqno = htonl(seqno);
  tcphdr->ackno = htonl(ackno);
  TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
  tcphdr->wnd = PP_HTONS(TCP_WND);
 800b09c:	2600      	movs	r6, #0
 800b09e:	210b      	movs	r1, #11
 800b0a0:	2368      	movs	r3, #104	; 0x68
  tcphdr = (struct tcp_hdr *)p->payload;
  tcphdr->src = htons(local_port);
  tcphdr->dest = htons(remote_port);
  tcphdr->seqno = htonl(seqno);
  tcphdr->ackno = htonl(ackno);
  TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
 800b0a2:	81a0      	strh	r0, [r4, #12]
  tcphdr->wnd = PP_HTONS(TCP_WND);
 800b0a4:	73a1      	strb	r1, [r4, #14]
 800b0a6:	73e3      	strb	r3, [r4, #15]
  tcphdr->chksum = 0;
 800b0a8:	7426      	strb	r6, [r4, #16]
 800b0aa:	7466      	strb	r6, [r4, #17]
  tcphdr->urgp = 0;
 800b0ac:	74a6      	strb	r6, [r4, #18]
 800b0ae:	74e6      	strb	r6, [r4, #19]

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
 800b0b0:	4639      	mov	r1, r7
 800b0b2:	9200      	str	r2, [sp, #0]
 800b0b4:	2306      	movs	r3, #6
 800b0b6:	4642      	mov	r2, r8
 800b0b8:	4628      	mov	r0, r5
 800b0ba:	f003 fb91 	bl	800e7e0 <inet_chksum_pseudo>
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
 800b0be:	2306      	movs	r3, #6
  tcphdr->wnd = PP_HTONS(TCP_WND);
  tcphdr->chksum = 0;
  tcphdr->urgp = 0;

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
 800b0c0:	8220      	strh	r0, [r4, #16]
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
 800b0c2:	4642      	mov	r2, r8
 800b0c4:	9301      	str	r3, [sp, #4]
 800b0c6:	9600      	str	r6, [sp, #0]
 800b0c8:	4639      	mov	r1, r7
 800b0ca:	23ff      	movs	r3, #255	; 0xff
 800b0cc:	4628      	mov	r0, r5
 800b0ce:	f003 fde7 	bl	800eca0 <ip_output>
  pbuf_free(p);
 800b0d2:	4628      	mov	r0, r5
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
 800b0d4:	b002      	add	sp, #8
 800b0d6:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  pbuf_free(p);
 800b0da:	f004 bfa5 	b.w	8010028 <pbuf_free>
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  if (p == NULL) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
 800b0de:	4b05      	ldr	r3, [pc, #20]	; (800b0f4 <tcp_rst+0xb0>)
 800b0e0:	f240 42b7 	movw	r2, #1207	; 0x4b7
 800b0e4:	4904      	ldr	r1, [pc, #16]	; (800b0f8 <tcp_rst+0xb4>)
 800b0e6:	4805      	ldr	r0, [pc, #20]	; (800b0fc <tcp_rst+0xb8>)
 800b0e8:	f009 fe46 	bl	8014d78 <iprintf>
 800b0ec:	e7c0      	b.n	800b070 <tcp_rst+0x2c>
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  pbuf_free(p);
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
 800b0ee:	b002      	add	sp, #8
 800b0f0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800b0f4:	08016aa0 	.word	0x08016aa0
 800b0f8:	08016ac8 	.word	0x08016ac8
 800b0fc:	0801660c 	.word	0x0801660c

0800b100 <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
 800b100:	b430      	push	{r4, r5}
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
 800b102:	6f04      	ldr	r4, [r0, #112]	; 0x70
 800b104:	b1a4      	cbz	r4, 800b130 <tcp_rexmit_rto+0x30>
 800b106:	4601      	mov	r1, r0
 800b108:	4622      	mov	r2, r4
 800b10a:	e000      	b.n	800b10e <tcp_rexmit_rto+0xe>
 800b10c:	461a      	mov	r2, r3
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
 800b10e:	6813      	ldr	r3, [r2, #0]
 800b110:	2b00      	cmp	r3, #0
 800b112:	d1fb      	bne.n	800b10c <tcp_rexmit_rto+0xc>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
 800b114:	6ecd      	ldr	r5, [r1, #108]	; 0x6c

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;

  /* Do the actual retransmission */
  tcp_output(pcb);
 800b116:	4608      	mov	r0, r1
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
 800b118:	6015      	str	r5, [r2, #0]
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  /* last unsent hasn't changed, no need to reset unsent_oversize */

  /* increment number of retransmissions */
  ++pcb->nrtx;
 800b11a:	f891 2046 	ldrb.w	r2, [r1, #70]	; 0x46
  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
 800b11e:	66cc      	str	r4, [r1, #108]	; 0x6c
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  /* last unsent hasn't changed, no need to reset unsent_oversize */

  /* increment number of retransmissions */
  ++pcb->nrtx;
 800b120:	3201      	adds	r2, #1
 800b122:	f881 2046 	strb.w	r2, [r1, #70]	; 0x46
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  /* unacked queue is now empty */
  pcb->unacked = NULL;
 800b126:	670b      	str	r3, [r1, #112]	; 0x70

  /* increment number of retransmissions */
  ++pcb->nrtx;

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
 800b128:	638b      	str	r3, [r1, #56]	; 0x38

  /* Do the actual retransmission */
  tcp_output(pcb);
}
 800b12a:	bc30      	pop	{r4, r5}

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;

  /* Do the actual retransmission */
  tcp_output(pcb);
 800b12c:	f7ff be18 	b.w	800ad60 <tcp_output>
}
 800b130:	bc30      	pop	{r4, r5}
 800b132:	4770      	bx	lr

0800b134 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
 800b134:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  struct tcp_seg *seg;
  struct tcp_seg **cur_seg;

  if (pcb->unacked == NULL) {
 800b136:	6f06      	ldr	r6, [r0, #112]	; 0x70
 800b138:	b316      	cbz	r6, 800b180 <tcp_rexmit+0x4c>
  }

  /* Move the first unacked segment to the unsent queue */
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;
 800b13a:	6832      	ldr	r2, [r6, #0]

  cur_seg = &(pcb->unsent);
  while (*cur_seg &&
 800b13c:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 800b13e:	4607      	mov	r7, r0
  }

  /* Move the first unacked segment to the unsent queue */
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;
 800b140:	6702      	str	r2, [r0, #112]	; 0x70

  cur_seg = &(pcb->unsent);
 800b142:	f100 056c 	add.w	r5, r0, #108	; 0x6c
  while (*cur_seg &&
 800b146:	b91b      	cbnz	r3, 800b150 <tcp_rexmit+0x1c>
 800b148:	e00f      	b.n	800b16a <tcp_rexmit+0x36>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
      cur_seg = &((*cur_seg)->next );
 800b14a:	682d      	ldr	r5, [r5, #0]
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;

  cur_seg = &(pcb->unsent);
  while (*cur_seg &&
 800b14c:	682b      	ldr	r3, [r5, #0]
 800b14e:	b163      	cbz	r3, 800b16a <tcp_rexmit+0x36>
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
 800b150:	68db      	ldr	r3, [r3, #12]
 800b152:	6858      	ldr	r0, [r3, #4]
 800b154:	f002 fd28 	bl	800dba8 <lwip_ntohl>
 800b158:	68f3      	ldr	r3, [r6, #12]
 800b15a:	4604      	mov	r4, r0
 800b15c:	6858      	ldr	r0, [r3, #4]
 800b15e:	f002 fd23 	bl	800dba8 <lwip_ntohl>
  /* Keep the unsent queue sorted. */
  seg = pcb->unacked;
  pcb->unacked = seg->next;

  cur_seg = &(pcb->unsent);
  while (*cur_seg &&
 800b162:	1a20      	subs	r0, r4, r0
 800b164:	2800      	cmp	r0, #0
 800b166:	dbf0      	blt.n	800b14a <tcp_rexmit+0x16>
 800b168:	682b      	ldr	r3, [r5, #0]
    TCP_SEQ_LT(ntohl((*cur_seg)->tcphdr->seqno), ntohl(seg->tcphdr->seqno))) {
      cur_seg = &((*cur_seg)->next );
  }
  seg->next = *cur_seg;
 800b16a:	6033      	str	r3, [r6, #0]
  *cur_seg = seg;
 800b16c:	602e      	str	r6, [r5, #0]
#if TCP_OVERSIZE
  if (seg->next == NULL) {
 800b16e:	6833      	ldr	r3, [r6, #0]
 800b170:	b13b      	cbz	r3, 800b182 <tcp_rexmit+0x4e>
    /* the retransmitted segment is last in unsent, so reset unsent_oversize */
    pcb->unsent_oversize = 0;
  }
#endif /* TCP_OVERSIZE */

  ++pcb->nrtx;
 800b172:	f897 3046 	ldrb.w	r3, [r7, #70]	; 0x46

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
 800b176:	2200      	movs	r2, #0
    /* the retransmitted segment is last in unsent, so reset unsent_oversize */
    pcb->unsent_oversize = 0;
  }
#endif /* TCP_OVERSIZE */

  ++pcb->nrtx;
 800b178:	3301      	adds	r3, #1
 800b17a:	f887 3046 	strb.w	r3, [r7, #70]	; 0x46

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
 800b17e:	63ba      	str	r2, [r7, #56]	; 0x38
 800b180:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  seg->next = *cur_seg;
  *cur_seg = seg;
#if TCP_OVERSIZE
  if (seg->next == NULL) {
    /* the retransmitted segment is last in unsent, so reset unsent_oversize */
    pcb->unsent_oversize = 0;
 800b182:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a
 800b186:	e7f4      	b.n	800b172 <tcp_rexmit+0x3e>

0800b188 <tcp_rexmit_fast>:
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void 
tcp_rexmit_fast(struct tcp_pcb *pcb)
{
  if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
 800b188:	6f02      	ldr	r2, [r0, #112]	; 0x70
 800b18a:	b112      	cbz	r2, 800b192 <tcp_rexmit_fast+0xa>
 800b18c:	7f82      	ldrb	r2, [r0, #30]
 800b18e:	0752      	lsls	r2, r2, #29
 800b190:	d500      	bpl.n	800b194 <tcp_rexmit_fast+0xc>
 800b192:	4770      	bx	lr
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void 
tcp_rexmit_fast(struct tcp_pcb *pcb)
{
 800b194:	b510      	push	{r4, lr}
 800b196:	4604      	mov	r4, r0
    LWIP_DEBUGF(TCP_FR_DEBUG, 
                ("tcp_receive: dupacks %"U16_F" (%"U32_F
                 "), fast retransmit %"U32_F"\n",
                 (u16_t)pcb->dupacks, pcb->lastack,
                 ntohl(pcb->unacked->tcphdr->seqno)));
    tcp_rexmit(pcb);
 800b198:	f7ff ffcc 	bl	800b134 <tcp_rexmit>

    /* Set ssthresh to half of the minimum of the current
     * cwnd and the advertised window */
    if (pcb->cwnd > pcb->snd_wnd) {
 800b19c:	f8b4 2060 	ldrh.w	r2, [r4, #96]	; 0x60
 800b1a0:	f8b4 304c 	ldrh.w	r3, [r4, #76]	; 0x4c
    } else {
      pcb->ssthresh = pcb->cwnd / 2;
    }
    
    /* The minimum value for ssthresh should be 2 MSS */
    if (pcb->ssthresh < 2*pcb->mss) {
 800b1a4:	8ee0      	ldrh	r0, [r4, #54]	; 0x36
                 ntohl(pcb->unacked->tcphdr->seqno)));
    tcp_rexmit(pcb);

    /* Set ssthresh to half of the minimum of the current
     * cwnd and the advertised window */
    if (pcb->cwnd > pcb->snd_wnd) {
 800b1a6:	4293      	cmp	r3, r2
      pcb->ssthresh = pcb->snd_wnd / 2;
    } else {
      pcb->ssthresh = pcb->cwnd / 2;
 800b1a8:	bf94      	ite	ls
 800b1aa:	085a      	lsrls	r2, r3, #1
    tcp_rexmit(pcb);

    /* Set ssthresh to half of the minimum of the current
     * cwnd and the advertised window */
    if (pcb->cwnd > pcb->snd_wnd) {
      pcb->ssthresh = pcb->snd_wnd / 2;
 800b1ac:	0852      	lsrhi	r2, r2, #1
    } else {
      pcb->ssthresh = pcb->cwnd / 2;
    }
    
    /* The minimum value for ssthresh should be 2 MSS */
    if (pcb->ssthresh < 2*pcb->mss) {
 800b1ae:	0043      	lsls	r3, r0, #1
 800b1b0:	429a      	cmp	r2, r3
                   pcb->ssthresh, 2*pcb->mss));
      pcb->ssthresh = 2*pcb->mss;
    }
    
    pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
    pcb->flags |= TF_INFR;
 800b1b2:	7fa1      	ldrb	r1, [r4, #30]
    /* Set ssthresh to half of the minimum of the current
     * cwnd and the advertised window */
    if (pcb->cwnd > pcb->snd_wnd) {
      pcb->ssthresh = pcb->snd_wnd / 2;
    } else {
      pcb->ssthresh = pcb->cwnd / 2;
 800b1b4:	f8a4 204e 	strh.w	r2, [r4, #78]	; 0x4e
    if (pcb->ssthresh < 2*pcb->mss) {
      LWIP_DEBUGF(TCP_FR_DEBUG, 
                  ("tcp_receive: The minimum value for ssthresh %"U16_F
                   " should be min 2 mss %"U16_F"...\n",
                   pcb->ssthresh, 2*pcb->mss));
      pcb->ssthresh = 2*pcb->mss;
 800b1b8:	bfb8      	it	lt
 800b1ba:	b29a      	uxthlt	r2, r3
    }
    
    pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
 800b1bc:	4403      	add	r3, r0
 800b1be:	4413      	add	r3, r2
    if (pcb->ssthresh < 2*pcb->mss) {
      LWIP_DEBUGF(TCP_FR_DEBUG, 
                  ("tcp_receive: The minimum value for ssthresh %"U16_F
                   " should be min 2 mss %"U16_F"...\n",
                   pcb->ssthresh, 2*pcb->mss));
      pcb->ssthresh = 2*pcb->mss;
 800b1c0:	bfb8      	it	lt
 800b1c2:	f8a4 204e 	strhlt.w	r2, [r4, #78]	; 0x4e
    }
    
    pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
    pcb->flags |= TF_INFR;
 800b1c6:	f041 0204 	orr.w	r2, r1, #4
 800b1ca:	77a2      	strb	r2, [r4, #30]
                   " should be min 2 mss %"U16_F"...\n",
                   pcb->ssthresh, 2*pcb->mss));
      pcb->ssthresh = 2*pcb->mss;
    }
    
    pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
 800b1cc:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
 800b1d0:	bd10      	pop	{r4, pc}
 800b1d2:	bf00      	nop

0800b1d4 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
 800b1d4:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b1d6:	4604      	mov	r4, r0
                          ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
 800b1d8:	6d00      	ldr	r0, [r0, #80]	; 0x50
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
 800b1da:	b083      	sub	sp, #12
                          ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = tcp_output_alloc_header(pcb, 0, 0, htonl(pcb->snd_nxt - 1));
 800b1dc:	3801      	subs	r0, #1
 800b1de:	f002 fce5 	bl	800dbac <lwip_htonl>
 800b1e2:	2100      	movs	r1, #0
 800b1e4:	4602      	mov	r2, r0
 800b1e6:	4620      	mov	r0, r4
 800b1e8:	f7ff f9c6 	bl	800a578 <tcp_output_alloc_header.constprop.1>
  if(p == NULL) {
 800b1ec:	b1d0      	cbz	r0, 800b224 <tcp_keepalive+0x50>
    return;
  }
  tcphdr = (struct tcp_hdr *)p->payload;

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
 800b1ee:	8903      	ldrh	r3, [r0, #8]
 800b1f0:	1d26      	adds	r6, r4, #4
  if(p == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  tcphdr = (struct tcp_hdr *)p->payload;
 800b1f2:	6847      	ldr	r7, [r0, #4]

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
 800b1f4:	4632      	mov	r2, r6
 800b1f6:	9300      	str	r3, [sp, #0]
 800b1f8:	4621      	mov	r1, r4
 800b1fa:	2306      	movs	r3, #6
 800b1fc:	4605      	mov	r5, r0
 800b1fe:	f003 faef 	bl	800e7e0 <inet_chksum_pseudo>
 800b202:	8238      	strh	r0, [r7, #16]
  /* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
 800b204:	2706      	movs	r7, #6
 800b206:	2000      	movs	r0, #0
 800b208:	7aa3      	ldrb	r3, [r4, #10]
 800b20a:	4632      	mov	r2, r6
 800b20c:	e88d 0081 	stmia.w	sp, {r0, r7}
 800b210:	4621      	mov	r1, r4
 800b212:	4628      	mov	r0, r5
 800b214:	f003 fd44 	bl	800eca0 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
 800b218:	4628      	mov	r0, r5

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
 800b21a:	b003      	add	sp, #12
 800b21c:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
 800b220:	f004 bf02 	b.w	8010028 <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
 800b224:	b003      	add	sp, #12
 800b226:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800b228 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
 800b228:	b5f0      	push	{r4, r5, r6, r7, lr}
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
 800b22a:	6f06      	ldr	r6, [r0, #112]	; 0x70
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
 800b22c:	b083      	sub	sp, #12
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;

  if(seg == NULL) {
 800b22e:	2e00      	cmp	r6, #0
 800b230:	d048      	beq.n	800b2c4 <tcp_zero_window_probe+0x9c>
  }
  if(seg == NULL) {
    return;
  }

  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
 800b232:	68f3      	ldr	r3, [r6, #12]
 800b234:	4604      	mov	r4, r0
 800b236:	8998      	ldrh	r0, [r3, #12]
 800b238:	f002 fcb2 	bl	800dba0 <lwip_ntohs>
 800b23c:	07c3      	lsls	r3, r0, #31
 800b23e:	d514      	bpl.n	800b26a <tcp_zero_window_probe+0x42>
 800b240:	8931      	ldrh	r1, [r6, #8]
 800b242:	b991      	cbnz	r1, 800b26a <tcp_zero_window_probe+0x42>
  /* we want to send one seqno: either FIN or data (no options) */
  len = is_fin ? 0 : 1;

  p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
 800b244:	68f3      	ldr	r3, [r6, #12]
 800b246:	4620      	mov	r0, r4
 800b248:	685a      	ldr	r2, [r3, #4]
 800b24a:	f7ff f995 	bl	800a578 <tcp_output_alloc_header.constprop.1>
  if(p == NULL) {
 800b24e:	4605      	mov	r5, r0
 800b250:	2800      	cmp	r0, #0
 800b252:	d03a      	beq.n	800b2ca <tcp_zero_window_probe+0xa2>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  tcphdr = (struct tcp_hdr *)p->payload;
 800b254:	686e      	ldr	r6, [r5, #4]

  if (is_fin) {
    /* FIN segment, no data */
    TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
 800b256:	2011      	movs	r0, #17
 800b258:	f9b6 700c 	ldrsh.w	r7, [r6, #12]
 800b25c:	f002 fc9c 	bl	800db98 <lwip_htons>
 800b260:	f427 577c 	bic.w	r7, r7, #16128	; 0x3f00
 800b264:	4338      	orrs	r0, r7
 800b266:	81b0      	strh	r0, [r6, #12]
 800b268:	e012      	b.n	800b290 <tcp_zero_window_probe+0x68>

  is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
  /* we want to send one seqno: either FIN or data (no options) */
  len = is_fin ? 0 : 1;

  p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
 800b26a:	68f3      	ldr	r3, [r6, #12]
 800b26c:	2101      	movs	r1, #1
 800b26e:	685a      	ldr	r2, [r3, #4]
 800b270:	4620      	mov	r0, r4
 800b272:	f7ff f981 	bl	800a578 <tcp_output_alloc_header.constprop.1>
  if(p == NULL) {
 800b276:	4605      	mov	r5, r0
 800b278:	b338      	cbz	r0, 800b2ca <tcp_zero_window_probe+0xa2>
    /* Data segment, copy in one byte from the head of the unacked queue */
    char *d = ((char *)p->payload + TCP_HLEN);
    /* Depending on whether the segment has already been sent (unacked) or not
       (unsent), seg->p->payload points to the IP header or TCP header.
       Ensure we copy the first TCP data byte: */
    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
 800b27a:	6870      	ldr	r0, [r6, #4]
 800b27c:	8932      	ldrh	r2, [r6, #8]
 800b27e:	8903      	ldrh	r3, [r0, #8]
  p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
  if(p == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  tcphdr = (struct tcp_hdr *)p->payload;
 800b280:	686e      	ldr	r6, [r5, #4]
    /* Data segment, copy in one byte from the head of the unacked queue */
    char *d = ((char *)p->payload + TCP_HLEN);
    /* Depending on whether the segment has already been sent (unacked) or not
       (unsent), seg->p->payload points to the IP header or TCP header.
       Ensure we copy the first TCP data byte: */
    pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
 800b282:	1a9b      	subs	r3, r3, r2
 800b284:	b29b      	uxth	r3, r3
 800b286:	f106 0114 	add.w	r1, r6, #20
 800b28a:	2201      	movs	r2, #1
 800b28c:	f005 f9ae 	bl	80105ec <pbuf_copy_partial>
  }

#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
 800b290:	892b      	ldrh	r3, [r5, #8]
 800b292:	1d27      	adds	r7, r4, #4
 800b294:	9300      	str	r3, [sp, #0]
 800b296:	463a      	mov	r2, r7
 800b298:	4621      	mov	r1, r4
 800b29a:	2306      	movs	r3, #6
 800b29c:	4628      	mov	r0, r5
 800b29e:	f003 fa9f 	bl	800e7e0 <inet_chksum_pseudo>
 800b2a2:	8230      	strh	r0, [r6, #16]
  /* Send output to IP */
#if LWIP_NETIF_HWADDRHINT
  ip_output_hinted(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP,
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
 800b2a4:	2606      	movs	r6, #6
 800b2a6:	2000      	movs	r0, #0
 800b2a8:	7aa3      	ldrb	r3, [r4, #10]
 800b2aa:	463a      	mov	r2, r7
 800b2ac:	e88d 0041 	stmia.w	sp, {r0, r6}
 800b2b0:	4621      	mov	r1, r4
 800b2b2:	4628      	mov	r0, r5
 800b2b4:	f003 fcf4 	bl	800eca0 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
 800b2b8:	4628      	mov	r0, r5

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
 800b2ba:	b003      	add	sp, #12
 800b2bc:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    &(pcb->addr_hint));
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
 800b2c0:	f004 beb2 	b.w	8010028 <pbuf_free>
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;

  if(seg == NULL) {
    seg = pcb->unsent;
 800b2c4:	6ec6      	ldr	r6, [r0, #108]	; 0x6c
  }
  if(seg == NULL) {
 800b2c6:	2e00      	cmp	r6, #0
 800b2c8:	d1b3      	bne.n	800b232 <tcp_zero_window_probe+0xa>
  pbuf_free(p);

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
 800b2ca:	b003      	add	sp, #12
 800b2cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800b2ce:	bf00      	nop

0800b2d0 <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
 800b2d0:	b500      	push	{lr}
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

  if (tcpip_init_done != NULL) {
 800b2d2:	4a27      	ldr	r2, [pc, #156]	; (800b370 <tcpip_thread+0xa0>)
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
 800b2d4:	b083      	sub	sp, #12
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

  if (tcpip_init_done != NULL) {
 800b2d6:	6813      	ldr	r3, [r2, #0]
 800b2d8:	b10b      	cbz	r3, 800b2de <tcpip_thread+0xe>
    tcpip_init_done(tcpip_init_done_arg);
 800b2da:	6850      	ldr	r0, [r2, #4]
 800b2dc:	4798      	blx	r3
  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    UNLOCK_TCPIP_CORE();
    LWIP_TCPIP_THREAD_ALIVE();
    /* wait for a message, timeouts are processed while waiting */
    sys_timeouts_mbox_fetch(&mbox, (void **)&msg);
 800b2de:	a901      	add	r1, sp, #4
 800b2e0:	4824      	ldr	r0, [pc, #144]	; (800b374 <tcpip_thread+0xa4>)
 800b2e2:	f000 fa31 	bl	800b748 <sys_timeouts_mbox_fetch>
    LOCK_TCPIP_CORE();
    switch (msg->type) {
 800b2e6:	9b01      	ldr	r3, [sp, #4]
 800b2e8:	781a      	ldrb	r2, [r3, #0]
 800b2ea:	2a05      	cmp	r2, #5
 800b2ec:	d836      	bhi.n	800b35c <tcpip_thread+0x8c>
 800b2ee:	e8df f002 	tbb	[pc, r2]
 800b2f2:	2230      	.short	0x2230
 800b2f4:	03070f18 	.word	0x03070f18
      memp_free(MEMP_TCPIP_MSG_API, msg);
      break;

    case TCPIP_MSG_CALLBACK_STATIC:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK_STATIC %p\n", (void *)msg));
      msg->msg.cb.function(msg->msg.cb.ctx);
 800b2f8:	689a      	ldr	r2, [r3, #8]
 800b2fa:	68d8      	ldr	r0, [r3, #12]
 800b2fc:	4790      	blx	r2
      break;
 800b2fe:	e7ee      	b.n	800b2de <tcpip_thread+0xe>
      break;
#endif /* LWIP_TCPIP_TIMEOUT */

    case TCPIP_MSG_CALLBACK:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
      msg->msg.cb.function(msg->msg.cb.ctx);
 800b300:	68d8      	ldr	r0, [r3, #12]
 800b302:	689a      	ldr	r2, [r3, #8]
 800b304:	4790      	blx	r2
      memp_free(MEMP_TCPIP_MSG_API, msg);
 800b306:	9901      	ldr	r1, [sp, #4]
 800b308:	2008      	movs	r0, #8
 800b30a:	f004 fcf7 	bl	800fcfc <memp_free>
      break;
 800b30e:	e7e6      	b.n	800b2de <tcpip_thread+0xe>
      sys_timeout(msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
      memp_free(MEMP_TCPIP_MSG_API, msg);
      break;
    case TCPIP_MSG_UNTIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: UNTIMEOUT %p\n", (void *)msg));
      sys_untimeout(msg->msg.tmo.h, msg->msg.tmo.arg);
 800b310:	6919      	ldr	r1, [r3, #16]
 800b312:	68d8      	ldr	r0, [r3, #12]
 800b314:	f000 f9f4 	bl	800b700 <sys_untimeout>
      memp_free(MEMP_TCPIP_MSG_API, msg);
 800b318:	9901      	ldr	r1, [sp, #4]
 800b31a:	2008      	movs	r0, #8
 800b31c:	f004 fcee 	bl	800fcfc <memp_free>
      break;
 800b320:	e7dd      	b.n	800b2de <tcpip_thread+0xe>
#endif /* LWIP_NETIF_API */

#if LWIP_TCPIP_TIMEOUT
    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));
      sys_timeout(msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
 800b322:	f103 0008 	add.w	r0, r3, #8
 800b326:	c807      	ldmia	r0, {r0, r1, r2}
 800b328:	f000 f93c 	bl	800b5a4 <sys_timeout>
      memp_free(MEMP_TCPIP_MSG_API, msg);
 800b32c:	9901      	ldr	r1, [sp, #4]
 800b32e:	2008      	movs	r0, #8
 800b330:	f004 fce4 	bl	800fcfc <memp_free>
      break;
 800b334:	e7d3      	b.n	800b2de <tcpip_thread+0xe>

#if !LWIP_TCPIP_CORE_LOCKING_INPUT
    case TCPIP_MSG_INPKT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
#if LWIP_ETHERNET
      if (msg->msg.inp.netif->flags & (NETIF_FLAG_ETHARP | NETIF_FLAG_ETHERNET)) {
 800b336:	68d9      	ldr	r1, [r3, #12]
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
 800b338:	6898      	ldr	r0, [r3, #8]

#if !LWIP_TCPIP_CORE_LOCKING_INPUT
    case TCPIP_MSG_INPKT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
#if LWIP_ETHERNET
      if (msg->msg.inp.netif->flags & (NETIF_FLAG_ETHARP | NETIF_FLAG_ETHERNET)) {
 800b33a:	f891 2029 	ldrb.w	r2, [r1, #41]	; 0x29
 800b33e:	f012 0f60 	tst.w	r2, #96	; 0x60
 800b342:	d012      	beq.n	800b36a <tcpip_thread+0x9a>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
 800b344:	f003 f880 	bl	800e448 <ethernet_input>
      } else
#endif /* LWIP_ETHERNET */
      {
        ip_input(msg->msg.inp.p, msg->msg.inp.netif);
      }
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
 800b348:	9901      	ldr	r1, [sp, #4]
 800b34a:	2009      	movs	r0, #9
 800b34c:	f004 fcd6 	bl	800fcfc <memp_free>
      break;
 800b350:	e7c5      	b.n	800b2de <tcpip_thread+0xe>
    LOCK_TCPIP_CORE();
    switch (msg->type) {
#if LWIP_NETCONN
    case TCPIP_MSG_API:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
 800b352:	6898      	ldr	r0, [r3, #8]
 800b354:	6803      	ldr	r3, [r0, #0]
 800b356:	3004      	adds	r0, #4
 800b358:	4798      	blx	r3
      break;
 800b35a:	e7c0      	b.n	800b2de <tcpip_thread+0xe>
      msg->msg.cb.function(msg->msg.cb.ctx);
      break;

    default:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: invalid message: %d\n", msg->type));
      LWIP_ASSERT("tcpip_thread: invalid message", 0);
 800b35c:	4b06      	ldr	r3, [pc, #24]	; (800b378 <tcpip_thread+0xa8>)
 800b35e:	2292      	movs	r2, #146	; 0x92
 800b360:	4906      	ldr	r1, [pc, #24]	; (800b37c <tcpip_thread+0xac>)
 800b362:	4807      	ldr	r0, [pc, #28]	; (800b380 <tcpip_thread+0xb0>)
 800b364:	f009 fd08 	bl	8014d78 <iprintf>
      break;
 800b368:	e7b9      	b.n	800b2de <tcpip_thread+0xe>
      if (msg->msg.inp.netif->flags & (NETIF_FLAG_ETHARP | NETIF_FLAG_ETHERNET)) {
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
      } else
#endif /* LWIP_ETHERNET */
      {
        ip_input(msg->msg.inp.p, msg->msg.inp.netif);
 800b36a:	f003 fb51 	bl	800ea10 <ip_input>
 800b36e:	e7eb      	b.n	800b348 <tcpip_thread+0x78>
 800b370:	200007ac 	.word	0x200007ac
 800b374:	200007b4 	.word	0x200007b4
 800b378:	08016de8 	.word	0x08016de8
 800b37c:	08016df8 	.word	0x08016df8
 800b380:	0801660c 	.word	0x0801660c

0800b384 <pbuf_free_int>:
 */
static void
pbuf_free_int(void *p)
{
  struct pbuf *q = (struct pbuf *)p;
  pbuf_free(q);
 800b384:	f004 be50 	b.w	8010028 <pbuf_free>

0800b388 <tcpip_input>:
 *          NETIF_FLAG_ETHERNET flags)
 * @param inp the network interface on which the packet was received
 */
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
 800b388:	b570      	push	{r4, r5, r6, lr}
 800b38a:	4606      	mov	r6, r0
  UNLOCK_TCPIP_CORE();
  return ret;
#else /* LWIP_TCPIP_CORE_LOCKING_INPUT */
  struct tcpip_msg *msg;

  if (!sys_mbox_valid(&mbox)) {
 800b38c:	4810      	ldr	r0, [pc, #64]	; (800b3d0 <tcpip_input+0x48>)
 *          NETIF_FLAG_ETHERNET flags)
 * @param inp the network interface on which the packet was received
 */
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
 800b38e:	460d      	mov	r5, r1
  UNLOCK_TCPIP_CORE();
  return ret;
#else /* LWIP_TCPIP_CORE_LOCKING_INPUT */
  struct tcpip_msg *msg;

  if (!sys_mbox_valid(&mbox)) {
 800b390:	f007 fe98 	bl	80130c4 <sys_mbox_valid>
 800b394:	b170      	cbz	r0, 800b3b4 <tcpip_input+0x2c>
    return ERR_VAL;
  }
  msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_INPKT);
 800b396:	2009      	movs	r0, #9
 800b398:	f004 fc7a 	bl	800fc90 <memp_malloc>
  if (msg == NULL) {
 800b39c:	4604      	mov	r4, r0
 800b39e:	b160      	cbz	r0, 800b3ba <tcpip_input+0x32>
    return ERR_MEM;
  }

  msg->type = TCPIP_MSG_INPKT;
 800b3a0:	2301      	movs	r3, #1
  msg->msg.inp.p = p;
 800b3a2:	6086      	str	r6, [r0, #8]
  msg->msg.inp.netif = inp;
 800b3a4:	60c5      	str	r5, [r0, #12]
  msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_INPKT);
  if (msg == NULL) {
    return ERR_MEM;
  }

  msg->type = TCPIP_MSG_INPKT;
 800b3a6:	7003      	strb	r3, [r0, #0]
  msg->msg.inp.p = p;
  msg->msg.inp.netif = inp;
  if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {
 800b3a8:	4601      	mov	r1, r0
 800b3aa:	4809      	ldr	r0, [pc, #36]	; (800b3d0 <tcpip_input+0x48>)
 800b3ac:	f007 fe4e 	bl	801304c <sys_mbox_trypost>
 800b3b0:	b930      	cbnz	r0, 800b3c0 <tcpip_input+0x38>
    memp_free(MEMP_TCPIP_MSG_INPKT, msg);
    return ERR_MEM;
  }
  return ERR_OK;
#endif /* LWIP_TCPIP_CORE_LOCKING_INPUT */
}
 800b3b2:	bd70      	pop	{r4, r5, r6, pc}
  return ret;
#else /* LWIP_TCPIP_CORE_LOCKING_INPUT */
  struct tcpip_msg *msg;

  if (!sys_mbox_valid(&mbox)) {
    return ERR_VAL;
 800b3b4:	f06f 0005 	mvn.w	r0, #5
 800b3b8:	bd70      	pop	{r4, r5, r6, pc}
  }
  msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_INPKT);
  if (msg == NULL) {
    return ERR_MEM;
 800b3ba:	f04f 30ff 	mov.w	r0, #4294967295
 800b3be:	e7f8      	b.n	800b3b2 <tcpip_input+0x2a>

  msg->type = TCPIP_MSG_INPKT;
  msg->msg.inp.p = p;
  msg->msg.inp.netif = inp;
  if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {
    memp_free(MEMP_TCPIP_MSG_INPKT, msg);
 800b3c0:	4621      	mov	r1, r4
 800b3c2:	2009      	movs	r0, #9
 800b3c4:	f004 fc9a 	bl	800fcfc <memp_free>
    return ERR_MEM;
 800b3c8:	f04f 30ff 	mov.w	r0, #4294967295
 800b3cc:	bd70      	pop	{r4, r5, r6, pc}
 800b3ce:	bf00      	nop
 800b3d0:	200007b4 	.word	0x200007b4

0800b3d4 <tcpip_callback_with_block>:
 * @param block 1 to block until the request is posted, 0 to non-blocking mode
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_callback_with_block(tcpip_callback_fn function, void *ctx, u8_t block)
{
 800b3d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800b3d6:	4607      	mov	r7, r0
  struct tcpip_msg *msg;

  if (sys_mbox_valid(&mbox)) {
 800b3d8:	4813      	ldr	r0, [pc, #76]	; (800b428 <tcpip_callback_with_block+0x54>)
 * @param block 1 to block until the request is posted, 0 to non-blocking mode
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_callback_with_block(tcpip_callback_fn function, void *ctx, u8_t block)
{
 800b3da:	460e      	mov	r6, r1
 800b3dc:	4615      	mov	r5, r2
  struct tcpip_msg *msg;

  if (sys_mbox_valid(&mbox)) {
 800b3de:	f007 fe71 	bl	80130c4 <sys_mbox_valid>
 800b3e2:	b198      	cbz	r0, 800b40c <tcpip_callback_with_block+0x38>
    msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
 800b3e4:	2008      	movs	r0, #8
 800b3e6:	f004 fc53 	bl	800fc90 <memp_malloc>
    if (msg == NULL) {
 800b3ea:	4604      	mov	r4, r0
 800b3ec:	b1c0      	cbz	r0, 800b420 <tcpip_callback_with_block+0x4c>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_CALLBACK;
 800b3ee:	2304      	movs	r3, #4
    msg->msg.cb.function = function;
 800b3f0:	6087      	str	r7, [r0, #8]
    msg->msg.cb.ctx = ctx;
 800b3f2:	60c6      	str	r6, [r0, #12]
    msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
    if (msg == NULL) {
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_CALLBACK;
 800b3f4:	7003      	strb	r3, [r0, #0]
    msg->msg.cb.function = function;
    msg->msg.cb.ctx = ctx;
    if (block) {
      sys_mbox_post(&mbox, msg);
 800b3f6:	4601      	mov	r1, r0
 800b3f8:	480b      	ldr	r0, [pc, #44]	; (800b428 <tcpip_callback_with_block+0x54>)
    }

    msg->type = TCPIP_MSG_CALLBACK;
    msg->msg.cb.function = function;
    msg->msg.cb.ctx = ctx;
    if (block) {
 800b3fa:	b91d      	cbnz	r5, 800b404 <tcpip_callback_with_block+0x30>
      sys_mbox_post(&mbox, msg);
    } else {
      if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {
 800b3fc:	f007 fe26 	bl	801304c <sys_mbox_trypost>
 800b400:	b938      	cbnz	r0, 800b412 <tcpip_callback_with_block+0x3e>
      }
    }
    return ERR_OK;
  }
  return ERR_VAL;
}
 800b402:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

    msg->type = TCPIP_MSG_CALLBACK;
    msg->msg.cb.function = function;
    msg->msg.cb.ctx = ctx;
    if (block) {
      sys_mbox_post(&mbox, msg);
 800b404:	f007 fdf4 	bl	8012ff0 <sys_mbox_post>
      if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {
        memp_free(MEMP_TCPIP_MSG_API, msg);
        return ERR_MEM;
      }
    }
    return ERR_OK;
 800b408:	2000      	movs	r0, #0
 800b40a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  }
  return ERR_VAL;
 800b40c:	f06f 0005 	mvn.w	r0, #5
 800b410:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    msg->msg.cb.ctx = ctx;
    if (block) {
      sys_mbox_post(&mbox, msg);
    } else {
      if (sys_mbox_trypost(&mbox, msg) != ERR_OK) {
        memp_free(MEMP_TCPIP_MSG_API, msg);
 800b412:	4621      	mov	r1, r4
 800b414:	2008      	movs	r0, #8
 800b416:	f004 fc71 	bl	800fcfc <memp_free>
        return ERR_MEM;
 800b41a:	f04f 30ff 	mov.w	r0, #4294967295
 800b41e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  struct tcpip_msg *msg;

  if (sys_mbox_valid(&mbox)) {
    msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
    if (msg == NULL) {
      return ERR_MEM;
 800b420:	f04f 30ff 	mov.w	r0, #4294967295
 800b424:	e7ed      	b.n	800b402 <tcpip_callback_with_block+0x2e>
 800b426:	bf00      	nop
 800b428:	200007b4 	.word	0x200007b4

0800b42c <tcpip_timeout>:
 * @param arg argument to pass to timeout function h
 * @return ERR_MEM on memory error, ERR_OK otherwise
 */
err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
 800b42c:	b570      	push	{r4, r5, r6, lr}
 800b42e:	4606      	mov	r6, r0
  struct tcpip_msg *msg;

  if (sys_mbox_valid(&mbox)) {
 800b430:	480d      	ldr	r0, [pc, #52]	; (800b468 <tcpip_timeout+0x3c>)
 * @param arg argument to pass to timeout function h
 * @return ERR_MEM on memory error, ERR_OK otherwise
 */
err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
 800b432:	460d      	mov	r5, r1
 800b434:	4614      	mov	r4, r2
  struct tcpip_msg *msg;

  if (sys_mbox_valid(&mbox)) {
 800b436:	f007 fe45 	bl	80130c4 <sys_mbox_valid>
 800b43a:	b170      	cbz	r0, 800b45a <tcpip_timeout+0x2e>
    msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
 800b43c:	2008      	movs	r0, #8
 800b43e:	f004 fc27 	bl	800fc90 <memp_malloc>
    if (msg == NULL) {
 800b442:	b168      	cbz	r0, 800b460 <tcpip_timeout+0x34>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_TIMEOUT;
 800b444:	2302      	movs	r3, #2
    msg->msg.tmo.msecs = msecs;
 800b446:	6086      	str	r6, [r0, #8]
    msg->msg.tmo.h = h;
 800b448:	60c5      	str	r5, [r0, #12]
    msg->msg.tmo.arg = arg;
 800b44a:	6104      	str	r4, [r0, #16]
    msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
    if (msg == NULL) {
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_TIMEOUT;
 800b44c:	7003      	strb	r3, [r0, #0]
    msg->msg.tmo.msecs = msecs;
    msg->msg.tmo.h = h;
    msg->msg.tmo.arg = arg;
    sys_mbox_post(&mbox, msg);
 800b44e:	4601      	mov	r1, r0
 800b450:	4805      	ldr	r0, [pc, #20]	; (800b468 <tcpip_timeout+0x3c>)
 800b452:	f007 fdcd 	bl	8012ff0 <sys_mbox_post>
    return ERR_OK;
 800b456:	2000      	movs	r0, #0
 800b458:	bd70      	pop	{r4, r5, r6, pc}
  }
  return ERR_VAL;
 800b45a:	f06f 0005 	mvn.w	r0, #5
 800b45e:	bd70      	pop	{r4, r5, r6, pc}
  struct tcpip_msg *msg;

  if (sys_mbox_valid(&mbox)) {
    msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
    if (msg == NULL) {
      return ERR_MEM;
 800b460:	f04f 30ff 	mov.w	r0, #4294967295
    msg->msg.tmo.arg = arg;
    sys_mbox_post(&mbox, msg);
    return ERR_OK;
  }
  return ERR_VAL;
}
 800b464:	bd70      	pop	{r4, r5, r6, pc}
 800b466:	bf00      	nop
 800b468:	200007b4 	.word	0x200007b4

0800b46c <tcpip_untimeout>:
 * @param arg argument to pass to timeout function h
 * @return ERR_MEM on memory error, ERR_OK otherwise
 */
err_t
tcpip_untimeout(sys_timeout_handler h, void *arg)
{
 800b46c:	b538      	push	{r3, r4, r5, lr}
 800b46e:	4605      	mov	r5, r0
  struct tcpip_msg *msg;

  if (sys_mbox_valid(&mbox)) {
 800b470:	480c      	ldr	r0, [pc, #48]	; (800b4a4 <tcpip_untimeout+0x38>)
 * @param arg argument to pass to timeout function h
 * @return ERR_MEM on memory error, ERR_OK otherwise
 */
err_t
tcpip_untimeout(sys_timeout_handler h, void *arg)
{
 800b472:	460c      	mov	r4, r1
  struct tcpip_msg *msg;

  if (sys_mbox_valid(&mbox)) {
 800b474:	f007 fe26 	bl	80130c4 <sys_mbox_valid>
 800b478:	b168      	cbz	r0, 800b496 <tcpip_untimeout+0x2a>
    msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
 800b47a:	2008      	movs	r0, #8
 800b47c:	f004 fc08 	bl	800fc90 <memp_malloc>
    if (msg == NULL) {
 800b480:	b160      	cbz	r0, 800b49c <tcpip_untimeout+0x30>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_UNTIMEOUT;
 800b482:	2303      	movs	r3, #3
    msg->msg.tmo.h = h;
 800b484:	60c5      	str	r5, [r0, #12]
    msg->msg.tmo.arg = arg;
 800b486:	6104      	str	r4, [r0, #16]
    msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
    if (msg == NULL) {
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_UNTIMEOUT;
 800b488:	7003      	strb	r3, [r0, #0]
    msg->msg.tmo.h = h;
    msg->msg.tmo.arg = arg;
    sys_mbox_post(&mbox, msg);
 800b48a:	4601      	mov	r1, r0
 800b48c:	4805      	ldr	r0, [pc, #20]	; (800b4a4 <tcpip_untimeout+0x38>)
 800b48e:	f007 fdaf 	bl	8012ff0 <sys_mbox_post>
    return ERR_OK;
 800b492:	2000      	movs	r0, #0
 800b494:	bd38      	pop	{r3, r4, r5, pc}
  }
  return ERR_VAL;
 800b496:	f06f 0005 	mvn.w	r0, #5
 800b49a:	bd38      	pop	{r3, r4, r5, pc}
  struct tcpip_msg *msg;

  if (sys_mbox_valid(&mbox)) {
    msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
    if (msg == NULL) {
      return ERR_MEM;
 800b49c:	f04f 30ff 	mov.w	r0, #4294967295
    msg->msg.tmo.arg = arg;
    sys_mbox_post(&mbox, msg);
    return ERR_OK;
  }
  return ERR_VAL;
}
 800b4a0:	bd38      	pop	{r3, r4, r5, pc}
 800b4a2:	bf00      	nop
 800b4a4:	200007b4 	.word	0x200007b4

0800b4a8 <tcpip_apimsg>:
 * @param apimsg a struct containing the function to call and its parameters
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_apimsg(struct api_msg *apimsg)
{
 800b4a8:	b530      	push	{r4, r5, lr}
 800b4aa:	4604      	mov	r4, r0
 800b4ac:	b087      	sub	sp, #28
#ifdef LWIP_DEBUG
  /* catch functions that don't set err */
  apimsg->msg.err = ERR_VAL;
#endif
  
  if (sys_mbox_valid(&mbox)) {
 800b4ae:	480c      	ldr	r0, [pc, #48]	; (800b4e0 <tcpip_apimsg+0x38>)
 800b4b0:	f007 fe08 	bl	80130c4 <sys_mbox_valid>
 800b4b4:	b180      	cbz	r0, 800b4d8 <tcpip_apimsg+0x30>
    msg.type = TCPIP_MSG_API;
 800b4b6:	2500      	movs	r5, #0
    msg.msg.apimsg = apimsg;
    sys_mbox_post(&mbox, &msg);
 800b4b8:	a901      	add	r1, sp, #4
 800b4ba:	4809      	ldr	r0, [pc, #36]	; (800b4e0 <tcpip_apimsg+0x38>)
  apimsg->msg.err = ERR_VAL;
#endif
  
  if (sys_mbox_valid(&mbox)) {
    msg.type = TCPIP_MSG_API;
    msg.msg.apimsg = apimsg;
 800b4bc:	9403      	str	r4, [sp, #12]
  /* catch functions that don't set err */
  apimsg->msg.err = ERR_VAL;
#endif
  
  if (sys_mbox_valid(&mbox)) {
    msg.type = TCPIP_MSG_API;
 800b4be:	f88d 5004 	strb.w	r5, [sp, #4]
    msg.msg.apimsg = apimsg;
    sys_mbox_post(&mbox, &msg);
 800b4c2:	f007 fd95 	bl	8012ff0 <sys_mbox_post>
    sys_arch_sem_wait(&apimsg->msg.conn->op_completed, 0);
 800b4c6:	6860      	ldr	r0, [r4, #4]
 800b4c8:	4629      	mov	r1, r5
 800b4ca:	300c      	adds	r0, #12
 800b4cc:	f007 fe38 	bl	8013140 <sys_arch_sem_wait>
    return apimsg->msg.err;
 800b4d0:	f994 0008 	ldrsb.w	r0, [r4, #8]
  }
  return ERR_VAL;
}
 800b4d4:	b007      	add	sp, #28
 800b4d6:	bd30      	pop	{r4, r5, pc}
    msg.msg.apimsg = apimsg;
    sys_mbox_post(&mbox, &msg);
    sys_arch_sem_wait(&apimsg->msg.conn->op_completed, 0);
    return apimsg->msg.err;
  }
  return ERR_VAL;
 800b4d8:	f06f 0005 	mvn.w	r0, #5
 800b4dc:	e7fa      	b.n	800b4d4 <tcpip_apimsg+0x2c>
 800b4de:	bf00      	nop
 800b4e0:	200007b4 	.word	0x200007b4

0800b4e4 <tcpip_callbackmsg_new>:
 * @param function the function to call
 * @param ctx parameter passed to function
 * @return a struct pointer to pass to tcpip_trycallback().
 */
struct tcpip_callback_msg* tcpip_callbackmsg_new(tcpip_callback_fn function, void *ctx)
{
 800b4e4:	b538      	push	{r3, r4, r5, lr}
 800b4e6:	4605      	mov	r5, r0
  struct tcpip_msg *msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
 800b4e8:	2008      	movs	r0, #8
 * @param function the function to call
 * @param ctx parameter passed to function
 * @return a struct pointer to pass to tcpip_trycallback().
 */
struct tcpip_callback_msg* tcpip_callbackmsg_new(tcpip_callback_fn function, void *ctx)
{
 800b4ea:	460c      	mov	r4, r1
  struct tcpip_msg *msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
 800b4ec:	f004 fbd0 	bl	800fc90 <memp_malloc>
  if (msg == NULL) {
 800b4f0:	b118      	cbz	r0, 800b4fa <tcpip_callbackmsg_new+0x16>
    return NULL;
  }
  msg->type = TCPIP_MSG_CALLBACK_STATIC;
 800b4f2:	2305      	movs	r3, #5
  msg->msg.cb.function = function;
 800b4f4:	6085      	str	r5, [r0, #8]
  msg->msg.cb.ctx = ctx;
 800b4f6:	60c4      	str	r4, [r0, #12]
{
  struct tcpip_msg *msg = (struct tcpip_msg *)memp_malloc(MEMP_TCPIP_MSG_API);
  if (msg == NULL) {
    return NULL;
  }
  msg->type = TCPIP_MSG_CALLBACK_STATIC;
 800b4f8:	7003      	strb	r3, [r0, #0]
  msg->msg.cb.function = function;
  msg->msg.cb.ctx = ctx;
  return (struct tcpip_callback_msg*)msg;
}
 800b4fa:	bd38      	pop	{r3, r4, r5, pc}

0800b4fc <tcpip_callbackmsg_delete>:
 *
 * @param msg the message to free
 */
void tcpip_callbackmsg_delete(struct tcpip_callback_msg* msg)
{
  memp_free(MEMP_TCPIP_MSG_API, msg);
 800b4fc:	4601      	mov	r1, r0
 800b4fe:	2008      	movs	r0, #8
 800b500:	f004 bbfc 	b.w	800fcfc <memp_free>

0800b504 <tcpip_trycallback>:
 * @param msg pointer to the message to post
 * @return sys_mbox_trypost() return code
 */
err_t
tcpip_trycallback(struct tcpip_callback_msg* msg)
{
 800b504:	b510      	push	{r4, lr}
 800b506:	4604      	mov	r4, r0
  if (!sys_mbox_valid(&mbox)) {
 800b508:	4806      	ldr	r0, [pc, #24]	; (800b524 <tcpip_trycallback+0x20>)
 800b50a:	f007 fddb 	bl	80130c4 <sys_mbox_valid>
 800b50e:	b128      	cbz	r0, 800b51c <tcpip_trycallback+0x18>
    return ERR_VAL;
  }
  return sys_mbox_trypost(&mbox, msg);
 800b510:	4621      	mov	r1, r4
}
 800b512:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
tcpip_trycallback(struct tcpip_callback_msg* msg)
{
  if (!sys_mbox_valid(&mbox)) {
    return ERR_VAL;
  }
  return sys_mbox_trypost(&mbox, msg);
 800b516:	4803      	ldr	r0, [pc, #12]	; (800b524 <tcpip_trycallback+0x20>)
 800b518:	f007 bd98 	b.w	801304c <sys_mbox_trypost>
}
 800b51c:	f06f 0005 	mvn.w	r0, #5
 800b520:	bd10      	pop	{r4, pc}
 800b522:	bf00      	nop
 800b524:	200007b4 	.word	0x200007b4

0800b528 <tcpip_init>:
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void
tcpip_init(tcpip_init_done_fn initfunc, void *arg)
{
 800b528:	b530      	push	{r4, r5, lr}
 800b52a:	4605      	mov	r5, r0
 800b52c:	460c      	mov	r4, r1
 800b52e:	b083      	sub	sp, #12
  lwip_init();
 800b530:	f003 fa3a 	bl	800e9a8 <lwip_init>

  tcpip_init_done = initfunc;
 800b534:	4b0d      	ldr	r3, [pc, #52]	; (800b56c <tcpip_init+0x44>)
  tcpip_init_done_arg = arg;
  if(sys_mbox_new(&mbox, TCPIP_MBOX_SIZE) != ERR_OK) {
 800b536:	2114      	movs	r1, #20
 800b538:	f103 0008 	add.w	r0, r3, #8
void
tcpip_init(tcpip_init_done_fn initfunc, void *arg)
{
  lwip_init();

  tcpip_init_done = initfunc;
 800b53c:	601d      	str	r5, [r3, #0]
  tcpip_init_done_arg = arg;
 800b53e:	605c      	str	r4, [r3, #4]
  if(sys_mbox_new(&mbox, TCPIP_MBOX_SIZE) != ERR_OK) {
 800b540:	f007 fd08 	bl	8012f54 <sys_mbox_new>
 800b544:	b130      	cbz	r0, 800b554 <tcpip_init+0x2c>
    LWIP_ASSERT("failed to create tcpip_thread mbox", 0);
 800b546:	4b0a      	ldr	r3, [pc, #40]	; (800b570 <tcpip_init+0x48>)
 800b548:	f44f 72e7 	mov.w	r2, #462	; 0x1ce
 800b54c:	4909      	ldr	r1, [pc, #36]	; (800b574 <tcpip_init+0x4c>)
 800b54e:	480a      	ldr	r0, [pc, #40]	; (800b578 <tcpip_init+0x50>)
 800b550:	f009 fc12 	bl	8014d78 <iprintf>
  if(sys_mutex_new(&lock_tcpip_core) != ERR_OK) {
    LWIP_ASSERT("failed to create lock_tcpip_core", 0);
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */

  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
 800b554:	2301      	movs	r3, #1
 800b556:	9300      	str	r3, [sp, #0]
 800b558:	2200      	movs	r2, #0
 800b55a:	f44f 63a0 	mov.w	r3, #1280	; 0x500
 800b55e:	4907      	ldr	r1, [pc, #28]	; (800b57c <tcpip_init+0x54>)
 800b560:	4807      	ldr	r0, [pc, #28]	; (800b580 <tcpip_init+0x58>)
 800b562:	f007 fe8f 	bl	8013284 <sys_thread_new>
}
 800b566:	b003      	add	sp, #12
 800b568:	bd30      	pop	{r4, r5, pc}
 800b56a:	bf00      	nop
 800b56c:	200007ac 	.word	0x200007ac
 800b570:	08016de8 	.word	0x08016de8
 800b574:	08016e18 	.word	0x08016e18
 800b578:	0801660c 	.word	0x0801660c
 800b57c:	0800b2d1 	.word	0x0800b2d1
 800b580:	08016e3c 	.word	0x08016e3c

0800b584 <pbuf_free_callback>:
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
  return tcpip_callback_with_block(pbuf_free_int, p, 0);
 800b584:	4601      	mov	r1, r0
 800b586:	2200      	movs	r2, #0
 800b588:	4801      	ldr	r0, [pc, #4]	; (800b590 <pbuf_free_callback+0xc>)
 800b58a:	f7ff bf23 	b.w	800b3d4 <tcpip_callback_with_block>
 800b58e:	bf00      	nop
 800b590:	0800b385 	.word	0x0800b385

0800b594 <mem_free_callback>:
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
  return tcpip_callback_with_block(mem_free, m, 0);
 800b594:	4601      	mov	r1, r0
 800b596:	2200      	movs	r2, #0
 800b598:	4801      	ldr	r0, [pc, #4]	; (800b5a0 <mem_free_callback+0xc>)
 800b59a:	f7ff bf1b 	b.w	800b3d4 <tcpip_callback_with_block>
 800b59e:	bf00      	nop
 800b5a0:	0800f811 	.word	0x0800f811

0800b5a4 <sys_timeout>:
sys_timeout_debug(u32_t msecs, sys_timeout_handler handler, void *arg, const char* handler_name)
#else /* LWIP_DEBUG_TIMERNAMES */
void
sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)
#endif /* LWIP_DEBUG_TIMERNAMES */
{
 800b5a4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800b5a8:	4604      	mov	r4, r0
  struct sys_timeo *timeout, *t;

  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
 800b5aa:	200b      	movs	r0, #11
sys_timeout_debug(u32_t msecs, sys_timeout_handler handler, void *arg, const char* handler_name)
#else /* LWIP_DEBUG_TIMERNAMES */
void
sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)
#endif /* LWIP_DEBUG_TIMERNAMES */
{
 800b5ac:	4688      	mov	r8, r1
 800b5ae:	4617      	mov	r7, r2
  struct sys_timeo *timeout, *t;

  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
 800b5b0:	f004 fb6e 	bl	800fc90 <memp_malloc>
  if (timeout == NULL) {
 800b5b4:	b348      	cbz	r0, 800b60a <sys_timeout+0x66>
  timeout->handler_name = handler_name;
  LWIP_DEBUGF(TIMERS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" handler=%s arg=%p\n",
    (void *)timeout, msecs, handler_name, (void *)arg));
#endif /* LWIP_DEBUG_TIMERNAMES */

  if (next_timeout == NULL) {
 800b5b6:	4e19      	ldr	r6, [pc, #100]	; (800b61c <sys_timeout+0x78>)
  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
  if (timeout == NULL) {
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
    return;
  }
  timeout->next = NULL;
 800b5b8:	2300      	movs	r3, #0
  timeout->handler_name = handler_name;
  LWIP_DEBUGF(TIMERS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" handler=%s arg=%p\n",
    (void *)timeout, msecs, handler_name, (void *)arg));
#endif /* LWIP_DEBUG_TIMERNAMES */

  if (next_timeout == NULL) {
 800b5ba:	6835      	ldr	r5, [r6, #0]
  if (timeout == NULL) {
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
    return;
  }
  timeout->next = NULL;
  timeout->h = handler;
 800b5bc:	f8c0 8008 	str.w	r8, [r0, #8]
  timeout->arg = arg;
 800b5c0:	60c7      	str	r7, [r0, #12]
  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
  if (timeout == NULL) {
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
    return;
  }
  timeout->next = NULL;
 800b5c2:	e880 0018 	stmia.w	r0, {r3, r4}
  timeout->handler_name = handler_name;
  LWIP_DEBUGF(TIMERS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" handler=%s arg=%p\n",
    (void *)timeout, msecs, handler_name, (void *)arg));
#endif /* LWIP_DEBUG_TIMERNAMES */

  if (next_timeout == NULL) {
 800b5c6:	b1ed      	cbz	r5, 800b604 <sys_timeout+0x60>
    next_timeout = timeout;
    return;
  }

  if (next_timeout->time > msecs) {
 800b5c8:	6869      	ldr	r1, [r5, #4]
 800b5ca:	428c      	cmp	r4, r1
 800b5cc:	d30e      	bcc.n	800b5ec <sys_timeout+0x48>
 800b5ce:	4623      	mov	r3, r4
 800b5d0:	e003      	b.n	800b5da <sys_timeout+0x36>
    timeout->next = next_timeout;
    next_timeout = timeout;
  } else {
    for(t = next_timeout; t != NULL; t = t->next) {
      timeout->time -= t->time;
      if (t->next == NULL || t->next->time > timeout->time) {
 800b5d2:	6851      	ldr	r1, [r2, #4]
 800b5d4:	428b      	cmp	r3, r1
 800b5d6:	d30f      	bcc.n	800b5f8 <sys_timeout+0x54>
 800b5d8:	4615      	mov	r5, r2
 800b5da:	682a      	ldr	r2, [r5, #0]
    next_timeout->time -= msecs;
    timeout->next = next_timeout;
    next_timeout = timeout;
  } else {
    for(t = next_timeout; t != NULL; t = t->next) {
      timeout->time -= t->time;
 800b5dc:	1a5b      	subs	r3, r3, r1
 800b5de:	6043      	str	r3, [r0, #4]
      if (t->next == NULL || t->next->time > timeout->time) {
 800b5e0:	2a00      	cmp	r2, #0
 800b5e2:	d1f6      	bne.n	800b5d2 <sys_timeout+0x2e>
        if (t->next != NULL) {
          t->next->time -= timeout->time;
        }
        timeout->next = t->next;
 800b5e4:	6002      	str	r2, [r0, #0]
        t->next = timeout;
 800b5e6:	6028      	str	r0, [r5, #0]
        break;
 800b5e8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    next_timeout = timeout;
    return;
  }

  if (next_timeout->time > msecs) {
    next_timeout->time -= msecs;
 800b5ec:	1b0b      	subs	r3, r1, r4
 800b5ee:	606b      	str	r3, [r5, #4]
    timeout->next = next_timeout;
    next_timeout = timeout;
 800b5f0:	6030      	str	r0, [r6, #0]
    return;
  }

  if (next_timeout->time > msecs) {
    next_timeout->time -= msecs;
    timeout->next = next_timeout;
 800b5f2:	6005      	str	r5, [r0, #0]
 800b5f4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  } else {
    for(t = next_timeout; t != NULL; t = t->next) {
      timeout->time -= t->time;
      if (t->next == NULL || t->next->time > timeout->time) {
        if (t->next != NULL) {
          t->next->time -= timeout->time;
 800b5f8:	1acb      	subs	r3, r1, r3
 800b5fa:	6053      	str	r3, [r2, #4]
        }
        timeout->next = t->next;
 800b5fc:	6002      	str	r2, [r0, #0]
        t->next = timeout;
 800b5fe:	6028      	str	r0, [r5, #0]
        break;
 800b600:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  LWIP_DEBUGF(TIMERS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" handler=%s arg=%p\n",
    (void *)timeout, msecs, handler_name, (void *)arg));
#endif /* LWIP_DEBUG_TIMERNAMES */

  if (next_timeout == NULL) {
    next_timeout = timeout;
 800b604:	6030      	str	r0, [r6, #0]
    return;
 800b606:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
{
  struct sys_timeo *timeout, *t;

  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
  if (timeout == NULL) {
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
 800b60a:	4b05      	ldr	r3, [pc, #20]	; (800b620 <sys_timeout+0x7c>)
 800b60c:	f240 1211 	movw	r2, #273	; 0x111
        t->next = timeout;
        break;
      }
    }
  }
}
 800b610:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
{
  struct sys_timeo *timeout, *t;

  timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
  if (timeout == NULL) {
    LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
 800b614:	4903      	ldr	r1, [pc, #12]	; (800b624 <sys_timeout+0x80>)
 800b616:	4804      	ldr	r0, [pc, #16]	; (800b628 <sys_timeout+0x84>)
 800b618:	f009 bbae 	b.w	8014d78 <iprintf>
 800b61c:	200007e4 	.word	0x200007e4
 800b620:	08016e4c 	.word	0x08016e4c
 800b624:	08016e60 	.word	0x08016e60
 800b628:	0801660c 	.word	0x0801660c

0800b62c <tcp_timer_needed>:
 */
void
tcp_timer_needed(void)
{
  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
 800b62c:	4b0a      	ldr	r3, [pc, #40]	; (800b658 <tcp_timer_needed+0x2c>)
 * the reason is to have the TCP timer only running when
 * there are active (or time-wait) PCBs.
 */
void
tcp_timer_needed(void)
{
 800b62e:	b410      	push	{r4}
  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
 800b630:	685a      	ldr	r2, [r3, #4]
 800b632:	b972      	cbnz	r2, 800b652 <tcp_timer_needed+0x26>
 800b634:	4a09      	ldr	r2, [pc, #36]	; (800b65c <tcp_timer_needed+0x30>)
 800b636:	6812      	ldr	r2, [r2, #0]
 800b638:	b13a      	cbz	r2, 800b64a <tcp_timer_needed+0x1e>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
 800b63a:	2401      	movs	r4, #1
 800b63c:	605c      	str	r4, [r3, #4]
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
 800b63e:	2200      	movs	r2, #0
 800b640:	4907      	ldr	r1, [pc, #28]	; (800b660 <tcp_timer_needed+0x34>)
 800b642:	20fa      	movs	r0, #250	; 0xfa
  }
}
 800b644:	bc10      	pop	{r4}
{
  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
 800b646:	f7ff bfad 	b.w	800b5a4 <sys_timeout>
 */
void
tcp_timer_needed(void)
{
  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
 800b64a:	4a06      	ldr	r2, [pc, #24]	; (800b664 <tcp_timer_needed+0x38>)
 800b64c:	6812      	ldr	r2, [r2, #0]
 800b64e:	2a00      	cmp	r2, #0
 800b650:	d1f3      	bne.n	800b63a <tcp_timer_needed+0xe>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  }
}
 800b652:	bc10      	pop	{r4}
 800b654:	4770      	bx	lr
 800b656:	bf00      	nop
 800b658:	200007e4 	.word	0x200007e4
 800b65c:	2000f040 	.word	0x2000f040
 800b660:	0800b669 	.word	0x0800b669
 800b664:	2000f054 	.word	0x2000f054

0800b668 <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
 800b668:	b508      	push	{r3, lr}
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
 800b66a:	f7fe fd89 	bl	800a180 <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
 800b66e:	4b08      	ldr	r3, [pc, #32]	; (800b690 <tcpip_tcp_timer+0x28>)
 800b670:	681b      	ldr	r3, [r3, #0]
 800b672:	b133      	cbz	r3, 800b682 <tcpip_tcp_timer+0x1a>
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
  }
}
 800b674:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  /* call TCP timer handler */
  tcp_tmr();
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
 800b678:	2200      	movs	r2, #0
 800b67a:	4906      	ldr	r1, [pc, #24]	; (800b694 <tcpip_tcp_timer+0x2c>)
 800b67c:	20fa      	movs	r0, #250	; 0xfa
 800b67e:	f7ff bf91 	b.w	800b5a4 <sys_timeout>
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
 800b682:	4b05      	ldr	r3, [pc, #20]	; (800b698 <tcpip_tcp_timer+0x30>)
 800b684:	681b      	ldr	r3, [r3, #0]
 800b686:	2b00      	cmp	r3, #0
 800b688:	d1f4      	bne.n	800b674 <tcpip_tcp_timer+0xc>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
 800b68a:	4a04      	ldr	r2, [pc, #16]	; (800b69c <tcpip_tcp_timer+0x34>)
 800b68c:	6053      	str	r3, [r2, #4]
 800b68e:	bd08      	pop	{r3, pc}
 800b690:	2000f040 	.word	0x2000f040
 800b694:	0800b669 	.word	0x0800b669
 800b698:	2000f054 	.word	0x2000f054
 800b69c:	200007e4 	.word	0x200007e4

0800b6a0 <sys_timeouts_init>:
}
#endif /* LWIP_DNS */

/** Initialize this module */
void sys_timeouts_init(void)
{
 800b6a0:	b508      	push	{r3, lr}
#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
 800b6a2:	2200      	movs	r2, #0
 800b6a4:	4906      	ldr	r1, [pc, #24]	; (800b6c0 <sys_timeouts_init+0x20>)
 800b6a6:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800b6aa:	f7ff ff7b 	bl	800b5a4 <sys_timeout>

#if NO_SYS
  /* Initialise timestamp for sys_check_timeouts */
  timeouts_last_time = sys_now();
#endif
}
 800b6ae:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
{
#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
 800b6b2:	2200      	movs	r2, #0
 800b6b4:	4903      	ldr	r1, [pc, #12]	; (800b6c4 <sys_timeouts_init+0x24>)
 800b6b6:	f241 3088 	movw	r0, #5000	; 0x1388
 800b6ba:	f7ff bf73 	b.w	800b5a4 <sys_timeout>
 800b6be:	bf00      	nop
 800b6c0:	0800b6e5 	.word	0x0800b6e5
 800b6c4:	0800b6c9 	.word	0x0800b6c9

0800b6c8 <arp_timer>:
 *
 * @param arg unused argument
 */
static void
arp_timer(void *arg)
{
 800b6c8:	b508      	push	{r3, lr}
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: etharp_tmr()\n"));
  etharp_tmr();
 800b6ca:	f002 fcd5 	bl	800e078 <etharp_tmr>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
}
 800b6ce:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
arp_timer(void *arg)
{
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: etharp_tmr()\n"));
  etharp_tmr();
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
 800b6d2:	2200      	movs	r2, #0
 800b6d4:	4902      	ldr	r1, [pc, #8]	; (800b6e0 <arp_timer+0x18>)
 800b6d6:	f241 3088 	movw	r0, #5000	; 0x1388
 800b6da:	f7ff bf63 	b.w	800b5a4 <sys_timeout>
 800b6de:	bf00      	nop
 800b6e0:	0800b6c9 	.word	0x0800b6c9

0800b6e4 <ip_reass_timer>:
 *
 * @param arg unused argument
 */
static void
ip_reass_timer(void *arg)
{
 800b6e4:	b508      	push	{r3, lr}
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: ip_reass_tmr()\n"));
  ip_reass_tmr();
 800b6e6:	f003 fd33 	bl	800f150 <ip_reass_tmr>
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
}
 800b6ea:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
ip_reass_timer(void *arg)
{
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: ip_reass_tmr()\n"));
  ip_reass_tmr();
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
 800b6ee:	2200      	movs	r2, #0
 800b6f0:	4902      	ldr	r1, [pc, #8]	; (800b6fc <ip_reass_timer+0x18>)
 800b6f2:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800b6f6:	f7ff bf55 	b.w	800b5a4 <sys_timeout>
 800b6fa:	bf00      	nop
 800b6fc:	0800b6e5 	.word	0x0800b6e5

0800b700 <sys_untimeout>:
 * @param handler callback function that would be called by the timeout
 * @param arg callback argument that would be passed to handler
*/
void
sys_untimeout(sys_timeout_handler handler, void *arg)
{
 800b700:	b430      	push	{r4, r5}
  struct sys_timeo *prev_t, *t;

  if (next_timeout == NULL) {
 800b702:	4d10      	ldr	r5, [pc, #64]	; (800b744 <sys_untimeout+0x44>)
 800b704:	682b      	ldr	r3, [r5, #0]
 800b706:	b1cb      	cbz	r3, 800b73c <sys_untimeout+0x3c>
 800b708:	2400      	movs	r4, #0
 800b70a:	e003      	b.n	800b714 <sys_untimeout+0x14>
    return;
  }

  for (t = next_timeout, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
 800b70c:	681a      	ldr	r2, [r3, #0]
 800b70e:	461c      	mov	r4, r3
 800b710:	b1a2      	cbz	r2, 800b73c <sys_untimeout+0x3c>
 800b712:	4613      	mov	r3, r2
    if ((t->h == handler) && (t->arg == arg)) {
 800b714:	689a      	ldr	r2, [r3, #8]
 800b716:	4282      	cmp	r2, r0
 800b718:	d1f8      	bne.n	800b70c <sys_untimeout+0xc>
 800b71a:	68da      	ldr	r2, [r3, #12]
 800b71c:	428a      	cmp	r2, r1
 800b71e:	d1f5      	bne.n	800b70c <sys_untimeout+0xc>
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL) {
        next_timeout = t->next;
 800b720:	681a      	ldr	r2, [r3, #0]

  for (t = next_timeout, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
    if ((t->h == handler) && (t->arg == arg)) {
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL) {
 800b722:	b16c      	cbz	r4, 800b740 <sys_untimeout+0x40>
        next_timeout = t->next;
      } else {
        prev_t->next = t->next;
 800b724:	6022      	str	r2, [r4, #0]
 800b726:	681a      	ldr	r2, [r3, #0]
      }
      /* If not the last one, add time of this one back to next */
      if (t->next != NULL) {
 800b728:	b11a      	cbz	r2, 800b732 <sys_untimeout+0x32>
        t->next->time += t->time;
 800b72a:	6850      	ldr	r0, [r2, #4]
 800b72c:	6859      	ldr	r1, [r3, #4]
 800b72e:	4401      	add	r1, r0
 800b730:	6051      	str	r1, [r2, #4]
      }
      memp_free(MEMP_SYS_TIMEOUT, t);
 800b732:	4619      	mov	r1, r3
      return;
    }
  }
  return;
}
 800b734:	bc30      	pop	{r4, r5}
      }
      /* If not the last one, add time of this one back to next */
      if (t->next != NULL) {
        t->next->time += t->time;
      }
      memp_free(MEMP_SYS_TIMEOUT, t);
 800b736:	200b      	movs	r0, #11
 800b738:	f004 bae0 	b.w	800fcfc <memp_free>
      return;
    }
  }
  return;
}
 800b73c:	bc30      	pop	{r4, r5}
 800b73e:	4770      	bx	lr
  for (t = next_timeout, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
    if ((t->h == handler) && (t->arg == arg)) {
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL) {
        next_timeout = t->next;
 800b740:	602a      	str	r2, [r5, #0]
 800b742:	e7f1      	b.n	800b728 <sys_untimeout+0x28>
 800b744:	200007e4 	.word	0x200007e4

0800b748 <sys_timeouts_mbox_fetch>:
 * @param mbox the mbox to fetch the message from
 * @param msg the place to store the message
 */
void
sys_timeouts_mbox_fetch(sys_mbox_t *mbox, void **msg)
{
 800b748:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800b74c:	4c18      	ldr	r4, [pc, #96]	; (800b7b0 <sys_timeouts_mbox_fetch+0x68>)
 800b74e:	4606      	mov	r6, r0
 800b750:	460f      	mov	r7, r1
  struct sys_timeo *tmptimeout;
  sys_timeout_handler handler;
  void *arg;

 again:
  if (!next_timeout) {
 800b752:	46a0      	mov	r8, r4
 800b754:	e009      	b.n	800b76a <sys_timeouts_mbox_fetch+0x22>
    if (time_needed == SYS_ARCH_TIMEOUT) {
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
         could be fetched. We should now call the timeout handler and
         deallocate the memory allocated for the timeout. */
      tmptimeout = next_timeout;
      next_timeout = tmptimeout->next;
 800b756:	681a      	ldr	r2, [r3, #0]
      handler = tmptimeout->h;
 800b758:	689d      	ldr	r5, [r3, #8]
      if (handler != NULL) {
        LWIP_DEBUGF(TIMERS_DEBUG, ("stmf calling h=%s arg=%p\n",
          tmptimeout->handler_name, arg));
      }
#endif /* LWIP_DEBUG_TIMERNAMES */
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
 800b75a:	200b      	movs	r0, #11
 800b75c:	4619      	mov	r1, r3
    if (time_needed == SYS_ARCH_TIMEOUT) {
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
         could be fetched. We should now call the timeout handler and
         deallocate the memory allocated for the timeout. */
      tmptimeout = next_timeout;
      next_timeout = tmptimeout->next;
 800b75e:	6022      	str	r2, [r4, #0]
      handler = tmptimeout->h;
      arg = tmptimeout->arg;
 800b760:	f8d3 900c 	ldr.w	r9, [r3, #12]
      if (handler != NULL) {
        LWIP_DEBUGF(TIMERS_DEBUG, ("stmf calling h=%s arg=%p\n",
          tmptimeout->handler_name, arg));
      }
#endif /* LWIP_DEBUG_TIMERNAMES */
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
 800b764:	f004 faca 	bl	800fcfc <memp_free>
      if (handler != NULL) {
 800b768:	b9f5      	cbnz	r5, 800b7a8 <sys_timeouts_mbox_fetch+0x60>
  struct sys_timeo *tmptimeout;
  sys_timeout_handler handler;
  void *arg;

 again:
  if (!next_timeout) {
 800b76a:	6823      	ldr	r3, [r4, #0]
 800b76c:	4d10      	ldr	r5, [pc, #64]	; (800b7b0 <sys_timeouts_mbox_fetch+0x68>)
 800b76e:	b15b      	cbz	r3, 800b788 <sys_timeouts_mbox_fetch+0x40>
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
  } else {
    if (next_timeout->time > 0) {
 800b770:	685a      	ldr	r2, [r3, #4]
 800b772:	2a00      	cmp	r2, #0
 800b774:	d0ef      	beq.n	800b756 <sys_timeouts_mbox_fetch+0xe>
      time_needed = sys_arch_mbox_fetch(mbox, msg, next_timeout->time);
 800b776:	4639      	mov	r1, r7
 800b778:	4630      	mov	r0, r6
 800b77a:	f007 fc81 	bl	8013080 <sys_arch_mbox_fetch>
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
 800b77e:	1c43      	adds	r3, r0, #1
 800b780:	d109      	bne.n	800b796 <sys_timeouts_mbox_fetch+0x4e>
 800b782:	f8d8 3000 	ldr.w	r3, [r8]
 800b786:	e7e6      	b.n	800b756 <sys_timeouts_mbox_fetch+0xe>
  sys_timeout_handler handler;
  void *arg;

 again:
  if (!next_timeout) {
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
 800b788:	461a      	mov	r2, r3
 800b78a:	4639      	mov	r1, r7
 800b78c:	4630      	mov	r0, r6
      } else {
        next_timeout->time = 0;
      }
    }
  }
}
 800b78e:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  sys_timeout_handler handler;
  void *arg;

 again:
  if (!next_timeout) {
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
 800b792:	f007 bc75 	b.w	8013080 <sys_arch_mbox_fetch>
      goto again;
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < next_timeout->time) {
 800b796:	682a      	ldr	r2, [r5, #0]
 800b798:	6853      	ldr	r3, [r2, #4]
 800b79a:	4298      	cmp	r0, r3
        next_timeout->time -= time_needed;
 800b79c:	bf34      	ite	cc
 800b79e:	1a1b      	subcc	r3, r3, r0
      } else {
        next_timeout->time = 0;
 800b7a0:	2300      	movcs	r3, #0
 800b7a2:	6053      	str	r3, [r2, #4]
 800b7a4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
      if (handler != NULL) {
        /* For LWIP_TCPIP_CORE_LOCKING, lock the core before calling the
           timeout handler function. */
        LOCK_TCPIP_CORE();
        handler(arg);
 800b7a8:	4648      	mov	r0, r9
 800b7aa:	47a8      	blx	r5
 800b7ac:	e7dd      	b.n	800b76a <sys_timeouts_mbox_fetch+0x22>
 800b7ae:	bf00      	nop
 800b7b0:	200007e4 	.word	0x200007e4

0800b7b4 <udpecho_thread>:
  	INT8U revbuff[20];
  	INT16U len=0;
  
  LWIP_UNUSED_ARG(arg);

  conn = netconn_new(NETCONN_UDP);
 800b7b4:	2200      	movs	r2, #0

//extern	INT8U UDP_TxBuff[1500];
//extern	INT16U UDP_TxBuff_len;
/*-----------------------------------------------------------------------------------*/
static void udpecho_thread(void *arg)
{
 800b7b6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  	INT8U revbuff[20];
  	INT16U len=0;
  
  LWIP_UNUSED_ARG(arg);

  conn = netconn_new(NETCONN_UDP);
 800b7b8:	4611      	mov	r1, r2
 800b7ba:	2020      	movs	r0, #32
 800b7bc:	f000 f92e 	bl	800ba1c <netconn_new_with_proto_and_callback>
 800b7c0:	4d1b      	ldr	r5, [pc, #108]	; (800b830 <udpecho_thread+0x7c>)
 800b7c2:	6028      	str	r0, [r5, #0]
  if (conn!= NULL)
 800b7c4:	b370      	cbz	r0, 800b824 <udpecho_thread+0x70>
  {
    err = netconn_bind(conn, IP_ADDR_ANY, 8808);
 800b7c6:	f242 2268 	movw	r2, #8808	; 0x2268
 800b7ca:	491a      	ldr	r1, [pc, #104]	; (800b834 <udpecho_thread+0x80>)
 800b7cc:	f000 f9dc 	bl	800bb88 <netconn_bind>
    if (err == ERR_OK)
 800b7d0:	bb18      	cbnz	r0, 800b81a <udpecho_thread+0x66>
 800b7d2:	4e19      	ldr	r6, [pc, #100]	; (800b838 <udpecho_thread+0x84>)
         // netconn_connect(conn, addr, port);
         // buf->addr.addr = NULL;
        //  netconn_send(conn,buf);
         // netbuf_delete(buf);
         	//PROTOCOL_PCcomm_Deal(buf->p->payload,buf->p->len);
		ACUDevInfo.DeviceInfo.PCCommStat.dst_IP_addr = addr->addr;
 800b7d4:	4637      	mov	r7, r6
    err = netconn_bind(conn, IP_ADDR_ANY, 8808);
    if (err == ERR_OK)
    {
      while (1) 
      {
        err = netconn_recv(conn,&buf);
 800b7d6:	4c16      	ldr	r4, [pc, #88]	; (800b830 <udpecho_thread+0x7c>)
 800b7d8:	6828      	ldr	r0, [r5, #0]
 800b7da:	1d21      	adds	r1, r4, #4
 800b7dc:	f000 faf2 	bl	800bdc4 <netconn_recv>
      
        if (buf!= NULL) 
 800b7e0:	6868      	ldr	r0, [r5, #4]
 800b7e2:	2800      	cmp	r0, #0
 800b7e4:	d0f7      	beq.n	800b7d6 <udpecho_thread+0x22>
         // netbuf_delete(buf);
         	//PROTOCOL_PCcomm_Deal(buf->p->payload,buf->p->len);
		ACUDevInfo.DeviceInfo.PCCommStat.dst_IP_addr = addr->addr;
		ACUDevInfo.DeviceInfo.PCCommStat.dst_IP_port = port;

		if( ACUDevInfo.ACUCurrSta.DevAdmin.admin_sta == 0x01)		// PC控制
 800b7e6:	f896 128c 	ldrb.w	r1, [r6, #652]	; 0x28c
        err = netconn_recv(conn,&buf);
      
        if (buf!= NULL) 
        {
          addr = netbuf_fromaddr(buf);
          port = netbuf_fromport(buf);
 800b7ea:	8983      	ldrh	r3, [r0, #12]
         // netconn_connect(conn, addr, port);
         // buf->addr.addr = NULL;
        //  netconn_send(conn,buf);
         // netbuf_delete(buf);
         	//PROTOCOL_PCcomm_Deal(buf->p->payload,buf->p->len);
		ACUDevInfo.DeviceInfo.PCCommStat.dst_IP_addr = addr->addr;
 800b7ec:	6882      	ldr	r2, [r0, #8]
      {
        err = netconn_recv(conn,&buf);
      
        if (buf!= NULL) 
        {
          addr = netbuf_fromaddr(buf);
 800b7ee:	f100 0e08 	add.w	lr, r0, #8
         // netbuf_delete(buf);
         	//PROTOCOL_PCcomm_Deal(buf->p->payload,buf->p->len);
		ACUDevInfo.DeviceInfo.PCCommStat.dst_IP_addr = addr->addr;
		ACUDevInfo.DeviceInfo.PCCommStat.dst_IP_port = port;

		if( ACUDevInfo.ACUCurrSta.DevAdmin.admin_sta == 0x01)		// PC控制
 800b7f2:	2901      	cmp	r1, #1
        err = netconn_recv(conn,&buf);
      
        if (buf!= NULL) 
        {
          addr = netbuf_fromaddr(buf);
          port = netbuf_fromport(buf);
 800b7f4:	81a3      	strh	r3, [r4, #12]
         // buf->addr.addr = NULL;
        //  netconn_send(conn,buf);
         // netbuf_delete(buf);
         	//PROTOCOL_PCcomm_Deal(buf->p->payload,buf->p->len);
		ACUDevInfo.DeviceInfo.PCCommStat.dst_IP_addr = addr->addr;
		ACUDevInfo.DeviceInfo.PCCommStat.dst_IP_port = port;
 800b7f6:	60f3      	str	r3, [r6, #12]
         // netconn_connect(conn, addr, port);
         // buf->addr.addr = NULL;
        //  netconn_send(conn,buf);
         // netbuf_delete(buf);
         	//PROTOCOL_PCcomm_Deal(buf->p->payload,buf->p->len);
		ACUDevInfo.DeviceInfo.PCCommStat.dst_IP_addr = addr->addr;
 800b7f8:	60b2      	str	r2, [r6, #8]
      {
        err = netconn_recv(conn,&buf);
      
        if (buf!= NULL) 
        {
          addr = netbuf_fromaddr(buf);
 800b7fa:	f8c4 e008 	str.w	lr, [r4, #8]
         // netbuf_delete(buf);
         	//PROTOCOL_PCcomm_Deal(buf->p->payload,buf->p->len);
		ACUDevInfo.DeviceInfo.PCCommStat.dst_IP_addr = addr->addr;
		ACUDevInfo.DeviceInfo.PCCommStat.dst_IP_port = port;

		if( ACUDevInfo.ACUCurrSta.DevAdmin.admin_sta == 0x01)		// PC控制
 800b7fe:	d002      	beq.n	800b806 <udpecho_thread+0x52>
         	buf->ptr->payload = PCCOMMTxBuff;
         	buf->ptr->len = PCCOMMTxBuffLen;
         	buf->ptr->tot_len= buf->ptr->len;
	     	netconn_sendto(conn,buf,addr,port);
	     	*/
         	 netbuf_delete(buf);
 800b800:	f004 faae 	bl	800fd60 <netbuf_delete>
 800b804:	e7e7      	b.n	800b7d6 <udpecho_thread+0x22>
		ACUDevInfo.DeviceInfo.PCCommStat.dst_IP_port = port;

		if( ACUDevInfo.ACUCurrSta.DevAdmin.admin_sta == 0x01)		// PC控制
		{
			//  当前通信PC机是否就是具有主控权限的PC机
			if( ACUDevInfo.DeviceInfo.PCCommStat.dst_IP_addr == ACUDevInfo.ACUCurrSta.DevAdmin.pc_admin_ip_addr)
 800b806:	f8d7 3290 	ldr.w	r3, [r7, #656]	; 0x290
 800b80a:	429a      	cmp	r2, r3
 800b80c:	d1f8      	bne.n	800b800 <udpecho_thread+0x4c>
				ACUDevInfo.ACUCurrSta.DevAdmin.pc_admin_link_cnt++;	
 800b80e:	f8d7 3298 	ldr.w	r3, [r7, #664]	; 0x298
 800b812:	3301      	adds	r3, #1
 800b814:	f8c7 3298 	str.w	r3, [r7, #664]	; 0x298
 800b818:	e7f2      	b.n	800b800 <udpecho_thread+0x4c>
        }
      }
    }
    else
    {
      printf("can not bind netconn");
 800b81a:	4808      	ldr	r0, [pc, #32]	; (800b83c <udpecho_thread+0x88>)
  }
  else
  {
    printf("can create new UDP netconn");
  }
}
 800b81c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
        }
      }
    }
    else
    {
      printf("can not bind netconn");
 800b820:	f009 baaa 	b.w	8014d78 <iprintf>
    }
  }
  else
  {
    printf("can create new UDP netconn");
 800b824:	4806      	ldr	r0, [pc, #24]	; (800b840 <udpecho_thread+0x8c>)
  }
}
 800b826:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
      printf("can not bind netconn");
    }
  }
  else
  {
    printf("can create new UDP netconn");
 800b82a:	f009 baa5 	b.w	8014d78 <iprintf>
 800b82e:	bf00      	nop
 800b830:	200007ec 	.word	0x200007ec
 800b834:	080161a8 	.word	0x080161a8
 800b838:	20004d00 	.word	0x20004d00
 800b83c:	08016ea0 	.word	0x08016ea0
 800b840:	08016eb8 	.word	0x08016eb8

0800b844 <udpecho_init>:
  }
}
/*-----------------------------------------------------------------------------------*/
void udpecho_init(void)
{
 800b844:	b500      	push	{lr}
  sys_thread_new("udpecho_thread", udpecho_thread, NULL, DEFAULT_THREAD_STACKSIZE,UDPECHO_THREAD_PRIO );
 800b846:	2303      	movs	r3, #3
    printf("can create new UDP netconn");
  }
}
/*-----------------------------------------------------------------------------------*/
void udpecho_init(void)
{
 800b848:	b083      	sub	sp, #12
  sys_thread_new("udpecho_thread", udpecho_thread, NULL, DEFAULT_THREAD_STACKSIZE,UDPECHO_THREAD_PRIO );
 800b84a:	9300      	str	r3, [sp, #0]
 800b84c:	2200      	movs	r2, #0
 800b84e:	f44f 63a0 	mov.w	r3, #1280	; 0x500
 800b852:	4903      	ldr	r1, [pc, #12]	; (800b860 <udpecho_init+0x1c>)
 800b854:	4803      	ldr	r0, [pc, #12]	; (800b864 <udpecho_init+0x20>)
 800b856:	f007 fd15 	bl	8013284 <sys_thread_new>
}
 800b85a:	b003      	add	sp, #12
 800b85c:	f85d fb04 	ldr.w	pc, [sp], #4
 800b860:	0800b7b5 	.word	0x0800b7b5
 800b864:	08016ed4 	.word	0x08016ed4

0800b868 <APP_UDP_Sendto>:

void APP_UDP_Sendto(INT8U *pbuff,INT32U len)
{
 800b868:	b570      	push	{r4, r5, r6, lr}
	buf->p->payload = pbuff;
 800b86a:	4c0a      	ldr	r4, [pc, #40]	; (800b894 <APP_UDP_Sendto+0x2c>)
	buf->p->len = len;
 800b86c:	b28a      	uxth	r2, r1
  sys_thread_new("udpecho_thread", udpecho_thread, NULL, DEFAULT_THREAD_STACKSIZE,UDPECHO_THREAD_PRIO );
}

void APP_UDP_Sendto(INT8U *pbuff,INT32U len)
{
	buf->p->payload = pbuff;
 800b86e:	6861      	ldr	r1, [r4, #4]
	buf->p->len = len;
	buf->p->tot_len= buf->p->len;
	buf->ptr->payload = pbuff;
	buf->ptr->len = len;
	buf->ptr->tot_len= buf->ptr->len;
	netconn_sendto(conn,buf,addr,port);
 800b870:	89a3      	ldrh	r3, [r4, #12]
  sys_thread_new("udpecho_thread", udpecho_thread, NULL, DEFAULT_THREAD_STACKSIZE,UDPECHO_THREAD_PRIO );
}

void APP_UDP_Sendto(INT8U *pbuff,INT32U len)
{
	buf->p->payload = pbuff;
 800b872:	680e      	ldr	r6, [r1, #0]
	buf->p->len = len;
	buf->p->tot_len= buf->p->len;
	buf->ptr->payload = pbuff;
 800b874:	684d      	ldr	r5, [r1, #4]
  sys_thread_new("udpecho_thread", udpecho_thread, NULL, DEFAULT_THREAD_STACKSIZE,UDPECHO_THREAD_PRIO );
}

void APP_UDP_Sendto(INT8U *pbuff,INT32U len)
{
	buf->p->payload = pbuff;
 800b876:	6070      	str	r0, [r6, #4]
	buf->p->len = len;
 800b878:	8172      	strh	r2, [r6, #10]
	buf->p->tot_len= buf->p->len;
 800b87a:	8132      	strh	r2, [r6, #8]
	buf->ptr->payload = pbuff;
 800b87c:	6068      	str	r0, [r5, #4]
	buf->ptr->len = len;
 800b87e:	816a      	strh	r2, [r5, #10]
	buf->ptr->tot_len= buf->ptr->len;
 800b880:	812a      	strh	r2, [r5, #8]
	netconn_sendto(conn,buf,addr,port);
 800b882:	6820      	ldr	r0, [r4, #0]
 800b884:	68a2      	ldr	r2, [r4, #8]
 800b886:	f000 fb53 	bl	800bf30 <netconn_sendto>
	BSP_Delay_ms(2);
}
 800b88a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	buf->p->tot_len= buf->p->len;
	buf->ptr->payload = pbuff;
	buf->ptr->len = len;
	buf->ptr->tot_len= buf->ptr->len;
	netconn_sendto(conn,buf,addr,port);
	BSP_Delay_ms(2);
 800b88e:	2002      	movs	r0, #2
 800b890:	f7f5 b982 	b.w	8000b98 <BSP_Delay_ms>
 800b894:	200007ec 	.word	0x200007ec

0800b898 <netconn_recv_data>:
 * @return ERR_OK if data has been received, an error code otherwise (timeout,
 *                memory error or another error)
 */
static err_t
netconn_recv_data(struct netconn *conn, void **new_buf)
{
 800b898:	b5f0      	push	{r4, r5, r6, r7, lr}
  void *buf = NULL;
 800b89a:	2500      	movs	r5, #0
 * @return ERR_OK if data has been received, an error code otherwise (timeout,
 *                memory error or another error)
 */
static err_t
netconn_recv_data(struct netconn *conn, void **new_buf)
{
 800b89c:	b089      	sub	sp, #36	; 0x24
  void *buf = NULL;
 800b89e:	9501      	str	r5, [sp, #4]
  err_t err;
#if LWIP_TCP
  struct api_msg msg;
#endif /* LWIP_TCP */

  LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
 800b8a0:	2900      	cmp	r1, #0
 800b8a2:	d076      	beq.n	800b992 <netconn_recv_data+0xfa>
 800b8a4:	4604      	mov	r4, r0
 800b8a6:	460e      	mov	r6, r1
  *new_buf = NULL;
 800b8a8:	600d      	str	r5, [r1, #0]
  LWIP_ERROR("netconn_recv: invalid conn",    (conn != NULL),    return ERR_ARG;);
 800b8aa:	2800      	cmp	r0, #0
 800b8ac:	d067      	beq.n	800b97e <netconn_recv_data+0xe6>
  LWIP_ERROR("netconn_accept: invalid recvmbox", sys_mbox_valid(&conn->recvmbox), return ERR_CONN;);
 800b8ae:	f100 0734 	add.w	r7, r0, #52	; 0x34
 800b8b2:	4638      	mov	r0, r7
 800b8b4:	f007 fc06 	bl	80130c4 <sys_mbox_valid>
 800b8b8:	2800      	cmp	r0, #0
 800b8ba:	d056      	beq.n	800b96a <netconn_recv_data+0xd2>

  err = conn->last_err;
 800b8bc:	f994 0008 	ldrsb.w	r0, [r4, #8]
  if (ERR_IS_FATAL(err)) {
 800b8c0:	f110 0f09 	cmn.w	r0, #9
 800b8c4:	da01      	bge.n	800b8ca <netconn_recv_data+0x32>
  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv_data: received %p, len=%"U16_F"\n", buf, len));

  *new_buf = buf;
  /* don't set conn->last_err: it's only ERR_OK, anyway */
  return ERR_OK;
}
 800b8c6:	b009      	add	sp, #36	; 0x24
 800b8c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (sys_arch_mbox_fetch(&conn->recvmbox, &buf, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    NETCONN_SET_SAFE_ERR(conn, ERR_TIMEOUT);
    return ERR_TIMEOUT;
  }
#else
  sys_arch_mbox_fetch(&conn->recvmbox, &buf, 0);
 800b8ca:	462a      	mov	r2, r5
 800b8cc:	4638      	mov	r0, r7
 800b8ce:	a901      	add	r1, sp, #4
 800b8d0:	f007 fbd6 	bl	8013080 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/

#if LWIP_TCP
#if (LWIP_UDP || LWIP_RAW)
  if (conn->type == NETCONN_TCP)
 800b8d4:	7823      	ldrb	r3, [r4, #0]
 800b8d6:	2b10      	cmp	r3, #16
 800b8d8:	d00f      	beq.n	800b8fa <netconn_recv_data+0x62>
#if LWIP_TCP && (LWIP_UDP || LWIP_RAW)
  else
#endif /* LWIP_TCP && (LWIP_UDP || LWIP_RAW) */
#if (LWIP_UDP || LWIP_RAW)
  {
    LWIP_ASSERT("buf != NULL", buf != NULL);
 800b8da:	9b01      	ldr	r3, [sp, #4]
 800b8dc:	2b00      	cmp	r3, #0
 800b8de:	d03b      	beq.n	800b958 <netconn_recv_data+0xc0>
    len = netbuf_len((struct netbuf *)buf);
 800b8e0:	681a      	ldr	r2, [r3, #0]
 800b8e2:	8912      	ldrh	r2, [r2, #8]

#if LWIP_SO_RCVBUF
  SYS_ARCH_DEC(conn->recv_avail, len);
#endif /* LWIP_SO_RCVBUF */
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
 800b8e4:	f8d4 50a4 	ldr.w	r5, [r4, #164]	; 0xa4
 800b8e8:	b11d      	cbz	r5, 800b8f2 <netconn_recv_data+0x5a>
 800b8ea:	4620      	mov	r0, r4
 800b8ec:	2101      	movs	r1, #1
 800b8ee:	47a8      	blx	r5
 800b8f0:	9b01      	ldr	r3, [sp, #4]

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv_data: received %p, len=%"U16_F"\n", buf, len));

  *new_buf = buf;
  /* don't set conn->last_err: it's only ERR_OK, anyway */
  return ERR_OK;
 800b8f2:	2000      	movs	r0, #0
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv_data: received %p, len=%"U16_F"\n", buf, len));

  *new_buf = buf;
 800b8f4:	6033      	str	r3, [r6, #0]
  /* don't set conn->last_err: it's only ERR_OK, anyway */
  return ERR_OK;
}
 800b8f6:	b009      	add	sp, #36	; 0x24
 800b8f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
#if LWIP_TCP
#if (LWIP_UDP || LWIP_RAW)
  if (conn->type == NETCONN_TCP)
#endif /* (LWIP_UDP || LWIP_RAW) */
  {
    if (!netconn_get_noautorecved(conn) || (buf == NULL)) {
 800b8fa:	f894 3098 	ldrb.w	r3, [r4, #152]	; 0x98
 800b8fe:	071b      	lsls	r3, r3, #28
 800b900:	d503      	bpl.n	800b90a <netconn_recv_data+0x72>
 800b902:	9b01      	ldr	r3, [sp, #4]
 800b904:	b313      	cbz	r3, 800b94c <netconn_recv_data+0xb4>
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
      /* Avoid to lose any previous error code */
      NETCONN_SET_SAFE_ERR(conn, ERR_CLSD);
      return ERR_CLSD;
    }
    len = ((struct pbuf *)buf)->tot_len;
 800b906:	891a      	ldrh	r2, [r3, #8]
 800b908:	e7ec      	b.n	800b8e4 <netconn_recv_data+0x4c>
  {
    if (!netconn_get_noautorecved(conn) || (buf == NULL)) {
      /* Let the stack know that we have taken the data. */
      /* TODO: Speedup: Don't block and wait for the answer here
         (to prevent multiple thread-switches). */
      msg.function = do_recv;
 800b90a:	4a27      	ldr	r2, [pc, #156]	; (800b9a8 <netconn_recv_data+0x110>)
      msg.msg.conn = conn;
      if (buf != NULL) {
 800b90c:	9b01      	ldr	r3, [sp, #4]
    if (!netconn_get_noautorecved(conn) || (buf == NULL)) {
      /* Let the stack know that we have taken the data. */
      /* TODO: Speedup: Don't block and wait for the answer here
         (to prevent multiple thread-switches). */
      msg.function = do_recv;
      msg.msg.conn = conn;
 800b90e:	9403      	str	r4, [sp, #12]
  {
    if (!netconn_get_noautorecved(conn) || (buf == NULL)) {
      /* Let the stack know that we have taken the data. */
      /* TODO: Speedup: Don't block and wait for the answer here
         (to prevent multiple thread-switches). */
      msg.function = do_recv;
 800b910:	9202      	str	r2, [sp, #8]
      msg.msg.conn = conn;
      if (buf != NULL) {
 800b912:	b1f3      	cbz	r3, 800b952 <netconn_recv_data+0xba>
        msg.msg.msg.r.len = ((struct pbuf *)buf)->tot_len;
 800b914:	891b      	ldrh	r3, [r3, #8]
 800b916:	9305      	str	r3, [sp, #20]
      } else {
        msg.msg.msg.r.len = 1;
      }
      /* don't care for the return value of do_recv */
      TCPIP_APIMSG(&msg);
 800b918:	a802      	add	r0, sp, #8
 800b91a:	f7ff fdc5 	bl	800b4a8 <tcpip_apimsg>
    }

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (buf == NULL) {
 800b91e:	9b01      	ldr	r3, [sp, #4]
 800b920:	2b00      	cmp	r3, #0
 800b922:	d1f0      	bne.n	800b906 <netconn_recv_data+0x6e>
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
 800b924:	f8d4 50a4 	ldr.w	r5, [r4, #164]	; 0xa4
 800b928:	b11d      	cbz	r5, 800b932 <netconn_recv_data+0x9a>
 800b92a:	461a      	mov	r2, r3
 800b92c:	2101      	movs	r1, #1
 800b92e:	4620      	mov	r0, r4
 800b930:	47a8      	blx	r5
      /* Avoid to lose any previous error code */
      NETCONN_SET_SAFE_ERR(conn, ERR_CLSD);
 800b932:	f7f5 ff1f 	bl	8001774 <CPU_SR_Save>
 800b936:	f994 3008 	ldrsb.w	r3, [r4, #8]
 800b93a:	3309      	adds	r3, #9
 800b93c:	bfa4      	itt	ge
 800b93e:	23f4      	movge	r3, #244	; 0xf4
 800b940:	7223      	strbge	r3, [r4, #8]
 800b942:	f7f5 ff1b 	bl	800177c <CPU_SR_Restore>
      return ERR_CLSD;
 800b946:	f06f 000b 	mvn.w	r0, #11
 800b94a:	e7bc      	b.n	800b8c6 <netconn_recv_data+0x2e>
  {
    if (!netconn_get_noautorecved(conn) || (buf == NULL)) {
      /* Let the stack know that we have taken the data. */
      /* TODO: Speedup: Don't block and wait for the answer here
         (to prevent multiple thread-switches). */
      msg.function = do_recv;
 800b94c:	4b16      	ldr	r3, [pc, #88]	; (800b9a8 <netconn_recv_data+0x110>)
      msg.msg.conn = conn;
 800b94e:	9403      	str	r4, [sp, #12]
  {
    if (!netconn_get_noautorecved(conn) || (buf == NULL)) {
      /* Let the stack know that we have taken the data. */
      /* TODO: Speedup: Don't block and wait for the answer here
         (to prevent multiple thread-switches). */
      msg.function = do_recv;
 800b950:	9302      	str	r3, [sp, #8]
      msg.msg.conn = conn;
      if (buf != NULL) {
        msg.msg.msg.r.len = ((struct pbuf *)buf)->tot_len;
      } else {
        msg.msg.msg.r.len = 1;
 800b952:	2301      	movs	r3, #1
 800b954:	9305      	str	r3, [sp, #20]
 800b956:	e7df      	b.n	800b918 <netconn_recv_data+0x80>
#if LWIP_TCP && (LWIP_UDP || LWIP_RAW)
  else
#endif /* LWIP_TCP && (LWIP_UDP || LWIP_RAW) */
#if (LWIP_UDP || LWIP_RAW)
  {
    LWIP_ASSERT("buf != NULL", buf != NULL);
 800b958:	4b14      	ldr	r3, [pc, #80]	; (800b9ac <netconn_recv_data+0x114>)
 800b95a:	f240 1299 	movw	r2, #409	; 0x199
 800b95e:	4914      	ldr	r1, [pc, #80]	; (800b9b0 <netconn_recv_data+0x118>)
 800b960:	4814      	ldr	r0, [pc, #80]	; (800b9b4 <netconn_recv_data+0x11c>)
 800b962:	f009 fa09 	bl	8014d78 <iprintf>
 800b966:	9b01      	ldr	r3, [sp, #4]
 800b968:	e7ba      	b.n	800b8e0 <netconn_recv_data+0x48>
#endif /* LWIP_TCP */

  LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
  *new_buf = NULL;
  LWIP_ERROR("netconn_recv: invalid conn",    (conn != NULL),    return ERR_ARG;);
  LWIP_ERROR("netconn_accept: invalid recvmbox", sys_mbox_valid(&conn->recvmbox), return ERR_CONN;);
 800b96a:	4b10      	ldr	r3, [pc, #64]	; (800b9ac <netconn_recv_data+0x114>)
 800b96c:	f44f 72b1 	mov.w	r2, #354	; 0x162
 800b970:	4911      	ldr	r1, [pc, #68]	; (800b9b8 <netconn_recv_data+0x120>)
 800b972:	4810      	ldr	r0, [pc, #64]	; (800b9b4 <netconn_recv_data+0x11c>)
 800b974:	f009 fa00 	bl	8014d78 <iprintf>
 800b978:	f06f 000c 	mvn.w	r0, #12
 800b97c:	e7a3      	b.n	800b8c6 <netconn_recv_data+0x2e>
  struct api_msg msg;
#endif /* LWIP_TCP */

  LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
  *new_buf = NULL;
  LWIP_ERROR("netconn_recv: invalid conn",    (conn != NULL),    return ERR_ARG;);
 800b97e:	4b0b      	ldr	r3, [pc, #44]	; (800b9ac <netconn_recv_data+0x114>)
 800b980:	f240 1261 	movw	r2, #353	; 0x161
 800b984:	490d      	ldr	r1, [pc, #52]	; (800b9bc <netconn_recv_data+0x124>)
 800b986:	480b      	ldr	r0, [pc, #44]	; (800b9b4 <netconn_recv_data+0x11c>)
 800b988:	f009 f9f6 	bl	8014d78 <iprintf>
 800b98c:	f06f 000d 	mvn.w	r0, #13
 800b990:	e799      	b.n	800b8c6 <netconn_recv_data+0x2e>
  err_t err;
#if LWIP_TCP
  struct api_msg msg;
#endif /* LWIP_TCP */

  LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
 800b992:	4b06      	ldr	r3, [pc, #24]	; (800b9ac <netconn_recv_data+0x114>)
 800b994:	f240 125f 	movw	r2, #351	; 0x15f
 800b998:	4909      	ldr	r1, [pc, #36]	; (800b9c0 <netconn_recv_data+0x128>)
 800b99a:	4806      	ldr	r0, [pc, #24]	; (800b9b4 <netconn_recv_data+0x11c>)
 800b99c:	f009 f9ec 	bl	8014d78 <iprintf>
 800b9a0:	f06f 000d 	mvn.w	r0, #13
 800b9a4:	e78f      	b.n	800b8c6 <netconn_recv_data+0x2e>
 800b9a6:	bf00      	nop
 800b9a8:	0800cfd5 	.word	0x0800cfd5
 800b9ac:	08016ee4 	.word	0x08016ee4
 800b9b0:	08016f58 	.word	0x08016f58
 800b9b4:	0801660c 	.word	0x0801660c
 800b9b8:	08016f34 	.word	0x08016f34
 800b9bc:	08016f18 	.word	0x08016f18
 800b9c0:	08016ef8 	.word	0x08016ef8

0800b9c4 <netconn_close_shutdown>:
 * @param how fully close or only shutdown one side?
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
static err_t
netconn_close_shutdown(struct netconn *conn, u8_t how)
{
 800b9c4:	b530      	push	{r4, r5, lr}
 800b9c6:	b087      	sub	sp, #28
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
 800b9c8:	b1a8      	cbz	r0, 800b9f6 <netconn_close_shutdown+0x32>
 800b9ca:	4604      	mov	r4, r0

  msg.function = do_close;
 800b9cc:	4b0f      	ldr	r3, [pc, #60]	; (800ba0c <netconn_close_shutdown+0x48>)
  msg.msg.conn = conn;
  /* shutting down both ends is the same as closing */
  msg.msg.msg.sd.shut = how;
  /* because of the LWIP_TCPIP_CORE_LOCKING implementation of do_close,
     don't use TCPIP_APIMSG here */
  err = tcpip_apimsg(&msg);
 800b9ce:	4668      	mov	r0, sp
  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);

  msg.function = do_close;
  msg.msg.conn = conn;
  /* shutting down both ends is the same as closing */
  msg.msg.msg.sd.shut = how;
 800b9d0:	f88d 100c 	strb.w	r1, [sp, #12]
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);

  msg.function = do_close;
 800b9d4:	9300      	str	r3, [sp, #0]
  msg.msg.conn = conn;
 800b9d6:	9401      	str	r4, [sp, #4]
  /* shutting down both ends is the same as closing */
  msg.msg.msg.sd.shut = how;
  /* because of the LWIP_TCPIP_CORE_LOCKING implementation of do_close,
     don't use TCPIP_APIMSG here */
  err = tcpip_apimsg(&msg);
 800b9d8:	f7ff fd66 	bl	800b4a8 <tcpip_apimsg>
 800b9dc:	4605      	mov	r5, r0

  NETCONN_SET_SAFE_ERR(conn, err);
 800b9de:	f7f5 fec9 	bl	8001774 <CPU_SR_Save>
 800b9e2:	f994 3008 	ldrsb.w	r3, [r4, #8]
 800b9e6:	3309      	adds	r3, #9
 800b9e8:	bfa8      	it	ge
 800b9ea:	7225      	strbge	r5, [r4, #8]
 800b9ec:	f7f5 fec6 	bl	800177c <CPU_SR_Restore>
  return err;
 800b9f0:	4628      	mov	r0, r5
}
 800b9f2:	b007      	add	sp, #28
 800b9f4:	bd30      	pop	{r4, r5, pc}
netconn_close_shutdown(struct netconn *conn, u8_t how)
{
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
 800b9f6:	4b06      	ldr	r3, [pc, #24]	; (800ba10 <netconn_close_shutdown+0x4c>)
 800b9f8:	f44f 7227 	mov.w	r2, #668	; 0x29c
 800b9fc:	4905      	ldr	r1, [pc, #20]	; (800ba14 <netconn_close_shutdown+0x50>)
 800b9fe:	4806      	ldr	r0, [pc, #24]	; (800ba18 <netconn_close_shutdown+0x54>)
 800ba00:	f009 f9ba 	bl	8014d78 <iprintf>
 800ba04:	f06f 000d 	mvn.w	r0, #13
 800ba08:	e7f3      	b.n	800b9f2 <netconn_close_shutdown+0x2e>
 800ba0a:	bf00      	nop
 800ba0c:	0800d16d 	.word	0x0800d16d
 800ba10:	08016ee4 	.word	0x08016ee4
 800ba14:	08016f64 	.word	0x08016f64
 800ba18:	0801660c 	.word	0x0801660c

0800ba1c <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
 800ba1c:	b570      	push	{r4, r5, r6, lr}
 800ba1e:	460d      	mov	r5, r1
 800ba20:	b086      	sub	sp, #24
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
 800ba22:	4611      	mov	r1, r2
 800ba24:	f000 ffa8 	bl	800c978 <netconn_alloc>
  if (conn != NULL) {
 800ba28:	4604      	mov	r4, r0
 800ba2a:	b370      	cbz	r0, 800ba8a <netconn_new_with_proto_and_callback+0x6e>
    msg.function = do_newconn;
 800ba2c:	4b23      	ldr	r3, [pc, #140]	; (800babc <netconn_new_with_proto_and_callback+0xa0>)
    msg.msg.msg.n.proto = proto;
    msg.msg.conn = conn;
    if (TCPIP_APIMSG(&msg) != ERR_OK) {
 800ba2e:	4668      	mov	r0, sp
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
  if (conn != NULL) {
    msg.function = do_newconn;
    msg.msg.msg.n.proto = proto;
 800ba30:	f88d 500c 	strb.w	r5, [sp, #12]
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
  if (conn != NULL) {
    msg.function = do_newconn;
 800ba34:	e88d 0018 	stmia.w	sp, {r3, r4}
    msg.msg.msg.n.proto = proto;
    msg.msg.conn = conn;
    if (TCPIP_APIMSG(&msg) != ERR_OK) {
 800ba38:	f7ff fd36 	bl	800b4a8 <tcpip_apimsg>
 800ba3c:	b910      	cbnz	r0, 800ba44 <netconn_new_with_proto_and_callback+0x28>
 800ba3e:	4620      	mov	r0, r4
      memp_free(MEMP_NETCONN, conn);
      return NULL;
    }
  }
  return conn;
}
 800ba40:	b006      	add	sp, #24
 800ba42:	bd70      	pop	{r4, r5, r6, pc}
  if (conn != NULL) {
    msg.function = do_newconn;
    msg.msg.msg.n.proto = proto;
    msg.msg.conn = conn;
    if (TCPIP_APIMSG(&msg) != ERR_OK) {
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
 800ba44:	6863      	ldr	r3, [r4, #4]
 800ba46:	b12b      	cbz	r3, 800ba54 <netconn_new_with_proto_and_callback+0x38>
 800ba48:	4b1d      	ldr	r3, [pc, #116]	; (800bac0 <netconn_new_with_proto_and_callback+0xa4>)
 800ba4a:	224f      	movs	r2, #79	; 0x4f
 800ba4c:	491d      	ldr	r1, [pc, #116]	; (800bac4 <netconn_new_with_proto_and_callback+0xa8>)
 800ba4e:	481e      	ldr	r0, [pc, #120]	; (800bac8 <netconn_new_with_proto_and_callback+0xac>)
 800ba50:	f009 f992 	bl	8014d78 <iprintf>
      LWIP_ASSERT("conn has no op_completed", sys_sem_valid(&conn->op_completed));
 800ba54:	f104 060c 	add.w	r6, r4, #12
 800ba58:	4630      	mov	r0, r6
 800ba5a:	f007 fbc5 	bl	80131e8 <sys_sem_valid>
 800ba5e:	b1b8      	cbz	r0, 800ba90 <netconn_new_with_proto_and_callback+0x74>
      LWIP_ASSERT("conn has no recvmbox", sys_mbox_valid(&conn->recvmbox));
 800ba60:	f104 0534 	add.w	r5, r4, #52	; 0x34
 800ba64:	4628      	mov	r0, r5
 800ba66:	f007 fb2d 	bl	80130c4 <sys_mbox_valid>
 800ba6a:	b1f8      	cbz	r0, 800baac <netconn_new_with_proto_and_callback+0x90>
#if LWIP_TCP
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", !sys_mbox_valid(&conn->acceptmbox));
 800ba6c:	f104 0064 	add.w	r0, r4, #100	; 0x64
 800ba70:	f007 fb28 	bl	80130c4 <sys_mbox_valid>
 800ba74:	b998      	cbnz	r0, 800ba9e <netconn_new_with_proto_and_callback+0x82>
#endif /* LWIP_TCP */
      sys_sem_free(&conn->op_completed);
 800ba76:	4630      	mov	r0, r6
 800ba78:	f007 fb9c 	bl	80131b4 <sys_sem_free>
      sys_mbox_free(&conn->recvmbox);
 800ba7c:	4628      	mov	r0, r5
 800ba7e:	f007 fa8d 	bl	8012f9c <sys_mbox_free>
      memp_free(MEMP_NETCONN, conn);
 800ba82:	4621      	mov	r1, r4
 800ba84:	2007      	movs	r0, #7
 800ba86:	f004 f939 	bl	800fcfc <memp_free>
      return NULL;
 800ba8a:	2000      	movs	r0, #0
    }
  }
  return conn;
}
 800ba8c:	b006      	add	sp, #24
 800ba8e:	bd70      	pop	{r4, r5, r6, pc}
    msg.function = do_newconn;
    msg.msg.msg.n.proto = proto;
    msg.msg.conn = conn;
    if (TCPIP_APIMSG(&msg) != ERR_OK) {
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
      LWIP_ASSERT("conn has no op_completed", sys_sem_valid(&conn->op_completed));
 800ba90:	4b0b      	ldr	r3, [pc, #44]	; (800bac0 <netconn_new_with_proto_and_callback+0xa4>)
 800ba92:	2250      	movs	r2, #80	; 0x50
 800ba94:	490d      	ldr	r1, [pc, #52]	; (800bacc <netconn_new_with_proto_and_callback+0xb0>)
 800ba96:	480c      	ldr	r0, [pc, #48]	; (800bac8 <netconn_new_with_proto_and_callback+0xac>)
 800ba98:	f009 f96e 	bl	8014d78 <iprintf>
 800ba9c:	e7e0      	b.n	800ba60 <netconn_new_with_proto_and_callback+0x44>
      LWIP_ASSERT("conn has no recvmbox", sys_mbox_valid(&conn->recvmbox));
#if LWIP_TCP
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", !sys_mbox_valid(&conn->acceptmbox));
 800ba9e:	4b08      	ldr	r3, [pc, #32]	; (800bac0 <netconn_new_with_proto_and_callback+0xa4>)
 800baa0:	2253      	movs	r2, #83	; 0x53
 800baa2:	490b      	ldr	r1, [pc, #44]	; (800bad0 <netconn_new_with_proto_and_callback+0xb4>)
 800baa4:	4808      	ldr	r0, [pc, #32]	; (800bac8 <netconn_new_with_proto_and_callback+0xac>)
 800baa6:	f009 f967 	bl	8014d78 <iprintf>
 800baaa:	e7e4      	b.n	800ba76 <netconn_new_with_proto_and_callback+0x5a>
    msg.msg.msg.n.proto = proto;
    msg.msg.conn = conn;
    if (TCPIP_APIMSG(&msg) != ERR_OK) {
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
      LWIP_ASSERT("conn has no op_completed", sys_sem_valid(&conn->op_completed));
      LWIP_ASSERT("conn has no recvmbox", sys_mbox_valid(&conn->recvmbox));
 800baac:	4b04      	ldr	r3, [pc, #16]	; (800bac0 <netconn_new_with_proto_and_callback+0xa4>)
 800baae:	2251      	movs	r2, #81	; 0x51
 800bab0:	4908      	ldr	r1, [pc, #32]	; (800bad4 <netconn_new_with_proto_and_callback+0xb8>)
 800bab2:	4805      	ldr	r0, [pc, #20]	; (800bac8 <netconn_new_with_proto_and_callback+0xac>)
 800bab4:	f009 f960 	bl	8014d78 <iprintf>
 800bab8:	e7d8      	b.n	800ba6c <netconn_new_with_proto_and_callback+0x50>
 800baba:	bf00      	nop
 800babc:	0800c8e1 	.word	0x0800c8e1
 800bac0:	08016ee4 	.word	0x08016ee4
 800bac4:	08016f80 	.word	0x08016f80
 800bac8:	0801660c 	.word	0x0801660c
 800bacc:	08016fa4 	.word	0x08016fa4
 800bad0:	08016fd8 	.word	0x08016fd8
 800bad4:	08016fc0 	.word	0x08016fc0

0800bad8 <netconn_delete>:
netconn_delete(struct netconn *conn)
{
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
 800bad8:	b170      	cbz	r0, 800baf8 <netconn_delete+0x20>
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
 800bada:	b510      	push	{r4, lr}
 800badc:	4604      	mov	r4, r0
 800bade:	b086      	sub	sp, #24
  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
    return ERR_OK;
  }

  msg.function = do_delconn;
 800bae0:	4b06      	ldr	r3, [pc, #24]	; (800bafc <netconn_delete+0x24>)
  msg.msg.conn = conn;
  tcpip_apimsg(&msg);
 800bae2:	4668      	mov	r0, sp
  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
    return ERR_OK;
  }

  msg.function = do_delconn;
 800bae4:	e88d 0018 	stmia.w	sp, {r3, r4}
  msg.msg.conn = conn;
  tcpip_apimsg(&msg);
 800bae8:	f7ff fcde 	bl	800b4a8 <tcpip_apimsg>

  netconn_free(conn);
 800baec:	4620      	mov	r0, r4
 800baee:	f000 ff79 	bl	800c9e4 <netconn_free>

  /* don't care for return value of do_delconn since it only calls void functions */

  return ERR_OK;
}
 800baf2:	2000      	movs	r0, #0
 800baf4:	b006      	add	sp, #24
 800baf6:	bd10      	pop	{r4, pc}
 800baf8:	2000      	movs	r0, #0
 800bafa:	4770      	bx	lr
 800bafc:	0800cbc5 	.word	0x0800cbc5

0800bb00 <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, ip_addr_t *addr, u16_t *port, u8_t local)
{
 800bb00:	b530      	push	{r4, r5, lr}
 800bb02:	b087      	sub	sp, #28
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
 800bb04:	b358      	cbz	r0, 800bb5e <netconn_getaddr+0x5e>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
 800bb06:	b309      	cbz	r1, 800bb4c <netconn_getaddr+0x4c>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
 800bb08:	b1ba      	cbz	r2, 800bb3a <netconn_getaddr+0x3a>
 800bb0a:	4604      	mov	r4, r0

  msg.function = do_getaddr;
 800bb0c:	4d18      	ldr	r5, [pc, #96]	; (800bb70 <netconn_getaddr+0x70>)
  msg.msg.conn = conn;
  msg.msg.msg.ad.ipaddr = addr;
  msg.msg.msg.ad.port = port;
  msg.msg.msg.ad.local = local;
  err = TCPIP_APIMSG(&msg);
 800bb0e:	4668      	mov	r0, sp
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);

  msg.function = do_getaddr;
  msg.msg.conn = conn;
  msg.msg.msg.ad.ipaddr = addr;
 800bb10:	9103      	str	r1, [sp, #12]
  msg.msg.msg.ad.port = port;
 800bb12:	9204      	str	r2, [sp, #16]
  msg.msg.msg.ad.local = local;
 800bb14:	f88d 3014 	strb.w	r3, [sp, #20]

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);

  msg.function = do_getaddr;
 800bb18:	9500      	str	r5, [sp, #0]
  msg.msg.conn = conn;
 800bb1a:	9401      	str	r4, [sp, #4]
  msg.msg.msg.ad.ipaddr = addr;
  msg.msg.msg.ad.port = port;
  msg.msg.msg.ad.local = local;
  err = TCPIP_APIMSG(&msg);
 800bb1c:	f7ff fcc4 	bl	800b4a8 <tcpip_apimsg>
 800bb20:	4605      	mov	r5, r0

  NETCONN_SET_SAFE_ERR(conn, err);
 800bb22:	f7f5 fe27 	bl	8001774 <CPU_SR_Save>
 800bb26:	f994 3008 	ldrsb.w	r3, [r4, #8]
 800bb2a:	3309      	adds	r3, #9
 800bb2c:	bfa8      	it	ge
 800bb2e:	7225      	strbge	r5, [r4, #8]
 800bb30:	f7f5 fe24 	bl	800177c <CPU_SR_Restore>
  return err;
 800bb34:	4628      	mov	r0, r5
}
 800bb36:	b007      	add	sp, #28
 800bb38:	bd30      	pop	{r4, r5, pc}
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
 800bb3a:	4b0e      	ldr	r3, [pc, #56]	; (800bb74 <netconn_getaddr+0x74>)
 800bb3c:	228e      	movs	r2, #142	; 0x8e
 800bb3e:	490e      	ldr	r1, [pc, #56]	; (800bb78 <netconn_getaddr+0x78>)
 800bb40:	480e      	ldr	r0, [pc, #56]	; (800bb7c <netconn_getaddr+0x7c>)
 800bb42:	f009 f919 	bl	8014d78 <iprintf>
 800bb46:	f06f 000d 	mvn.w	r0, #13
 800bb4a:	e7f4      	b.n	800bb36 <netconn_getaddr+0x36>
{
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
 800bb4c:	4b09      	ldr	r3, [pc, #36]	; (800bb74 <netconn_getaddr+0x74>)
 800bb4e:	228d      	movs	r2, #141	; 0x8d
 800bb50:	490b      	ldr	r1, [pc, #44]	; (800bb80 <netconn_getaddr+0x80>)
 800bb52:	480a      	ldr	r0, [pc, #40]	; (800bb7c <netconn_getaddr+0x7c>)
 800bb54:	f009 f910 	bl	8014d78 <iprintf>
 800bb58:	f06f 000d 	mvn.w	r0, #13
 800bb5c:	e7eb      	b.n	800bb36 <netconn_getaddr+0x36>
netconn_getaddr(struct netconn *conn, ip_addr_t *addr, u16_t *port, u8_t local)
{
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
 800bb5e:	4b05      	ldr	r3, [pc, #20]	; (800bb74 <netconn_getaddr+0x74>)
 800bb60:	228c      	movs	r2, #140	; 0x8c
 800bb62:	4908      	ldr	r1, [pc, #32]	; (800bb84 <netconn_getaddr+0x84>)
 800bb64:	4805      	ldr	r0, [pc, #20]	; (800bb7c <netconn_getaddr+0x7c>)
 800bb66:	f009 f907 	bl	8014d78 <iprintf>
 800bb6a:	f06f 000d 	mvn.w	r0, #13
 800bb6e:	e7e2      	b.n	800bb36 <netconn_getaddr+0x36>
 800bb70:	0800d0b1 	.word	0x0800d0b1
 800bb74:	08016ee4 	.word	0x08016ee4
 800bb78:	0801703c 	.word	0x0801703c
 800bb7c:	0801660c 	.word	0x0801660c
 800bb80:	0801701c 	.word	0x0801701c
 800bb84:	08016ffc 	.word	0x08016ffc

0800bb88 <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, ip_addr_t *addr, u16_t port)
{
 800bb88:	b530      	push	{r4, r5, lr}
 800bb8a:	b087      	sub	sp, #28
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
 800bb8c:	b1b0      	cbz	r0, 800bbbc <netconn_bind+0x34>
 800bb8e:	4604      	mov	r4, r0

  msg.function = do_bind;
 800bb90:	4b0f      	ldr	r3, [pc, #60]	; (800bbd0 <netconn_bind+0x48>)
  msg.msg.conn = conn;
  msg.msg.msg.bc.ipaddr = addr;
  msg.msg.msg.bc.port = port;
  err = TCPIP_APIMSG(&msg);
 800bb92:	4668      	mov	r0, sp

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);

  msg.function = do_bind;
  msg.msg.conn = conn;
  msg.msg.msg.bc.ipaddr = addr;
 800bb94:	9103      	str	r1, [sp, #12]
  msg.msg.msg.bc.port = port;
 800bb96:	f8ad 2010 	strh.w	r2, [sp, #16]
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);

  msg.function = do_bind;
 800bb9a:	9300      	str	r3, [sp, #0]
  msg.msg.conn = conn;
 800bb9c:	9401      	str	r4, [sp, #4]
  msg.msg.msg.bc.ipaddr = addr;
  msg.msg.msg.bc.port = port;
  err = TCPIP_APIMSG(&msg);
 800bb9e:	f7ff fc83 	bl	800b4a8 <tcpip_apimsg>
 800bba2:	4605      	mov	r5, r0

  NETCONN_SET_SAFE_ERR(conn, err);
 800bba4:	f7f5 fde6 	bl	8001774 <CPU_SR_Save>
 800bba8:	f994 3008 	ldrsb.w	r3, [r4, #8]
 800bbac:	3309      	adds	r3, #9
 800bbae:	bfa8      	it	ge
 800bbb0:	7225      	strbge	r5, [r4, #8]
 800bbb2:	f7f5 fde3 	bl	800177c <CPU_SR_Restore>
  return err;
 800bbb6:	4628      	mov	r0, r5
}
 800bbb8:	b007      	add	sp, #28
 800bbba:	bd30      	pop	{r4, r5, pc}
netconn_bind(struct netconn *conn, ip_addr_t *addr, u16_t port)
{
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
 800bbbc:	4b05      	ldr	r3, [pc, #20]	; (800bbd4 <netconn_bind+0x4c>)
 800bbbe:	22ab      	movs	r2, #171	; 0xab
 800bbc0:	4905      	ldr	r1, [pc, #20]	; (800bbd8 <netconn_bind+0x50>)
 800bbc2:	4806      	ldr	r0, [pc, #24]	; (800bbdc <netconn_bind+0x54>)
 800bbc4:	f009 f8d8 	bl	8014d78 <iprintf>
 800bbc8:	f06f 000d 	mvn.w	r0, #13
 800bbcc:	e7f4      	b.n	800bbb8 <netconn_bind+0x30>
 800bbce:	bf00      	nop
 800bbd0:	0800ccd5 	.word	0x0800ccd5
 800bbd4:	08016ee4 	.word	0x08016ee4
 800bbd8:	0801705c 	.word	0x0801705c
 800bbdc:	0801660c 	.word	0x0801660c

0800bbe0 <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, ip_addr_t *addr, u16_t port)
{
 800bbe0:	b530      	push	{r4, r5, lr}
 800bbe2:	b087      	sub	sp, #28
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
 800bbe4:	b1b0      	cbz	r0, 800bc14 <netconn_connect+0x34>
 800bbe6:	4604      	mov	r4, r0

  msg.function = do_connect;
 800bbe8:	4b0f      	ldr	r3, [pc, #60]	; (800bc28 <netconn_connect+0x48>)
  msg.msg.conn = conn;
  msg.msg.msg.bc.ipaddr = addr;
  msg.msg.msg.bc.port = port;
  /* This is the only function which need to not block tcpip_thread */
  err = tcpip_apimsg(&msg);
 800bbea:	4668      	mov	r0, sp

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);

  msg.function = do_connect;
  msg.msg.conn = conn;
  msg.msg.msg.bc.ipaddr = addr;
 800bbec:	9103      	str	r1, [sp, #12]
  msg.msg.msg.bc.port = port;
 800bbee:	f8ad 2010 	strh.w	r2, [sp, #16]
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);

  msg.function = do_connect;
 800bbf2:	9300      	str	r3, [sp, #0]
  msg.msg.conn = conn;
 800bbf4:	9401      	str	r4, [sp, #4]
  msg.msg.msg.bc.ipaddr = addr;
  msg.msg.msg.bc.port = port;
  /* This is the only function which need to not block tcpip_thread */
  err = tcpip_apimsg(&msg);
 800bbf6:	f7ff fc57 	bl	800b4a8 <tcpip_apimsg>
 800bbfa:	4605      	mov	r5, r0

  NETCONN_SET_SAFE_ERR(conn, err);
 800bbfc:	f7f5 fdba 	bl	8001774 <CPU_SR_Save>
 800bc00:	f994 3008 	ldrsb.w	r3, [r4, #8]
 800bc04:	3309      	adds	r3, #9
 800bc06:	bfa8      	it	ge
 800bc08:	7225      	strbge	r5, [r4, #8]
 800bc0a:	f7f5 fdb7 	bl	800177c <CPU_SR_Restore>
  return err;
 800bc0e:	4628      	mov	r0, r5
}
 800bc10:	b007      	add	sp, #28
 800bc12:	bd30      	pop	{r4, r5, pc}
netconn_connect(struct netconn *conn, ip_addr_t *addr, u16_t port)
{
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
 800bc14:	4b05      	ldr	r3, [pc, #20]	; (800bc2c <netconn_connect+0x4c>)
 800bc16:	22c5      	movs	r2, #197	; 0xc5
 800bc18:	4905      	ldr	r1, [pc, #20]	; (800bc30 <netconn_connect+0x50>)
 800bc1a:	4806      	ldr	r0, [pc, #24]	; (800bc34 <netconn_connect+0x54>)
 800bc1c:	f009 f8ac 	bl	8014d78 <iprintf>
 800bc20:	f06f 000d 	mvn.w	r0, #13
 800bc24:	e7f4      	b.n	800bc10 <netconn_connect+0x30>
 800bc26:	bf00      	nop
 800bc28:	0800cd61 	.word	0x0800cd61
 800bc2c:	08016ee4 	.word	0x08016ee4
 800bc30:	08017078 	.word	0x08017078
 800bc34:	0801660c 	.word	0x0801660c

0800bc38 <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t
netconn_disconnect(struct netconn *conn)
{
 800bc38:	b530      	push	{r4, r5, lr}
 800bc3a:	b087      	sub	sp, #28
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
 800bc3c:	b198      	cbz	r0, 800bc66 <netconn_disconnect+0x2e>
 800bc3e:	4604      	mov	r4, r0

  msg.function = do_disconnect;
 800bc40:	4b0d      	ldr	r3, [pc, #52]	; (800bc78 <netconn_disconnect+0x40>)
  msg.msg.conn = conn;
  err = TCPIP_APIMSG(&msg);
 800bc42:	4668      	mov	r0, sp
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);

  msg.function = do_disconnect;
 800bc44:	e88d 0018 	stmia.w	sp, {r3, r4}
  msg.msg.conn = conn;
  err = TCPIP_APIMSG(&msg);
 800bc48:	f7ff fc2e 	bl	800b4a8 <tcpip_apimsg>
 800bc4c:	4605      	mov	r5, r0

  NETCONN_SET_SAFE_ERR(conn, err);
 800bc4e:	f7f5 fd91 	bl	8001774 <CPU_SR_Save>
 800bc52:	f994 3008 	ldrsb.w	r3, [r4, #8]
 800bc56:	3309      	adds	r3, #9
 800bc58:	bfa8      	it	ge
 800bc5a:	7225      	strbge	r5, [r4, #8]
 800bc5c:	f7f5 fd8e 	bl	800177c <CPU_SR_Restore>
  return err;
 800bc60:	4628      	mov	r0, r5
}
 800bc62:	b007      	add	sp, #28
 800bc64:	bd30      	pop	{r4, r5, pc}
netconn_disconnect(struct netconn *conn)
{
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
 800bc66:	4b05      	ldr	r3, [pc, #20]	; (800bc7c <netconn_disconnect+0x44>)
 800bc68:	22de      	movs	r2, #222	; 0xde
 800bc6a:	4905      	ldr	r1, [pc, #20]	; (800bc80 <netconn_disconnect+0x48>)
 800bc6c:	4805      	ldr	r0, [pc, #20]	; (800bc84 <netconn_disconnect+0x4c>)
 800bc6e:	f009 f883 	bl	8014d78 <iprintf>
 800bc72:	f06f 000d 	mvn.w	r0, #13
 800bc76:	e7f4      	b.n	800bc62 <netconn_disconnect+0x2a>
 800bc78:	0800ce4d 	.word	0x0800ce4d
 800bc7c:	08016ee4 	.word	0x08016ee4
 800bc80:	08017098 	.word	0x08017098
 800bc84:	0801660c 	.word	0x0801660c

0800bc88 <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
 800bc88:	b530      	push	{r4, r5, lr}
 800bc8a:	b087      	sub	sp, #28
  err_t err;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
 800bc8c:	b198      	cbz	r0, 800bcb6 <netconn_listen_with_backlog+0x2e>
 800bc8e:	4604      	mov	r4, r0

  msg.function = do_listen;
 800bc90:	4b0d      	ldr	r3, [pc, #52]	; (800bcc8 <netconn_listen_with_backlog+0x40>)
  msg.msg.conn = conn;
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  err = TCPIP_APIMSG(&msg);
 800bc92:	4668      	mov	r0, sp
  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);

  msg.function = do_listen;
 800bc94:	e88d 0018 	stmia.w	sp, {r3, r4}
  msg.msg.conn = conn;
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  err = TCPIP_APIMSG(&msg);
 800bc98:	f7ff fc06 	bl	800b4a8 <tcpip_apimsg>
 800bc9c:	4605      	mov	r5, r0

  NETCONN_SET_SAFE_ERR(conn, err);
 800bc9e:	f7f5 fd69 	bl	8001774 <CPU_SR_Save>
 800bca2:	f994 3008 	ldrsb.w	r3, [r4, #8]
 800bca6:	3309      	adds	r3, #9
 800bca8:	bfa8      	it	ge
 800bcaa:	7225      	strbge	r5, [r4, #8]
 800bcac:	f7f5 fd66 	bl	800177c <CPU_SR_Restore>
  return err;
 800bcb0:	4628      	mov	r0, r5
#else /* LWIP_TCP */
  LWIP_UNUSED_ARG(conn);
  LWIP_UNUSED_ARG(backlog);
  return ERR_ARG;
#endif /* LWIP_TCP */
}
 800bcb2:	b007      	add	sp, #28
 800bcb4:	bd30      	pop	{r4, r5, pc}
  err_t err;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
 800bcb6:	4b05      	ldr	r3, [pc, #20]	; (800bccc <netconn_listen_with_backlog+0x44>)
 800bcb8:	22fa      	movs	r2, #250	; 0xfa
 800bcba:	4905      	ldr	r1, [pc, #20]	; (800bcd0 <netconn_listen_with_backlog+0x48>)
 800bcbc:	4805      	ldr	r0, [pc, #20]	; (800bcd4 <netconn_listen_with_backlog+0x4c>)
 800bcbe:	f009 f85b 	bl	8014d78 <iprintf>
 800bcc2:	f06f 000d 	mvn.w	r0, #13
 800bcc6:	e7f4      	b.n	800bcb2 <netconn_listen_with_backlog+0x2a>
 800bcc8:	0800ce81 	.word	0x0800ce81
 800bccc:	08016ee4 	.word	0x08016ee4
 800bcd0:	080170bc 	.word	0x080170bc
 800bcd4:	0801660c 	.word	0x0801660c

0800bcd8 <netconn_accept>:
 * @return ERR_OK if a new connection has been received or an error
 *                code otherwise
 */
err_t
netconn_accept(struct netconn *conn, struct netconn **new_conn)
{
 800bcd8:	b5f0      	push	{r4, r5, r6, r7, lr}
 800bcda:	b083      	sub	sp, #12
  err_t err;
#if TCP_LISTEN_BACKLOG
  struct api_msg msg;
#endif /* TCP_LISTEN_BACKLOG */

  LWIP_ERROR("netconn_accept: invalid pointer",    (new_conn != NULL),                  return ERR_ARG;);
 800bcdc:	2900      	cmp	r1, #0
 800bcde:	d037      	beq.n	800bd50 <netconn_accept+0x78>
  *new_conn = NULL;
 800bce0:	2600      	movs	r6, #0
 800bce2:	4604      	mov	r4, r0
 800bce4:	460d      	mov	r5, r1
 800bce6:	600e      	str	r6, [r1, #0]
  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return ERR_ARG;);
 800bce8:	b340      	cbz	r0, 800bd3c <netconn_accept+0x64>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", sys_mbox_valid(&conn->acceptmbox),   return ERR_ARG;);
 800bcea:	f100 0764 	add.w	r7, r0, #100	; 0x64
 800bcee:	4638      	mov	r0, r7
 800bcf0:	f007 f9e8 	bl	80130c4 <sys_mbox_valid>
 800bcf4:	b1c0      	cbz	r0, 800bd28 <netconn_accept+0x50>

  err = conn->last_err;
 800bcf6:	f994 0008 	ldrsb.w	r0, [r4, #8]
  if (ERR_IS_FATAL(err)) {
 800bcfa:	f110 0f09 	cmn.w	r0, #9
 800bcfe:	da01      	bge.n	800bd04 <netconn_accept+0x2c>
#else /* LWIP_TCP */
  LWIP_UNUSED_ARG(conn);
  LWIP_UNUSED_ARG(new_conn);
  return ERR_ARG;
#endif /* LWIP_TCP */
}
 800bd00:	b003      	add	sp, #12
 800bd02:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (sys_arch_mbox_fetch(&conn->acceptmbox, (void **)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    NETCONN_SET_SAFE_ERR(conn, ERR_TIMEOUT);
    return ERR_TIMEOUT;
  }
#else
  sys_arch_mbox_fetch(&conn->acceptmbox, (void **)&newconn, 0);
 800bd04:	4638      	mov	r0, r7
 800bd06:	4632      	mov	r2, r6
 800bd08:	a901      	add	r1, sp, #4
 800bd0a:	f007 f9b9 	bl	8013080 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
 800bd0e:	f8d4 30a4 	ldr.w	r3, [r4, #164]	; 0xa4
 800bd12:	b11b      	cbz	r3, 800bd1c <netconn_accept+0x44>
 800bd14:	4632      	mov	r2, r6
 800bd16:	2101      	movs	r1, #1
 800bd18:	4620      	mov	r0, r4
 800bd1a:	4798      	blx	r3

  if (newconn == NULL) {
 800bd1c:	9b01      	ldr	r3, [sp, #4]
 800bd1e:	b30b      	cbz	r3, 800bd64 <netconn_accept+0x8c>
  TCPIP_APIMSG(&msg);
#endif /* TCP_LISTEN_BACKLOG */

  *new_conn = newconn;
  /* don't set conn->last_err: it's only ERR_OK, anyway */
  return ERR_OK;
 800bd20:	2000      	movs	r0, #0
  msg.msg.conn = conn;
  /* don't care for the return value of do_recv */
  TCPIP_APIMSG(&msg);
#endif /* TCP_LISTEN_BACKLOG */

  *new_conn = newconn;
 800bd22:	602b      	str	r3, [r5, #0]
#else /* LWIP_TCP */
  LWIP_UNUSED_ARG(conn);
  LWIP_UNUSED_ARG(new_conn);
  return ERR_ARG;
#endif /* LWIP_TCP */
}
 800bd24:	b003      	add	sp, #12
 800bd26:	bdf0      	pop	{r4, r5, r6, r7, pc}
#endif /* TCP_LISTEN_BACKLOG */

  LWIP_ERROR("netconn_accept: invalid pointer",    (new_conn != NULL),                  return ERR_ARG;);
  *new_conn = NULL;
  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return ERR_ARG;);
  LWIP_ERROR("netconn_accept: invalid acceptmbox", sys_mbox_valid(&conn->acceptmbox),   return ERR_ARG;);
 800bd28:	4b15      	ldr	r3, [pc, #84]	; (800bd80 <netconn_accept+0xa8>)
 800bd2a:	f240 1221 	movw	r2, #289	; 0x121
 800bd2e:	4915      	ldr	r1, [pc, #84]	; (800bd84 <netconn_accept+0xac>)
 800bd30:	4815      	ldr	r0, [pc, #84]	; (800bd88 <netconn_accept+0xb0>)
 800bd32:	f009 f821 	bl	8014d78 <iprintf>
 800bd36:	f06f 000d 	mvn.w	r0, #13
 800bd3a:	e7e1      	b.n	800bd00 <netconn_accept+0x28>
  struct api_msg msg;
#endif /* TCP_LISTEN_BACKLOG */

  LWIP_ERROR("netconn_accept: invalid pointer",    (new_conn != NULL),                  return ERR_ARG;);
  *new_conn = NULL;
  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return ERR_ARG;);
 800bd3c:	4b10      	ldr	r3, [pc, #64]	; (800bd80 <netconn_accept+0xa8>)
 800bd3e:	f44f 7290 	mov.w	r2, #288	; 0x120
 800bd42:	4912      	ldr	r1, [pc, #72]	; (800bd8c <netconn_accept+0xb4>)
 800bd44:	4810      	ldr	r0, [pc, #64]	; (800bd88 <netconn_accept+0xb0>)
 800bd46:	f009 f817 	bl	8014d78 <iprintf>
 800bd4a:	f06f 000d 	mvn.w	r0, #13
 800bd4e:	e7d7      	b.n	800bd00 <netconn_accept+0x28>
  err_t err;
#if TCP_LISTEN_BACKLOG
  struct api_msg msg;
#endif /* TCP_LISTEN_BACKLOG */

  LWIP_ERROR("netconn_accept: invalid pointer",    (new_conn != NULL),                  return ERR_ARG;);
 800bd50:	4b0b      	ldr	r3, [pc, #44]	; (800bd80 <netconn_accept+0xa8>)
 800bd52:	f44f 728f 	mov.w	r2, #286	; 0x11e
 800bd56:	490e      	ldr	r1, [pc, #56]	; (800bd90 <netconn_accept+0xb8>)
 800bd58:	480b      	ldr	r0, [pc, #44]	; (800bd88 <netconn_accept+0xb0>)
 800bd5a:	f009 f80d 	bl	8014d78 <iprintf>
 800bd5e:	f06f 000d 	mvn.w	r0, #13
 800bd62:	e7cd      	b.n	800bd00 <netconn_accept+0x28>
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);

  if (newconn == NULL) {
    /* connection has been aborted */
    NETCONN_SET_SAFE_ERR(conn, ERR_ABRT);
 800bd64:	f7f5 fd06 	bl	8001774 <CPU_SR_Save>
 800bd68:	f994 3008 	ldrsb.w	r3, [r4, #8]
 800bd6c:	3309      	adds	r3, #9
 800bd6e:	bfa4      	itt	ge
 800bd70:	23f6      	movge	r3, #246	; 0xf6
 800bd72:	7223      	strbge	r3, [r4, #8]
 800bd74:	f7f5 fd02 	bl	800177c <CPU_SR_Restore>
    return ERR_ABRT;
 800bd78:	f06f 0009 	mvn.w	r0, #9
 800bd7c:	e7c0      	b.n	800bd00 <netconn_accept+0x28>
 800bd7e:	bf00      	nop
 800bd80:	08016ee4 	.word	0x08016ee4
 800bd84:	0801711c 	.word	0x0801711c
 800bd88:	0801660c 	.word	0x0801660c
 800bd8c:	080170fc 	.word	0x080170fc
 800bd90:	080170dc 	.word	0x080170dc

0800bd94 <netconn_recv_tcp_pbuf>:
 *                memory error or another error)
 *         ERR_ARG if conn is not a TCP netconn
 */
err_t
netconn_recv_tcp_pbuf(struct netconn *conn, struct pbuf **new_buf)
{
 800bd94:	b508      	push	{r3, lr}
  LWIP_ERROR("netconn_recv: invalid conn", (conn != NULL) &&
 800bd96:	b128      	cbz	r0, 800bda4 <netconn_recv_tcp_pbuf+0x10>
 800bd98:	7803      	ldrb	r3, [r0, #0]
 800bd9a:	2b10      	cmp	r3, #16
 800bd9c:	d102      	bne.n	800bda4 <netconn_recv_tcp_pbuf+0x10>
             netconn_type(conn) == NETCONN_TCP, return ERR_ARG;);

  return netconn_recv_data(conn, (void **)new_buf);
}
 800bd9e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
netconn_recv_tcp_pbuf(struct netconn *conn, struct pbuf **new_buf)
{
  LWIP_ERROR("netconn_recv: invalid conn", (conn != NULL) &&
             netconn_type(conn) == NETCONN_TCP, return ERR_ARG;);

  return netconn_recv_data(conn, (void **)new_buf);
 800bda2:	e579      	b.n	800b898 <netconn_recv_data>
 *         ERR_ARG if conn is not a TCP netconn
 */
err_t
netconn_recv_tcp_pbuf(struct netconn *conn, struct pbuf **new_buf)
{
  LWIP_ERROR("netconn_recv: invalid conn", (conn != NULL) &&
 800bda4:	4b04      	ldr	r3, [pc, #16]	; (800bdb8 <netconn_recv_tcp_pbuf+0x24>)
 800bda6:	f44f 72dc 	mov.w	r2, #440	; 0x1b8
 800bdaa:	4904      	ldr	r1, [pc, #16]	; (800bdbc <netconn_recv_tcp_pbuf+0x28>)
 800bdac:	4804      	ldr	r0, [pc, #16]	; (800bdc0 <netconn_recv_tcp_pbuf+0x2c>)
 800bdae:	f008 ffe3 	bl	8014d78 <iprintf>
             netconn_type(conn) == NETCONN_TCP, return ERR_ARG;);

  return netconn_recv_data(conn, (void **)new_buf);
}
 800bdb2:	f06f 000d 	mvn.w	r0, #13
 800bdb6:	bd08      	pop	{r3, pc}
 800bdb8:	08016ee4 	.word	0x08016ee4
 800bdbc:	08016f18 	.word	0x08016f18
 800bdc0:	0801660c 	.word	0x0801660c

0800bdc4 <netconn_recv>:
 * @return ERR_OK if data has been received, an error code otherwise (timeout,
 *                memory error or another error)
 */
err_t
netconn_recv(struct netconn *conn, struct netbuf **new_buf)
{
 800bdc4:	b570      	push	{r4, r5, r6, lr}
 800bdc6:	b082      	sub	sp, #8
#if LWIP_TCP
  struct netbuf *buf = NULL;
  err_t err;
#endif /* LWIP_TCP */

  LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
 800bdc8:	2900      	cmp	r1, #0
 800bdca:	d059      	beq.n	800be80 <netconn_recv+0xbc>
  *new_buf = NULL;
 800bdcc:	2600      	movs	r6, #0
 800bdce:	4604      	mov	r4, r0
 800bdd0:	460d      	mov	r5, r1
 800bdd2:	600e      	str	r6, [r1, #0]
  LWIP_ERROR("netconn_recv: invalid conn",    (conn != NULL),    return ERR_ARG;);
 800bdd4:	2800      	cmp	r0, #0
 800bdd6:	d049      	beq.n	800be6c <netconn_recv+0xa8>
  LWIP_ERROR("netconn_accept: invalid recvmbox", sys_mbox_valid(&conn->recvmbox), return ERR_CONN;);
 800bdd8:	3034      	adds	r0, #52	; 0x34
 800bdda:	f007 f973 	bl	80130c4 <sys_mbox_valid>
 800bdde:	2800      	cmp	r0, #0
 800bde0:	d031      	beq.n	800be46 <netconn_recv+0x82>

#if LWIP_TCP
#if (LWIP_UDP || LWIP_RAW)
  if (conn->type == NETCONN_TCP)
 800bde2:	7823      	ldrb	r3, [r4, #0]
 800bde4:	2b10      	cmp	r3, #16
 800bde6:	d005      	beq.n	800bdf4 <netconn_recv+0x30>
#if LWIP_TCP && (LWIP_UDP || LWIP_RAW)
  else
#endif /* LWIP_TCP && (LWIP_UDP || LWIP_RAW) */
  {
#if (LWIP_UDP || LWIP_RAW)
    return netconn_recv_data(conn, (void **)new_buf);
 800bde8:	4629      	mov	r1, r5
 800bdea:	4620      	mov	r0, r4
 800bdec:	f7ff fd54 	bl	800b898 <netconn_recv_data>
#endif /* (LWIP_UDP || LWIP_RAW) */
  }
}
 800bdf0:	b002      	add	sp, #8
 800bdf2:	bd70      	pop	{r4, r5, r6, pc}
#endif /* (LWIP_UDP || LWIP_RAW) */
  {
    struct pbuf *p = NULL;
    /* This is not a listening netconn, since recvmbox is set */

    buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
 800bdf4:	2006      	movs	r0, #6
#if LWIP_TCP
#if (LWIP_UDP || LWIP_RAW)
  if (conn->type == NETCONN_TCP)
#endif /* (LWIP_UDP || LWIP_RAW) */
  {
    struct pbuf *p = NULL;
 800bdf6:	9601      	str	r6, [sp, #4]
    /* This is not a listening netconn, since recvmbox is set */

    buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
 800bdf8:	f003 ff4a 	bl	800fc90 <memp_malloc>
    if (buf == NULL) {
 800bdfc:	4606      	mov	r6, r0
 800bdfe:	b1a8      	cbz	r0, 800be2c <netconn_recv+0x68>
      NETCONN_SET_SAFE_ERR(conn, ERR_MEM);
      return ERR_MEM;
    }

    err = netconn_recv_data(conn, (void **)&p);
 800be00:	4620      	mov	r0, r4
 800be02:	a901      	add	r1, sp, #4
 800be04:	f7ff fd48 	bl	800b898 <netconn_recv_data>
    if (err != ERR_OK) {
 800be08:	4604      	mov	r4, r0
 800be0a:	b948      	cbnz	r0, 800be20 <netconn_recv+0x5c>
      memp_free(MEMP_NETBUF, buf);
      return err;
    }
    LWIP_ASSERT("p != NULL", p != NULL);
 800be0c:	9b01      	ldr	r3, [sp, #4]
 800be0e:	b323      	cbz	r3, 800be5a <netconn_recv+0x96>

    buf->p = p;
    buf->ptr = p;
    buf->port = 0;
 800be10:	2000      	movs	r0, #0
      memp_free(MEMP_NETBUF, buf);
      return err;
    }
    LWIP_ASSERT("p != NULL", p != NULL);

    buf->p = p;
 800be12:	6033      	str	r3, [r6, #0]
    buf->ptr = p;
 800be14:	6073      	str	r3, [r6, #4]
    buf->port = 0;
 800be16:	81b0      	strh	r0, [r6, #12]
    ip_addr_set_any(&buf->addr);
 800be18:	60b0      	str	r0, [r6, #8]
    *new_buf = buf;
 800be1a:	602e      	str	r6, [r5, #0]
  {
#if (LWIP_UDP || LWIP_RAW)
    return netconn_recv_data(conn, (void **)new_buf);
#endif /* (LWIP_UDP || LWIP_RAW) */
  }
}
 800be1c:	b002      	add	sp, #8
 800be1e:	bd70      	pop	{r4, r5, r6, pc}
      return ERR_MEM;
    }

    err = netconn_recv_data(conn, (void **)&p);
    if (err != ERR_OK) {
      memp_free(MEMP_NETBUF, buf);
 800be20:	2006      	movs	r0, #6
 800be22:	4631      	mov	r1, r6
 800be24:	f003 ff6a 	bl	800fcfc <memp_free>
      return err;
 800be28:	4620      	mov	r0, r4
 800be2a:	e7e1      	b.n	800bdf0 <netconn_recv+0x2c>
    struct pbuf *p = NULL;
    /* This is not a listening netconn, since recvmbox is set */

    buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
    if (buf == NULL) {
      NETCONN_SET_SAFE_ERR(conn, ERR_MEM);
 800be2c:	f7f5 fca2 	bl	8001774 <CPU_SR_Save>
 800be30:	f994 3008 	ldrsb.w	r3, [r4, #8]
 800be34:	3309      	adds	r3, #9
 800be36:	bfa4      	itt	ge
 800be38:	23ff      	movge	r3, #255	; 0xff
 800be3a:	7223      	strbge	r3, [r4, #8]
 800be3c:	f7f5 fc9e 	bl	800177c <CPU_SR_Restore>
      return ERR_MEM;
 800be40:	f04f 30ff 	mov.w	r0, #4294967295
 800be44:	e7d4      	b.n	800bdf0 <netconn_recv+0x2c>
#endif /* LWIP_TCP */

  LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
  *new_buf = NULL;
  LWIP_ERROR("netconn_recv: invalid conn",    (conn != NULL),    return ERR_ARG;);
  LWIP_ERROR("netconn_accept: invalid recvmbox", sys_mbox_valid(&conn->recvmbox), return ERR_CONN;);
 800be46:	4b13      	ldr	r3, [pc, #76]	; (800be94 <netconn_recv+0xd0>)
 800be48:	f44f 72e8 	mov.w	r2, #464	; 0x1d0
 800be4c:	4912      	ldr	r1, [pc, #72]	; (800be98 <netconn_recv+0xd4>)
 800be4e:	4813      	ldr	r0, [pc, #76]	; (800be9c <netconn_recv+0xd8>)
 800be50:	f008 ff92 	bl	8014d78 <iprintf>
 800be54:	f06f 000c 	mvn.w	r0, #12
 800be58:	e7ca      	b.n	800bdf0 <netconn_recv+0x2c>
    err = netconn_recv_data(conn, (void **)&p);
    if (err != ERR_OK) {
      memp_free(MEMP_NETBUF, buf);
      return err;
    }
    LWIP_ASSERT("p != NULL", p != NULL);
 800be5a:	4b0e      	ldr	r3, [pc, #56]	; (800be94 <netconn_recv+0xd0>)
 800be5c:	f240 12e5 	movw	r2, #485	; 0x1e5
 800be60:	490f      	ldr	r1, [pc, #60]	; (800bea0 <netconn_recv+0xdc>)
 800be62:	480e      	ldr	r0, [pc, #56]	; (800be9c <netconn_recv+0xd8>)
 800be64:	f008 ff88 	bl	8014d78 <iprintf>
 800be68:	9b01      	ldr	r3, [sp, #4]
 800be6a:	e7d1      	b.n	800be10 <netconn_recv+0x4c>
  err_t err;
#endif /* LWIP_TCP */

  LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
  *new_buf = NULL;
  LWIP_ERROR("netconn_recv: invalid conn",    (conn != NULL),    return ERR_ARG;);
 800be6c:	4b09      	ldr	r3, [pc, #36]	; (800be94 <netconn_recv+0xd0>)
 800be6e:	f240 12cf 	movw	r2, #463	; 0x1cf
 800be72:	490c      	ldr	r1, [pc, #48]	; (800bea4 <netconn_recv+0xe0>)
 800be74:	4809      	ldr	r0, [pc, #36]	; (800be9c <netconn_recv+0xd8>)
 800be76:	f008 ff7f 	bl	8014d78 <iprintf>
 800be7a:	f06f 000d 	mvn.w	r0, #13
 800be7e:	e7b7      	b.n	800bdf0 <netconn_recv+0x2c>
#if LWIP_TCP
  struct netbuf *buf = NULL;
  err_t err;
#endif /* LWIP_TCP */

  LWIP_ERROR("netconn_recv: invalid pointer", (new_buf != NULL), return ERR_ARG;);
 800be80:	4b04      	ldr	r3, [pc, #16]	; (800be94 <netconn_recv+0xd0>)
 800be82:	f240 12cd 	movw	r2, #461	; 0x1cd
 800be86:	4908      	ldr	r1, [pc, #32]	; (800bea8 <netconn_recv+0xe4>)
 800be88:	4804      	ldr	r0, [pc, #16]	; (800be9c <netconn_recv+0xd8>)
 800be8a:	f008 ff75 	bl	8014d78 <iprintf>
 800be8e:	f06f 000d 	mvn.w	r0, #13
 800be92:	e7ad      	b.n	800bdf0 <netconn_recv+0x2c>
 800be94:	08016ee4 	.word	0x08016ee4
 800be98:	08016f34 	.word	0x08016f34
 800be9c:	0801660c 	.word	0x0801660c
 800bea0:	080172e8 	.word	0x080172e8
 800bea4:	08016f18 	.word	0x08016f18
 800bea8:	08016ef8 	.word	0x08016ef8

0800beac <netconn_recved>:
 */
void
netconn_recved(struct netconn *conn, u32_t length)
{
#if LWIP_TCP
  if ((conn != NULL) && (conn->type == NETCONN_TCP) &&
 800beac:	b110      	cbz	r0, 800beb4 <netconn_recved+0x8>
 800beae:	7803      	ldrb	r3, [r0, #0]
 800beb0:	2b10      	cmp	r3, #16
 800beb2:	d000      	beq.n	800beb6 <netconn_recved+0xa>
 800beb4:	4770      	bx	lr
 800beb6:	f890 3098 	ldrb.w	r3, [r0, #152]	; 0x98
 800beba:	071b      	lsls	r3, r3, #28
 800bebc:	d5fa      	bpl.n	800beb4 <netconn_recved+0x8>
 800bebe:	4603      	mov	r3, r0
 * @param conn the netconn for which to update the receive window
 * @param length amount of data processed (ATTENTION: this must be accurate!)
 */
void
netconn_recved(struct netconn *conn, u32_t length)
{
 800bec0:	b500      	push	{lr}
      (netconn_get_noautorecved(conn))) {
    struct api_msg msg;
    /* Let the stack know that we have taken the data. */
    /* TODO: Speedup: Don't block and wait for the answer here
       (to prevent multiple thread-switches). */
    msg.function = do_recv;
 800bec2:	4a05      	ldr	r2, [pc, #20]	; (800bed8 <netconn_recved+0x2c>)
 * @param conn the netconn for which to update the receive window
 * @param length amount of data processed (ATTENTION: this must be accurate!)
 */
void
netconn_recved(struct netconn *conn, u32_t length)
{
 800bec4:	b087      	sub	sp, #28
       (to prevent multiple thread-switches). */
    msg.function = do_recv;
    msg.msg.conn = conn;
    msg.msg.msg.r.len = length;
    /* don't care for the return value of do_recv */
    TCPIP_APIMSG(&msg);
 800bec6:	4668      	mov	r0, sp
    struct api_msg msg;
    /* Let the stack know that we have taken the data. */
    /* TODO: Speedup: Don't block and wait for the answer here
       (to prevent multiple thread-switches). */
    msg.function = do_recv;
    msg.msg.conn = conn;
 800bec8:	9301      	str	r3, [sp, #4]
    msg.msg.msg.r.len = length;
 800beca:	9103      	str	r1, [sp, #12]
      (netconn_get_noautorecved(conn))) {
    struct api_msg msg;
    /* Let the stack know that we have taken the data. */
    /* TODO: Speedup: Don't block and wait for the answer here
       (to prevent multiple thread-switches). */
    msg.function = do_recv;
 800becc:	9200      	str	r2, [sp, #0]
    msg.msg.conn = conn;
    msg.msg.msg.r.len = length;
    /* don't care for the return value of do_recv */
    TCPIP_APIMSG(&msg);
 800bece:	f7ff faeb 	bl	800b4a8 <tcpip_apimsg>
  }
#else /* LWIP_TCP */
  LWIP_UNUSED_ARG(conn);
  LWIP_UNUSED_ARG(length);
#endif /* LWIP_TCP */
}
 800bed2:	b007      	add	sp, #28
 800bed4:	f85d fb04 	ldr.w	pc, [sp], #4
 800bed8:	0800cfd5 	.word	0x0800cfd5

0800bedc <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
 800bedc:	b530      	push	{r4, r5, lr}
 800bede:	b087      	sub	sp, #28
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
 800bee0:	b1a0      	cbz	r0, 800bf0c <netconn_send+0x30>
 800bee2:	4604      	mov	r4, r0

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %"U16_F" bytes\n", buf->p->tot_len));
  msg.function = do_send;
 800bee4:	4b0e      	ldr	r3, [pc, #56]	; (800bf20 <netconn_send+0x44>)
  msg.msg.conn = conn;
  msg.msg.msg.b = buf;
  err = TCPIP_APIMSG(&msg);
 800bee6:	4668      	mov	r0, sp
  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %"U16_F" bytes\n", buf->p->tot_len));
  msg.function = do_send;
  msg.msg.conn = conn;
  msg.msg.msg.b = buf;
 800bee8:	9103      	str	r1, [sp, #12]
  err_t err;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %"U16_F" bytes\n", buf->p->tot_len));
  msg.function = do_send;
 800beea:	9300      	str	r3, [sp, #0]
  msg.msg.conn = conn;
 800beec:	9401      	str	r4, [sp, #4]
  msg.msg.msg.b = buf;
  err = TCPIP_APIMSG(&msg);
 800beee:	f7ff fadb 	bl	800b4a8 <tcpip_apimsg>
 800bef2:	4605      	mov	r5, r0

  NETCONN_SET_SAFE_ERR(conn, err);
 800bef4:	f7f5 fc3e 	bl	8001774 <CPU_SR_Save>
 800bef8:	f994 3008 	ldrsb.w	r3, [r4, #8]
 800befc:	3309      	adds	r3, #9
 800befe:	bfa8      	it	ge
 800bf00:	7225      	strbge	r5, [r4, #8]
 800bf02:	f7f5 fc3b 	bl	800177c <CPU_SR_Restore>
  return err;
 800bf06:	4628      	mov	r0, r5
}
 800bf08:	b007      	add	sp, #28
 800bf0a:	bd30      	pop	{r4, r5, pc}
netconn_send(struct netconn *conn, struct netbuf *buf)
{
  struct api_msg msg;
  err_t err;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
 800bf0c:	4b05      	ldr	r3, [pc, #20]	; (800bf24 <netconn_send+0x48>)
 800bf0e:	f44f 720f 	mov.w	r2, #572	; 0x23c
 800bf12:	4905      	ldr	r1, [pc, #20]	; (800bf28 <netconn_send+0x4c>)
 800bf14:	4805      	ldr	r0, [pc, #20]	; (800bf2c <netconn_send+0x50>)
 800bf16:	f008 ff2f 	bl	8014d78 <iprintf>
 800bf1a:	f06f 000d 	mvn.w	r0, #13
 800bf1e:	e7f3      	b.n	800bf08 <netconn_send+0x2c>
 800bf20:	0800cf39 	.word	0x0800cf39
 800bf24:	08016ee4 	.word	0x08016ee4
 800bf28:	08017140 	.word	0x08017140
 800bf2c:	0801660c 	.word	0x0801660c

0800bf30 <netconn_sendto>:
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_sendto(struct netconn *conn, struct netbuf *buf, ip_addr_t *addr, u16_t port)
{
  if (buf != NULL) {
 800bf30:	b129      	cbz	r1, 800bf3e <netconn_sendto+0xe>
    ip_addr_set(&buf->addr, addr);
 800bf32:	b102      	cbz	r2, 800bf36 <netconn_sendto+0x6>
 800bf34:	6812      	ldr	r2, [r2, #0]
 800bf36:	608a      	str	r2, [r1, #8]
    buf->port = port;
 800bf38:	818b      	strh	r3, [r1, #12]
    return netconn_send(conn, buf);
 800bf3a:	f7ff bfcf 	b.w	800bedc <netconn_send>
  }
  return ERR_VAL;
}
 800bf3e:	f06f 0005 	mvn.w	r0, #5
 800bf42:	4770      	bx	lr

0800bf44 <netconn_write_partly>:
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write_partly(struct netconn *conn, const void *dataptr, size_t size,
                     u8_t apiflags, size_t *bytes_written)
{
 800bf44:	b530      	push	{r4, r5, lr}
 800bf46:	b089      	sub	sp, #36	; 0x24
  struct api_msg msg;
  err_t err;
  u8_t dontblock;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
 800bf48:	2800      	cmp	r0, #0
 800bf4a:	d04f      	beq.n	800bfec <netconn_write_partly+0xa8>
 800bf4c:	4604      	mov	r4, r0
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
 800bf4e:	7800      	ldrb	r0, [r0, #0]
 800bf50:	2810      	cmp	r0, #16
 800bf52:	d13e      	bne.n	800bfd2 <netconn_write_partly+0x8e>
  if (size == 0) {
 800bf54:	2a00      	cmp	r2, #0
 800bf56:	d035      	beq.n	800bfc4 <netconn_write_partly+0x80>
    return ERR_OK;
  }
  dontblock = netconn_is_nonblocking(conn) || (apiflags & NETCONN_DONTBLOCK);
 800bf58:	f894 0098 	ldrb.w	r0, [r4, #152]	; 0x98
 800bf5c:	0785      	lsls	r5, r0, #30
 800bf5e:	d51a      	bpl.n	800bf96 <netconn_write_partly+0x52>
  if (dontblock && !bytes_written) {
 800bf60:	980c      	ldr	r0, [sp, #48]	; 0x30
 800bf62:	2800      	cmp	r0, #0
 800bf64:	d03f      	beq.n	800bfe6 <netconn_write_partly+0xa2>
       it has no way to return the number of bytes written. */
    return ERR_VAL;
  }

  /* non-blocking write sends as much  */
  msg.function = do_write;
 800bf66:	4d26      	ldr	r5, [pc, #152]	; (800c000 <netconn_write_partly+0xbc>)
#endif /* LWIP_SO_SNDTIMEO */

  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  err = TCPIP_APIMSG(&msg);
 800bf68:	a802      	add	r0, sp, #8
       it has no way to return the number of bytes written. */
    return ERR_VAL;
  }

  /* non-blocking write sends as much  */
  msg.function = do_write;
 800bf6a:	9502      	str	r5, [sp, #8]
  msg.msg.conn = conn;
 800bf6c:	9403      	str	r4, [sp, #12]
  msg.msg.msg.w.dataptr = dataptr;
 800bf6e:	9105      	str	r1, [sp, #20]
  msg.msg.msg.w.apiflags = apiflags;
 800bf70:	f88d 301c 	strb.w	r3, [sp, #28]
  msg.msg.msg.w.len = size;
 800bf74:	9206      	str	r2, [sp, #24]
#endif /* LWIP_SO_SNDTIMEO */

  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  err = TCPIP_APIMSG(&msg);
 800bf76:	f7ff fa97 	bl	800b4a8 <tcpip_apimsg>
  if ((err == ERR_OK) && (bytes_written != NULL)) {
 800bf7a:	4605      	mov	r5, r0
 800bf7c:	b328      	cbz	r0, 800bfca <netconn_write_partly+0x86>
      /* blocking call succeeded: all data has been sent if it */
      *bytes_written = size;
    }
  }

  NETCONN_SET_SAFE_ERR(conn, err);
 800bf7e:	f7f5 fbf9 	bl	8001774 <CPU_SR_Save>
 800bf82:	f994 3008 	ldrsb.w	r3, [r4, #8]
 800bf86:	3309      	adds	r3, #9
 800bf88:	bfa8      	it	ge
 800bf8a:	7225      	strbge	r5, [r4, #8]
 800bf8c:	f7f5 fbf6 	bl	800177c <CPU_SR_Restore>
  return err;
 800bf90:	4628      	mov	r0, r5
}
 800bf92:	b009      	add	sp, #36	; 0x24
 800bf94:	bd30      	pop	{r4, r5, pc}
  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  if (size == 0) {
    return ERR_OK;
  }
  dontblock = netconn_is_nonblocking(conn) || (apiflags & NETCONN_DONTBLOCK);
 800bf96:	0758      	lsls	r0, r3, #29
 800bf98:	d4e2      	bmi.n	800bf60 <netconn_write_partly+0x1c>
       it has no way to return the number of bytes written. */
    return ERR_VAL;
  }

  /* non-blocking write sends as much  */
  msg.function = do_write;
 800bf9a:	4d19      	ldr	r5, [pc, #100]	; (800c000 <netconn_write_partly+0xbc>)
#endif /* LWIP_SO_SNDTIMEO */

  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  err = TCPIP_APIMSG(&msg);
 800bf9c:	a802      	add	r0, sp, #8
       it has no way to return the number of bytes written. */
    return ERR_VAL;
  }

  /* non-blocking write sends as much  */
  msg.function = do_write;
 800bf9e:	9502      	str	r5, [sp, #8]
  msg.msg.conn = conn;
 800bfa0:	9403      	str	r4, [sp, #12]
  msg.msg.msg.w.dataptr = dataptr;
 800bfa2:	9105      	str	r1, [sp, #20]
  msg.msg.msg.w.apiflags = apiflags;
 800bfa4:	f88d 301c 	strb.w	r3, [sp, #28]
  msg.msg.msg.w.len = size;
 800bfa8:	9206      	str	r2, [sp, #24]
 800bfaa:	9201      	str	r2, [sp, #4]
#endif /* LWIP_SO_SNDTIMEO */

  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  err = TCPIP_APIMSG(&msg);
 800bfac:	f7ff fa7c 	bl	800b4a8 <tcpip_apimsg>
  if ((err == ERR_OK) && (bytes_written != NULL)) {
 800bfb0:	4605      	mov	r5, r0
 800bfb2:	2800      	cmp	r0, #0
 800bfb4:	d1e3      	bne.n	800bf7e <netconn_write_partly+0x3a>
 800bfb6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800bfb8:	9a01      	ldr	r2, [sp, #4]
 800bfba:	2b00      	cmp	r3, #0
 800bfbc:	d0df      	beq.n	800bf7e <netconn_write_partly+0x3a>
       ) {
      /* nonblocking write: maybe the data has been sent partly */
      *bytes_written = msg.msg.msg.w.len;
    } else {
      /* blocking call succeeded: all data has been sent if it */
      *bytes_written = size;
 800bfbe:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800bfc0:	601a      	str	r2, [r3, #0]
 800bfc2:	e7dc      	b.n	800bf7e <netconn_write_partly+0x3a>
  u8_t dontblock;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  if (size == 0) {
    return ERR_OK;
 800bfc4:	4610      	mov	r0, r2
    }
  }

  NETCONN_SET_SAFE_ERR(conn, err);
  return err;
}
 800bfc6:	b009      	add	sp, #36	; 0x24
 800bfc8:	bd30      	pop	{r4, r5, pc}
#if LWIP_SO_SNDTIMEO
        || (conn->send_timeout != 0)
#endif /* LWIP_SO_SNDTIMEO */
       ) {
      /* nonblocking write: maybe the data has been sent partly */
      *bytes_written = msg.msg.msg.w.len;
 800bfca:	9b06      	ldr	r3, [sp, #24]
 800bfcc:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 800bfce:	6013      	str	r3, [r2, #0]
 800bfd0:	e7d5      	b.n	800bf7e <netconn_write_partly+0x3a>
  struct api_msg msg;
  err_t err;
  u8_t dontblock;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
 800bfd2:	4b0c      	ldr	r3, [pc, #48]	; (800c004 <netconn_write_partly+0xc0>)
 800bfd4:	f240 225e 	movw	r2, #606	; 0x25e
 800bfd8:	490b      	ldr	r1, [pc, #44]	; (800c008 <netconn_write_partly+0xc4>)
 800bfda:	480c      	ldr	r0, [pc, #48]	; (800c00c <netconn_write_partly+0xc8>)
 800bfdc:	f008 fecc 	bl	8014d78 <iprintf>
 800bfe0:	f06f 0005 	mvn.w	r0, #5
 800bfe4:	e7d5      	b.n	800bf92 <netconn_write_partly+0x4e>
  }
  dontblock = netconn_is_nonblocking(conn) || (apiflags & NETCONN_DONTBLOCK);
  if (dontblock && !bytes_written) {
    /* This implies netconn_write() cannot be used for non-blocking send, since
       it has no way to return the number of bytes written. */
    return ERR_VAL;
 800bfe6:	f06f 0005 	mvn.w	r0, #5
 800bfea:	e7d2      	b.n	800bf92 <netconn_write_partly+0x4e>
{
  struct api_msg msg;
  err_t err;
  u8_t dontblock;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
 800bfec:	4b05      	ldr	r3, [pc, #20]	; (800c004 <netconn_write_partly+0xc0>)
 800bfee:	f240 225d 	movw	r2, #605	; 0x25d
 800bff2:	4907      	ldr	r1, [pc, #28]	; (800c010 <netconn_write_partly+0xcc>)
 800bff4:	4805      	ldr	r0, [pc, #20]	; (800c00c <netconn_write_partly+0xc8>)
 800bff6:	f008 febf 	bl	8014d78 <iprintf>
 800bffa:	f06f 000d 	mvn.w	r0, #13
 800bffe:	e7c8      	b.n	800bf92 <netconn_write_partly+0x4e>
 800c000:	0800d021 	.word	0x0800d021
 800c004:	08016ee4 	.word	0x08016ee4
 800c008:	08017178 	.word	0x08017178
 800c00c:	0801660c 	.word	0x0801660c
 800c010:	0801715c 	.word	0x0801715c

0800c014 <netconn_close>:
 */
err_t
netconn_close(struct netconn *conn)
{
  /* shutting down both ends is the same as closing */
  return netconn_close_shutdown(conn, NETCONN_SHUT_RDWR);
 800c014:	2103      	movs	r1, #3
 800c016:	e4d5      	b.n	800b9c4 <netconn_close_shutdown>

0800c018 <netconn_shutdown>:
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_shutdown(struct netconn *conn, u8_t shut_rx, u8_t shut_tx)
{
  return netconn_close_shutdown(conn, (shut_rx ? NETCONN_SHUT_RD : 0) | (shut_tx ? NETCONN_SHUT_WR : 0));
 800c018:	2a00      	cmp	r2, #0
 800c01a:	bf14      	ite	ne
 800c01c:	2302      	movne	r3, #2
 800c01e:	2300      	moveq	r3, #0
 800c020:	2900      	cmp	r1, #0
 800c022:	bf0c      	ite	eq
 800c024:	4619      	moveq	r1, r3
 800c026:	f043 0101 	orrne.w	r1, r3, #1
 800c02a:	e4cb      	b.n	800b9c4 <netconn_close_shutdown>

0800c02c <recv_udp>:
 * @see udp.h (struct udp_pcb.recv) for parameters
 */
static void
recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
   ip_addr_t *addr, u16_t port)
{
 800c02c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800c030:	4604      	mov	r4, r0
 800c032:	4616      	mov	r6, r2
 800c034:	461f      	mov	r7, r3
 800c036:	f8bd 9020 	ldrh.w	r9, [sp, #32]
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
 800c03a:	460d      	mov	r5, r1
 800c03c:	b389      	cbz	r1, 800c0a2 <recv_udp+0x76>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
 800c03e:	2c00      	cmp	r4, #0
 800c040:	d03b      	beq.n	800c0ba <recv_udp+0x8e>
  conn = (struct netconn *)arg;
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
 800c042:	6863      	ldr	r3, [r4, #4]
 800c044:	429d      	cmp	r5, r3
 800c046:	d005      	beq.n	800c054 <recv_udp+0x28>
 800c048:	4b20      	ldr	r3, [pc, #128]	; (800c0cc <recv_udp+0xa0>)
 800c04a:	229e      	movs	r2, #158	; 0x9e
 800c04c:	4920      	ldr	r1, [pc, #128]	; (800c0d0 <recv_udp+0xa4>)
 800c04e:	4821      	ldr	r0, [pc, #132]	; (800c0d4 <recv_udp+0xa8>)
 800c050:	f008 fe92 	bl	8014d78 <iprintf>
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn == NULL) || !sys_mbox_valid(&conn->recvmbox) ||
      ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn == NULL) || !sys_mbox_valid(&conn->recvmbox)) {
 800c054:	f104 0834 	add.w	r8, r4, #52	; 0x34
 800c058:	4640      	mov	r0, r8
 800c05a:	f007 f833 	bl	80130c4 <sys_mbox_valid>
 800c05e:	b920      	cbnz	r0, 800c06a <recv_udp+0x3e>
#endif /* LWIP_SO_RCVBUF */
    pbuf_free(p);
 800c060:	4630      	mov	r0, r6
    SYS_ARCH_INC(conn->recv_avail, len);
#endif /* LWIP_SO_RCVBUF */
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  }
}
 800c062:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  if ((conn == NULL) || !sys_mbox_valid(&conn->recvmbox) ||
      ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn == NULL) || !sys_mbox_valid(&conn->recvmbox)) {
#endif /* LWIP_SO_RCVBUF */
    pbuf_free(p);
 800c066:	f003 bfdf 	b.w	8010028 <pbuf_free>
    return;
  }

  buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
 800c06a:	2006      	movs	r0, #6
 800c06c:	f003 fe10 	bl	800fc90 <memp_malloc>
  if (buf == NULL) {
 800c070:	4605      	mov	r5, r0
 800c072:	2800      	cmp	r0, #0
 800c074:	d0f4      	beq.n	800c060 <recv_udp+0x34>
    pbuf_free(p);
    return;
  } else {
    buf->p = p;
 800c076:	6006      	str	r6, [r0, #0]
    buf->ptr = p;
 800c078:	6046      	str	r6, [r0, #4]
    ip_addr_set(&buf->addr, addr);
 800c07a:	b107      	cbz	r7, 800c07e <recv_udp+0x52>
 800c07c:	683f      	ldr	r7, [r7, #0]
 800c07e:	60af      	str	r7, [r5, #8]
    buf->port = port;
 800c080:	f8a5 900c 	strh.w	r9, [r5, #12]
    }
#endif /* LWIP_NETBUF_RECVINFO */
  }

  len = p->tot_len;
  if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
 800c084:	4640      	mov	r0, r8
 800c086:	4629      	mov	r1, r5
      buf->toport_chksum = udphdr->dest;
    }
#endif /* LWIP_NETBUF_RECVINFO */
  }

  len = p->tot_len;
 800c088:	8936      	ldrh	r6, [r6, #8]
  if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
 800c08a:	f006 ffdf 	bl	801304c <sys_mbox_trypost>
 800c08e:	b978      	cbnz	r0, 800c0b0 <recv_udp+0x84>
  } else {
#if LWIP_SO_RCVBUF
    SYS_ARCH_INC(conn->recv_avail, len);
#endif /* LWIP_SO_RCVBUF */
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
 800c090:	f8d4 30a4 	ldr.w	r3, [r4, #164]	; 0xa4
 800c094:	b1c3      	cbz	r3, 800c0c8 <recv_udp+0x9c>
 800c096:	4632      	mov	r2, r6
 800c098:	4601      	mov	r1, r0
 800c09a:	4620      	mov	r0, r4
  }
}
 800c09c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  } else {
#if LWIP_SO_RCVBUF
    SYS_ARCH_INC(conn->recv_avail, len);
#endif /* LWIP_SO_RCVBUF */
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
 800c0a0:	4718      	bx	r3
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
 800c0a2:	4b0a      	ldr	r3, [pc, #40]	; (800c0cc <recv_udp+0xa0>)
 800c0a4:	229b      	movs	r2, #155	; 0x9b
 800c0a6:	490c      	ldr	r1, [pc, #48]	; (800c0d8 <recv_udp+0xac>)
 800c0a8:	480a      	ldr	r0, [pc, #40]	; (800c0d4 <recv_udp+0xa8>)
 800c0aa:	f008 fe65 	bl	8014d78 <iprintf>
 800c0ae:	e7c6      	b.n	800c03e <recv_udp+0x12>
#endif /* LWIP_NETBUF_RECVINFO */
  }

  len = p->tot_len;
  if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
    netbuf_delete(buf);
 800c0b0:	4628      	mov	r0, r5
    SYS_ARCH_INC(conn->recv_avail, len);
#endif /* LWIP_SO_RCVBUF */
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  }
}
 800c0b2:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
#endif /* LWIP_NETBUF_RECVINFO */
  }

  len = p->tot_len;
  if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
    netbuf_delete(buf);
 800c0b6:	f003 be53 	b.w	800fd60 <netbuf_delete>
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
 800c0ba:	4b04      	ldr	r3, [pc, #16]	; (800c0cc <recv_udp+0xa0>)
 800c0bc:	229c      	movs	r2, #156	; 0x9c
 800c0be:	4907      	ldr	r1, [pc, #28]	; (800c0dc <recv_udp+0xb0>)
 800c0c0:	4804      	ldr	r0, [pc, #16]	; (800c0d4 <recv_udp+0xa8>)
 800c0c2:	f008 fe59 	bl	8014d78 <iprintf>
 800c0c6:	e7bc      	b.n	800c042 <recv_udp+0x16>
 800c0c8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800c0cc:	0801719c 	.word	0x0801719c
 800c0d0:	080171f4 	.word	0x080171f4
 800c0d4:	0801660c 	.word	0x0801660c
 800c0d8:	080171b0 	.word	0x080171b0
 800c0dc:	080171d4 	.word	0x080171d4

0800c0e0 <recv_raw>:
  struct netconn *conn;

  LWIP_UNUSED_ARG(addr);
  conn = (struct netconn *)arg;

  if ((conn != NULL) && sys_mbox_valid(&conn->recvmbox)) {
 800c0e0:	2800      	cmp	r0, #0
 800c0e2:	d039      	beq.n	800c158 <recv_raw+0x78>
 * @see raw.h (struct raw_pcb.recv) for parameters and return value
 */
static u8_t
recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
    ip_addr_t *addr)
{
 800c0e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  struct netconn *conn;

  LWIP_UNUSED_ARG(addr);
  conn = (struct netconn *)arg;

  if ((conn != NULL) && sys_mbox_valid(&conn->recvmbox)) {
 800c0e8:	f100 0734 	add.w	r7, r0, #52	; 0x34
 800c0ec:	4605      	mov	r5, r0
 800c0ee:	4638      	mov	r0, r7
 800c0f0:	4614      	mov	r4, r2
 800c0f2:	460e      	mov	r6, r1
 800c0f4:	f006 ffe6 	bl	80130c4 <sys_mbox_valid>
 800c0f8:	b910      	cbnz	r0, 800c100 <recv_raw+0x20>
      }
    }
  }

  return 0; /* do not eat the packet */
}
 800c0fa:	2000      	movs	r0, #0
 800c0fc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize) {
      return 0;
    }
#endif /* LWIP_SO_RCVBUF */
    /* copy the whole packet into new pbufs */
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
 800c100:	2200      	movs	r2, #0
 800c102:	8921      	ldrh	r1, [r4, #8]
 800c104:	2003      	movs	r0, #3
 800c106:	f003 ffe7 	bl	80100d8 <pbuf_alloc>
    if(q != NULL) {
 800c10a:	4680      	mov	r8, r0
 800c10c:	2800      	cmp	r0, #0
 800c10e:	d0f4      	beq.n	800c0fa <recv_raw+0x1a>
      if (pbuf_copy(q, p) != ERR_OK) {
 800c110:	4621      	mov	r1, r4
 800c112:	f004 f9cb 	bl	80104ac <pbuf_copy>
 800c116:	bb08      	cbnz	r0, 800c15c <recv_raw+0x7c>
      }
    }

    if (q != NULL) {
      u16_t len;
      buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
 800c118:	2006      	movs	r0, #6
 800c11a:	f003 fdb9 	bl	800fc90 <memp_malloc>
      if (buf == NULL) {
 800c11e:	4604      	mov	r4, r0
 800c120:	b1e0      	cbz	r0, 800c15c <recv_raw+0x7c>
        return 0;
      }

      buf->p = q;
      buf->ptr = q;
      ip_addr_copy(buf->addr, *ip_current_src_addr());
 800c122:	4b12      	ldr	r3, [pc, #72]	; (800c16c <recv_raw+0x8c>)
      if (buf == NULL) {
        pbuf_free(q);
        return 0;
      }

      buf->p = q;
 800c124:	f8c4 8000 	str.w	r8, [r4]
      buf->ptr = q;
      ip_addr_copy(buf->addr, *ip_current_src_addr());
 800c128:	681b      	ldr	r3, [r3, #0]
        pbuf_free(q);
        return 0;
      }

      buf->p = q;
      buf->ptr = q;
 800c12a:	f8c4 8004 	str.w	r8, [r4, #4]
      ip_addr_copy(buf->addr, *ip_current_src_addr());
 800c12e:	60a3      	str	r3, [r4, #8]
      buf->port = pcb->protocol;
 800c130:	7c33      	ldrb	r3, [r6, #16]

      len = q->tot_len;
      if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
 800c132:	4638      	mov	r0, r7
      }

      buf->p = q;
      buf->ptr = q;
      ip_addr_copy(buf->addr, *ip_current_src_addr());
      buf->port = pcb->protocol;
 800c134:	81a3      	strh	r3, [r4, #12]

      len = q->tot_len;
      if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
 800c136:	4621      	mov	r1, r4
      buf->p = q;
      buf->ptr = q;
      ip_addr_copy(buf->addr, *ip_current_src_addr());
      buf->port = pcb->protocol;

      len = q->tot_len;
 800c138:	f8b8 6008 	ldrh.w	r6, [r8, #8]
      if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
 800c13c:	f006 ff86 	bl	801304c <sys_mbox_trypost>
 800c140:	b980      	cbnz	r0, 800c164 <recv_raw+0x84>
      } else {
#if LWIP_SO_RCVBUF
        SYS_ARCH_INC(conn->recv_avail, len);
#endif /* LWIP_SO_RCVBUF */
        /* Register event with callback */
        API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
 800c142:	f8d5 30a4 	ldr.w	r3, [r5, #164]	; 0xa4
 800c146:	2b00      	cmp	r3, #0
 800c148:	d0d7      	beq.n	800c0fa <recv_raw+0x1a>
 800c14a:	4601      	mov	r1, r0
 800c14c:	4632      	mov	r2, r6
 800c14e:	4628      	mov	r0, r5
 800c150:	4798      	blx	r3
      }
    }
  }

  return 0; /* do not eat the packet */
}
 800c152:	2000      	movs	r0, #0
 800c154:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800c158:	2000      	movs	r0, #0
 800c15a:	4770      	bx	lr

    if (q != NULL) {
      u16_t len;
      buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
      if (buf == NULL) {
        pbuf_free(q);
 800c15c:	4640      	mov	r0, r8
 800c15e:	f003 ff63 	bl	8010028 <pbuf_free>
        return 0;
 800c162:	e7ca      	b.n	800c0fa <recv_raw+0x1a>
      ip_addr_copy(buf->addr, *ip_current_src_addr());
      buf->port = pcb->protocol;

      len = q->tot_len;
      if (sys_mbox_trypost(&conn->recvmbox, buf) != ERR_OK) {
        netbuf_delete(buf);
 800c164:	4620      	mov	r0, r4
 800c166:	f003 fdfb 	bl	800fd60 <netbuf_delete>
        return 0;
 800c16a:	e7c6      	b.n	800c0fa <recv_raw+0x1a>
 800c16c:	2000f09c 	.word	0x2000f09c

0800c170 <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
 800c170:	b510      	push	{r4, lr}
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
 800c172:	6844      	ldr	r4, [r0, #4]
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
 800c174:	4601      	mov	r1, r0
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
  tcp_arg(pcb, conn);
 800c176:	4620      	mov	r0, r4
 800c178:	f7fd fdda 	bl	8009d30 <tcp_arg>
  tcp_recv(pcb, recv_tcp);
 800c17c:	4620      	mov	r0, r4
 800c17e:	4909      	ldr	r1, [pc, #36]	; (800c1a4 <setup_tcp+0x34>)
 800c180:	f7fd fdd8 	bl	8009d34 <tcp_recv>
  tcp_sent(pcb, sent_tcp);
 800c184:	4620      	mov	r0, r4
 800c186:	4908      	ldr	r1, [pc, #32]	; (800c1a8 <setup_tcp+0x38>)
 800c188:	f7fd fdec 	bl	8009d64 <tcp_sent>
  tcp_poll(pcb, poll_tcp, 4);
 800c18c:	4620      	mov	r0, r4
 800c18e:	4907      	ldr	r1, [pc, #28]	; (800c1ac <setup_tcp+0x3c>)
 800c190:	2204      	movs	r2, #4
 800c192:	f7fd fe1b 	bl	8009dcc <tcp_poll>
  tcp_err(pcb, err_tcp);
 800c196:	4620      	mov	r0, r4
}
 800c198:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  pcb = conn->pcb.tcp;
  tcp_arg(pcb, conn);
  tcp_recv(pcb, recv_tcp);
  tcp_sent(pcb, sent_tcp);
  tcp_poll(pcb, poll_tcp, 4);
  tcp_err(pcb, err_tcp);
 800c19c:	4904      	ldr	r1, [pc, #16]	; (800c1b0 <setup_tcp+0x40>)
 800c19e:	f7fd bdf9 	b.w	8009d94 <tcp_err>
 800c1a2:	bf00      	nop
 800c1a4:	0800c7a5 	.word	0x0800c7a5
 800c1a8:	0800c86d 	.word	0x0800c86d
 800c1ac:	0800c72d 	.word	0x0800c72d
 800c1b0:	0800c1b5 	.word	0x0800c1b5

0800c1b4 <err_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.err) for parameters
 */
static void
err_tcp(void *arg, err_t err)
{
 800c1b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800c1b8:	460f      	mov	r7, r1
  struct netconn *conn;
  enum netconn_state old_state;
  SYS_ARCH_DECL_PROTECT(lev);

  conn = (struct netconn *)arg;
  LWIP_ASSERT("conn != NULL", (conn != NULL));
 800c1ba:	4604      	mov	r4, r0
 800c1bc:	2800      	cmp	r0, #0
 800c1be:	d05b      	beq.n	800c278 <err_tcp+0xc4>

  conn->pcb.tcp = NULL;
 800c1c0:	2500      	movs	r5, #0
 800c1c2:	6065      	str	r5, [r4, #4]

  /* no check since this is always fatal! */
  SYS_ARCH_PROTECT(lev);
 800c1c4:	f7f5 fad6 	bl	8001774 <CPU_SR_Save>
  conn->last_err = err;
 800c1c8:	7227      	strb	r7, [r4, #8]
  SYS_ARCH_UNPROTECT(lev);
 800c1ca:	f7f5 fad7 	bl	800177c <CPU_SR_Restore>
  old_state = conn->state;
  conn->state = NETCONN_NONE;

  /* Notify the user layer about a connection error. Used to signal
     select. */
  API_EVENT(conn, NETCONN_EVT_ERROR, 0);
 800c1ce:	f8d4 30a4 	ldr.w	r3, [r4, #164]	; 0xa4
  SYS_ARCH_PROTECT(lev);
  conn->last_err = err;
  SYS_ARCH_UNPROTECT(lev);

  /* reset conn->state now before waking up other threads */
  old_state = conn->state;
 800c1d2:	7866      	ldrb	r6, [r4, #1]
  conn->state = NETCONN_NONE;
 800c1d4:	7065      	strb	r5, [r4, #1]

  /* Notify the user layer about a connection error. Used to signal
     select. */
  API_EVENT(conn, NETCONN_EVT_ERROR, 0);
 800c1d6:	b18b      	cbz	r3, 800c1fc <err_tcp+0x48>
 800c1d8:	462a      	mov	r2, r5
 800c1da:	2104      	movs	r1, #4
 800c1dc:	4620      	mov	r0, r4
 800c1de:	4798      	blx	r3
  /* Try to release selects pending on 'read' or 'write', too.
     They will get an error if they actually try to read or write. */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
 800c1e0:	f8d4 30a4 	ldr.w	r3, [r4, #164]	; 0xa4
 800c1e4:	b153      	cbz	r3, 800c1fc <err_tcp+0x48>
 800c1e6:	462a      	mov	r2, r5
 800c1e8:	4629      	mov	r1, r5
 800c1ea:	4620      	mov	r0, r4
 800c1ec:	4798      	blx	r3
 800c1ee:	f8d4 30a4 	ldr.w	r3, [r4, #164]	; 0xa4
  API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
 800c1f2:	b11b      	cbz	r3, 800c1fc <err_tcp+0x48>
 800c1f4:	462a      	mov	r2, r5
 800c1f6:	2102      	movs	r1, #2
 800c1f8:	4620      	mov	r0, r4
 800c1fa:	4798      	blx	r3

  /* pass NULL-message to recvmbox to wake up pending recv */
  if (sys_mbox_valid(&conn->recvmbox)) {
 800c1fc:	f104 0534 	add.w	r5, r4, #52	; 0x34
 800c200:	4628      	mov	r0, r5
 800c202:	f006 ff5f 	bl	80130c4 <sys_mbox_valid>
 800c206:	bb90      	cbnz	r0, 800c26e <err_tcp+0xba>
    /* use trypost to prevent deadlock */
    sys_mbox_trypost(&conn->recvmbox, NULL);
  }
  /* pass NULL-message to acceptmbox to wake up pending accept */
  if (sys_mbox_valid(&conn->acceptmbox)) {
 800c208:	f104 0564 	add.w	r5, r4, #100	; 0x64
 800c20c:	4628      	mov	r0, r5
 800c20e:	f006 ff59 	bl	80130c4 <sys_mbox_valid>
 800c212:	bb38      	cbnz	r0, 800c264 <err_tcp+0xb0>
    /* use trypost to preven deadlock */
    sys_mbox_trypost(&conn->acceptmbox, NULL);
  }

  if ((old_state == NETCONN_WRITE) || (old_state == NETCONN_CLOSE) ||
 800c214:	2e01      	cmp	r6, #1
 800c216:	d00e      	beq.n	800c236 <err_tcp+0x82>
 800c218:	3e03      	subs	r6, #3
 800c21a:	2e01      	cmp	r6, #1
 800c21c:	d90b      	bls.n	800c236 <err_tcp+0x82>
      conn->current_msg = NULL;
      /* wake up the waiting task */
      sys_sem_signal(&conn->op_completed);
    }
  } else {
    LWIP_ASSERT("conn->current_msg == NULL", conn->current_msg == NULL);
 800c21e:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
 800c222:	b1eb      	cbz	r3, 800c260 <err_tcp+0xac>
  }
}
 800c224:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
      conn->current_msg = NULL;
      /* wake up the waiting task */
      sys_sem_signal(&conn->op_completed);
    }
  } else {
    LWIP_ASSERT("conn->current_msg == NULL", conn->current_msg == NULL);
 800c228:	4b1c      	ldr	r3, [pc, #112]	; (800c29c <err_tcp+0xe8>)
 800c22a:	f44f 72c9 	mov.w	r2, #402	; 0x192
 800c22e:	491c      	ldr	r1, [pc, #112]	; (800c2a0 <err_tcp+0xec>)
 800c230:	481c      	ldr	r0, [pc, #112]	; (800c2a4 <err_tcp+0xf0>)
 800c232:	f008 bda1 	b.w	8014d78 <iprintf>

  if ((old_state == NETCONN_WRITE) || (old_state == NETCONN_CLOSE) ||
      (old_state == NETCONN_CONNECT)) {
    /* calling do_writemore/do_close_internal is not necessary
       since the pcb has already been deleted! */
    int was_nonblocking_connect = IN_NONBLOCKING_CONNECT(conn);
 800c236:	f894 3098 	ldrb.w	r3, [r4, #152]	; 0x98
    SET_NONBLOCKING_CONNECT(conn, 0);
 800c23a:	f023 0204 	bic.w	r2, r3, #4

    if (!was_nonblocking_connect) {
 800c23e:	075b      	lsls	r3, r3, #29
  if ((old_state == NETCONN_WRITE) || (old_state == NETCONN_CLOSE) ||
      (old_state == NETCONN_CONNECT)) {
    /* calling do_writemore/do_close_internal is not necessary
       since the pcb has already been deleted! */
    int was_nonblocking_connect = IN_NONBLOCKING_CONNECT(conn);
    SET_NONBLOCKING_CONNECT(conn, 0);
 800c240:	f884 2098 	strb.w	r2, [r4, #152]	; 0x98

    if (!was_nonblocking_connect) {
 800c244:	d40c      	bmi.n	800c260 <err_tcp+0xac>
      /* set error return code */
      LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
 800c246:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
 800c24a:	b1eb      	cbz	r3, 800c288 <err_tcp+0xd4>
      conn->current_msg->err = err;
 800c24c:	711f      	strb	r7, [r3, #4]
      conn->current_msg = NULL;
 800c24e:	2200      	movs	r2, #0
      /* wake up the waiting task */
      sys_sem_signal(&conn->op_completed);
 800c250:	f104 000c 	add.w	r0, r4, #12

    if (!was_nonblocking_connect) {
      /* set error return code */
      LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
      conn->current_msg->err = err;
      conn->current_msg = NULL;
 800c254:	f8c4 20a0 	str.w	r2, [r4, #160]	; 0xa0
      sys_sem_signal(&conn->op_completed);
    }
  } else {
    LWIP_ASSERT("conn->current_msg == NULL", conn->current_msg == NULL);
  }
}
 800c258:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
      /* set error return code */
      LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
      conn->current_msg->err = err;
      conn->current_msg = NULL;
      /* wake up the waiting task */
      sys_sem_signal(&conn->op_completed);
 800c25c:	f006 bf90 	b.w	8013180 <sys_sem_signal>
 800c260:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    sys_mbox_trypost(&conn->recvmbox, NULL);
  }
  /* pass NULL-message to acceptmbox to wake up pending accept */
  if (sys_mbox_valid(&conn->acceptmbox)) {
    /* use trypost to preven deadlock */
    sys_mbox_trypost(&conn->acceptmbox, NULL);
 800c264:	4628      	mov	r0, r5
 800c266:	2100      	movs	r1, #0
 800c268:	f006 fef0 	bl	801304c <sys_mbox_trypost>
 800c26c:	e7d2      	b.n	800c214 <err_tcp+0x60>
  API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);

  /* pass NULL-message to recvmbox to wake up pending recv */
  if (sys_mbox_valid(&conn->recvmbox)) {
    /* use trypost to prevent deadlock */
    sys_mbox_trypost(&conn->recvmbox, NULL);
 800c26e:	4628      	mov	r0, r5
 800c270:	2100      	movs	r1, #0
 800c272:	f006 feeb 	bl	801304c <sys_mbox_trypost>
 800c276:	e7c7      	b.n	800c208 <err_tcp+0x54>
  struct netconn *conn;
  enum netconn_state old_state;
  SYS_ARCH_DECL_PROTECT(lev);

  conn = (struct netconn *)arg;
  LWIP_ASSERT("conn != NULL", (conn != NULL));
 800c278:	4b08      	ldr	r3, [pc, #32]	; (800c29c <err_tcp+0xe8>)
 800c27a:	f44f 72b1 	mov.w	r2, #354	; 0x162
 800c27e:	490a      	ldr	r1, [pc, #40]	; (800c2a8 <err_tcp+0xf4>)
 800c280:	4808      	ldr	r0, [pc, #32]	; (800c2a4 <err_tcp+0xf0>)
 800c282:	f008 fd79 	bl	8014d78 <iprintf>
 800c286:	e79b      	b.n	800c1c0 <err_tcp+0xc>
    int was_nonblocking_connect = IN_NONBLOCKING_CONNECT(conn);
    SET_NONBLOCKING_CONNECT(conn, 0);

    if (!was_nonblocking_connect) {
      /* set error return code */
      LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
 800c288:	4b04      	ldr	r3, [pc, #16]	; (800c29c <err_tcp+0xe8>)
 800c28a:	f240 128b 	movw	r2, #395	; 0x18b
 800c28e:	4907      	ldr	r1, [pc, #28]	; (800c2ac <err_tcp+0xf8>)
 800c290:	4804      	ldr	r0, [pc, #16]	; (800c2a4 <err_tcp+0xf0>)
 800c292:	f008 fd71 	bl	8014d78 <iprintf>
 800c296:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
 800c29a:	e7d7      	b.n	800c24c <err_tcp+0x98>
 800c29c:	0801719c 	.word	0x0801719c
 800c2a0:	08017240 	.word	0x08017240
 800c2a4:	0801660c 	.word	0x0801660c
 800c2a8:	08017214 	.word	0x08017214
 800c2ac:	08017224 	.word	0x08017224

0800c2b0 <do_connected>:

  LWIP_UNUSED_ARG(pcb);

  conn = (struct netconn *)arg;

  if (conn == NULL) {
 800c2b0:	2800      	cmp	r0, #0
 800c2b2:	d058      	beq.n	800c366 <do_connected+0xb6>
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
 800c2b4:	b538      	push	{r3, r4, r5, lr}

  if (conn == NULL) {
    return ERR_VAL;
  }

  LWIP_ASSERT("conn->state == NETCONN_CONNECT", conn->state == NETCONN_CONNECT);
 800c2b6:	7843      	ldrb	r3, [r0, #1]
 800c2b8:	4604      	mov	r4, r0
 800c2ba:	2b03      	cmp	r3, #3
 800c2bc:	4615      	mov	r5, r2
 800c2be:	d006      	beq.n	800c2ce <do_connected+0x1e>
 800c2c0:	4b2a      	ldr	r3, [pc, #168]	; (800c36c <do_connected+0xbc>)
 800c2c2:	f240 32b6 	movw	r2, #950	; 0x3b6
 800c2c6:	492a      	ldr	r1, [pc, #168]	; (800c370 <do_connected+0xc0>)
 800c2c8:	482a      	ldr	r0, [pc, #168]	; (800c374 <do_connected+0xc4>)
 800c2ca:	f008 fd55 	bl	8014d78 <iprintf>
  LWIP_ASSERT("(conn->current_msg != NULL) || conn->in_non_blocking_connect",
 800c2ce:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
 800c2d2:	2b00      	cmp	r3, #0
 800c2d4:	d037      	beq.n	800c346 <do_connected+0x96>
    (conn->current_msg != NULL) || IN_NONBLOCKING_CONNECT(conn));

  if (conn->current_msg != NULL) {
    conn->current_msg->err = err;
 800c2d6:	711d      	strb	r5, [r3, #4]
  }
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
 800c2d8:	7823      	ldrb	r3, [r4, #0]
 800c2da:	2b10      	cmp	r3, #16
 800c2dc:	d02d      	beq.n	800c33a <do_connected+0x8a>
    setup_tcp(conn);
  }
  was_blocking = !IN_NONBLOCKING_CONNECT(conn);
 800c2de:	f894 3098 	ldrb.w	r3, [r4, #152]	; 0x98
  SET_NONBLOCKING_CONNECT(conn, 0);
  conn->current_msg = NULL;
 800c2e2:	2500      	movs	r5, #0
  }
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
    setup_tcp(conn);
  }
  was_blocking = !IN_NONBLOCKING_CONNECT(conn);
  SET_NONBLOCKING_CONNECT(conn, 0);
 800c2e4:	f023 0204 	bic.w	r2, r3, #4
  conn->current_msg = NULL;
  conn->state = NETCONN_NONE;
  if (!was_blocking) {
 800c2e8:	f003 0304 	and.w	r3, r3, #4
  }
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
    setup_tcp(conn);
  }
  was_blocking = !IN_NONBLOCKING_CONNECT(conn);
  SET_NONBLOCKING_CONNECT(conn, 0);
 800c2ec:	f884 2098 	strb.w	r2, [r4, #152]	; 0x98
  conn->current_msg = NULL;
 800c2f0:	f8c4 50a0 	str.w	r5, [r4, #160]	; 0xa0
  conn->state = NETCONN_NONE;
  if (!was_blocking) {
 800c2f4:	f003 02ff 	and.w	r2, r3, #255	; 0xff
    setup_tcp(conn);
  }
  was_blocking = !IN_NONBLOCKING_CONNECT(conn);
  SET_NONBLOCKING_CONNECT(conn, 0);
  conn->current_msg = NULL;
  conn->state = NETCONN_NONE;
 800c2f8:	7065      	strb	r5, [r4, #1]
  if (!was_blocking) {
 800c2fa:	b95b      	cbnz	r3, 800c314 <do_connected+0x64>
    NETCONN_SET_SAFE_ERR(conn, ERR_OK);
  }
  API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
 800c2fc:	f8d4 30a4 	ldr.w	r3, [r4, #164]	; 0xa4
 800c300:	b113      	cbz	r3, 800c308 <do_connected+0x58>
 800c302:	2102      	movs	r1, #2
 800c304:	4620      	mov	r0, r4
 800c306:	4798      	blx	r3

  if (was_blocking) {
    sys_sem_signal(&conn->op_completed);
 800c308:	f104 000c 	add.w	r0, r4, #12
 800c30c:	f006 ff38 	bl	8013180 <sys_sem_signal>
  }
  return ERR_OK;
 800c310:	2000      	movs	r0, #0
 800c312:	bd38      	pop	{r3, r4, r5, pc}
  was_blocking = !IN_NONBLOCKING_CONNECT(conn);
  SET_NONBLOCKING_CONNECT(conn, 0);
  conn->current_msg = NULL;
  conn->state = NETCONN_NONE;
  if (!was_blocking) {
    NETCONN_SET_SAFE_ERR(conn, ERR_OK);
 800c314:	f7f5 fa2e 	bl	8001774 <CPU_SR_Save>
 800c318:	f994 3008 	ldrsb.w	r3, [r4, #8]
 800c31c:	3309      	adds	r3, #9
 800c31e:	bfa8      	it	ge
 800c320:	7225      	strbge	r5, [r4, #8]
 800c322:	f7f5 fa2b 	bl	800177c <CPU_SR_Restore>
  }
  API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
 800c326:	f8d4 30a4 	ldr.w	r3, [r4, #164]	; 0xa4
 800c32a:	2b00      	cmp	r3, #0
 800c32c:	d0f0      	beq.n	800c310 <do_connected+0x60>
 800c32e:	4620      	mov	r0, r4
 800c330:	2200      	movs	r2, #0
 800c332:	2102      	movs	r1, #2
 800c334:	4798      	blx	r3

  if (was_blocking) {
    sys_sem_signal(&conn->op_completed);
  }
  return ERR_OK;
 800c336:	2000      	movs	r0, #0
 800c338:	bd38      	pop	{r3, r4, r5, pc}
    (conn->current_msg != NULL) || IN_NONBLOCKING_CONNECT(conn));

  if (conn->current_msg != NULL) {
    conn->current_msg->err = err;
  }
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
 800c33a:	2d00      	cmp	r5, #0
 800c33c:	d1cf      	bne.n	800c2de <do_connected+0x2e>
    setup_tcp(conn);
 800c33e:	4620      	mov	r0, r4
 800c340:	f7ff ff16 	bl	800c170 <setup_tcp>
 800c344:	e7cb      	b.n	800c2de <do_connected+0x2e>
  if (conn == NULL) {
    return ERR_VAL;
  }

  LWIP_ASSERT("conn->state == NETCONN_CONNECT", conn->state == NETCONN_CONNECT);
  LWIP_ASSERT("(conn->current_msg != NULL) || conn->in_non_blocking_connect",
 800c346:	f894 3098 	ldrb.w	r3, [r4, #152]	; 0x98
 800c34a:	075b      	lsls	r3, r3, #29
 800c34c:	d4c4      	bmi.n	800c2d8 <do_connected+0x28>
 800c34e:	4b07      	ldr	r3, [pc, #28]	; (800c36c <do_connected+0xbc>)
 800c350:	f44f 726e 	mov.w	r2, #952	; 0x3b8
 800c354:	4908      	ldr	r1, [pc, #32]	; (800c378 <do_connected+0xc8>)
 800c356:	4807      	ldr	r0, [pc, #28]	; (800c374 <do_connected+0xc4>)
 800c358:	f008 fd0e 	bl	8014d78 <iprintf>
    (conn->current_msg != NULL) || IN_NONBLOCKING_CONNECT(conn));

  if (conn->current_msg != NULL) {
 800c35c:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
 800c360:	2b00      	cmp	r3, #0
 800c362:	d0b9      	beq.n	800c2d8 <do_connected+0x28>
 800c364:	e7b7      	b.n	800c2d6 <do_connected+0x26>
  LWIP_UNUSED_ARG(pcb);

  conn = (struct netconn *)arg;

  if (conn == NULL) {
    return ERR_VAL;
 800c366:	f06f 0005 	mvn.w	r0, #5

  if (was_blocking) {
    sys_sem_signal(&conn->op_completed);
  }
  return ERR_OK;
}
 800c36a:	4770      	bx	lr
 800c36c:	0801719c 	.word	0x0801719c
 800c370:	0801725c 	.word	0x0801725c
 800c374:	0801660c 	.word	0x0801660c
 800c378:	0801727c 	.word	0x0801727c

0800c37c <do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
 800c37c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;
  size_t diff;
  u8_t dontblock = netconn_is_nonblocking(conn) ||
 800c380:	f890 3098 	ldrb.w	r3, [r0, #152]	; 0x98
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
 800c384:	4604      	mov	r4, r0
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;
  size_t diff;
  u8_t dontblock = netconn_is_nonblocking(conn) ||
 800c386:	f013 0f02 	tst.w	r3, #2
 800c38a:	f8d0 30a0 	ldr.w	r3, [r0, #160]	; 0xa0
 800c38e:	d07b      	beq.n	800c488 <do_writemore+0x10c>
 800c390:	f893 8010 	ldrb.w	r8, [r3, #16]
 800c394:	2701      	movs	r7, #1
       (conn->current_msg->msg.w.apiflags & NETCONN_DONTBLOCK);
  u8_t apiflags = conn->current_msg->msg.w.apiflags;

  LWIP_ASSERT("conn != NULL", conn != NULL);
  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
 800c396:	7863      	ldrb	r3, [r4, #1]
 800c398:	2b01      	cmp	r3, #1
 800c39a:	d00b      	beq.n	800c3b4 <do_writemore+0x38>
 800c39c:	4b6a      	ldr	r3, [pc, #424]	; (800c548 <do_writemore+0x1cc>)
 800c39e:	f240 42c4 	movw	r2, #1220	; 0x4c4
 800c3a2:	496a      	ldr	r1, [pc, #424]	; (800c54c <do_writemore+0x1d0>)
 800c3a4:	486a      	ldr	r0, [pc, #424]	; (800c550 <do_writemore+0x1d4>)
 800c3a6:	f008 fce7 	bl	8014d78 <iprintf>
  LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
 800c3aa:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
 800c3ae:	2b00      	cmp	r3, #0
 800c3b0:	f000 809c 	beq.w	800c4ec <do_writemore+0x170>
  LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
 800c3b4:	6863      	ldr	r3, [r4, #4]
 800c3b6:	2b00      	cmp	r3, #0
 800c3b8:	f000 80af 	beq.w	800c51a <do_writemore+0x19e>
  LWIP_ASSERT("conn->write_offset < conn->current_msg->msg.w.len",
 800c3bc:	f8d4 20a0 	ldr.w	r2, [r4, #160]	; 0xa0
 800c3c0:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
 800c3c4:	68d1      	ldr	r1, [r2, #12]
 800c3c6:	428b      	cmp	r3, r1
 800c3c8:	d263      	bcs.n	800c492 <do_writemore+0x116>
    }
  } else
#endif /* LWIP_SO_SNDTIMEO */
  {
    dataptr = (u8_t*)conn->current_msg->msg.w.dataptr + conn->write_offset;
    diff = conn->current_msg->msg.w.len - conn->write_offset;
 800c3ca:	1acd      	subs	r5, r1, r3
    if (diff > 0xffffUL) { /* max_u16_t */
 800c3cc:	f5b5 3f80 	cmp.w	r5, #65536	; 0x10000
      len = 0xffff;
 800c3d0:	bf28      	it	cs
 800c3d2:	f64f 75ff 	movwcs	r5, #65535	; 0xffff
#endif
      apiflags |= TCP_WRITE_FLAG_MORE;
    } else {
      len = (u16_t)diff;
    }
    available = tcp_sndbuf(conn->pcb.tcp);
 800c3d6:	6860      	ldr	r0, [r4, #4]
      conn->current_msg->msg.w.len = conn->write_offset;
    }
  } else
#endif /* LWIP_SO_SNDTIMEO */
  {
    dataptr = (u8_t*)conn->current_msg->msg.w.dataptr + conn->write_offset;
 800c3d8:	6896      	ldr	r6, [r2, #8]
#endif
      apiflags |= TCP_WRITE_FLAG_MORE;
    } else {
      len = (u16_t)diff;
    }
    available = tcp_sndbuf(conn->pcb.tcp);
 800c3da:	f8b0 9066 	ldrh.w	r9, [r0, #102]	; 0x66
#if LWIP_TCPIP_CORE_LOCKING
      conn->flags |= NETCONN_FLAG_WRITE_DELAYED;
#endif
      apiflags |= TCP_WRITE_FLAG_MORE;
    } else {
      len = (u16_t)diff;
 800c3de:	bf34      	ite	cc
 800c3e0:	b2ad      	uxthcc	r5, r5
    if (diff > 0xffffUL) { /* max_u16_t */
      len = 0xffff;
#if LWIP_TCPIP_CORE_LOCKING
      conn->flags |= NETCONN_FLAG_WRITE_DELAYED;
#endif
      apiflags |= TCP_WRITE_FLAG_MORE;
 800c3e2:	f048 0802 	orrcs.w	r8, r8, #2
    } else {
      len = (u16_t)diff;
    }
    available = tcp_sndbuf(conn->pcb.tcp);
    if (available < len) {
 800c3e6:	454d      	cmp	r5, r9
      conn->current_msg->msg.w.len = conn->write_offset;
    }
  } else
#endif /* LWIP_SO_SNDTIMEO */
  {
    dataptr = (u8_t*)conn->current_msg->msg.w.dataptr + conn->write_offset;
 800c3e8:	441e      	add	r6, r3
      apiflags |= TCP_WRITE_FLAG_MORE;
    } else {
      len = (u16_t)diff;
    }
    available = tcp_sndbuf(conn->pcb.tcp);
    if (available < len) {
 800c3ea:	d92e      	bls.n	800c44a <do_writemore+0xce>
      /* don't try to write more than sendbuf */
      len = available;
      if (dontblock){ 
 800c3ec:	b357      	cbz	r7, 800c444 <do_writemore+0xc8>
        if (!len) {
 800c3ee:	f1b9 0f00 	cmp.w	r9, #0
 800c3f2:	d179      	bne.n	800c4e8 <do_writemore+0x16c>
    LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->current_msg->msg.w.len));
    err = tcp_write(conn->pcb.tcp, dataptr, len, apiflags);
    /* if OK or memory error, check available space */
    if ((err == ERR_OK) || (err == ERR_MEM)) {
err_mem:
      if (dontblock && (len < conn->current_msg->msg.w.len)) {
 800c3f4:	2900      	cmp	r1, #0
 800c3f6:	f000 8098 	beq.w	800c52a <do_writemore+0x1ae>
    if (available < len) {
      /* don't try to write more than sendbuf */
      len = available;
      if (dontblock){ 
        if (!len) {
          err = ERR_WOULDBLOCK;
 800c3fa:	f06f 0606 	mvn.w	r6, #6
    if ((err == ERR_OK) || (err == ERR_MEM)) {
err_mem:
      if (dontblock && (len < conn->current_msg->msg.w.len)) {
        /* non-blocking write did not write everything: mark the pcb non-writable
           and let poll_tcp check writable space to mark the pcb writable again */
        API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
 800c3fe:	f8d4 30a4 	ldr.w	r3, [r4, #164]	; 0xa4
 800c402:	b11b      	cbz	r3, 800c40c <do_writemore+0x90>
 800c404:	464a      	mov	r2, r9
 800c406:	2103      	movs	r1, #3
 800c408:	4620      	mov	r0, r4
 800c40a:	4798      	blx	r3
        conn->flags |= NETCONN_FLAG_CHECK_WRITESPACE;
 800c40c:	464d      	mov	r5, r9
 800c40e:	f894 3098 	ldrb.w	r3, [r4, #152]	; 0x98
 800c412:	f043 0310 	orr.w	r3, r3, #16
 800c416:	f884 3098 	strb.w	r3, [r4, #152]	; 0x98
           let select mark this pcb as non-writable. */
        API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
      }
    }

    if (err == ERR_OK) {
 800c41a:	2e00      	cmp	r6, #0
 800c41c:	f040 808c 	bne.w	800c538 <do_writemore+0x1bc>
      conn->write_offset += len;
 800c420:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
      if ((conn->write_offset == conn->current_msg->msg.w.len) || dontblock) {
 800c424:	f8d4 20a0 	ldr.w	r2, [r4, #160]	; 0xa0
        API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
      }
    }

    if (err == ERR_OK) {
      conn->write_offset += len;
 800c428:	441d      	add	r5, r3
 800c42a:	f8c4 509c 	str.w	r5, [r4, #156]	; 0x9c
      if ((conn->write_offset == conn->current_msg->msg.w.len) || dontblock) {
 800c42e:	68d3      	ldr	r3, [r2, #12]
 800c430:	429d      	cmp	r5, r3
 800c432:	d06a      	beq.n	800c50a <do_writemore+0x18e>
 800c434:	2f00      	cmp	r7, #0
 800c436:	d168      	bne.n	800c50a <do_writemore+0x18e>
        conn->current_msg->msg.w.len = conn->write_offset;
        /* everything was written */
        write_finished = 1;
        conn->write_offset = 0;
      }
      tcp_output(conn->pcb.tcp);
 800c438:	6860      	ldr	r0, [r4, #4]
 800c43a:	f7fe fc91 	bl	800ad60 <tcp_output>
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
}
 800c43e:	2000      	movs	r0, #0
 800c440:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        }
      } else {
#if LWIP_TCPIP_CORE_LOCKING
        conn->flags |= NETCONN_FLAG_WRITE_DELAYED;
#endif
        apiflags |= TCP_WRITE_FLAG_MORE;
 800c444:	464d      	mov	r5, r9
 800c446:	f048 0802 	orr.w	r8, r8, #2
      }
    }
    LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->current_msg->msg.w.len));
 800c44a:	442b      	add	r3, r5
 800c44c:	428b      	cmp	r3, r1
 800c44e:	d82d      	bhi.n	800c4ac <do_writemore+0x130>
    err = tcp_write(conn->pcb.tcp, dataptr, len, apiflags);
 800c450:	4643      	mov	r3, r8
 800c452:	4631      	mov	r1, r6
 800c454:	462a      	mov	r2, r5
 800c456:	f7fe f8cd 	bl	800a5f4 <tcp_write>
    /* if OK or memory error, check available space */
    if ((err == ERR_OK) || (err == ERR_MEM)) {
 800c45a:	1c43      	adds	r3, r0, #1
 800c45c:	b2db      	uxtb	r3, r3
 800c45e:	2b01      	cmp	r3, #1
#endif
        apiflags |= TCP_WRITE_FLAG_MORE;
      }
    }
    LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->current_msg->msg.w.len));
    err = tcp_write(conn->pcb.tcp, dataptr, len, apiflags);
 800c460:	4606      	mov	r6, r0
    /* if OK or memory error, check available space */
    if ((err == ERR_OK) || (err == ERR_MEM)) {
 800c462:	d92c      	bls.n	800c4be <do_writemore+0x142>
 800c464:	f8d4 20a0 	ldr.w	r2, [r4, #160]	; 0xa0
#endif
    } else {
      /* On errors != ERR_MEM, we don't try writing any more but return
         the error to the application thread. */
      write_finished = 1;
      conn->current_msg->msg.w.len = 0;
 800c468:	2300      	movs	r3, #0
 800c46a:	60d3      	str	r3, [r2, #12]
    }
  }
  if (write_finished) {
    /* everything was written: set back connection state
       and back to application task */
    conn->current_msg->err = err;
 800c46c:	f8d4 20a0 	ldr.w	r2, [r4, #160]	; 0xa0
    conn->current_msg = NULL;
 800c470:	2300      	movs	r3, #0
    }
  }
  if (write_finished) {
    /* everything was written: set back connection state
       and back to application task */
    conn->current_msg->err = err;
 800c472:	7116      	strb	r6, [r2, #4]
    conn->state = NETCONN_NONE;
#if LWIP_TCPIP_CORE_LOCKING
    if ((conn->flags & NETCONN_FLAG_WRITE_DELAYED) != 0)
#endif
    {
      sys_sem_signal(&conn->op_completed);
 800c474:	f104 000c 	add.w	r0, r4, #12
  }
  if (write_finished) {
    /* everything was written: set back connection state
       and back to application task */
    conn->current_msg->err = err;
    conn->current_msg = NULL;
 800c478:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0
    conn->state = NETCONN_NONE;
 800c47c:	7063      	strb	r3, [r4, #1]
#if LWIP_TCPIP_CORE_LOCKING
    if ((conn->flags & NETCONN_FLAG_WRITE_DELAYED) != 0)
#endif
    {
      sys_sem_signal(&conn->op_completed);
 800c47e:	f006 fe7f 	bl	8013180 <sys_sem_signal>
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
}
 800c482:	2000      	movs	r0, #0
 800c484:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;
  size_t diff;
  u8_t dontblock = netconn_is_nonblocking(conn) ||
       (conn->current_msg->msg.w.apiflags & NETCONN_DONTBLOCK);
 800c488:	7c1f      	ldrb	r7, [r3, #16]
 800c48a:	46b8      	mov	r8, r7
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;
  size_t diff;
  u8_t dontblock = netconn_is_nonblocking(conn) ||
 800c48c:	f3c7 0780 	ubfx	r7, r7, #2, #1
 800c490:	e781      	b.n	800c396 <do_writemore+0x1a>

  LWIP_ASSERT("conn != NULL", conn != NULL);
  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
  LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  LWIP_ASSERT("conn->write_offset < conn->current_msg->msg.w.len",
 800c492:	4b2d      	ldr	r3, [pc, #180]	; (800c548 <do_writemore+0x1cc>)
 800c494:	f44f 6299 	mov.w	r2, #1224	; 0x4c8
 800c498:	492e      	ldr	r1, [pc, #184]	; (800c554 <do_writemore+0x1d8>)
 800c49a:	482d      	ldr	r0, [pc, #180]	; (800c550 <do_writemore+0x1d4>)
 800c49c:	f008 fc6c 	bl	8014d78 <iprintf>
 800c4a0:	f8d4 20a0 	ldr.w	r2, [r4, #160]	; 0xa0
 800c4a4:	f8d4 309c 	ldr.w	r3, [r4, #156]	; 0x9c
 800c4a8:	68d1      	ldr	r1, [r2, #12]
 800c4aa:	e78e      	b.n	800c3ca <do_writemore+0x4e>
        conn->flags |= NETCONN_FLAG_WRITE_DELAYED;
#endif
        apiflags |= TCP_WRITE_FLAG_MORE;
      }
    }
    LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->current_msg->msg.w.len));
 800c4ac:	4b26      	ldr	r3, [pc, #152]	; (800c548 <do_writemore+0x1cc>)
 800c4ae:	f240 42f5 	movw	r2, #1269	; 0x4f5
 800c4b2:	4929      	ldr	r1, [pc, #164]	; (800c558 <do_writemore+0x1dc>)
 800c4b4:	4826      	ldr	r0, [pc, #152]	; (800c550 <do_writemore+0x1d4>)
 800c4b6:	f008 fc5f 	bl	8014d78 <iprintf>
 800c4ba:	6860      	ldr	r0, [r4, #4]
 800c4bc:	e7c8      	b.n	800c450 <do_writemore+0xd4>
    err = tcp_write(conn->pcb.tcp, dataptr, len, apiflags);
    /* if OK or memory error, check available space */
    if ((err == ERR_OK) || (err == ERR_MEM)) {
err_mem:
      if (dontblock && (len < conn->current_msg->msg.w.len)) {
 800c4be:	b9ef      	cbnz	r7, 800c4fc <do_writemore+0x180>
        /* non-blocking write did not write everything: mark the pcb non-writable
           and let poll_tcp check writable space to mark the pcb writable again */
        API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
        conn->flags |= NETCONN_FLAG_CHECK_WRITESPACE;
      } else if ((tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT) ||
 800c4c0:	f640 3269 	movw	r2, #2921	; 0xb69
 800c4c4:	6863      	ldr	r3, [r4, #4]
 800c4c6:	f8b3 1066 	ldrh.w	r1, [r3, #102]	; 0x66
 800c4ca:	4291      	cmp	r1, r2
 800c4cc:	d903      	bls.n	800c4d6 <do_writemore+0x15a>
 800c4ce:	f8b3 3068 	ldrh.w	r3, [r3, #104]	; 0x68
 800c4d2:	2b0b      	cmp	r3, #11
 800c4d4:	d9a1      	bls.n	800c41a <do_writemore+0x9e>
                 (tcp_sndqueuelen(conn->pcb.tcp) >= TCP_SNDQUEUELOWAT)) {
        /* The queued byte- or pbuf-count exceeds the configured low-water limit,
           let select mark this pcb as non-writable. */
        API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
 800c4d6:	f8d4 30a4 	ldr.w	r3, [r4, #164]	; 0xa4
 800c4da:	2b00      	cmp	r3, #0
 800c4dc:	d09d      	beq.n	800c41a <do_writemore+0x9e>
 800c4de:	462a      	mov	r2, r5
 800c4e0:	2103      	movs	r1, #3
 800c4e2:	4620      	mov	r0, r4
 800c4e4:	4798      	blx	r3
 800c4e6:	e798      	b.n	800c41a <do_writemore+0x9e>
 800c4e8:	464d      	mov	r5, r9
 800c4ea:	e7ae      	b.n	800c44a <do_writemore+0xce>
       (conn->current_msg->msg.w.apiflags & NETCONN_DONTBLOCK);
  u8_t apiflags = conn->current_msg->msg.w.apiflags;

  LWIP_ASSERT("conn != NULL", conn != NULL);
  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
 800c4ec:	4b16      	ldr	r3, [pc, #88]	; (800c548 <do_writemore+0x1cc>)
 800c4ee:	f240 42c5 	movw	r2, #1221	; 0x4c5
 800c4f2:	491a      	ldr	r1, [pc, #104]	; (800c55c <do_writemore+0x1e0>)
 800c4f4:	4816      	ldr	r0, [pc, #88]	; (800c550 <do_writemore+0x1d4>)
 800c4f6:	f008 fc3f 	bl	8014d78 <iprintf>
 800c4fa:	e75b      	b.n	800c3b4 <do_writemore+0x38>
 800c4fc:	f8d4 20a0 	ldr.w	r2, [r4, #160]	; 0xa0
    LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->current_msg->msg.w.len));
    err = tcp_write(conn->pcb.tcp, dataptr, len, apiflags);
    /* if OK or memory error, check available space */
    if ((err == ERR_OK) || (err == ERR_MEM)) {
err_mem:
      if (dontblock && (len < conn->current_msg->msg.w.len)) {
 800c500:	68d3      	ldr	r3, [r2, #12]
 800c502:	429d      	cmp	r5, r3
 800c504:	d2dc      	bcs.n	800c4c0 <do_writemore+0x144>
 800c506:	46a9      	mov	r9, r5
 800c508:	e779      	b.n	800c3fe <do_writemore+0x82>

    if (err == ERR_OK) {
      conn->write_offset += len;
      if ((conn->write_offset == conn->current_msg->msg.w.len) || dontblock) {
        /* return sent length */
        conn->current_msg->msg.w.len = conn->write_offset;
 800c50a:	60d5      	str	r5, [r2, #12]
        /* everything was written */
        write_finished = 1;
        conn->write_offset = 0;
 800c50c:	2300      	movs	r3, #0
      }
      tcp_output(conn->pcb.tcp);
 800c50e:	6860      	ldr	r0, [r4, #4]
      if ((conn->write_offset == conn->current_msg->msg.w.len) || dontblock) {
        /* return sent length */
        conn->current_msg->msg.w.len = conn->write_offset;
        /* everything was written */
        write_finished = 1;
        conn->write_offset = 0;
 800c510:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
      }
      tcp_output(conn->pcb.tcp);
 800c514:	f7fe fc24 	bl	800ad60 <tcp_output>
 800c518:	e7a8      	b.n	800c46c <do_writemore+0xf0>
  u8_t apiflags = conn->current_msg->msg.w.apiflags;

  LWIP_ASSERT("conn != NULL", conn != NULL);
  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
  LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
 800c51a:	4b0b      	ldr	r3, [pc, #44]	; (800c548 <do_writemore+0x1cc>)
 800c51c:	f240 42c6 	movw	r2, #1222	; 0x4c6
 800c520:	490f      	ldr	r1, [pc, #60]	; (800c560 <do_writemore+0x1e4>)
 800c522:	480b      	ldr	r0, [pc, #44]	; (800c550 <do_writemore+0x1d4>)
 800c524:	f008 fc28 	bl	8014d78 <iprintf>
 800c528:	e748      	b.n	800c3bc <do_writemore+0x40>
        conn->flags |= NETCONN_FLAG_CHECK_WRITESPACE;
      } else if ((tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT) ||
                 (tcp_sndqueuelen(conn->pcb.tcp) >= TCP_SNDQUEUELOWAT)) {
        /* The queued byte- or pbuf-count exceeds the configured low-water limit,
           let select mark this pcb as non-writable. */
        API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
 800c52a:	f8d4 30a4 	ldr.w	r3, [r4, #164]	; 0xa4
 800c52e:	b143      	cbz	r3, 800c542 <do_writemore+0x1c6>
 800c530:	460d      	mov	r5, r1
    if (available < len) {
      /* don't try to write more than sendbuf */
      len = available;
      if (dontblock){ 
        if (!len) {
          err = ERR_WOULDBLOCK;
 800c532:	f06f 0606 	mvn.w	r6, #6
 800c536:	e7d2      	b.n	800c4de <do_writemore+0x162>
        /* everything was written */
        write_finished = 1;
        conn->write_offset = 0;
      }
      tcp_output(conn->pcb.tcp);
    } else if ((err == ERR_MEM) && !dontblock) {
 800c538:	1c73      	adds	r3, r6, #1
 800c53a:	d193      	bne.n	800c464 <do_writemore+0xe8>
 800c53c:	2f00      	cmp	r7, #0
 800c53e:	d191      	bne.n	800c464 <do_writemore+0xe8>
 800c540:	e77a      	b.n	800c438 <do_writemore+0xbc>
    if (available < len) {
      /* don't try to write more than sendbuf */
      len = available;
      if (dontblock){ 
        if (!len) {
          err = ERR_WOULDBLOCK;
 800c542:	f06f 0606 	mvn.w	r6, #6
 800c546:	e78f      	b.n	800c468 <do_writemore+0xec>
 800c548:	0801719c 	.word	0x0801719c
 800c54c:	080172bc 	.word	0x080172bc
 800c550:	0801660c 	.word	0x0801660c
 800c554:	080172f4 	.word	0x080172f4
 800c558:	08017328 	.word	0x08017328
 800c55c:	08017224 	.word	0x08017224
 800c560:	080172dc 	.word	0x080172dc

0800c564 <do_close_internal>:
 *
 * @param conn the TCP netconn to close
 */
static void
do_close_internal(struct netconn *conn)
{
 800c564:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  err_t err;
  u8_t shut, shut_rx, shut_tx, close;

  LWIP_ASSERT("invalid conn", (conn != NULL));
 800c566:	4604      	mov	r4, r0
 800c568:	2800      	cmp	r0, #0
 800c56a:	f000 80bb 	beq.w	800c6e4 <do_close_internal+0x180>
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
 800c56e:	7823      	ldrb	r3, [r4, #0]
 800c570:	2b10      	cmp	r3, #16
 800c572:	d006      	beq.n	800c582 <do_close_internal+0x1e>
 800c574:	4b62      	ldr	r3, [pc, #392]	; (800c700 <do_close_internal+0x19c>)
 800c576:	f240 22f1 	movw	r2, #753	; 0x2f1
 800c57a:	4962      	ldr	r1, [pc, #392]	; (800c704 <do_close_internal+0x1a0>)
 800c57c:	4862      	ldr	r0, [pc, #392]	; (800c708 <do_close_internal+0x1a4>)
 800c57e:	f008 fbfb 	bl	8014d78 <iprintf>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
 800c582:	7863      	ldrb	r3, [r4, #1]
 800c584:	2b04      	cmp	r3, #4
 800c586:	d006      	beq.n	800c596 <do_close_internal+0x32>
 800c588:	4b5d      	ldr	r3, [pc, #372]	; (800c700 <do_close_internal+0x19c>)
 800c58a:	f240 22f2 	movw	r2, #754	; 0x2f2
 800c58e:	495f      	ldr	r1, [pc, #380]	; (800c70c <do_close_internal+0x1a8>)
 800c590:	485d      	ldr	r0, [pc, #372]	; (800c708 <do_close_internal+0x1a4>)
 800c592:	f008 fbf1 	bl	8014d78 <iprintf>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
 800c596:	6863      	ldr	r3, [r4, #4]
 800c598:	2b00      	cmp	r3, #0
 800c59a:	f000 8091 	beq.w	800c6c0 <do_close_internal+0x15c>
  LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
 800c59e:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
 800c5a2:	2b00      	cmp	r3, #0
 800c5a4:	f000 8094 	beq.w	800c6d0 <do_close_internal+0x16c>

  shut = conn->current_msg->msg.sd.shut;
 800c5a8:	7a1d      	ldrb	r5, [r3, #8]
  shut_rx = shut & NETCONN_SHUT_RD;
  shut_tx = shut & NETCONN_SHUT_WR;
 800c5aa:	f005 0602 	and.w	r6, r5, #2
  /* shutting down both ends is the same as closing */
  close = shut == NETCONN_SHUT_RDWR;

  /* Set back some callback pointers */
  if (close) {
 800c5ae:	2d03      	cmp	r5, #3
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);

  shut = conn->current_msg->msg.sd.shut;
  shut_rx = shut & NETCONN_SHUT_RD;
  shut_tx = shut & NETCONN_SHUT_WR;
 800c5b0:	b2f6      	uxtb	r6, r6
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);

  shut = conn->current_msg->msg.sd.shut;
  shut_rx = shut & NETCONN_SHUT_RD;
 800c5b2:	f005 0701 	and.w	r7, r5, #1
  shut_tx = shut & NETCONN_SHUT_WR;
  /* shutting down both ends is the same as closing */
  close = shut == NETCONN_SHUT_RDWR;

  /* Set back some callback pointers */
  if (close) {
 800c5b6:	d074      	beq.n	800c6a2 <do_close_internal+0x13e>
    tcp_arg(conn->pcb.tcp, NULL);
  }
  if (conn->pcb.tcp->state == LISTEN) {
 800c5b8:	6860      	ldr	r0, [r4, #4]
 800c5ba:	7e03      	ldrb	r3, [r0, #24]
 800c5bc:	2b01      	cmp	r3, #1
 800c5be:	f000 8099 	beq.w	800c6f4 <do_close_internal+0x190>
    tcp_accept(conn->pcb.tcp, NULL);
  } else {
    /* some callbacks have to be reset if tcp_close is not successful */
    if (shut_rx) {
 800c5c2:	2f00      	cmp	r7, #0
 800c5c4:	d136      	bne.n	800c634 <do_close_internal+0xd0>
      tcp_recv(conn->pcb.tcp, NULL);
      tcp_accept(conn->pcb.tcp, NULL);
    }
    if (shut_tx) {
 800c5c6:	2e00      	cmp	r6, #0
 800c5c8:	d13e      	bne.n	800c648 <do_close_internal+0xe4>
      tcp_sent(conn->pcb.tcp, NULL);
    }
    if (close) {
 800c5ca:	2d03      	cmp	r5, #3
 800c5cc:	d042      	beq.n	800c654 <do_close_internal+0xf0>
  }
  /* Try to close the connection */
  if (close) {
    err = tcp_close(conn->pcb.tcp);
  } else {
    err = tcp_shutdown(conn->pcb.tcp, shut_rx, shut_tx);
 800c5ce:	4632      	mov	r2, r6
 800c5d0:	4639      	mov	r1, r7
 800c5d2:	f7fd fde7 	bl	800a1a4 <tcp_shutdown>
  }
  if (err == ERR_OK) {
 800c5d6:	b9b8      	cbnz	r0, 800c608 <do_close_internal+0xa4>
    /* Closing succeeded */
    conn->current_msg->err = ERR_OK;
 800c5d8:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
    conn->current_msg = NULL;
    conn->state = NETCONN_NONE;
    if (close) {
 800c5dc:	2d03      	cmp	r5, #3
  } else {
    err = tcp_shutdown(conn->pcb.tcp, shut_rx, shut_tx);
  }
  if (err == ERR_OK) {
    /* Closing succeeded */
    conn->current_msg->err = ERR_OK;
 800c5de:	7118      	strb	r0, [r3, #4]
    conn->current_msg = NULL;
 800c5e0:	f8c4 00a0 	str.w	r0, [r4, #160]	; 0xa0
    conn->state = NETCONN_NONE;
 800c5e4:	7060      	strb	r0, [r4, #1]
    if (close) {
 800c5e6:	d047      	beq.n	800c678 <do_close_internal+0x114>
      conn->pcb.tcp = NULL;
      /* Trigger select() in socket layer. Make sure everybody notices activity
       on the connection, error first! */
      API_EVENT(conn, NETCONN_EVT_ERROR, 0);
    }
    if (shut_rx) {
 800c5e8:	2f00      	cmp	r7, #0
 800c5ea:	d13c      	bne.n	800c666 <do_close_internal+0x102>
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
    }
    if (shut_tx) {
 800c5ec:	b136      	cbz	r6, 800c5fc <do_close_internal+0x98>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
 800c5ee:	f8d4 30a4 	ldr.w	r3, [r4, #164]	; 0xa4
 800c5f2:	b11b      	cbz	r3, 800c5fc <do_close_internal+0x98>
 800c5f4:	2200      	movs	r2, #0
 800c5f6:	2102      	movs	r1, #2
 800c5f8:	4620      	mov	r0, r4
 800c5fa:	4798      	blx	r3
    }
    /* wake up the application task */
    sys_sem_signal(&conn->op_completed);
 800c5fc:	f104 000c 	add.w	r0, r4, #12
    tcp_arg(conn->pcb.tcp, conn);
    /* don't restore recv callback: we don't want to receive any more data */
  }
  /* If closing didn't succeed, we get called again either
     from poll_tcp or from sent_tcp */
}
 800c600:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    }
    if (shut_tx) {
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
    }
    /* wake up the application task */
    sys_sem_signal(&conn->op_completed);
 800c604:	f006 bdbc 	b.w	8013180 <sys_sem_signal>
  } else {
    /* Closing failed, restore some of the callbacks */
    /* Closing of listen pcb will never fail! */
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
 800c608:	6860      	ldr	r0, [r4, #4]
 800c60a:	7e03      	ldrb	r3, [r0, #24]
 800c60c:	2b01      	cmp	r3, #1
 800c60e:	d03f      	beq.n	800c690 <do_close_internal+0x12c>
    tcp_sent(conn->pcb.tcp, sent_tcp);
 800c610:	493f      	ldr	r1, [pc, #252]	; (800c710 <do_close_internal+0x1ac>)
 800c612:	f7fd fba7 	bl	8009d64 <tcp_sent>
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
 800c616:	6860      	ldr	r0, [r4, #4]
 800c618:	2204      	movs	r2, #4
 800c61a:	493e      	ldr	r1, [pc, #248]	; (800c714 <do_close_internal+0x1b0>)
 800c61c:	f7fd fbd6 	bl	8009dcc <tcp_poll>
    tcp_err(conn->pcb.tcp, err_tcp);
 800c620:	6860      	ldr	r0, [r4, #4]
 800c622:	493d      	ldr	r1, [pc, #244]	; (800c718 <do_close_internal+0x1b4>)
 800c624:	f7fd fbb6 	bl	8009d94 <tcp_err>
    tcp_arg(conn->pcb.tcp, conn);
 800c628:	4621      	mov	r1, r4
 800c62a:	6860      	ldr	r0, [r4, #4]
    /* don't restore recv callback: we don't want to receive any more data */
  }
  /* If closing didn't succeed, we get called again either
     from poll_tcp or from sent_tcp */
}
 800c62c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    /* Closing of listen pcb will never fail! */
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
    tcp_sent(conn->pcb.tcp, sent_tcp);
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
    tcp_err(conn->pcb.tcp, err_tcp);
    tcp_arg(conn->pcb.tcp, conn);
 800c630:	f7fd bb7e 	b.w	8009d30 <tcp_arg>
  if (conn->pcb.tcp->state == LISTEN) {
    tcp_accept(conn->pcb.tcp, NULL);
  } else {
    /* some callbacks have to be reset if tcp_close is not successful */
    if (shut_rx) {
      tcp_recv(conn->pcb.tcp, NULL);
 800c634:	2100      	movs	r1, #0
 800c636:	f7fd fb7d 	bl	8009d34 <tcp_recv>
      tcp_accept(conn->pcb.tcp, NULL);
 800c63a:	6860      	ldr	r0, [r4, #4]
 800c63c:	2100      	movs	r1, #0
 800c63e:	f7fd fbc3 	bl	8009dc8 <tcp_accept>
 800c642:	6860      	ldr	r0, [r4, #4]
    }
    if (shut_tx) {
 800c644:	2e00      	cmp	r6, #0
 800c646:	d0c0      	beq.n	800c5ca <do_close_internal+0x66>
      tcp_sent(conn->pcb.tcp, NULL);
 800c648:	2100      	movs	r1, #0
 800c64a:	f7fd fb8b 	bl	8009d64 <tcp_sent>
    }
    if (close) {
 800c64e:	2d03      	cmp	r5, #3
 800c650:	6860      	ldr	r0, [r4, #4]
 800c652:	d1bc      	bne.n	800c5ce <do_close_internal+0x6a>
      tcp_poll(conn->pcb.tcp, NULL, 4);
 800c654:	2204      	movs	r2, #4
 800c656:	2100      	movs	r1, #0
 800c658:	f7fd fbb8 	bl	8009dcc <tcp_poll>
      tcp_err(conn->pcb.tcp, NULL);
 800c65c:	2100      	movs	r1, #0
 800c65e:	6860      	ldr	r0, [r4, #4]
 800c660:	f7fd fb98 	bl	8009d94 <tcp_err>
 800c664:	e028      	b.n	800c6b8 <do_close_internal+0x154>
      /* Trigger select() in socket layer. Make sure everybody notices activity
       on the connection, error first! */
      API_EVENT(conn, NETCONN_EVT_ERROR, 0);
    }
    if (shut_rx) {
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
 800c666:	f8d4 30a4 	ldr.w	r3, [r4, #164]	; 0xa4
 800c66a:	2b00      	cmp	r3, #0
 800c66c:	d0c6      	beq.n	800c5fc <do_close_internal+0x98>
 800c66e:	2200      	movs	r2, #0
 800c670:	4611      	mov	r1, r2
 800c672:	4620      	mov	r0, r4
 800c674:	4798      	blx	r3
 800c676:	e7b9      	b.n	800c5ec <do_close_internal+0x88>
    if (close) {
      /* Set back some callback pointers as conn is going away */
      conn->pcb.tcp = NULL;
      /* Trigger select() in socket layer. Make sure everybody notices activity
       on the connection, error first! */
      API_EVENT(conn, NETCONN_EVT_ERROR, 0);
 800c678:	f8d4 30a4 	ldr.w	r3, [r4, #164]	; 0xa4
    conn->current_msg->err = ERR_OK;
    conn->current_msg = NULL;
    conn->state = NETCONN_NONE;
    if (close) {
      /* Set back some callback pointers as conn is going away */
      conn->pcb.tcp = NULL;
 800c67c:	6060      	str	r0, [r4, #4]
      /* Trigger select() in socket layer. Make sure everybody notices activity
       on the connection, error first! */
      API_EVENT(conn, NETCONN_EVT_ERROR, 0);
 800c67e:	2b00      	cmp	r3, #0
 800c680:	d0b2      	beq.n	800c5e8 <do_close_internal+0x84>
 800c682:	4602      	mov	r2, r0
 800c684:	2104      	movs	r1, #4
 800c686:	4620      	mov	r0, r4
 800c688:	4798      	blx	r3
    }
    if (shut_rx) {
 800c68a:	2f00      	cmp	r7, #0
 800c68c:	d0ae      	beq.n	800c5ec <do_close_internal+0x88>
 800c68e:	e7ea      	b.n	800c666 <do_close_internal+0x102>
    /* wake up the application task */
    sys_sem_signal(&conn->op_completed);
  } else {
    /* Closing failed, restore some of the callbacks */
    /* Closing of listen pcb will never fail! */
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
 800c690:	4b1b      	ldr	r3, [pc, #108]	; (800c700 <do_close_internal+0x19c>)
 800c692:	f240 322d 	movw	r2, #813	; 0x32d
 800c696:	4921      	ldr	r1, [pc, #132]	; (800c71c <do_close_internal+0x1b8>)
 800c698:	481b      	ldr	r0, [pc, #108]	; (800c708 <do_close_internal+0x1a4>)
 800c69a:	f008 fb6d 	bl	8014d78 <iprintf>
 800c69e:	6860      	ldr	r0, [r4, #4]
 800c6a0:	e7b6      	b.n	800c610 <do_close_internal+0xac>
  /* shutting down both ends is the same as closing */
  close = shut == NETCONN_SHUT_RDWR;

  /* Set back some callback pointers */
  if (close) {
    tcp_arg(conn->pcb.tcp, NULL);
 800c6a2:	6860      	ldr	r0, [r4, #4]
 800c6a4:	2100      	movs	r1, #0
 800c6a6:	f7fd fb43 	bl	8009d30 <tcp_arg>
  }
  if (conn->pcb.tcp->state == LISTEN) {
 800c6aa:	6860      	ldr	r0, [r4, #4]
 800c6ac:	7e03      	ldrb	r3, [r0, #24]
 800c6ae:	2b01      	cmp	r3, #1
 800c6b0:	d187      	bne.n	800c5c2 <do_close_internal+0x5e>
    tcp_accept(conn->pcb.tcp, NULL);
 800c6b2:	2100      	movs	r1, #0
 800c6b4:	f7fd fb88 	bl	8009dc8 <tcp_accept>
      tcp_err(conn->pcb.tcp, NULL);
    }
  }
  /* Try to close the connection */
  if (close) {
    err = tcp_close(conn->pcb.tcp);
 800c6b8:	6860      	ldr	r0, [r4, #4]
 800c6ba:	f7fd fcd5 	bl	800a068 <tcp_close>
 800c6be:	e78a      	b.n	800c5d6 <do_close_internal+0x72>
  u8_t shut, shut_rx, shut_tx, close;

  LWIP_ASSERT("invalid conn", (conn != NULL));
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
 800c6c0:	4b0f      	ldr	r3, [pc, #60]	; (800c700 <do_close_internal+0x19c>)
 800c6c2:	f240 22f3 	movw	r2, #755	; 0x2f3
 800c6c6:	4916      	ldr	r1, [pc, #88]	; (800c720 <do_close_internal+0x1bc>)
 800c6c8:	480f      	ldr	r0, [pc, #60]	; (800c708 <do_close_internal+0x1a4>)
 800c6ca:	f008 fb55 	bl	8014d78 <iprintf>
 800c6ce:	e766      	b.n	800c59e <do_close_internal+0x3a>
  LWIP_ASSERT("conn->current_msg != NULL", conn->current_msg != NULL);
 800c6d0:	4b0b      	ldr	r3, [pc, #44]	; (800c700 <do_close_internal+0x19c>)
 800c6d2:	f44f 723d 	mov.w	r2, #756	; 0x2f4
 800c6d6:	4913      	ldr	r1, [pc, #76]	; (800c724 <do_close_internal+0x1c0>)
 800c6d8:	480b      	ldr	r0, [pc, #44]	; (800c708 <do_close_internal+0x1a4>)
 800c6da:	f008 fb4d 	bl	8014d78 <iprintf>
 800c6de:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
 800c6e2:	e761      	b.n	800c5a8 <do_close_internal+0x44>
do_close_internal(struct netconn *conn)
{
  err_t err;
  u8_t shut, shut_rx, shut_tx, close;

  LWIP_ASSERT("invalid conn", (conn != NULL));
 800c6e4:	4b06      	ldr	r3, [pc, #24]	; (800c700 <do_close_internal+0x19c>)
 800c6e6:	f44f 723c 	mov.w	r2, #752	; 0x2f0
 800c6ea:	490f      	ldr	r1, [pc, #60]	; (800c728 <do_close_internal+0x1c4>)
 800c6ec:	4806      	ldr	r0, [pc, #24]	; (800c708 <do_close_internal+0x1a4>)
 800c6ee:	f008 fb43 	bl	8014d78 <iprintf>
 800c6f2:	e73c      	b.n	800c56e <do_close_internal+0xa>
  /* Set back some callback pointers */
  if (close) {
    tcp_arg(conn->pcb.tcp, NULL);
  }
  if (conn->pcb.tcp->state == LISTEN) {
    tcp_accept(conn->pcb.tcp, NULL);
 800c6f4:	2100      	movs	r1, #0
 800c6f6:	f7fd fb67 	bl	8009dc8 <tcp_accept>
 800c6fa:	6860      	ldr	r0, [r4, #4]
 800c6fc:	e767      	b.n	800c5ce <do_close_internal+0x6a>
 800c6fe:	bf00      	nop
 800c700:	0801719c 	.word	0x0801719c
 800c704:	08017348 	.word	0x08017348
 800c708:	0801660c 	.word	0x0801660c
 800c70c:	08017368 	.word	0x08017368
 800c710:	0800c86d 	.word	0x0800c86d
 800c714:	0800c72d 	.word	0x0800c72d
 800c718:	0800c1b5 	.word	0x0800c1b5
 800c71c:	080173a0 	.word	0x080173a0
 800c720:	0801738c 	.word	0x0801738c
 800c724:	08017224 	.word	0x08017224
 800c728:	080170cc 	.word	0x080170cc

0800c72c <poll_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.poll) for parameters and return value
 */
static err_t
poll_tcp(void *arg, struct tcp_pcb *pcb)
{
 800c72c:	b538      	push	{r3, r4, r5, lr}
  struct netconn *conn = (struct netconn *)arg;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
 800c72e:	4604      	mov	r4, r0
 800c730:	b348      	cbz	r0, 800c786 <poll_tcp+0x5a>

  if (conn->state == NETCONN_WRITE) {
 800c732:	7863      	ldrb	r3, [r4, #1]
 800c734:	2b01      	cmp	r3, #1
 800c736:	d01e      	beq.n	800c776 <poll_tcp+0x4a>
    do_writemore(conn);
  } else if (conn->state == NETCONN_CLOSE) {
 800c738:	2b04      	cmp	r3, #4
 800c73a:	d020      	beq.n	800c77e <poll_tcp+0x52>
    do_close_internal(conn);
  }
  /* @todo: implement connect timeout here? */

  /* Did a nonblocking write fail before? Then check available write-space. */
  if (conn->flags & NETCONN_FLAG_CHECK_WRITESPACE) {
 800c73c:	f894 3098 	ldrb.w	r3, [r4, #152]	; 0x98
 800c740:	06da      	lsls	r2, r3, #27
 800c742:	d516      	bpl.n	800c772 <poll_tcp+0x46>
    /* If the queued byte- or pbuf-count drops below the configured low-water limit,
       let select mark this pcb as writable again. */
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
 800c744:	6862      	ldr	r2, [r4, #4]
 800c746:	b1a2      	cbz	r2, 800c772 <poll_tcp+0x46>
 800c748:	f640 3169 	movw	r1, #2921	; 0xb69
 800c74c:	f8b2 0066 	ldrh.w	r0, [r2, #102]	; 0x66
 800c750:	4288      	cmp	r0, r1
 800c752:	d90e      	bls.n	800c772 <poll_tcp+0x46>
 800c754:	f8b2 2068 	ldrh.w	r2, [r2, #104]	; 0x68
 800c758:	2a0b      	cmp	r2, #11
 800c75a:	d80a      	bhi.n	800c772 <poll_tcp+0x46>
      (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
      conn->flags &= ~NETCONN_FLAG_CHECK_WRITESPACE;
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
 800c75c:	f8d4 50a4 	ldr.w	r5, [r4, #164]	; 0xa4
  if (conn->flags & NETCONN_FLAG_CHECK_WRITESPACE) {
    /* If the queued byte- or pbuf-count drops below the configured low-water limit,
       let select mark this pcb as writable again. */
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
      (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
      conn->flags &= ~NETCONN_FLAG_CHECK_WRITESPACE;
 800c760:	f023 0310 	bic.w	r3, r3, #16
 800c764:	f884 3098 	strb.w	r3, [r4, #152]	; 0x98
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
 800c768:	b11d      	cbz	r5, 800c772 <poll_tcp+0x46>
 800c76a:	4620      	mov	r0, r4
 800c76c:	2200      	movs	r2, #0
 800c76e:	2102      	movs	r1, #2
 800c770:	47a8      	blx	r5
    }
  }

  return ERR_OK;
}
 800c772:	2000      	movs	r0, #0
 800c774:	bd38      	pop	{r3, r4, r5, pc}

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));

  if (conn->state == NETCONN_WRITE) {
    do_writemore(conn);
 800c776:	4620      	mov	r0, r4
 800c778:	f7ff fe00 	bl	800c37c <do_writemore>
 800c77c:	e7de      	b.n	800c73c <poll_tcp+0x10>
  } else if (conn->state == NETCONN_CLOSE) {
    do_close_internal(conn);
 800c77e:	4620      	mov	r0, r4
 800c780:	f7ff fef0 	bl	800c564 <do_close_internal>
 800c784:	e7da      	b.n	800c73c <poll_tcp+0x10>
poll_tcp(void *arg, struct tcp_pcb *pcb)
{
  struct netconn *conn = (struct netconn *)arg;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
 800c786:	4b04      	ldr	r3, [pc, #16]	; (800c798 <poll_tcp+0x6c>)
 800c788:	f44f 728d 	mov.w	r2, #282	; 0x11a
 800c78c:	4903      	ldr	r1, [pc, #12]	; (800c79c <poll_tcp+0x70>)
 800c78e:	4804      	ldr	r0, [pc, #16]	; (800c7a0 <poll_tcp+0x74>)
 800c790:	f008 faf2 	bl	8014d78 <iprintf>
 800c794:	e7cd      	b.n	800c732 <poll_tcp+0x6>
 800c796:	bf00      	nop
 800c798:	0801719c 	.word	0x0801719c
 800c79c:	08017214 	.word	0x08017214
 800c7a0:	0801660c 	.word	0x0801660c

0800c7a4 <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
 800c7a4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800c7a8:	4605      	mov	r5, r0
 800c7aa:	4616      	mov	r6, r2
 800c7ac:	4699      	mov	r9, r3
  struct netconn *conn;
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
 800c7ae:	460f      	mov	r7, r1
 800c7b0:	2900      	cmp	r1, #0
 800c7b2:	d03d      	beq.n	800c830 <recv_tcp+0x8c>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
 800c7b4:	2d00      	cmp	r5, #0
 800c7b6:	d042      	beq.n	800c83e <recv_tcp+0x9a>
  conn = (struct netconn *)arg;
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
 800c7b8:	686b      	ldr	r3, [r5, #4]
 800c7ba:	429f      	cmp	r7, r3
 800c7bc:	d005      	beq.n	800c7ca <recv_tcp+0x26>
 800c7be:	4b26      	ldr	r3, [pc, #152]	; (800c858 <recv_tcp+0xb4>)
 800c7c0:	22e1      	movs	r2, #225	; 0xe1
 800c7c2:	4926      	ldr	r1, [pc, #152]	; (800c85c <recv_tcp+0xb8>)
 800c7c4:	4826      	ldr	r0, [pc, #152]	; (800c860 <recv_tcp+0xbc>)
 800c7c6:	f008 fad7 	bl	8014d78 <iprintf>

  if (conn == NULL) {
    return ERR_VAL;
  }
  if (!sys_mbox_valid(&conn->recvmbox)) {
 800c7ca:	f105 0834 	add.w	r8, r5, #52	; 0x34
 800c7ce:	4640      	mov	r0, r8
 800c7d0:	f006 fc78 	bl	80130c4 <sys_mbox_valid>
 800c7d4:	4604      	mov	r4, r0
 800c7d6:	b970      	cbnz	r0, 800c7f6 <recv_tcp+0x52>
    /* recvmbox already deleted */
    if (p != NULL) {
 800c7d8:	b14e      	cbz	r6, 800c7ee <recv_tcp+0x4a>
      tcp_recved(pcb, p->tot_len);
 800c7da:	4638      	mov	r0, r7
 800c7dc:	8931      	ldrh	r1, [r6, #8]
 800c7de:	f7fc ff53 	bl	8009688 <tcp_recved>
      pbuf_free(p);
 800c7e2:	4630      	mov	r0, r6
 800c7e4:	f003 fc20 	bl	8010028 <pbuf_free>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  }

  return ERR_OK;
}
 800c7e8:	4620      	mov	r0, r4
 800c7ea:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    /* recvmbox already deleted */
    if (p != NULL) {
      tcp_recved(pcb, p->tot_len);
      pbuf_free(p);
    }
    return ERR_OK;
 800c7ee:	2400      	movs	r4, #0
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  }

  return ERR_OK;
}
 800c7f0:	4620      	mov	r0, r4
 800c7f2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  /* Unlike for UDP or RAW pcbs, don't check for available space
     using recv_avail since that could break the connection
     (data is already ACKed) */

  /* don't overwrite fatal errors! */
  NETCONN_SET_SAFE_ERR(conn, err);
 800c7f6:	f7f4 ffbd 	bl	8001774 <CPU_SR_Save>
 800c7fa:	f995 3008 	ldrsb.w	r3, [r5, #8]
 800c7fe:	3309      	adds	r3, #9
 800c800:	bfa8      	it	ge
 800c802:	f885 9008 	strbge.w	r9, [r5, #8]
 800c806:	f7f4 ffb9 	bl	800177c <CPU_SR_Restore>

  if (p != NULL) {
 800c80a:	b1fe      	cbz	r6, 800c84c <recv_tcp+0xa8>
    len = p->tot_len;
 800c80c:	8937      	ldrh	r7, [r6, #8]
  } else {
    len = 0;
  }

  if (sys_mbox_trypost(&conn->recvmbox, p) != ERR_OK) {
 800c80e:	4631      	mov	r1, r6
 800c810:	4640      	mov	r0, r8
 800c812:	f006 fc1b 	bl	801304c <sys_mbox_trypost>
 800c816:	4604      	mov	r4, r0
 800c818:	b9d0      	cbnz	r0, 800c850 <recv_tcp+0xac>
  } else {
#if LWIP_SO_RCVBUF
    SYS_ARCH_INC(conn->recv_avail, len);
#endif /* LWIP_SO_RCVBUF */
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
 800c81a:	f8d5 30a4 	ldr.w	r3, [r5, #164]	; 0xa4
 800c81e:	2b00      	cmp	r3, #0
 800c820:	d0e5      	beq.n	800c7ee <recv_tcp+0x4a>
 800c822:	4628      	mov	r0, r5
 800c824:	463a      	mov	r2, r7
 800c826:	4621      	mov	r1, r4
 800c828:	4798      	blx	r3
  }

  return ERR_OK;
}
 800c82a:	4620      	mov	r0, r4
 800c82c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
{
  struct netconn *conn;
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
 800c830:	4b09      	ldr	r3, [pc, #36]	; (800c858 <recv_tcp+0xb4>)
 800c832:	22de      	movs	r2, #222	; 0xde
 800c834:	490b      	ldr	r1, [pc, #44]	; (800c864 <recv_tcp+0xc0>)
 800c836:	480a      	ldr	r0, [pc, #40]	; (800c860 <recv_tcp+0xbc>)
 800c838:	f008 fa9e 	bl	8014d78 <iprintf>
 800c83c:	e7ba      	b.n	800c7b4 <recv_tcp+0x10>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
 800c83e:	4b06      	ldr	r3, [pc, #24]	; (800c858 <recv_tcp+0xb4>)
 800c840:	22df      	movs	r2, #223	; 0xdf
 800c842:	4909      	ldr	r1, [pc, #36]	; (800c868 <recv_tcp+0xc4>)
 800c844:	4806      	ldr	r0, [pc, #24]	; (800c860 <recv_tcp+0xbc>)
 800c846:	f008 fa97 	bl	8014d78 <iprintf>
 800c84a:	e7b5      	b.n	800c7b8 <recv_tcp+0x14>
  NETCONN_SET_SAFE_ERR(conn, err);

  if (p != NULL) {
    len = p->tot_len;
  } else {
    len = 0;
 800c84c:	4637      	mov	r7, r6
 800c84e:	e7de      	b.n	800c80e <recv_tcp+0x6a>
  }

  if (sys_mbox_trypost(&conn->recvmbox, p) != ERR_OK) {
    /* don't deallocate p: it is presented to us later again from tcp_fasttmr! */
    return ERR_MEM;
 800c850:	f04f 34ff 	mov.w	r4, #4294967295
 800c854:	e7c8      	b.n	800c7e8 <recv_tcp+0x44>
 800c856:	bf00      	nop
 800c858:	0801719c 	.word	0x0801719c
 800c85c:	08017408 	.word	0x08017408
 800c860:	0801660c 	.word	0x0801660c
 800c864:	080173c4 	.word	0x080173c4
 800c868:	080173e8 	.word	0x080173e8

0800c86c <sent_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.sent) for parameters and return value
 */
static err_t
sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
{
 800c86c:	b570      	push	{r4, r5, r6, lr}
 800c86e:	4615      	mov	r5, r2
  struct netconn *conn = (struct netconn *)arg;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
 800c870:	4604      	mov	r4, r0
 800c872:	b338      	cbz	r0, 800c8c4 <sent_tcp+0x58>

  if (conn->state == NETCONN_WRITE) {
 800c874:	7863      	ldrb	r3, [r4, #1]
 800c876:	2b01      	cmp	r3, #1
 800c878:	d01c      	beq.n	800c8b4 <sent_tcp+0x48>
    do_writemore(conn);
  } else if (conn->state == NETCONN_CLOSE) {
 800c87a:	2b04      	cmp	r3, #4
 800c87c:	d01e      	beq.n	800c8bc <sent_tcp+0x50>
  }

  if (conn) {
    /* If the queued byte- or pbuf-count drops below the configured low-water limit,
       let select mark this pcb as writable again. */
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
 800c87e:	6863      	ldr	r3, [r4, #4]
 800c880:	b1b3      	cbz	r3, 800c8b0 <sent_tcp+0x44>
 800c882:	f640 3269 	movw	r2, #2921	; 0xb69
 800c886:	f8b3 1066 	ldrh.w	r1, [r3, #102]	; 0x66
 800c88a:	4291      	cmp	r1, r2
 800c88c:	d910      	bls.n	800c8b0 <sent_tcp+0x44>
 800c88e:	f8b3 3068 	ldrh.w	r3, [r3, #104]	; 0x68
 800c892:	2b0b      	cmp	r3, #11
 800c894:	d80c      	bhi.n	800c8b0 <sent_tcp+0x44>
      (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
      conn->flags &= ~NETCONN_FLAG_CHECK_WRITESPACE;
 800c896:	f894 3098 	ldrb.w	r3, [r4, #152]	; 0x98
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
 800c89a:	f8d4 60a4 	ldr.w	r6, [r4, #164]	; 0xa4
  if (conn) {
    /* If the queued byte- or pbuf-count drops below the configured low-water limit,
       let select mark this pcb as writable again. */
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT) &&
      (tcp_sndqueuelen(conn->pcb.tcp) < TCP_SNDQUEUELOWAT)) {
      conn->flags &= ~NETCONN_FLAG_CHECK_WRITESPACE;
 800c89e:	f023 0310 	bic.w	r3, r3, #16
 800c8a2:	f884 3098 	strb.w	r3, [r4, #152]	; 0x98
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
 800c8a6:	b11e      	cbz	r6, 800c8b0 <sent_tcp+0x44>
 800c8a8:	462a      	mov	r2, r5
 800c8aa:	4620      	mov	r0, r4
 800c8ac:	2102      	movs	r1, #2
 800c8ae:	47b0      	blx	r6
    }
  }
  
  return ERR_OK;
}
 800c8b0:	2000      	movs	r0, #0
 800c8b2:	bd70      	pop	{r4, r5, r6, pc}

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));

  if (conn->state == NETCONN_WRITE) {
    do_writemore(conn);
 800c8b4:	4620      	mov	r0, r4
 800c8b6:	f7ff fd61 	bl	800c37c <do_writemore>
 800c8ba:	e7e0      	b.n	800c87e <sent_tcp+0x12>
  } else if (conn->state == NETCONN_CLOSE) {
    do_close_internal(conn);
 800c8bc:	4620      	mov	r0, r4
 800c8be:	f7ff fe51 	bl	800c564 <do_close_internal>
 800c8c2:	e7dc      	b.n	800c87e <sent_tcp+0x12>
sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
{
  struct netconn *conn = (struct netconn *)arg;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
 800c8c4:	4b03      	ldr	r3, [pc, #12]	; (800c8d4 <sent_tcp+0x68>)
 800c8c6:	f44f 729f 	mov.w	r2, #318	; 0x13e
 800c8ca:	4903      	ldr	r1, [pc, #12]	; (800c8d8 <sent_tcp+0x6c>)
 800c8cc:	4803      	ldr	r0, [pc, #12]	; (800c8dc <sent_tcp+0x70>)
 800c8ce:	f008 fa53 	bl	8014d78 <iprintf>
 800c8d2:	e7cf      	b.n	800c874 <sent_tcp+0x8>
 800c8d4:	0801719c 	.word	0x0801719c
 800c8d8:	08017214 	.word	0x08017214
 800c8dc:	0801660c 	.word	0x0801660c

0800c8e0 <do_newconn>:
 *
 * @param msg the api_msg_msg describing the connection type
 */
void
do_newconn(struct api_msg_msg *msg)
{
 800c8e0:	b538      	push	{r3, r4, r5, lr}
  msg->err = ERR_OK;
 800c8e2:	2300      	movs	r3, #0
  if(msg->conn->pcb.tcp == NULL) {
 800c8e4:	6804      	ldr	r4, [r0, #0]
 * @param msg the api_msg_msg describing the connection type
 */
void
do_newconn(struct api_msg_msg *msg)
{
  msg->err = ERR_OK;
 800c8e6:	7103      	strb	r3, [r0, #4]
  if(msg->conn->pcb.tcp == NULL) {
 800c8e8:	6863      	ldr	r3, [r4, #4]
 800c8ea:	b12b      	cbz	r3, 800c8f8 <do_newconn+0x18>
  }
  /* Else? This "new" connection already has a PCB allocated. */
  /* Is this an error condition? Should it be deleted? */
  /* We currently just are happy and return. */

  TCPIP_APIMSG_ACK(msg);
 800c8ec:	f104 000c 	add.w	r0, r4, #12
}
 800c8f0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  }
  /* Else? This "new" connection already has a PCB allocated. */
  /* Is this an error condition? Should it be deleted? */
  /* We currently just are happy and return. */

  TCPIP_APIMSG_ACK(msg);
 800c8f4:	f006 bc44 	b.w	8013180 <sys_sem_signal>
pcb_new(struct api_msg_msg *msg)
{
  LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);

  /* Allocate a PCB for this connection */
  switch(NETCONNTYPE_GROUP(msg->conn->type)) {
 800c8f8:	7823      	ldrb	r3, [r4, #0]
 800c8fa:	4605      	mov	r5, r0
 800c8fc:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800c900:	2b20      	cmp	r3, #32
 800c902:	d01e      	beq.n	800c942 <do_newconn+0x62>
 800c904:	2b40      	cmp	r3, #64	; 0x40
 800c906:	d00f      	beq.n	800c928 <do_newconn+0x48>
 800c908:	2b10      	cmp	r3, #16
 800c90a:	d002      	beq.n	800c912 <do_newconn+0x32>
    setup_tcp(msg->conn);
    break;
#endif /* LWIP_TCP */
  default:
    /* Unsupported netconn type, e.g. protocol disabled */
    msg->err = ERR_VAL;
 800c90c:	23fa      	movs	r3, #250	; 0xfa
 800c90e:	7103      	strb	r3, [r0, #4]
 800c910:	e7ec      	b.n	800c8ec <do_newconn+0xc>
    udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
    break;
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    msg->conn->pcb.tcp = tcp_new();
 800c912:	f7fd fd6f 	bl	800a3f4 <tcp_new>
 800c916:	6060      	str	r0, [r4, #4]
    if(msg->conn->pcb.tcp == NULL) {
 800c918:	682c      	ldr	r4, [r5, #0]
 800c91a:	6863      	ldr	r3, [r4, #4]
 800c91c:	b323      	cbz	r3, 800c968 <do_newconn+0x88>
      msg->err = ERR_MEM;
      break;
    }
    setup_tcp(msg->conn);
 800c91e:	4620      	mov	r0, r4
 800c920:	f7ff fc26 	bl	800c170 <setup_tcp>
 800c924:	682c      	ldr	r4, [r5, #0]
 800c926:	e7e1      	b.n	800c8ec <do_newconn+0xc>

  /* Allocate a PCB for this connection */
  switch(NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
  case NETCONN_RAW:
    msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
 800c928:	7a00      	ldrb	r0, [r0, #8]
 800c92a:	f004 f893 	bl	8010a54 <raw_new>
 800c92e:	6060      	str	r0, [r4, #4]
    if(msg->conn->pcb.raw == NULL) {
 800c930:	682c      	ldr	r4, [r5, #0]
 800c932:	6860      	ldr	r0, [r4, #4]
 800c934:	b1c0      	cbz	r0, 800c968 <do_newconn+0x88>
      msg->err = ERR_MEM;
      break;
    }
    raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
 800c936:	4622      	mov	r2, r4
 800c938:	490d      	ldr	r1, [pc, #52]	; (800c970 <do_newconn+0x90>)
 800c93a:	f004 f809 	bl	8010950 <raw_recv>
 800c93e:	682c      	ldr	r4, [r5, #0]
 800c940:	e7d4      	b.n	800c8ec <do_newconn+0xc>
    break;
#endif /* LWIP_RAW */
#if LWIP_UDP
  case NETCONN_UDP:
    msg->conn->pcb.udp = udp_new();
 800c942:	f007 ff8d 	bl	8014860 <udp_new>
 800c946:	6060      	str	r0, [r4, #4]
    if(msg->conn->pcb.udp == NULL) {
 800c948:	682c      	ldr	r4, [r5, #0]
 800c94a:	6860      	ldr	r0, [r4, #4]
 800c94c:	b160      	cbz	r0, 800c968 <do_newconn+0x88>
#if LWIP_UDPLITE
    if (msg->conn->type==NETCONN_UDPLITE) {
      udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
    }
#endif /* LWIP_UDPLITE */
    if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
 800c94e:	7823      	ldrb	r3, [r4, #0]
 800c950:	2b22      	cmp	r3, #34	; 0x22
 800c952:	d103      	bne.n	800c95c <do_newconn+0x7c>
      udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
 800c954:	2301      	movs	r3, #1
 800c956:	7403      	strb	r3, [r0, #16]
 800c958:	682c      	ldr	r4, [r5, #0]
 800c95a:	6860      	ldr	r0, [r4, #4]
    }
    udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
 800c95c:	4622      	mov	r2, r4
 800c95e:	4905      	ldr	r1, [pc, #20]	; (800c974 <do_newconn+0x94>)
 800c960:	f007 ff5c 	bl	801481c <udp_recv>
 800c964:	682c      	ldr	r4, [r5, #0]
 800c966:	e7c1      	b.n	800c8ec <do_newconn+0xc>
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    msg->conn->pcb.tcp = tcp_new();
    if(msg->conn->pcb.tcp == NULL) {
      msg->err = ERR_MEM;
 800c968:	23ff      	movs	r3, #255	; 0xff
 800c96a:	712b      	strb	r3, [r5, #4]
 800c96c:	e7be      	b.n	800c8ec <do_newconn+0xc>
 800c96e:	bf00      	nop
 800c970:	0800c0e1 	.word	0x0800c0e1
 800c974:	0800c02d 	.word	0x0800c02d

0800c978 <netconn_alloc>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_alloc(enum netconn_type t, netconn_callback callback)
{
 800c978:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c97a:	4605      	mov	r5, r0
  struct netconn *conn;
  int size;

  conn = (struct netconn *)memp_malloc(MEMP_NETCONN);
 800c97c:	2007      	movs	r0, #7
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_alloc(enum netconn_type t, netconn_callback callback)
{
 800c97e:	460f      	mov	r7, r1
  struct netconn *conn;
  int size;

  conn = (struct netconn *)memp_malloc(MEMP_NETCONN);
 800c980:	f003 f986 	bl	800fc90 <memp_malloc>
  if (conn == NULL) {
 800c984:	4604      	mov	r4, r0
 800c986:	b360      	cbz	r0, 800c9e2 <netconn_alloc+0x6a>
    return NULL;
  }

  conn->last_err = ERR_OK;
 800c988:	2100      	movs	r1, #0
    LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
    goto free_and_return;
  }
#endif

  if (sys_sem_new(&conn->op_completed, 0) != ERR_OK) {
 800c98a:	f100 060c 	add.w	r6, r0, #12
  if (conn == NULL) {
    return NULL;
  }

  conn->last_err = ERR_OK;
  conn->type = t;
 800c98e:	7005      	strb	r5, [r0, #0]
  conn = (struct netconn *)memp_malloc(MEMP_NETCONN);
  if (conn == NULL) {
    return NULL;
  }

  conn->last_err = ERR_OK;
 800c990:	7201      	strb	r1, [r0, #8]
  conn->type = t;
  conn->pcb.tcp = NULL;
 800c992:	6041      	str	r1, [r0, #4]
    LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
    goto free_and_return;
  }
#endif

  if (sys_sem_new(&conn->op_completed, 0) != ERR_OK) {
 800c994:	4630      	mov	r0, r6
 800c996:	f006 fbb5 	bl	8013104 <sys_sem_new>
 800c99a:	b9e0      	cbnz	r0, 800c9d6 <netconn_alloc+0x5e>
    goto free_and_return;
  }
  if (sys_mbox_new(&conn->recvmbox, size) != ERR_OK) {
 800c99c:	2114      	movs	r1, #20
 800c99e:	f104 0034 	add.w	r0, r4, #52	; 0x34
 800c9a2:	f006 fad7 	bl	8012f54 <sys_mbox_new>
 800c9a6:	4605      	mov	r5, r0
 800c9a8:	b990      	cbnz	r0, 800c9d0 <netconn_alloc+0x58>
    sys_sem_free(&conn->op_completed);
    goto free_and_return;
  }

#if LWIP_TCP
  sys_mbox_set_invalid(&conn->acceptmbox);
 800c9aa:	f104 0064 	add.w	r0, r4, #100	; 0x64
 800c9ae:	f006 fb97 	bl	80130e0 <sys_mbox_set_invalid>
#endif
  conn->state        = NETCONN_NONE;
#if LWIP_SOCKET
  /* initialize socket to -1 since 0 is a valid socket */
  conn->socket       = -1;
 800c9b2:	f04f 33ff 	mov.w	r3, #4294967295
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = RECV_BUFSIZE_DEFAULT;
  conn->recv_avail   = 0;
#endif /* LWIP_SO_RCVBUF */
  conn->flags = 0;
 800c9b6:	f884 5098 	strb.w	r5, [r4, #152]	; 0x98
  }

#if LWIP_TCP
  sys_mbox_set_invalid(&conn->acceptmbox);
#endif
  conn->state        = NETCONN_NONE;
 800c9ba:	7065      	strb	r5, [r4, #1]
#if LWIP_SOCKET
  /* initialize socket to -1 since 0 is a valid socket */
  conn->socket       = -1;
#endif /* LWIP_SOCKET */
  conn->callback     = callback;
 800c9bc:	f8c4 70a4 	str.w	r7, [r4, #164]	; 0xa4
#if LWIP_TCP
  conn->current_msg  = NULL;
 800c9c0:	f8c4 50a0 	str.w	r5, [r4, #160]	; 0xa0
  conn->write_offset = 0;
 800c9c4:	f8c4 509c 	str.w	r5, [r4, #156]	; 0x9c
  sys_mbox_set_invalid(&conn->acceptmbox);
#endif
  conn->state        = NETCONN_NONE;
#if LWIP_SOCKET
  /* initialize socket to -1 since 0 is a valid socket */
  conn->socket       = -1;
 800c9c8:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = RECV_BUFSIZE_DEFAULT;
  conn->recv_avail   = 0;
#endif /* LWIP_SO_RCVBUF */
  conn->flags = 0;
  return conn;
 800c9cc:	4620      	mov	r0, r4
 800c9ce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

  if (sys_sem_new(&conn->op_completed, 0) != ERR_OK) {
    goto free_and_return;
  }
  if (sys_mbox_new(&conn->recvmbox, size) != ERR_OK) {
    sys_sem_free(&conn->op_completed);
 800c9d0:	4630      	mov	r0, r6
 800c9d2:	f006 fbef 	bl	80131b4 <sys_sem_free>
  conn->recv_avail   = 0;
#endif /* LWIP_SO_RCVBUF */
  conn->flags = 0;
  return conn;
free_and_return:
  memp_free(MEMP_NETCONN, conn);
 800c9d6:	4621      	mov	r1, r4
 800c9d8:	2007      	movs	r0, #7
 800c9da:	f003 f98f 	bl	800fcfc <memp_free>
  return NULL;
 800c9de:	2000      	movs	r0, #0
 800c9e0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
}
 800c9e2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0800c9e4 <netconn_free>:
 *
 * @param conn the netconn to free
 */
void
netconn_free(struct netconn *conn)
{
 800c9e4:	b538      	push	{r3, r4, r5, lr}
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
 800c9e6:	6843      	ldr	r3, [r0, #4]
 *
 * @param conn the netconn to free
 */
void
netconn_free(struct netconn *conn)
{
 800c9e8:	4604      	mov	r4, r0
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
 800c9ea:	b133      	cbz	r3, 800c9fa <netconn_free+0x16>
 800c9ec:	4b16      	ldr	r3, [pc, #88]	; (800ca48 <netconn_free+0x64>)
 800c9ee:	f240 2293 	movw	r2, #659	; 0x293
 800c9f2:	4916      	ldr	r1, [pc, #88]	; (800ca4c <netconn_free+0x68>)
 800c9f4:	4816      	ldr	r0, [pc, #88]	; (800ca50 <netconn_free+0x6c>)
 800c9f6:	f008 f9bf 	bl	8014d78 <iprintf>
  LWIP_ASSERT("recvmbox must be deallocated before calling this function",
 800c9fa:	f104 0034 	add.w	r0, r4, #52	; 0x34
 800c9fe:	f006 fb61 	bl	80130c4 <sys_mbox_valid>
 800ca02:	b9c8      	cbnz	r0, 800ca38 <netconn_free+0x54>
    !sys_mbox_valid(&conn->recvmbox));
#if LWIP_TCP
  LWIP_ASSERT("acceptmbox must be deallocated before calling this function",
 800ca04:	f104 0064 	add.w	r0, r4, #100	; 0x64
 800ca08:	f006 fb5c 	bl	80130c4 <sys_mbox_valid>
 800ca0c:	b130      	cbz	r0, 800ca1c <netconn_free+0x38>
 800ca0e:	4b0e      	ldr	r3, [pc, #56]	; (800ca48 <netconn_free+0x64>)
 800ca10:	f44f 7226 	mov.w	r2, #664	; 0x298
 800ca14:	490f      	ldr	r1, [pc, #60]	; (800ca54 <netconn_free+0x70>)
 800ca16:	480e      	ldr	r0, [pc, #56]	; (800ca50 <netconn_free+0x6c>)
 800ca18:	f008 f9ae 	bl	8014d78 <iprintf>
    !sys_mbox_valid(&conn->acceptmbox));
#endif /* LWIP_TCP */

  sys_sem_free(&conn->op_completed);
 800ca1c:	f104 050c 	add.w	r5, r4, #12
 800ca20:	4628      	mov	r0, r5
 800ca22:	f006 fbc7 	bl	80131b4 <sys_sem_free>
  sys_sem_set_invalid(&conn->op_completed);
 800ca26:	4628      	mov	r0, r5
 800ca28:	f006 fbec 	bl	8013204 <sys_sem_set_invalid>

  memp_free(MEMP_NETCONN, conn);
 800ca2c:	4621      	mov	r1, r4
}
 800ca2e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
#endif /* LWIP_TCP */

  sys_sem_free(&conn->op_completed);
  sys_sem_set_invalid(&conn->op_completed);

  memp_free(MEMP_NETCONN, conn);
 800ca32:	2007      	movs	r0, #7
 800ca34:	f003 b962 	b.w	800fcfc <memp_free>
 */
void
netconn_free(struct netconn *conn)
{
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  LWIP_ASSERT("recvmbox must be deallocated before calling this function",
 800ca38:	4b03      	ldr	r3, [pc, #12]	; (800ca48 <netconn_free+0x64>)
 800ca3a:	f240 2295 	movw	r2, #661	; 0x295
 800ca3e:	4906      	ldr	r1, [pc, #24]	; (800ca58 <netconn_free+0x74>)
 800ca40:	4803      	ldr	r0, [pc, #12]	; (800ca50 <netconn_free+0x6c>)
 800ca42:	f008 f999 	bl	8014d78 <iprintf>
 800ca46:	e7dd      	b.n	800ca04 <netconn_free+0x20>
 800ca48:	0801719c 	.word	0x0801719c
 800ca4c:	08017428 	.word	0x08017428
 800ca50:	0801660c 	.word	0x0801660c
 800ca54:	08017494 	.word	0x08017494
 800ca58:	08017458 	.word	0x08017458

0800ca5c <netconn_drain>:
 * @bytes_drained bytes drained from recvmbox
 * @accepts_drained pending connections drained from acceptmbox
 */
static void
netconn_drain(struct netconn *conn)
{
 800ca5c:	b5f0      	push	{r4, r5, r6, r7, lr}
#endif /* LWIP_TCP */

  /* This runs in tcpip_thread, so we don't need to lock against rx packets */

  /* Delete and drain the recvmbox. */
  if (sys_mbox_valid(&conn->recvmbox)) {
 800ca5e:	f100 0434 	add.w	r4, r0, #52	; 0x34
 * @bytes_drained bytes drained from recvmbox
 * @accepts_drained pending connections drained from acceptmbox
 */
static void
netconn_drain(struct netconn *conn)
{
 800ca62:	b083      	sub	sp, #12
 800ca64:	4605      	mov	r5, r0
#endif /* LWIP_TCP */

  /* This runs in tcpip_thread, so we don't need to lock against rx packets */

  /* Delete and drain the recvmbox. */
  if (sys_mbox_valid(&conn->recvmbox)) {
 800ca66:	4620      	mov	r0, r4
 800ca68:	f006 fb2c 	bl	80130c4 <sys_mbox_valid>
 800ca6c:	b300      	cbz	r0, 800cab0 <netconn_drain+0x54>
 800ca6e:	ae01      	add	r6, sp, #4
    while (sys_mbox_tryfetch(&conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
 800ca70:	2201      	movs	r2, #1
 800ca72:	4631      	mov	r1, r6
 800ca74:	4620      	mov	r0, r4
 800ca76:	f006 fb03 	bl	8013080 <sys_arch_mbox_fetch>
 800ca7a:	3001      	adds	r0, #1
 800ca7c:	d012      	beq.n	800caa4 <netconn_drain+0x48>
#if LWIP_TCP
      if (conn->type == NETCONN_TCP) {
 800ca7e:	782b      	ldrb	r3, [r5, #0]
 800ca80:	2b10      	cmp	r3, #16
 800ca82:	d10b      	bne.n	800ca9c <netconn_drain+0x40>
        if(mem != NULL) {
 800ca84:	9f01      	ldr	r7, [sp, #4]
 800ca86:	2f00      	cmp	r7, #0
 800ca88:	d0f2      	beq.n	800ca70 <netconn_drain+0x14>
          p = (struct pbuf*)mem;
          /* pcb might be set to NULL already by err_tcp() */
          if (conn->pcb.tcp != NULL) {
 800ca8a:	6868      	ldr	r0, [r5, #4]
 800ca8c:	b110      	cbz	r0, 800ca94 <netconn_drain+0x38>
            tcp_recved(conn->pcb.tcp, p->tot_len);
 800ca8e:	8939      	ldrh	r1, [r7, #8]
 800ca90:	f7fc fdfa 	bl	8009688 <tcp_recved>
          }
          pbuf_free(p);
 800ca94:	4638      	mov	r0, r7
 800ca96:	f003 fac7 	bl	8010028 <pbuf_free>
 800ca9a:	e7e9      	b.n	800ca70 <netconn_drain+0x14>
        }
      } else
#endif /* LWIP_TCP */
      {
        netbuf_delete((struct netbuf *)mem);
 800ca9c:	9801      	ldr	r0, [sp, #4]
 800ca9e:	f003 f95f 	bl	800fd60 <netbuf_delete>
 800caa2:	e7e5      	b.n	800ca70 <netconn_drain+0x14>
      }
    }
    sys_mbox_free(&conn->recvmbox);
 800caa4:	4620      	mov	r0, r4
 800caa6:	f006 fa79 	bl	8012f9c <sys_mbox_free>
    sys_mbox_set_invalid(&conn->recvmbox);
 800caaa:	4620      	mov	r0, r4
 800caac:	f006 fb18 	bl	80130e0 <sys_mbox_set_invalid>
  }

  /* Delete and drain the acceptmbox. */
#if LWIP_TCP
  if (sys_mbox_valid(&conn->acceptmbox)) {
 800cab0:	f105 0764 	add.w	r7, r5, #100	; 0x64
 800cab4:	4638      	mov	r0, r7
 800cab6:	f006 fb05 	bl	80130c4 <sys_mbox_valid>
 800caba:	b338      	cbz	r0, 800cb0c <netconn_drain+0xb0>
 800cabc:	ae01      	add	r6, sp, #4
 800cabe:	e018      	b.n	800caf2 <netconn_drain+0x96>
    while (sys_mbox_tryfetch(&conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
      struct netconn *newconn = (struct netconn *)mem;
      /* Only tcp pcbs have an acceptmbox, so no need to check conn->type */
      /* pcb might be set to NULL already by err_tcp() */
      if (conn->pcb.tcp != NULL) {
 800cac0:	686a      	ldr	r2, [r5, #4]
        tcp_accepted(conn->pcb.tcp);
 800cac2:	4b13      	ldr	r3, [pc, #76]	; (800cb10 <netconn_drain+0xb4>)
 800cac4:	4913      	ldr	r1, [pc, #76]	; (800cb14 <netconn_drain+0xb8>)
 800cac6:	4814      	ldr	r0, [pc, #80]	; (800cb18 <netconn_drain+0xbc>)

  /* Delete and drain the acceptmbox. */
#if LWIP_TCP
  if (sys_mbox_valid(&conn->acceptmbox)) {
    while (sys_mbox_tryfetch(&conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
      struct netconn *newconn = (struct netconn *)mem;
 800cac8:	9c01      	ldr	r4, [sp, #4]
      /* Only tcp pcbs have an acceptmbox, so no need to check conn->type */
      /* pcb might be set to NULL already by err_tcp() */
      if (conn->pcb.tcp != NULL) {
 800caca:	b132      	cbz	r2, 800cada <netconn_drain+0x7e>
        tcp_accepted(conn->pcb.tcp);
 800cacc:	7e12      	ldrb	r2, [r2, #24]
 800cace:	2a01      	cmp	r2, #1
 800cad0:	d003      	beq.n	800cada <netconn_drain+0x7e>
 800cad2:	f240 22d2 	movw	r2, #722	; 0x2d2
 800cad6:	f008 f94f 	bl	8014d78 <iprintf>
      }
      /* drain recvmbox */
      netconn_drain(newconn);
 800cada:	4620      	mov	r0, r4
 800cadc:	f7ff ffbe 	bl	800ca5c <netconn_drain>
      if (newconn->pcb.tcp != NULL) {
 800cae0:	6860      	ldr	r0, [r4, #4]
 800cae2:	b118      	cbz	r0, 800caec <netconn_drain+0x90>
        tcp_abort(newconn->pcb.tcp);
 800cae4:	f7fd fbf0 	bl	800a2c8 <tcp_abort>
        newconn->pcb.tcp = NULL;
 800cae8:	2300      	movs	r3, #0
 800caea:	6063      	str	r3, [r4, #4]
      }
      netconn_free(newconn);
 800caec:	4620      	mov	r0, r4
 800caee:	f7ff ff79 	bl	800c9e4 <netconn_free>
  }

  /* Delete and drain the acceptmbox. */
#if LWIP_TCP
  if (sys_mbox_valid(&conn->acceptmbox)) {
    while (sys_mbox_tryfetch(&conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
 800caf2:	2201      	movs	r2, #1
 800caf4:	4631      	mov	r1, r6
 800caf6:	4638      	mov	r0, r7
 800caf8:	f006 fac2 	bl	8013080 <sys_arch_mbox_fetch>
 800cafc:	3001      	adds	r0, #1
 800cafe:	d1df      	bne.n	800cac0 <netconn_drain+0x64>
        tcp_abort(newconn->pcb.tcp);
        newconn->pcb.tcp = NULL;
      }
      netconn_free(newconn);
    }
    sys_mbox_free(&conn->acceptmbox);
 800cb00:	4638      	mov	r0, r7
 800cb02:	f006 fa4b 	bl	8012f9c <sys_mbox_free>
    sys_mbox_set_invalid(&conn->acceptmbox);
 800cb06:	4638      	mov	r0, r7
 800cb08:	f006 faea 	bl	80130e0 <sys_mbox_set_invalid>
  }
#endif /* LWIP_TCP */
}
 800cb0c:	b003      	add	sp, #12
 800cb0e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800cb10:	0801719c 	.word	0x0801719c
 800cb14:	080174d0 	.word	0x080174d0
 800cb18:	0801660c 	.word	0x0801660c

0800cb1c <accept_function>:
 *
 * @see tcp.h (struct tcp_pcb_listen.accept) for parameters and return value
 */
static err_t
accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
{
 800cb1c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  struct netconn *newconn;
  struct netconn *conn = (struct netconn *)arg;

  LWIP_DEBUGF(API_MSG_DEBUG, ("accept_function: newpcb->tate: %s\n", tcp_debug_state_str(newpcb->state)));

  if (!sys_mbox_valid(&conn->acceptmbox)) {
 800cb20:	f100 0564 	add.w	r5, r0, #100	; 0x64
 *
 * @see tcp.h (struct tcp_pcb_listen.accept) for parameters and return value
 */
static err_t
accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
{
 800cb24:	4604      	mov	r4, r0
  struct netconn *newconn;
  struct netconn *conn = (struct netconn *)arg;

  LWIP_DEBUGF(API_MSG_DEBUG, ("accept_function: newpcb->tate: %s\n", tcp_debug_state_str(newpcb->state)));

  if (!sys_mbox_valid(&conn->acceptmbox)) {
 800cb26:	4628      	mov	r0, r5
 *
 * @see tcp.h (struct tcp_pcb_listen.accept) for parameters and return value
 */
static err_t
accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
{
 800cb28:	4688      	mov	r8, r1
 800cb2a:	4617      	mov	r7, r2
  struct netconn *newconn;
  struct netconn *conn = (struct netconn *)arg;

  LWIP_DEBUGF(API_MSG_DEBUG, ("accept_function: newpcb->tate: %s\n", tcp_debug_state_str(newpcb->state)));

  if (!sys_mbox_valid(&conn->acceptmbox)) {
 800cb2c:	f006 faca 	bl	80130c4 <sys_mbox_valid>
 800cb30:	b1d8      	cbz	r0, 800cb6a <accept_function+0x4e>
    return ERR_VAL;
  }

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
 800cb32:	f8d4 10a4 	ldr.w	r1, [r4, #164]	; 0xa4
 800cb36:	7820      	ldrb	r0, [r4, #0]
 800cb38:	f7ff ff1e 	bl	800c978 <netconn_alloc>
  if (newconn == NULL) {
 800cb3c:	4606      	mov	r6, r0
 800cb3e:	b1b8      	cbz	r0, 800cb70 <accept_function+0x54>
    return ERR_MEM;
  }
  newconn->pcb.tcp = newpcb;
 800cb40:	f8c0 8004 	str.w	r8, [r0, #4]
  setup_tcp(newconn);
 800cb44:	f7ff fb14 	bl	800c170 <setup_tcp>
  /* no protection: when creating the pcb, the netconn is not yet known
     to the application thread */
  newconn->last_err = err;

  if (sys_mbox_trypost(&conn->acceptmbox, newconn) != ERR_OK) {
 800cb48:	4628      	mov	r0, r5
  }
  newconn->pcb.tcp = newpcb;
  setup_tcp(newconn);
  /* no protection: when creating the pcb, the netconn is not yet known
     to the application thread */
  newconn->last_err = err;
 800cb4a:	7237      	strb	r7, [r6, #8]

  if (sys_mbox_trypost(&conn->acceptmbox, newconn) != ERR_OK) {
 800cb4c:	4631      	mov	r1, r6
 800cb4e:	f006 fa7d 	bl	801304c <sys_mbox_trypost>
 800cb52:	4605      	mov	r5, r0
 800cb54:	b978      	cbnz	r0, 800cb76 <accept_function+0x5a>
    sys_mbox_set_invalid(&newconn->recvmbox);
    netconn_free(newconn);
    return ERR_MEM;
  } else {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
 800cb56:	f8d4 30a4 	ldr.w	r3, [r4, #164]	; 0xa4
 800cb5a:	b11b      	cbz	r3, 800cb64 <accept_function+0x48>
 800cb5c:	4620      	mov	r0, r4
 800cb5e:	462a      	mov	r2, r5
 800cb60:	4629      	mov	r1, r5
 800cb62:	4798      	blx	r3
  }

  return ERR_OK;
}
 800cb64:	4628      	mov	r0, r5
 800cb66:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

  LWIP_DEBUGF(API_MSG_DEBUG, ("accept_function: newpcb->tate: %s\n", tcp_debug_state_str(newpcb->state)));

  if (!sys_mbox_valid(&conn->acceptmbox)) {
    LWIP_DEBUGF(API_MSG_DEBUG, ("accept_function: acceptmbox already deleted\n"));
    return ERR_VAL;
 800cb6a:	f06f 0505 	mvn.w	r5, #5
 800cb6e:	e7f9      	b.n	800cb64 <accept_function+0x48>

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
  if (newconn == NULL) {
    return ERR_MEM;
 800cb70:	f04f 35ff 	mov.w	r5, #4294967295
 800cb74:	e7f6      	b.n	800cb64 <accept_function+0x48>

  if (sys_mbox_trypost(&conn->acceptmbox, newconn) != ERR_OK) {
    /* When returning != ERR_OK, the pcb is aborted in tcp_process(),
       so do nothing here! */
    /* remove all references to this netconn from the pcb */
    struct tcp_pcb* pcb = newconn->pcb.tcp;
 800cb76:	6874      	ldr	r4, [r6, #4]
    tcp_arg(pcb, NULL);
 800cb78:	2100      	movs	r1, #0
 800cb7a:	4620      	mov	r0, r4
 800cb7c:	f7fd f8d8 	bl	8009d30 <tcp_arg>
    tcp_recv(pcb, NULL);
 800cb80:	4620      	mov	r0, r4
 800cb82:	2100      	movs	r1, #0
 800cb84:	f7fd f8d6 	bl	8009d34 <tcp_recv>
    tcp_sent(pcb, NULL);
 800cb88:	4620      	mov	r0, r4
 800cb8a:	2100      	movs	r1, #0
 800cb8c:	f7fd f8ea 	bl	8009d64 <tcp_sent>
    tcp_poll(pcb, NULL, 4);
 800cb90:	2204      	movs	r2, #4
 800cb92:	4620      	mov	r0, r4
 800cb94:	2100      	movs	r1, #0
 800cb96:	f7fd f919 	bl	8009dcc <tcp_poll>
    tcp_err(pcb, NULL);
 800cb9a:	2100      	movs	r1, #0
 800cb9c:	4620      	mov	r0, r4
 800cb9e:	f7fd f8f9 	bl	8009d94 <tcp_err>
    /* remove reference from to the pcb from this netconn */
    newconn->pcb.tcp = NULL;
    /* no need to drain since we know the recvmbox is empty. */
    sys_mbox_free(&newconn->recvmbox);
 800cba2:	f106 0434 	add.w	r4, r6, #52	; 0x34
    tcp_recv(pcb, NULL);
    tcp_sent(pcb, NULL);
    tcp_poll(pcb, NULL, 4);
    tcp_err(pcb, NULL);
    /* remove reference from to the pcb from this netconn */
    newconn->pcb.tcp = NULL;
 800cba6:	2300      	movs	r3, #0
 800cba8:	6073      	str	r3, [r6, #4]
    /* no need to drain since we know the recvmbox is empty. */
    sys_mbox_free(&newconn->recvmbox);
 800cbaa:	4620      	mov	r0, r4
 800cbac:	f006 f9f6 	bl	8012f9c <sys_mbox_free>
    sys_mbox_set_invalid(&newconn->recvmbox);
 800cbb0:	4620      	mov	r0, r4
 800cbb2:	f006 fa95 	bl	80130e0 <sys_mbox_set_invalid>
    netconn_free(newconn);
 800cbb6:	4630      	mov	r0, r6
 800cbb8:	f7ff ff14 	bl	800c9e4 <netconn_free>
    return ERR_MEM;
 800cbbc:	f04f 35ff 	mov.w	r5, #4294967295
 800cbc0:	e7d0      	b.n	800cb64 <accept_function+0x48>
 800cbc2:	bf00      	nop

0800cbc4 <do_delconn>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_delconn(struct api_msg_msg *msg)
{
 800cbc4:	b538      	push	{r3, r4, r5, lr}
  /* @todo TCP: abort running write/connect? */
 if ((msg->conn->state != NETCONN_NONE) &&
 800cbc6:	6803      	ldr	r3, [r0, #0]
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_delconn(struct api_msg_msg *msg)
{
 800cbc8:	4604      	mov	r4, r0
  /* @todo TCP: abort running write/connect? */
 if ((msg->conn->state != NETCONN_NONE) &&
 800cbca:	785a      	ldrb	r2, [r3, #1]
 800cbcc:	f012 0ffd 	tst.w	r2, #253	; 0xfd
 800cbd0:	d021      	beq.n	800cc16 <do_delconn+0x52>
     (msg->conn->state != NETCONN_LISTEN) &&
 800cbd2:	2a03      	cmp	r2, #3
 800cbd4:	d013      	beq.n	800cbfe <do_delconn+0x3a>
     (msg->conn->state != NETCONN_CONNECT)) {
    /* this only happens for TCP netconns */
    LWIP_ASSERT("msg->conn->type == NETCONN_TCP", msg->conn->type == NETCONN_TCP);
 800cbd6:	781a      	ldrb	r2, [r3, #0]
 800cbd8:	2a10      	cmp	r2, #16
 800cbda:	d007      	beq.n	800cbec <do_delconn+0x28>
 800cbdc:	4b38      	ldr	r3, [pc, #224]	; (800ccc0 <do_delconn+0xfc>)
 800cbde:	f240 3247 	movw	r2, #839	; 0x347
 800cbe2:	4938      	ldr	r1, [pc, #224]	; (800ccc4 <do_delconn+0x100>)
 800cbe4:	4838      	ldr	r0, [pc, #224]	; (800ccc8 <do_delconn+0x104>)
 800cbe6:	f008 f8c7 	bl	8014d78 <iprintf>
 800cbea:	6823      	ldr	r3, [r4, #0]
    msg->err = ERR_INPROGRESS;
 800cbec:	22fb      	movs	r2, #251	; 0xfb
 800cbee:	7122      	strb	r2, [r4, #4]
    /* @todo: this lets select make the socket readable and writable,
       which is wrong! errfd instead? */
    API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
    API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  }
  if (sys_sem_valid(&msg->conn->op_completed)) {
 800cbf0:	f103 000c 	add.w	r0, r3, #12
 800cbf4:	f006 faf8 	bl	80131e8 <sys_sem_valid>
 800cbf8:	2800      	cmp	r0, #0
 800cbfa:	d136      	bne.n	800cc6a <do_delconn+0xa6>
 800cbfc:	bd38      	pop	{r3, r4, r5, pc}
     (msg->conn->state != NETCONN_CONNECT)) {
    /* this only happens for TCP netconns */
    LWIP_ASSERT("msg->conn->type == NETCONN_TCP", msg->conn->type == NETCONN_TCP);
    msg->err = ERR_INPROGRESS;
  } else {
    LWIP_ASSERT("blocking connect in progress",
 800cbfe:	f893 2098 	ldrb.w	r2, [r3, #152]	; 0x98
 800cc02:	0752      	lsls	r2, r2, #29
 800cc04:	d407      	bmi.n	800cc16 <do_delconn+0x52>
 800cc06:	4b2e      	ldr	r3, [pc, #184]	; (800ccc0 <do_delconn+0xfc>)
 800cc08:	f240 324b 	movw	r2, #843	; 0x34b
 800cc0c:	492f      	ldr	r1, [pc, #188]	; (800cccc <do_delconn+0x108>)
 800cc0e:	482e      	ldr	r0, [pc, #184]	; (800ccc8 <do_delconn+0x104>)
 800cc10:	f008 f8b2 	bl	8014d78 <iprintf>
 800cc14:	6823      	ldr	r3, [r4, #0]
      (msg->conn->state != NETCONN_CONNECT) || IN_NONBLOCKING_CONNECT(msg->conn));
    /* Drain and delete mboxes */
    netconn_drain(msg->conn);
 800cc16:	4618      	mov	r0, r3
 800cc18:	f7ff ff20 	bl	800ca5c <netconn_drain>

    if (msg->conn->pcb.tcp != NULL) {
 800cc1c:	6823      	ldr	r3, [r4, #0]
 800cc1e:	6858      	ldr	r0, [r3, #4]
 800cc20:	b158      	cbz	r0, 800cc3a <do_delconn+0x76>

      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
 800cc22:	781a      	ldrb	r2, [r3, #0]
 800cc24:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 800cc28:	2a20      	cmp	r2, #32
 800cc2a:	d024      	beq.n	800cc76 <do_delconn+0xb2>
 800cc2c:	2a40      	cmp	r2, #64	; 0x40
 800cc2e:	d03e      	beq.n	800ccae <do_delconn+0xea>
 800cc30:	2a10      	cmp	r2, #16
 800cc32:	d027      	beq.n	800cc84 <do_delconn+0xc0>
        return;
#endif /* LWIP_TCP */
      default:
        break;
      }
      msg->conn->pcb.tcp = NULL;
 800cc34:	2200      	movs	r2, #0
 800cc36:	605a      	str	r2, [r3, #4]
 800cc38:	6823      	ldr	r3, [r4, #0]
    }
    /* tcp netconns don't come here! */

    /* @todo: this lets select make the socket readable and writable,
       which is wrong! errfd instead? */
    API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
 800cc3a:	f8d3 50a4 	ldr.w	r5, [r3, #164]	; 0xa4
 800cc3e:	2d00      	cmp	r5, #0
 800cc40:	d0d6      	beq.n	800cbf0 <do_delconn+0x2c>
 800cc42:	2200      	movs	r2, #0
 800cc44:	4618      	mov	r0, r3
 800cc46:	4611      	mov	r1, r2
 800cc48:	47a8      	blx	r5
    API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
 800cc4a:	6823      	ldr	r3, [r4, #0]
 800cc4c:	f8d3 50a4 	ldr.w	r5, [r3, #164]	; 0xa4
 800cc50:	2d00      	cmp	r5, #0
 800cc52:	d0cd      	beq.n	800cbf0 <do_delconn+0x2c>
 800cc54:	4618      	mov	r0, r3
 800cc56:	2200      	movs	r2, #0
 800cc58:	2102      	movs	r1, #2
 800cc5a:	47a8      	blx	r5
 800cc5c:	6823      	ldr	r3, [r4, #0]
  }
  if (sys_sem_valid(&msg->conn->op_completed)) {
 800cc5e:	f103 000c 	add.w	r0, r3, #12
 800cc62:	f006 fac1 	bl	80131e8 <sys_sem_valid>
 800cc66:	2800      	cmp	r0, #0
 800cc68:	d0c8      	beq.n	800cbfc <do_delconn+0x38>
    sys_sem_signal(&msg->conn->op_completed);
 800cc6a:	6820      	ldr	r0, [r4, #0]
  }
}
 800cc6c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
       which is wrong! errfd instead? */
    API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
    API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  }
  if (sys_sem_valid(&msg->conn->op_completed)) {
    sys_sem_signal(&msg->conn->op_completed);
 800cc70:	300c      	adds	r0, #12
 800cc72:	f006 ba85 	b.w	8013180 <sys_sem_signal>
        raw_remove(msg->conn->pcb.raw);
        break;
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        msg->conn->pcb.udp->recv_arg = NULL;
 800cc76:	2200      	movs	r2, #0
 800cc78:	61c2      	str	r2, [r0, #28]
        udp_remove(msg->conn->pcb.udp);
 800cc7a:	6858      	ldr	r0, [r3, #4]
 800cc7c:	f007 fdd2 	bl	8014824 <udp_remove>
 800cc80:	6823      	ldr	r3, [r4, #0]
        break;
 800cc82:	e7d7      	b.n	800cc34 <do_delconn+0x70>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
 800cc84:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
 800cc88:	b1aa      	cbz	r2, 800ccb6 <do_delconn+0xf2>
 800cc8a:	4b0d      	ldr	r3, [pc, #52]	; (800ccc0 <do_delconn+0xfc>)
 800cc8c:	f44f 7258 	mov.w	r2, #864	; 0x360
 800cc90:	490f      	ldr	r1, [pc, #60]	; (800ccd0 <do_delconn+0x10c>)
 800cc92:	480d      	ldr	r0, [pc, #52]	; (800ccc8 <do_delconn+0x104>)
 800cc94:	f008 f870 	bl	8014d78 <iprintf>
 800cc98:	6823      	ldr	r3, [r4, #0]
          msg->conn->write_offset == 0);
        msg->conn->state = NETCONN_CLOSE;
 800cc9a:	2104      	movs	r1, #4
        msg->msg.sd.shut = NETCONN_SHUT_RDWR;
 800cc9c:	2203      	movs	r2, #3
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
          msg->conn->write_offset == 0);
        msg->conn->state = NETCONN_CLOSE;
 800cc9e:	7059      	strb	r1, [r3, #1]
        msg->msg.sd.shut = NETCONN_SHUT_RDWR;
 800cca0:	7222      	strb	r2, [r4, #8]
        msg->conn->current_msg = msg;
        do_close_internal(msg->conn);
 800cca2:	4618      	mov	r0, r3
      case NETCONN_TCP:
        LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
          msg->conn->write_offset == 0);
        msg->conn->state = NETCONN_CLOSE;
        msg->msg.sd.shut = NETCONN_SHUT_RDWR;
        msg->conn->current_msg = msg;
 800cca4:	f8c3 40a0 	str.w	r4, [r3, #160]	; 0xa0
    API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  }
  if (sys_sem_valid(&msg->conn->op_completed)) {
    sys_sem_signal(&msg->conn->op_completed);
  }
}
 800cca8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
          msg->conn->write_offset == 0);
        msg->conn->state = NETCONN_CLOSE;
        msg->msg.sd.shut = NETCONN_SHUT_RDWR;
        msg->conn->current_msg = msg;
        do_close_internal(msg->conn);
 800ccac:	e45a      	b.n	800c564 <do_close_internal>
    if (msg->conn->pcb.tcp != NULL) {

      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
      case NETCONN_RAW:
        raw_remove(msg->conn->pcb.raw);
 800ccae:	f003 feb3 	bl	8010a18 <raw_remove>
 800ccb2:	6823      	ldr	r3, [r4, #0]
        break;
 800ccb4:	e7be      	b.n	800cc34 <do_delconn+0x70>
        udp_remove(msg->conn->pcb.udp);
        break;
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
 800ccb6:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
 800ccba:	2a00      	cmp	r2, #0
 800ccbc:	d1e5      	bne.n	800cc8a <do_delconn+0xc6>
 800ccbe:	e7ec      	b.n	800cc9a <do_delconn+0xd6>
 800ccc0:	0801719c 	.word	0x0801719c
 800ccc4:	08017500 	.word	0x08017500
 800ccc8:	0801660c 	.word	0x0801660c
 800cccc:	08017520 	.word	0x08017520
 800ccd0:	08017540 	.word	0x08017540

0800ccd4 <do_bind>:
 *            the IP address and port to bind to
 */
void
do_bind(struct api_msg_msg *msg)
{
  if (ERR_IS_FATAL(msg->conn->last_err)) {
 800ccd4:	6803      	ldr	r3, [r0, #0]
 800ccd6:	f993 2008 	ldrsb.w	r2, [r3, #8]
 800ccda:	f112 0f09 	cmn.w	r2, #9
 800ccde:	db14      	blt.n	800cd0a <do_bind+0x36>
    msg->err = msg->conn->last_err;
  } else {
    msg->err = ERR_VAL;
 800cce0:	22fa      	movs	r2, #250	; 0xfa
 800cce2:	7102      	strb	r2, [r0, #4]
    if (msg->conn->pcb.tcp != NULL) {
 800cce4:	6859      	ldr	r1, [r3, #4]
 800cce6:	b189      	cbz	r1, 800cd0c <do_bind+0x38>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
 800cce8:	781a      	ldrb	r2, [r3, #0]
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to bind to
 */
void
do_bind(struct api_msg_msg *msg)
{
 800ccea:	b510      	push	{r4, lr}
  if (ERR_IS_FATAL(msg->conn->last_err)) {
    msg->err = msg->conn->last_err;
  } else {
    msg->err = ERR_VAL;
    if (msg->conn->pcb.tcp != NULL) {
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
 800ccec:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 800ccf0:	2a20      	cmp	r2, #32
 800ccf2:	4604      	mov	r4, r0
 800ccf4:	d00e      	beq.n	800cd14 <do_bind+0x40>
 800ccf6:	2a40      	cmp	r2, #64	; 0x40
 800ccf8:	d026      	beq.n	800cd48 <do_bind+0x74>
 800ccfa:	2a10      	cmp	r2, #16
 800ccfc:	d017      	beq.n	800cd2e <do_bind+0x5a>
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
}
 800ccfe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
 800cd02:	f103 000c 	add.w	r0, r3, #12
 800cd06:	f006 ba3b 	b.w	8013180 <sys_sem_signal>
 */
void
do_bind(struct api_msg_msg *msg)
{
  if (ERR_IS_FATAL(msg->conn->last_err)) {
    msg->err = msg->conn->last_err;
 800cd0a:	7102      	strb	r2, [r0, #4]
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
 800cd0c:	f103 000c 	add.w	r0, r3, #12
 800cd10:	f006 ba36 	b.w	8013180 <sys_sem_signal>
        msg->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
        break;
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        msg->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
 800cd14:	4608      	mov	r0, r1
 800cd16:	89a2      	ldrh	r2, [r4, #12]
 800cd18:	68a1      	ldr	r1, [r4, #8]
 800cd1a:	f007 fc2f 	bl	801457c <udp_bind>
 800cd1e:	6823      	ldr	r3, [r4, #0]
 800cd20:	7120      	strb	r0, [r4, #4]
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
}
 800cd22:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
 800cd26:	f103 000c 	add.w	r0, r3, #12
 800cd2a:	f006 ba29 	b.w	8013180 <sys_sem_signal>
        msg->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
        break;
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        msg->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
 800cd2e:	4608      	mov	r0, r1
 800cd30:	89a2      	ldrh	r2, [r4, #12]
 800cd32:	68a1      	ldr	r1, [r4, #8]
 800cd34:	f7fc fbc8 	bl	80094c8 <tcp_bind>
 800cd38:	6823      	ldr	r3, [r4, #0]
 800cd3a:	7120      	strb	r0, [r4, #4]
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
}
 800cd3c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
 800cd40:	f103 000c 	add.w	r0, r3, #12
 800cd44:	f006 ba1c 	b.w	8013180 <sys_sem_signal>
    msg->err = ERR_VAL;
    if (msg->conn->pcb.tcp != NULL) {
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
      case NETCONN_RAW:
        msg->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
 800cd48:	4608      	mov	r0, r1
 800cd4a:	68a1      	ldr	r1, [r4, #8]
 800cd4c:	f003 fdf4 	bl	8010938 <raw_bind>
 800cd50:	6823      	ldr	r3, [r4, #0]
 800cd52:	7120      	strb	r0, [r4, #4]
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
}
 800cd54:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
 800cd58:	f103 000c 	add.w	r0, r3, #12
 800cd5c:	f006 ba10 	b.w	8013180 <sys_sem_signal>

0800cd60 <do_connect>:
 *            the IP address and port to connect to
 */
void
do_connect(struct api_msg_msg *msg)
{
  if (msg->conn->pcb.tcp == NULL) {
 800cd60:	6803      	ldr	r3, [r0, #0]
 800cd62:	6859      	ldr	r1, [r3, #4]
 800cd64:	2900      	cmp	r1, #0
 800cd66:	d058      	beq.n	800ce1a <do_connect+0xba>
    /* This may happen when calling netconn_connect() a second time */
    msg->err = ERR_CLSD;
  } else {
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
 800cd68:	781a      	ldrb	r2, [r3, #0]
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to connect to
 */
void
do_connect(struct api_msg_msg *msg)
{
 800cd6a:	b510      	push	{r4, lr}
  if (msg->conn->pcb.tcp == NULL) {
    /* This may happen when calling netconn_connect() a second time */
    msg->err = ERR_CLSD;
  } else {
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
 800cd6c:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 800cd70:	2a20      	cmp	r2, #32
 800cd72:	4604      	mov	r4, r0
 800cd74:	d029      	beq.n	800cdca <do_connect+0x6a>
 800cd76:	2a40      	cmp	r2, #64	; 0x40
 800cd78:	d011      	beq.n	800cd9e <do_connect+0x3e>
 800cd7a:	2a10      	cmp	r2, #16
 800cd7c:	d01b      	beq.n	800cdb6 <do_connect+0x56>
      }
    }
    break;
#endif /* LWIP_TCP */
  default:
    LWIP_ERROR("Invalid netconn type", 0, do{ msg->err = ERR_VAL; }while(0));
 800cd7e:	4b2f      	ldr	r3, [pc, #188]	; (800ce3c <do_connect+0xdc>)
 800cd80:	f240 4203 	movw	r2, #1027	; 0x403
 800cd84:	492e      	ldr	r1, [pc, #184]	; (800ce40 <do_connect+0xe0>)
 800cd86:	482f      	ldr	r0, [pc, #188]	; (800ce44 <do_connect+0xe4>)
 800cd88:	f007 fff6 	bl	8014d78 <iprintf>
 800cd8c:	22fa      	movs	r2, #250	; 0xfa
 800cd8e:	6823      	ldr	r3, [r4, #0]
 800cd90:	7122      	strb	r2, [r4, #4]
    break;
    }
  }
  sys_sem_signal(&msg->conn->op_completed);
 800cd92:	f103 000c 	add.w	r0, r3, #12
}
 800cd96:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  default:
    LWIP_ERROR("Invalid netconn type", 0, do{ msg->err = ERR_VAL; }while(0));
    break;
    }
  }
  sys_sem_signal(&msg->conn->op_completed);
 800cd9a:	f006 b9f1 	b.w	8013180 <sys_sem_signal>
    msg->err = ERR_CLSD;
  } else {
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
  case NETCONN_RAW:
    msg->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
 800cd9e:	4608      	mov	r0, r1
 800cda0:	68a1      	ldr	r1, [r4, #8]
 800cda2:	f003 fdcf 	bl	8010944 <raw_connect>
 800cda6:	6823      	ldr	r3, [r4, #0]
 800cda8:	7120      	strb	r0, [r4, #4]
    LWIP_ERROR("Invalid netconn type", 0, do{ msg->err = ERR_VAL; }while(0));
    break;
    }
  }
  sys_sem_signal(&msg->conn->op_completed);
}
 800cdaa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  default:
    LWIP_ERROR("Invalid netconn type", 0, do{ msg->err = ERR_VAL; }while(0));
    break;
    }
  }
  sys_sem_signal(&msg->conn->op_completed);
 800cdae:	f103 000c 	add.w	r0, r3, #12
 800cdb2:	f006 b9e5 	b.w	8013180 <sys_sem_signal>
    break;
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    /* Prevent connect while doing any other action. */
    if (msg->conn->state != NETCONN_NONE) {
 800cdb6:	785a      	ldrb	r2, [r3, #1]
 800cdb8:	b1a2      	cbz	r2, 800cde4 <do_connect+0x84>
      msg->err = ERR_ISCONN;
 800cdba:	22f7      	movs	r2, #247	; 0xf7
 800cdbc:	7102      	strb	r2, [r0, #4]
    LWIP_ERROR("Invalid netconn type", 0, do{ msg->err = ERR_VAL; }while(0));
    break;
    }
  }
  sys_sem_signal(&msg->conn->op_completed);
}
 800cdbe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  default:
    LWIP_ERROR("Invalid netconn type", 0, do{ msg->err = ERR_VAL; }while(0));
    break;
    }
  }
  sys_sem_signal(&msg->conn->op_completed);
 800cdc2:	f103 000c 	add.w	r0, r3, #12
 800cdc6:	f006 b9db 	b.w	8013180 <sys_sem_signal>
    msg->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
    break;
#endif /* LWIP_RAW */
#if LWIP_UDP
  case NETCONN_UDP:
    msg->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
 800cdca:	4608      	mov	r0, r1
 800cdcc:	89a2      	ldrh	r2, [r4, #12]
 800cdce:	68a1      	ldr	r1, [r4, #8]
 800cdd0:	f007 fcf2 	bl	80147b8 <udp_connect>
 800cdd4:	6823      	ldr	r3, [r4, #0]
 800cdd6:	7120      	strb	r0, [r4, #4]
    LWIP_ERROR("Invalid netconn type", 0, do{ msg->err = ERR_VAL; }while(0));
    break;
    }
  }
  sys_sem_signal(&msg->conn->op_completed);
}
 800cdd8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  default:
    LWIP_ERROR("Invalid netconn type", 0, do{ msg->err = ERR_VAL; }while(0));
    break;
    }
  }
  sys_sem_signal(&msg->conn->op_completed);
 800cddc:	f103 000c 	add.w	r0, r3, #12
 800cde0:	f006 b9ce 	b.w	8013180 <sys_sem_signal>
  case NETCONN_TCP:
    /* Prevent connect while doing any other action. */
    if (msg->conn->state != NETCONN_NONE) {
      msg->err = ERR_ISCONN;
    } else {
      setup_tcp(msg->conn);
 800cde4:	4618      	mov	r0, r3
 800cde6:	f7ff f9c3 	bl	800c170 <setup_tcp>
      msg->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr,
 800cdea:	6822      	ldr	r2, [r4, #0]
 800cdec:	4b16      	ldr	r3, [pc, #88]	; (800ce48 <do_connect+0xe8>)
 800cdee:	6850      	ldr	r0, [r2, #4]
 800cdf0:	68a1      	ldr	r1, [r4, #8]
 800cdf2:	89a2      	ldrh	r2, [r4, #12]
 800cdf4:	f7fc fc86 	bl	8009704 <tcp_connect>
 800cdf8:	7120      	strb	r0, [r4, #4]
        msg->msg.bc.port, do_connected);
      if (msg->err == ERR_OK) {
 800cdfa:	b9a0      	cbnz	r0, 800ce26 <do_connect+0xc6>
        u8_t non_blocking = netconn_is_nonblocking(msg->conn);
 800cdfc:	6822      	ldr	r2, [r4, #0]
        msg->conn->state = NETCONN_CONNECT;
 800cdfe:	2103      	movs	r1, #3
    } else {
      setup_tcp(msg->conn);
      msg->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr,
        msg->msg.bc.port, do_connected);
      if (msg->err == ERR_OK) {
        u8_t non_blocking = netconn_is_nonblocking(msg->conn);
 800ce00:	f892 3098 	ldrb.w	r3, [r2, #152]	; 0x98
        msg->conn->state = NETCONN_CONNECT;
 800ce04:	7051      	strb	r1, [r2, #1]
        SET_NONBLOCKING_CONNECT(msg->conn, non_blocking);
 800ce06:	0799      	lsls	r1, r3, #30
 800ce08:	d40f      	bmi.n	800ce2a <do_connect+0xca>
 800ce0a:	f023 0304 	bic.w	r3, r3, #4
 800ce0e:	f882 3098 	strb.w	r3, [r2, #152]	; 0x98
        if (non_blocking) {
          msg->err = ERR_INPROGRESS;
        } else {
          msg->conn->current_msg = msg;
 800ce12:	6823      	ldr	r3, [r4, #0]
 800ce14:	f8c3 40a0 	str.w	r4, [r3, #160]	; 0xa0
          /* sys_sem_signal() is called from do_connected (or err_tcp()),
          * when the connection is established! */
          return;
 800ce18:	bd10      	pop	{r4, pc}
void
do_connect(struct api_msg_msg *msg)
{
  if (msg->conn->pcb.tcp == NULL) {
    /* This may happen when calling netconn_connect() a second time */
    msg->err = ERR_CLSD;
 800ce1a:	22f4      	movs	r2, #244	; 0xf4
 800ce1c:	7102      	strb	r2, [r0, #4]
  default:
    LWIP_ERROR("Invalid netconn type", 0, do{ msg->err = ERR_VAL; }while(0));
    break;
    }
  }
  sys_sem_signal(&msg->conn->op_completed);
 800ce1e:	f103 000c 	add.w	r0, r3, #12
 800ce22:	f006 b9ad 	b.w	8013180 <sys_sem_signal>
 800ce26:	6823      	ldr	r3, [r4, #0]
 800ce28:	e7b3      	b.n	800cd92 <do_connect+0x32>
      msg->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr,
        msg->msg.bc.port, do_connected);
      if (msg->err == ERR_OK) {
        u8_t non_blocking = netconn_is_nonblocking(msg->conn);
        msg->conn->state = NETCONN_CONNECT;
        SET_NONBLOCKING_CONNECT(msg->conn, non_blocking);
 800ce2a:	f043 0304 	orr.w	r3, r3, #4
 800ce2e:	f882 3098 	strb.w	r3, [r2, #152]	; 0x98
        if (non_blocking) {
          msg->err = ERR_INPROGRESS;
 800ce32:	22fb      	movs	r2, #251	; 0xfb
 800ce34:	6823      	ldr	r3, [r4, #0]
 800ce36:	7122      	strb	r2, [r4, #4]
 800ce38:	e7ab      	b.n	800cd92 <do_connect+0x32>
 800ce3a:	bf00      	nop
 800ce3c:	0801719c 	.word	0x0801719c
 800ce40:	0801755c 	.word	0x0801755c
 800ce44:	0801660c 	.word	0x0801660c
 800ce48:	0800c2b1 	.word	0x0800c2b1

0800ce4c <do_disconnect>:
 */
void
do_disconnect(struct api_msg_msg *msg)
{
#if LWIP_UDP
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
 800ce4c:	6802      	ldr	r2, [r0, #0]
 800ce4e:	7813      	ldrb	r3, [r2, #0]
 800ce50:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800ce54:	2b20      	cmp	r3, #32
 800ce56:	d005      	beq.n	800ce64 <do_disconnect+0x18>
    udp_disconnect(msg->conn->pcb.udp);
    msg->err = ERR_OK;
  } else
#endif /* LWIP_UDP */
  {
    msg->err = ERR_VAL;
 800ce58:	23fa      	movs	r3, #250	; 0xfa
 800ce5a:	7103      	strb	r3, [r0, #4]
  }
  TCPIP_APIMSG_ACK(msg);
 800ce5c:	f102 000c 	add.w	r0, r2, #12
 800ce60:	f006 b98e 	b.w	8013180 <sys_sem_signal>
 *
 * @param msg the api_msg_msg pointing to the connection to disconnect
 */
void
do_disconnect(struct api_msg_msg *msg)
{
 800ce64:	b510      	push	{r4, lr}
 800ce66:	4604      	mov	r4, r0
#if LWIP_UDP
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
    udp_disconnect(msg->conn->pcb.udp);
 800ce68:	6850      	ldr	r0, [r2, #4]
 800ce6a:	f007 fccf 	bl	801480c <udp_disconnect>
 800ce6e:	6822      	ldr	r2, [r4, #0]
    msg->err = ERR_OK;
 800ce70:	2300      	movs	r3, #0
 800ce72:	7123      	strb	r3, [r4, #4]
  } else
#endif /* LWIP_UDP */
  {
    msg->err = ERR_VAL;
  }
  TCPIP_APIMSG_ACK(msg);
 800ce74:	f102 000c 	add.w	r0, r2, #12
}
 800ce78:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  } else
#endif /* LWIP_UDP */
  {
    msg->err = ERR_VAL;
  }
  TCPIP_APIMSG_ACK(msg);
 800ce7c:	f006 b980 	b.w	8013180 <sys_sem_signal>

0800ce80 <do_listen>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_listen(struct api_msg_msg *msg)
{
 800ce80:	b538      	push	{r3, r4, r5, lr}
  if (ERR_IS_FATAL(msg->conn->last_err)) {
 800ce82:	6803      	ldr	r3, [r0, #0]
 800ce84:	f993 2008 	ldrsb.w	r2, [r3, #8]
 800ce88:	f112 0f09 	cmn.w	r2, #9
 800ce8c:	db07      	blt.n	800ce9e <do_listen+0x1e>
    msg->err = msg->conn->last_err;
  } else {
    msg->err = ERR_CONN;
 800ce8e:	22f3      	movs	r2, #243	; 0xf3
 800ce90:	7102      	strb	r2, [r0, #4]
    if (msg->conn->pcb.tcp != NULL) {
 800ce92:	685a      	ldr	r2, [r3, #4]
 800ce94:	b122      	cbz	r2, 800cea0 <do_listen+0x20>
      if (msg->conn->type == NETCONN_TCP) {
 800ce96:	7819      	ldrb	r1, [r3, #0]
 800ce98:	2910      	cmp	r1, #16
 800ce9a:	d007      	beq.n	800ceac <do_listen+0x2c>
              msg->conn->pcb.tcp = NULL;
            }
          }
        }
      } else {
        msg->err = ERR_ARG;
 800ce9c:	22f2      	movs	r2, #242	; 0xf2
 800ce9e:	7102      	strb	r2, [r0, #4]
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
 800cea0:	f103 000c 	add.w	r0, r3, #12
}
 800cea4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      } else {
        msg->err = ERR_ARG;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
 800cea8:	f006 b96a 	b.w	8013180 <sys_sem_signal>
    msg->err = msg->conn->last_err;
  } else {
    msg->err = ERR_CONN;
    if (msg->conn->pcb.tcp != NULL) {
      if (msg->conn->type == NETCONN_TCP) {
        if (msg->conn->state == NETCONN_NONE) {
 800ceac:	7859      	ldrb	r1, [r3, #1]
 800ceae:	2900      	cmp	r1, #0
 800ceb0:	d1f6      	bne.n	800cea0 <do_listen+0x20>
 800ceb2:	4604      	mov	r4, r0
#if TCP_LISTEN_BACKLOG
          struct tcp_pcb* lpcb = tcp_listen_with_backlog(msg->conn->pcb.tcp, msg->msg.lb.backlog);
#else  /* TCP_LISTEN_BACKLOG */
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
 800ceb4:	21ff      	movs	r1, #255	; 0xff
 800ceb6:	4610      	mov	r0, r2
 800ceb8:	f7fc fb54 	bl	8009564 <tcp_listen_with_backlog>
#endif /* TCP_LISTEN_BACKLOG */
          if (lpcb == NULL) {
 800cebc:	4605      	mov	r5, r0
 800cebe:	b1e8      	cbz	r0, 800cefc <do_listen+0x7c>
            /* in this case, the old pcb is still allocated */
            msg->err = ERR_MEM;
          } else {
            /* delete the recvmbox and allocate the acceptmbox */
            if (sys_mbox_valid(&msg->conn->recvmbox)) {
 800cec0:	6820      	ldr	r0, [r4, #0]
 800cec2:	3034      	adds	r0, #52	; 0x34
 800cec4:	f006 f8fe 	bl	80130c4 <sys_mbox_valid>
 800cec8:	bb58      	cbnz	r0, 800cf22 <do_listen+0xa2>
              /** @todo: should we drain the recvmbox here? */
              sys_mbox_free(&msg->conn->recvmbox);
              sys_mbox_set_invalid(&msg->conn->recvmbox);
            }
            msg->err = ERR_OK;
            if (!sys_mbox_valid(&msg->conn->acceptmbox)) {
 800ceca:	6820      	ldr	r0, [r4, #0]
            if (sys_mbox_valid(&msg->conn->recvmbox)) {
              /** @todo: should we drain the recvmbox here? */
              sys_mbox_free(&msg->conn->recvmbox);
              sys_mbox_set_invalid(&msg->conn->recvmbox);
            }
            msg->err = ERR_OK;
 800cecc:	2300      	movs	r3, #0
            if (!sys_mbox_valid(&msg->conn->acceptmbox)) {
 800cece:	3064      	adds	r0, #100	; 0x64
            if (sys_mbox_valid(&msg->conn->recvmbox)) {
              /** @todo: should we drain the recvmbox here? */
              sys_mbox_free(&msg->conn->recvmbox);
              sys_mbox_set_invalid(&msg->conn->recvmbox);
            }
            msg->err = ERR_OK;
 800ced0:	7123      	strb	r3, [r4, #4]
            if (!sys_mbox_valid(&msg->conn->acceptmbox)) {
 800ced2:	f006 f8f7 	bl	80130c4 <sys_mbox_valid>
 800ced6:	b1e8      	cbz	r0, 800cf14 <do_listen+0x94>
 800ced8:	f994 0004 	ldrsb.w	r0, [r4, #4]
              msg->err = sys_mbox_new(&msg->conn->acceptmbox, DEFAULT_ACCEPTMBOX_SIZE);
            }
            if (msg->err == ERR_OK) {
 800cedc:	b990      	cbnz	r0, 800cf04 <do_listen+0x84>
              msg->conn->state = NETCONN_LISTEN;
 800cede:	6823      	ldr	r3, [r4, #0]
 800cee0:	2202      	movs	r2, #2
              msg->conn->pcb.tcp = lpcb;
 800cee2:	605d      	str	r5, [r3, #4]
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
 800cee4:	6821      	ldr	r1, [r4, #0]
            msg->err = ERR_OK;
            if (!sys_mbox_valid(&msg->conn->acceptmbox)) {
              msg->err = sys_mbox_new(&msg->conn->acceptmbox, DEFAULT_ACCEPTMBOX_SIZE);
            }
            if (msg->err == ERR_OK) {
              msg->conn->state = NETCONN_LISTEN;
 800cee6:	705a      	strb	r2, [r3, #1]
              msg->conn->pcb.tcp = lpcb;
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
 800cee8:	6848      	ldr	r0, [r1, #4]
 800ceea:	f7fc ff21 	bl	8009d30 <tcp_arg>
              tcp_accept(msg->conn->pcb.tcp, accept_function);
 800ceee:	6823      	ldr	r3, [r4, #0]
 800cef0:	4910      	ldr	r1, [pc, #64]	; (800cf34 <do_listen+0xb4>)
 800cef2:	6858      	ldr	r0, [r3, #4]
 800cef4:	f7fc ff68 	bl	8009dc8 <tcp_accept>
 800cef8:	6823      	ldr	r3, [r4, #0]
 800cefa:	e7d1      	b.n	800cea0 <do_listen+0x20>
#else  /* TCP_LISTEN_BACKLOG */
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
#endif /* TCP_LISTEN_BACKLOG */
          if (lpcb == NULL) {
            /* in this case, the old pcb is still allocated */
            msg->err = ERR_MEM;
 800cefc:	23ff      	movs	r3, #255	; 0xff
 800cefe:	7123      	strb	r3, [r4, #4]
 800cf00:	6823      	ldr	r3, [r4, #0]
 800cf02:	e7cd      	b.n	800cea0 <do_listen+0x20>
              msg->conn->pcb.tcp = lpcb;
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
              tcp_accept(msg->conn->pcb.tcp, accept_function);
            } else {
              /* since the old pcb is already deallocated, free lpcb now */
              tcp_close(lpcb);
 800cf04:	4628      	mov	r0, r5
 800cf06:	f7fd f8af 	bl	800a068 <tcp_close>
              msg->conn->pcb.tcp = NULL;
 800cf0a:	6823      	ldr	r3, [r4, #0]
 800cf0c:	2200      	movs	r2, #0
 800cf0e:	605a      	str	r2, [r3, #4]
 800cf10:	6823      	ldr	r3, [r4, #0]
 800cf12:	e7c5      	b.n	800cea0 <do_listen+0x20>
              sys_mbox_free(&msg->conn->recvmbox);
              sys_mbox_set_invalid(&msg->conn->recvmbox);
            }
            msg->err = ERR_OK;
            if (!sys_mbox_valid(&msg->conn->acceptmbox)) {
              msg->err = sys_mbox_new(&msg->conn->acceptmbox, DEFAULT_ACCEPTMBOX_SIZE);
 800cf14:	6820      	ldr	r0, [r4, #0]
 800cf16:	2114      	movs	r1, #20
 800cf18:	3064      	adds	r0, #100	; 0x64
 800cf1a:	f006 f81b 	bl	8012f54 <sys_mbox_new>
 800cf1e:	7120      	strb	r0, [r4, #4]
 800cf20:	e7dc      	b.n	800cedc <do_listen+0x5c>
            msg->err = ERR_MEM;
          } else {
            /* delete the recvmbox and allocate the acceptmbox */
            if (sys_mbox_valid(&msg->conn->recvmbox)) {
              /** @todo: should we drain the recvmbox here? */
              sys_mbox_free(&msg->conn->recvmbox);
 800cf22:	6820      	ldr	r0, [r4, #0]
 800cf24:	3034      	adds	r0, #52	; 0x34
 800cf26:	f006 f839 	bl	8012f9c <sys_mbox_free>
              sys_mbox_set_invalid(&msg->conn->recvmbox);
 800cf2a:	6820      	ldr	r0, [r4, #0]
 800cf2c:	3034      	adds	r0, #52	; 0x34
 800cf2e:	f006 f8d7 	bl	80130e0 <sys_mbox_set_invalid>
 800cf32:	e7ca      	b.n	800ceca <do_listen+0x4a>
 800cf34:	0800cb1d 	.word	0x0800cb1d

0800cf38 <do_send>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_send(struct api_msg_msg *msg)
{
 800cf38:	b538      	push	{r3, r4, r5, lr}
  if (ERR_IS_FATAL(msg->conn->last_err)) {
 800cf3a:	6803      	ldr	r3, [r0, #0]
 800cf3c:	f993 2008 	ldrsb.w	r2, [r3, #8]
 800cf40:	f112 0f09 	cmn.w	r2, #9
 800cf44:	db1d      	blt.n	800cf82 <do_send+0x4a>
    msg->err = msg->conn->last_err;
  } else {
    msg->err = ERR_CONN;
 800cf46:	22f3      	movs	r2, #243	; 0xf3
 800cf48:	7102      	strb	r2, [r0, #4]
    if (msg->conn->pcb.tcp != NULL) {
 800cf4a:	685d      	ldr	r5, [r3, #4]
 800cf4c:	b19d      	cbz	r5, 800cf76 <do_send+0x3e>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
 800cf4e:	781a      	ldrb	r2, [r3, #0]
 800cf50:	4604      	mov	r4, r0
 800cf52:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 800cf56:	2a20      	cmp	r2, #32
 800cf58:	d01a      	beq.n	800cf90 <do_send+0x58>
 800cf5a:	2a40      	cmp	r2, #64	; 0x40
 800cf5c:	d10b      	bne.n	800cf76 <do_send+0x3e>
#if LWIP_RAW
      case NETCONN_RAW:
        if (ip_addr_isany(&msg->msg.b->addr)) {
 800cf5e:	6883      	ldr	r3, [r0, #8]
 800cf60:	f113 0208 	adds.w	r2, r3, #8
 800cf64:	d001      	beq.n	800cf6a <do_send+0x32>
 800cf66:	6899      	ldr	r1, [r3, #8]
 800cf68:	bb61      	cbnz	r1, 800cfc4 <do_send+0x8c>
          msg->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
 800cf6a:	6819      	ldr	r1, [r3, #0]
 800cf6c:	4628      	mov	r0, r5
 800cf6e:	f003 fd4f 	bl	8010a10 <raw_send>
 800cf72:	6823      	ldr	r3, [r4, #0]
 800cf74:	7120      	strb	r0, [r4, #4]
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
 800cf76:	f103 000c 	add.w	r0, r3, #12
}
 800cf7a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
 800cf7e:	f006 b8ff 	b.w	8013180 <sys_sem_signal>
 */
void
do_send(struct api_msg_msg *msg)
{
  if (ERR_IS_FATAL(msg->conn->last_err)) {
    msg->err = msg->conn->last_err;
 800cf82:	7102      	strb	r2, [r0, #4]
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
 800cf84:	f103 000c 	add.w	r0, r3, #12
}
 800cf88:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
 800cf8c:	f006 b8f8 	b.w	8013180 <sys_sem_signal>
          msg->err = udp_sendto_chksum(msg->conn->pcb.udp, msg->msg.b->p,
            &msg->msg.b->addr, msg->msg.b->port,
            msg->msg.b->flags & NETBUF_FLAG_CHKSUM, msg->msg.b->toport_chksum);
        }
#else /* LWIP_CHECKSUM_ON_COPY */
        if (ip_addr_isany(&msg->msg.b->addr)) {
 800cf90:	6881      	ldr	r1, [r0, #8]
 800cf92:	f111 0208 	adds.w	r2, r1, #8
 800cf96:	d001      	beq.n	800cf9c <do_send+0x64>
 800cf98:	688b      	ldr	r3, [r1, #8]
 800cf9a:	b95b      	cbnz	r3, 800cfb4 <do_send+0x7c>
          msg->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
 800cf9c:	4628      	mov	r0, r5
 800cf9e:	6809      	ldr	r1, [r1, #0]
 800cfa0:	f007 fc04 	bl	80147ac <udp_send>
 800cfa4:	6823      	ldr	r3, [r4, #0]
 800cfa6:	7120      	strb	r0, [r4, #4]
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
 800cfa8:	f103 000c 	add.w	r0, r3, #12
}
 800cfac:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
 800cfb0:	f006 b8e6 	b.w	8013180 <sys_sem_signal>
        }
#else /* LWIP_CHECKSUM_ON_COPY */
        if (ip_addr_isany(&msg->msg.b->addr)) {
          msg->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
        } else {
          msg->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, &msg->msg.b->addr, msg->msg.b->port);
 800cfb4:	898b      	ldrh	r3, [r1, #12]
 800cfb6:	4628      	mov	r0, r5
 800cfb8:	6809      	ldr	r1, [r1, #0]
 800cfba:	f007 fbe1 	bl	8014780 <udp_sendto>
 800cfbe:	6823      	ldr	r3, [r4, #0]
 800cfc0:	7120      	strb	r0, [r4, #4]
 800cfc2:	e7d8      	b.n	800cf76 <do_send+0x3e>
#if LWIP_RAW
      case NETCONN_RAW:
        if (ip_addr_isany(&msg->msg.b->addr)) {
          msg->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
        } else {
          msg->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, &msg->msg.b->addr);
 800cfc4:	6819      	ldr	r1, [r3, #0]
 800cfc6:	4628      	mov	r0, r5
 800cfc8:	f003 fcc6 	bl	8010958 <raw_sendto>
 800cfcc:	6823      	ldr	r3, [r4, #0]
 800cfce:	7120      	strb	r0, [r4, #4]
 800cfd0:	e7d1      	b.n	800cf76 <do_send+0x3e>
 800cfd2:	bf00      	nop

0800cfd4 <do_recv>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_recv(struct api_msg_msg *msg)
{
 800cfd4:	b570      	push	{r4, r5, r6, lr}
  msg->err = ERR_OK;
 800cfd6:	2200      	movs	r2, #0
  if (msg->conn->pcb.tcp != NULL) {
 800cfd8:	6803      	ldr	r3, [r0, #0]
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_recv(struct api_msg_msg *msg)
{
  msg->err = ERR_OK;
 800cfda:	7102      	strb	r2, [r0, #4]
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_recv(struct api_msg_msg *msg)
{
 800cfdc:	4606      	mov	r6, r0
  msg->err = ERR_OK;
  if (msg->conn->pcb.tcp != NULL) {
 800cfde:	6858      	ldr	r0, [r3, #4]
 800cfe0:	b110      	cbz	r0, 800cfe8 <do_recv+0x14>
    if (msg->conn->type == NETCONN_TCP) {
 800cfe2:	781a      	ldrb	r2, [r3, #0]
 800cfe4:	2a10      	cmp	r2, #16
 800cfe6:	d005      	beq.n	800cff4 <do_recv+0x20>
        }while(remaining != 0);
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
}
 800cfe8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
          remaining -= recved;
        }while(remaining != 0);
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
 800cfec:	f103 000c 	add.w	r0, r3, #12
 800cff0:	f006 b8c6 	b.w	8013180 <sys_sem_signal>
      if (msg->conn->pcb.tcp->state == LISTEN) {
        tcp_accepted(msg->conn->pcb.tcp);
      } else
#endif /* TCP_LISTEN_BACKLOG */
      {
        u32_t remaining = msg->msg.r.len;
 800cff4:	68b4      	ldr	r4, [r6, #8]
 800cff6:	e000      	b.n	800cffa <do_recv+0x26>
 800cff8:	6858      	ldr	r0, [r3, #4]
        do {
          u16_t recved = (remaining > 0xffff) ? 0xffff : (u16_t)remaining;
 800cffa:	f5b4 3f80 	cmp.w	r4, #65536	; 0x10000
 800cffe:	bf2d      	iteet	cs
 800d000:	f64f 75ff 	movwcs	r5, #65535	; 0xffff
 800d004:	4625      	movcc	r5, r4
 800d006:	b2a1      	uxthcc	r1, r4
 800d008:	4629      	movcs	r1, r5
          tcp_recved(msg->conn->pcb.tcp, recved);
 800d00a:	f7fc fb3d 	bl	8009688 <tcp_recved>
          remaining -= recved;
        }while(remaining != 0);
 800d00e:	1b64      	subs	r4, r4, r5
 800d010:	6833      	ldr	r3, [r6, #0]
 800d012:	d1f1      	bne.n	800cff8 <do_recv+0x24>
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
 800d014:	f103 000c 	add.w	r0, r3, #12
}
 800d018:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
          remaining -= recved;
        }while(remaining != 0);
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
 800d01c:	f006 b8b0 	b.w	8013180 <sys_sem_signal>

0800d020 <do_write>:
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
  if (ERR_IS_FATAL(msg->conn->last_err)) {
 800d020:	6803      	ldr	r3, [r0, #0]
 800d022:	f993 2008 	ldrsb.w	r2, [r3, #8]
 800d026:	f112 0f09 	cmn.w	r2, #9
 800d02a:	db03      	blt.n	800d034 <do_write+0x14>
    msg->err = msg->conn->last_err;
  } else {
    if (msg->conn->type == NETCONN_TCP) {
 800d02c:	781a      	ldrb	r2, [r3, #0]
 800d02e:	2a10      	cmp	r2, #16
 800d030:	d005      	beq.n	800d03e <do_write+0x1e>
#else /* LWIP_TCP */
      msg->err = ERR_VAL;
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->err = ERR_VAL;
 800d032:	22fa      	movs	r2, #250	; 0xfa
 800d034:	7102      	strb	r2, [r0, #4]
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
 800d036:	f103 000c 	add.w	r0, r3, #12
 800d03a:	f006 b8a1 	b.w	8013180 <sys_sem_signal>
  if (ERR_IS_FATAL(msg->conn->last_err)) {
    msg->err = msg->conn->last_err;
  } else {
    if (msg->conn->type == NETCONN_TCP) {
#if LWIP_TCP
      if (msg->conn->state != NETCONN_NONE) {
 800d03e:	785a      	ldrb	r2, [r3, #1]
 800d040:	b112      	cbz	r2, 800d048 <do_write+0x28>
        /* netconn is connecting, closing or in blocking write */
        msg->err = ERR_INPROGRESS;
 800d042:	22fb      	movs	r2, #251	; 0xfb
 800d044:	7102      	strb	r2, [r0, #4]
 800d046:	e7f6      	b.n	800d036 <do_write+0x16>
      } else if (msg->conn->pcb.tcp != NULL) {
 800d048:	685a      	ldr	r2, [r3, #4]
 800d04a:	b332      	cbz	r2, 800d09a <do_write+0x7a>
        msg->conn->state = NETCONN_WRITE;
        /* set all the variables used by do_writemore */
        LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
 800d04c:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
#if LWIP_TCP
      if (msg->conn->state != NETCONN_NONE) {
        /* netconn is connecting, closing or in blocking write */
        msg->err = ERR_INPROGRESS;
      } else if (msg->conn->pcb.tcp != NULL) {
        msg->conn->state = NETCONN_WRITE;
 800d050:	2101      	movs	r1, #1
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
 800d052:	b510      	push	{r4, lr}
 800d054:	4604      	mov	r4, r0
#if LWIP_TCP
      if (msg->conn->state != NETCONN_NONE) {
        /* netconn is connecting, closing or in blocking write */
        msg->err = ERR_INPROGRESS;
      } else if (msg->conn->pcb.tcp != NULL) {
        msg->conn->state = NETCONN_WRITE;
 800d056:	7059      	strb	r1, [r3, #1]
        /* set all the variables used by do_writemore */
        LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
 800d058:	b1d2      	cbz	r2, 800d090 <do_write+0x70>
 800d05a:	4b11      	ldr	r3, [pc, #68]	; (800d0a0 <do_write+0x80>)
 800d05c:	f240 524d 	movw	r2, #1357	; 0x54d
 800d060:	4910      	ldr	r1, [pc, #64]	; (800d0a4 <do_write+0x84>)
 800d062:	4811      	ldr	r0, [pc, #68]	; (800d0a8 <do_write+0x88>)
 800d064:	f007 fe88 	bl	8014d78 <iprintf>
          msg->conn->write_offset == 0);
        LWIP_ASSERT("msg->msg.w.len != 0", msg->msg.w.len != 0);
 800d068:	68e3      	ldr	r3, [r4, #12]
 800d06a:	b14b      	cbz	r3, 800d080 <do_write+0x60>
        msg->conn->current_msg = msg;
 800d06c:	6820      	ldr	r0, [r4, #0]
        msg->conn->write_offset = 0;
 800d06e:	2300      	movs	r3, #0
        msg->conn->state = NETCONN_WRITE;
        /* set all the variables used by do_writemore */
        LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
          msg->conn->write_offset == 0);
        LWIP_ASSERT("msg->msg.w.len != 0", msg->msg.w.len != 0);
        msg->conn->current_msg = msg;
 800d070:	f8c0 40a0 	str.w	r4, [r0, #160]	; 0xa0
        msg->conn->write_offset = 0;
 800d074:	f8c0 309c 	str.w	r3, [r0, #156]	; 0x9c
      msg->err = ERR_VAL;
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
}
 800d078:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
          sys_arch_sem_wait(&msg->conn->op_completed, 0);
          LOCK_TCPIP_CORE();
          LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
        }
#else /* LWIP_TCPIP_CORE_LOCKING */
        do_writemore(msg->conn);
 800d07c:	f7ff b97e 	b.w	800c37c <do_writemore>
      } else if (msg->conn->pcb.tcp != NULL) {
        msg->conn->state = NETCONN_WRITE;
        /* set all the variables used by do_writemore */
        LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
          msg->conn->write_offset == 0);
        LWIP_ASSERT("msg->msg.w.len != 0", msg->msg.w.len != 0);
 800d080:	4b07      	ldr	r3, [pc, #28]	; (800d0a0 <do_write+0x80>)
 800d082:	f240 524e 	movw	r2, #1358	; 0x54e
 800d086:	4909      	ldr	r1, [pc, #36]	; (800d0ac <do_write+0x8c>)
 800d088:	4807      	ldr	r0, [pc, #28]	; (800d0a8 <do_write+0x88>)
 800d08a:	f007 fe75 	bl	8014d78 <iprintf>
 800d08e:	e7ed      	b.n	800d06c <do_write+0x4c>
        /* netconn is connecting, closing or in blocking write */
        msg->err = ERR_INPROGRESS;
      } else if (msg->conn->pcb.tcp != NULL) {
        msg->conn->state = NETCONN_WRITE;
        /* set all the variables used by do_writemore */
        LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
 800d090:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 800d094:	2b00      	cmp	r3, #0
 800d096:	d0e7      	beq.n	800d068 <do_write+0x48>
 800d098:	e7df      	b.n	800d05a <do_write+0x3a>
#endif /* LWIP_TCPIP_CORE_LOCKING */
        /* for both cases: if do_writemore was called, don't ACK the APIMSG
           since do_writemore ACKs it! */
        return;
      } else {
        msg->err = ERR_CONN;
 800d09a:	22f3      	movs	r2, #243	; 0xf3
 800d09c:	7102      	strb	r2, [r0, #4]
 800d09e:	e7ca      	b.n	800d036 <do_write+0x16>
 800d0a0:	0801719c 	.word	0x0801719c
 800d0a4:	08017540 	.word	0x08017540
 800d0a8:	0801660c 	.word	0x0801660c
 800d0ac:	08017574 	.word	0x08017574

0800d0b0 <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
 800d0b0:	b510      	push	{r4, lr}
  if (msg->conn->pcb.ip != NULL) {
 800d0b2:	6804      	ldr	r4, [r0, #0]
 800d0b4:	6863      	ldr	r3, [r4, #4]
 800d0b6:	b31b      	cbz	r3, 800d100 <do_getaddr+0x50>
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local ? msg->conn->pcb.ip->local_ip :
 800d0b8:	7c01      	ldrb	r1, [r0, #16]
 800d0ba:	6882      	ldr	r2, [r0, #8]
 800d0bc:	b9d9      	cbnz	r1, 800d0f6 <do_getaddr+0x46>
 800d0be:	685b      	ldr	r3, [r3, #4]
 800d0c0:	6013      	str	r3, [r2, #0]
                             msg->conn->pcb.ip->remote_ip);

    msg->err = ERR_OK;
 800d0c2:	2300      	movs	r3, #0
 800d0c4:	7103      	strb	r3, [r0, #4]
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
 800d0c6:	7823      	ldrb	r3, [r4, #0]
 800d0c8:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800d0cc:	2b20      	cmp	r3, #32
 800d0ce:	d02b      	beq.n	800d128 <do_getaddr+0x78>
 800d0d0:	2b40      	cmp	r3, #64	; 0x40
 800d0d2:	d013      	beq.n	800d0fc <do_getaddr+0x4c>
 800d0d4:	2b10      	cmp	r3, #16
 800d0d6:	d01b      	beq.n	800d110 <do_getaddr+0x60>
 800d0d8:	4604      	mov	r4, r0
    case NETCONN_TCP:
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
      break;
#endif /* LWIP_TCP */
    default:
      LWIP_ASSERT("invalid netconn_type", 0);
 800d0da:	4b21      	ldr	r3, [pc, #132]	; (800d160 <do_getaddr+0xb0>)
 800d0dc:	f240 529b 	movw	r2, #1435	; 0x59b
 800d0e0:	4920      	ldr	r1, [pc, #128]	; (800d164 <do_getaddr+0xb4>)
 800d0e2:	4821      	ldr	r0, [pc, #132]	; (800d168 <do_getaddr+0xb8>)
 800d0e4:	f007 fe48 	bl	8014d78 <iprintf>
 800d0e8:	6824      	ldr	r4, [r4, #0]
      break;
    }
  } else {
    msg->err = ERR_CONN;
  }
  TCPIP_APIMSG_ACK(msg);
 800d0ea:	f104 000c 	add.w	r0, r4, #12
}
 800d0ee:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      break;
    }
  } else {
    msg->err = ERR_CONN;
  }
  TCPIP_APIMSG_ACK(msg);
 800d0f2:	f006 b845 	b.w	8013180 <sys_sem_signal>
 */
void
do_getaddr(struct api_msg_msg *msg)
{
  if (msg->conn->pcb.ip != NULL) {
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local ? msg->conn->pcb.ip->local_ip :
 800d0f6:	681b      	ldr	r3, [r3, #0]
 800d0f8:	6013      	str	r3, [r2, #0]
 800d0fa:	e7e2      	b.n	800d0c2 <do_getaddr+0x12>

    msg->err = ERR_OK;
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
 800d0fc:	7c03      	ldrb	r3, [r0, #16]
 800d0fe:	b9eb      	cbnz	r3, 800d13c <do_getaddr+0x8c>
    default:
      LWIP_ASSERT("invalid netconn_type", 0);
      break;
    }
  } else {
    msg->err = ERR_CONN;
 800d100:	23f3      	movs	r3, #243	; 0xf3
 800d102:	7103      	strb	r3, [r0, #4]
  }
  TCPIP_APIMSG_ACK(msg);
 800d104:	f104 000c 	add.w	r0, r4, #12
}
 800d108:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      break;
    }
  } else {
    msg->err = ERR_CONN;
  }
  TCPIP_APIMSG_ACK(msg);
 800d10c:	f006 b838 	b.w	8013180 <sys_sem_signal>
      }
      break;
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
 800d110:	7c02      	ldrb	r2, [r0, #16]
 800d112:	68c3      	ldr	r3, [r0, #12]
 800d114:	b9e2      	cbnz	r2, 800d150 <do_getaddr+0xa0>
 800d116:	6862      	ldr	r2, [r4, #4]
 800d118:	8b92      	ldrh	r2, [r2, #28]
      break;
    }
  } else {
    msg->err = ERR_CONN;
  }
  TCPIP_APIMSG_ACK(msg);
 800d11a:	f104 000c 	add.w	r0, r4, #12
      }
      break;
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
 800d11e:	801a      	strh	r2, [r3, #0]
    }
  } else {
    msg->err = ERR_CONN;
  }
  TCPIP_APIMSG_ACK(msg);
}
 800d120:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      break;
    }
  } else {
    msg->err = ERR_CONN;
  }
  TCPIP_APIMSG_ACK(msg);
 800d124:	f006 b82c 	b.w	8013180 <sys_sem_signal>
      }
      break;
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
 800d128:	7c03      	ldrb	r3, [r0, #16]
 800d12a:	b9a3      	cbnz	r3, 800d156 <do_getaddr+0xa6>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
 800d12c:	6863      	ldr	r3, [r4, #4]
 800d12e:	7c1a      	ldrb	r2, [r3, #16]
 800d130:	0752      	lsls	r2, r2, #29
 800d132:	d5e5      	bpl.n	800d100 <do_getaddr+0x50>
          msg->err = ERR_CONN;
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
 800d134:	68c2      	ldr	r2, [r0, #12]
 800d136:	8a9b      	ldrh	r3, [r3, #20]
 800d138:	8013      	strh	r3, [r2, #0]
 800d13a:	e7d6      	b.n	800d0ea <do_getaddr+0x3a>
    msg->err = ERR_OK;
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
 800d13c:	6862      	ldr	r2, [r4, #4]
 800d13e:	68c3      	ldr	r3, [r0, #12]
 800d140:	7c12      	ldrb	r2, [r2, #16]
      break;
    }
  } else {
    msg->err = ERR_CONN;
  }
  TCPIP_APIMSG_ACK(msg);
 800d142:	f104 000c 	add.w	r0, r4, #12
    msg->err = ERR_OK;
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
#if LWIP_RAW
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
 800d146:	801a      	strh	r2, [r3, #0]
    }
  } else {
    msg->err = ERR_CONN;
  }
  TCPIP_APIMSG_ACK(msg);
}
 800d148:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      break;
    }
  } else {
    msg->err = ERR_CONN;
  }
  TCPIP_APIMSG_ACK(msg);
 800d14c:	f006 b818 	b.w	8013180 <sys_sem_signal>
      }
      break;
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
 800d150:	6862      	ldr	r2, [r4, #4]
 800d152:	8b52      	ldrh	r2, [r2, #26]
 800d154:	e7e1      	b.n	800d11a <do_getaddr+0x6a>
      break;
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
 800d156:	6862      	ldr	r2, [r4, #4]
 800d158:	68c3      	ldr	r3, [r0, #12]
 800d15a:	8a52      	ldrh	r2, [r2, #18]
 800d15c:	801a      	strh	r2, [r3, #0]
 800d15e:	e7c4      	b.n	800d0ea <do_getaddr+0x3a>
 800d160:	0801719c 	.word	0x0801719c
 800d164:	08017588 	.word	0x08017588
 800d168:	0801660c 	.word	0x0801660c

0800d16c <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
 800d16c:	b510      	push	{r4, lr}
 800d16e:	4604      	mov	r4, r0
#if LWIP_TCP
  /* @todo: abort running write/connect? */
  if ((msg->conn->state != NETCONN_NONE) && (msg->conn->state != NETCONN_LISTEN)) {
 800d170:	6800      	ldr	r0, [r0, #0]
 800d172:	7843      	ldrb	r3, [r0, #1]
 800d174:	f013 0ffd 	tst.w	r3, #253	; 0xfd
 800d178:	d011      	beq.n	800d19e <do_close+0x32>
    /* this only happens for TCP netconns */
    LWIP_ASSERT("msg->conn->type == NETCONN_TCP", msg->conn->type == NETCONN_TCP);
 800d17a:	7803      	ldrb	r3, [r0, #0]
 800d17c:	2b10      	cmp	r3, #16
 800d17e:	d007      	beq.n	800d190 <do_close+0x24>
 800d180:	4b20      	ldr	r3, [pc, #128]	; (800d204 <do_close+0x98>)
 800d182:	f240 52b1 	movw	r2, #1457	; 0x5b1
 800d186:	4920      	ldr	r1, [pc, #128]	; (800d208 <do_close+0x9c>)
 800d188:	4820      	ldr	r0, [pc, #128]	; (800d20c <do_close+0xa0>)
 800d18a:	f007 fdf5 	bl	8014d78 <iprintf>
 800d18e:	6820      	ldr	r0, [r4, #0]
    msg->err = ERR_INPROGRESS;
 800d190:	23fb      	movs	r3, #251	; 0xfb
 800d192:	7123      	strb	r3, [r4, #4]
  } else
#endif /* LWIP_TCP */
  {
    msg->err = ERR_VAL;
  }
  sys_sem_signal(&msg->conn->op_completed);
 800d194:	300c      	adds	r0, #12
}
 800d196:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  } else
#endif /* LWIP_TCP */
  {
    msg->err = ERR_VAL;
  }
  sys_sem_signal(&msg->conn->op_completed);
 800d19a:	f005 bff1 	b.w	8013180 <sys_sem_signal>
  /* @todo: abort running write/connect? */
  if ((msg->conn->state != NETCONN_NONE) && (msg->conn->state != NETCONN_LISTEN)) {
    /* this only happens for TCP netconns */
    LWIP_ASSERT("msg->conn->type == NETCONN_TCP", msg->conn->type == NETCONN_TCP);
    msg->err = ERR_INPROGRESS;
  } else if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
 800d19e:	6842      	ldr	r2, [r0, #4]
 800d1a0:	b112      	cbz	r2, 800d1a8 <do_close+0x3c>
 800d1a2:	7802      	ldrb	r2, [r0, #0]
 800d1a4:	2a10      	cmp	r2, #16
 800d1a6:	d006      	beq.n	800d1b6 <do_close+0x4a>
      return;
    }
  } else
#endif /* LWIP_TCP */
  {
    msg->err = ERR_VAL;
 800d1a8:	23fa      	movs	r3, #250	; 0xfa
 800d1aa:	7123      	strb	r3, [r4, #4]
  }
  sys_sem_signal(&msg->conn->op_completed);
 800d1ac:	300c      	adds	r0, #12
}
 800d1ae:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  } else
#endif /* LWIP_TCP */
  {
    msg->err = ERR_VAL;
  }
  sys_sem_signal(&msg->conn->op_completed);
 800d1b2:	f005 bfe5 	b.w	8013180 <sys_sem_signal>
  if ((msg->conn->state != NETCONN_NONE) && (msg->conn->state != NETCONN_LISTEN)) {
    /* this only happens for TCP netconns */
    LWIP_ASSERT("msg->conn->type == NETCONN_TCP", msg->conn->type == NETCONN_TCP);
    msg->err = ERR_INPROGRESS;
  } else if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
    if ((msg->msg.sd.shut != NETCONN_SHUT_RDWR) && (msg->conn->state == NETCONN_LISTEN)) {
 800d1b6:	7a22      	ldrb	r2, [r4, #8]
 800d1b8:	2a03      	cmp	r2, #3
 800d1ba:	d01b      	beq.n	800d1f4 <do_close+0x88>
 800d1bc:	2b02      	cmp	r3, #2
 800d1be:	d01d      	beq.n	800d1fc <do_close+0x90>
      /* LISTEN doesn't support half shutdown */
      msg->err = ERR_CONN;
    } else {
      if (msg->msg.sd.shut & NETCONN_SHUT_RD) {
 800d1c0:	07d3      	lsls	r3, r2, #31
 800d1c2:	d417      	bmi.n	800d1f4 <do_close+0x88>
        /* Drain and delete mboxes */
        netconn_drain(msg->conn);
      }
      LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
 800d1c4:	f8d0 30a0 	ldr.w	r3, [r0, #160]	; 0xa0
 800d1c8:	b17b      	cbz	r3, 800d1ea <do_close+0x7e>
 800d1ca:	4b0e      	ldr	r3, [pc, #56]	; (800d204 <do_close+0x98>)
 800d1cc:	f240 52bd 	movw	r2, #1469	; 0x5bd
 800d1d0:	490f      	ldr	r1, [pc, #60]	; (800d210 <do_close+0xa4>)
 800d1d2:	480e      	ldr	r0, [pc, #56]	; (800d20c <do_close+0xa0>)
 800d1d4:	f007 fdd0 	bl	8014d78 <iprintf>
 800d1d8:	6820      	ldr	r0, [r4, #0]
        msg->conn->write_offset == 0);
      msg->conn->state = NETCONN_CLOSE;
 800d1da:	2304      	movs	r3, #4
      msg->conn->current_msg = msg;
 800d1dc:	f8c0 40a0 	str.w	r4, [r0, #160]	; 0xa0
        /* Drain and delete mboxes */
        netconn_drain(msg->conn);
      }
      LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
        msg->conn->write_offset == 0);
      msg->conn->state = NETCONN_CLOSE;
 800d1e0:	7043      	strb	r3, [r0, #1]
#endif /* LWIP_TCP */
  {
    msg->err = ERR_VAL;
  }
  sys_sem_signal(&msg->conn->op_completed);
}
 800d1e2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      }
      LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
        msg->conn->write_offset == 0);
      msg->conn->state = NETCONN_CLOSE;
      msg->conn->current_msg = msg;
      do_close_internal(msg->conn);
 800d1e6:	f7ff b9bd 	b.w	800c564 <do_close_internal>
    } else {
      if (msg->msg.sd.shut & NETCONN_SHUT_RD) {
        /* Drain and delete mboxes */
        netconn_drain(msg->conn);
      }
      LWIP_ASSERT("already writing or closing", msg->conn->current_msg == NULL &&
 800d1ea:	f8d0 309c 	ldr.w	r3, [r0, #156]	; 0x9c
 800d1ee:	2b00      	cmp	r3, #0
 800d1f0:	d1eb      	bne.n	800d1ca <do_close+0x5e>
 800d1f2:	e7f2      	b.n	800d1da <do_close+0x6e>
      /* LISTEN doesn't support half shutdown */
      msg->err = ERR_CONN;
    } else {
      if (msg->msg.sd.shut & NETCONN_SHUT_RD) {
        /* Drain and delete mboxes */
        netconn_drain(msg->conn);
 800d1f4:	f7ff fc32 	bl	800ca5c <netconn_drain>
 800d1f8:	6820      	ldr	r0, [r4, #0]
 800d1fa:	e7e3      	b.n	800d1c4 <do_close+0x58>
    LWIP_ASSERT("msg->conn->type == NETCONN_TCP", msg->conn->type == NETCONN_TCP);
    msg->err = ERR_INPROGRESS;
  } else if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
    if ((msg->msg.sd.shut != NETCONN_SHUT_RDWR) && (msg->conn->state == NETCONN_LISTEN)) {
      /* LISTEN doesn't support half shutdown */
      msg->err = ERR_CONN;
 800d1fc:	23f3      	movs	r3, #243	; 0xf3
 800d1fe:	7123      	strb	r3, [r4, #4]
  if ((msg->conn->state != NETCONN_NONE) && (msg->conn->state != NETCONN_LISTEN)) {
    /* this only happens for TCP netconns */
    LWIP_ASSERT("msg->conn->type == NETCONN_TCP", msg->conn->type == NETCONN_TCP);
    msg->err = ERR_INPROGRESS;
  } else if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
    if ((msg->msg.sd.shut != NETCONN_SHUT_RDWR) && (msg->conn->state == NETCONN_LISTEN)) {
 800d200:	e7d4      	b.n	800d1ac <do_close+0x40>
 800d202:	bf00      	nop
 800d204:	0801719c 	.word	0x0801719c
 800d208:	08017500 	.word	0x08017500
 800d20c:	0801660c 	.word	0x0801660c
 800d210:	08017540 	.word	0x08017540

0800d214 <ETH_IRQHandler>:
**return:
**autor:  andiman
**date:
************************************************************/
void ETH_IRQHandler(void)
{
 800d214:	b508      	push	{r3, lr}

	if ( ETH_GetDMAFlagStatus(ETH_DMA_FLAG_R) == SET)
 800d216:	2040      	movs	r0, #64	; 0x40
 800d218:	f005 fb20 	bl	801285c <ETH_GetDMAFlagStatus>
 800d21c:	2801      	cmp	r0, #1
 800d21e:	d008      	beq.n	800d232 <ETH_IRQHandler+0x1e>
      			BSP_ETH_IRQHandler();
	}
	
	//Clear the interrupt flags. 
	//Clear the Eth DMA Rx IT pending bits 
	ETH_DMAClearITPendingBit(ETH_DMA_IT_R);
 800d220:	2040      	movs	r0, #64	; 0x40
 800d222:	f005 fb1d 	bl	8012860 <ETH_DMAClearITPendingBit>
	ETH_DMAClearITPendingBit(ETH_DMA_IT_NIS);
}
 800d226:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	}
	
	//Clear the interrupt flags. 
	//Clear the Eth DMA Rx IT pending bits 
	ETH_DMAClearITPendingBit(ETH_DMA_IT_R);
	ETH_DMAClearITPendingBit(ETH_DMA_IT_NIS);
 800d22a:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 800d22e:	f005 bb17 	b.w	8012860 <ETH_DMAClearITPendingBit>
{

	if ( ETH_GetDMAFlagStatus(ETH_DMA_FLAG_R) == SET)
	{
	    	// 此处发送一个信号量
	    	if(BSP_ETH_IRQHandler)
 800d232:	4b03      	ldr	r3, [pc, #12]	; (800d240 <ETH_IRQHandler+0x2c>)
 800d234:	681b      	ldr	r3, [r3, #0]
 800d236:	2b00      	cmp	r3, #0
 800d238:	d0f2      	beq.n	800d220 <ETH_IRQHandler+0xc>
      			BSP_ETH_IRQHandler();
 800d23a:	4798      	blx	r3
 800d23c:	e7f0      	b.n	800d220 <ETH_IRQHandler+0xc>
 800d23e:	bf00      	nop
 800d240:	200007fc 	.word	0x200007fc

0800d244 <BSP_ETH_GetCurrentTxBuffer>:
* Output         : None
* Return         : Buffer address
*******************************************************************************/
INT8U * BSP_ETH_GetCurrentTxBuffer(void)
{
	INT8U* tx_addr = (BYTE*)DMATxDescToSet->Buffer1Addr;
 800d244:	4b01      	ldr	r3, [pc, #4]	; (800d24c <BSP_ETH_GetCurrentTxBuffer+0x8>)
 800d246:	681b      	ldr	r3, [r3, #0]
	/* Return Buffer address */
	return tx_addr;   
}
 800d248:	6898      	ldr	r0, [r3, #8]
 800d24a:	4770      	bx	lr
 800d24c:	2000f4d0 	.word	0x2000f4d0

0800d250 <BSP_ETH_IsRxPktValid>:
* Output         : None
* Return         : 
*******************************************************************************/
INT32U BSP_ETH_IsRxPktValid(void)
{
	return ETH_GetRxPktSize(DMARxDescToGet); 
 800d250:	4b01      	ldr	r3, [pc, #4]	; (800d258 <BSP_ETH_IsRxPktValid+0x8>)
 800d252:	6818      	ldr	r0, [r3, #0]
 800d254:	f005 baac 	b.w	80127b0 <ETH_GetRxPktSize>
 800d258:	2000f4cc 	.word	0x2000f4cc

0800d25c <Eth_Link_PHYITConfig>:
  * @brief  Configure the PHY to generate an interrupt on change of link status.
  * @param PHYAddress: external PHY address  
  * @retval None
  */
INT32U Eth_Link_PHYITConfig(INT16U PHYAddress)
{
 800d25c:	b510      	push	{r4, lr}
  INT32U tmpreg = 0;

  /* Read MICR register */
  tmpreg = ETH_ReadPHYRegister(PHYAddress, PHY_MICR);
 800d25e:	2111      	movs	r1, #17
  * @brief  Configure the PHY to generate an interrupt on change of link status.
  * @param PHYAddress: external PHY address  
  * @retval None
  */
INT32U Eth_Link_PHYITConfig(INT16U PHYAddress)
{
 800d260:	4604      	mov	r4, r0
  INT32U tmpreg = 0;

  /* Read MICR register */
  tmpreg = ETH_ReadPHYRegister(PHYAddress, PHY_MICR);
 800d262:	f005 fb9d 	bl	80129a0 <ETH_ReadPHYRegister>

  /* Enable output interrupt events to signal via the INT pin */
  tmpreg |= (uint32_t)PHY_MICR_INT_EN | PHY_MICR_INT_OE;
  if(!(ETH_WritePHYRegister(PHYAddress, PHY_MICR, tmpreg)))
 800d266:	f040 0203 	orr.w	r2, r0, #3
 800d26a:	b292      	uxth	r2, r2
 800d26c:	4620      	mov	r0, r4
 800d26e:	2111      	movs	r1, #17
 800d270:	f005 fbc6 	bl	8012a00 <ETH_WritePHYRegister>
 800d274:	b168      	cbz	r0, 800d292 <Eth_Link_PHYITConfig+0x36>
    /* Return ERROR in case of write timeout */
    return ETH_ERROR;
  }

  /* Read MISR register */
  tmpreg = ETH_ReadPHYRegister(PHYAddress, PHY_MISR);
 800d276:	2112      	movs	r1, #18
 800d278:	4620      	mov	r0, r4
 800d27a:	f005 fb91 	bl	80129a0 <ETH_ReadPHYRegister>

  /* Enable Interrupt on change of link status */
  tmpreg |= (uint32_t)PHY_MISR_LINK_INT_EN;
  if(!(ETH_WritePHYRegister(PHYAddress, PHY_MISR, tmpreg)))
 800d27e:	f040 0220 	orr.w	r2, r0, #32
 800d282:	b292      	uxth	r2, r2
 800d284:	4620      	mov	r0, r4
 800d286:	2112      	movs	r1, #18
 800d288:	f005 fbba 	bl	8012a00 <ETH_WritePHYRegister>
  /* Enable output interrupt events to signal via the INT pin */
  tmpreg |= (uint32_t)PHY_MICR_INT_EN | PHY_MICR_INT_OE;
  if(!(ETH_WritePHYRegister(PHYAddress, PHY_MICR, tmpreg)))
  {
    /* Return ERROR in case of write timeout */
    return ETH_ERROR;
 800d28c:	3000      	adds	r0, #0
 800d28e:	bf18      	it	ne
 800d290:	2001      	movne	r0, #1
    /* Return ERROR in case of write timeout */
    return ETH_ERROR;
  }
  /* Return SUCCESS */
  return ETH_SUCCESS;   
}
 800d292:	bd10      	pop	{r4, pc}

0800d294 <Eth_Link_EXTIConfig>:
  * @brief  EXTI configuration for Ethernet link status.
  * @param PHYAddress: external PHY address  
  * @retval None
  */
void Eth_Link_EXTIConfig(void)
{
 800d294:	b530      	push	{r4, r5, lr}
  GPIO_InitTypeDef GPIO_InitStructure;
  EXTI_InitTypeDef EXTI_InitStructure;
  NVIC_InitTypeDef NVIC_InitStructure;

  /* Enable the INT (PG12) Clock */
  RCC_AHB1PeriphClockCmd(ETH_LINK_GPIO_CLK, ENABLE);
 800d296:	2101      	movs	r1, #1
  * @brief  EXTI configuration for Ethernet link status.
  * @param PHYAddress: external PHY address  
  * @retval None
  */
void Eth_Link_EXTIConfig(void)
{
 800d298:	b085      	sub	sp, #20
  GPIO_InitTypeDef GPIO_InitStructure;
  EXTI_InitTypeDef EXTI_InitStructure;
  NVIC_InitTypeDef NVIC_InitStructure;

  /* Enable the INT (PG12) Clock */
  RCC_AHB1PeriphClockCmd(ETH_LINK_GPIO_CLK, ENABLE);
 800d29a:	2040      	movs	r0, #64	; 0x40
 800d29c:	f7fb fdb4 	bl	8008e08 <RCC_AHB1PeriphClockCmd>
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
 800d2a0:	2101      	movs	r1, #1
 800d2a2:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800d2a6:	f7fb fde7 	bl	8008e78 <RCC_APB2PeriphClockCmd>

  /* Configure INT pin as input */
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
  GPIO_InitStructure.GPIO_Pin = ETH_LINK_PIN;
 800d2aa:	f44f 5580 	mov.w	r5, #4096	; 0x1000
 800d2ae:	a904      	add	r1, sp, #16
  /* Enable the INT (PG12) Clock */
  RCC_AHB1PeriphClockCmd(ETH_LINK_GPIO_CLK, ENABLE);
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);

  /* Configure INT pin as input */
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 800d2b0:	2400      	movs	r4, #0
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
  GPIO_InitStructure.GPIO_Pin = ETH_LINK_PIN;
 800d2b2:	f841 5d10 	str.w	r5, [r1, #-16]!
  GPIO_Init(ETH_LINK_GPIO_PORT, &GPIO_InitStructure);
 800d2b6:	480c      	ldr	r0, [pc, #48]	; (800d2e8 <Eth_Link_EXTIConfig+0x54>)
  /* Enable the INT (PG12) Clock */
  RCC_AHB1PeriphClockCmd(ETH_LINK_GPIO_CLK, ENABLE);
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);

  /* Configure INT pin as input */
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 800d2b8:	f88d 4004 	strb.w	r4, [sp, #4]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 800d2bc:	f88d 4007 	strb.w	r4, [sp, #7]
  GPIO_InitStructure.GPIO_Pin = ETH_LINK_PIN;
  GPIO_Init(ETH_LINK_GPIO_PORT, &GPIO_InitStructure);
 800d2c0:	f7fb fbaa 	bl	8008a18 <GPIO_Init>

  /* Connect EXTI Line to INT Pin */
  SYSCFG_EXTILineConfig(ETH_LINK_EXTI_PORT_SOURCE, ETH_LINK_EXTI_PIN_SOURCE);
 800d2c4:	210c      	movs	r1, #12
 800d2c6:	2006      	movs	r0, #6
 800d2c8:	f005 fe1a 	bl	8012f00 <SYSCFG_EXTILineConfig>

  /* Configure EXTI line */
  EXTI_InitStructure.EXTI_Line = ETH_LINK_EXTI_LINE;
  EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
  EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;  
 800d2cc:	220c      	movs	r2, #12
  EXTI_InitStructure.EXTI_LineCmd = ENABLE;
 800d2ce:	2301      	movs	r3, #1
  EXTI_Init(&EXTI_InitStructure);
 800d2d0:	a802      	add	r0, sp, #8

  /* Connect EXTI Line to INT Pin */
  SYSCFG_EXTILineConfig(ETH_LINK_EXTI_PORT_SOURCE, ETH_LINK_EXTI_PIN_SOURCE);

  /* Configure EXTI line */
  EXTI_InitStructure.EXTI_Line = ETH_LINK_EXTI_LINE;
 800d2d2:	9502      	str	r5, [sp, #8]
  EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
 800d2d4:	f88d 400c 	strb.w	r4, [sp, #12]
  EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;  
 800d2d8:	f88d 200d 	strb.w	r2, [sp, #13]
  EXTI_InitStructure.EXTI_LineCmd = ENABLE;
 800d2dc:	f88d 300e 	strb.w	r3, [sp, #14]
  EXTI_Init(&EXTI_InitStructure);
 800d2e0:	f7fb f864 	bl	80083ac <EXTI_Init>
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
  NVIC_Init(&NVIC_InitStructure);
	#endif
 	
}
 800d2e4:	b005      	add	sp, #20
 800d2e6:	bd30      	pop	{r4, r5, pc}
 800d2e8:	40021800 	.word	0x40021800

0800d2ec <Eth_Link_ITHandler>:
  * @brief  This function handles Ethernet link status.
  * @param  None
  * @retval None
  */
void Eth_Link_ITHandler(INT16U PHYAddress)
{
 800d2ec:	b510      	push	{r4, lr}
  /* Check whether the link interrupt has occurred or not */
  if(((ETH_ReadPHYRegister(PHYAddress, PHY_MISR)) & PHY_LINK_STATUS) != 0)
 800d2ee:	2112      	movs	r1, #18
  * @brief  This function handles Ethernet link status.
  * @param  None
  * @retval None
  */
void Eth_Link_ITHandler(INT16U PHYAddress)
{
 800d2f0:	4604      	mov	r4, r0
  /* Check whether the link interrupt has occurred or not */
  if(((ETH_ReadPHYRegister(PHYAddress, PHY_MISR)) & PHY_LINK_STATUS) != 0)
 800d2f2:	f005 fb55 	bl	80129a0 <ETH_ReadPHYRegister>
 800d2f6:	0482      	lsls	r2, r0, #18
 800d2f8:	d400      	bmi.n	800d2fc <Eth_Link_ITHandler+0x10>
 800d2fa:	bd10      	pop	{r4, pc}
  {
  	 if(((ETH_ReadPHYRegister(PHYAddress, PHY_STS)) & PHY_LINK_STATUS_LINK) != 0)
 800d2fc:	4620      	mov	r0, r4
 800d2fe:	2110      	movs	r1, #16
 800d300:	f005 fb4e 	bl	80129a0 <ETH_ReadPHYRegister>
 800d304:	07c3      	lsls	r3, r0, #31
 800d306:	d5f8      	bpl.n	800d2fa <Eth_Link_ITHandler+0xe>
	{
// 		ETH_BSP_Config();
		LWIP_Init();
  	 }
  }
}
 800d308:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  if(((ETH_ReadPHYRegister(PHYAddress, PHY_MISR)) & PHY_LINK_STATUS) != 0)
  {
  	 if(((ETH_ReadPHYRegister(PHYAddress, PHY_STS)) & PHY_LINK_STATUS_LINK) != 0)
	{
// 		ETH_BSP_Config();
		LWIP_Init();
 800d30c:	f7f6 b9d8 	b.w	80036c0 <LWIP_Init>

0800d310 <BSP_InitEth>:
**return:
**autor:  andiman
**date:
************************************************************/
void  BSP_InitEth(void)
{
 800d310:	b570      	push	{r4, r5, r6, lr}
	INT32S	i;
	

	CPU_SR_ALLOC();  
	CPU_CRITICAL_ENTER();
 800d312:	f7f4 fa2f 	bl	8001774 <CPU_SR_Save>
**autor:  andiman
**date:
************************************************************/
void ETH_MACaddr_Config(INT8U *mac_addr)
{
	ETH_MACAddressConfig(ETH_MAC_Address0, mac_addr); 
 800d316:	4910      	ldr	r1, [pc, #64]	; (800d358 <BSP_InitEth+0x48>)
{
	INT32S	i;
	

	CPU_SR_ALLOC();  
	CPU_CRITICAL_ENTER();
 800d318:	4606      	mov	r6, r0
**autor:  andiman
**date:
************************************************************/
void ETH_MACaddr_Config(INT8U *mac_addr)
{
	ETH_MACAddressConfig(ETH_MAC_Address0, mac_addr); 
 800d31a:	2000      	movs	r0, #0
 800d31c:	f005 f816 	bl	801234c <ETH_MACAddressConfig>
	

	
	ETH_MACaddr_Config(ETH_MAC_ADDR);

 	ETH_DMATxDescChainInit(DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
 800d320:	2205      	movs	r2, #5
 800d322:	490e      	ldr	r1, [pc, #56]	; (800d35c <BSP_InitEth+0x4c>)
 800d324:	480e      	ldr	r0, [pc, #56]	; (800d360 <BSP_InitEth+0x50>)
 800d326:	f005 f9a5 	bl	8012674 <ETH_DMATxDescChainInit>

	ETH_DMARxDescChainInit(DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
 800d32a:	2205      	movs	r2, #5
 800d32c:	490d      	ldr	r1, [pc, #52]	; (800d364 <BSP_InitEth+0x54>)
 800d32e:	480e      	ldr	r0, [pc, #56]	; (800d368 <BSP_InitEth+0x58>)
 800d330:	f005 f92a 	bl	8012588 <ETH_DMARxDescChainInit>
 800d334:	4c0c      	ldr	r4, [pc, #48]	; (800d368 <BSP_InitEth+0x58>)
 800d336:	f104 05a0 	add.w	r5, r4, #160	; 0xa0
	
 
	    

	for(i=0; i<ETH_RXBUFNB; ++i)
		ETH_DMARxDescReceiveITConfig(&DMARxDscrTab[i], ENABLE);
 800d33a:	4620      	mov	r0, r4
 800d33c:	2101      	movs	r1, #1
 800d33e:	3420      	adds	r4, #32
 800d340:	f005 fa22 	bl	8012788 <ETH_DMARxDescReceiveITConfig>

	
 
	    

	for(i=0; i<ETH_RXBUFNB; ++i)
 800d344:	42ac      	cmp	r4, r5
 800d346:	d1f8      	bne.n	800d33a <BSP_InitEth+0x2a>
	// Enable the checksum insertion for the Tx frames 
	for(i=0; i<ETH_TXBUFNB; i++)
		ETH_DMATxDescChecksumInsertionConfig(&DMATxDscrTab[i], ETH_DMATxDesc_ChecksumTCPUDPICMPFull);
	#endif

	CPU_CRITICAL_EXIT();
 800d348:	4630      	mov	r0, r6
 800d34a:	f7f4 fa17 	bl	800177c <CPU_SR_Restore>

	
	//Enable MAC and DMA transmission and reception 
	ETH_Start();  
}
 800d34e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

	CPU_CRITICAL_EXIT();

	
	//Enable MAC and DMA transmission and reception 
	ETH_Start();  
 800d352:	f004 bf8f 	b.w	8012274 <ETH_Start>
 800d356:	bf00      	nop
 800d358:	2000002c 	.word	0x2000002c
 800d35c:	200113e0 	.word	0x200113e0
 800d360:	2000f4d4 	.word	0x2000f4d4
 800d364:	2000f574 	.word	0x2000f574
 800d368:	20011340 	.word	0x20011340

0800d36c <ETH_GPIO_Config>:
**return:
**autor:  andiman
**date:
************************************************************/
void ETH_GPIO_Config(void)
{
 800d36c:	b570      	push	{r4, r5, r6, lr}
  GPIO_InitTypeDef GPIO_InitStructure;

  // Enable GPIOs clocks 
  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA | RCC_AHB1Periph_GPIOB |
 800d36e:	2101      	movs	r1, #1
**return:
**autor:  andiman
**date:
************************************************************/
void ETH_GPIO_Config(void)
{
 800d370:	b082      	sub	sp, #8
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 800d372:	4c32      	ldr	r4, [pc, #200]	; (800d43c <ETH_GPIO_Config+0xd0>)
void ETH_GPIO_Config(void)
{
  GPIO_InitTypeDef GPIO_InitStructure;

  // Enable GPIOs clocks 
  RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA | RCC_AHB1Periph_GPIOB |
 800d374:	f240 10e7 	movw	r0, #487	; 0x1e7
 800d378:	f7fb fd46 	bl	8008e08 <RCC_AHB1PeriphClockCmd>
                         RCC_AHB1Periph_GPIOC | RCC_AHB1Periph_GPIOI |
                         RCC_AHB1Periph_GPIOG | RCC_AHB1Periph_GPIOH |
                         RCC_AHB1Periph_GPIOF, ENABLE);

  // Enable SYSCFG clock
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
 800d37c:	2101      	movs	r1, #1
 800d37e:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800d382:	f7fb fd79 	bl	8008e78 <RCC_APB2PeriphClockCmd>
 
  //Configure MCO (PA8)
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 800d386:	2602      	movs	r6, #2
  // Enable SYSCFG clock
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
 
  //Configure MCO (PA8)
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 800d388:	2203      	movs	r2, #3
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800d38a:	2300      	movs	r3, #0
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 800d38c:	4669      	mov	r1, sp
 800d38e:	4620      	mov	r0, r4

  // Enable SYSCFG clock
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
 
  //Configure MCO (PA8)
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
 800d390:	f44f 7580 	mov.w	r5, #256	; 0x100
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 800d394:	f88d 2005 	strb.w	r2, [sp, #5]
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800d398:	f88d 3006 	strb.w	r3, [sp, #6]
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
 800d39c:	f88d 3007 	strb.w	r3, [sp, #7]

  // Enable SYSCFG clock
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
 
  //Configure MCO (PA8)
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
 800d3a0:	9500      	str	r5, [sp, #0]
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 800d3a2:	f88d 6004 	strb.w	r6, [sp, #4]
  GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 800d3a6:	f7fb fb37 	bl	8008a18 <GPIO_Init>
 #endif /* PHY_CLOCK_MCO */

  SYSCFG_ETH_MediaInterfaceConfig(SYSCFG_ETH_MediaInterface_MII);
#elif defined RMII_MODE  /* Mode RMII with STM322xG-EVAL */

  SYSCFG_ETH_MediaInterfaceConfig(SYSCFG_ETH_MediaInterface_RMII);
 800d3aa:	2001      	movs	r0, #1
 800d3ac:	f005 fdbe 	bl	8012f2c <SYSCFG_ETH_MediaInterfaceConfig>
        ETH_MII_TXD0/ETH_RMII_TXD0 -------> PG13
        ETH_MII_TXD1/ETH_RMII_TXD1 -------> PG14
                                                  */

  /* Configure PA1, PA2 and PA7 */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_7;
 800d3b0:	2386      	movs	r3, #134	; 0x86
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 800d3b2:	4669      	mov	r1, sp
 800d3b4:	4620      	mov	r0, r4
        ETH_MII_TXD0/ETH_RMII_TXD0 -------> PG13
        ETH_MII_TXD1/ETH_RMII_TXD1 -------> PG14
                                                  */

  /* Configure PA1, PA2 and PA7 */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_7;
 800d3b6:	9300      	str	r3, [sp, #0]
  GPIO_Init(GPIOA, &GPIO_InitStructure);
 800d3b8:	f7fb fb2e 	bl	8008a18 <GPIO_Init>
  GPIO_PinAFConfig(GPIOA, GPIO_PinSource1, GPIO_AF_ETH);
 800d3bc:	4620      	mov	r0, r4
 800d3be:	220b      	movs	r2, #11
 800d3c0:	2101      	movs	r1, #1
 800d3c2:	f7fb fbbb 	bl	8008b3c <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_ETH);
  GPIO_PinAFConfig(GPIOA, GPIO_PinSource7, GPIO_AF_ETH);

  /* Configure PC1, PC4 and PC5 */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_4 | GPIO_Pin_5;
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 800d3c6:	4d1e      	ldr	r5, [pc, #120]	; (800d440 <ETH_GPIO_Config+0xd4>)

  /* Configure PA1, PA2 and PA7 */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_7;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
  GPIO_PinAFConfig(GPIOA, GPIO_PinSource1, GPIO_AF_ETH);
  GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_ETH);
 800d3c8:	4631      	mov	r1, r6
 800d3ca:	4620      	mov	r0, r4
 800d3cc:	220b      	movs	r2, #11
 800d3ce:	f7fb fbb5 	bl	8008b3c <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOA, GPIO_PinSource7, GPIO_AF_ETH);
 800d3d2:	4620      	mov	r0, r4
 800d3d4:	220b      	movs	r2, #11
 800d3d6:	2107      	movs	r1, #7
 800d3d8:	f7fb fbb0 	bl	8008b3c <GPIO_PinAFConfig>

  /* Configure PC1, PC4 and PC5 */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_4 | GPIO_Pin_5;
 800d3dc:	2332      	movs	r3, #50	; 0x32
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 800d3de:	4669      	mov	r1, sp
 800d3e0:	4628      	mov	r0, r5
  GPIO_PinAFConfig(GPIOA, GPIO_PinSource1, GPIO_AF_ETH);
  GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_ETH);
  GPIO_PinAFConfig(GPIOA, GPIO_PinSource7, GPIO_AF_ETH);

  /* Configure PC1, PC4 and PC5 */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_4 | GPIO_Pin_5;
 800d3e2:	9300      	str	r3, [sp, #0]
  GPIO_Init(GPIOC, &GPIO_InitStructure);
 800d3e4:	f7fb fb18 	bl	8008a18 <GPIO_Init>
  GPIO_PinAFConfig(GPIOC, GPIO_PinSource1, GPIO_AF_ETH);
 800d3e8:	4628      	mov	r0, r5
 800d3ea:	220b      	movs	r2, #11
 800d3ec:	2101      	movs	r1, #1
 800d3ee:	f7fb fba5 	bl	8008b3c <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOC, GPIO_PinSource4, GPIO_AF_ETH);
 800d3f2:	4628      	mov	r0, r5
 800d3f4:	220b      	movs	r2, #11
 800d3f6:	2104      	movs	r1, #4
 800d3f8:	f7fb fba0 	bl	8008b3c <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOC, GPIO_PinSource5, GPIO_AF_ETH);
                                
  /* Configure PG11, PG14 and PG13 */
  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_11 | GPIO_Pin_13 | GPIO_Pin_14;
  GPIO_Init(GPIOG, &GPIO_InitStructure);
 800d3fc:	f504 54c0 	add.w	r4, r4, #6144	; 0x1800
  /* Configure PC1, PC4 and PC5 */
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_4 | GPIO_Pin_5;
  GPIO_Init(GPIOC, &GPIO_InitStructure);
  GPIO_PinAFConfig(GPIOC, GPIO_PinSource1, GPIO_AF_ETH);
  GPIO_PinAFConfig(GPIOC, GPIO_PinSource4, GPIO_AF_ETH);
  GPIO_PinAFConfig(GPIOC, GPIO_PinSource5, GPIO_AF_ETH);
 800d400:	4628      	mov	r0, r5
 800d402:	220b      	movs	r2, #11
 800d404:	2105      	movs	r1, #5
 800d406:	f7fb fb99 	bl	8008b3c <GPIO_PinAFConfig>
                                
  /* Configure PG11, PG14 and PG13 */
  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_11 | GPIO_Pin_13 | GPIO_Pin_14;
 800d40a:	f44f 43d0 	mov.w	r3, #26624	; 0x6800
  GPIO_Init(GPIOG, &GPIO_InitStructure);
 800d40e:	4669      	mov	r1, sp
 800d410:	4620      	mov	r0, r4
  GPIO_PinAFConfig(GPIOC, GPIO_PinSource1, GPIO_AF_ETH);
  GPIO_PinAFConfig(GPIOC, GPIO_PinSource4, GPIO_AF_ETH);
  GPIO_PinAFConfig(GPIOC, GPIO_PinSource5, GPIO_AF_ETH);
                                
  /* Configure PG11, PG14 and PG13 */
  GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_11 | GPIO_Pin_13 | GPIO_Pin_14;
 800d412:	9300      	str	r3, [sp, #0]
  GPIO_Init(GPIOG, &GPIO_InitStructure);
 800d414:	f7fb fb00 	bl	8008a18 <GPIO_Init>
  GPIO_PinAFConfig(GPIOG, GPIO_PinSource11, GPIO_AF_ETH);
 800d418:	220b      	movs	r2, #11
 800d41a:	4620      	mov	r0, r4
 800d41c:	4611      	mov	r1, r2
 800d41e:	f7fb fb8d 	bl	8008b3c <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOG, GPIO_PinSource13, GPIO_AF_ETH);
 800d422:	4620      	mov	r0, r4
 800d424:	220b      	movs	r2, #11
 800d426:	210d      	movs	r1, #13
 800d428:	f7fb fb88 	bl	8008b3c <GPIO_PinAFConfig>
  GPIO_PinAFConfig(GPIOG, GPIO_PinSource14, GPIO_AF_ETH);
 800d42c:	4620      	mov	r0, r4
 800d42e:	220b      	movs	r2, #11
 800d430:	210e      	movs	r1, #14
 800d432:	f7fb fb83 	bl	8008b3c <GPIO_PinAFConfig>
#endif

	
}
 800d436:	b002      	add	sp, #8
 800d438:	bd70      	pop	{r4, r5, r6, pc}
 800d43a:	bf00      	nop
 800d43c:	40020000 	.word	0x40020000
 800d440:	40020800 	.word	0x40020800

0800d444 <ETH_MACDMA_Config>:
**return:
**autor:  andiman
**date:
************************************************************/
void ETH_MACDMA_Config(void)
{
 800d444:	b5f0      	push	{r4, r5, r6, r7, lr}
	INT32U timeout = 0;
	ETH_InitTypeDef ETH_InitStructure;

	// Enable ETHERNET clock  
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_ETH_MAC | RCC_AHB1Periph_ETH_MAC_Tx |
 800d446:	2101      	movs	r1, #1
**return:
**autor:  andiman
**date:
************************************************************/
void ETH_MACDMA_Config(void)
{
 800d448:	b0b1      	sub	sp, #196	; 0xc4
	INT32U timeout = 0;
	ETH_InitTypeDef ETH_InitStructure;

	// Enable ETHERNET clock  
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_ETH_MAC | RCC_AHB1Periph_ETH_MAC_Tx |
 800d44a:	f04f 6060 	mov.w	r0, #234881024	; 0xe000000
 800d44e:	f7fb fcdb 	bl	8008e08 <RCC_AHB1PeriphClockCmd>

	//Software reset 
	ETH_SoftwareReset();

	//Wait for software reset
	while (ETH_GetSoftwareResetStatus() == SET)
 800d452:	f242 7412 	movw	r4, #10002	; 0x2712
	// Enable ETHERNET clock  
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_ETH_MAC | RCC_AHB1Periph_ETH_MAC_Tx |
                         RCC_AHB1Periph_ETH_MAC_Rx, ENABLE);                                             

	//Reset ETHERNET on AHB Bus 
	ETH_DeInit();
 800d456:	f004 fea9 	bl	80121ac <ETH_DeInit>

	//Software reset 
	ETH_SoftwareReset();
 800d45a:	f005 f9c9 	bl	80127f0 <ETH_SoftwareReset>

	//Wait for software reset
	while (ETH_GetSoftwareResetStatus() == SET)
 800d45e:	e003      	b.n	800d468 <ETH_MACDMA_Config+0x24>
	{
		BSP_Delay_ms(1);
 800d460:	f7f3 fb9a 	bl	8000b98 <BSP_Delay_ms>
		if( timeout++ > 10000)
 800d464:	3c01      	subs	r4, #1
 800d466:	d034      	beq.n	800d4d2 <ETH_MACDMA_Config+0x8e>

	//Software reset 
	ETH_SoftwareReset();

	//Wait for software reset
	while (ETH_GetSoftwareResetStatus() == SET)
 800d468:	f005 f9ca 	bl	8012800 <ETH_GetSoftwareResetStatus>
 800d46c:	2801      	cmp	r0, #1
 800d46e:	d0f7      	beq.n	800d460 <ETH_MACDMA_Config+0x1c>
			return;
	}

	//ETHERNET Configuration
	//Call ETH_StructInit if you don't like to configure all ETH_InitStructure parameter 
	ETH_StructInit(&ETH_InitStructure);
 800d470:	a801      	add	r0, sp, #4
 800d472:	f004 fea9 	bl	80121c8 <ETH_StructInit>

	//Fill ETH_InitStructure parametrs 
	//------------------------   MAC   -----------------------------------
	ETH_InitStructure.ETH_AutoNegotiation = ETH_AutoNegotiation_Enable;
 800d476:	2401      	movs	r4, #1
	//ETH_InitStructure.ETH_AutoNegotiation = ETH_AutoNegotiation_Disable; 
	//  ETH_InitStructure.ETH_Speed = ETH_Speed_10M;
	//  ETH_InitStructure.ETH_Mode = ETH_Mode_FullDuplex;   

	ETH_InitStructure.ETH_LoopbackMode = ETH_LoopbackMode_Disable;
 800d478:	2300      	movs	r3, #0
  
	//When we use the Checksum offload feature, we need to enable the Store and Forward mode: 
	//the store and forward guarantee that a whole frame is stored in the FIFO, so the MAC can insert/verify the checksum, 
	//if the checksum is OK the DMA can handle the frame otherwise the frame is dropped 
	ETH_InitStructure.ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Enable; 
	ETH_InitStructure.ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;         
 800d47a:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
	//ETH_InitStructure.ETH_AutoNegotiation = ETH_AutoNegotiation_Disable; 
	//  ETH_InitStructure.ETH_Speed = ETH_Speed_10M;
	//  ETH_InitStructure.ETH_Mode = ETH_Mode_FullDuplex;   

	ETH_InitStructure.ETH_LoopbackMode = ETH_LoopbackMode_Disable;
	ETH_InitStructure.ETH_RetryTransmission = ETH_RetryTransmission_Disable;
 800d47e:	f44f 7500 	mov.w	r5, #512	; 0x200
	ETH_InitStructure.ETH_RxDMABurstLength = ETH_RxDMABurstLength_32Beat;          
	ETH_InitStructure.ETH_TxDMABurstLength = ETH_TxDMABurstLength_32Beat;
	ETH_InitStructure.ETH_DMAArbitration = ETH_DMAArbitration_RoundRobin_RxTx_2_1;

	//Configure Ethernet 
	ETH_Init(&ETH_InitStructure, DP83848_PHY_ADDRESS);
 800d482:	4621      	mov	r1, r4
	//When we use the Checksum offload feature, we need to enable the Store and Forward mode: 
	//the store and forward guarantee that a whole frame is stored in the FIFO, so the MAC can insert/verify the checksum, 
	//if the checksum is OK the DMA can handle the frame otherwise the frame is dropped 
	ETH_InitStructure.ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Enable; 
	ETH_InitStructure.ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;         
	ETH_InitStructure.ETH_TransmitStoreForward = ETH_TransmitStoreForward_Enable;     
 800d484:	f44f 1e00 	mov.w	lr, #2097152	; 0x200000
	ETH_InitStructure.ETH_AutoNegotiation = ETH_AutoNegotiation_Enable;
	//ETH_InitStructure.ETH_AutoNegotiation = ETH_AutoNegotiation_Disable; 
	//  ETH_InitStructure.ETH_Speed = ETH_Speed_10M;
	//  ETH_InitStructure.ETH_Mode = ETH_Mode_FullDuplex;   

	ETH_InitStructure.ETH_LoopbackMode = ETH_LoopbackMode_Disable;
 800d488:	9308      	str	r3, [sp, #32]
	ETH_InitStructure.ETH_RetryTransmission = ETH_RetryTransmission_Disable;
	ETH_InitStructure.ETH_AutomaticPadCRCStrip = ETH_AutomaticPadCRCStrip_Disable;
 800d48a:	930c      	str	r3, [sp, #48]	; 0x30
	ETH_InitStructure.ETH_ReceiveAll = ETH_ReceiveAll_Disable;
 800d48c:	930f      	str	r3, [sp, #60]	; 0x3c
	ETH_InitStructure.ETH_BroadcastFramesReception = ETH_BroadcastFramesReception_Enable;
 800d48e:	9312      	str	r3, [sp, #72]	; 0x48
	ETH_InitStructure.ETH_PromiscuousMode = ETH_PromiscuousMode_Disable;
 800d490:	9314      	str	r3, [sp, #80]	; 0x50
	ETH_InitStructure.ETH_MulticastFramesFilter = ETH_MulticastFramesFilter_Perfect;
 800d492:	9315      	str	r3, [sp, #84]	; 0x54
	ETH_InitStructure.ETH_UnicastFramesFilter = ETH_UnicastFramesFilter_Perfect;
 800d494:	9316      	str	r3, [sp, #88]	; 0x58
	//------------------------   DMA   -----------------------------------  
  
	//When we use the Checksum offload feature, we need to enable the Store and Forward mode: 
	//the store and forward guarantee that a whole frame is stored in the FIFO, so the MAC can insert/verify the checksum, 
	//if the checksum is OK the DMA can handle the frame otherwise the frame is dropped 
	ETH_InitStructure.ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Enable; 
 800d496:	9321      	str	r3, [sp, #132]	; 0x84
	ETH_InitStructure.ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;         
	ETH_InitStructure.ETH_TransmitStoreForward = ETH_TransmitStoreForward_Enable;     
 
	ETH_InitStructure.ETH_ForwardErrorFrames = ETH_ForwardErrorFrames_Disable;       
 800d498:	9326      	str	r3, [sp, #152]	; 0x98
	ETH_InitStructure.ETH_ForwardUndersizedGoodFrames = ETH_ForwardUndersizedGoodFrames_Disable;   
 800d49a:	9327      	str	r3, [sp, #156]	; 0x9c
	//ETH_InitStructure.ETH_AutoNegotiation = ETH_AutoNegotiation_Disable; 
	//  ETH_InitStructure.ETH_Speed = ETH_Speed_10M;
	//  ETH_InitStructure.ETH_Mode = ETH_Mode_FullDuplex;   

	ETH_InitStructure.ETH_LoopbackMode = ETH_LoopbackMode_Disable;
	ETH_InitStructure.ETH_RetryTransmission = ETH_RetryTransmission_Disable;
 800d49c:	950b      	str	r5, [sp, #44]	; 0x2c
  
	//When we use the Checksum offload feature, we need to enable the Store and Forward mode: 
	//the store and forward guarantee that a whole frame is stored in the FIFO, so the MAC can insert/verify the checksum, 
	//if the checksum is OK the DMA can handle the frame otherwise the frame is dropped 
	ETH_InitStructure.ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Enable; 
	ETH_InitStructure.ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;         
 800d49e:	9222      	str	r2, [sp, #136]	; 0x88
	ETH_InitStructure.ETH_TransmitStoreForward = ETH_TransmitStoreForward_Enable;     
 
	ETH_InitStructure.ETH_ForwardErrorFrames = ETH_ForwardErrorFrames_Disable;       
	ETH_InitStructure.ETH_ForwardUndersizedGoodFrames = ETH_ForwardUndersizedGoodFrames_Disable;   
	ETH_InitStructure.ETH_SecondFrameOperate = ETH_SecondFrameOperate_Enable;
	ETH_InitStructure.ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable;      
 800d4a0:	922a      	str	r2, [sp, #168]	; 0xa8
	ETH_InitStructure.ETH_FixedBurst = ETH_FixedBurst_Enable;                
	ETH_InitStructure.ETH_RxDMABurstLength = ETH_RxDMABurstLength_32Beat;          
	ETH_InitStructure.ETH_TxDMABurstLength = ETH_TxDMABurstLength_32Beat;
	ETH_InitStructure.ETH_DMAArbitration = ETH_DMAArbitration_RoundRobin_RxTx_2_1;
 800d4a2:	f44f 4380 	mov.w	r3, #16384	; 0x4000
	ETH_InitStructure.ETH_ForwardUndersizedGoodFrames = ETH_ForwardUndersizedGoodFrames_Disable;   
	ETH_InitStructure.ETH_SecondFrameOperate = ETH_SecondFrameOperate_Enable;
	ETH_InitStructure.ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable;      
	ETH_InitStructure.ETH_FixedBurst = ETH_FixedBurst_Enable;                
	ETH_InitStructure.ETH_RxDMABurstLength = ETH_RxDMABurstLength_32Beat;          
	ETH_InitStructure.ETH_TxDMABurstLength = ETH_TxDMABurstLength_32Beat;
 800d4a6:	f44f 5200 	mov.w	r2, #8192	; 0x2000
	ETH_InitStructure.ETH_DMAArbitration = ETH_DMAArbitration_RoundRobin_RxTx_2_1;

	//Configure Ethernet 
	ETH_Init(&ETH_InitStructure, DP83848_PHY_ADDRESS);
 800d4aa:	a801      	add	r0, sp, #4
	ETH_InitStructure.ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;         
	ETH_InitStructure.ETH_TransmitStoreForward = ETH_TransmitStoreForward_Enable;     
 
	ETH_InitStructure.ETH_ForwardErrorFrames = ETH_ForwardErrorFrames_Disable;       
	ETH_InitStructure.ETH_ForwardUndersizedGoodFrames = ETH_ForwardUndersizedGoodFrames_Disable;   
	ETH_InitStructure.ETH_SecondFrameOperate = ETH_SecondFrameOperate_Enable;
 800d4ac:	2704      	movs	r7, #4
	ETH_InitStructure.ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable;      
	ETH_InitStructure.ETH_FixedBurst = ETH_FixedBurst_Enable;                
 800d4ae:	f44f 3680 	mov.w	r6, #65536	; 0x10000
	ETH_InitStructure.ETH_RxDMABurstLength = ETH_RxDMABurstLength_32Beat;          
 800d4b2:	f44f 0580 	mov.w	r5, #4194304	; 0x400000
	//Call ETH_StructInit if you don't like to configure all ETH_InitStructure parameter 
	ETH_StructInit(&ETH_InitStructure);

	//Fill ETH_InitStructure parametrs 
	//------------------------   MAC   -----------------------------------
	ETH_InitStructure.ETH_AutoNegotiation = ETH_AutoNegotiation_Enable;
 800d4b6:	9401      	str	r4, [sp, #4]
	//When we use the Checksum offload feature, we need to enable the Store and Forward mode: 
	//the store and forward guarantee that a whole frame is stored in the FIFO, so the MAC can insert/verify the checksum, 
	//if the checksum is OK the DMA can handle the frame otherwise the frame is dropped 
	ETH_InitStructure.ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Enable; 
	ETH_InitStructure.ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;         
	ETH_InitStructure.ETH_TransmitStoreForward = ETH_TransmitStoreForward_Enable;     
 800d4b8:	f8cd e090 	str.w	lr, [sp, #144]	; 0x90
 
	ETH_InitStructure.ETH_ForwardErrorFrames = ETH_ForwardErrorFrames_Disable;       
	ETH_InitStructure.ETH_ForwardUndersizedGoodFrames = ETH_ForwardUndersizedGoodFrames_Disable;   
	ETH_InitStructure.ETH_SecondFrameOperate = ETH_SecondFrameOperate_Enable;
 800d4bc:	9729      	str	r7, [sp, #164]	; 0xa4
	ETH_InitStructure.ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable;      
	ETH_InitStructure.ETH_FixedBurst = ETH_FixedBurst_Enable;                
 800d4be:	962b      	str	r6, [sp, #172]	; 0xac
	ETH_InitStructure.ETH_RxDMABurstLength = ETH_RxDMABurstLength_32Beat;          
 800d4c0:	952c      	str	r5, [sp, #176]	; 0xb0
	ETH_InitStructure.ETH_TxDMABurstLength = ETH_TxDMABurstLength_32Beat;
 800d4c2:	922d      	str	r2, [sp, #180]	; 0xb4
	ETH_InitStructure.ETH_DMAArbitration = ETH_DMAArbitration_RoundRobin_RxTx_2_1;
 800d4c4:	932f      	str	r3, [sp, #188]	; 0xbc

	//Configure Ethernet 
	ETH_Init(&ETH_InitStructure, DP83848_PHY_ADDRESS);
 800d4c6:	f005 fac9 	bl	8012a5c <ETH_Init>

	//Enable the Ethernet Rx Interrupt 
	ETH_DMAITConfig(ETH_DMA_IT_NIS | ETH_DMA_IT_R, ENABLE);
 800d4ca:	4621      	mov	r1, r4
 800d4cc:	4802      	ldr	r0, [pc, #8]	; (800d4d8 <ETH_MACDMA_Config+0x94>)
 800d4ce:	f005 f9a7 	bl	8012820 <ETH_DMAITConfig>
}
 800d4d2:	b031      	add	sp, #196	; 0xc4
 800d4d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800d4d6:	bf00      	nop
 800d4d8:	00010040 	.word	0x00010040

0800d4dc <ETH_BSP_Config>:
**return:
**autor:  andiman
**date:
************************************************************/
void ETH_BSP_Config(void)
{
 800d4dc:	b508      	push	{r3, lr}
	ETH_GPIO_Config();
 800d4de:	f7ff ff45 	bl	800d36c <ETH_GPIO_Config>

	BSP_ETH_IRQHandler = LwIP_SendSem;
 800d4e2:	4b07      	ldr	r3, [pc, #28]	; (800d500 <ETH_BSP_Config+0x24>)
 800d4e4:	4a07      	ldr	r2, [pc, #28]	; (800d504 <ETH_BSP_Config+0x28>)
	
	BSP_IntVectSet(BSP_INT_ID_ETH, ETH_IRQHandler);
 800d4e6:	4908      	ldr	r1, [pc, #32]	; (800d508 <ETH_BSP_Config+0x2c>)
 800d4e8:	203d      	movs	r0, #61	; 0x3d
************************************************************/
void ETH_BSP_Config(void)
{
	ETH_GPIO_Config();

	BSP_ETH_IRQHandler = LwIP_SendSem;
 800d4ea:	601a      	str	r2, [r3, #0]
	
	BSP_IntVectSet(BSP_INT_ID_ETH, ETH_IRQHandler);
 800d4ec:	f7f3 fbbc 	bl	8000c68 <BSP_IntVectSet>
	BSP_IntEn(BSP_INT_ID_ETH);
 800d4f0:	203d      	movs	r0, #61	; 0x3d
 800d4f2:	f7f3 fbb1 	bl	8000c58 <BSP_IntEn>

	ETH_MACDMA_Config();

	
}
 800d4f6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	BSP_ETH_IRQHandler = LwIP_SendSem;
	
	BSP_IntVectSet(BSP_INT_ID_ETH, ETH_IRQHandler);
	BSP_IntEn(BSP_INT_ID_ETH);

	ETH_MACDMA_Config();
 800d4fa:	f7ff bfa3 	b.w	800d444 <ETH_MACDMA_Config>
 800d4fe:	bf00      	nop
 800d500:	200007fc 	.word	0x200007fc
 800d504:	080036a9 	.word	0x080036a9
 800d508:	0800d215 	.word	0x0800d215

0800d50c <ETH_MACaddr_Config>:
**autor:  andiman
**date:
************************************************************/
void ETH_MACaddr_Config(INT8U *mac_addr)
{
	ETH_MACAddressConfig(ETH_MAC_Address0, mac_addr); 
 800d50c:	4601      	mov	r1, r0
 800d50e:	2000      	movs	r0, #0
 800d510:	f004 bf1c 	b.w	801234c <ETH_MACAddressConfig>

0800d514 <BSP_ETH_ReleaseDescriptor>:
{
	INT32S i;
	volatile ETH_DMADESCTypeDef *DMARxNextDesc;
	//Release descriptors to DMA 
	//Check if received frame with multiple DMA buffer segments 
	if (DMA_RX_FRAME_infos->Seg_Count > 1)
 800d514:	4b10      	ldr	r3, [pc, #64]	; (800d558 <BSP_ETH_ReleaseDescriptor+0x44>)
**return:
**autor:  andiman
**date:
************************************************************/
void BSP_ETH_ReleaseDescriptor(FrameTypeDef * pframe)
{
 800d516:	b410      	push	{r4}
	INT32S i;
	volatile ETH_DMADESCTypeDef *DMARxNextDesc;
	//Release descriptors to DMA 
	//Check if received frame with multiple DMA buffer segments 
	if (DMA_RX_FRAME_infos->Seg_Count > 1)
 800d518:	681c      	ldr	r4, [r3, #0]
 800d51a:	68a3      	ldr	r3, [r4, #8]
		DMARxNextDesc = DMA_RX_FRAME_infos->FS_Rx_Desc;
	else
		DMARxNextDesc = pframe->descriptor;
  
	//Set Own bit in Rx descriptors: gives the buffers back to DMA 
	for (i=0; i<DMA_RX_FRAME_infos->Seg_Count; i++)
 800d51c:	68a2      	ldr	r2, [r4, #8]
{
	INT32S i;
	volatile ETH_DMADESCTypeDef *DMARxNextDesc;
	//Release descriptors to DMA 
	//Check if received frame with multiple DMA buffer segments 
	if (DMA_RX_FRAME_infos->Seg_Count > 1)
 800d51e:	2b01      	cmp	r3, #1
		DMARxNextDesc = DMA_RX_FRAME_infos->FS_Rx_Desc;
 800d520:	bf8c      	ite	hi
 800d522:	6823      	ldrhi	r3, [r4, #0]
	else
		DMARxNextDesc = pframe->descriptor;
 800d524:	6883      	ldrls	r3, [r0, #8]
  
	//Set Own bit in Rx descriptors: gives the buffers back to DMA 
	for (i=0; i<DMA_RX_FRAME_infos->Seg_Count; i++)
 800d526:	b142      	cbz	r2, 800d53a <BSP_ETH_ReleaseDescriptor+0x26>
 800d528:	2200      	movs	r2, #0
	{  
		DMARxNextDesc->Status = ETH_DMARxDesc_OWN;
 800d52a:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 800d52e:	6018      	str	r0, [r3, #0]
		DMARxNextDesc = (ETH_DMADESCTypeDef *)(DMARxNextDesc->Buffer2NextDescAddr);
 800d530:	68db      	ldr	r3, [r3, #12]
		DMARxNextDesc = DMA_RX_FRAME_infos->FS_Rx_Desc;
	else
		DMARxNextDesc = pframe->descriptor;
  
	//Set Own bit in Rx descriptors: gives the buffers back to DMA 
	for (i=0; i<DMA_RX_FRAME_infos->Seg_Count; i++)
 800d532:	68a1      	ldr	r1, [r4, #8]
 800d534:	3201      	adds	r2, #1
 800d536:	4291      	cmp	r1, r2
 800d538:	d8f9      	bhi.n	800d52e <BSP_ETH_ReleaseDescriptor+0x1a>
	//Clear Segment_Count 
	DMA_RX_FRAME_infos->Seg_Count =0;
  
  
	//When Rx Buffer unavailable flag is set: clear it and resume reception 
	if ((ETH->DMASR & ETH_DMASR_RBUS) != RESET)
 800d53a:	f241 0114 	movw	r1, #4116	; 0x1014
		DMARxNextDesc->Status = ETH_DMARxDesc_OWN;
		DMARxNextDesc = (ETH_DMADESCTypeDef *)(DMARxNextDesc->Buffer2NextDescAddr);
	}
  
	//Clear Segment_Count 
	DMA_RX_FRAME_infos->Seg_Count =0;
 800d53e:	2200      	movs	r2, #0
  
  
	//When Rx Buffer unavailable flag is set: clear it and resume reception 
	if ((ETH->DMASR & ETH_DMASR_RBUS) != RESET)
 800d540:	4b06      	ldr	r3, [pc, #24]	; (800d55c <BSP_ETH_ReleaseDescriptor+0x48>)
		DMARxNextDesc->Status = ETH_DMARxDesc_OWN;
		DMARxNextDesc = (ETH_DMADESCTypeDef *)(DMARxNextDesc->Buffer2NextDescAddr);
	}
  
	//Clear Segment_Count 
	DMA_RX_FRAME_infos->Seg_Count =0;
 800d542:	60a2      	str	r2, [r4, #8]
  
  
	//When Rx Buffer unavailable flag is set: clear it and resume reception 
	if ((ETH->DMASR & ETH_DMASR_RBUS) != RESET)
 800d544:	5858      	ldr	r0, [r3, r1]
 800d546:	0600      	lsls	r0, r0, #24
 800d548:	d504      	bpl.n	800d554 <BSP_ETH_ReleaseDescriptor+0x40>
	{
		//Clear RBUS ETHERNET DMA flag 
		ETH->DMASR = ETH_DMASR_RBUS;
      
		//Resume DMA reception 
		ETH->DMARPDR = 0;
 800d54a:	f241 0008 	movw	r0, #4104	; 0x1008
  
	//When Rx Buffer unavailable flag is set: clear it and resume reception 
	if ((ETH->DMASR & ETH_DMASR_RBUS) != RESET)
	{
		//Clear RBUS ETHERNET DMA flag 
		ETH->DMASR = ETH_DMASR_RBUS;
 800d54e:	2480      	movs	r4, #128	; 0x80
 800d550:	505c      	str	r4, [r3, r1]
      
		//Resume DMA reception 
		ETH->DMARPDR = 0;
 800d552:	501a      	str	r2, [r3, r0]
	}
}
 800d554:	bc10      	pop	{r4}
 800d556:	4770      	bx	lr
 800d558:	2001133c 	.word	0x2001133c
 800d55c:	40028000 	.word	0x40028000

0800d560 <BSP_ETH_GetDescriptorStatus>:
**autor:  andiman
**date:
************************************************************/
INT8U BSP_ETH_GetDescriptorStatus(FrameTypeDef * pframe)
{
	return ((pframe->descriptor->Status & ETH_DMARxDesc_ES) == RESET)?true:false;
 800d560:	6883      	ldr	r3, [r0, #8]
 800d562:	6818      	ldr	r0, [r3, #0]
 800d564:	f480 4000 	eor.w	r0, r0, #32768	; 0x8000
}
 800d568:	f3c0 30c0 	ubfx	r0, r0, #15, #1
 800d56c:	4770      	bx	lr
 800d56e:	bf00      	nop

0800d570 <BSP_GPIO_PortClkSwitch>:

	PortClk = 1<<(index /4);

	switch_set = switch_set>0?ENABLE : DISABLE;

	RCC_AHB1PeriphClockCmd(PortClk, switch_set);	
 800d570:	f3c0 2085 	ubfx	r0, r0, #10, #6
 800d574:	2301      	movs	r3, #1
 800d576:	3100      	adds	r1, #0
 800d578:	bf18      	it	ne
 800d57a:	2101      	movne	r1, #1
 800d57c:	fa03 f000 	lsl.w	r0, r3, r0
 800d580:	f7fb bc42 	b.w	8008e08 <RCC_AHB1PeriphClockCmd>

0800d584 <BSP_GPIO_Init>:
**return:
**autor:  andiman
**date:
************************************************************/
int BSP_GPIO_Init(GPIO_TypeDef* GPIOx,INT16U PINx,INT8U PinDir,INT8U PinOtype,INT8U PinPuPd)
{
 800d584:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800d588:	4614      	mov	r4, r2
 800d58a:	4699      	mov	r9, r3

	PortClk = 1<<(index /4);

	switch_set = switch_set>0?ENABLE : DISABLE;

	RCC_AHB1PeriphClockCmd(PortClk, switch_set);	
 800d58c:	2601      	movs	r6, #1
**return:
**autor:  andiman
**date:
************************************************************/
int BSP_GPIO_Init(GPIO_TypeDef* GPIOx,INT16U PINx,INT8U PinDir,INT8U PinOtype,INT8U PinPuPd)
{
 800d58e:	4607      	mov	r7, r0

	PortClk = 1<<(index /4);

	switch_set = switch_set>0?ENABLE : DISABLE;

	RCC_AHB1PeriphClockCmd(PortClk, switch_set);	
 800d590:	f3c0 2085 	ubfx	r0, r0, #10, #6
**return:
**autor:  andiman
**date:
************************************************************/
int BSP_GPIO_Init(GPIO_TypeDef* GPIOx,INT16U PINx,INT8U PinDir,INT8U PinOtype,INT8U PinPuPd)
{
 800d594:	b083      	sub	sp, #12
 800d596:	460d      	mov	r5, r1

	PortClk = 1<<(index /4);

	switch_set = switch_set>0?ENABLE : DISABLE;

	RCC_AHB1PeriphClockCmd(PortClk, switch_set);	
 800d598:	fa06 f000 	lsl.w	r0, r6, r0
 800d59c:	4631      	mov	r1, r6
**return:
**autor:  andiman
**date:
************************************************************/
int BSP_GPIO_Init(GPIO_TypeDef* GPIOx,INT16U PINx,INT8U PinDir,INT8U PinOtype,INT8U PinPuPd)
{
 800d59e:	f89d 8028 	ldrb.w	r8, [sp, #40]	; 0x28

	PortClk = 1<<(index /4);

	switch_set = switch_set>0?ENABLE : DISABLE;

	RCC_AHB1PeriphClockCmd(PortClk, switch_set);	
 800d5a2:	f7fb fc31 	bl	8008e08 <RCC_AHB1PeriphClockCmd>


	 BSP_GPIO_PortClkSwitch(GPIOx,ENABLE);
	
	GPIO_InitStruct.GPIO_Pin = PINx;
	GPIO_InitStruct.GPIO_Mode = PinDir>0?GPIO_Mode_OUT : GPIO_Mode_IN;
 800d5a6:	3400      	adds	r4, #0
 800d5a8:	bf18      	it	ne
 800d5aa:	2401      	movne	r4, #1
	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;
 800d5ac:	2202      	movs	r2, #2


	 BSP_GPIO_PortClkSwitch(GPIOx,ENABLE);
	
	GPIO_InitStruct.GPIO_Pin = PINx;
	GPIO_InitStruct.GPIO_Mode = PinDir>0?GPIO_Mode_OUT : GPIO_Mode_IN;
 800d5ae:	f88d 4004 	strb.w	r4, [sp, #4]
	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStruct.GPIO_OType = PinOtype;
 800d5b2:	f88d 9006 	strb.w	r9, [sp, #6]
	GPIO_InitStruct.GPIO_PuPd  = PinPuPd;
 800d5b6:	f88d 8007 	strb.w	r8, [sp, #7]

	 BSP_GPIO_PortClkSwitch(GPIOx,ENABLE);
	
	GPIO_InitStruct.GPIO_Pin = PINx;
	GPIO_InitStruct.GPIO_Mode = PinDir>0?GPIO_Mode_OUT : GPIO_Mode_IN;
	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;
 800d5ba:	f88d 2005 	strb.w	r2, [sp, #5]
	GPIO_InitStruct.GPIO_OType = PinOtype;
	GPIO_InitStruct.GPIO_PuPd  = PinPuPd;
 800d5be:	2400      	movs	r4, #0
 800d5c0:	e002      	b.n	800d5c8 <BSP_GPIO_Init+0x44>
 800d5c2:	3401      	adds	r4, #1

	for(i=0;i<16;i++)
 800d5c4:	2c10      	cmp	r4, #16
 800d5c6:	d00e      	beq.n	800d5e6 <BSP_GPIO_Init+0x62>
	{
		if( PINx & (1<<i))
 800d5c8:	fa45 f304 	asr.w	r3, r5, r4
 800d5cc:	07db      	lsls	r3, r3, #31
 800d5ce:	d5f8      	bpl.n	800d5c2 <BSP_GPIO_Init+0x3e>
		{
			GPIO_InitStruct.GPIO_Pin = PINx & (1<<i);
 800d5d0:	fa06 f304 	lsl.w	r3, r6, r4
 800d5d4:	402b      	ands	r3, r5
			GPIO_Init(GPIOx, &GPIO_InitStruct);
 800d5d6:	4669      	mov	r1, sp
 800d5d8:	4638      	mov	r0, r7
 800d5da:	3401      	adds	r4, #1

	for(i=0;i<16;i++)
	{
		if( PINx & (1<<i))
		{
			GPIO_InitStruct.GPIO_Pin = PINx & (1<<i);
 800d5dc:	9300      	str	r3, [sp, #0]
			GPIO_Init(GPIOx, &GPIO_InitStruct);
 800d5de:	f7fb fa1b 	bl	8008a18 <GPIO_Init>
	GPIO_InitStruct.GPIO_Mode = PinDir>0?GPIO_Mode_OUT : GPIO_Mode_IN;
	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStruct.GPIO_OType = PinOtype;
	GPIO_InitStruct.GPIO_PuPd  = PinPuPd;

	for(i=0;i<16;i++)
 800d5e2:	2c10      	cmp	r4, #16
 800d5e4:	d1f0      	bne.n	800d5c8 <BSP_GPIO_Init+0x44>
			GPIO_Init(GPIOx, &GPIO_InitStruct);
		}
	}

	return SUCC;
}
 800d5e6:	2000      	movs	r0, #0
 800d5e8:	b003      	add	sp, #12
 800d5ea:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800d5ee:	bf00      	nop

0800d5f0 <BSP_GPIO_PinWriteHigh>:
**autor:  andiman
**date:
************************************************************/
void BSP_GPIO_PinWriteHigh(GPIO_TypeDef* GPIOx,INT16U PINx)
{
	GPIO_SetBits(GPIOx, PINx);
 800d5f0:	f7fb ba94 	b.w	8008b1c <GPIO_SetBits>

0800d5f4 <BSP_GPIO_PinWriteLow>:
**autor:  andiman
**date:
************************************************************/
void BSP_GPIO_PinWriteLow(GPIO_TypeDef* GPIOx,INT16U PINx)
{
	GPIO_ResetBits(GPIOx, PINx);
 800d5f4:	f7fb ba94 	b.w	8008b20 <GPIO_ResetBits>

0800d5f8 <BSP_GPIO_InputPinRead>:
**autor:  andiman
**date:
************************************************************/
INT8U BSP_GPIO_InputPinRead(GPIO_TypeDef* GPIOx,INT16U PINx)
{
	return ( GPIO_ReadInputDataBit(GPIOx, PINx));
 800d5f8:	f7fb ba7c 	b.w	8008af4 <GPIO_ReadInputDataBit>

0800d5fc <BSP_GPIO_OutputPinRead>:
**autor:  andiman
**date:
************************************************************/
INT8U BSP_GPIO_OutputPinRead(GPIO_TypeDef* GPIOx,INT16U PINx)
{
	return ( GPIO_ReadOutputDataBit(GPIOx, PINx));
 800d5fc:	f7fb ba84 	b.w	8008b08 <GPIO_ReadOutputDataBit>

0800d600 <BSP_OS_SemCreate>:
*/

CPU_BOOLEAN  BSP_OS_SemCreate (BSP_OS_SEM       *p_sem,
                               BSP_OS_SEM_VAL    sem_val,
                               CPU_CHAR         *p_sem_name)
{
 800d600:	b510      	push	{r4, lr}
 800d602:	4614      	mov	r4, r2
 800d604:	b082      	sub	sp, #8
    OS_ERR     err;


    OSSemCreate((OS_SEM    *)p_sem,
 800d606:	460a      	mov	r2, r1
 800d608:	f10d 0306 	add.w	r3, sp, #6
 800d60c:	4621      	mov	r1, r4
 800d60e:	f7f8 fc01 	bl	8005e14 <OSSemCreate>
                (CPU_CHAR  *)p_sem_name,
                (OS_SEM_CTR )sem_val,
                (OS_ERR    *)&err);

    if (err != OS_ERR_NONE) {
        return (DEF_FAIL);
 800d612:	f8bd 0006 	ldrh.w	r0, [sp, #6]
    }

    return (DEF_OK);
}
 800d616:	fab0 f080 	clz	r0, r0
 800d61a:	0940      	lsrs	r0, r0, #5
 800d61c:	b002      	add	sp, #8
 800d61e:	bd10      	pop	{r4, pc}

0800d620 <BSP_OS_SemWait>:
*********************************************************************************************************
*/

CPU_BOOLEAN  BSP_OS_SemWait (BSP_OS_SEM  *p_sem,
                             CPU_INT32U   dly_ms)
{
 800d620:	b510      	push	{r4, lr}
    CPU_INT32U  dly_ticks;


    dly_ticks  = ((dly_ms * DEF_TIME_NBR_mS_PER_SEC) / OSCfg_TickRate_Hz);

    OSSemPend((OS_SEM *)p_sem,
 800d622:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800d626:	fb03 f101 	mul.w	r1, r3, r1
{
    OS_ERR      err;
    CPU_INT32U  dly_ticks;


    dly_ticks  = ((dly_ms * DEF_TIME_NBR_mS_PER_SEC) / OSCfg_TickRate_Hz);
 800d62a:	4b09      	ldr	r3, [pc, #36]	; (800d650 <BSP_OS_SemWait+0x30>)
*********************************************************************************************************
*/

CPU_BOOLEAN  BSP_OS_SemWait (BSP_OS_SEM  *p_sem,
                             CPU_INT32U   dly_ms)
{
 800d62c:	b084      	sub	sp, #16
    CPU_INT32U  dly_ticks;


    dly_ticks  = ((dly_ms * DEF_TIME_NBR_mS_PER_SEC) / OSCfg_TickRate_Hz);

    OSSemPend((OS_SEM *)p_sem,
 800d62e:	681c      	ldr	r4, [r3, #0]
 800d630:	f10d 020e 	add.w	r2, sp, #14
 800d634:	2300      	movs	r3, #0
 800d636:	9200      	str	r2, [sp, #0]
 800d638:	fbb1 f1f4 	udiv	r1, r1, r4
 800d63c:	461a      	mov	r2, r3
 800d63e:	f7f8 fccf 	bl	8005fe0 <OSSemPend>
              (OS_OPT  )OS_OPT_PEND_BLOCKING,
              (CPU_TS  )0,
              (OS_ERR *)&err);

    if (err != OS_ERR_NONE) {
       return (DEF_FAIL);
 800d642:	f8bd 000e 	ldrh.w	r0, [sp, #14]
    }

    return (DEF_OK);
}
 800d646:	fab0 f080 	clz	r0, r0
 800d64a:	0940      	lsrs	r0, r0, #5
 800d64c:	b004      	add	sp, #16
 800d64e:	bd10      	pop	{r4, pc}
 800d650:	080160cc 	.word	0x080160cc

0800d654 <BSP_OS_SemPost>:
* Note(s)     : none.
*********************************************************************************************************
*/

CPU_BOOLEAN  BSP_OS_SemPost (BSP_OS_SEM *p_sem)
{
 800d654:	b500      	push	{lr}
 800d656:	b083      	sub	sp, #12
    OS_ERR  err;


    OSSemPost((OS_SEM *)p_sem,
 800d658:	f10d 0206 	add.w	r2, sp, #6
 800d65c:	2100      	movs	r1, #0
 800d65e:	f7f8 fe97 	bl	8006390 <OSSemPost>
              (OS_OPT  )OS_OPT_POST_1,
              (OS_ERR *)&err);

    if (err != OS_ERR_NONE) {
        return (DEF_FAIL);
 800d662:	f8bd 0006 	ldrh.w	r0, [sp, #6]
    }

    return (DEF_OK);
}
 800d666:	fab0 f080 	clz	r0, r0
 800d66a:	0940      	lsrs	r0, r0, #5
 800d66c:	b003      	add	sp, #12
 800d66e:	f85d fb04 	ldr.w	pc, [sp], #4
 800d672:	bf00      	nop

0800d674 <BSP_OS_TimeDlyMs>:
    CPU_INT16U  ms;
    CPU_INT16U  sec;
    OS_ERR      err;


    if (dly_ms > 10000u) {                                       /* Limit delays to 10 seconds.                        */
 800d674:	f242 7310 	movw	r3, #10000	; 0x2710
*
*********************************************************************************************************
*/

void   BSP_OS_TimeDlyMs (CPU_INT32U  dly_ms)
{
 800d678:	b500      	push	{lr}
    CPU_INT16U  ms;
    CPU_INT16U  sec;
    OS_ERR      err;


    if (dly_ms > 10000u) {                                       /* Limit delays to 10 seconds.                        */
 800d67a:	4298      	cmp	r0, r3
*
*********************************************************************************************************
*/

void   BSP_OS_TimeDlyMs (CPU_INT32U  dly_ms)
{
 800d67c:	b085      	sub	sp, #20
    CPU_INT16U  ms;
    CPU_INT16U  sec;
    OS_ERR      err;


    if (dly_ms > 10000u) {                                       /* Limit delays to 10 seconds.                        */
 800d67e:	d80f      	bhi.n	800d6a0 <BSP_OS_TimeDlyMs+0x2c>
        dly_ms = 10000u;
    }

    if (dly_ms >= 1000u) {
 800d680:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 800d684:	d20f      	bcs.n	800d6a6 <BSP_OS_TimeDlyMs+0x32>
 800d686:	4603      	mov	r3, r0
        ms  = dly_ms / 1000u;
        sec = dly_ms % 1000u;
    } else {
        ms  = dly_ms;
        sec = 0u;
 800d688:	2200      	movs	r2, #0
    }


    OSTimeDlyHMSM((CPU_INT16U) 0u,
 800d68a:	2100      	movs	r1, #0
 800d68c:	f10d 000e 	add.w	r0, sp, #14
 800d690:	9001      	str	r0, [sp, #4]
 800d692:	9100      	str	r1, [sp, #0]
 800d694:	4608      	mov	r0, r1
 800d696:	f7fa fa35 	bl	8007b04 <OSTimeDlyHMSM>
                  (CPU_INT16U) 0u,
                  (CPU_INT16U) sec,
                  (CPU_INT32U) ms,
                  (OS_OPT    ) OS_OPT_TIME_HMSM_STRICT,
                  (OS_ERR   *)&err);
}
 800d69a:	b005      	add	sp, #20
 800d69c:	f85d fb04 	ldr.w	pc, [sp], #4
 800d6a0:	230a      	movs	r3, #10
 800d6a2:	2200      	movs	r2, #0
 800d6a4:	e7f1      	b.n	800d68a <BSP_OS_TimeDlyMs+0x16>
 800d6a6:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800d6aa:	fbb0 f3f2 	udiv	r3, r0, r2
 800d6ae:	fb02 0213 	mls	r2, r2, r3, r0

    if (dly_ms > 10000u) {                                       /* Limit delays to 10 seconds.                        */
        dly_ms = 10000u;
    }

    if (dly_ms >= 1000u) {
 800d6b2:	b292      	uxth	r2, r2
 800d6b4:	e7e9      	b.n	800d68a <BSP_OS_TimeDlyMs+0x16>
 800d6b6:	bf00      	nop

0800d6b8 <BSP_OS_Q_Creat>:
**return:
**autor:  andiman
**date:
************************************************************/
int BSP_OS_Q_Creat(OS_Q *bsp_os_q,char    *p_name,INT16U   max_qty)
{
 800d6b8:	b500      	push	{lr}
 800d6ba:	b083      	sub	sp, #12
	OS_ERR     err;

	OSQCreate (bsp_os_q,p_name,max_qty,&err);
 800d6bc:	f10d 0306 	add.w	r3, sp, #6
 800d6c0:	f7f8 f8a0 	bl	8005804 <OSQCreate>
	if( err != OS_ERR_NONE)
 800d6c4:	f8bd 0006 	ldrh.w	r0, [sp, #6]
 800d6c8:	3000      	adds	r0, #0
 800d6ca:	bf18      	it	ne
 800d6cc:	2001      	movne	r0, #1

		return (-1);
	}

	return 0;
}
 800d6ce:	4240      	negs	r0, r0
 800d6d0:	b003      	add	sp, #12
 800d6d2:	f85d fb04 	ldr.w	pc, [sp], #4
 800d6d6:	bf00      	nop

0800d6d8 <BSP_OS_Q_Post>:
**return:
**autor:  andiman
**date:
************************************************************/
int BSP_OS_Q_Post(OS_Q *bsp_os_q,void *buff,	INT16U buffsize)
{
 800d6d8:	b500      	push	{lr}
 800d6da:	b085      	sub	sp, #20
	OS_ERR     err;

	OSQPost(bsp_os_q, buff, buffsize,OS_OPT_POST_ALL, &err);
 800d6dc:	f10d 030e 	add.w	r3, sp, #14
 800d6e0:	9300      	str	r3, [sp, #0]
 800d6e2:	f44f 7300 	mov.w	r3, #512	; 0x200
 800d6e6:	f7f8 fb49 	bl	8005d7c <OSQPost>
	if( err != OS_ERR_NONE)
 800d6ea:	f8bd 000e 	ldrh.w	r0, [sp, #14]
 800d6ee:	3000      	adds	r0, #0
 800d6f0:	bf18      	it	ne
 800d6f2:	2001      	movne	r0, #1

		return (-1);
	}

	return 0;
}
 800d6f4:	4240      	negs	r0, r0
 800d6f6:	b005      	add	sp, #20
 800d6f8:	f85d fb04 	ldr.w	pc, [sp], #4

0800d6fc <BSP_OS_Q_Block_Pend>:
**return:
**autor:  andiman
**date:
************************************************************/
int BSP_OS_Q_Block_Pend(OS_Q *bsp_os_q,void *buff,INT16U *buffsize,INT32U timeout)
{
 800d6fc:	b5f0      	push	{r4, r5, r6, r7, lr}
 800d6fe:	4615      	mov	r5, r2
 800d700:	461e      	mov	r6, r3
 800d702:	b085      	sub	sp, #20
	OS_ERR     err;
	CPU_TS       ts;
	void *pbuff;

	pbuff = OSQPend(bsp_os_q, timeout, OS_OPT_PEND_BLOCKING, buffsize, &ts,&err);
 800d704:	f10d 040a 	add.w	r4, sp, #10
 800d708:	aa03      	add	r2, sp, #12
 800d70a:	e88d 0014 	stmia.w	sp, {r2, r4}
**return:
**autor:  andiman
**date:
************************************************************/
int BSP_OS_Q_Block_Pend(OS_Q *bsp_os_q,void *buff,INT16U *buffsize,INT32U timeout)
{
 800d70e:	460f      	mov	r7, r1
	OS_ERR     err;
	CPU_TS       ts;
	void *pbuff;

	pbuff = OSQPend(bsp_os_q, timeout, OS_OPT_PEND_BLOCKING, buffsize, &ts,&err);
 800d710:	462b      	mov	r3, r5
 800d712:	4631      	mov	r1, r6
 800d714:	2200      	movs	r2, #0
 800d716:	f7f8 f8eb 	bl	80058f0 <OSQPend>
	
	if( err != OS_ERR_NONE)
 800d71a:	f8bd 400a 	ldrh.w	r4, [sp, #10]
 800d71e:	b93c      	cbnz	r4, 800d730 <BSP_OS_Q_Block_Pend+0x34>
		// 告警日志


		return (-1);
	}
	memcpy(buff,pbuff,*buffsize);
 800d720:	4601      	mov	r1, r0
 800d722:	882a      	ldrh	r2, [r5, #0]
 800d724:	4638      	mov	r0, r7
 800d726:	f007 fb14 	bl	8014d52 <memcpy>
	return 0;
 800d72a:	4620      	mov	r0, r4
}
 800d72c:	b005      	add	sp, #20
 800d72e:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if( err != OS_ERR_NONE)
	{
		// 告警日志


		return (-1);
 800d730:	f04f 30ff 	mov.w	r0, #4294967295
 800d734:	e7fa      	b.n	800d72c <BSP_OS_Q_Block_Pend+0x30>
 800d736:	bf00      	nop

0800d738 <BSP_OS_Q_Flush>:
**return:
**autor:  andiman
**date:
************************************************************/
void BSP_OS_Q_Flush(OS_Q *bsp_os_q)
{
 800d738:	b500      	push	{lr}
 800d73a:	b083      	sub	sp, #12
	OS_ERR     err;

	OSQFlush(bsp_os_q,&err);
 800d73c:	f10d 0106 	add.w	r1, sp, #6
 800d740:	f7f8 f8aa 	bl	8005898 <OSQFlush>
}
 800d744:	b003      	add	sp, #12
 800d746:	f85d fb04 	ldr.w	pc, [sp], #4
 800d74a:	bf00      	nop

0800d74c <BSP_OS_Q_Del>:
**return:
**autor:  andiman
**date:
************************************************************/
int BSP_OS_Q_Del(OS_Q *bsp_os_q)
{
 800d74c:	b500      	push	{lr}
 800d74e:	b083      	sub	sp, #12
	OS_ERR     err;
	CPU_TS       ts;

	OSQDel(bsp_os_q,OS_OPT_DEL_NO_PEND,&err);
 800d750:	f10d 0206 	add.w	r2, sp, #6
 800d754:	2100      	movs	r1, #0
 800d756:	f7f8 fa07 	bl	8005b68 <OSQDel>
	if( err != OS_ERR_NONE)
 800d75a:	f8bd 0006 	ldrh.w	r0, [sp, #6]
 800d75e:	3000      	adds	r0, #0
 800d760:	bf18      	it	ne
 800d762:	2001      	movne	r0, #1

		return (-1);
	}

	return 0;
}
 800d764:	4240      	negs	r0, r0
 800d766:	b003      	add	sp, #12
 800d768:	f85d fb04 	ldr.w	pc, [sp], #4

0800d76c <BSP_OS_Q_NoBlock_Pend>:
**return:
**autor:  andiman
**date:
************************************************************/
int BSP_OS_Q_NoBlock_Pend(OS_Q *bsp_os_q,void *buff,INT16U *buffsize)
{
 800d76c:	b510      	push	{r4, lr}
 800d76e:	4614      	mov	r4, r2
 800d770:	b084      	sub	sp, #16
	OS_ERR     err;
	CPU_TS       ts;
	void *pbuff;

	buff = OSQPend(bsp_os_q, 0, OS_OPT_PEND_NON_BLOCKING, buffsize, &ts,&err);
 800d772:	f10d 010a 	add.w	r1, sp, #10
 800d776:	aa03      	add	r2, sp, #12
 800d778:	4623      	mov	r3, r4
 800d77a:	9101      	str	r1, [sp, #4]
 800d77c:	9200      	str	r2, [sp, #0]
 800d77e:	2100      	movs	r1, #0
 800d780:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 800d784:	f7f8 f8b4 	bl	80058f0 <OSQPend>
	memcpy(buff,pbuff,*buffsize);
 800d788:	8822      	ldrh	r2, [r4, #0]
 800d78a:	2100      	movs	r1, #0
 800d78c:	f007 fae1 	bl	8014d52 <memcpy>
	if( err != OS_ERR_NONE)
 800d790:	f8bd 000a 	ldrh.w	r0, [sp, #10]
 800d794:	3000      	adds	r0, #0
 800d796:	bf18      	it	ne
 800d798:	2001      	movne	r0, #1

		return (-1);
	}

	return 0;
}
 800d79a:	4240      	negs	r0, r0
 800d79c:	b004      	add	sp, #16
 800d79e:	bd10      	pop	{r4, pc}

0800d7a0 <BSP_OS_Sem_Creat>:
**return:
**autor:  andiman
**date:
************************************************************/
int BSP_OS_Sem_Creat(OS_SEM *bsp_os_sem,char    *p_name,INT32U   init_value)
{
 800d7a0:	b500      	push	{lr}
 800d7a2:	b083      	sub	sp, #12
	OS_ERR     err;

	OSSemCreate(bsp_os_sem,p_name,(OS_SEM_CTR)init_value,&err);
 800d7a4:	f10d 0306 	add.w	r3, sp, #6
 800d7a8:	f7f8 fb34 	bl	8005e14 <OSSemCreate>
	if( err != OS_ERR_NONE)
 800d7ac:	f8bd 0006 	ldrh.w	r0, [sp, #6]
 800d7b0:	3000      	adds	r0, #0
 800d7b2:	bf18      	it	ne
 800d7b4:	2001      	movne	r0, #1

		return (-1);
	}

	return 0;
}
 800d7b6:	4240      	negs	r0, r0
 800d7b8:	b003      	add	sp, #12
 800d7ba:	f85d fb04 	ldr.w	pc, [sp], #4
 800d7be:	bf00      	nop

0800d7c0 <BSP_OS_Sem_Post>:
**return:
**autor:  andiman
**date:
************************************************************/
int BSP_OS_Sem_Post(OS_SEM *bsp_os_sem)
{
 800d7c0:	b500      	push	{lr}
 800d7c2:	b083      	sub	sp, #12
	OS_ERR     err;

	OSSemPost(bsp_os_sem,OS_OPT_POST_ALL,&err);
 800d7c4:	f10d 0206 	add.w	r2, sp, #6
 800d7c8:	f44f 7100 	mov.w	r1, #512	; 0x200
 800d7cc:	f7f8 fde0 	bl	8006390 <OSSemPost>
	if( err != OS_ERR_NONE)
 800d7d0:	f8bd 0006 	ldrh.w	r0, [sp, #6]
 800d7d4:	3000      	adds	r0, #0
 800d7d6:	bf18      	it	ne
 800d7d8:	2001      	movne	r0, #1

		return (-1);
	}

	return 0;
}
 800d7da:	4240      	negs	r0, r0
 800d7dc:	b003      	add	sp, #12
 800d7de:	f85d fb04 	ldr.w	pc, [sp], #4
 800d7e2:	bf00      	nop

0800d7e4 <BSP_OS_Sem_Pend>:
**return:
**autor:  andiman
**date:
************************************************************/
int BSP_OS_Sem_Pend(OS_SEM *bsp_os_sem,INT32U timeout_ms)
{
 800d7e4:	b500      	push	{lr}
 800d7e6:	b085      	sub	sp, #20
	OS_ERR     err;
	CPU_TS       ts;

	OSSemPend(bsp_os_sem,timeout_ms,OS_OPT_PEND_BLOCKING,&ts,&err);
 800d7e8:	f10d 030a 	add.w	r3, sp, #10
 800d7ec:	9300      	str	r3, [sp, #0]
 800d7ee:	2200      	movs	r2, #0
 800d7f0:	ab03      	add	r3, sp, #12
 800d7f2:	f7f8 fbf5 	bl	8005fe0 <OSSemPend>
	if( err != OS_ERR_NONE)
 800d7f6:	f8bd 000a 	ldrh.w	r0, [sp, #10]
 800d7fa:	3000      	adds	r0, #0
 800d7fc:	bf18      	it	ne
 800d7fe:	2001      	movne	r0, #1

		return (-1);
	}

	return 0;
}
 800d800:	4240      	negs	r0, r0
 800d802:	b005      	add	sp, #20
 800d804:	f85d fb04 	ldr.w	pc, [sp], #4

0800d808 <BSP_OS_Sem_Del>:
**return:
**autor:  andiman
**date:
************************************************************/
int BSP_OS_Sem_Del(OS_SEM *bsp_os_sem)
{
 800d808:	b500      	push	{lr}
 800d80a:	b083      	sub	sp, #12
	OS_ERR     err;
	CPU_TS       ts;

	OSSemDel(bsp_os_sem,OS_OPT_DEL_ALWAYS,&err);
 800d80c:	f10d 0206 	add.w	r2, sp, #6
 800d810:	2101      	movs	r1, #1
 800d812:	f7f8 fb3f 	bl	8005e94 <OSSemDel>
	if( err != OS_ERR_NONE)
 800d816:	f8bd 0006 	ldrh.w	r0, [sp, #6]
 800d81a:	3000      	adds	r0, #0
 800d81c:	bf18      	it	ne
 800d81e:	2001      	movne	r0, #1

		return (-1);
	}

	return 0;
}
 800d820:	4240      	negs	r0, r0
 800d822:	b003      	add	sp, #12
 800d824:	f85d fb04 	ldr.w	pc, [sp], #4

0800d828 <BSP_UART_PortClkSwitch>:
**autor:  andiman
**date:
************************************************************/
void BSP_UART_PortClkSwitch(USART_TypeDef* USARTx,INT8U switch_set)
{
	switch( (INT32U)USARTx )
 800d828:	4b17      	ldr	r3, [pc, #92]	; (800d888 <BSP_UART_PortClkSwitch+0x60>)
 800d82a:	4298      	cmp	r0, r3
 800d82c:	d020      	beq.n	800d870 <BSP_UART_PortClkSwitch+0x48>
 800d82e:	d90b      	bls.n	800d848 <BSP_UART_PortClkSwitch+0x20>
 800d830:	4b16      	ldr	r3, [pc, #88]	; (800d88c <BSP_UART_PortClkSwitch+0x64>)
 800d832:	4298      	cmp	r0, r3
 800d834:	d014      	beq.n	800d860 <BSP_UART_PortClkSwitch+0x38>
 800d836:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800d83a:	4298      	cmp	r0, r3
 800d83c:	d020      	beq.n	800d880 <BSP_UART_PortClkSwitch+0x58>
 800d83e:	f5a3 4344 	sub.w	r3, r3, #50176	; 0xc400
 800d842:	4298      	cmp	r0, r3
 800d844:	d00f      	beq.n	800d866 <BSP_UART_PortClkSwitch+0x3e>
 800d846:	4770      	bx	lr
 800d848:	f5a3 6300 	sub.w	r3, r3, #2048	; 0x800
 800d84c:	4298      	cmp	r0, r3
 800d84e:	d013      	beq.n	800d878 <BSP_UART_PortClkSwitch+0x50>
 800d850:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800d854:	4298      	cmp	r0, r3
 800d856:	d10a      	bne.n	800d86e <BSP_UART_PortClkSwitch+0x46>
		case (INT32U)USART2:
			RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, switch_set);	
			break;

		case (INT32U)USART3:
			RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, switch_set);	
 800d858:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 800d85c:	f7fb bafe 	b.w	8008e5c <RCC_APB1PeriphClockCmd>
void BSP_UART_PortClkSwitch(USART_TypeDef* USARTx,INT8U switch_set)
{
	switch( (INT32U)USARTx )
	{
		case (INT32U)USART1:
			RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, switch_set);	
 800d860:	2010      	movs	r0, #16
 800d862:	f7fb bb09 	b.w	8008e78 <RCC_APB2PeriphClockCmd>
		case (INT32U)UART4:
			RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, switch_set);	
			break;

		case (INT32U)UART5:
			RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART5, switch_set);	
 800d866:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 800d86a:	f7fb baf7 	b.w	8008e5c <RCC_APB1PeriphClockCmd>
 800d86e:	4770      	bx	lr
		case (INT32U)USART3:
			RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, switch_set);	
			break;

		case (INT32U)UART4:
			RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, switch_set);	
 800d870:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 800d874:	f7fb baf2 	b.w	8008e5c <RCC_APB1PeriphClockCmd>
		case (INT32U)USART1:
			RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, switch_set);	
			break;

		case (INT32U)USART2:
			RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, switch_set);	
 800d878:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 800d87c:	f7fb baee 	b.w	8008e5c <RCC_APB1PeriphClockCmd>
		case (INT32U)UART5:
			RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART5, switch_set);	
			break;

		case (INT32U)USART6:
			RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART6, switch_set);	
 800d880:	2020      	movs	r0, #32
 800d882:	f7fb baf9 	b.w	8008e78 <RCC_APB2PeriphClockCmd>
 800d886:	bf00      	nop
 800d888:	40004c00 	.word	0x40004c00
 800d88c:	40011000 	.word	0x40011000

0800d890 <BSP_UART_Init>:
**return:
**autor:  andiman
**date:
************************************************************/
void BSP_UART_Init(str_UART_GPIO_HARD UART_GPIO_HARD)
{
 800d890:	b084      	sub	sp, #16
 800d892:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800d896:	ad08      	add	r5, sp, #32
	BSP_GPIO_PortClkSwitch(UART_GPIO_HARD.GPIOx[UART_GPIO_TX_INDEX],ENABLE);
	BSP_GPIO_PortClkSwitch(UART_GPIO_HARD.GPIOx[UART_GPIO_RX_INDEX],ENABLE);
	GPIO_Init(UART_GPIO_HARD.GPIOx[UART_GPIO_TX_INDEX],&UART_GPIO_HARD.GPIO_InitStruct[UART_GPIO_TX_INDEX]);
	GPIO_Init(UART_GPIO_HARD.GPIOx[UART_GPIO_RX_INDEX],&UART_GPIO_HARD.GPIO_InitStruct[UART_GPIO_RX_INDEX]);

	BSP_UART_PortClkSwitch(UART_GPIO_HARD.USARTx,ENABLE);
 800d898:	462e      	mov	r6, r5
**return:
**autor:  andiman
**date:
************************************************************/
void BSP_UART_Init(str_UART_GPIO_HARD UART_GPIO_HARD)
{
 800d89a:	ac08      	add	r4, sp, #32
 800d89c:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	INT16U	GPIO_PinSource;
	INT8U i,ii;
	INT8U	GPIO_AF;
	
	BSP_GPIO_PortClkSwitch(UART_GPIO_HARD.GPIOx[UART_GPIO_TX_INDEX],ENABLE);
 800d8a0:	2101      	movs	r1, #1
 800d8a2:	f7ff fe65 	bl	800d570 <BSP_GPIO_PortClkSwitch>
	BSP_GPIO_PortClkSwitch(UART_GPIO_HARD.GPIOx[UART_GPIO_RX_INDEX],ENABLE);
	GPIO_Init(UART_GPIO_HARD.GPIOx[UART_GPIO_TX_INDEX],&UART_GPIO_HARD.GPIO_InitStruct[UART_GPIO_TX_INDEX]);
 800d8a6:	af08      	add	r7, sp, #32
	INT16U	GPIO_PinSource;
	INT8U i,ii;
	INT8U	GPIO_AF;
	
	BSP_GPIO_PortClkSwitch(UART_GPIO_HARD.GPIOx[UART_GPIO_TX_INDEX],ENABLE);
	BSP_GPIO_PortClkSwitch(UART_GPIO_HARD.GPIOx[UART_GPIO_RX_INDEX],ENABLE);
 800d8a8:	2101      	movs	r1, #1
 800d8aa:	9809      	ldr	r0, [sp, #36]	; 0x24
 800d8ac:	f7ff fe60 	bl	800d570 <BSP_GPIO_PortClkSwitch>
	GPIO_Init(UART_GPIO_HARD.GPIOx[UART_GPIO_TX_INDEX],&UART_GPIO_HARD.GPIO_InitStruct[UART_GPIO_TX_INDEX]);
 800d8b0:	f857 0b10 	ldr.w	r0, [r7], #16
 800d8b4:	a90a      	add	r1, sp, #40	; 0x28
 800d8b6:	f7fb f8af 	bl	8008a18 <GPIO_Init>
	GPIO_Init(UART_GPIO_HARD.GPIOx[UART_GPIO_RX_INDEX],&UART_GPIO_HARD.GPIO_InitStruct[UART_GPIO_RX_INDEX]);
 800d8ba:	4639      	mov	r1, r7
 800d8bc:	9809      	ldr	r0, [sp, #36]	; 0x24
 800d8be:	f7fb f8ab 	bl	8008a18 <GPIO_Init>

	BSP_UART_PortClkSwitch(UART_GPIO_HARD.USARTx,ENABLE);
 800d8c2:	980e      	ldr	r0, [sp, #56]	; 0x38
 800d8c4:	2101      	movs	r1, #1
 800d8c6:	f7ff ffaf 	bl	800d828 <BSP_UART_PortClkSwitch>
				GPIO_PinSource = ii;
				break;
			}
		}

		if(UART_GPIO_HARD.USARTx == USART1)
 800d8ca:	f8df 9088 	ldr.w	r9, [pc, #136]	; 800d954 <BSP_UART_Init+0xc4>
 800d8ce:	980e      	ldr	r0, [sp, #56]	; 0x38

	for(i=0;i<2;i++)
	{
		for(ii=0;ii<16;ii++)
		{
			if(UART_GPIO_HARD.GPIO_InitStruct[i].GPIO_Pin & (1<<ii))
 800d8d0:	2401      	movs	r4, #1
 800d8d2:	68a9      	ldr	r1, [r5, #8]
**return:
**autor:  andiman
**date:
************************************************************/
void BSP_UART_Init(str_UART_GPIO_HARD UART_GPIO_HARD)
{
 800d8d4:	2300      	movs	r3, #0

	for(i=0;i<2;i++)
	{
		for(ii=0;ii<16;ii++)
		{
			if(UART_GPIO_HARD.GPIO_InitStruct[i].GPIO_Pin & (1<<ii))
 800d8d6:	fa04 f203 	lsl.w	r2, r4, r3
 800d8da:	420a      	tst	r2, r1
 800d8dc:	fa5f fe83 	uxtb.w	lr, r3
 800d8e0:	f103 0301 	add.w	r3, r3, #1
 800d8e4:	d126      	bne.n	800d934 <BSP_UART_Init+0xa4>

	BSP_UART_PortClkSwitch(UART_GPIO_HARD.USARTx,ENABLE);

	for(i=0;i<2;i++)
	{
		for(ii=0;ii<16;ii++)
 800d8e6:	2b10      	cmp	r3, #16
 800d8e8:	d1f5      	bne.n	800d8d6 <BSP_UART_Init+0x46>
				GPIO_PinSource = ii;
				break;
			}
		}

		if(UART_GPIO_HARD.USARTx == USART1)
 800d8ea:	4548      	cmp	r0, r9
 800d8ec:	d026      	beq.n	800d93c <BSP_UART_Init+0xac>
		{
			GPIO_AF = GPIO_AF_USART1;
		}
		else if(UART_GPIO_HARD.USARTx == USART2)
 800d8ee:	4b18      	ldr	r3, [pc, #96]	; (800d950 <BSP_UART_Init+0xc0>)
 800d8f0:	4298      	cmp	r0, r3
 800d8f2:	d023      	beq.n	800d93c <BSP_UART_Init+0xac>
		{
			GPIO_AF = GPIO_AF_USART2;
		}
		else if(UART_GPIO_HARD.USARTx == USART3)
 800d8f4:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800d8f8:	4298      	cmp	r0, r3
 800d8fa:	d01f      	beq.n	800d93c <BSP_UART_Init+0xac>
		{
			GPIO_AF = GPIO_AF_USART3;
		}
		else if(UART_GPIO_HARD.USARTx == UART4)
 800d8fc:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800d900:	4298      	cmp	r0, r3
 800d902:	d022      	beq.n	800d94a <BSP_UART_Init+0xba>
		{
			GPIO_AF = GPIO_AF_UART4;
		}
		else if(UART_GPIO_HARD.USARTx == UART5)
 800d904:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800d908:	4298      	cmp	r0, r3
 800d90a:	d01e      	beq.n	800d94a <BSP_UART_Init+0xba>
		{
			GPIO_AF = GPIO_AF_UART5;
		}
		else if(UART_GPIO_HARD.USARTx == USART6)
 800d90c:	f503 4344 	add.w	r3, r3, #50176	; 0xc400
 800d910:	4298      	cmp	r0, r3
 800d912:	d01a      	beq.n	800d94a <BSP_UART_Init+0xba>
 800d914:	3508      	adds	r5, #8
	GPIO_Init(UART_GPIO_HARD.GPIOx[UART_GPIO_TX_INDEX],&UART_GPIO_HARD.GPIO_InitStruct[UART_GPIO_TX_INDEX]);
	GPIO_Init(UART_GPIO_HARD.GPIOx[UART_GPIO_RX_INDEX],&UART_GPIO_HARD.GPIO_InitStruct[UART_GPIO_RX_INDEX]);

	BSP_UART_PortClkSwitch(UART_GPIO_HARD.USARTx,ENABLE);

	for(i=0;i<2;i++)
 800d916:	42af      	cmp	r7, r5
 800d918:	f106 0604 	add.w	r6, r6, #4
 800d91c:	d1d9      	bne.n	800d8d2 <BSP_UART_Init+0x42>
		
		GPIO_PinAFConfig(UART_GPIO_HARD.GPIOx[i], GPIO_PinSource, GPIO_AF);
	}

	
	USART_Init(UART_GPIO_HARD.USARTx,&UART_GPIO_HARD.USART_InitStruct);
 800d91e:	a90f      	add	r1, sp, #60	; 0x3c
 800d920:	f7fb fbe8 	bl	80090f4 <USART_Init>

	//USART_ITConfig(UART_GPIO_HARD.USARTx, USART_IT_RXNE, ENABLE);
	USART_Cmd(UART_GPIO_HARD.USARTx, ENABLE);
 800d924:	980e      	ldr	r0, [sp, #56]	; 0x38
 800d926:	2101      	movs	r1, #1
 800d928:	f7fb fc6c 	bl	8009204 <USART_Cmd>
}
 800d92c:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800d930:	b004      	add	sp, #16
 800d932:	4770      	bx	lr
				GPIO_PinSource = ii;
				break;
			}
		}

		if(UART_GPIO_HARD.USARTx == USART1)
 800d934:	4548      	cmp	r0, r9
	{
		for(ii=0;ii<16;ii++)
		{
			if(UART_GPIO_HARD.GPIO_InitStruct[i].GPIO_Pin & (1<<ii))
			{
				GPIO_PinSource = ii;
 800d936:	fa1f f88e 	uxth.w	r8, lr
				break;
			}
		}

		if(UART_GPIO_HARD.USARTx == USART1)
 800d93a:	d1d8      	bne.n	800d8ee <BSP_UART_Init+0x5e>
		{
			GPIO_AF = GPIO_AF_USART1;
 800d93c:	2207      	movs	r2, #7
			GPIO_AF = GPIO_AF_USART6;
		}
		else
			continue;
		
		GPIO_PinAFConfig(UART_GPIO_HARD.GPIOx[i], GPIO_PinSource, GPIO_AF);
 800d93e:	6830      	ldr	r0, [r6, #0]
 800d940:	4641      	mov	r1, r8
 800d942:	f7fb f8fb 	bl	8008b3c <GPIO_PinAFConfig>
 800d946:	980e      	ldr	r0, [sp, #56]	; 0x38
 800d948:	e7e4      	b.n	800d914 <BSP_UART_Init+0x84>
		{
			GPIO_AF = GPIO_AF_USART3;
		}
		else if(UART_GPIO_HARD.USARTx == UART4)
		{
			GPIO_AF = GPIO_AF_UART4;
 800d94a:	2208      	movs	r2, #8
 800d94c:	e7f7      	b.n	800d93e <BSP_UART_Init+0xae>
 800d94e:	bf00      	nop
 800d950:	40004400 	.word	0x40004400
 800d954:	40011000 	.word	0x40011000

0800d958 <BSP_UART_Send>:
**return:
**autor:  andiman
**date:
************************************************************/
void BSP_UART_Send(USART_TypeDef* USARTx, INT8U *sendbuff,	INT32U len)
{
 800d958:	b570      	push	{r4, r5, r6, lr}
 800d95a:	460d      	mov	r5, r1
 800d95c:	188e      	adds	r6, r1, r2
	while(len--)
 800d95e:	42b5      	cmp	r5, r6
**return:
**autor:  andiman
**date:
************************************************************/
void BSP_UART_Send(USART_TypeDef* USARTx, INT8U *sendbuff,	INT32U len)
{
 800d960:	4604      	mov	r4, r0
	while(len--)
 800d962:	d00c      	beq.n	800d97e <BSP_UART_Send+0x26>
	{
		USART_SendData(USARTx,*sendbuff++);
 800d964:	f815 1b01 	ldrb.w	r1, [r5], #1
 800d968:	4620      	mov	r0, r4
 800d96a:	f7fb fc7f 	bl	800926c <USART_SendData>
		while (USART_GetFlagStatus(USARTx, USART_FLAG_TC) == RESET);
 800d96e:	2140      	movs	r1, #64	; 0x40
 800d970:	4620      	mov	r0, r4
 800d972:	f7fb fd3d 	bl	80093f0 <USART_GetFlagStatus>
 800d976:	2800      	cmp	r0, #0
 800d978:	d0f9      	beq.n	800d96e <BSP_UART_Send+0x16>
**autor:  andiman
**date:
************************************************************/
void BSP_UART_Send(USART_TypeDef* USARTx, INT8U *sendbuff,	INT32U len)
{
	while(len--)
 800d97a:	42b5      	cmp	r5, r6
 800d97c:	d1f2      	bne.n	800d964 <BSP_UART_Send+0xc>
	{
		USART_SendData(USARTx,*sendbuff++);
		while (USART_GetFlagStatus(USARTx, USART_FLAG_TC) == RESET);
	}
}
 800d97e:	bd70      	pop	{r4, r5, r6, pc}

0800d980 <BSP_UART_RCV>:

INT16U BSP_UART_RCV(USART_TypeDef * USARTx)
{
	//while (USART_GetFlagStatus(USARTx, USART_FLAG_RXNE) == RESET);
	return USART_ReceiveData(USARTx);
 800d980:	f7fb bc78 	b.w	8009274 <USART_ReceiveData>

0800d984 <BSP_UART_TST>:
}

INT16U BSP_UART_TST(USART_TypeDef * USARTx)
{
 800d984:	b508      	push	{r3, lr}
	if (USART_GetFlagStatus(USARTx, USART_FLAG_RXNE) == RESET)
 800d986:	2120      	movs	r1, #32
 800d988:	f7fb fd32 	bl	80093f0 <USART_GetFlagStatus>
	{
		return 0;
	}

	return 1;
}
 800d98c:	3000      	adds	r0, #0
 800d98e:	bf18      	it	ne
 800d990:	2001      	movne	r0, #1
 800d992:	bd08      	pop	{r3, pc}

0800d994 <delete_char.part.0>:
static const char erase_seq[] = "\b \b";	/* erase sequence */
static const char   tab_seq[] = "        ";	/* used to expand TABs */

char console_buffer[SHELL_SYS_CBSIZE + 1];	/* console I/O buffer	*/

static char *delete_char (char *buffer, char *p, int *colp, int *np, int plen)
 800d994:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800d998:	460c      	mov	r4, r1
	char *s;

	if (*np == 0)
		return p;

	if (*(--p) == '\t') {		/* will retype the whole line */
 800d99a:	f811 1c01 	ldrb.w	r1, [r1, #-1]
static const char erase_seq[] = "\b \b";	/* erase sequence */
static const char   tab_seq[] = "        ";	/* used to expand TABs */

char console_buffer[SHELL_SYS_CBSIZE + 1];	/* console I/O buffer	*/

static char *delete_char (char *buffer, char *p, int *colp, int *np, int plen)
 800d99e:	4690      	mov	r8, r2
	char *s;

	if (*np == 0)
		return p;

	if (*(--p) == '\t') {		/* will retype the whole line */
 800d9a0:	2909      	cmp	r1, #9
static const char erase_seq[] = "\b \b";	/* erase sequence */
static const char   tab_seq[] = "        ";	/* used to expand TABs */

char console_buffer[SHELL_SYS_CBSIZE + 1];	/* console I/O buffer	*/

static char *delete_char (char *buffer, char *p, int *colp, int *np, int plen)
 800d9a2:	461d      	mov	r5, r3
	char *s;

	if (*np == 0)
		return p;

	if (*(--p) == '\t') {		/* will retype the whole line */
 800d9a4:	f104 36ff 	add.w	r6, r4, #4294967295
static const char erase_seq[] = "\b \b";	/* erase sequence */
static const char   tab_seq[] = "        ";	/* used to expand TABs */

char console_buffer[SHELL_SYS_CBSIZE + 1];	/* console I/O buffer	*/

static char *delete_char (char *buffer, char *p, int *colp, int *np, int plen)
 800d9a8:	9f08      	ldr	r7, [sp, #32]
	char *s;

	if (*np == 0)
		return p;

	if (*(--p) == '\t') {		/* will retype the whole line */
 800d9aa:	d00d      	beq.n	800d9c8 <delete_char.part.0+0x34>
				++(*colp);
				cputc(*s);
			}
		}
	} else {
		cputs(erase_seq);
 800d9ac:	481f      	ldr	r0, [pc, #124]	; (800da2c <delete_char.part.0+0x98>)
 800d9ae:	f7f3 fe5b 	bl	8001668 <cputs>
		(*colp)--;
 800d9b2:	f8d8 3000 	ldr.w	r3, [r8]
 800d9b6:	3b01      	subs	r3, #1
 800d9b8:	f8c8 3000 	str.w	r3, [r8]
	}
	(*np)--;
 800d9bc:	682b      	ldr	r3, [r5, #0]

	return p;
}
 800d9be:	4630      	mov	r0, r6
		}
	} else {
		cputs(erase_seq);
		(*colp)--;
	}
	(*np)--;
 800d9c0:	3b01      	subs	r3, #1
 800d9c2:	602b      	str	r3, [r5, #0]

	return p;
}
 800d9c4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800d9c8:	4681      	mov	r9, r0

	if (*np == 0)
		return p;

	if (*(--p) == '\t') {		/* will retype the whole line */
		while (*colp > plen) {
 800d9ca:	6810      	ldr	r0, [r2, #0]
 800d9cc:	4287      	cmp	r7, r0
 800d9ce:	da09      	bge.n	800d9e4 <delete_char.part.0+0x50>
			cputs(erase_seq);
 800d9d0:	4816      	ldr	r0, [pc, #88]	; (800da2c <delete_char.part.0+0x98>)
 800d9d2:	f7f3 fe49 	bl	8001668 <cputs>
			(*colp)--;
 800d9d6:	f8d8 0000 	ldr.w	r0, [r8]
 800d9da:	3801      	subs	r0, #1

	if (*np == 0)
		return p;

	if (*(--p) == '\t') {		/* will retype the whole line */
		while (*colp > plen) {
 800d9dc:	42b8      	cmp	r0, r7
			cputs(erase_seq);
			(*colp)--;
 800d9de:	f8c8 0000 	str.w	r0, [r8]

	if (*np == 0)
		return p;

	if (*(--p) == '\t') {		/* will retype the whole line */
		while (*colp > plen) {
 800d9e2:	dcf5      	bgt.n	800d9d0 <delete_char.part.0+0x3c>
			cputs(erase_seq);
			(*colp)--;
		}
		for (s = buffer; s < p; ++s) {
 800d9e4:	454e      	cmp	r6, r9
 800d9e6:	d9e9      	bls.n	800d9bc <delete_char.part.0+0x28>
			if (*s == '\t') {
				cputs(tab_seq + ((*colp) & 07));
 800d9e8:	4f11      	ldr	r7, [pc, #68]	; (800da30 <delete_char.part.0+0x9c>)
 800d9ea:	f109 39ff 	add.w	r9, r9, #4294967295
 800d9ee:	3c02      	subs	r4, #2
 800d9f0:	e009      	b.n	800da06 <delete_char.part.0+0x72>
				*colp += 8 - ((*colp) & 07);
			} else {
				++(*colp);
 800d9f2:	f8c8 2000 	str.w	r2, [r8]
				cputc(*s);
 800d9f6:	f899 0000 	ldrb.w	r0, [r9]
 800d9fa:	f7f3 fe29 	bl	8001650 <cputc>
	if (*(--p) == '\t') {		/* will retype the whole line */
		while (*colp > plen) {
			cputs(erase_seq);
			(*colp)--;
		}
		for (s = buffer; s < p; ++s) {
 800d9fe:	45a1      	cmp	r9, r4
 800da00:	d0dc      	beq.n	800d9bc <delete_char.part.0+0x28>
 800da02:	f8d8 0000 	ldr.w	r0, [r8]
			if (*s == '\t') {
 800da06:	f819 3f01 	ldrb.w	r3, [r9, #1]!
				cputs(tab_seq + ((*colp) & 07));
				*colp += 8 - ((*colp) & 07);
			} else {
				++(*colp);
 800da0a:	1c42      	adds	r2, r0, #1
		while (*colp > plen) {
			cputs(erase_seq);
			(*colp)--;
		}
		for (s = buffer; s < p; ++s) {
			if (*s == '\t') {
 800da0c:	2b09      	cmp	r3, #9
 800da0e:	d1f0      	bne.n	800d9f2 <delete_char.part.0+0x5e>
				cputs(tab_seq + ((*colp) & 07));
 800da10:	f000 0007 	and.w	r0, r0, #7
 800da14:	4438      	add	r0, r7
 800da16:	f7f3 fe27 	bl	8001668 <cputs>
				*colp += 8 - ((*colp) & 07);
 800da1a:	f8d8 0000 	ldr.w	r0, [r8]
 800da1e:	f020 0007 	bic.w	r0, r0, #7
 800da22:	3008      	adds	r0, #8
 800da24:	f8c8 0000 	str.w	r0, [r8]
 800da28:	e7e9      	b.n	800d9fe <delete_char.part.0+0x6a>
 800da2a:	bf00      	nop
 800da2c:	08016184 	.word	0x08016184
 800da30:	08016188 	.word	0x08016188

0800da34 <cli_readline_into_buffer>:
}


int cli_readline_into_buffer(const char *const prompt, char *buffer,
			     int timeout)
{
 800da34:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	char *p = buffer;
	char *p_buf = p;
	int	n = 0;				/* buffer index		*/
 800da38:	2300      	movs	r3, #0
}


int cli_readline_into_buffer(const char *const prompt, char *buffer,
			     int timeout)
{
 800da3a:	b087      	sub	sp, #28
 800da3c:	460f      	mov	r7, r1
	char *p = buffer;
	char *p_buf = p;
	int	n = 0;				/* buffer index		*/
 800da3e:	9304      	str	r3, [sp, #16]
	int	plen = 0;			/* prompt length	*/
	int	col;				/* output column cnt	*/
	char	c;

	/* print prompt */
	if (prompt) {
 800da40:	4680      	mov	r8, r0
 800da42:	2800      	cmp	r0, #0
 800da44:	d076      	beq.n	800db34 <cli_readline_into_buffer+0x100>
		plen = strlen(prompt);
 800da46:	f007 f8df 	bl	8014c08 <strlen>
 800da4a:	4606      	mov	r6, r0
		cputs(prompt);
 800da4c:	4640      	mov	r0, r8
 800da4e:	f7f3 fe0b 	bl	8001668 <cputs>


int cli_readline_into_buffer(const char *const prompt, char *buffer,
			     int timeout)
{
	char *p = buffer;
 800da52:	463c      	mov	r4, r7
							      console_buffer,
							      &n, &col)) {
						p = p_buf + n;	/* reset */
						continue;
					}
					puts(tab_seq + (col & 07));
 800da54:	f8df 9124 	ldr.w	r9, [pc, #292]	; 800db7c <cli_readline_into_buffer+0x148>
	/* print prompt */
	if (prompt) {
		plen = strlen(prompt);
		cputs(prompt);
	}
	col = plen;
 800da58:	9605      	str	r6, [sp, #20]

	for (;;) {
        
		//c = getc();
		c = cgetc();
 800da5a:	f7f3 fdf5 	bl	8001648 <cgetc>

		/*
		 * Special character handling
		 */
		switch (c) {
 800da5e:	b2c5      	uxtb	r5, r0
 800da60:	2d0a      	cmp	r5, #10
 800da62:	d01b      	beq.n	800da9c <cli_readline_into_buffer+0x68>
 800da64:	dd23      	ble.n	800daae <cli_readline_into_buffer+0x7a>
 800da66:	2d15      	cmp	r5, #21
 800da68:	d052      	beq.n	800db10 <cli_readline_into_buffer+0xdc>
 800da6a:	dd60      	ble.n	800db2e <cli_readline_into_buffer+0xfa>
 800da6c:	2d17      	cmp	r5, #23
 800da6e:	d13a      	bne.n	800dae6 <cli_readline_into_buffer+0xb2>

static char *delete_char (char *buffer, char *p, int *colp, int *np, int plen)
{
	char *s;

	if (*np == 0)
 800da70:	9b04      	ldr	r3, [sp, #16]
 800da72:	2b00      	cmp	r3, #0
 800da74:	d0f1      	beq.n	800da5a <cli_readline_into_buffer+0x26>
 800da76:	4621      	mov	r1, r4
 800da78:	ab04      	add	r3, sp, #16
 800da7a:	9600      	str	r6, [sp, #0]
 800da7c:	aa05      	add	r2, sp, #20
 800da7e:	4638      	mov	r0, r7
 800da80:	f7ff ff88 	bl	800d994 <delete_char.part.0>
			n = 0;
			continue;

		case 0x17:			/* ^W - erase word	*/
			p = delete_char(p_buf, p, &col, &n, plen);
			while ((n > 0) && (*p != ' '))
 800da84:	9b04      	ldr	r3, [sp, #16]
 800da86:	4604      	mov	r4, r0
 800da88:	2b00      	cmp	r3, #0
 800da8a:	dde6      	ble.n	800da5a <cli_readline_into_buffer+0x26>
 800da8c:	7803      	ldrb	r3, [r0, #0]
 800da8e:	2b20      	cmp	r3, #32
 800da90:	d1f1      	bne.n	800da76 <cli_readline_into_buffer+0x42>
	col = plen;

	for (;;) {
        
		//c = getc();
		c = cgetc();
 800da92:	f7f3 fdd9 	bl	8001648 <cgetc>

		/*
		 * Special character handling
		 */
		switch (c) {
 800da96:	b2c5      	uxtb	r5, r0
 800da98:	2d0a      	cmp	r5, #10
 800da9a:	d1e3      	bne.n	800da64 <cli_readline_into_buffer+0x30>
		case '\r':			/* Enter		*/
		case '\n':
			*p = '\0';
 800da9c:	2300      	movs	r3, #0
 800da9e:	7023      	strb	r3, [r4, #0]
			cputs("\r\n");
 800daa0:	4833      	ldr	r0, [pc, #204]	; (800db70 <cli_readline_into_buffer+0x13c>)
 800daa2:	f7f3 fde1 	bl	8001668 <cputs>
			return p - p_buf;
 800daa6:	1be0      	subs	r0, r4, r7
			{           /* Buffer full */
				cputc('\a');
			}
		}
	}
}
 800daa8:	b007      	add	sp, #28
 800daaa:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		c = cgetc();

		/*
		 * Special character handling
		 */
		switch (c) {
 800daae:	2d03      	cmp	r5, #3
 800dab0:	d027      	beq.n	800db02 <cli_readline_into_buffer+0xce>
 800dab2:	2d08      	cmp	r5, #8
 800dab4:	d019      	beq.n	800daea <cli_readline_into_buffer+0xb6>
 800dab6:	2d00      	cmp	r5, #0
 800dab8:	d0cf      	beq.n	800da5a <cli_readline_into_buffer+0x26>

		default:
			/*
			 * Must be a normal character then
			 */
			if (n < SHELL_SYS_CBSIZE-2) {
 800daba:	9b04      	ldr	r3, [sp, #16]
 800dabc:	2b3d      	cmp	r3, #61	; 0x3d
 800dabe:	dc3b      	bgt.n	800db38 <cli_readline_into_buffer+0x104>
				if (c == '\t') {	/* expand TABs */
 800dac0:	2d09      	cmp	r5, #9
 800dac2:	d03d      	beq.n	800db40 <cli_readline_into_buffer+0x10c>
                    
					/*
					 * Echo input using puts() to force an
					 * LCD flush if we are using an LCD
					 */
					++col;
 800dac4:	9b05      	ldr	r3, [sp, #20]
					buf[0] = c;
					buf[1] = '\0';
 800dac6:	2200      	movs	r2, #0
                    
					/*
					 * Echo input using puts() to force an
					 * LCD flush if we are using an LCD
					 */
					++col;
 800dac8:	3301      	adds	r3, #1
					buf[0] = c;
					buf[1] = '\0';
					cputs(buf);
 800daca:	a803      	add	r0, sp, #12
					/*
					 * Echo input using puts() to force an
					 * LCD flush if we are using an LCD
					 */
					++col;
					buf[0] = c;
 800dacc:	f88d 500c 	strb.w	r5, [sp, #12]
                    
					/*
					 * Echo input using puts() to force an
					 * LCD flush if we are using an LCD
					 */
					++col;
 800dad0:	9305      	str	r3, [sp, #20]
					buf[0] = c;
					buf[1] = '\0';
 800dad2:	f88d 200d 	strb.w	r2, [sp, #13]
					cputs(buf);
 800dad6:	f7f3 fdc7 	bl	8001668 <cputs>
				}
				*p++ = c;
 800dada:	7025      	strb	r5, [r4, #0]
				++n;
 800dadc:	9b04      	ldr	r3, [sp, #16]
					++col;
					buf[0] = c;
					buf[1] = '\0';
					cputs(buf);
				}
				*p++ = c;
 800dade:	3401      	adds	r4, #1
				++n;
 800dae0:	3301      	adds	r3, #1
 800dae2:	9304      	str	r3, [sp, #16]
 800dae4:	e7b9      	b.n	800da5a <cli_readline_into_buffer+0x26>
		c = cgetc();

		/*
		 * Special character handling
		 */
		switch (c) {
 800dae6:	2d7f      	cmp	r5, #127	; 0x7f
 800dae8:	d1e7      	bne.n	800daba <cli_readline_into_buffer+0x86>

static char *delete_char (char *buffer, char *p, int *colp, int *np, int plen)
{
	char *s;

	if (*np == 0)
 800daea:	9b04      	ldr	r3, [sp, #16]
 800daec:	2b00      	cmp	r3, #0
 800daee:	d0b4      	beq.n	800da5a <cli_readline_into_buffer+0x26>
 800daf0:	4621      	mov	r1, r4
 800daf2:	9600      	str	r6, [sp, #0]
 800daf4:	ab04      	add	r3, sp, #16
 800daf6:	aa05      	add	r2, sp, #20
 800daf8:	4638      	mov	r0, r7
 800dafa:	f7ff ff4b 	bl	800d994 <delete_char.part.0>
 800dafe:	4604      	mov	r4, r0
 800db00:	e7ab      	b.n	800da5a <cli_readline_into_buffer+0x26>

		case '\0':			/* nul			*/
			continue;

		case 0x03:			/* ^C - break		*/
			p_buf[0] = '\0';	/* discard input */
 800db02:	2300      	movs	r3, #0
			return -1;
 800db04:	f04f 30ff 	mov.w	r0, #4294967295

		case '\0':			/* nul			*/
			continue;

		case 0x03:			/* ^C - break		*/
			p_buf[0] = '\0';	/* discard input */
 800db08:	703b      	strb	r3, [r7, #0]
			{           /* Buffer full */
				cputc('\a');
			}
		}
	}
}
 800db0a:	b007      	add	sp, #28
 800db0c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		case 0x03:			/* ^C - break		*/
			p_buf[0] = '\0';	/* discard input */
			return -1;

		case 0x15:			/* ^U - erase line	*/
			while (col > plen) {
 800db10:	9b05      	ldr	r3, [sp, #20]
 800db12:	429e      	cmp	r6, r3
 800db14:	da07      	bge.n	800db26 <cli_readline_into_buffer+0xf2>
				cputs(erase_seq);
 800db16:	4817      	ldr	r0, [pc, #92]	; (800db74 <cli_readline_into_buffer+0x140>)
 800db18:	f7f3 fda6 	bl	8001668 <cputs>
				--col;
 800db1c:	9b05      	ldr	r3, [sp, #20]
 800db1e:	3b01      	subs	r3, #1
		case 0x03:			/* ^C - break		*/
			p_buf[0] = '\0';	/* discard input */
			return -1;

		case 0x15:			/* ^U - erase line	*/
			while (col > plen) {
 800db20:	429e      	cmp	r6, r3
				cputs(erase_seq);
				--col;
 800db22:	9305      	str	r3, [sp, #20]
		case 0x03:			/* ^C - break		*/
			p_buf[0] = '\0';	/* discard input */
			return -1;

		case 0x15:			/* ^U - erase line	*/
			while (col > plen) {
 800db24:	dbf7      	blt.n	800db16 <cli_readline_into_buffer+0xe2>
				cputs(erase_seq);
				--col;
			}
			p = p_buf;
			n = 0;
 800db26:	2300      	movs	r3, #0
 800db28:	9304      	str	r3, [sp, #16]
		case 0x15:			/* ^U - erase line	*/
			while (col > plen) {
				cputs(erase_seq);
				--col;
			}
			p = p_buf;
 800db2a:	463c      	mov	r4, r7
			n = 0;
			continue;
 800db2c:	e795      	b.n	800da5a <cli_readline_into_buffer+0x26>
		c = cgetc();

		/*
		 * Special character handling
		 */
		switch (c) {
 800db2e:	2d0d      	cmp	r5, #13
 800db30:	d0b4      	beq.n	800da9c <cli_readline_into_buffer+0x68>
 800db32:	e7c2      	b.n	800daba <cli_readline_into_buffer+0x86>
			     int timeout)
{
	char *p = buffer;
	char *p_buf = p;
	int	n = 0;				/* buffer index		*/
	int	plen = 0;			/* prompt length	*/
 800db34:	4606      	mov	r6, r0
 800db36:	e78c      	b.n	800da52 <cli_readline_into_buffer+0x1e>
				*p++ = c;
				++n;
			} 
			else 
			{           /* Buffer full */
				cputc('\a');
 800db38:	2007      	movs	r0, #7
 800db3a:	f7f3 fd89 	bl	8001650 <cputc>
 800db3e:	e78c      	b.n	800da5a <cli_readline_into_buffer+0x26>
				if (c == '\t') {	/* expand TABs */
					/*
					 * if auto completion triggered just
					 * continue
					 */
					*p = '\0';
 800db40:	2300      	movs	r3, #0
 800db42:	7023      	strb	r3, [r4, #0]
					if (cmd_auto_complete(prompt,
 800db44:	aa04      	add	r2, sp, #16
 800db46:	ab05      	add	r3, sp, #20
 800db48:	490b      	ldr	r1, [pc, #44]	; (800db78 <cli_readline_into_buffer+0x144>)
 800db4a:	4640      	mov	r0, r8
 800db4c:	f7f3 fcf4 	bl	8001538 <cmd_auto_complete>
 800db50:	b110      	cbz	r0, 800db58 <cli_readline_into_buffer+0x124>
							      console_buffer,
							      &n, &col)) {
						p = p_buf + n;	/* reset */
 800db52:	9c04      	ldr	r4, [sp, #16]
 800db54:	443c      	add	r4, r7
						continue;
 800db56:	e780      	b.n	800da5a <cli_readline_into_buffer+0x26>
					}
					puts(tab_seq + (col & 07));
 800db58:	9b05      	ldr	r3, [sp, #20]
 800db5a:	f003 0007 	and.w	r0, r3, #7
 800db5e:	4448      	add	r0, r9
 800db60:	f007 f9ba 	bl	8014ed8 <puts>
					col += 8 - (col & 07);
 800db64:	9b05      	ldr	r3, [sp, #20]
 800db66:	f023 0307 	bic.w	r3, r3, #7
 800db6a:	3308      	adds	r3, #8
 800db6c:	9305      	str	r3, [sp, #20]
 800db6e:	e7b4      	b.n	800dada <cli_readline_into_buffer+0xa6>
 800db70:	080164ec 	.word	0x080164ec
 800db74:	08016184 	.word	0x08016184
 800db78:	2000f058 	.word	0x2000f058
 800db7c:	08016188 	.word	0x08016188

0800db80 <cli_readline>:
{
	/*
	 * If console_buffer isn't 0-length the user will be prompted to modify
	 * it instead of entering it from scratch as desired.
	 */
	console_buffer[0] = '\0';
 800db80:	4b04      	ldr	r3, [pc, #16]	; (800db94 <cli_readline+0x14>)
}

/****************************************************************************/

int cli_readline(const char *const prompt)
{
 800db82:	b410      	push	{r4}
	/*
	 * If console_buffer isn't 0-length the user will be prompted to modify
	 * it instead of entering it from scratch as desired.
	 */
	console_buffer[0] = '\0';
 800db84:	2400      	movs	r4, #0
 800db86:	701c      	strb	r4, [r3, #0]

	return cli_readline_into_buffer(prompt, console_buffer, 0);
 800db88:	4622      	mov	r2, r4
 800db8a:	4619      	mov	r1, r3
}
 800db8c:	bc10      	pop	{r4}
	 * If console_buffer isn't 0-length the user will be prompted to modify
	 * it instead of entering it from scratch as desired.
	 */
	console_buffer[0] = '\0';

	return cli_readline_into_buffer(prompt, console_buffer, 0);
 800db8e:	f7ff bf51 	b.w	800da34 <cli_readline_into_buffer>
 800db92:	bf00      	nop
 800db94:	2000f058 	.word	0x2000f058

0800db98 <lwip_htons>:
 800db98:	ba40      	rev16	r0, r0
 800db9a:	b280      	uxth	r0, r0
 800db9c:	4770      	bx	lr
 800db9e:	bf00      	nop

0800dba0 <lwip_ntohs>:
 * @return n in host byte order
 */
u16_t
lwip_ntohs(u16_t n)
{
  return lwip_htons(n);
 800dba0:	ba40      	rev16	r0, r0
}
 800dba2:	b280      	uxth	r0, r0
 800dba4:	4770      	bx	lr
 800dba6:	bf00      	nop

0800dba8 <lwip_ntohl>:
 */
u32_t
lwip_ntohl(u32_t n)
{
  return lwip_htonl(n);
}
 800dba8:	ba00      	rev	r0, r0
 800dbaa:	4770      	bx	lr

0800dbac <lwip_htonl>:
 800dbac:	f7ff bffc 	b.w	800dba8 <lwip_ntohl>

0800dbb0 <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
 800dbb0:	b538      	push	{r3, r4, r5, lr}
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
 800dbb2:	4605      	mov	r5, r0
 800dbb4:	b1b8      	cbz	r0, 800dbe6 <free_etharp_q+0x36>
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
 800dbb6:	6868      	ldr	r0, [r5, #4]
 800dbb8:	b910      	cbnz	r0, 800dbc0 <free_etharp_q+0x10>
 800dbba:	e01b      	b.n	800dbf4 <free_etharp_q+0x44>
  while (q) {
 800dbbc:	4625      	mov	r5, r4
 800dbbe:	6860      	ldr	r0, [r4, #4]
    r = q;
    q = q->next;
 800dbc0:	682c      	ldr	r4, [r5, #0]
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
 800dbc2:	b140      	cbz	r0, 800dbd6 <free_etharp_q+0x26>
    pbuf_free(r->p);
 800dbc4:	f002 fa30 	bl	8010028 <pbuf_free>
    memp_free(MEMP_ARP_QUEUE, r);
 800dbc8:	4629      	mov	r1, r5
 800dbca:	200a      	movs	r0, #10
 800dbcc:	f002 f896 	bl	800fcfc <memp_free>
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
 800dbd0:	2c00      	cmp	r4, #0
 800dbd2:	d1f3      	bne.n	800dbbc <free_etharp_q+0xc>
 800dbd4:	bd38      	pop	{r3, r4, r5, pc}
    r = q;
    q = q->next;
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
 800dbd6:	4b0b      	ldr	r3, [pc, #44]	; (800dc04 <free_etharp_q+0x54>)
 800dbd8:	22a3      	movs	r2, #163	; 0xa3
 800dbda:	490b      	ldr	r1, [pc, #44]	; (800dc08 <free_etharp_q+0x58>)
 800dbdc:	480b      	ldr	r0, [pc, #44]	; (800dc0c <free_etharp_q+0x5c>)
 800dbde:	f007 f8cb 	bl	8014d78 <iprintf>
 800dbe2:	6868      	ldr	r0, [r5, #4]
 800dbe4:	e7ee      	b.n	800dbc4 <free_etharp_q+0x14>
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
 800dbe6:	4b07      	ldr	r3, [pc, #28]	; (800dc04 <free_etharp_q+0x54>)
 800dbe8:	229e      	movs	r2, #158	; 0x9e
 800dbea:	4909      	ldr	r1, [pc, #36]	; (800dc10 <free_etharp_q+0x60>)
 800dbec:	4807      	ldr	r0, [pc, #28]	; (800dc0c <free_etharp_q+0x5c>)
 800dbee:	f007 f8c3 	bl	8014d78 <iprintf>
 800dbf2:	e7e0      	b.n	800dbb6 <free_etharp_q+0x6>
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
 800dbf4:	4b03      	ldr	r3, [pc, #12]	; (800dc04 <free_etharp_q+0x54>)
 800dbf6:	229f      	movs	r2, #159	; 0x9f
 800dbf8:	4906      	ldr	r1, [pc, #24]	; (800dc14 <free_etharp_q+0x64>)
 800dbfa:	4804      	ldr	r0, [pc, #16]	; (800dc0c <free_etharp_q+0x5c>)
 800dbfc:	f007 f8bc 	bl	8014d78 <iprintf>
 800dc00:	6868      	ldr	r0, [r5, #4]
 800dc02:	e7dd      	b.n	800dbc0 <free_etharp_q+0x10>
 800dc04:	080175a0 	.word	0x080175a0
 800dc08:	080175d0 	.word	0x080175d0
 800dc0c:	0801660c 	.word	0x0801660c
 800dc10:	080175b4 	.word	0x080175b4
 800dc14:	080175c0 	.word	0x080175c0

0800dc18 <etharp_find_entry>:
 * @return The ARP entry index that matched or is created, ERR_MEM if no
 * entry is found or could be recycled.
 */
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
 800dc18:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800dc1c:	4f64      	ldr	r7, [pc, #400]	; (800ddb0 <etharp_find_entry+0x198>)
 800dc1e:	2300      	movs	r3, #0
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
  s8_t empty = ARP_TABLE_SIZE;
  u8_t i = 0, age_pending = 0, age_stable = 0;
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
 800dc20:	f04f 0e0a 	mov.w	lr, #10
 * @return The ARP entry index that matched or is created, ERR_MEM if no
 * entry is found or could be recycled.
 */
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
 800dc24:	b083      	sub	sp, #12
 800dc26:	463a      	mov	r2, r7
  s8_t empty = ARP_TABLE_SIZE;
  u8_t i = 0, age_pending = 0, age_stable = 0;
  /* oldest entry with packets on queue */
  s8_t old_queue = ARP_TABLE_SIZE;
  /* its age */
  u8_t age_queue = 0;
 800dc28:	4699      	mov	r9, r3
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
  s8_t empty = ARP_TABLE_SIZE;
  u8_t i = 0, age_pending = 0, age_stable = 0;
 800dc2a:	469c      	mov	ip, r3
 */
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
  s8_t empty = ARP_TABLE_SIZE;
 800dc2c:	4674      	mov	r4, lr
 * entry is found or could be recycled.
 */
static s8_t
etharp_find_entry(ip_addr_t *ipaddr, u8_t flags)
{
  s8_t old_pending = ARP_TABLE_SIZE, old_stable = ARP_TABLE_SIZE;
 800dc2e:	46f0      	mov	r8, lr
 800dc30:	46f2      	mov	sl, lr
 800dc32:	9301      	str	r3, [sp, #4]
 800dc34:	e004      	b.n	800dc40 <etharp_find_entry+0x28>
 800dc36:	3301      	adds	r3, #1
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 800dc38:	2b0a      	cmp	r3, #10
 800dc3a:	f102 0214 	add.w	r2, r2, #20
 800dc3e:	d019      	beq.n	800dc74 <etharp_find_entry+0x5c>
    u8_t state = arp_table[i].state;
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 800dc40:	2c0a      	cmp	r4, #10
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
 800dc42:	7c95      	ldrb	r5, [r2, #18]
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 800dc44:	d036      	beq.n	800dcb4 <etharp_find_entry+0x9c>
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
    } else if (state != ETHARP_STATE_EMPTY) {
 800dc46:	2d00      	cmp	r5, #0
 800dc48:	d0f5      	beq.n	800dc36 <etharp_find_entry+0x1e>
      LWIP_ASSERT("state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE",
        state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
 800dc4a:	b128      	cbz	r0, 800dc58 <etharp_find_entry+0x40>
 800dc4c:	6806      	ldr	r6, [r0, #0]
 800dc4e:	46b3      	mov	fp, r6
 800dc50:	6856      	ldr	r6, [r2, #4]
 800dc52:	45b3      	cmp	fp, r6
 800dc54:	f000 80a3 	beq.w	800dd9e <etharp_find_entry+0x186>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
 800dc58:	2d01      	cmp	r5, #1
 800dc5a:	d02f      	beq.n	800dcbc <etharp_find_entry+0xa4>
        /* don't record old_stable for static entries since they never expire */
        if (state < ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
        {
          /* remember entry with oldest stable entry in oldest, its age in maxtime */
          if (arp_table[i].ctime >= age_stable) {
 800dc5c:	7cd5      	ldrb	r5, [r2, #19]
 800dc5e:	3214      	adds	r2, #20
 800dc60:	4565      	cmp	r5, ip
            old_stable = i;
 800dc62:	bf28      	it	cs
 800dc64:	fa4f f883 	sxtbcs.w	r8, r3
 800dc68:	f103 0301 	add.w	r3, r3, #1
 800dc6c:	bf28      	it	cs
 800dc6e:	46ac      	movcs	ip, r5
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 800dc70:	2b0a      	cmp	r3, #10
 800dc72:	d1e5      	bne.n	800dc40 <etharp_find_entry+0x28>
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* don't create new entry, only search? */
  if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
 800dc74:	078a      	lsls	r2, r1, #30
 800dc76:	f100 8098 	bmi.w	800ddaa <etharp_find_entry+0x192>
 800dc7a:	2c0a      	cmp	r4, #10
 800dc7c:	4606      	mov	r6, r0
 800dc7e:	d02f      	beq.n	800dce0 <etharp_find_entry+0xc8>
 800dc80:	46a1      	mov	r9, r4
 800dc82:	ea4f 0589 	mov.w	r5, r9, lsl #2
    LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
    etharp_free_entry(i);
  }

  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
 800dc86:	eb05 0309 	add.w	r3, r5, r9
 800dc8a:	eb07 0383 	add.w	r3, r7, r3, lsl #2
 800dc8e:	7c9b      	ldrb	r3, [r3, #18]
   * { ETHARP_FLAG_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
    i = empty;
 800dc90:	b2e4      	uxtb	r4, r4
    LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
    etharp_free_entry(i);
  }

  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
 800dc92:	b9eb      	cbnz	r3, 800dcd0 <etharp_find_entry+0xb8>
    arp_table[i].state == ETHARP_STATE_EMPTY);

  /* IP address given? */
  if (ipaddr != NULL) {
 800dc94:	b12e      	cbz	r6, 800dca2 <etharp_find_entry+0x8a>
    /* set IP address */
    ip_addr_copy(arp_table[i].ipaddr, *ipaddr);
 800dc96:	6832      	ldr	r2, [r6, #0]
 800dc98:	eb05 0309 	add.w	r3, r5, r9
 800dc9c:	eb07 0383 	add.w	r3, r7, r3, lsl #2
 800dca0:	605a      	str	r2, [r3, #4]
  }
  arp_table[i].ctime = 0;
 800dca2:	444d      	add	r5, r9
 800dca4:	eb07 0785 	add.w	r7, r7, r5, lsl #2
 800dca8:	2300      	movs	r3, #0
  return (err_t)i;
 800dcaa:	b260      	sxtb	r0, r4
  /* IP address given? */
  if (ipaddr != NULL) {
    /* set IP address */
    ip_addr_copy(arp_table[i].ipaddr, *ipaddr);
  }
  arp_table[i].ctime = 0;
 800dcac:	74fb      	strb	r3, [r7, #19]
  return (err_t)i;
}
 800dcae:	b003      	add	sp, #12
 800dcb0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (state == ETHARP_STATE_EMPTY)) {
 800dcb4:	2d00      	cmp	r5, #0
 800dcb6:	d1c8      	bne.n	800dc4a <etharp_find_entry+0x32>
      LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
 800dcb8:	b25c      	sxtb	r4, r3
 800dcba:	e7bc      	b.n	800dc36 <etharp_find_entry+0x1e>
        return i;
      }
      /* pending entry? */
      if (state == ETHARP_STATE_PENDING) {
        /* pending with queued packets? */
        if (arp_table[i].q != NULL) {
 800dcbc:	6815      	ldr	r5, [r2, #0]
 800dcbe:	2d00      	cmp	r5, #0
 800dcc0:	d064      	beq.n	800dd8c <etharp_find_entry+0x174>
          if (arp_table[i].ctime >= age_queue) {
 800dcc2:	7cd5      	ldrb	r5, [r2, #19]
 800dcc4:	454d      	cmp	r5, r9
 800dcc6:	d3b6      	bcc.n	800dc36 <etharp_find_entry+0x1e>
            old_queue = i;
 800dcc8:	46a9      	mov	r9, r5
 800dcca:	fa4f fe83 	sxtb.w	lr, r3
 800dcce:	e7b2      	b.n	800dc36 <etharp_find_entry+0x1e>
    LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
    etharp_free_entry(i);
  }

  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
 800dcd0:	4b38      	ldr	r3, [pc, #224]	; (800ddb4 <etharp_find_entry+0x19c>)
 800dcd2:	f240 1289 	movw	r2, #393	; 0x189
 800dcd6:	4938      	ldr	r1, [pc, #224]	; (800ddb8 <etharp_find_entry+0x1a0>)
 800dcd8:	4838      	ldr	r0, [pc, #224]	; (800ddbc <etharp_find_entry+0x1a4>)
 800dcda:	f007 f84d 	bl	8014d78 <iprintf>
 800dcde:	e7d9      	b.n	800dc94 <etharp_find_entry+0x7c>
  /* { we have no match } => try to create a new entry */
   
  /* don't create new entry, only search? */
  if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
      /* or no empty entry found and not allowed to recycle? */
      ((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_FLAG_TRY_HARD) == 0))) {
 800dce0:	07cb      	lsls	r3, r1, #31
 800dce2:	d562      	bpl.n	800ddaa <etharp_find_entry+0x192>
  if (empty < ARP_TABLE_SIZE) {
    i = empty;
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  } else {
    /* 2) found recyclable stable entry? */
    if (old_stable < ARP_TABLE_SIZE) {
 800dce4:	f1b8 0f0a 	cmp.w	r8, #10
 800dce8:	d031      	beq.n	800dd4e <etharp_find_entry+0x136>
      /* recycle oldest stable*/
      i = old_stable;
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
      /* no queued packets should exist on stable entries */
      LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
 800dcea:	eb08 0388 	add.w	r3, r8, r8, lsl #2
 800dcee:	f857 3023 	ldr.w	r3, [r7, r3, lsl #2]
 800dcf2:	46c1      	mov	r9, r8
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  } else {
    /* 2) found recyclable stable entry? */
    if (old_stable < ARP_TABLE_SIZE) {
      /* recycle oldest stable*/
      i = old_stable;
 800dcf4:	fa5f f488 	uxtb.w	r4, r8
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
      /* no queued packets should exist on stable entries */
      LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
 800dcf8:	b133      	cbz	r3, 800dd08 <etharp_find_entry+0xf0>
 800dcfa:	4b2e      	ldr	r3, [pc, #184]	; (800ddb4 <etharp_find_entry+0x19c>)
 800dcfc:	f240 1271 	movw	r2, #369	; 0x171
 800dd00:	492f      	ldr	r1, [pc, #188]	; (800ddc0 <etharp_find_entry+0x1a8>)
 800dd02:	482e      	ldr	r0, [pc, #184]	; (800ddbc <etharp_find_entry+0x1a4>)
 800dd04:	f007 f838 	bl	8014d78 <iprintf>
etharp_free_entry(int i)
{
  /* remove from SNMP ARP index tree */
  snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
 800dd08:	ea4f 0589 	mov.w	r5, r9, lsl #2
 800dd0c:	eb05 0309 	add.w	r3, r5, r9
 800dd10:	009b      	lsls	r3, r3, #2
 800dd12:	58f8      	ldr	r0, [r7, r3]
 800dd14:	443b      	add	r3, r7
 800dd16:	2800      	cmp	r0, #0
 800dd18:	d045      	beq.n	800dda6 <etharp_find_entry+0x18e>
    /* remove all queued packets */
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
 800dd1a:	f7ff ff49 	bl	800dbb0 <free_etharp_q>
    arp_table[i].q = NULL;
 800dd1e:	eb05 0309 	add.w	r3, r5, r9
 800dd22:	009b      	lsls	r3, r3, #2
 800dd24:	2200      	movs	r2, #0
 800dd26:	18f9      	adds	r1, r7, r3
    /* { empty or recyclable entry found } */
    LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
    etharp_free_entry(i);
  }

  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
 800dd28:	2c09      	cmp	r4, #9
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
    arp_table[i].q = NULL;
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
 800dd2a:	748a      	strb	r2, [r1, #18]
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
    /* remove all queued packets */
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
    arp_table[i].q = NULL;
 800dd2c:	50fa      	str	r2, [r7, r3]
    /* { empty or recyclable entry found } */
    LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
    etharp_free_entry(i);
  }

  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
 800dd2e:	d9b1      	bls.n	800dc94 <etharp_find_entry+0x7c>
 800dd30:	4b20      	ldr	r3, [pc, #128]	; (800ddb4 <etharp_find_entry+0x19c>)
 800dd32:	f240 1287 	movw	r2, #391	; 0x187
 800dd36:	4923      	ldr	r1, [pc, #140]	; (800ddc4 <etharp_find_entry+0x1ac>)
 800dd38:	4820      	ldr	r0, [pc, #128]	; (800ddbc <etharp_find_entry+0x1a4>)
 800dd3a:	f007 f81d 	bl	8014d78 <iprintf>
  LWIP_ASSERT("arp_table[i].state == ETHARP_STATE_EMPTY",
 800dd3e:	eb05 0309 	add.w	r3, r5, r9
 800dd42:	eb07 0383 	add.w	r3, r7, r3, lsl #2
 800dd46:	7c9b      	ldrb	r3, [r3, #18]
 800dd48:	2b00      	cmp	r3, #0
 800dd4a:	d0a3      	beq.n	800dc94 <etharp_find_entry+0x7c>
 800dd4c:	e7c0      	b.n	800dcd0 <etharp_find_entry+0xb8>
      i = old_stable;
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
      /* no queued packets should exist on stable entries */
      LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
    /* 3) found recyclable pending entry without queued packets? */
    } else if (old_pending < ARP_TABLE_SIZE) {
 800dd4e:	f1ba 0f0a 	cmp.w	sl, #10
 800dd52:	d117      	bne.n	800dd84 <etharp_find_entry+0x16c>
      /* recycle oldest pending */
      i = old_pending;
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
    /* 4) found recyclable pending entry with queued packets? */
    } else if (old_queue < ARP_TABLE_SIZE) {
 800dd54:	f1be 0f0a 	cmp.w	lr, #10
 800dd58:	d027      	beq.n	800ddaa <etharp_find_entry+0x192>
      /* recycle oldest pending (queued packets are free in etharp_free_entry) */
      i = old_queue;
 800dd5a:	fa5f f48e 	uxtb.w	r4, lr
 800dd5e:	46a1      	mov	r9, r4
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty or recyclable entries found\n"));
      return (s8_t)ERR_MEM;
    }

    /* { empty or recyclable entry found } */
    LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
 800dd60:	2c09      	cmp	r4, #9
 800dd62:	d9d1      	bls.n	800dd08 <etharp_find_entry+0xf0>
 800dd64:	4b13      	ldr	r3, [pc, #76]	; (800ddb4 <etharp_find_entry+0x19c>)
 800dd66:	f240 1283 	movw	r2, #387	; 0x183
 800dd6a:	4916      	ldr	r1, [pc, #88]	; (800ddc4 <etharp_find_entry+0x1ac>)
 800dd6c:	4813      	ldr	r0, [pc, #76]	; (800ddbc <etharp_find_entry+0x1a4>)
etharp_free_entry(int i)
{
  /* remove from SNMP ARP index tree */
  snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
 800dd6e:	00a5      	lsls	r5, r4, #2
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty or recyclable entries found\n"));
      return (s8_t)ERR_MEM;
    }

    /* { empty or recyclable entry found } */
    LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
 800dd70:	f007 f802 	bl	8014d78 <iprintf>
etharp_free_entry(int i)
{
  /* remove from SNMP ARP index tree */
  snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
 800dd74:	192b      	adds	r3, r5, r4
 800dd76:	009b      	lsls	r3, r3, #2
 800dd78:	58f8      	ldr	r0, [r7, r3]
 800dd7a:	443b      	add	r3, r7
 800dd7c:	2800      	cmp	r0, #0
 800dd7e:	d1cc      	bne.n	800dd1a <etharp_find_entry+0x102>
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
    arp_table[i].q = NULL;
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
 800dd80:	7498      	strb	r0, [r3, #18]
 800dd82:	e7d5      	b.n	800dd30 <etharp_find_entry+0x118>
      /* no queued packets should exist on stable entries */
      LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
    /* 3) found recyclable pending entry without queued packets? */
    } else if (old_pending < ARP_TABLE_SIZE) {
      /* recycle oldest pending */
      i = old_pending;
 800dd84:	fa5f f48a 	uxtb.w	r4, sl
 800dd88:	46a1      	mov	r9, r4
 800dd8a:	e7e9      	b.n	800dd60 <etharp_find_entry+0x148>
            age_queue = arp_table[i].ctime;
          }
        } else
        /* pending without queued packets? */
        {
          if (arp_table[i].ctime >= age_pending) {
 800dd8c:	7cd5      	ldrb	r5, [r2, #19]
 800dd8e:	9e01      	ldr	r6, [sp, #4]
 800dd90:	42b5      	cmp	r5, r6
 800dd92:	f4ff af50 	bcc.w	800dc36 <etharp_find_entry+0x1e>
            old_pending = i;
 800dd96:	9501      	str	r5, [sp, #4]
 800dd98:	fa4f fa83 	sxtb.w	sl, r3
 800dd9c:	e74b      	b.n	800dc36 <etharp_find_entry+0x1e>
        state == ETHARP_STATE_PENDING || state >= ETHARP_STATE_STABLE);
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: found matching entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
        return i;
 800dd9e:	b258      	sxtb	r0, r3
    /* set IP address */
    ip_addr_copy(arp_table[i].ipaddr, *ipaddr);
  }
  arp_table[i].ctime = 0;
  return (err_t)i;
}
 800dda0:	b003      	add	sp, #12
 800dda2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
    arp_table[i].q = NULL;
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
 800dda6:	7498      	strb	r0, [r3, #18]
 800dda8:	e774      	b.n	800dc94 <etharp_find_entry+0x7c>
  /* don't create new entry, only search? */
  if (((flags & ETHARP_FLAG_FIND_ONLY) != 0) ||
      /* or no empty entry found and not allowed to recycle? */
      ((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_FLAG_TRY_HARD) == 0))) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
 800ddaa:	f04f 30ff 	mov.w	r0, #4294967295
 800ddae:	e77e      	b.n	800dcae <etharp_find_entry+0x96>
 800ddb0:	20000804 	.word	0x20000804
 800ddb4:	080175a0 	.word	0x080175a0
 800ddb8:	0801760c 	.word	0x0801760c
 800ddbc:	0801660c 	.word	0x0801660c
 800ddc0:	080175e0 	.word	0x080175e0
 800ddc4:	080175f8 	.word	0x080175f8

0800ddc8 <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
 800ddc8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800ddcc:	460e      	mov	r6, r1
  struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
 800ddce:	f890 1022 	ldrb.w	r1, [r0, #34]	; 0x22
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
 800ddd2:	4605      	mov	r5, r0
  struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
 800ddd4:	2906      	cmp	r1, #6
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
 800ddd6:	4617      	mov	r7, r2
 800ddd8:	4698      	mov	r8, r3
  struct eth_hdr *ethhdr = (struct eth_hdr *)p->payload;
 800ddda:	6874      	ldr	r4, [r6, #4]

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
 800dddc:	d006      	beq.n	800ddec <etharp_send_ip+0x24>
 800ddde:	4b0d      	ldr	r3, [pc, #52]	; (800de14 <etharp_send_ip+0x4c>)
 800dde0:	f44f 72d2 	mov.w	r2, #420	; 0x1a4
 800dde4:	490c      	ldr	r1, [pc, #48]	; (800de18 <etharp_send_ip+0x50>)
 800dde6:	480d      	ldr	r0, [pc, #52]	; (800de1c <etharp_send_ip+0x54>)
 800dde8:	f006 ffc6 	bl	8014d78 <iprintf>
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  ETHADDR32_COPY(&ethhdr->dest, dst);
 800ddec:	4641      	mov	r1, r8
 800ddee:	2206      	movs	r2, #6
 800ddf0:	4620      	mov	r0, r4
 800ddf2:	f006 ffae 	bl	8014d52 <memcpy>
  ETHADDR16_COPY(&ethhdr->src, src);
 800ddf6:	2206      	movs	r2, #6
 800ddf8:	4639      	mov	r1, r7
 800ddfa:	18a0      	adds	r0, r4, r2
 800ddfc:	f006 ffa9 	bl	8014d52 <memcpy>
  ethhdr->type = PP_HTONS(ETHTYPE_IP);
 800de00:	2308      	movs	r3, #8
 800de02:	2200      	movs	r2, #0
 800de04:	7323      	strb	r3, [r4, #12]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
 800de06:	4631      	mov	r1, r6

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  ETHADDR32_COPY(&ethhdr->dest, dst);
  ETHADDR16_COPY(&ethhdr->src, src);
  ethhdr->type = PP_HTONS(ETHTYPE_IP);
 800de08:	7362      	strb	r2, [r4, #13]
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
 800de0a:	69ab      	ldr	r3, [r5, #24]
 800de0c:	4628      	mov	r0, r5
}
 800de0e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  ETHADDR32_COPY(&ethhdr->dest, dst);
  ETHADDR16_COPY(&ethhdr->src, src);
  ethhdr->type = PP_HTONS(ETHTYPE_IP);
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
 800de12:	4718      	bx	r3
 800de14:	080175a0 	.word	0x080175a0
 800de18:	08017638 	.word	0x08017638
 800de1c:	0801660c 	.word	0x0801660c

0800de20 <etharp_update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
etharp_update_arp_entry(struct netif *netif, ip_addr_t *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
 800de20:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800de24:	4606      	mov	r6, r0
  s8_t i;
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
 800de26:	f890 0022 	ldrb.w	r0, [r0, #34]	; 0x22
 *
 * @see pbuf_free()
 */
static err_t
etharp_update_arp_entry(struct netif *netif, ip_addr_t *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
 800de2a:	460c      	mov	r4, r1
  s8_t i;
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
 800de2c:	2806      	cmp	r0, #6
 *
 * @see pbuf_free()
 */
static err_t
etharp_update_arp_entry(struct netif *netif, ip_addr_t *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
 800de2e:	4617      	mov	r7, r2
 800de30:	461d      	mov	r5, r3
  s8_t i;
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
 800de32:	d006      	beq.n	800de42 <etharp_update_arp_entry+0x22>
 800de34:	4b27      	ldr	r3, [pc, #156]	; (800ded4 <etharp_update_arp_entry+0xb4>)
 800de36:	f240 12c3 	movw	r2, #451	; 0x1c3
 800de3a:	4927      	ldr	r1, [pc, #156]	; (800ded8 <etharp_update_arp_entry+0xb8>)
 800de3c:	4827      	ldr	r0, [pc, #156]	; (800dedc <etharp_update_arp_entry+0xbc>)
 800de3e:	f006 ff9b 	bl	8014d78 <iprintf>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
    ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
    ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
    ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
 800de42:	2c00      	cmp	r4, #0
 800de44:	d042      	beq.n	800decc <etharp_update_arp_entry+0xac>
 800de46:	6820      	ldr	r0, [r4, #0]
 800de48:	2800      	cmp	r0, #0
 800de4a:	d03f      	beq.n	800decc <etharp_update_arp_entry+0xac>
      ip_addr_isbroadcast(ipaddr, netif) ||
 800de4c:	4631      	mov	r1, r6
 800de4e:	f000 ff55 	bl	800ecfc <ip4_addr_isbroadcast>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
    ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr),
    ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
    ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
 800de52:	4680      	mov	r8, r0
 800de54:	2800      	cmp	r0, #0
 800de56:	d139      	bne.n	800decc <etharp_update_arp_entry+0xac>
      ip_addr_isbroadcast(ipaddr, netif) ||
 800de58:	6823      	ldr	r3, [r4, #0]
 800de5a:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800de5e:	2be0      	cmp	r3, #224	; 0xe0
 800de60:	d034      	beq.n	800decc <etharp_update_arp_entry+0xac>
      ip_addr_ismulticast(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  }
  /* find or create ARP entry */
  i = etharp_find_entry(ipaddr, flags);
 800de62:	4629      	mov	r1, r5
 800de64:	4620      	mov	r0, r4
 800de66:	f7ff fed7 	bl	800dc18 <etharp_find_entry>
  /* bail out if no entry could be found */
  if (i < 0) {
 800de6a:	2800      	cmp	r0, #0
 800de6c:	db2c      	blt.n	800dec8 <etharp_update_arp_entry+0xa8>
    arp_table[i].state = ETHARP_STATE_STATIC;
  } else
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
  {
    /* mark it stable */
    arp_table[i].state = ETHARP_STATE_STABLE;
 800de6e:	f8df 9070 	ldr.w	r9, [pc, #112]	; 800dee0 <etharp_update_arp_entry+0xc0>
 800de72:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800de76:	0084      	lsls	r4, r0, #2
 800de78:	eb09 0504 	add.w	r5, r9, r4
 800de7c:	2302      	movs	r3, #2
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
 800de7e:	eb09 0004 	add.w	r0, r9, r4
 800de82:	4639      	mov	r1, r7
 800de84:	300c      	adds	r0, #12
 800de86:	2206      	movs	r2, #6
    /* mark it stable */
    arp_table[i].state = ETHARP_STATE_STABLE;
  }

  /* record network interface */
  arp_table[i].netif = netif;
 800de88:	60ae      	str	r6, [r5, #8]
    arp_table[i].state = ETHARP_STATE_STATIC;
  } else
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
  {
    /* mark it stable */
    arp_table[i].state = ETHARP_STATE_STABLE;
 800de8a:	74ab      	strb	r3, [r5, #18]
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
 800de8c:	f006 ff61 	bl	8014d52 <memcpy>
  /* reset time stamp */
  arp_table[i].ctime = 0;
  /* this is where we will send out queued packets! */
#if ARP_QUEUEING
  while (arp_table[i].q != NULL) {
 800de90:	f859 1004 	ldr.w	r1, [r9, r4]

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
  /* reset time stamp */
  arp_table[i].ctime = 0;
 800de94:	f885 8013 	strb.w	r8, [r5, #19]
 800de98:	f106 0823 	add.w	r8, r6, #35	; 0x23
  /* this is where we will send out queued packets! */
#if ARP_QUEUEING
  while (arp_table[i].q != NULL) {
 800de9c:	b189      	cbz	r1, 800dec2 <etharp_update_arp_entry+0xa2>
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
    /* pop first item off the queue */
    arp_table[i].q = q->next;
    /* get the packet pointer */
    p = q->p;
 800de9e:	e891 0018 	ldmia.w	r1, {r3, r4}
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
 800dea2:	200a      	movs	r0, #10
  while (arp_table[i].q != NULL) {
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
    /* pop first item off the queue */
    arp_table[i].q = q->next;
 800dea4:	602b      	str	r3, [r5, #0]
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
 800dea6:	f001 ff29 	bl	800fcfc <memp_free>
  if (arp_table[i].q != NULL) {
    struct pbuf *p = arp_table[i].q;
    arp_table[i].q = NULL;
#endif /* ARP_QUEUEING */
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
 800deaa:	4621      	mov	r1, r4
 800deac:	463b      	mov	r3, r7
 800deae:	4642      	mov	r2, r8
 800deb0:	4630      	mov	r0, r6
 800deb2:	f7ff ff89 	bl	800ddc8 <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
 800deb6:	4620      	mov	r0, r4
 800deb8:	f002 f8b6 	bl	8010028 <pbuf_free>
  ETHADDR32_COPY(&arp_table[i].ethaddr, ethaddr);
  /* reset time stamp */
  arp_table[i].ctime = 0;
  /* this is where we will send out queued packets! */
#if ARP_QUEUEING
  while (arp_table[i].q != NULL) {
 800debc:	6829      	ldr	r1, [r5, #0]
 800debe:	2900      	cmp	r1, #0
 800dec0:	d1ed      	bne.n	800de9e <etharp_update_arp_entry+0x7e>
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
    /* free the queued IP packet */
    pbuf_free(p);
  }
  return ERR_OK;
 800dec2:	2000      	movs	r0, #0
 800dec4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
}
 800dec8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
 800decc:	f06f 000d 	mvn.w	r0, #13
 800ded0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800ded4:	080175a0 	.word	0x080175a0
 800ded8:	0801767c 	.word	0x0801767c
 800dedc:	0801660c 	.word	0x0801660c
 800dee0:	20000804 	.word	0x20000804

0800dee4 <etharp_raw.constprop.1>:
 */
#if !LWIP_AUTOIP
static
#endif /* LWIP_AUTOIP */
err_t
etharp_raw(struct netif *netif, const struct eth_addr *ethsrc_addr,
 800dee4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800dee8:	4688      	mov	r8, r1
 800deea:	4691      	mov	r9, r2
 800deec:	461f      	mov	r7, r3
  struct etharp_hdr *hdr;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ASSERT("netif != NULL", netif != NULL);
 800deee:	4606      	mov	r6, r0
 800def0:	2800      	cmp	r0, #0
 800def2:	d05e      	beq.n	800dfb2 <etharp_raw.constprop.1+0xce>

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_RAW, SIZEOF_ETHARP_PACKET, PBUF_RAM);
 800def4:	2200      	movs	r2, #0
 800def6:	212a      	movs	r1, #42	; 0x2a
 800def8:	2003      	movs	r0, #3
 800defa:	f002 f8ed 	bl	80100d8 <pbuf_alloc>
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
 800defe:	4605      	mov	r5, r0
 800df00:	2800      	cmp	r0, #0
 800df02:	d05e      	beq.n	800dfc2 <etharp_raw.constprop.1+0xde>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
 800df04:	8943      	ldrh	r3, [r0, #10]
 800df06:	2b29      	cmp	r3, #41	; 0x29
 800df08:	d94b      	bls.n	800dfa2 <etharp_raw.constprop.1+0xbe>
              (p->len >= SIZEOF_ETHARP_PACKET));

  ethhdr = (struct eth_hdr *)p->payload;
  hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
 800df0a:	2001      	movs	r0, #1
    return ERR_MEM;
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
              (p->len >= SIZEOF_ETHARP_PACKET));

  ethhdr = (struct eth_hdr *)p->payload;
 800df0c:	686c      	ldr	r4, [r5, #4]
  hdr = (struct etharp_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR);
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
 800df0e:	f7ff fe43 	bl	800db98 <lwip_htons>
 800df12:	82a0      	strh	r0, [r4, #20]

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
 800df14:	f896 3022 	ldrb.w	r3, [r6, #34]	; 0x22
 800df18:	2b06      	cmp	r3, #6
 800df1a:	d006      	beq.n	800df2a <etharp_raw.constprop.1+0x46>
 800df1c:	4b2b      	ldr	r3, [pc, #172]	; (800dfcc <etharp_raw.constprop.1+0xe8>)
 800df1e:	f240 42b9 	movw	r2, #1209	; 0x4b9
 800df22:	492b      	ldr	r1, [pc, #172]	; (800dfd0 <etharp_raw.constprop.1+0xec>)
 800df24:	482b      	ldr	r0, [pc, #172]	; (800dfd4 <etharp_raw.constprop.1+0xf0>)
 800df26:	f006 ff27 	bl	8014d78 <iprintf>
   * 'sender IP address' MUST be sent using link-layer broadcast instead of
   * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
  ethdst_hwaddr = ip_addr_islinklocal(ipsrc_addr) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write the ARP MAC-Addresses */
  ETHADDR16_COPY(&hdr->shwaddr, hwsrc_addr);
 800df2a:	4649      	mov	r1, r9
 800df2c:	2206      	movs	r2, #6
 800df2e:	f104 0016 	add.w	r0, r4, #22
 800df32:	f006 ff0e 	bl	8014d52 <memcpy>
  ETHADDR16_COPY(&hdr->dhwaddr, hwdst_addr);
 800df36:	2206      	movs	r2, #6
 800df38:	4927      	ldr	r1, [pc, #156]	; (800dfd8 <etharp_raw.constprop.1+0xf4>)
 800df3a:	f104 0020 	add.w	r0, r4, #32
 800df3e:	f006 ff08 	bl	8014d52 <memcpy>
  /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
  ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
#else  /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->dest, ethdst_addr);
 800df42:	2206      	movs	r2, #6
 800df44:	4925      	ldr	r1, [pc, #148]	; (800dfdc <etharp_raw.constprop.1+0xf8>)
 800df46:	4620      	mov	r0, r4
 800df48:	f006 ff03 	bl	8014d52 <memcpy>
#endif /* LWIP_AUTOIP */
  ETHADDR16_COPY(&ethhdr->src, ethsrc_addr);
 800df4c:	2206      	movs	r2, #6
 800df4e:	4641      	mov	r1, r8
 800df50:	18a0      	adds	r0, r4, r2
 800df52:	f006 fefe 	bl	8014d52 <memcpy>
  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing. */ 
  IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
 800df56:	4639      	mov	r1, r7
 800df58:	2204      	movs	r2, #4
 800df5a:	f104 001c 	add.w	r0, r4, #28
 800df5e:	f006 fef8 	bl	8014d52 <memcpy>
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);
 800df62:	9908      	ldr	r1, [sp, #32]
 800df64:	2204      	movs	r2, #4
 800df66:	f104 0026 	add.w	r0, r4, #38	; 0x26
 800df6a:	f006 fef2 	bl	8014d52 <memcpy>

  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
  hdr->proto = PP_HTONS(ETHTYPE_IP);
  /* set hwlen and protolen */
  hdr->hwlen = ETHARP_HWADDR_LEN;
 800df6e:	2106      	movs	r1, #6
  hdr->protolen = sizeof(ip_addr_t);
 800df70:	2304      	movs	r3, #4
  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing. */ 
  IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);

  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
 800df72:	2200      	movs	r2, #0
  hdr->proto = PP_HTONS(ETHTYPE_IP);
  /* set hwlen and protolen */
  hdr->hwlen = ETHARP_HWADDR_LEN;
 800df74:	74a1      	strb	r1, [r4, #18]
  hdr->protolen = sizeof(ip_addr_t);
 800df76:	74e3      	strb	r3, [r4, #19]
  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing. */ 
  IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);

  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
 800df78:	f04f 0e01 	mov.w	lr, #1
  hdr->proto = PP_HTONS(ETHTYPE_IP);
 800df7c:	2308      	movs	r3, #8
  hdr->hwlen = ETHARP_HWADDR_LEN;
  hdr->protolen = sizeof(ip_addr_t);

  ethhdr->type = PP_HTONS(ETHTYPE_ARP);
  /* send ARP query */
  result = netif->linkoutput(netif, p);
 800df7e:	69b7      	ldr	r7, [r6, #24]
  hdr->proto = PP_HTONS(ETHTYPE_IP);
  /* set hwlen and protolen */
  hdr->hwlen = ETHARP_HWADDR_LEN;
  hdr->protolen = sizeof(ip_addr_t);

  ethhdr->type = PP_HTONS(ETHTYPE_ARP);
 800df80:	7361      	strb	r1, [r4, #13]
  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing. */ 
  IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);

  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
 800df82:	73a2      	strb	r2, [r4, #14]
  hdr->proto = PP_HTONS(ETHTYPE_IP);
 800df84:	7462      	strb	r2, [r4, #17]
  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing. */ 
  IPADDR2_COPY(&hdr->sipaddr, ipsrc_addr);
  IPADDR2_COPY(&hdr->dipaddr, ipdst_addr);

  hdr->hwtype = PP_HTONS(HWTYPE_ETHERNET);
 800df86:	f884 e00f 	strb.w	lr, [r4, #15]
  hdr->proto = PP_HTONS(ETHTYPE_IP);
 800df8a:	7423      	strb	r3, [r4, #16]
  /* set hwlen and protolen */
  hdr->hwlen = ETHARP_HWADDR_LEN;
  hdr->protolen = sizeof(ip_addr_t);

  ethhdr->type = PP_HTONS(ETHTYPE_ARP);
 800df8c:	7323      	strb	r3, [r4, #12]
  /* send ARP query */
  result = netif->linkoutput(netif, p);
 800df8e:	4629      	mov	r1, r5
 800df90:	4630      	mov	r0, r6
 800df92:	47b8      	blx	r7
 800df94:	4604      	mov	r4, r0
  ETHARP_STATS_INC(etharp.xmit);
  /* free ARP query packet */
  pbuf_free(p);
 800df96:	4628      	mov	r0, r5
 800df98:	f002 f846 	bl	8010028 <pbuf_free>
  p = NULL;
  /* could not allocate pbuf for ARP request */

  return result;
 800df9c:	4620      	mov	r0, r4
 800df9e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
 800dfa2:	4b0a      	ldr	r3, [pc, #40]	; (800dfcc <etharp_raw.constprop.1+0xe8>)
 800dfa4:	f240 42b1 	movw	r2, #1201	; 0x4b1
 800dfa8:	490d      	ldr	r1, [pc, #52]	; (800dfe0 <etharp_raw.constprop.1+0xfc>)
 800dfaa:	480a      	ldr	r0, [pc, #40]	; (800dfd4 <etharp_raw.constprop.1+0xf0>)
 800dfac:	f006 fee4 	bl	8014d78 <iprintf>
 800dfb0:	e7ab      	b.n	800df0a <etharp_raw.constprop.1+0x26>
  struct etharp_hdr *hdr;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ASSERT("netif != NULL", netif != NULL);
 800dfb2:	4b06      	ldr	r3, [pc, #24]	; (800dfcc <etharp_raw.constprop.1+0xe8>)
 800dfb4:	f240 42a5 	movw	r2, #1189	; 0x4a5
 800dfb8:	490a      	ldr	r1, [pc, #40]	; (800dfe4 <etharp_raw.constprop.1+0x100>)
 800dfba:	4806      	ldr	r0, [pc, #24]	; (800dfd4 <etharp_raw.constprop.1+0xf0>)
 800dfbc:	f006 fedc 	bl	8014d78 <iprintf>
 800dfc0:	e798      	b.n	800def4 <etharp_raw.constprop.1+0x10>
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
 800dfc2:	f04f 30ff 	mov.w	r0, #4294967295
  pbuf_free(p);
  p = NULL;
  /* could not allocate pbuf for ARP request */

  return result;
}
 800dfc6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800dfca:	bf00      	nop
 800dfcc:	080175a0 	.word	0x080175a0
 800dfd0:	08017638 	.word	0x08017638
 800dfd4:	0801660c 	.word	0x0801660c
 800dfd8:	08016194 	.word	0x08016194
 800dfdc:	0801619c 	.word	0x0801619c
 800dfe0:	080176b4 	.word	0x080176b4
 800dfe4:	080176a4 	.word	0x080176a4

0800dfe8 <etharp_output_to_arp_index>:
/** Just a small helper function that sends a pbuf to an ethernet address
 * in the arp_table specified by the index 'arp_idx'.
 */
static err_t
etharp_output_to_arp_index(struct netif *netif, struct pbuf *q, u8_t arp_idx)
{
 800dfe8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
 800dfec:	4d1e      	ldr	r5, [pc, #120]	; (800e068 <etharp_output_to_arp_index+0x80>)
 800dfee:	0097      	lsls	r7, r2, #2
 800dff0:	18be      	adds	r6, r7, r2
 800dff2:	eb05 0686 	add.w	r6, r5, r6, lsl #2
 800dff6:	7cb3      	ldrb	r3, [r6, #18]
/** Just a small helper function that sends a pbuf to an ethernet address
 * in the arp_table specified by the index 'arp_idx'.
 */
static err_t
etharp_output_to_arp_index(struct netif *netif, struct pbuf *q, u8_t arp_idx)
{
 800dff8:	b082      	sub	sp, #8
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
 800dffa:	2b01      	cmp	r3, #1
/** Just a small helper function that sends a pbuf to an ethernet address
 * in the arp_table specified by the index 'arp_idx'.
 */
static err_t
etharp_output_to_arp_index(struct netif *netif, struct pbuf *q, u8_t arp_idx)
{
 800dffc:	4614      	mov	r4, r2
 800dffe:	4680      	mov	r8, r0
 800e000:	4689      	mov	r9, r1
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
 800e002:	d928      	bls.n	800e056 <etharp_output_to_arp_index+0x6e>
              arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
  /* if arp table entry is about to expire: re-request it,
     but only if its state is ETHARP_STATE_STABLE to prevent flooding the
     network with ARP requests if this address is used frequently. */
  if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
 800e004:	2b02      	cmp	r3, #2
 800e006:	d00c      	beq.n	800e022 <etharp_output_to_arp_index+0x3a>
 800e008:	f108 0623 	add.w	r6, r8, #35	; 0x23
    if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
      arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING;
    }
  }
  
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr),
 800e00c:	4632      	mov	r2, r6
 800e00e:	4649      	mov	r1, r9
 800e010:	4640      	mov	r0, r8
 800e012:	443c      	add	r4, r7
 800e014:	eb05 0384 	add.w	r3, r5, r4, lsl #2
 800e018:	330c      	adds	r3, #12
    &arp_table[arp_idx].ethaddr);
}
 800e01a:	b002      	add	sp, #8
 800e01c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
      arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING;
    }
  }
  
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr),
 800e020:	e6d2      	b.n	800ddc8 <etharp_send_ip>
              arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
  /* if arp table entry is about to expire: re-request it,
     but only if its state is ETHARP_STATE_STABLE to prevent flooding the
     network with ARP requests if this address is used frequently. */
  if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
      (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
 800e022:	eb07 0a04 	add.w	sl, r7, r4
 800e026:	eb05 0a8a 	add.w	sl, r5, sl, lsl #2
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
              arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
  /* if arp table entry is about to expire: re-request it,
     but only if its state is ETHARP_STATE_STABLE to prevent flooding the
     network with ARP requests if this address is used frequently. */
  if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
 800e02a:	f89a 3013 	ldrb.w	r3, [sl, #19]
err_t
etharp_request(struct netif *netif, ip_addr_t *ipaddr)
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
 800e02e:	f108 0623 	add.w	r6, r8, #35	; 0x23
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
              arp_table[arp_idx].state >= ETHARP_STATE_STABLE);
  /* if arp table entry is about to expire: re-request it,
     but only if its state is ETHARP_STATE_STABLE to prevent flooding the
     network with ARP requests if this address is used frequently. */
  if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
 800e032:	2be3      	cmp	r3, #227	; 0xe3
 800e034:	d9ea      	bls.n	800e00c <etharp_output_to_arp_index+0x24>
      (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
    if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
 800e036:	f10a 0304 	add.w	r3, sl, #4
 */
err_t
etharp_request(struct netif *netif, ip_addr_t *ipaddr)
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
 800e03a:	9300      	str	r3, [sp, #0]
 800e03c:	4632      	mov	r2, r6
 800e03e:	4631      	mov	r1, r6
 800e040:	f108 0304 	add.w	r3, r8, #4
 800e044:	4640      	mov	r0, r8
 800e046:	f7ff ff4d 	bl	800dee4 <etharp_raw.constprop.1>
  /* if arp table entry is about to expire: re-request it,
     but only if its state is ETHARP_STATE_STABLE to prevent flooding the
     network with ARP requests if this address is used frequently. */
  if ((arp_table[arp_idx].state == ETHARP_STATE_STABLE) && 
      (arp_table[arp_idx].ctime >= ARP_AGE_REREQUEST_USED)) {
    if (etharp_request(netif, &arp_table[arp_idx].ipaddr) == ERR_OK) {
 800e04a:	2800      	cmp	r0, #0
 800e04c:	d1de      	bne.n	800e00c <etharp_output_to_arp_index+0x24>
      arp_table[arp_idx].state = ETHARP_STATE_STABLE_REREQUESTING;
 800e04e:	2303      	movs	r3, #3
 800e050:	f88a 3012 	strb.w	r3, [sl, #18]
 800e054:	e7da      	b.n	800e00c <etharp_output_to_arp_index+0x24>
 * in the arp_table specified by the index 'arp_idx'.
 */
static err_t
etharp_output_to_arp_index(struct netif *netif, struct pbuf *q, u8_t arp_idx)
{
  LWIP_ASSERT("arp_table[arp_idx].state >= ETHARP_STATE_STABLE",
 800e056:	4b05      	ldr	r3, [pc, #20]	; (800e06c <etharp_output_to_arp_index+0x84>)
 800e058:	f240 324d 	movw	r2, #845	; 0x34d
 800e05c:	4904      	ldr	r1, [pc, #16]	; (800e070 <etharp_output_to_arp_index+0x88>)
 800e05e:	4805      	ldr	r0, [pc, #20]	; (800e074 <etharp_output_to_arp_index+0x8c>)
 800e060:	f006 fe8a 	bl	8014d78 <iprintf>
 800e064:	7cb3      	ldrb	r3, [r6, #18]
 800e066:	e7cd      	b.n	800e004 <etharp_output_to_arp_index+0x1c>
 800e068:	20000804 	.word	0x20000804
 800e06c:	080175a0 	.word	0x080175a0
 800e070:	080176e8 	.word	0x080176e8
 800e074:	0801660c 	.word	0x0801660c

0800e078 <etharp_tmr>:
 * This function should be called every ETHARP_TMR_INTERVAL milliseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
 800e078:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800e07c:	4d17      	ldr	r5, [pc, #92]	; (800e0dc <etharp_tmr+0x64>)
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
    arp_table[i].q = NULL;
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
 800e07e:	f04f 0800 	mov.w	r8, #0
 800e082:	f1a5 0412 	sub.w	r4, r5, #18
 800e086:	f104 06c8 	add.w	r6, r4, #200	; 0xc8
        etharp_free_entry(i);
      }
      else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING) {
        /* Reset state to stable, so that the next transmitted packet will
           re-send an ARP request. */
        arp_table[i].state = ETHARP_STATE_STABLE;
 800e08a:	2702      	movs	r7, #2
 800e08c:	e009      	b.n	800e0a2 <etharp_tmr+0x2a>
#if ETHARP_SUPPORT_STATIC_ENTRIES
      && (state != ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
      ) {
      arp_table[i].ctime++;
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
 800e08e:	2a01      	cmp	r2, #1
 800e090:	d020      	beq.n	800e0d4 <etharp_tmr+0x5c>
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: expired %s entry %"U16_F".\n",
             arp_table[i].state >= ETHARP_STATE_STABLE ? "stable" : "pending", (u16_t)i));
        /* clean up entries that have just been expired */
        etharp_free_entry(i);
      }
      else if (arp_table[i].state == ETHARP_STATE_STABLE_REREQUESTING) {
 800e092:	2a03      	cmp	r2, #3
        /* Reset state to stable, so that the next transmitted packet will
           re-send an ARP request. */
        arp_table[i].state = ETHARP_STATE_STABLE;
 800e094:	bf08      	it	eq
 800e096:	74a7      	strbeq	r7, [r4, #18]
 800e098:	3414      	adds	r4, #20
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 800e09a:	42b4      	cmp	r4, r6
 800e09c:	f105 0514 	add.w	r5, r5, #20
 800e0a0:	d016      	beq.n	800e0d0 <etharp_tmr+0x58>
    u8_t state = arp_table[i].state;
 800e0a2:	7ca2      	ldrb	r2, [r4, #18]
    if (state != ETHARP_STATE_EMPTY
 800e0a4:	2a00      	cmp	r2, #0
 800e0a6:	d0f7      	beq.n	800e098 <etharp_tmr+0x20>
#if ETHARP_SUPPORT_STATIC_ENTRIES
      && (state != ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
      ) {
      arp_table[i].ctime++;
 800e0a8:	7ce3      	ldrb	r3, [r4, #19]
 800e0aa:	3301      	adds	r3, #1
 800e0ac:	b2db      	uxtb	r3, r3
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
 800e0ae:	2bef      	cmp	r3, #239	; 0xef
    if (state != ETHARP_STATE_EMPTY
#if ETHARP_SUPPORT_STATIC_ENTRIES
      && (state != ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
      ) {
      arp_table[i].ctime++;
 800e0b0:	74e3      	strb	r3, [r4, #19]
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
 800e0b2:	d9ec      	bls.n	800e08e <etharp_tmr+0x16>
etharp_free_entry(int i)
{
  /* remove from SNMP ARP index tree */
  snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
 800e0b4:	f855 0c12 	ldr.w	r0, [r5, #-18]
 800e0b8:	b118      	cbz	r0, 800e0c2 <etharp_tmr+0x4a>
    /* remove all queued packets */
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
 800e0ba:	f7ff fd79 	bl	800dbb0 <free_etharp_q>
    arp_table[i].q = NULL;
 800e0be:	f845 8c12 	str.w	r8, [r5, #-18]
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
 800e0c2:	f884 8012 	strb.w	r8, [r4, #18]
 800e0c6:	3414      	adds	r4, #20
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 800e0c8:	42b4      	cmp	r4, r6
 800e0ca:	f105 0514 	add.w	r5, r5, #20
 800e0ce:	d1e8      	bne.n	800e0a2 <etharp_tmr+0x2a>
        /* resend an ARP query here? */
      }
#endif /* ARP_QUEUEING */
    }
  }
}
 800e0d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      && (state != ETHARP_STATE_STATIC)
#endif /* ETHARP_SUPPORT_STATIC_ENTRIES */
      ) {
      arp_table[i].ctime++;
      if ((arp_table[i].ctime >= ARP_MAXAGE) ||
          ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
 800e0d4:	2b01      	cmp	r3, #1
 800e0d6:	d8ed      	bhi.n	800e0b4 <etharp_tmr+0x3c>
 800e0d8:	e7de      	b.n	800e098 <etharp_tmr+0x20>
 800e0da:	bf00      	nop
 800e0dc:	20000816 	.word	0x20000816

0800e0e0 <etharp_cleanup_netif>:
 * Remove all ARP table entries of the specified netif.
 *
 * @param netif points to a network interface
 */
void etharp_cleanup_netif(struct netif *netif)
{
 800e0e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800e0e2:	4606      	mov	r6, r0
 800e0e4:	4c0a      	ldr	r4, [pc, #40]	; (800e110 <etharp_cleanup_netif+0x30>)
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
    arp_table[i].q = NULL;
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
 800e0e6:	2700      	movs	r7, #0
 800e0e8:	f104 05c8 	add.w	r5, r4, #200	; 0xc8
{
  u8_t i;

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    u8_t state = arp_table[i].state;
    if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
 800e0ec:	7aa3      	ldrb	r3, [r4, #10]
 800e0ee:	b113      	cbz	r3, 800e0f6 <etharp_cleanup_netif+0x16>
 800e0f0:	6823      	ldr	r3, [r4, #0]
 800e0f2:	42b3      	cmp	r3, r6
 800e0f4:	d003      	beq.n	800e0fe <etharp_cleanup_netif+0x1e>
 800e0f6:	3414      	adds	r4, #20
 */
void etharp_cleanup_netif(struct netif *netif)
{
  u8_t i;

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
 800e0f8:	42ac      	cmp	r4, r5
 800e0fa:	d1f7      	bne.n	800e0ec <etharp_cleanup_netif+0xc>
    u8_t state = arp_table[i].state;
    if ((state != ETHARP_STATE_EMPTY) && (arp_table[i].netif == netif)) {
      etharp_free_entry(i);
    }
  }
}
 800e0fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
etharp_free_entry(int i)
{
  /* remove from SNMP ARP index tree */
  snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  /* and empty packet queue */
  if (arp_table[i].q != NULL) {
 800e0fe:	f854 0c08 	ldr.w	r0, [r4, #-8]
 800e102:	b118      	cbz	r0, 800e10c <etharp_cleanup_netif+0x2c>
    /* remove all queued packets */
    LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_free_entry: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
 800e104:	f7ff fd54 	bl	800dbb0 <free_etharp_q>
    arp_table[i].q = NULL;
 800e108:	f844 7c08 	str.w	r7, [r4, #-8]
  }
  /* recycle entry for re-use */
  arp_table[i].state = ETHARP_STATE_EMPTY;
 800e10c:	72a7      	strb	r7, [r4, #10]
 800e10e:	e7f2      	b.n	800e0f6 <etharp_cleanup_netif+0x16>
 800e110:	2000080c 	.word	0x2000080c

0800e114 <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, ip_addr_t *ipaddr,
         struct eth_addr **eth_ret, ip_addr_t **ip_ret)
{
 800e114:	b570      	push	{r4, r5, r6, lr}
 800e116:	460e      	mov	r6, r1
 800e118:	461c      	mov	r4, r3
  s8_t i;

  LWIP_ASSERT("eth_ret != NULL && ip_ret != NULL",
 800e11a:	4615      	mov	r5, r2
 800e11c:	b1a2      	cbz	r2, 800e148 <etharp_find_addr+0x34>
 800e11e:	b19b      	cbz	r3, 800e148 <etharp_find_addr+0x34>
    eth_ret != NULL && ip_ret != NULL);

  LWIP_UNUSED_ARG(netif);

  i = etharp_find_entry(ipaddr, ETHARP_FLAG_FIND_ONLY);
 800e120:	4630      	mov	r0, r6
 800e122:	2102      	movs	r1, #2
 800e124:	f7ff fd78 	bl	800dc18 <etharp_find_entry>
  if((i >= 0) && (arp_table[i].state >= ETHARP_STATE_STABLE)) {
 800e128:	2800      	cmp	r0, #0
 800e12a:	db15      	blt.n	800e158 <etharp_find_addr+0x44>
 800e12c:	eb00 0380 	add.w	r3, r0, r0, lsl #2
 800e130:	490b      	ldr	r1, [pc, #44]	; (800e160 <etharp_find_addr+0x4c>)
 800e132:	009b      	lsls	r3, r3, #2
 800e134:	18ca      	adds	r2, r1, r3
 800e136:	7c96      	ldrb	r6, [r2, #18]
 800e138:	2e01      	cmp	r6, #1
 800e13a:	d90d      	bls.n	800e158 <etharp_find_addr+0x44>
      *eth_ret = &arp_table[i].ethaddr;
 800e13c:	4613      	mov	r3, r2
      *ip_ret = &arp_table[i].ipaddr;
 800e13e:	3204      	adds	r2, #4

  LWIP_UNUSED_ARG(netif);

  i = etharp_find_entry(ipaddr, ETHARP_FLAG_FIND_ONLY);
  if((i >= 0) && (arp_table[i].state >= ETHARP_STATE_STABLE)) {
      *eth_ret = &arp_table[i].ethaddr;
 800e140:	330c      	adds	r3, #12
 800e142:	602b      	str	r3, [r5, #0]
      *ip_ret = &arp_table[i].ipaddr;
 800e144:	6022      	str	r2, [r4, #0]
      return i;
 800e146:	bd70      	pop	{r4, r5, r6, pc}
etharp_find_addr(struct netif *netif, ip_addr_t *ipaddr,
         struct eth_addr **eth_ret, ip_addr_t **ip_ret)
{
  s8_t i;

  LWIP_ASSERT("eth_ret != NULL && ip_ret != NULL",
 800e148:	4b06      	ldr	r3, [pc, #24]	; (800e164 <etharp_find_addr+0x50>)
 800e14a:	f240 2261 	movw	r2, #609	; 0x261
 800e14e:	4906      	ldr	r1, [pc, #24]	; (800e168 <etharp_find_addr+0x54>)
 800e150:	4806      	ldr	r0, [pc, #24]	; (800e16c <etharp_find_addr+0x58>)
 800e152:	f006 fe11 	bl	8014d78 <iprintf>
 800e156:	e7e3      	b.n	800e120 <etharp_find_addr+0xc>
  if((i >= 0) && (arp_table[i].state >= ETHARP_STATE_STABLE)) {
      *eth_ret = &arp_table[i].ethaddr;
      *ip_ret = &arp_table[i].ipaddr;
      return i;
  }
  return -1;
 800e158:	f04f 30ff 	mov.w	r0, #4294967295
}
 800e15c:	bd70      	pop	{r4, r5, r6, pc}
 800e15e:	bf00      	nop
 800e160:	20000804 	.word	0x20000804
 800e164:	080175a0 	.word	0x080175a0
 800e168:	08017718 	.word	0x08017718
 800e16c:	0801660c 	.word	0x0801660c

0800e170 <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, ip_addr_t *ipaddr, struct pbuf *q)
{
 800e170:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800e174:	460c      	mov	r4, r1
 800e176:	b082      	sub	sp, #8
 800e178:	4606      	mov	r6, r0
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
 800e17a:	4601      	mov	r1, r0
 800e17c:	6820      	ldr	r0, [r4, #0]
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, ip_addr_t *ipaddr, struct pbuf *q)
{
 800e17e:	4690      	mov	r8, r2
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
 800e180:	f000 fdbc 	bl	800ecfc <ip4_addr_isbroadcast>
 800e184:	2800      	cmp	r0, #0
 800e186:	d157      	bne.n	800e238 <etharp_query+0xc8>
      ip_addr_ismulticast(ipaddr) ||
 800e188:	6823      	ldr	r3, [r4, #0]
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
 800e18a:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
 800e18e:	2ae0      	cmp	r2, #224	; 0xe0
 800e190:	d052      	beq.n	800e238 <etharp_query+0xc8>
      ip_addr_ismulticast(ipaddr) ||
      ip_addr_isany(ipaddr)) {
 800e192:	2b00      	cmp	r3, #0
 800e194:	d050      	beq.n	800e238 <etharp_query+0xc8>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  }

  /* find entry in ARP cache, ask to create entry if queueing packet */
  i = etharp_find_entry(ipaddr, ETHARP_FLAG_TRY_HARD);
 800e196:	2101      	movs	r1, #1
 800e198:	4620      	mov	r0, r4
 800e19a:	f7ff fd3d 	bl	800dc18 <etharp_find_entry>

  /* could not find or create entry? */
  if (i < 0) {
 800e19e:	1e05      	subs	r5, r0, #0
 800e1a0:	db46      	blt.n	800e230 <etharp_query+0xc0>
    }
    return (err_t)i;
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
 800e1a2:	00af      	lsls	r7, r5, #2
 800e1a4:	f8df 9130 	ldr.w	r9, [pc, #304]	; 800e2d8 <etharp_query+0x168>
 800e1a8:	197b      	adds	r3, r7, r5
 800e1aa:	eb09 0383 	add.w	r3, r9, r3, lsl #2
 800e1ae:	7c9a      	ldrb	r2, [r3, #18]
 800e1b0:	b19a      	cbz	r2, 800e1da <etharp_query+0x6a>
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state >= ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
 800e1b2:	2a01      	cmp	r2, #1
 *
 */
err_t
etharp_query(struct netif *netif, ip_addr_t *ipaddr, struct pbuf *q)
{
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
 800e1b4:	f106 0a23 	add.w	sl, r6, #35	; 0x23
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state >= ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
 800e1b8:	d013      	beq.n	800e1e2 <etharp_query+0x72>
 800e1ba:	f1b8 0f00 	cmp.w	r8, #0
 800e1be:	d06d      	beq.n	800e29c <etharp_query+0x12c>
  /* stable entry? */
  if (arp_table[i].state >= ETHARP_STATE_STABLE) {
    /* we have a valid IP->Ethernet address mapping */
    ETHARP_SET_HINT(netif, i);
    /* send the packet */
    result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
 800e1c0:	4652      	mov	r2, sl
 800e1c2:	4641      	mov	r1, r8
 800e1c4:	4630      	mov	r0, r6
 800e1c6:	197b      	adds	r3, r7, r5
 800e1c8:	eb09 0383 	add.w	r3, r9, r3, lsl #2
 800e1cc:	330c      	adds	r3, #12
  /* packet given? */
  LWIP_ASSERT("q != NULL", q != NULL);
  /* stable entry? */
  if (arp_table[i].state >= ETHARP_STATE_STABLE) {
    /* we have a valid IP->Ethernet address mapping */
    ETHARP_SET_HINT(netif, i);
 800e1ce:	f889 50c8 	strb.w	r5, [r9, #200]	; 0xc8
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
      result = ERR_MEM;
    }
  }
  return result;
}
 800e1d2:	b002      	add	sp, #8
 800e1d4:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  /* stable entry? */
  if (arp_table[i].state >= ETHARP_STATE_STABLE) {
    /* we have a valid IP->Ethernet address mapping */
    ETHARP_SET_HINT(netif, i);
    /* send the packet */
    result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
 800e1d8:	e5f6      	b.n	800ddc8 <etharp_send_ip>
    return (err_t)i;
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
    arp_table[i].state = ETHARP_STATE_PENDING;
 800e1da:	2201      	movs	r2, #1
 800e1dc:	749a      	strb	r2, [r3, #18]
 *
 */
err_t
etharp_query(struct netif *netif, ip_addr_t *ipaddr, struct pbuf *q)
{
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
 800e1de:	f106 0a23 	add.w	sl, r6, #35	; 0x23
 */
err_t
etharp_request(struct netif *netif, ip_addr_t *ipaddr)
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
 800e1e2:	9400      	str	r4, [sp, #0]
 800e1e4:	1d33      	adds	r3, r6, #4
 800e1e6:	4652      	mov	r2, sl
 800e1e8:	4651      	mov	r1, sl
 800e1ea:	4630      	mov	r0, r6
 800e1ec:	f7ff fe7a 	bl	800dee4 <etharp_raw.constprop.1>
      /* ARP request couldn't be sent */
      /* We don't re-send arp request in etharp_tmr, but we still queue packets,
         since this failure could be temporary, and the next packet calling
         etharp_query again could lead to sending the queued packets. */
    }
    if (q == NULL) {
 800e1f0:	f1b8 0f00 	cmp.w	r8, #0
 800e1f4:	d01d      	beq.n	800e232 <etharp_query+0xc2>
  }

  /* packet given? */
  LWIP_ASSERT("q != NULL", q != NULL);
  /* stable entry? */
  if (arp_table[i].state >= ETHARP_STATE_STABLE) {
 800e1f6:	197a      	adds	r2, r7, r5
 800e1f8:	eb09 0282 	add.w	r2, r9, r2, lsl #2
 800e1fc:	7c92      	ldrb	r2, [r2, #18]
 800e1fe:	2a01      	cmp	r2, #1
 800e200:	d8de      	bhi.n	800e1c0 <etharp_query+0x50>
    /* we have a valid IP->Ethernet address mapping */
    ETHARP_SET_HINT(netif, i);
    /* send the packet */
    result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  /* pending entry? (either just created or already pending */
  } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
 800e202:	d116      	bne.n	800e232 <etharp_query+0xc2>
 800e204:	4644      	mov	r4, r8
 800e206:	e005      	b.n	800e214 <etharp_query+0xa4>
     * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
     * PBUF_ROMs can be left as they are, since ROM must not get changed. */
    p = q;
    while (p) {
      LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
      if(p->type != PBUF_ROM) {
 800e208:	7b23      	ldrb	r3, [r4, #12]
 800e20a:	2b01      	cmp	r3, #1
 800e20c:	d156      	bne.n	800e2bc <etharp_query+0x14c>
        copy_needed = 1;
        break;
      }
      p = p->next;
 800e20e:	6824      	ldr	r4, [r4, #0]
    int copy_needed = 0;
    /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
     * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
     * PBUF_ROMs can be left as they are, since ROM must not get changed. */
    p = q;
    while (p) {
 800e210:	2c00      	cmp	r4, #0
 800e212:	d04b      	beq.n	800e2ac <etharp_query+0x13c>
      LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
 800e214:	8963      	ldrh	r3, [r4, #10]
 800e216:	8926      	ldrh	r6, [r4, #8]
 800e218:	42b3      	cmp	r3, r6
 800e21a:	d1f5      	bne.n	800e208 <etharp_query+0x98>
 800e21c:	6822      	ldr	r2, [r4, #0]
 800e21e:	4b2b      	ldr	r3, [pc, #172]	; (800e2cc <etharp_query+0x15c>)
 800e220:	492b      	ldr	r1, [pc, #172]	; (800e2d0 <etharp_query+0x160>)
 800e222:	482c      	ldr	r0, [pc, #176]	; (800e2d4 <etharp_query+0x164>)
 800e224:	b16a      	cbz	r2, 800e242 <etharp_query+0xd2>
 800e226:	f240 423e 	movw	r2, #1086	; 0x43e
 800e22a:	f006 fda5 	bl	8014d78 <iprintf>
 800e22e:	e7eb      	b.n	800e208 <etharp_query+0x98>
 800e230:	4628      	mov	r0, r5
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
      result = ERR_MEM;
    }
  }
  return result;
}
 800e232:	b002      	add	sp, #8
 800e234:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr) ||
      ip_addr_isany(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
 800e238:	f06f 000d 	mvn.w	r0, #13
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
      result = ERR_MEM;
    }
  }
  return result;
}
 800e23c:	b002      	add	sp, #8
 800e23e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
     * PBUF_ROMs can be left as they are, since ROM must not get changed. */
    p = q;
    while (p) {
      LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
      if(p->type != PBUF_ROM) {
 800e242:	7b23      	ldrb	r3, [r4, #12]
 800e244:	2b01      	cmp	r3, #1
 800e246:	d031      	beq.n	800e2ac <etharp_query+0x13c>
      }
      p = p->next;
    }
    if(copy_needed) {
      /* copy the whole packet into new pbufs */
      p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
 800e248:	4631      	mov	r1, r6
 800e24a:	2200      	movs	r2, #0
 800e24c:	2003      	movs	r0, #3
 800e24e:	f001 ff43 	bl	80100d8 <pbuf_alloc>
      if(p != NULL) {
 800e252:	4604      	mov	r4, r0
 800e254:	b1e8      	cbz	r0, 800e292 <etharp_query+0x122>
        if (pbuf_copy(p, q) != ERR_OK) {
 800e256:	4641      	mov	r1, r8
 800e258:	f002 f928 	bl	80104ac <pbuf_copy>
 800e25c:	b9b0      	cbnz	r0, 800e28c <etharp_query+0x11c>
    if (p != NULL) {
      /* queue packet ... */
#if ARP_QUEUEING
      struct etharp_q_entry *new_entry;
      /* allocate a new arp queue entry */
      new_entry = (struct etharp_q_entry *)memp_malloc(MEMP_ARP_QUEUE);
 800e25e:	200a      	movs	r0, #10
 800e260:	f001 fd16 	bl	800fc90 <memp_malloc>
      if (new_entry != NULL) {
 800e264:	b360      	cbz	r0, 800e2c0 <etharp_query+0x150>
        new_entry->next = 0;
        new_entry->p = p;
        if(arp_table[i].q != NULL) {
 800e266:	442f      	add	r7, r5
 800e268:	00bf      	lsls	r7, r7, #2
 800e26a:	f859 5007 	ldr.w	r5, [r9, r7]
#if ARP_QUEUEING
      struct etharp_q_entry *new_entry;
      /* allocate a new arp queue entry */
      new_entry = (struct etharp_q_entry *)memp_malloc(MEMP_ARP_QUEUE);
      if (new_entry != NULL) {
        new_entry->next = 0;
 800e26e:	2300      	movs	r3, #0
 800e270:	e880 0018 	stmia.w	r0, {r3, r4}
        new_entry->p = p;
        if(arp_table[i].q != NULL) {
 800e274:	4b18      	ldr	r3, [pc, #96]	; (800e2d8 <etharp_query+0x168>)
 800e276:	b90d      	cbnz	r5, 800e27c <etharp_query+0x10c>
 800e278:	e01d      	b.n	800e2b6 <etharp_query+0x146>
 800e27a:	461d      	mov	r5, r3
          /* queue was already existent, append the new entry to the end */
          struct etharp_q_entry *r;
          r = arp_table[i].q;
          while (r->next != NULL) {
 800e27c:	682b      	ldr	r3, [r5, #0]
 800e27e:	2b00      	cmp	r3, #0
 800e280:	d1fb      	bne.n	800e27a <etharp_query+0x10a>
            r = r->next;
          }
          r->next = new_entry;
 800e282:	6028      	str	r0, [r5, #0]
        } else {
          /* queue did not exist, first item in queue */
          arp_table[i].q = new_entry;
        }
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
        result = ERR_OK;
 800e284:	4618      	mov	r0, r3
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
      result = ERR_MEM;
    }
  }
  return result;
}
 800e286:	b002      	add	sp, #8
 800e288:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if(copy_needed) {
      /* copy the whole packet into new pbufs */
      p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
      if(p != NULL) {
        if (pbuf_copy(p, q) != ERR_OK) {
          pbuf_free(p);
 800e28c:	4620      	mov	r0, r4
 800e28e:	f001 fecb 	bl	8010028 <pbuf_free>
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
#endif /* ARP_QUEUEING */
    } else {
      ETHARP_STATS_INC(etharp.memerr);
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
      result = ERR_MEM;
 800e292:	f04f 30ff 	mov.w	r0, #4294967295
    }
  }
  return result;
}
 800e296:	b002      	add	sp, #8
 800e298:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 */
err_t
etharp_request(struct netif *netif, ip_addr_t *ipaddr)
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
 800e29c:	9400      	str	r4, [sp, #0]
 800e29e:	1d33      	adds	r3, r6, #4
 800e2a0:	4630      	mov	r0, r6
 800e2a2:	4652      	mov	r2, sl
 800e2a4:	4651      	mov	r1, sl
 800e2a6:	f7ff fe1d 	bl	800dee4 <etharp_raw.constprop.1>
 800e2aa:	e7c2      	b.n	800e232 <etharp_query+0xc2>
        }
      }
    } else {
      /* referencing the old pbuf is enough */
      p = q;
      pbuf_ref(p);
 800e2ac:	4640      	mov	r0, r8
 800e2ae:	f002 f86b 	bl	8010388 <pbuf_ref>
 800e2b2:	4644      	mov	r4, r8
 800e2b4:	e7d3      	b.n	800e25e <etharp_query+0xee>
            r = r->next;
          }
          r->next = new_entry;
        } else {
          /* queue did not exist, first item in queue */
          arp_table[i].q = new_entry;
 800e2b6:	51d8      	str	r0, [r3, r7]
        }
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
        result = ERR_OK;
 800e2b8:	4628      	mov	r0, r5
 800e2ba:	e7ba      	b.n	800e232 <etharp_query+0xc2>
 800e2bc:	8926      	ldrh	r6, [r4, #8]
 800e2be:	e7c3      	b.n	800e248 <etharp_query+0xd8>
      } else {
        /* the pool MEMP_ARP_QUEUE is empty */
        pbuf_free(p);
 800e2c0:	4620      	mov	r0, r4
 800e2c2:	f001 feb1 	bl	8010028 <pbuf_free>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
        result = ERR_MEM;
 800e2c6:	f04f 30ff 	mov.w	r0, #4294967295
 800e2ca:	e7b2      	b.n	800e232 <etharp_query+0xc2>
 800e2cc:	080175a0 	.word	0x080175a0
 800e2d0:	0801773c 	.word	0x0801773c
 800e2d4:	0801660c 	.word	0x0801660c
 800e2d8:	20000804 	.word	0x20000804

0800e2dc <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, ip_addr_t *ipaddr)
{
 800e2dc:	b5f0      	push	{r4, r5, r6, r7, lr}
 800e2de:	460e      	mov	r6, r1
 800e2e0:	b083      	sub	sp, #12
 800e2e2:	4614      	mov	r4, r2
  struct eth_addr *dest;
  struct eth_addr mcastaddr;
  ip_addr_t *dst_addr = ipaddr;

  LWIP_ASSERT("netif != NULL", netif != NULL);
 800e2e4:	4605      	mov	r5, r0
 800e2e6:	2800      	cmp	r0, #0
 800e2e8:	d064      	beq.n	800e3b4 <etharp_output+0xd8>
  LWIP_ASSERT("q != NULL", q != NULL);
 800e2ea:	2e00      	cmp	r6, #0
 800e2ec:	d06b      	beq.n	800e3c6 <etharp_output+0xea>
  LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
 800e2ee:	2c00      	cmp	r4, #0
 800e2f0:	d07e      	beq.n	800e3f0 <etharp_output+0x114>

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
 800e2f2:	210e      	movs	r1, #14
 800e2f4:	4630      	mov	r0, r6
 800e2f6:	f001 fe3f 	bl	800ff78 <pbuf_header>
 800e2fa:	2800      	cmp	r0, #0
 800e2fc:	d175      	bne.n	800e3ea <etharp_output+0x10e>

  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
 800e2fe:	4629      	mov	r1, r5
 800e300:	6820      	ldr	r0, [r4, #0]
 800e302:	f000 fcfb 	bl	800ecfc <ip4_addr_isbroadcast>
 800e306:	2800      	cmp	r0, #0
 800e308:	d136      	bne.n	800e378 <etharp_output+0x9c>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
 800e30a:	6823      	ldr	r3, [r4, #0]
 800e30c:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
 800e310:	2ae0      	cmp	r2, #224	; 0xe0
 800e312:	d03a      	beq.n	800e38a <etharp_output+0xae>
  /* unicast destination IP address? */
  } else {
    s8_t i;
    /* outside local network? if so, this can neither be a global broadcast nor
       a subnet broadcast. */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask)) &&
 800e314:	686a      	ldr	r2, [r5, #4]
 800e316:	68a9      	ldr	r1, [r5, #8]
 800e318:	405a      	eors	r2, r3
 800e31a:	420a      	tst	r2, r1
 800e31c:	d009      	beq.n	800e332 <etharp_output+0x56>
 800e31e:	f64f 62a9 	movw	r2, #65193	; 0xfea9
 800e322:	b29b      	uxth	r3, r3
 800e324:	4293      	cmp	r3, r2
 800e326:	d004      	beq.n	800e332 <etharp_output+0x56>
         router for forwarding". */
      if (!ip_addr_islinklocal(&iphdr->src))
#endif /* LWIP_AUTOIP */
      {
        /* interface has default gateway? */
        if (!ip_addr_isany(&netif->gw)) {
 800e328:	68eb      	ldr	r3, [r5, #12]
 800e32a:	f105 040c 	add.w	r4, r5, #12
 800e32e:	2b00      	cmp	r3, #0
 800e330:	d066      	beq.n	800e400 <etharp_output+0x124>
    if (netif->addr_hint != NULL) {
      /* per-pcb cached entry was given */
      u8_t etharp_cached_entry = *(netif->addr_hint);
      if (etharp_cached_entry < ARP_TABLE_SIZE) {
#endif /* LWIP_NETIF_HWADDRHINT */
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
 800e332:	4f37      	ldr	r7, [pc, #220]	; (800e410 <etharp_output+0x134>)
 800e334:	f897 20c8 	ldrb.w	r2, [r7, #200]	; 0xc8
 800e338:	eb02 0382 	add.w	r3, r2, r2, lsl #2
 800e33c:	eb07 0383 	add.w	r3, r7, r3, lsl #2
 800e340:	7c99      	ldrb	r1, [r3, #18]
 800e342:	2901      	cmp	r1, #1
 800e344:	d903      	bls.n	800e34e <etharp_output+0x72>
 800e346:	685b      	ldr	r3, [r3, #4]
 800e348:	6821      	ldr	r1, [r4, #0]
 800e34a:	4299      	cmp	r1, r3
 800e34c:	d05b      	beq.n	800e406 <etharp_output+0x12a>
 800e34e:	4b30      	ldr	r3, [pc, #192]	; (800e410 <etharp_output+0x134>)
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, ip_addr_t *ipaddr)
{
 800e350:	2200      	movs	r2, #0
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
 800e352:	7c99      	ldrb	r1, [r3, #18]
 800e354:	2901      	cmp	r1, #1
 800e356:	d903      	bls.n	800e360 <etharp_output+0x84>
 800e358:	6820      	ldr	r0, [r4, #0]
 800e35a:	6859      	ldr	r1, [r3, #4]
 800e35c:	4288      	cmp	r0, r1
 800e35e:	d03a      	beq.n	800e3d6 <etharp_output+0xfa>
 800e360:	3201      	adds	r2, #1
    }
#endif /* LWIP_NETIF_HWADDRHINT */

    /* find stable entry: do this here since this is a critical path for
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
 800e362:	2a0a      	cmp	r2, #10
 800e364:	f103 0314 	add.w	r3, r3, #20
 800e368:	d1f3      	bne.n	800e352 <etharp_output+0x76>
        return etharp_output_to_arp_index(netif, q, i);
      }
    }
    /* no stable entry found, use the (slower) query function:
       queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, dst_addr, q);
 800e36a:	4632      	mov	r2, r6
 800e36c:	4621      	mov	r1, r4
 800e36e:	4628      	mov	r0, r5
 800e370:	f7ff fefe 	bl	800e170 <etharp_query>

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
}
 800e374:	b003      	add	sp, #12
 800e376:	bdf0      	pop	{r4, r5, r6, r7, pc}
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
 800e378:	4b26      	ldr	r3, [pc, #152]	; (800e414 <etharp_output+0x138>)
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
 800e37a:	4631      	mov	r1, r6
 800e37c:	f105 0223 	add.w	r2, r5, #35	; 0x23
 800e380:	4628      	mov	r0, r5
 800e382:	f7ff fd21 	bl	800ddc8 <etharp_send_ip>
}
 800e386:	b003      	add	sp, #12
 800e388:	bdf0      	pop	{r4, r5, r6, r7, pc}
  } else if (ip_addr_ismulticast(ipaddr)) {
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
    mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
    mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
 800e38a:	7863      	ldrb	r3, [r4, #1]
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
 800e38c:	78a7      	ldrb	r7, [r4, #2]
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
 800e38e:	78e4      	ldrb	r4, [r4, #3]
  } else if (ip_addr_ismulticast(ipaddr)) {
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
    mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
    mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
 800e390:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
 800e394:	2101      	movs	r1, #1
    mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
    mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
 800e396:	225e      	movs	r2, #94	; 0x5e
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
 800e398:	f88d 3003 	strb.w	r3, [sp, #3]
    dest = (struct eth_addr *)&ethbroadcast;
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
    mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
 800e39c:	f88d 0001 	strb.w	r0, [sp, #1]
    mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
 800e3a0:	f88d 7004 	strb.w	r7, [sp, #4]
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
 800e3a4:	f88d 4005 	strb.w	r4, [sp, #5]
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = LL_MULTICAST_ADDR_0;
 800e3a8:	f88d 1000 	strb.w	r1, [sp]
    mcastaddr.addr[1] = LL_MULTICAST_ADDR_1;
    mcastaddr.addr[2] = LL_MULTICAST_ADDR_2;
 800e3ac:	f88d 2002 	strb.w	r2, [sp, #2]
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
 800e3b0:	466b      	mov	r3, sp
 800e3b2:	e7e2      	b.n	800e37a <etharp_output+0x9e>
{
  struct eth_addr *dest;
  struct eth_addr mcastaddr;
  ip_addr_t *dst_addr = ipaddr;

  LWIP_ASSERT("netif != NULL", netif != NULL);
 800e3b4:	4b18      	ldr	r3, [pc, #96]	; (800e418 <etharp_output+0x13c>)
 800e3b6:	f240 3275 	movw	r2, #885	; 0x375
 800e3ba:	4918      	ldr	r1, [pc, #96]	; (800e41c <etharp_output+0x140>)
 800e3bc:	4818      	ldr	r0, [pc, #96]	; (800e420 <etharp_output+0x144>)
 800e3be:	f006 fcdb 	bl	8014d78 <iprintf>
  LWIP_ASSERT("q != NULL", q != NULL);
 800e3c2:	2e00      	cmp	r6, #0
 800e3c4:	d193      	bne.n	800e2ee <etharp_output+0x12>
 800e3c6:	4b14      	ldr	r3, [pc, #80]	; (800e418 <etharp_output+0x13c>)
 800e3c8:	f240 3276 	movw	r2, #886	; 0x376
 800e3cc:	4915      	ldr	r1, [pc, #84]	; (800e424 <etharp_output+0x148>)
 800e3ce:	4814      	ldr	r0, [pc, #80]	; (800e420 <etharp_output+0x144>)
 800e3d0:	f006 fcd2 	bl	8014d78 <iprintf>
 800e3d4:	e78b      	b.n	800e2ee <etharp_output+0x12>
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
          (ip_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
        /* found an existing, stable entry */
        ETHARP_SET_HINT(netif, i);
 800e3d6:	b2d3      	uxtb	r3, r2
        return etharp_output_to_arp_index(netif, q, i);
 800e3d8:	461a      	mov	r2, r3
 800e3da:	4631      	mov	r1, r6
 800e3dc:	4628      	mov	r0, r5
       throughput and etharp_find_entry() is kind of slow */
    for (i = 0; i < ARP_TABLE_SIZE; i++) {
      if ((arp_table[i].state >= ETHARP_STATE_STABLE) &&
          (ip_addr_cmp(dst_addr, &arp_table[i].ipaddr))) {
        /* found an existing, stable entry */
        ETHARP_SET_HINT(netif, i);
 800e3de:	f887 30c8 	strb.w	r3, [r7, #200]	; 0xc8
        return etharp_output_to_arp_index(netif, q, i);
 800e3e2:	f7ff fe01 	bl	800dfe8 <etharp_output_to_arp_index>

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
}
 800e3e6:	b003      	add	sp, #12
 800e3e8:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
    /* bail out */
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
      ("etharp_output: could not allocate room for header.\n"));
    LINK_STATS_INC(link.lenerr);
    return ERR_BUF;
 800e3ea:	f06f 0001 	mvn.w	r0, #1
 800e3ee:	e7c1      	b.n	800e374 <etharp_output+0x98>
  struct eth_addr mcastaddr;
  ip_addr_t *dst_addr = ipaddr;

  LWIP_ASSERT("netif != NULL", netif != NULL);
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("ipaddr != NULL", ipaddr != NULL);
 800e3f0:	4b09      	ldr	r3, [pc, #36]	; (800e418 <etharp_output+0x13c>)
 800e3f2:	f240 3277 	movw	r2, #887	; 0x377
 800e3f6:	490c      	ldr	r1, [pc, #48]	; (800e428 <etharp_output+0x14c>)
 800e3f8:	4809      	ldr	r0, [pc, #36]	; (800e420 <etharp_output+0x144>)
 800e3fa:	f006 fcbd 	bl	8014d78 <iprintf>
 800e3fe:	e778      	b.n	800e2f2 <etharp_output+0x16>
          /* send to hardware address of default gateway IP address */
          dst_addr = &(netif->gw);
        /* no default gateway available */
        } else {
          /* no route to destination error (default gateway missing) */
          return ERR_RTE;
 800e400:	f06f 0003 	mvn.w	r0, #3
 800e404:	e7b6      	b.n	800e374 <etharp_output+0x98>
#endif /* LWIP_NETIF_HWADDRHINT */
        if ((arp_table[etharp_cached_entry].state >= ETHARP_STATE_STABLE) &&
            (ip_addr_cmp(dst_addr, &arp_table[etharp_cached_entry].ipaddr))) {
          /* the per-pcb-cached entry is stable and the right one! */
          ETHARP_STATS_INC(etharp.cachehit);
          return etharp_output_to_arp_index(netif, q, etharp_cached_entry);
 800e406:	4631      	mov	r1, r6
 800e408:	4628      	mov	r0, r5
 800e40a:	f7ff fded 	bl	800dfe8 <etharp_output_to_arp_index>
 800e40e:	e7b1      	b.n	800e374 <etharp_output+0x98>
 800e410:	20000804 	.word	0x20000804
 800e414:	0801619c 	.word	0x0801619c
 800e418:	080175a0 	.word	0x080175a0
 800e41c:	080176a4 	.word	0x080176a4
 800e420:	0801660c 	.word	0x0801660c
 800e424:	080175b4 	.word	0x080175b4
 800e428:	08017758 	.word	0x08017758

0800e42c <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, ip_addr_t *ipaddr)
{
 800e42c:	4603      	mov	r3, r0
 800e42e:	b500      	push	{lr}
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
 800e430:	f100 0223 	add.w	r2, r0, #35	; 0x23
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, ip_addr_t *ipaddr)
{
 800e434:	b083      	sub	sp, #12
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
 800e436:	9100      	str	r1, [sp, #0]
 800e438:	3304      	adds	r3, #4
 800e43a:	4611      	mov	r1, r2
 800e43c:	f7ff fd52 	bl	800dee4 <etharp_raw.constprop.1>
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
 800e440:	b003      	add	sp, #12
 800e442:	f85d fb04 	ldr.w	pc, [sp], #4
 800e446:	bf00      	nop

0800e448 <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
 800e448:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  u16_t type;
#if LWIP_ARP || ETHARP_SUPPORT_VLAN
  s16_t ip_hdr_offset = SIZEOF_ETH_HDR;
#endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */

  if (p->len <= SIZEOF_ETH_HDR) {
 800e44c:	8943      	ldrh	r3, [r0, #10]
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
 800e44e:	b083      	sub	sp, #12
  u16_t type;
#if LWIP_ARP || ETHARP_SUPPORT_VLAN
  s16_t ip_hdr_offset = SIZEOF_ETH_HDR;
#endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */

  if (p->len <= SIZEOF_ETH_HDR) {
 800e450:	2b0e      	cmp	r3, #14
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
 800e452:	4604      	mov	r4, r0
  u16_t type;
#if LWIP_ARP || ETHARP_SUPPORT_VLAN
  s16_t ip_hdr_offset = SIZEOF_ETH_HDR;
#endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */

  if (p->len <= SIZEOF_ETH_HDR) {
 800e454:	d919      	bls.n	800e48a <ethernet_input+0x42>
    ETHARP_STATS_INC(etharp.drop);
    goto free_and_return;
  }

  /* points to packet payload, which starts with an Ethernet header */
  ethhdr = (struct eth_hdr *)p->payload;
 800e456:	6840      	ldr	r0, [r0, #4]
 800e458:	460e      	mov	r6, r1

#if LWIP_ARP_FILTER_NETIF
  netif = LWIP_ARP_FILTER_NETIF_FN(p, netif, htons(type));
#endif /* LWIP_ARP_FILTER_NETIF*/

  if (ethhdr->dest.addr[0] & 1) {
 800e45a:	7803      	ldrb	r3, [r0, #0]
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  type = ethhdr->type;
 800e45c:	8985      	ldrh	r5, [r0, #12]

#if LWIP_ARP_FILTER_NETIF
  netif = LWIP_ARP_FILTER_NETIF_FN(p, netif, htons(type));
#endif /* LWIP_ARP_FILTER_NETIF*/

  if (ethhdr->dest.addr[0] & 1) {
 800e45e:	07d9      	lsls	r1, r3, #31
 800e460:	d50a      	bpl.n	800e478 <ethernet_input+0x30>
    /* this might be a multicast or broadcast packet */
    if (ethhdr->dest.addr[0] == LL_MULTICAST_ADDR_0) {
 800e462:	2b01      	cmp	r3, #1
 800e464:	d035      	beq.n	800e4d2 <ethernet_input+0x8a>
      if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) &&
          (ethhdr->dest.addr[2] == LL_MULTICAST_ADDR_2)) {
        /* mark the pbuf as link-layer multicast */
        p->flags |= PBUF_FLAG_LLMCAST;
      }
    } else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
 800e466:	2206      	movs	r2, #6
 800e468:	495d      	ldr	r1, [pc, #372]	; (800e5e0 <ethernet_input+0x198>)
 800e46a:	f006 fc63 	bl	8014d34 <memcmp>
 800e46e:	b918      	cbnz	r0, 800e478 <ethernet_input+0x30>
      /* mark the pbuf as link-layer broadcast */
      p->flags |= PBUF_FLAG_LLBCAST;
 800e470:	7b63      	ldrb	r3, [r4, #13]
 800e472:	f043 0308 	orr.w	r3, r3, #8
 800e476:	7363      	strb	r3, [r4, #13]
    }
  }

  switch (type) {
 800e478:	2d08      	cmp	r5, #8
 800e47a:	d00d      	beq.n	800e498 <ethernet_input+0x50>
 800e47c:	f5b5 6fc1 	cmp.w	r5, #1544	; 0x608
 800e480:	d103      	bne.n	800e48a <ethernet_input+0x42>
        ip_input(p, netif);
      }
      break;
      
    case PP_HTONS(ETHTYPE_ARP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
 800e482:	f896 3029 	ldrb.w	r3, [r6, #41]	; 0x29
 800e486:	069b      	lsls	r3, r3, #26
 800e488:	d42e      	bmi.n	800e4e8 <ethernet_input+0xa0>
  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;

free_and_return:
  pbuf_free(p);
 800e48a:	4620      	mov	r0, r4
 800e48c:	f001 fdcc 	bl	8010028 <pbuf_free>
  return ERR_OK;
}
 800e490:	2000      	movs	r0, #0
 800e492:	b003      	add	sp, #12
 800e494:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

  switch (type) {
#if LWIP_ARP
    /* IP packet? */
    case PP_HTONS(ETHTYPE_IP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
 800e498:	f896 3029 	ldrb.w	r3, [r6, #41]	; 0x29
 800e49c:	069a      	lsls	r2, r3, #26
 800e49e:	d5f4      	bpl.n	800e48a <ethernet_input+0x42>
  ip_addr_t iphdr_src;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);

  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  ethhdr = (struct eth_hdr *)p->payload;
 800e4a0:	6862      	ldr	r2, [r4, #4]
#endif /* ETHARP_SUPPORT_VLAN */

  ip_addr_copy(iphdr_src, iphdr->src);

  /* source is not on the local network? */
  if (!ip_addr_netcmp(&iphdr_src, &(netif->ip_addr), &(netif->netmask))) {
 800e4a2:	6873      	ldr	r3, [r6, #4]
  if (ethhdr->type == PP_HTONS(ETHTYPE_VLAN)) {
    iphdr = (struct ip_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  ip_addr_copy(iphdr_src, iphdr->src);
 800e4a4:	f8d2 101a 	ldr.w	r1, [r2, #26]

  /* source is not on the local network? */
  if (!ip_addr_netcmp(&iphdr_src, &(netif->ip_addr), &(netif->netmask))) {
 800e4a8:	68b0      	ldr	r0, [r6, #8]
 800e4aa:	404b      	eors	r3, r1
 800e4ac:	4203      	tst	r3, r0
  if (ethhdr->type == PP_HTONS(ETHTYPE_VLAN)) {
    iphdr = (struct ip_hdr *)((u8_t*)ethhdr + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  ip_addr_copy(iphdr_src, iphdr->src);
 800e4ae:	9101      	str	r1, [sp, #4]

  /* source is not on the local network? */
  if (!ip_addr_netcmp(&iphdr_src, &(netif->ip_addr), &(netif->netmask))) {
 800e4b0:	f000 8085 	beq.w	800e5be <ethernet_input+0x176>
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -ip_hdr_offset)) {
 800e4b4:	f06f 010d 	mvn.w	r1, #13
 800e4b8:	4620      	mov	r0, r4
 800e4ba:	f001 fd5d 	bl	800ff78 <pbuf_header>
 800e4be:	2800      	cmp	r0, #0
 800e4c0:	d078      	beq.n	800e5b4 <ethernet_input+0x16c>
        LWIP_ASSERT("Can't move over header in packet", 0);
 800e4c2:	4b48      	ldr	r3, [pc, #288]	; (800e5e4 <ethernet_input+0x19c>)
 800e4c4:	f240 524f 	movw	r2, #1359	; 0x54f
 800e4c8:	4947      	ldr	r1, [pc, #284]	; (800e5e8 <ethernet_input+0x1a0>)
 800e4ca:	4848      	ldr	r0, [pc, #288]	; (800e5ec <ethernet_input+0x1a4>)
 800e4cc:	f006 fc54 	bl	8014d78 <iprintf>
        goto free_and_return;
 800e4d0:	e7db      	b.n	800e48a <ethernet_input+0x42>
#endif /* LWIP_ARP_FILTER_NETIF*/

  if (ethhdr->dest.addr[0] & 1) {
    /* this might be a multicast or broadcast packet */
    if (ethhdr->dest.addr[0] == LL_MULTICAST_ADDR_0) {
      if ((ethhdr->dest.addr[1] == LL_MULTICAST_ADDR_1) &&
 800e4d2:	7843      	ldrb	r3, [r0, #1]
 800e4d4:	2b00      	cmp	r3, #0
 800e4d6:	d1cf      	bne.n	800e478 <ethernet_input+0x30>
 800e4d8:	7883      	ldrb	r3, [r0, #2]
 800e4da:	2b5e      	cmp	r3, #94	; 0x5e
 800e4dc:	d1cc      	bne.n	800e478 <ethernet_input+0x30>
          (ethhdr->dest.addr[2] == LL_MULTICAST_ADDR_2)) {
        /* mark the pbuf as link-layer multicast */
        p->flags |= PBUF_FLAG_LLMCAST;
 800e4de:	7b63      	ldrb	r3, [r4, #13]
 800e4e0:	f043 0310 	orr.w	r3, r3, #16
 800e4e4:	7363      	strb	r3, [r4, #13]
 800e4e6:	e7c7      	b.n	800e478 <ethernet_input+0x30>

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);

  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < SIZEOF_ETHARP_PACKET) {
 800e4e8:	8963      	ldrh	r3, [r4, #10]
 800e4ea:	2b29      	cmp	r3, #41	; 0x29
 800e4ec:	d9cd      	bls.n	800e48a <ethernet_input+0x42>
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
    return;
  }

  ethhdr = (struct eth_hdr *)p->payload;
 800e4ee:	6865      	ldr	r5, [r4, #4]
    hdr = (struct etharp_hdr *)(((u8_t*)ethhdr) + SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR);
  }
#endif /* ETHARP_SUPPORT_VLAN */

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != PP_HTONS(HWTYPE_ETHERNET)) ||
 800e4f0:	89eb      	ldrh	r3, [r5, #14]
 800e4f2:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800e4f6:	d1c8      	bne.n	800e48a <ethernet_input+0x42>
 800e4f8:	7cab      	ldrb	r3, [r5, #18]
 800e4fa:	2b06      	cmp	r3, #6
 800e4fc:	d1c5      	bne.n	800e48a <ethernet_input+0x42>
      (hdr->hwlen != ETHARP_HWADDR_LEN) ||
 800e4fe:	7cef      	ldrb	r7, [r5, #19]
 800e500:	2f04      	cmp	r7, #4
 800e502:	d1c2      	bne.n	800e48a <ethernet_input+0x42>
      (hdr->protolen != sizeof(ip_addr_t)) ||
 800e504:	8a2b      	ldrh	r3, [r5, #16]
 800e506:	2b08      	cmp	r3, #8
 800e508:	d1bf      	bne.n	800e48a <ethernet_input+0x42>
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
 800e50a:	f105 081c 	add.w	r8, r5, #28
 800e50e:	4641      	mov	r1, r8
 800e510:	463a      	mov	r2, r7
 800e512:	4668      	mov	r0, sp
  IPADDR2_COPY(&dipaddr, &hdr->dipaddr);
 800e514:	f105 0926 	add.w	r9, r5, #38	; 0x26
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  IPADDR2_COPY(&sipaddr, &hdr->sipaddr);
 800e518:	f006 fc1b 	bl	8014d52 <memcpy>
  IPADDR2_COPY(&dipaddr, &hdr->dipaddr);
 800e51c:	463a      	mov	r2, r7
 800e51e:	4649      	mov	r1, r9
 800e520:	a801      	add	r0, sp, #4
 800e522:	f006 fc16 	bl	8014d52 <memcpy>

  /* this interface is not configured? */
  if (ip_addr_isany(&netif->ip_addr)) {
 800e526:	6873      	ldr	r3, [r6, #4]
 800e528:	2b00      	cmp	r3, #0
 800e52a:	d04f      	beq.n	800e5cc <ethernet_input+0x184>
  /* ARP message directed to us?
      -> add IP address in ARP cache; assume requester wants to talk to us,
         can result in directly sending the queued packets for this host.
     ARP message not directed to us?
      ->  update the source IP address in the cache, if present */
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
 800e52c:	9a01      	ldr	r2, [sp, #4]
 800e52e:	f105 0716 	add.w	r7, r5, #22
 800e532:	4293      	cmp	r3, r2
 800e534:	d14c      	bne.n	800e5d0 <ethernet_input+0x188>
 800e536:	2301      	movs	r3, #1
 800e538:	4669      	mov	r1, sp
 800e53a:	463a      	mov	r2, r7
 800e53c:	4630      	mov	r0, r6
 800e53e:	f7ff fc6f 	bl	800de20 <etharp_update_arp_entry>
                   for_us ? ETHARP_FLAG_TRY_HARD : ETHARP_FLAG_FIND_ONLY);

  /* now act on the message itself */
  switch (hdr->opcode) {
 800e542:	8aab      	ldrh	r3, [r5, #20]
 800e544:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800e548:	d19f      	bne.n	800e48a <ethernet_input+0x42>

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
 800e54a:	2002      	movs	r0, #2
 800e54c:	f7ff fb24 	bl	800db98 <lwip_htons>

      IPADDR2_COPY(&hdr->dipaddr, &hdr->sipaddr);
 800e550:	2204      	movs	r2, #4

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
 800e552:	82a8      	strh	r0, [r5, #20]

      IPADDR2_COPY(&hdr->dipaddr, &hdr->sipaddr);
 800e554:	4641      	mov	r1, r8
 800e556:	4648      	mov	r0, r9
 800e558:	f006 fbfb 	bl	8014d52 <memcpy>
      IPADDR2_COPY(&hdr->sipaddr, &netif->ip_addr);
 800e55c:	2204      	movs	r2, #4
 800e55e:	4640      	mov	r0, r8
 800e560:	18b1      	adds	r1, r6, r2
 800e562:	f006 fbf6 	bl	8014d52 <memcpy>

      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
 800e566:	f896 3022 	ldrb.w	r3, [r6, #34]	; 0x22
 800e56a:	2b06      	cmp	r3, #6
 800e56c:	d006      	beq.n	800e57c <ethernet_input+0x134>
 800e56e:	4b1d      	ldr	r3, [pc, #116]	; (800e5e4 <ethernet_input+0x19c>)
 800e570:	f240 3212 	movw	r2, #786	; 0x312
 800e574:	491e      	ldr	r1, [pc, #120]	; (800e5f0 <ethernet_input+0x1a8>)
 800e576:	481d      	ldr	r0, [pc, #116]	; (800e5ec <ethernet_input+0x1a4>)
 800e578:	f006 fbfe 	bl	8014d78 <iprintf>
       * 'sender IP address' MUST be sent using link-layer broadcast instead of
       * link-layer unicast. (See RFC3927 Section 2.5, last paragraph) */
      ethdst_hwaddr = ip_addr_islinklocal(&netif->ip_addr) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      ETHADDR16_COPY(&hdr->dhwaddr, &hdr->shwaddr);
 800e57c:	4639      	mov	r1, r7
 800e57e:	2206      	movs	r2, #6
 800e580:	f105 0020 	add.w	r0, r5, #32
 800e584:	f006 fbe5 	bl	8014d52 <memcpy>
    case PP_HTONS(ETHTYPE_ARP):
      if (!(netif->flags & NETIF_FLAG_ETHARP)) {
        goto free_and_return;
      }
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
 800e588:	f106 0823 	add.w	r8, r6, #35	; 0x23

      ETHADDR16_COPY(&hdr->dhwaddr, &hdr->shwaddr);
#if LWIP_AUTOIP
      ETHADDR16_COPY(&ethhdr->dest, ethdst_hwaddr);
#else  /* LWIP_AUTOIP */
      ETHADDR16_COPY(&ethhdr->dest, &hdr->shwaddr);
 800e58c:	4639      	mov	r1, r7
 800e58e:	2206      	movs	r2, #6
 800e590:	4628      	mov	r0, r5
 800e592:	f006 fbde 	bl	8014d52 <memcpy>
#endif /* LWIP_AUTOIP */
      ETHADDR16_COPY(&hdr->shwaddr, ethaddr);
 800e596:	4641      	mov	r1, r8
 800e598:	4638      	mov	r0, r7
 800e59a:	2206      	movs	r2, #6
 800e59c:	f006 fbd9 	bl	8014d52 <memcpy>
      ETHADDR16_COPY(&ethhdr->src, ethaddr);
 800e5a0:	4641      	mov	r1, r8
 800e5a2:	1da8      	adds	r0, r5, #6
 800e5a4:	2206      	movs	r2, #6
 800e5a6:	f006 fbd4 	bl	8014d52 <memcpy>

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
 800e5aa:	69b3      	ldr	r3, [r6, #24]
 800e5ac:	4630      	mov	r0, r6
 800e5ae:	4621      	mov	r1, r4
 800e5b0:	4798      	blx	r3
 800e5b2:	e76a      	b.n	800e48a <ethernet_input+0x42>
      if(pbuf_header(p, -ip_hdr_offset)) {
        LWIP_ASSERT("Can't move over header in packet", 0);
        goto free_and_return;
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
 800e5b4:	4631      	mov	r1, r6
 800e5b6:	4620      	mov	r0, r4
 800e5b8:	f000 fa2a 	bl	800ea10 <ip_input>
      }
      break;
 800e5bc:	e768      	b.n	800e490 <ethernet_input+0x48>

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update the source IP address in the cache, if present */
  /* @todo We could use ETHARP_FLAG_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  etharp_update_arp_entry(netif, &iphdr_src, &(ethhdr->src), ETHARP_FLAG_FIND_ONLY);
 800e5be:	3206      	adds	r2, #6
 800e5c0:	2302      	movs	r3, #2
 800e5c2:	a901      	add	r1, sp, #4
 800e5c4:	4630      	mov	r0, r6
 800e5c6:	f7ff fc2b 	bl	800de20 <etharp_update_arp_entry>
 800e5ca:	e773      	b.n	800e4b4 <ethernet_input+0x6c>
  /* ARP message directed to us?
      -> add IP address in ARP cache; assume requester wants to talk to us,
         can result in directly sending the queued packets for this host.
     ARP message not directed to us?
      ->  update the source IP address in the cache, if present */
  etharp_update_arp_entry(netif, &sipaddr, &(hdr->shwaddr),
 800e5cc:	f105 0716 	add.w	r7, r5, #22
 800e5d0:	463a      	mov	r2, r7
 800e5d2:	4669      	mov	r1, sp
 800e5d4:	4630      	mov	r0, r6
 800e5d6:	2302      	movs	r3, #2
 800e5d8:	f7ff fc22 	bl	800de20 <etharp_update_arp_entry>
 800e5dc:	e755      	b.n	800e48a <ethernet_input+0x42>
 800e5de:	bf00      	nop
 800e5e0:	0801619c 	.word	0x0801619c
 800e5e4:	080175a0 	.word	0x080175a0
 800e5e8:	08017768 	.word	0x08017768
 800e5ec:	0801660c 	.word	0x0801660c
 800e5f0:	08017638 	.word	0x08017638

0800e5f4 <low_level_output>:
 *       dropped because of memory failure (except for the TCP timers).
 */

static err_t
low_level_output(struct netif *netif, struct pbuf *p)
{
 800e5f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800e5f6:	460c      	mov	r4, r1
	INT8U *buffer = NULL;

	SYS_ARCH_DECL_PROTECT(sr);
	/* Interrupts are disabled through this whole thing to support multi-threading
	   transmit calls. Also this function might be called from an ISR. */
	SYS_ARCH_PROTECT(sr);
 800e5f8:	f7f3 f8bc 	bl	8001774 <CPU_SR_Save>
 800e5fc:	4607      	mov	r7, r0
	buffer =  BSP_ETH_GetCurrentTxBuffer();
 800e5fe:	f7fe fe21 	bl	800d244 <BSP_ETH_GetCurrentTxBuffer>
  
	for(q = p; q != NULL; q = q->next)
 800e602:	b19c      	cbz	r4, 800e62c <low_level_output+0x38>
 800e604:	4606      	mov	r6, r0
 800e606:	2500      	movs	r5, #0
	{
		MEMCPY((INT8U*)&buffer[l], q->payload, q->len);
 800e608:	8962      	ldrh	r2, [r4, #10]
 800e60a:	6861      	ldr	r1, [r4, #4]
 800e60c:	1970      	adds	r0, r6, r5
 800e60e:	f006 fba0 	bl	8014d52 <memcpy>
		l = l + q->len;
 800e612:	8963      	ldrh	r3, [r4, #10]
	/* Interrupts are disabled through this whole thing to support multi-threading
	   transmit calls. Also this function might be called from an ISR. */
	SYS_ARCH_PROTECT(sr);
	buffer =  BSP_ETH_GetCurrentTxBuffer();
  
	for(q = p; q != NULL; q = q->next)
 800e614:	6824      	ldr	r4, [r4, #0]
	{
		MEMCPY((INT8U*)&buffer[l], q->payload, q->len);
		l = l + q->len;
 800e616:	441d      	add	r5, r3
	/* Interrupts are disabled through this whole thing to support multi-threading
	   transmit calls. Also this function might be called from an ISR. */
	SYS_ARCH_PROTECT(sr);
	buffer =  BSP_ETH_GetCurrentTxBuffer();
  
	for(q = p; q != NULL; q = q->next)
 800e618:	2c00      	cmp	r4, #0
 800e61a:	d1f5      	bne.n	800e608 <low_level_output+0x14>
 800e61c:	b2a8      	uxth	r0, r5
	{
		MEMCPY((INT8U*)&buffer[l], q->payload, q->len);
		l = l + q->len;
	}
	ETH_Prepare_Transmit_Descriptors(l);
 800e61e:	f003 ff4d 	bl	80124bc <ETH_Prepare_Transmit_Descriptors>
	SYS_ARCH_UNPROTECT(sr);
 800e622:	4638      	mov	r0, r7
 800e624:	f7f3 f8aa 	bl	800177c <CPU_SR_Restore>

	return ERR_OK;
}
 800e628:	2000      	movs	r0, #0
 800e62a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	/* Interrupts are disabled through this whole thing to support multi-threading
	   transmit calls. Also this function might be called from an ISR. */
	SYS_ARCH_PROTECT(sr);
	buffer =  BSP_ETH_GetCurrentTxBuffer();
  
	for(q = p; q != NULL; q = q->next)
 800e62c:	4620      	mov	r0, r4
 800e62e:	e7f6      	b.n	800e61e <low_level_output+0x2a>

0800e630 <ethernetif_input>:
 *
 * @param netif the lwip network interface structure for this ethernetif
 */
err_t
ethernetif_input(struct netif *netif)
{
 800e630:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800e634:	b088      	sub	sp, #32
 800e636:	4680      	mov	r8, r0
   err_t err;
  struct pbuf *p;
  SYS_ARCH_DECL_PROTECT(sr);
  
  SYS_ARCH_PROTECT(sr);
 800e638:	f7f3 f89c 	bl	8001774 <CPU_SR_Save>
	FrameTypeDef frame;
	INT8U*buffer;
 
    
	p = NULL;
	frame = ETH_Get_Received_Frame_interrupt();
 800e63c:	af05      	add	r7, sp, #20
{
   err_t err;
  struct pbuf *p;
  SYS_ARCH_DECL_PROTECT(sr);
  
  SYS_ARCH_PROTECT(sr);
 800e63e:	4681      	mov	r9, r0
	FrameTypeDef frame;
	INT8U*buffer;
 
    
	p = NULL;
	frame = ETH_Get_Received_Frame_interrupt();
 800e640:	4668      	mov	r0, sp
 800e642:	f003 fee7 	bl	8012414 <ETH_Get_Received_Frame_interrupt>
 800e646:	e89d 0007 	ldmia.w	sp, {r0, r1, r2}
 800e64a:	e887 0007 	stmia.w	r7, {r0, r1, r2}
	// check that frame has no error 
	if (BSP_ETH_GetDescriptorStatus(&frame))
 800e64e:	4638      	mov	r0, r7
 800e650:	f7fe ff86 	bl	800d560 <BSP_ETH_GetDescriptorStatus>
 800e654:	b360      	cbz	r0, 800e6b0 <ethernetif_input+0x80>
		len = frame.length;
    
		buffer = (u8 *)frame.buffer;
  
		/* We allocate a pbuf chain of pbufs from the pool. */
		p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
 800e656:	2203      	movs	r2, #3
 800e658:	4610      	mov	r0, r2
 800e65a:	f8bd 1014 	ldrh.w	r1, [sp, #20]
	{  
  		/* Obtain the size of the packet and put it into the "len"
    		 variable. */
		len = frame.length;
    
		buffer = (u8 *)frame.buffer;
 800e65e:	9e06      	ldr	r6, [sp, #24]
  
		/* We allocate a pbuf chain of pbufs from the pool. */
		p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
 800e660:	f001 fd3a 	bl	80100d8 <pbuf_alloc>
  
		if (p != NULL)
 800e664:	4682      	mov	sl, r0
 800e666:	b318      	cbz	r0, 800e6b0 <ethernetif_input+0x80>
 800e668:	4604      	mov	r4, r0
 800e66a:	2500      	movs	r5, #0
		{
			for (q = p; q != NULL; q = q->next)
			{
				MEMCPY((INT8U*)q->payload, (INT8U*)&buffer[l], q->len);
 800e66c:	8962      	ldrh	r2, [r4, #10]
 800e66e:	1971      	adds	r1, r6, r5
 800e670:	6860      	ldr	r0, [r4, #4]
 800e672:	f006 fb6e 	bl	8014d52 <memcpy>
				l = l + q->len;
 800e676:	8963      	ldrh	r3, [r4, #10]
		/* We allocate a pbuf chain of pbufs from the pool. */
		p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
  
		if (p != NULL)
		{
			for (q = p; q != NULL; q = q->next)
 800e678:	6824      	ldr	r4, [r4, #0]
			{
				MEMCPY((INT8U*)q->payload, (INT8U*)&buffer[l], q->len);
				l = l + q->len;
 800e67a:	441d      	add	r5, r3
		/* We allocate a pbuf chain of pbufs from the pool. */
		p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
  
		if (p != NULL)
		{
			for (q = p; q != NULL; q = q->next)
 800e67c:	2c00      	cmp	r4, #0
 800e67e:	d1f5      	bne.n	800e66c <ethernetif_input+0x3c>
				l = l + q->len;
			}    
		}
	}

	BSP_ETH_ReleaseDescriptor(&frame);
 800e680:	4638      	mov	r0, r7
 800e682:	f7fe ff47 	bl	800d514 <BSP_ETH_ReleaseDescriptor>
  SYS_ARCH_DECL_PROTECT(sr);
  
  SYS_ARCH_PROTECT(sr);
  /* move received packet into a new pbuf */
  p = low_level_input(netif);
  SYS_ARCH_UNPROTECT(sr);
 800e686:	4648      	mov	r0, r9
 800e688:	f7f3 f878 	bl	800177c <CPU_SR_Restore>

  /* no packet could be read, silently ignore this */
  if (p == NULL) return ERR_MEM;

  err = netif->input(p, netif);
 800e68c:	f8d8 3010 	ldr.w	r3, [r8, #16]
 800e690:	4641      	mov	r1, r8
 800e692:	4650      	mov	r0, sl
 800e694:	4798      	blx	r3
  if (err != ERR_OK){
 800e696:	4605      	mov	r5, r0
 800e698:	b918      	cbnz	r0, 800e6a2 <ethernetif_input+0x72>
 800e69a:	4620      	mov	r0, r4
    pbuf_free(p);
    p = NULL;
  }

  return err;
}
 800e69c:	b008      	add	sp, #32
 800e69e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  if (p == NULL) return ERR_MEM;

  err = netif->input(p, netif);
  if (err != ERR_OK){
    LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
    pbuf_free(p);
 800e6a2:	4650      	mov	r0, sl
 800e6a4:	f001 fcc0 	bl	8010028 <pbuf_free>
 800e6a8:	4628      	mov	r0, r5
    p = NULL;
  }

  return err;
}
 800e6aa:	b008      	add	sp, #32
 800e6ac:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				l = l + q->len;
			}    
		}
	}

	BSP_ETH_ReleaseDescriptor(&frame);
 800e6b0:	4638      	mov	r0, r7
 800e6b2:	f7fe ff2f 	bl	800d514 <BSP_ETH_ReleaseDescriptor>
  SYS_ARCH_DECL_PROTECT(sr);
  
  SYS_ARCH_PROTECT(sr);
  /* move received packet into a new pbuf */
  p = low_level_input(netif);
  SYS_ARCH_UNPROTECT(sr);
 800e6b6:	4648      	mov	r0, r9
 800e6b8:	f7f3 f860 	bl	800177c <CPU_SR_Restore>

  /* no packet could be read, silently ignore this */
  if (p == NULL) return ERR_MEM;
 800e6bc:	f04f 30ff 	mov.w	r0, #4294967295
    pbuf_free(p);
    p = NULL;
  }

  return err;
}
 800e6c0:	b008      	add	sp, #32
 800e6c2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800e6c6:	bf00      	nop

0800e6c8 <ethernetif_init>:
 *         ERR_MEM if private data couldn't be allocated
 *         any other err_t on error
 */
err_t
ethernetif_init(struct netif *netif)
{
 800e6c8:	b5f0      	push	{r4, r5, r6, r7, lr}
	INT32U MAC_addr_buff[3];
  	LWIP_ASSERT("netif != NULL", (netif != NULL));
 800e6ca:	4604      	mov	r4, r0
 *         ERR_MEM if private data couldn't be allocated
 *         any other err_t on error
 */
err_t
ethernetif_init(struct netif *netif)
{
 800e6cc:	b085      	sub	sp, #20
	INT32U MAC_addr_buff[3];
  	LWIP_ASSERT("netif != NULL", (netif != NULL));
 800e6ce:	2800      	cmp	r0, #0
 800e6d0:	d037      	beq.n	800e742 <ethernetif_init+0x7a>
  netif->output = etharp_output;
  netif->linkoutput = low_level_output;
  /* set MAC hardware address length */
  netif->hwaddr_len = ETHARP_HWADDR_LEN;
  /* maximum transfer unit */
  netif->mtu = 1500;
 800e6d2:	f240 56dc 	movw	r6, #1500	; 0x5dc
ethernetif_init(struct netif *netif)
{
	INT32U MAC_addr_buff[3];
  	LWIP_ASSERT("netif != NULL", (netif != NULL));

  	TOOL_GetCPI_ID(MAC_addr_buff);
 800e6d6:	a801      	add	r0, sp, #4
 800e6d8:	f006 f92c 	bl	8014934 <TOOL_GetCPI_ID>
	//ETH_MAC_ADDR[0] = (MAC_addr_buff[1] & 0x0000FF00)>>8;
	ETH_MAC_ADDR[0] = 0x00;
	ETH_MAC_ADDR[1] = (MAC_addr_buff[1] & 0x000000FF);
	ETH_MAC_ADDR[2] = (MAC_addr_buff[0] & 0xFF000000)>>24;
 800e6dc:	9b01      	ldr	r3, [sp, #4]
	INT32U MAC_addr_buff[3];
  	LWIP_ASSERT("netif != NULL", (netif != NULL));

  	TOOL_GetCPI_ID(MAC_addr_buff);
	//ETH_MAC_ADDR[0] = (MAC_addr_buff[1] & 0x0000FF00)>>8;
	ETH_MAC_ADDR[0] = 0x00;
 800e6de:	4a1c      	ldr	r2, [pc, #112]	; (800e750 <ethernetif_init+0x88>)
	ETH_MAC_ADDR[1] = (MAC_addr_buff[1] & 0x000000FF);
	ETH_MAC_ADDR[2] = (MAC_addr_buff[0] & 0xFF000000)>>24;
 800e6e0:	0e1f      	lsrs	r7, r3, #24
  /* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
  netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP ;

  	netif->hwaddr[0] =  ETH_MAC_ADDR[0];
  	netif->hwaddr[1] =  ETH_MAC_ADDR[1];
  	netif->hwaddr[2] =  ETH_MAC_ADDR[2];
 800e6e2:	f884 7025 	strb.w	r7, [r4, #37]	; 0x25

  	TOOL_GetCPI_ID(MAC_addr_buff);
	//ETH_MAC_ADDR[0] = (MAC_addr_buff[1] & 0x0000FF00)>>8;
	ETH_MAC_ADDR[0] = 0x00;
	ETH_MAC_ADDR[1] = (MAC_addr_buff[1] & 0x000000FF);
	ETH_MAC_ADDR[2] = (MAC_addr_buff[0] & 0xFF000000)>>24;
 800e6e6:	7097      	strb	r7, [r2, #2]

  /* We directly use etharp_output() here to save a function call.
   * You can instead declare your own function an call etharp_output()
   * from it if you have to do some checks before sending (e.g. if link
   * is available...) */
     netif->name[0] = IFNAME0;
 800e6e8:	2773      	movs	r7, #115	; 0x73
 800e6ea:	f884 702a 	strb.w	r7, [r4, #42]	; 0x2a
  netif->name[1] = IFNAME1;
  netif->output = etharp_output;
 800e6ee:	4819      	ldr	r0, [pc, #100]	; (800e754 <ethernetif_init+0x8c>)
  netif->linkoutput = low_level_output;
 800e6f0:	4d19      	ldr	r5, [pc, #100]	; (800e758 <ethernetif_init+0x90>)
  /* We directly use etharp_output() here to save a function call.
   * You can instead declare your own function an call etharp_output()
   * from it if you have to do some checks before sending (e.g. if link
   * is available...) */
     netif->name[0] = IFNAME0;
  netif->name[1] = IFNAME1;
 800e6f2:	2774      	movs	r7, #116	; 0x74
  	LWIP_ASSERT("netif != NULL", (netif != NULL));

  	TOOL_GetCPI_ID(MAC_addr_buff);
	//ETH_MAC_ADDR[0] = (MAC_addr_buff[1] & 0x0000FF00)>>8;
	ETH_MAC_ADDR[0] = 0x00;
	ETH_MAC_ADDR[1] = (MAC_addr_buff[1] & 0x000000FF);
 800e6f4:	f89d 1008 	ldrb.w	r1, [sp, #8]
  /* We directly use etharp_output() here to save a function call.
   * You can instead declare your own function an call etharp_output()
   * from it if you have to do some checks before sending (e.g. if link
   * is available...) */
     netif->name[0] = IFNAME0;
  netif->name[1] = IFNAME1;
 800e6f8:	f884 702b 	strb.w	r7, [r4, #43]	; 0x2b
  netif->output = etharp_output;
  netif->linkoutput = low_level_output;
  /* set MAC hardware address length */
  netif->hwaddr_len = ETHARP_HWADDR_LEN;
 800e6fc:	2706      	movs	r7, #6
  /* maximum transfer unit */
  netif->mtu = 1500;
 800e6fe:	8426      	strh	r6, [r4, #32]
   * You can instead declare your own function an call etharp_output()
   * from it if you have to do some checks before sending (e.g. if link
   * is available...) */
     netif->name[0] = IFNAME0;
  netif->name[1] = IFNAME1;
  netif->output = etharp_output;
 800e700:	6160      	str	r0, [r4, #20]
  	TOOL_GetCPI_ID(MAC_addr_buff);
	//ETH_MAC_ADDR[0] = (MAC_addr_buff[1] & 0x0000FF00)>>8;
	ETH_MAC_ADDR[0] = 0x00;
	ETH_MAC_ADDR[1] = (MAC_addr_buff[1] & 0x000000FF);
	ETH_MAC_ADDR[2] = (MAC_addr_buff[0] & 0xFF000000)>>24;
	ETH_MAC_ADDR[3] = (MAC_addr_buff[0] & 0x00FF0000)>>16;
 800e702:	f3c3 4607 	ubfx	r6, r3, #16, #8
	ETH_MAC_ADDR[4] = (MAC_addr_buff[0] & 0x0000FF00)>>8;
 800e706:	f3c3 2007 	ubfx	r0, r3, #8, #8
   * from it if you have to do some checks before sending (e.g. if link
   * is available...) */
     netif->name[0] = IFNAME0;
  netif->name[1] = IFNAME1;
  netif->output = etharp_output;
  netif->linkoutput = low_level_output;
 800e70a:	61a5      	str	r5, [r4, #24]
	ETH_MAC_ADDR[0] = 0x00;
	ETH_MAC_ADDR[1] = (MAC_addr_buff[1] & 0x000000FF);
	ETH_MAC_ADDR[2] = (MAC_addr_buff[0] & 0xFF000000)>>24;
	ETH_MAC_ADDR[3] = (MAC_addr_buff[0] & 0x00FF0000)>>16;
	ETH_MAC_ADDR[4] = (MAC_addr_buff[0] & 0x0000FF00)>>8;
	ETH_MAC_ADDR[5] = (MAC_addr_buff[0] & 0x000000FF);
 800e70c:	b2db      	uxtb	r3, r3
	INT32U MAC_addr_buff[3];
  	LWIP_ASSERT("netif != NULL", (netif != NULL));

  	TOOL_GetCPI_ID(MAC_addr_buff);
	//ETH_MAC_ADDR[0] = (MAC_addr_buff[1] & 0x0000FF00)>>8;
	ETH_MAC_ADDR[0] = 0x00;
 800e70e:	2500      	movs	r5, #0
     netif->name[0] = IFNAME0;
  netif->name[1] = IFNAME1;
  netif->output = etharp_output;
  netif->linkoutput = low_level_output;
  /* set MAC hardware address length */
  netif->hwaddr_len = ETHARP_HWADDR_LEN;
 800e710:	f884 7022 	strb.w	r7, [r4, #34]	; 0x22
  /* maximum transfer unit */
  netif->mtu = 1500;
  /* device capabilities */
  /* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
  netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP ;
 800e714:	2722      	movs	r7, #34	; 0x22

  	netif->hwaddr[0] =  ETH_MAC_ADDR[0];
  	netif->hwaddr[1] =  ETH_MAC_ADDR[1];
  	netif->hwaddr[2] =  ETH_MAC_ADDR[2];
  	netif->hwaddr[3] =  ETH_MAC_ADDR[3];
  	netif->hwaddr[4] =  ETH_MAC_ADDR[4];
 800e716:	f884 0027 	strb.w	r0, [r4, #39]	; 0x27
  /* device capabilities */
  /* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
  netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP ;

  	netif->hwaddr[0] =  ETH_MAC_ADDR[0];
  	netif->hwaddr[1] =  ETH_MAC_ADDR[1];
 800e71a:	f884 1024 	strb.w	r1, [r4, #36]	; 0x24
  	netif->hwaddr[2] =  ETH_MAC_ADDR[2];
  	netif->hwaddr[3] =  ETH_MAC_ADDR[3];
 800e71e:	f884 6026 	strb.w	r6, [r4, #38]	; 0x26
  	netif->hwaddr[4] =  ETH_MAC_ADDR[4];
 	netif->hwaddr[5] =  ETH_MAC_ADDR[5];
 800e722:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
  netif->mtu = 1500;
  /* device capabilities */
  /* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
  netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP ;

  	netif->hwaddr[0] =  ETH_MAC_ADDR[0];
 800e726:	f884 5023 	strb.w	r5, [r4, #35]	; 0x23
  netif->hwaddr_len = ETHARP_HWADDR_LEN;
  /* maximum transfer unit */
  netif->mtu = 1500;
  /* device capabilities */
  /* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
  netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP ;
 800e72a:	f884 7029 	strb.w	r7, [r4, #41]	; 0x29
	//ETH_MAC_ADDR[0] = (MAC_addr_buff[1] & 0x0000FF00)>>8;
	ETH_MAC_ADDR[0] = 0x00;
	ETH_MAC_ADDR[1] = (MAC_addr_buff[1] & 0x000000FF);
	ETH_MAC_ADDR[2] = (MAC_addr_buff[0] & 0xFF000000)>>24;
	ETH_MAC_ADDR[3] = (MAC_addr_buff[0] & 0x00FF0000)>>16;
	ETH_MAC_ADDR[4] = (MAC_addr_buff[0] & 0x0000FF00)>>8;
 800e72e:	7110      	strb	r0, [r2, #4]
  	TOOL_GetCPI_ID(MAC_addr_buff);
	//ETH_MAC_ADDR[0] = (MAC_addr_buff[1] & 0x0000FF00)>>8;
	ETH_MAC_ADDR[0] = 0x00;
	ETH_MAC_ADDR[1] = (MAC_addr_buff[1] & 0x000000FF);
	ETH_MAC_ADDR[2] = (MAC_addr_buff[0] & 0xFF000000)>>24;
	ETH_MAC_ADDR[3] = (MAC_addr_buff[0] & 0x00FF0000)>>16;
 800e730:	70d6      	strb	r6, [r2, #3]
	ETH_MAC_ADDR[4] = (MAC_addr_buff[0] & 0x0000FF00)>>8;
	ETH_MAC_ADDR[5] = (MAC_addr_buff[0] & 0x000000FF);
 800e732:	7153      	strb	r3, [r2, #5]
	INT32U MAC_addr_buff[3];
  	LWIP_ASSERT("netif != NULL", (netif != NULL));

  	TOOL_GetCPI_ID(MAC_addr_buff);
	//ETH_MAC_ADDR[0] = (MAC_addr_buff[1] & 0x0000FF00)>>8;
	ETH_MAC_ADDR[0] = 0x00;
 800e734:	7015      	strb	r5, [r2, #0]
	ETH_MAC_ADDR[1] = (MAC_addr_buff[1] & 0x000000FF);
 800e736:	7051      	strb	r1, [r2, #1]
  	netif->hwaddr[3] =  ETH_MAC_ADDR[3];
  	netif->hwaddr[4] =  ETH_MAC_ADDR[4];
 	netif->hwaddr[5] =  ETH_MAC_ADDR[5];
  
  /* initialize the hardware */
  BSP_InitEth();
 800e738:	f7fe fdea 	bl	800d310 <BSP_InitEth>

  etharp_init();

  return ERR_OK;
}
 800e73c:	4628      	mov	r0, r5
 800e73e:	b005      	add	sp, #20
 800e740:	bdf0      	pop	{r4, r5, r6, r7, pc}
 */
err_t
ethernetif_init(struct netif *netif)
{
	INT32U MAC_addr_buff[3];
  	LWIP_ASSERT("netif != NULL", (netif != NULL));
 800e742:	4b06      	ldr	r3, [pc, #24]	; (800e75c <ethernetif_init+0x94>)
 800e744:	22c9      	movs	r2, #201	; 0xc9
 800e746:	4906      	ldr	r1, [pc, #24]	; (800e760 <ethernetif_init+0x98>)
 800e748:	4806      	ldr	r0, [pc, #24]	; (800e764 <ethernetif_init+0x9c>)
 800e74a:	f006 fb15 	bl	8014d78 <iprintf>
 800e74e:	e7c0      	b.n	800e6d2 <ethernetif_init+0xa>
 800e750:	2000002c 	.word	0x2000002c
 800e754:	0800e2dd 	.word	0x0800e2dd
 800e758:	0800e5f5 	.word	0x0800e5f5
 800e75c:	0801778c 	.word	0x0801778c
 800e760:	080176a4 	.word	0x080176a4
 800e764:	0801660c 	.word	0x0801660c

0800e768 <lwip_standard_chksum>:
 * @return host order (!) lwip checksum (non-inverted Internet sum) 
 */

static u16_t
lwip_standard_chksum(void *dataptr, int len)
{
 800e768:	b470      	push	{r4, r5, r6}
  u8_t *pb = (u8_t *)dataptr;
  u16_t *ps, t = 0;
 800e76a:	2200      	movs	r2, #0
 * @return host order (!) lwip checksum (non-inverted Internet sum) 
 */

static u16_t
lwip_standard_chksum(void *dataptr, int len)
{
 800e76c:	b083      	sub	sp, #12
  u16_t *ps, t = 0;
  u32_t sum = 0;
  int odd = ((mem_ptr_t)pb & 1);

  /* Get aligned to u16_t */
  if (odd && len > 0) {
 800e76e:	f010 0601 	ands.w	r6, r0, #1

static u16_t
lwip_standard_chksum(void *dataptr, int len)
{
  u8_t *pb = (u8_t *)dataptr;
  u16_t *ps, t = 0;
 800e772:	f8ad 2006 	strh.w	r2, [sp, #6]
  u32_t sum = 0;
  int odd = ((mem_ptr_t)pb & 1);

  /* Get aligned to u16_t */
  if (odd && len > 0) {
 800e776:	d006      	beq.n	800e786 <lwip_standard_chksum+0x1e>
 800e778:	4291      	cmp	r1, r2
 800e77a:	dd1b      	ble.n	800e7b4 <lwip_standard_chksum+0x4c>
    ((u8_t *)&t)[1] = *pb++;
 800e77c:	7803      	ldrb	r3, [r0, #0]
    len--;
 800e77e:	3901      	subs	r1, #1
  u32_t sum = 0;
  int odd = ((mem_ptr_t)pb & 1);

  /* Get aligned to u16_t */
  if (odd && len > 0) {
    ((u8_t *)&t)[1] = *pb++;
 800e780:	f88d 3007 	strb.w	r3, [sp, #7]
 800e784:	3001      	adds	r0, #1
    len--;
  }

  /* Add the bulk of the data */
  ps = (u16_t *)(void *)pb;
  while (len > 1) {
 800e786:	2901      	cmp	r1, #1
 800e788:	dd27      	ble.n	800e7da <lwip_standard_chksum+0x72>
 800e78a:	4604      	mov	r4, r0
 800e78c:	460b      	mov	r3, r1
 800e78e:	2200      	movs	r2, #0
    sum += *ps++;
 800e790:	f834 5b02 	ldrh.w	r5, [r4], #2
    len -= 2;
 800e794:	3b02      	subs	r3, #2
    len--;
  }

  /* Add the bulk of the data */
  ps = (u16_t *)(void *)pb;
  while (len > 1) {
 800e796:	2b01      	cmp	r3, #1
    sum += *ps++;
 800e798:	442a      	add	r2, r5
    len--;
  }

  /* Add the bulk of the data */
  ps = (u16_t *)(void *)pb;
  while (len > 1) {
 800e79a:	dcf9      	bgt.n	800e790 <lwip_standard_chksum+0x28>
 800e79c:	3902      	subs	r1, #2
 800e79e:	084b      	lsrs	r3, r1, #1
 800e7a0:	1c5c      	adds	r4, r3, #1
 800e7a2:	eba1 0143 	sub.w	r1, r1, r3, lsl #1
 800e7a6:	eb00 0044 	add.w	r0, r0, r4, lsl #1
    sum += *ps++;
    len -= 2;
  }

  /* Consume left-over byte, if any */
  if (len > 0) {
 800e7aa:	2901      	cmp	r1, #1
    ((u8_t *)&t)[0] = *(u8_t *)ps;
 800e7ac:	bf04      	itt	eq
 800e7ae:	7803      	ldrbeq	r3, [r0, #0]
 800e7b0:	f88d 3006 	strbeq.w	r3, [sp, #6]
  }

  /* Add end bytes */
  sum += t;
 800e7b4:	f8bd 0006 	ldrh.w	r0, [sp, #6]
 800e7b8:	4402      	add	r2, r0

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  sum = FOLD_U32T(sum);
 800e7ba:	b290      	uxth	r0, r2
 800e7bc:	eb00 4212 	add.w	r2, r0, r2, lsr #16
  sum = FOLD_U32T(sum);
 800e7c0:	b293      	uxth	r3, r2
 800e7c2:	eb03 4012 	add.w	r0, r3, r2, lsr #16

  /* Swap if alignment was odd */
  if (odd) {
 800e7c6:	b126      	cbz	r6, 800e7d2 <lwip_standard_chksum+0x6a>
    sum = SWAP_BYTES_IN_WORD(sum);
 800e7c8:	0203      	lsls	r3, r0, #8
 800e7ca:	b29b      	uxth	r3, r3
 800e7cc:	f3c0 2007 	ubfx	r0, r0, #8, #8
 800e7d0:	4318      	orrs	r0, r3
  }

  return (u16_t)sum;
}
 800e7d2:	b280      	uxth	r0, r0
 800e7d4:	b003      	add	sp, #12
 800e7d6:	bc70      	pop	{r4, r5, r6}
 800e7d8:	4770      	bx	lr
static u16_t
lwip_standard_chksum(void *dataptr, int len)
{
  u8_t *pb = (u8_t *)dataptr;
  u16_t *ps, t = 0;
  u32_t sum = 0;
 800e7da:	2200      	movs	r2, #0
 800e7dc:	e7e5      	b.n	800e7aa <lwip_standard_chksum+0x42>
 800e7de:	bf00      	nop

0800e7e0 <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       ip_addr_t *src, ip_addr_t *dest,
       u8_t proto, u16_t proto_len)
{
 800e7e0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800e7e4:	468a      	mov	sl, r1
 800e7e6:	4691      	mov	r9, r2
 800e7e8:	4698      	mov	r8, r3
 800e7ea:	f8bd 7020 	ldrh.w	r7, [sp, #32]
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
 800e7ee:	4605      	mov	r5, r0
 800e7f0:	2800      	cmp	r0, #0
 800e7f2:	d03b      	beq.n	800e86c <inet_chksum_pseudo+0x8c>
 800e7f4:	2600      	movs	r6, #0
 800e7f6:	4634      	mov	r4, r6
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
 800e7f8:	8969      	ldrh	r1, [r5, #10]
 800e7fa:	6868      	ldr	r0, [r5, #4]
 800e7fc:	f7ff ffb4 	bl	800e768 <lwip_standard_chksum>
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
    if (q->len % 2 != 0) {
 800e800:	896b      	ldrh	r3, [r5, #10]
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
 800e802:	4420      	add	r0, r4
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
 800e804:	b284      	uxth	r4, r0
    if (q->len % 2 != 0) {
 800e806:	07db      	lsls	r3, r3, #31
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
 800e808:	eb04 4410 	add.w	r4, r4, r0, lsr #16
    if (q->len % 2 != 0) {
 800e80c:	d507      	bpl.n	800e81e <inet_chksum_pseudo+0x3e>
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
 800e80e:	0223      	lsls	r3, r4, #8
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
    if (q->len % 2 != 0) {
      swapped = 1 - swapped;
 800e810:	f1c6 0601 	rsb	r6, r6, #1
      acc = SWAP_BYTES_IN_WORD(acc);
 800e814:	b29b      	uxth	r3, r3
 800e816:	f3c4 2407 	ubfx	r4, r4, #8, #8
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
    if (q->len % 2 != 0) {
      swapped = 1 - swapped;
 800e81a:	b2f6      	uxtb	r6, r6
      acc = SWAP_BYTES_IN_WORD(acc);
 800e81c:	431c      	orrs	r4, r3
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
 800e81e:	682d      	ldr	r5, [r5, #0]
 800e820:	2d00      	cmp	r5, #0
 800e822:	d1e9      	bne.n	800e7f8 <inet_chksum_pseudo+0x18>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
 800e824:	b126      	cbz	r6, 800e830 <inet_chksum_pseudo+0x50>
    acc = SWAP_BYTES_IN_WORD(acc);
 800e826:	0223      	lsls	r3, r4, #8
 800e828:	b29b      	uxth	r3, r3
 800e82a:	f3c4 2407 	ubfx	r4, r4, #8, #8
 800e82e:	431c      	orrs	r4, r3
  }
  addr = ip4_addr_get_u32(src);
 800e830:	f8da 3000 	ldr.w	r3, [sl]
  acc += (addr & 0xffffUL);
  acc += ((addr >> 16) & 0xffffUL);
  addr = ip4_addr_get_u32(dest);
 800e834:	f8d9 1000 	ldr.w	r1, [r9]
  acc += (addr & 0xffffUL);
  acc += ((addr >> 16) & 0xffffUL);
 800e838:	b29a      	uxth	r2, r3
 800e83a:	eb02 4313 	add.w	r3, r2, r3, lsr #16
 800e83e:	b28a      	uxth	r2, r1
 800e840:	4413      	add	r3, r2
 800e842:	eb03 4311 	add.w	r3, r3, r1, lsr #16
  acc += (u32_t)htons((u16_t)proto);
 800e846:	4640      	mov	r0, r8
  addr = ip4_addr_get_u32(src);
  acc += (addr & 0xffffUL);
  acc += ((addr >> 16) & 0xffffUL);
  addr = ip4_addr_get_u32(dest);
  acc += (addr & 0xffffUL);
  acc += ((addr >> 16) & 0xffffUL);
 800e848:	441c      	add	r4, r3
  acc += (u32_t)htons((u16_t)proto);
 800e84a:	f7ff f9a5 	bl	800db98 <lwip_htons>
 800e84e:	4404      	add	r4, r0
  acc += (u32_t)htons(proto_len);
 800e850:	4638      	mov	r0, r7
 800e852:	f7ff f9a1 	bl	800db98 <lwip_htons>
 800e856:	4420      	add	r0, r4

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
 800e858:	b283      	uxth	r3, r0
 800e85a:	eb03 4010 	add.w	r0, r3, r0, lsr #16
  acc = FOLD_U32T(acc);
 800e85e:	b283      	uxth	r3, r0
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
 800e860:	eb03 4010 	add.w	r0, r3, r0, lsr #16
 800e864:	43c0      	mvns	r0, r0
}
 800e866:	b280      	uxth	r0, r0
 800e868:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  u32_t acc;
  u32_t addr;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
 800e86c:	4604      	mov	r4, r0
 800e86e:	e7df      	b.n	800e830 <inet_chksum_pseudo+0x50>

0800e870 <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       ip_addr_t *src, ip_addr_t *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
 800e870:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800e874:	b083      	sub	sp, #12
 800e876:	4699      	mov	r9, r3
 800e878:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
 800e87c:	468b      	mov	fp, r1
 800e87e:	4692      	mov	sl, r2
 800e880:	9301      	str	r3, [sp, #4]
 800e882:	f8bd 6034 	ldrh.w	r6, [sp, #52]	; 0x34
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
 800e886:	4605      	mov	r5, r0
 800e888:	2800      	cmp	r0, #0
 800e88a:	d053      	beq.n	800e934 <inet_chksum_pseudo_partial+0xc4>
 800e88c:	2e00      	cmp	r6, #0
 800e88e:	d053      	beq.n	800e938 <inet_chksum_pseudo_partial+0xc8>
 800e890:	2700      	movs	r7, #0
 800e892:	463c      	mov	r4, r7
 800e894:	e010      	b.n	800e8b8 <inet_chksum_pseudo_partial+0x48>
    chksum_len -= chklen;
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
    if (q->len % 2 != 0) {
 800e896:	896b      	ldrh	r3, [r5, #10]
    acc += LWIP_CHKSUM(q->payload, chklen);
    chksum_len -= chklen;
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
 800e898:	b2a2      	uxth	r2, r4
    if (q->len % 2 != 0) {
 800e89a:	07db      	lsls	r3, r3, #31
    acc += LWIP_CHKSUM(q->payload, chklen);
    chksum_len -= chklen;
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
 800e89c:	eb02 4414 	add.w	r4, r2, r4, lsr #16
    if (q->len % 2 != 0) {
 800e8a0:	d507      	bpl.n	800e8b2 <inet_chksum_pseudo_partial+0x42>
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
 800e8a2:	0223      	lsls	r3, r4, #8
 800e8a4:	b29b      	uxth	r3, r3
 800e8a6:	f3c4 2407 	ubfx	r4, r4, #8, #8
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
    if (q->len % 2 != 0) {
      swapped = 1 - swapped;
 800e8aa:	f1c7 0701 	rsb	r7, r7, #1
      acc = SWAP_BYTES_IN_WORD(acc);
 800e8ae:	431c      	orrs	r4, r3
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
    if (q->len % 2 != 0) {
      swapped = 1 - swapped;
 800e8b0:	b2ff      	uxtb	r7, r7
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
 800e8b2:	682d      	ldr	r5, [r5, #0]
 800e8b4:	b1cd      	cbz	r5, 800e8ea <inet_chksum_pseudo_partial+0x7a>
 800e8b6:	b1c6      	cbz	r6, 800e8ea <inet_chksum_pseudo_partial+0x7a>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    chklen = q->len;
 800e8b8:	896b      	ldrh	r3, [r5, #10]
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
 800e8ba:	6868      	ldr	r0, [r5, #4]
 800e8bc:	42b3      	cmp	r3, r6
 800e8be:	bf28      	it	cs
 800e8c0:	4633      	movcs	r3, r6
 800e8c2:	4698      	mov	r8, r3
 800e8c4:	4619      	mov	r1, r3
 800e8c6:	f7ff ff4f 	bl	800e768 <lwip_standard_chksum>
    chksum_len -= chklen;
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
 800e8ca:	f647 72fe 	movw	r2, #32766	; 0x7ffe
    chklen = q->len;
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
    chksum_len -= chklen;
 800e8ce:	ebc8 0606 	rsb	r6, r8, r6
 800e8d2:	b2b6      	uxth	r6, r6
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
 800e8d4:	4296      	cmp	r6, r2
      (void *)q, (void *)q->next));
    chklen = q->len;
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
 800e8d6:	4404      	add	r4, r0
    chksum_len -= chklen;
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
 800e8d8:	d9dd      	bls.n	800e896 <inet_chksum_pseudo_partial+0x26>
 800e8da:	4b18      	ldr	r3, [pc, #96]	; (800e93c <inet_chksum_pseudo_partial+0xcc>)
 800e8dc:	f44f 72b1 	mov.w	r2, #354	; 0x162
 800e8e0:	4917      	ldr	r1, [pc, #92]	; (800e940 <inet_chksum_pseudo_partial+0xd0>)
 800e8e2:	4818      	ldr	r0, [pc, #96]	; (800e944 <inet_chksum_pseudo_partial+0xd4>)
 800e8e4:	f006 fa48 	bl	8014d78 <iprintf>
 800e8e8:	e7d5      	b.n	800e896 <inet_chksum_pseudo_partial+0x26>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
 800e8ea:	b127      	cbz	r7, 800e8f6 <inet_chksum_pseudo_partial+0x86>
    acc = SWAP_BYTES_IN_WORD(acc);
 800e8ec:	0223      	lsls	r3, r4, #8
 800e8ee:	b29b      	uxth	r3, r3
 800e8f0:	f3c4 2407 	ubfx	r4, r4, #8, #8
 800e8f4:	431c      	orrs	r4, r3
  }
  addr = ip4_addr_get_u32(src);
 800e8f6:	f8db 3000 	ldr.w	r3, [fp]
  acc += (addr & 0xffffUL);
  acc += ((addr >> 16) & 0xffffUL);
  addr = ip4_addr_get_u32(dest);
 800e8fa:	f8da 1000 	ldr.w	r1, [sl]
  acc += (addr & 0xffffUL);
  acc += ((addr >> 16) & 0xffffUL);
 800e8fe:	b29a      	uxth	r2, r3
 800e900:	eb02 4313 	add.w	r3, r2, r3, lsr #16
 800e904:	b28a      	uxth	r2, r1
 800e906:	4413      	add	r3, r2
 800e908:	eb03 4311 	add.w	r3, r3, r1, lsr #16
  acc += (u32_t)htons((u16_t)proto);
 800e90c:	4648      	mov	r0, r9
  addr = ip4_addr_get_u32(src);
  acc += (addr & 0xffffUL);
  acc += ((addr >> 16) & 0xffffUL);
  addr = ip4_addr_get_u32(dest);
  acc += (addr & 0xffffUL);
  acc += ((addr >> 16) & 0xffffUL);
 800e90e:	441c      	add	r4, r3
  acc += (u32_t)htons((u16_t)proto);
 800e910:	f7ff f942 	bl	800db98 <lwip_htons>
 800e914:	4404      	add	r4, r0
  acc += (u32_t)htons(proto_len);
 800e916:	9801      	ldr	r0, [sp, #4]
 800e918:	f7ff f93e 	bl	800db98 <lwip_htons>
 800e91c:	4420      	add	r0, r4

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
 800e91e:	b283      	uxth	r3, r0
 800e920:	eb03 4010 	add.w	r0, r3, r0, lsr #16
  acc = FOLD_U32T(acc);
 800e924:	b283      	uxth	r3, r0
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
 800e926:	eb03 4010 	add.w	r0, r3, r0, lsr #16
 800e92a:	43c0      	mvns	r0, r0
}
 800e92c:	b280      	uxth	r0, r0
 800e92e:	b003      	add	sp, #12
 800e930:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
 800e934:	4604      	mov	r4, r0
 800e936:	e7de      	b.n	800e8f6 <inet_chksum_pseudo_partial+0x86>
 800e938:	4634      	mov	r4, r6
 800e93a:	e7dc      	b.n	800e8f6 <inet_chksum_pseudo_partial+0x86>
 800e93c:	080177a4 	.word	0x080177a4
 800e940:	080177c0 	.word	0x080177c0
 800e944:	0801660c 	.word	0x0801660c

0800e948 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
 800e948:	b508      	push	{r3, lr}
  return ~LWIP_CHKSUM(dataptr, len);
 800e94a:	f7ff ff0d 	bl	800e768 <lwip_standard_chksum>
 800e94e:	43c0      	mvns	r0, r0
}
 800e950:	b280      	uxth	r0, r0
 800e952:	bd08      	pop	{r3, pc}

0800e954 <inet_chksum_pbuf>:
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
 800e954:	b328      	cbz	r0, 800e9a2 <inet_chksum_pbuf+0x4e>
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
 800e956:	b570      	push	{r4, r5, r6, lr}
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
 800e958:	2600      	movs	r6, #0
 800e95a:	4605      	mov	r5, r0
 800e95c:	4634      	mov	r4, r6
    acc += LWIP_CHKSUM(q->payload, q->len);
 800e95e:	8969      	ldrh	r1, [r5, #10]
 800e960:	6868      	ldr	r0, [r5, #4]
 800e962:	f7ff ff01 	bl	800e768 <lwip_standard_chksum>
    acc = FOLD_U32T(acc);
    if (q->len % 2 != 0) {
 800e966:	896b      	ldrh	r3, [r5, #10]
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
    acc += LWIP_CHKSUM(q->payload, q->len);
 800e968:	4420      	add	r0, r4
    acc = FOLD_U32T(acc);
 800e96a:	b284      	uxth	r4, r0
    if (q->len % 2 != 0) {
 800e96c:	07db      	lsls	r3, r3, #31

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
    acc += LWIP_CHKSUM(q->payload, q->len);
    acc = FOLD_U32T(acc);
 800e96e:	eb04 4410 	add.w	r4, r4, r0, lsr #16
    if (q->len % 2 != 0) {
 800e972:	d507      	bpl.n	800e984 <inet_chksum_pbuf+0x30>
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
 800e974:	0223      	lsls	r3, r4, #8
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
    acc += LWIP_CHKSUM(q->payload, q->len);
    acc = FOLD_U32T(acc);
    if (q->len % 2 != 0) {
      swapped = 1 - swapped;
 800e976:	f1c6 0601 	rsb	r6, r6, #1
      acc = SWAP_BYTES_IN_WORD(acc);
 800e97a:	b29b      	uxth	r3, r3
 800e97c:	f3c4 2407 	ubfx	r4, r4, #8, #8
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
    acc += LWIP_CHKSUM(q->payload, q->len);
    acc = FOLD_U32T(acc);
    if (q->len % 2 != 0) {
      swapped = 1 - swapped;
 800e980:	b2f6      	uxtb	r6, r6
      acc = SWAP_BYTES_IN_WORD(acc);
 800e982:	431c      	orrs	r4, r3
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
 800e984:	682d      	ldr	r5, [r5, #0]
 800e986:	2d00      	cmp	r5, #0
 800e988:	d1e9      	bne.n	800e95e <inet_chksum_pbuf+0xa>
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    }
  }

  if (swapped) {
 800e98a:	b13e      	cbz	r6, 800e99c <inet_chksum_pbuf+0x48>
    acc = SWAP_BYTES_IN_WORD(acc);
 800e98c:	0220      	lsls	r0, r4, #8
 800e98e:	b280      	uxth	r0, r0
 800e990:	f3c4 2407 	ubfx	r4, r4, #8, #8
 800e994:	4320      	orrs	r0, r4
 800e996:	43c0      	mvns	r0, r0
 800e998:	b280      	uxth	r0, r0
 800e99a:	bd70      	pop	{r4, r5, r6, pc}
 800e99c:	43e0      	mvns	r0, r4
 800e99e:	b280      	uxth	r0, r0
 800e9a0:	bd70      	pop	{r4, r5, r6, pc}
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
 800e9a2:	f64f 70ff 	movw	r0, #65535	; 0xffff
 800e9a6:	4770      	bx	lr

0800e9a8 <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
 800e9a8:	b508      	push	{r3, lr}
  /* Modules initialization */
  stats_init();
#if !NO_SYS
  sys_init();
 800e9aa:	f004 fc3d 	bl	8013228 <sys_init>
#endif /* !NO_SYS */
  mem_init();
 800e9ae:	f000 fefb 	bl	800f7a8 <mem_init>
  memp_init();
 800e9b2:	f001 f935 	bl	800fc20 <memp_init>
  pbuf_init();
  netif_init();
 800e9b6:	f7f4 fed9 	bl	800376c <netif_init>
#if LWIP_SOCKET
  lwip_socket_init();
 800e9ba:	f002 fbcd 	bl	8011158 <lwip_socket_init>
#endif /* LWIP_ARP */
#if LWIP_RAW
  raw_init();
#endif /* LWIP_RAW */
#if LWIP_UDP
  udp_init();
 800e9be:	f005 fd0f 	bl	80143e0 <udp_init>
#endif /* LWIP_UDP */
#if LWIP_TCP
  tcp_init();
 800e9c2:	f7fa fd7f 	bl	80094c4 <tcp_init>
#endif /* LWIP_DNS */

#if LWIP_TIMERS
  sys_timeouts_init();
#endif /* LWIP_TIMERS */
}
 800e9c6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */

#if LWIP_TIMERS
  sys_timeouts_init();
 800e9ca:	f7fc be69 	b.w	800b6a0 <sys_timeouts_init>
 800e9ce:	bf00      	nop

0800e9d0 <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(ip_addr_t *dest)
{
 800e9d0:	b410      	push	{r4}
    return netif;
  }
#endif

  /* iterate through netifs */
  for (netif = netif_list; netif != NULL; netif = netif->next) {
 800e9d2:	4b0d      	ldr	r3, [pc, #52]	; (800ea08 <ip_route+0x38>)
 800e9d4:	681b      	ldr	r3, [r3, #0]
 800e9d6:	b163      	cbz	r3, 800e9f2 <ip_route+0x22>
    /* network mask matches? */
    if (netif_is_up(netif)) {
 800e9d8:	f893 2029 	ldrb.w	r2, [r3, #41]	; 0x29
 800e9dc:	07d2      	lsls	r2, r2, #31
 800e9de:	d5f9      	bpl.n	800e9d4 <ip_route+0x4>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
 800e9e0:	6804      	ldr	r4, [r0, #0]
 800e9e2:	685a      	ldr	r2, [r3, #4]
 800e9e4:	6899      	ldr	r1, [r3, #8]
 800e9e6:	4062      	eors	r2, r4
 800e9e8:	420a      	tst	r2, r1
 800e9ea:	d1f3      	bne.n	800e9d4 <ip_route+0x4>
 800e9ec:	4618      	mov	r0, r3
    snmp_inc_ipoutnoroutes();
    return NULL;
  }
  /* no matching netif found, use default netif */
  return netif_default;
}
 800e9ee:	bc10      	pop	{r4}
 800e9f0:	4770      	bx	lr
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
 800e9f2:	4b06      	ldr	r3, [pc, #24]	; (800ea0c <ip_route+0x3c>)
 800e9f4:	6818      	ldr	r0, [r3, #0]
 800e9f6:	b128      	cbz	r0, 800ea04 <ip_route+0x34>
 800e9f8:	f890 3029 	ldrb.w	r3, [r0, #41]	; 0x29
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_route: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
 800e9fc:	f013 0f01 	tst.w	r3, #1
 800ea00:	bf08      	it	eq
 800ea02:	2000      	moveq	r0, #0
  }
  /* no matching netif found, use default netif */
  return netif_default;
}
 800ea04:	bc10      	pop	{r4}
 800ea06:	4770      	bx	lr
 800ea08:	2000d940 	.word	0x2000d940
 800ea0c:	2000d944 	.word	0x2000d944

0800ea10 <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
 800ea10:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = (struct ip_hdr *)p->payload;
 800ea14:	f8d0 a004 	ldr.w	sl, [r0, #4]
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
 800ea18:	4607      	mov	r7, r0
  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = (struct ip_hdr *)p->payload;
  if (IPH_V(iphdr) != 4) {
 800ea1a:	f89a 3000 	ldrb.w	r3, [sl]
 800ea1e:	091a      	lsrs	r2, r3, #4
 800ea20:	2a04      	cmp	r2, #4
 800ea22:	d005      	beq.n	800ea30 <ip_input+0x20>
    LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
 800ea24:	4638      	mov	r0, r7
 800ea26:	f001 faff 	bl	8010028 <pbuf_free>
  current_header = NULL;
  ip_addr_set_any(&current_iphdr_src);
  ip_addr_set_any(&current_iphdr_dest);

  return ERR_OK;
}
 800ea2a:	2000      	movs	r0, #0
 800ea2c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
 800ea30:	f8ba 0002 	ldrh.w	r0, [sl, #2]
    return ERR_OK;
  }
#endif

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
 800ea34:	f003 040f 	and.w	r4, r3, #15
 800ea38:	460e      	mov	r6, r1
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
 800ea3a:	f7ff f8b1 	bl	800dba0 <lwip_ntohs>

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
 800ea3e:	897b      	ldrh	r3, [r7, #10]
 800ea40:	ebb3 0f84 	cmp.w	r3, r4, lsl #2
 800ea44:	d3ee      	bcc.n	800ea24 <ip_input+0x14>
 800ea46:	893b      	ldrh	r3, [r7, #8]
 800ea48:	4283      	cmp	r3, r0
 800ea4a:	d3eb      	bcc.n	800ea24 <ip_input+0x14>
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);

  /* copy IP addresses to aligned ip_addr_t */
  ip_addr_copy(current_iphdr_dest, iphdr->dest);
  ip_addr_copy(current_iphdr_src, iphdr->src);
 800ea4c:	4634      	mov	r4, r6
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
 800ea4e:	4601      	mov	r1, r0
 800ea50:	4638      	mov	r0, r7
 800ea52:	f001 fc23 	bl	801029c <pbuf_realloc>

  /* copy IP addresses to aligned ip_addr_t */
  ip_addr_copy(current_iphdr_dest, iphdr->dest);
 800ea56:	f8df 8110 	ldr.w	r8, [pc, #272]	; 800eb68 <ip_input+0x158>
 800ea5a:	f8da 3010 	ldr.w	r3, [sl, #16]
  ip_addr_copy(current_iphdr_src, iphdr->src);
 800ea5e:	f8df 90fc 	ldr.w	r9, [pc, #252]	; 800eb5c <ip_input+0x14c>
  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);

  /* copy IP addresses to aligned ip_addr_t */
  ip_addr_copy(current_iphdr_dest, iphdr->dest);
 800ea62:	f8c8 3000 	str.w	r3, [r8]
  ip_addr_copy(current_iphdr_src, iphdr->src);
 800ea66:	f8da 300c 	ldr.w	r3, [sl, #12]
        }
#endif /* LWIP_AUTOIP */
      }
      if (first) {
        first = 0;
        netif = netif_list;
 800ea6a:	f8df b100 	ldr.w	fp, [pc, #256]	; 800eb6c <ip_input+0x15c>
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);

  /* copy IP addresses to aligned ip_addr_t */
  ip_addr_copy(current_iphdr_dest, iphdr->dest);
  ip_addr_copy(current_iphdr_src, iphdr->src);
 800ea6e:	f8c9 3000 	str.w	r3, [r9]
#endif /* LWIP_IGMP */
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
 800ea72:	2501      	movs	r5, #1
          ip4_addr_get_u32(&iphdr->dest) & ip4_addr_get_u32(&netif->netmask),
          ip4_addr_get_u32(&netif->ip_addr) & ip4_addr_get_u32(&netif->netmask),
          ip4_addr_get_u32(&iphdr->dest) & ~ip4_addr_get_u32(&netif->netmask)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
 800ea74:	f894 3029 	ldrb.w	r3, [r4, #41]	; 0x29
 800ea78:	07db      	lsls	r3, r3, #31
 800ea7a:	d509      	bpl.n	800ea90 <ip_input+0x80>
 800ea7c:	6863      	ldr	r3, [r4, #4]
 800ea7e:	b13b      	cbz	r3, 800ea90 <ip_input+0x80>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
 800ea80:	f8d8 0000 	ldr.w	r0, [r8]
 800ea84:	4283      	cmp	r3, r0
 800ea86:	d00d      	beq.n	800eaa4 <ip_input+0x94>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&current_iphdr_dest, netif)) {
 800ea88:	4621      	mov	r1, r4
 800ea8a:	f000 f937 	bl	800ecfc <ip4_addr_isbroadcast>
          ip4_addr_get_u32(&iphdr->dest) & ~ip4_addr_get_u32(&netif->netmask)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&current_iphdr_dest, &(netif->ip_addr)) ||
 800ea8e:	b948      	cbnz	r0, 800eaa4 <ip_input+0x94>
          /* break out of for loop */
          break;
        }
#endif /* LWIP_AUTOIP */
      }
      if (first) {
 800ea90:	2d00      	cmp	r5, #0
 800ea92:	d052      	beq.n	800eb3a <ip_input+0x12a>
        first = 0;
        netif = netif_list;
 800ea94:	f8db 4000 	ldr.w	r4, [fp]
      } else {
        netif = netif->next;
      }
      if (netif == inp) {
 800ea98:	42b4      	cmp	r4, r6
        netif = netif->next;
 800ea9a:	bf08      	it	eq
 800ea9c:	6824      	ldreq	r4, [r4, #0]
 800ea9e:	2500      	movs	r5, #0
      }
    } while(netif != NULL);
 800eaa0:	2c00      	cmp	r4, #0
 800eaa2:	d1e7      	bne.n	800ea74 <ip_input+0x64>
  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if IP_ACCEPT_LINK_LAYER_ADDRESSING
  /* DHCP servers need 0.0.0.0 to be allowed as source address (RFC 1.1.2.2: 3.2.1.3/a) */
  if (check_ip_src && !ip_addr_isany(&current_iphdr_src))
#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
  {  if ((ip_addr_isbroadcast(&current_iphdr_src, inp)) ||
 800eaa4:	4631      	mov	r1, r6
 800eaa6:	f8d9 0000 	ldr.w	r0, [r9]
 800eaaa:	4d2c      	ldr	r5, [pc, #176]	; (800eb5c <ip_input+0x14c>)
 800eaac:	f000 f926 	bl	800ecfc <ip4_addr_isbroadcast>
 800eab0:	2800      	cmp	r0, #0
 800eab2:	d1b7      	bne.n	800ea24 <ip_input+0x14>
 800eab4:	682b      	ldr	r3, [r5, #0]
 800eab6:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800eaba:	2be0      	cmp	r3, #224	; 0xe0
 800eabc:	d0b2      	beq.n	800ea24 <ip_input+0x14>
      return ERR_OK;
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
 800eabe:	2c00      	cmp	r4, #0
 800eac0:	d0b0      	beq.n	800ea24 <ip_input+0x14>
    }
    pbuf_free(p);
    return ERR_OK;
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & PP_HTONS(IP_OFFMASK | IP_MF)) != 0) {
 800eac2:	f8ba 3006 	ldrh.w	r3, [sl, #6]
 800eac6:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 800eaca:	b13b      	cbz	r3, 800eadc <ip_input+0xcc>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & PP_HTONS(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    /* reassemble the packet*/
    p = ip_reass(p);
 800eacc:	4638      	mov	r0, r7
 800eace:	f000 fb57 	bl	800f180 <ip_reass>
    /* packet not fully reassembled yet? */
    if (p == NULL) {
 800ead2:	4607      	mov	r7, r0
 800ead4:	2800      	cmp	r0, #0
 800ead6:	d0a8      	beq.n	800ea2a <ip_input+0x1a>
      return ERR_OK;
    }
    iphdr = (struct ip_hdr *)p->payload;
 800ead8:	f8d0 a004 	ldr.w	sl, [r0, #4]
  /* send to upper layers */
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: \n"));
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

  current_netif = inp;
 800eadc:	4d20      	ldr	r5, [pc, #128]	; (800eb60 <ip_input+0x150>)
  current_header = iphdr;
 800eade:	4c21      	ldr	r4, [pc, #132]	; (800eb64 <ip_input+0x154>)

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
 800eae0:	4631      	mov	r1, r6
 800eae2:	4638      	mov	r0, r7
  /* send to upper layers */
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: \n"));
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

  current_netif = inp;
 800eae4:	602e      	str	r6, [r5, #0]
  current_header = iphdr;
 800eae6:	f8c4 a000 	str.w	sl, [r4]

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
 800eaea:	f001 fee9 	bl	80108c0 <raw_input>
 800eaee:	b9e0      	cbnz	r0, 800eb2a <ip_input+0x11a>
#endif /* LWIP_RAW */
  {
    switch (IPH_PROTO(iphdr)) {
 800eaf0:	f89a 3009 	ldrb.w	r3, [sl, #9]
 800eaf4:	2b06      	cmp	r3, #6
 800eaf6:	d02c      	beq.n	800eb52 <ip_input+0x142>
 800eaf8:	2b11      	cmp	r3, #17
 800eafa:	d025      	beq.n	800eb48 <ip_input+0x138>
 800eafc:	2b01      	cmp	r3, #1
 800eafe:	d01e      	beq.n	800eb3e <ip_input+0x12e>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&current_iphdr_dest, inp) &&
 800eb00:	4631      	mov	r1, r6
 800eb02:	f8d8 0000 	ldr.w	r0, [r8]
 800eb06:	4e18      	ldr	r6, [pc, #96]	; (800eb68 <ip_input+0x158>)
 800eb08:	f000 f8f8 	bl	800ecfc <ip4_addr_isbroadcast>
 800eb0c:	b950      	cbnz	r0, 800eb24 <ip_input+0x114>
 800eb0e:	6833      	ldr	r3, [r6, #0]
 800eb10:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800eb14:	2be0      	cmp	r3, #224	; 0xe0
 800eb16:	d005      	beq.n	800eb24 <ip_input+0x114>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
        p->payload = iphdr;
 800eb18:	f8c7 a004 	str.w	sl, [r7, #4]
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
 800eb1c:	2102      	movs	r1, #2
 800eb1e:	4638      	mov	r0, r7
 800eb20:	f006 f860 	bl	8014be4 <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
 800eb24:	4638      	mov	r0, r7
 800eb26:	f001 fa7f 	bl	8010028 <pbuf_free>
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinunknownprotos();
    }
  }

  current_netif = NULL;
 800eb2a:	2300      	movs	r3, #0
 800eb2c:	602b      	str	r3, [r5, #0]
  current_header = NULL;
 800eb2e:	6023      	str	r3, [r4, #0]
  ip_addr_set_any(&current_iphdr_src);
 800eb30:	f8c9 3000 	str.w	r3, [r9]
  ip_addr_set_any(&current_iphdr_dest);
 800eb34:	f8c8 3000 	str.w	r3, [r8]

  return ERR_OK;
 800eb38:	e777      	b.n	800ea2a <ip_input+0x1a>
      }
      if (first) {
        first = 0;
        netif = netif_list;
      } else {
        netif = netif->next;
 800eb3a:	6824      	ldr	r4, [r4, #0]
 800eb3c:	e7ac      	b.n	800ea98 <ip_input+0x88>
      break;
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      icmp_input(p, inp);
 800eb3e:	4631      	mov	r1, r6
 800eb40:	4638      	mov	r0, r7
 800eb42:	f005 ff83 	bl	8014a4c <icmp_input>
      break;
 800eb46:	e7f0      	b.n	800eb2a <ip_input+0x11a>
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      udp_input(p, inp);
 800eb48:	4631      	mov	r1, r6
 800eb4a:	4638      	mov	r0, r7
 800eb4c:	f005 fc4a 	bl	80143e4 <udp_input>
      break;
 800eb50:	e7eb      	b.n	800eb2a <ip_input+0x11a>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      tcp_input(p, inp);
 800eb52:	4631      	mov	r1, r6
 800eb54:	4638      	mov	r0, r7
 800eb56:	f004 ffa1 	bl	8013a9c <tcp_input>
      break;
 800eb5a:	e7e6      	b.n	800eb2a <ip_input+0x11a>
 800eb5c:	2000f09c 	.word	0x2000f09c
 800eb60:	2000f0a0 	.word	0x2000f0a0
 800eb64:	2000f0a8 	.word	0x2000f0a8
 800eb68:	2000f0a4 	.word	0x2000f0a4
 800eb6c:	2000d940 	.word	0x2000d940

0800eb70 <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
 800eb70:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800eb74:	4605      	mov	r5, r0
  u32_t chk_sum = 0;
#endif /* CHECKSUM_GEN_IP_INLINE */

  /* pbufs passed to IP must have a ref-count of 1 as their payload pointer
     gets altered as the packet is passed down the stack */
  LWIP_ASSERT("p->ref == 1", p->ref == 1);
 800eb76:	89c0      	ldrh	r0, [r0, #14]
 */
err_t
ip_output_if(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
 800eb78:	b087      	sub	sp, #28
  u32_t chk_sum = 0;
#endif /* CHECKSUM_GEN_IP_INLINE */

  /* pbufs passed to IP must have a ref-count of 1 as their payload pointer
     gets altered as the packet is passed down the stack */
  LWIP_ASSERT("p->ref == 1", p->ref == 1);
 800eb7a:	2801      	cmp	r0, #1
 */
err_t
ip_output_if(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
 800eb7c:	468b      	mov	fp, r1
 800eb7e:	4616      	mov	r6, r2
 800eb80:	4698      	mov	r8, r3
 800eb82:	f89d 9040 	ldrb.w	r9, [sp, #64]	; 0x40
 800eb86:	f89d a044 	ldrb.w	sl, [sp, #68]	; 0x44
 800eb8a:	9f12      	ldr	r7, [sp, #72]	; 0x48
  u32_t chk_sum = 0;
#endif /* CHECKSUM_GEN_IP_INLINE */

  /* pbufs passed to IP must have a ref-count of 1 as their payload pointer
     gets altered as the packet is passed down the stack */
  LWIP_ASSERT("p->ref == 1", p->ref == 1);
 800eb8c:	d006      	beq.n	800eb9c <ip_output_if+0x2c>
 800eb8e:	4b3f      	ldr	r3, [pc, #252]	; (800ec8c <ip_output_if+0x11c>)
 800eb90:	f44f 7227 	mov.w	r2, #668	; 0x29c
 800eb94:	493e      	ldr	r1, [pc, #248]	; (800ec90 <ip_output_if+0x120>)
 800eb96:	483f      	ldr	r0, [pc, #252]	; (800ec94 <ip_output_if+0x124>)
 800eb98:	f006 f8ee 	bl	8014d78 <iprintf>

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
 800eb9c:	2e00      	cmp	r6, #0
 800eb9e:	d05c      	beq.n	800ec5a <ip_output_if+0xea>
      }
#endif /* CHECKSUM_GEN_IP_INLINE */
    }
#endif /* IP_OPTIONS_SEND */
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
 800eba0:	2114      	movs	r1, #20
 800eba2:	4628      	mov	r0, r5
 800eba4:	f001 f9e8 	bl	800ff78 <pbuf_header>
 800eba8:	2800      	cmp	r0, #0
 800ebaa:	d16c      	bne.n	800ec86 <ip_output_if+0x116>
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = (struct ip_hdr *)p->payload;
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
 800ebac:	896b      	ldrh	r3, [r5, #10]
      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = (struct ip_hdr *)p->payload;
 800ebae:	686c      	ldr	r4, [r5, #4]
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
 800ebb0:	2b13      	cmp	r3, #19
 800ebb2:	d958      	bls.n	800ec66 <ip_output_if+0xf6>
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
 800ebb4:	f884 8008 	strb.w	r8, [r4, #8]
    IPH_PROTO_SET(iphdr, proto);
 800ebb8:	f884 a009 	strb.w	sl, [r4, #9]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(proto, ttl);
#endif /* CHECKSUM_GEN_IP_INLINE */

    /* dest cannot be NULL here */
    ip_addr_copy(iphdr->dest, *dest);
 800ebbc:	6833      	ldr	r3, [r6, #0]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
    chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
#endif /* CHECKSUM_GEN_IP_INLINE */

    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
 800ebbe:	2245      	movs	r2, #69	; 0x45
    IPH_TOS_SET(iphdr, tos);
 800ebc0:	f884 9001 	strb.w	r9, [r4, #1]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
    chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
#endif /* CHECKSUM_GEN_IP_INLINE */

    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
 800ebc4:	7022      	strb	r2, [r4, #0]
    IPH_TOS_SET(iphdr, tos);
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
 800ebc6:	ea4f 2209 	mov.w	r2, r9, lsl #8
 800ebca:	f042 0245 	orr.w	r2, r2, #69	; 0x45
 800ebce:	fa1f f983 	uxth.w	r9, r3
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(proto, ttl);
#endif /* CHECKSUM_GEN_IP_INLINE */

    /* dest cannot be NULL here */
    ip_addr_copy(iphdr->dest, *dest);
 800ebd2:	6123      	str	r3, [r4, #16]
    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
    IPH_TOS_SET(iphdr, tos);
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_LEN_SET(iphdr, htons(p->tot_len));
 800ebd4:	8928      	ldrh	r0, [r5, #8]
#endif /* CHECKSUM_GEN_IP_INLINE */

    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
    IPH_TOS_SET(iphdr, tos);
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
 800ebd6:	9203      	str	r2, [sp, #12]
 800ebd8:	eb09 4913 	add.w	r9, r9, r3, lsr #16
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_LEN_SET(iphdr, htons(p->tot_len));
 800ebdc:	f7fe ffdc 	bl	800db98 <lwip_htons>
 800ebe0:	4601      	mov	r1, r0
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
    IPH_ID_SET(iphdr, htons(ip_id));
 800ebe2:	4b2d      	ldr	r3, [pc, #180]	; (800ec98 <ip_output_if+0x128>)
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_LEN_SET(iphdr, htons(p->tot_len));
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
 800ebe4:	2000      	movs	r0, #0
    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
    IPH_TOS_SET(iphdr, tos);
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_LEN_SET(iphdr, htons(p->tot_len));
 800ebe6:	8061      	strh	r1, [r4, #2]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
 800ebe8:	71a0      	strb	r0, [r4, #6]
 800ebea:	71e0      	strb	r0, [r4, #7]
    IPH_ID_SET(iphdr, htons(ip_id));
 800ebec:	8818      	ldrh	r0, [r3, #0]
    IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
    IPH_TOS_SET(iphdr, tos);
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(tos, iphdr->_v_hl);
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_LEN_SET(iphdr, htons(p->tot_len));
 800ebee:	9102      	str	r1, [sp, #8]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
    IPH_ID_SET(iphdr, htons(ip_id));
 800ebf0:	9301      	str	r3, [sp, #4]
 800ebf2:	f7fe ffd1 	bl	800db98 <lwip_htons>
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_id;
#endif /* CHECKSUM_GEN_IP_INLINE */
    ++ip_id;
 800ebf6:	9b01      	ldr	r3, [sp, #4]
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
    IPH_PROTO_SET(iphdr, proto);
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += LWIP_MAKE_U16(proto, ttl);
 800ebf8:	ea48 280a 	orr.w	r8, r8, sl, lsl #8
    IPH_OFFSET_SET(iphdr, 0);
    IPH_ID_SET(iphdr, htons(ip_id));
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_id;
#endif /* CHECKSUM_GEN_IP_INLINE */
    ++ip_id;
 800ebfc:	f8b3 e000 	ldrh.w	lr, [r3]
    IPH_LEN_SET(iphdr, htons(p->tot_len));
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_len;
#endif /* CHECKSUM_GEN_IP_INLINE */
    IPH_OFFSET_SET(iphdr, 0);
    IPH_ID_SET(iphdr, htons(ip_id));
 800ec00:	80a0      	strh	r0, [r4, #4]
#if CHECKSUM_GEN_IP_INLINE
    chk_sum += iphdr->_id;
#endif /* CHECKSUM_GEN_IP_INLINE */
    ++ip_id;
 800ec02:	f10e 0e01 	add.w	lr, lr, #1
 800ec06:	f8a3 e000 	strh.w	lr, [r3]

    if (ip_addr_isany(src)) {
 800ec0a:	9902      	ldr	r1, [sp, #8]
 800ec0c:	9a03      	ldr	r2, [sp, #12]
 800ec0e:	f1bb 0f00 	cmp.w	fp, #0
 800ec12:	d002      	beq.n	800ec1a <ip_output_if+0xaa>
 800ec14:	f8db 3000 	ldr.w	r3, [fp]
 800ec18:	b9eb      	cbnz	r3, 800ec56 <ip_output_if+0xe6>
      ip_addr_copy(iphdr->src, netif->ip_addr);
 800ec1a:	687b      	ldr	r3, [r7, #4]
 800ec1c:	60e3      	str	r3, [r4, #12]
      ip_addr_copy(iphdr->src, *src);
    }

#if CHECKSUM_GEN_IP_INLINE
    chk_sum += ip4_addr_get_u32(&iphdr->src) & 0xFFFF;
    chk_sum += ip4_addr_get_u32(&iphdr->src) >> 16;
 800ec1e:	4491      	add	r9, r2
 800ec20:	44c1      	add	r9, r8
 800ec22:	4449      	add	r1, r9
 800ec24:	b29a      	uxth	r2, r3
 800ec26:	4408      	add	r0, r1
 800ec28:	4410      	add	r0, r2
 800ec2a:	eb00 4013 	add.w	r0, r0, r3, lsr #16
    chk_sum = (chk_sum >> 16) + (chk_sum & 0xFFFF);
 800ec2e:	b283      	uxth	r3, r0
 800ec30:	eb03 4310 	add.w	r3, r3, r0, lsr #16
    chk_sum = (chk_sum >> 16) + chk_sum;
 800ec34:	eb03 4313 	add.w	r3, r3, r3, lsr #16
    chk_sum = ~chk_sum;
    iphdr->_chksum = chk_sum; /* network order */
 800ec38:	43db      	mvns	r3, r3
 800ec3a:	8163      	strh	r3, [r4, #10]
  }
#endif /* LWIP_IGMP */
#endif /* ENABLE_LOOPBACK */
#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu)) {
 800ec3c:	8c3b      	ldrh	r3, [r7, #32]
 800ec3e:	b113      	cbz	r3, 800ec46 <ip_output_if+0xd6>
 800ec40:	892a      	ldrh	r2, [r5, #8]
 800ec42:	429a      	cmp	r2, r3
 800ec44:	d817      	bhi.n	800ec76 <ip_output_if+0x106>
    return ip_frag(p, netif, dest);
  }
#endif /* IP_FRAG */

  LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));
  return netif->output(netif, p, dest);
 800ec46:	4632      	mov	r2, r6
 800ec48:	4629      	mov	r1, r5
 800ec4a:	697b      	ldr	r3, [r7, #20]
 800ec4c:	4638      	mov	r0, r7
 800ec4e:	4798      	blx	r3
}
 800ec50:	b007      	add	sp, #28
 800ec52:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

    if (ip_addr_isany(src)) {
      ip_addr_copy(iphdr->src, netif->ip_addr);
    } else {
      /* src cannot be NULL here */
      ip_addr_copy(iphdr->src, *src);
 800ec56:	60e3      	str	r3, [r4, #12]
 800ec58:	e7e1      	b.n	800ec1e <ip_output_if+0xae>
#endif
#endif /* CHECKSUM_GEN_IP_INLINE */
  } else {
    /* IP header already included in p */
    iphdr = (struct ip_hdr *)p->payload;
    ip_addr_copy(dest_addr, iphdr->dest);
 800ec5a:	686b      	ldr	r3, [r5, #4]
 800ec5c:	ae06      	add	r6, sp, #24
 800ec5e:	691b      	ldr	r3, [r3, #16]
 800ec60:	f846 3d04 	str.w	r3, [r6, #-4]!
 800ec64:	e7ea      	b.n	800ec3c <ip_output_if+0xcc>
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = (struct ip_hdr *)p->payload;
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
 800ec66:	4b09      	ldr	r3, [pc, #36]	; (800ec8c <ip_output_if+0x11c>)
 800ec68:	f240 22ca 	movw	r2, #714	; 0x2ca
 800ec6c:	490b      	ldr	r1, [pc, #44]	; (800ec9c <ip_output_if+0x12c>)
 800ec6e:	4809      	ldr	r0, [pc, #36]	; (800ec94 <ip_output_if+0x124>)
 800ec70:	f006 f882 	bl	8014d78 <iprintf>
 800ec74:	e79e      	b.n	800ebb4 <ip_output_if+0x44>
#endif /* LWIP_IGMP */
#endif /* ENABLE_LOOPBACK */
#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu)) {
    return ip_frag(p, netif, dest);
 800ec76:	4632      	mov	r2, r6
 800ec78:	4639      	mov	r1, r7
 800ec7a:	4628      	mov	r0, r5
 800ec7c:	f000 fc3a 	bl	800f4f4 <ip_frag>
  }
#endif /* IP_FRAG */

  LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));
  return netif->output(netif, p, dest);
}
 800ec80:	b007      	add	sp, #28
 800ec82:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (pbuf_header(p, IP_HLEN)) {
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
 800ec86:	f06f 0001 	mvn.w	r0, #1
 800ec8a:	e7e1      	b.n	800ec50 <ip_output_if+0xe0>
 800ec8c:	080177cc 	.word	0x080177cc
 800ec90:	080177e0 	.word	0x080177e0
 800ec94:	0801660c 	.word	0x0801660c
 800ec98:	200008ce 	.word	0x200008ce
 800ec9c:	080177ec 	.word	0x080177ec

0800eca0 <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
 800eca0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800eca4:	4604      	mov	r4, r0
  struct netif *netif;

  /* pbufs passed to IP must have a ref-count of 1 as their payload pointer
     gets altered as the packet is passed down the stack */
  LWIP_ASSERT("p->ref == 1", p->ref == 1);
 800eca6:	89c0      	ldrh	r0, [r0, #14]
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
 800eca8:	b085      	sub	sp, #20
  struct netif *netif;

  /* pbufs passed to IP must have a ref-count of 1 as their payload pointer
     gets altered as the packet is passed down the stack */
  LWIP_ASSERT("p->ref == 1", p->ref == 1);
 800ecaa:	2801      	cmp	r0, #1
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, ip_addr_t *src, ip_addr_t *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
 800ecac:	460e      	mov	r6, r1
 800ecae:	4615      	mov	r5, r2
 800ecb0:	461f      	mov	r7, r3
 800ecb2:	f89d 8030 	ldrb.w	r8, [sp, #48]	; 0x30
 800ecb6:	f89d 9034 	ldrb.w	r9, [sp, #52]	; 0x34
  struct netif *netif;

  /* pbufs passed to IP must have a ref-count of 1 as their payload pointer
     gets altered as the packet is passed down the stack */
  LWIP_ASSERT("p->ref == 1", p->ref == 1);
 800ecba:	d006      	beq.n	800ecca <ip_output+0x2a>
 800ecbc:	4b0c      	ldr	r3, [pc, #48]	; (800ecf0 <ip_output+0x50>)
 800ecbe:	f240 3239 	movw	r2, #825	; 0x339
 800ecc2:	490c      	ldr	r1, [pc, #48]	; (800ecf4 <ip_output+0x54>)
 800ecc4:	480c      	ldr	r0, [pc, #48]	; (800ecf8 <ip_output+0x58>)
 800ecc6:	f006 f857 	bl	8014d78 <iprintf>

  if ((netif = ip_route(dest)) == NULL) {
 800ecca:	4628      	mov	r0, r5
 800eccc:	f7ff fe80 	bl	800e9d0 <ip_route>
 800ecd0:	b158      	cbz	r0, 800ecea <ip_output+0x4a>
      ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
    return ERR_RTE;
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
 800ecd2:	9002      	str	r0, [sp, #8]
 800ecd4:	e88d 0300 	stmia.w	sp, {r8, r9}
 800ecd8:	463b      	mov	r3, r7
 800ecda:	462a      	mov	r2, r5
 800ecdc:	4631      	mov	r1, r6
 800ecde:	4620      	mov	r0, r4
 800ece0:	f7ff ff46 	bl	800eb70 <ip_output_if>
}
 800ece4:	b005      	add	sp, #20
 800ece6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

  if ((netif = ip_route(dest)) == NULL) {
    LWIP_DEBUGF(IP_DEBUG, ("ip_output: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
    IP_STATS_INC(ip.rterr);
    return ERR_RTE;
 800ecea:	f06f 0003 	mvn.w	r0, #3
 800ecee:	e7f9      	b.n	800ece4 <ip_output+0x44>
 800ecf0:	080177cc 	.word	0x080177cc
 800ecf4:	080177e0 	.word	0x080177e0
 800ecf8:	0801660c 	.word	0x0801660c

0800ecfc <ip4_addr_isbroadcast>:
{
  ip_addr_t ipaddr;
  ip4_addr_set_u32(&ipaddr, addr);

  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr == IPADDR_ANY) ||
 800ecfc:	1e43      	subs	r3, r0, #1
 800ecfe:	3303      	adds	r3, #3
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t
ip4_addr_isbroadcast(u32_t addr, const struct netif *netif)
{
 800ed00:	4602      	mov	r2, r0
  ip_addr_t ipaddr;
  ip4_addr_set_u32(&ipaddr, addr);

  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr == IPADDR_ANY) ||
 800ed02:	d816      	bhi.n	800ed32 <ip4_addr_isbroadcast+0x36>
 800ed04:	f891 3029 	ldrb.w	r3, [r1, #41]	; 0x29
 800ed08:	f003 0302 	and.w	r3, r3, #2
      (addr == IPADDR_ANY)) {
    return 1;
  /* no broadcast support on this network interface? */
  } else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0) {
 800ed0c:	f003 00ff 	and.w	r0, r3, #255	; 0xff
 800ed10:	b173      	cbz	r3, 800ed30 <ip4_addr_isbroadcast+0x34>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  } else if (addr == ip4_addr_get_u32(&netif->ip_addr)) {
 800ed12:	684b      	ldr	r3, [r1, #4]
 800ed14:	429a      	cmp	r2, r3
 800ed16:	d00a      	beq.n	800ed2e <ip4_addr_isbroadcast+0x32>
    return 0;
  /*  on the same (sub) network... */
  } else if (ip_addr_netcmp(&ipaddr, &(netif->ip_addr), &(netif->netmask))
 800ed18:	6889      	ldr	r1, [r1, #8]
 800ed1a:	4053      	eors	r3, r2
 800ed1c:	420b      	tst	r3, r1
 800ed1e:	d106      	bne.n	800ed2e <ip4_addr_isbroadcast+0x32>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr & ~ip4_addr_get_u32(&netif->netmask)) ==
 800ed20:	43c9      	mvns	r1, r1
  ip4_addr_set_u32(&ipaddr, addr);

  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr == IPADDR_ANY) ||
      (addr == IPADDR_ANY)) {
    return 1;
 800ed22:	ea31 0302 	bics.w	r3, r1, r2
 800ed26:	bf0c      	ite	eq
 800ed28:	2001      	moveq	r0, #1
 800ed2a:	2000      	movne	r0, #0
 800ed2c:	4770      	bx	lr
          && ((addr & ~ip4_addr_get_u32(&netif->netmask)) ==
           (IPADDR_BROADCAST & ~ip4_addr_get_u32(&netif->netmask)))) {
    /* => network broadcast address */
    return 1;
  } else {
    return 0;
 800ed2e:	2000      	movs	r0, #0
  }
}
 800ed30:	4770      	bx	lr
  ip4_addr_set_u32(&ipaddr, addr);

  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr == IPADDR_ANY) ||
      (addr == IPADDR_ANY)) {
    return 1;
 800ed32:	2001      	movs	r0, #1
 800ed34:	4770      	bx	lr
 800ed36:	bf00      	nop

0800ed38 <ip4_addr_netmask_valid>:
 * @param netmask the IPv4 netmask to check (in network byte order!)
 * @return 1 if the netmask is valid, 0 if it is not
 */
u8_t
ip4_addr_netmask_valid(u32_t netmask)
{
 800ed38:	b508      	push	{r3, lr}
  u32_t mask;
  u32_t nm_hostorder = lwip_htonl(netmask);
 800ed3a:	f7fe ff37 	bl	800dbac <lwip_htonl>
 800ed3e:	2220      	movs	r2, #32

  /* first, check for the first zero */
  for (mask = 1UL << 31 ; mask != 0; mask >>= 1) {
 800ed40:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 800ed44:	e003      	b.n	800ed4e <ip4_addr_netmask_valid+0x16>
 800ed46:	3a01      	subs	r2, #1
 800ed48:	ea4f 0353 	mov.w	r3, r3, lsr #1
 800ed4c:	d008      	beq.n	800ed60 <ip4_addr_netmask_valid+0x28>
    if ((nm_hostorder & mask) == 0) {
 800ed4e:	4218      	tst	r0, r3
 800ed50:	d1f9      	bne.n	800ed46 <ip4_addr_netmask_valid+0xe>
      break;
    }
  }
  /* then check that there is no one */
  for (; mask != 0; mask >>= 1) {
 800ed52:	b12b      	cbz	r3, 800ed60 <ip4_addr_netmask_valid+0x28>
 800ed54:	085b      	lsrs	r3, r3, #1
 800ed56:	d003      	beq.n	800ed60 <ip4_addr_netmask_valid+0x28>
    if ((nm_hostorder & mask) != 0) {
 800ed58:	4218      	tst	r0, r3
 800ed5a:	d0fb      	beq.n	800ed54 <ip4_addr_netmask_valid+0x1c>
      /* there is a one after the first zero -> invalid */
      return 0;
 800ed5c:	2000      	movs	r0, #0
    }
  }
  /* no one after the first zero -> valid */
  return 1;
}
 800ed5e:	bd08      	pop	{r3, pc}
      /* there is a one after the first zero -> invalid */
      return 0;
    }
  }
  /* no one after the first zero -> valid */
  return 1;
 800ed60:	2001      	movs	r0, #1
 800ed62:	bd08      	pop	{r3, pc}

0800ed64 <ipaddr_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
ipaddr_aton(const char *cp, ip_addr_t *addr)
{
 800ed64:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  u8_t base;
  char c;
  u32_t parts[4];
  u32_t *pp = parts;

  c = *cp;
 800ed68:	7803      	ldrb	r3, [r0, #0]
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
ipaddr_aton(const char *cp, ip_addr_t *addr)
{
 800ed6a:	460c      	mov	r4, r1
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
 800ed6c:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 800ed70:	b2d1      	uxtb	r1, r2
 800ed72:	2909      	cmp	r1, #9
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
ipaddr_aton(const char *cp, ip_addr_t *addr)
{
 800ed74:	b084      	sub	sp, #16
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
 800ed76:	d83d      	bhi.n	800edf4 <ipaddr_aton+0x90>
 800ed78:	46ee      	mov	lr, sp
 800ed7a:	466f      	mov	r7, sp
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3) {
 800ed7c:	f10d 0c0c 	add.w	ip, sp, #12
     */
    if (!isdigit(c))
      return (0);
    val = 0;
    base = 10;
    if (c == '0') {
 800ed80:	2b30      	cmp	r3, #48	; 0x30
 800ed82:	d03c      	beq.n	800edfe <ipaddr_aton+0x9a>
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
      return (0);
    val = 0;
    base = 10;
 800ed84:	260a      	movs	r6, #10
 800ed86:	3001      	adds	r0, #1
    if (c == '0') {
      c = *++cp;
      if (c == 'x' || c == 'X') {
        base = 16;
 800ed88:	2500      	movs	r5, #0
 800ed8a:	e006      	b.n	800ed9a <ipaddr_aton+0x36>
      } else
        base = 8;
    }
    for (;;) {
      if (isdigit(c)) {
        val = (val * base) + (int)(c - '0');
 800ed8c:	fb05 3506 	mla	r5, r5, r6, r3
        c = *++cp;
 800ed90:	7803      	ldrb	r3, [r0, #0]
      } else
        base = 8;
    }
    for (;;) {
      if (isdigit(c)) {
        val = (val * base) + (int)(c - '0');
 800ed92:	3d30      	subs	r5, #48	; 0x30
 800ed94:	3001      	adds	r0, #1
 800ed96:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
        c = *++cp;
      } else
        base = 8;
    }
    for (;;) {
      if (isdigit(c)) {
 800ed9a:	fa5f fa82 	uxtb.w	sl, r2
        val = (val * base) + (int)(c - '0');
        c = *++cp;
      } else if (base == 16 && isxdigit(c)) {
 800ed9e:	f023 0120 	bic.w	r1, r3, #32
 800eda2:	3941      	subs	r1, #65	; 0x41
 800eda4:	f1a3 0261 	sub.w	r2, r3, #97	; 0x61
        c = *++cp;
      } else
        base = 8;
    }
    for (;;) {
      if (isdigit(c)) {
 800eda8:	f1ba 0f09 	cmp.w	sl, #9
        val = (val * base) + (int)(c - '0');
        c = *++cp;
      } else if (base == 16 && isxdigit(c)) {
 800edac:	b2c9      	uxtb	r1, r1
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
 800edae:	f103 090a 	add.w	r9, r3, #10
 800edb2:	f100 38ff 	add.w	r8, r0, #4294967295
    }
    for (;;) {
      if (isdigit(c)) {
        val = (val * base) + (int)(c - '0');
        c = *++cp;
      } else if (base == 16 && isxdigit(c)) {
 800edb6:	b2d2      	uxtb	r2, r2
        c = *++cp;
      } else
        base = 8;
    }
    for (;;) {
      if (isdigit(c)) {
 800edb8:	d9e8      	bls.n	800ed8c <ipaddr_aton+0x28>
        val = (val * base) + (int)(c - '0');
        c = *++cp;
      } else if (base == 16 && isxdigit(c)) {
 800edba:	2e10      	cmp	r6, #16
 800edbc:	d10b      	bne.n	800edd6 <ipaddr_aton+0x72>
 800edbe:	2905      	cmp	r1, #5
 800edc0:	d809      	bhi.n	800edd6 <ipaddr_aton+0x72>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
 800edc2:	2a1a      	cmp	r2, #26
 800edc4:	bf34      	ite	cc
 800edc6:	2361      	movcc	r3, #97	; 0x61
 800edc8:	2341      	movcs	r3, #65	; 0x41
 800edca:	ebc3 0909 	rsb	r9, r3, r9
 800edce:	ea49 1505 	orr.w	r5, r9, r5, lsl #4
        c = *++cp;
 800edd2:	7803      	ldrb	r3, [r0, #0]
 800edd4:	e7de      	b.n	800ed94 <ipaddr_aton+0x30>
      } else
        break;
    }
    if (c == '.') {
 800edd6:	2b2e      	cmp	r3, #46	; 0x2e
 800edd8:	d121      	bne.n	800ee1e <ipaddr_aton+0xba>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3) {
 800edda:	4567      	cmp	r7, ip
 800eddc:	d00a      	beq.n	800edf4 <ipaddr_aton+0x90>
        return (0);
      }
      *pp++ = val;
      c = *++cp;
 800edde:	f898 3001 	ldrb.w	r3, [r8, #1]
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3) {
        return (0);
      }
      *pp++ = val;
 800ede2:	f847 5b04 	str.w	r5, [r7], #4
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
 800ede6:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 800edea:	b2d1      	uxtb	r1, r2
 800edec:	2909      	cmp	r1, #9
       */
      if (pp >= parts + 3) {
        return (0);
      }
      *pp++ = val;
      c = *++cp;
 800edee:	f108 0001 	add.w	r0, r8, #1
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
 800edf2:	d9c5      	bls.n	800ed80 <ipaddr_aton+0x1c>
      return (0);
 800edf4:	2300      	movs	r3, #0
  }
  if (addr) {
    ip4_addr_set_u32(addr, htonl(val));
  }
  return (1);
}
 800edf6:	4618      	mov	r0, r3
 800edf8:	b004      	add	sp, #16
 800edfa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (!isdigit(c))
      return (0);
    val = 0;
    base = 10;
    if (c == '0') {
      c = *++cp;
 800edfe:	7843      	ldrb	r3, [r0, #1]
      if (c == 'x' || c == 'X') {
 800ee00:	f003 02df 	and.w	r2, r3, #223	; 0xdf
 800ee04:	2a58      	cmp	r2, #88	; 0x58
 800ee06:	d004      	beq.n	800ee12 <ipaddr_aton+0xae>
    if (!isdigit(c))
      return (0);
    val = 0;
    base = 10;
    if (c == '0') {
      c = *++cp;
 800ee08:	3001      	adds	r0, #1
      if (c == 'x' || c == 'X') {
        base = 16;
        c = *++cp;
      } else
        base = 8;
 800ee0a:	2608      	movs	r6, #8
 800ee0c:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 800ee10:	e7b9      	b.n	800ed86 <ipaddr_aton+0x22>
    base = 10;
    if (c == '0') {
      c = *++cp;
      if (c == 'x' || c == 'X') {
        base = 16;
        c = *++cp;
 800ee12:	7883      	ldrb	r3, [r0, #2]
    val = 0;
    base = 10;
    if (c == '0') {
      c = *++cp;
      if (c == 'x' || c == 'X') {
        base = 16;
 800ee14:	2610      	movs	r6, #16
        c = *++cp;
 800ee16:	3002      	adds	r0, #2
 800ee18:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 800ee1c:	e7b3      	b.n	800ed86 <ipaddr_aton+0x22>
      break;
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && !isspace(c)) {
 800ee1e:	f013 0fdf 	tst.w	r3, #223	; 0xdf
 800ee22:	d002      	beq.n	800ee2a <ipaddr_aton+0xc6>
 800ee24:	3b09      	subs	r3, #9
 800ee26:	2b04      	cmp	r3, #4
 800ee28:	d8e4      	bhi.n	800edf4 <ipaddr_aton+0x90>
  }
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  switch (pp - parts + 1) {
 800ee2a:	ebce 0307 	rsb	r3, lr, r7
 800ee2e:	109b      	asrs	r3, r3, #2
 800ee30:	3301      	adds	r3, #1
 800ee32:	2b04      	cmp	r3, #4
 800ee34:	d82f      	bhi.n	800ee96 <ipaddr_aton+0x132>
 800ee36:	a201      	add	r2, pc, #4	; (adr r2, 800ee3c <ipaddr_aton+0xd8>)
 800ee38:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800ee3c:	0800edf7 	.word	0x0800edf7
 800ee40:	0800ee63 	.word	0x0800ee63
 800ee44:	0800ee89 	.word	0x0800ee89
 800ee48:	0800ee51 	.word	0x0800ee51
 800ee4c:	0800ee71 	.word	0x0800ee71
    }
    val |= parts[0] << 24;
    break;

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff) {
 800ee50:	f5b5 3f80 	cmp.w	r5, #65536	; 0x10000
 800ee54:	d2ce      	bcs.n	800edf4 <ipaddr_aton+0x90>
      return (0);
    }
    val |= (parts[0] << 24) | (parts[1] << 16);
 800ee56:	e89d 000c 	ldmia.w	sp, {r2, r3}
 800ee5a:	041b      	lsls	r3, r3, #16
 800ee5c:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 800ee60:	431d      	orrs	r5, r3
    break;
  default:
    LWIP_ASSERT("unhandled", 0);
    break;
  }
  if (addr) {
 800ee62:	b1fc      	cbz	r4, 800eea4 <ipaddr_aton+0x140>
    ip4_addr_set_u32(addr, htonl(val));
 800ee64:	4628      	mov	r0, r5
 800ee66:	f7fe fea1 	bl	800dbac <lwip_htonl>
  }
  return (1);
 800ee6a:	2301      	movs	r3, #1
  default:
    LWIP_ASSERT("unhandled", 0);
    break;
  }
  if (addr) {
    ip4_addr_set_u32(addr, htonl(val));
 800ee6c:	6020      	str	r0, [r4, #0]
 800ee6e:	e7c2      	b.n	800edf6 <ipaddr_aton+0x92>
    }
    val |= (parts[0] << 24) | (parts[1] << 16);
    break;

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff) {
 800ee70:	2dff      	cmp	r5, #255	; 0xff
 800ee72:	d8bf      	bhi.n	800edf4 <ipaddr_aton+0x90>
      return (0);
    }
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
 800ee74:	e89d 000a 	ldmia.w	sp, {r1, r3}
 800ee78:	9a02      	ldr	r2, [sp, #8]
 800ee7a:	041b      	lsls	r3, r3, #16
 800ee7c:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 800ee80:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800ee84:	431d      	orrs	r5, r3
    break;
 800ee86:	e7ec      	b.n	800ee62 <ipaddr_aton+0xfe>

  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL) {
 800ee88:	f1b5 7f80 	cmp.w	r5, #16777216	; 0x1000000
 800ee8c:	d2b2      	bcs.n	800edf4 <ipaddr_aton+0x90>
      return (0);
    }
    val |= parts[0] << 24;
 800ee8e:	9b00      	ldr	r3, [sp, #0]
 800ee90:	ea45 6503 	orr.w	r5, r5, r3, lsl #24
    break;
 800ee94:	e7e5      	b.n	800ee62 <ipaddr_aton+0xfe>
      return (0);
    }
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
    break;
  default:
    LWIP_ASSERT("unhandled", 0);
 800ee96:	4b04      	ldr	r3, [pc, #16]	; (800eea8 <ipaddr_aton+0x144>)
 800ee98:	22f3      	movs	r2, #243	; 0xf3
 800ee9a:	4904      	ldr	r1, [pc, #16]	; (800eeac <ipaddr_aton+0x148>)
 800ee9c:	4804      	ldr	r0, [pc, #16]	; (800eeb0 <ipaddr_aton+0x14c>)
 800ee9e:	f005 ff6b 	bl	8014d78 <iprintf>
    break;
 800eea2:	e7de      	b.n	800ee62 <ipaddr_aton+0xfe>
  }
  if (addr) {
    ip4_addr_set_u32(addr, htonl(val));
  }
  return (1);
 800eea4:	2301      	movs	r3, #1
 800eea6:	e7a6      	b.n	800edf6 <ipaddr_aton+0x92>
 800eea8:	0801781c 	.word	0x0801781c
 800eeac:	08017834 	.word	0x08017834
 800eeb0:	0801660c 	.word	0x0801660c

0800eeb4 <ipaddr_addr>:
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @return ip address in network order
 */
u32_t
ipaddr_addr(const char *cp)
{
 800eeb4:	b500      	push	{lr}
 800eeb6:	b083      	sub	sp, #12
  ip_addr_t val;

  if (ipaddr_aton(cp, &val)) {
 800eeb8:	a901      	add	r1, sp, #4
 800eeba:	f7ff ff53 	bl	800ed64 <ipaddr_aton>
 800eebe:	b920      	cbnz	r0, 800eeca <ipaddr_addr+0x16>
    return ip4_addr_get_u32(&val);
  }
  return (IPADDR_NONE);
 800eec0:	f04f 30ff 	mov.w	r0, #4294967295
}
 800eec4:	b003      	add	sp, #12
 800eec6:	f85d fb04 	ldr.w	pc, [sp], #4
ipaddr_addr(const char *cp)
{
  ip_addr_t val;

  if (ipaddr_aton(cp, &val)) {
    return ip4_addr_get_u32(&val);
 800eeca:	9801      	ldr	r0, [sp, #4]
  }
  return (IPADDR_NONE);
}
 800eecc:	b003      	add	sp, #12
 800eece:	f85d fb04 	ldr.w	pc, [sp], #4
 800eed2:	bf00      	nop

0800eed4 <ipaddr_ntoa_r>:
 * @param buflen length of buf
 * @return either pointer to buf which now holds the ASCII
 *         representation of addr or NULL if buf was too small
 */
char *ipaddr_ntoa_r(const ip_addr_t *addr, char *buf, int buflen)
{
 800eed4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  u8_t i;
  int len = 0;

  s_addr = ip4_addr_get_u32(addr);

  rp = buf;
 800eed8:	468e      	mov	lr, r1
 * @param buflen length of buf
 * @return either pointer to buf which now holds the ASCII
 *         representation of addr or NULL if buf was too small
 */
char *ipaddr_ntoa_r(const ip_addr_t *addr, char *buf, int buflen)
{
 800eeda:	b083      	sub	sp, #12
  u8_t rem;
  u8_t n;
  u8_t i;
  int len = 0;

  s_addr = ip4_addr_get_u32(addr);
 800eedc:	6803      	ldr	r3, [r0, #0]
 800eede:	f10d 0808 	add.w	r8, sp, #8
  rp = buf;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
    i = 0;
    do {
      rem = *ap % (u8_t)10;
 800eee2:	482a      	ldr	r0, [pc, #168]	; (800ef8c <ipaddr_ntoa_r+0xb8>)
  u8_t rem;
  u8_t n;
  u8_t i;
  int len = 0;

  s_addr = ip4_addr_get_u32(addr);
 800eee4:	f848 3d04 	str.w	r3, [r8, #-4]!
 800eee8:	f102 0c01 	add.w	ip, r2, #1
 800eeec:	f10d 0a08 	add.w	sl, sp, #8
  char *rp;
  u8_t *ap;
  u8_t rem;
  u8_t n;
  u8_t i;
  int len = 0;
 800eef0:	f04f 0b00 	mov.w	fp, #0
      *rp++ = inv[i];
    }
    if (len++ >= buflen) {
      return NULL;
    }
    *rp++ = '.';
 800eef4:	f04f 092e 	mov.w	r9, #46	; 0x2e
 800eef8:	f898 7000 	ldrb.w	r7, [r8]
  char *rp;
  u8_t *ap;
  u8_t rem;
  u8_t n;
  u8_t i;
  int len = 0;
 800eefc:	2500      	movs	r5, #0
 800eefe:	e000      	b.n	800ef02 <ipaddr_ntoa_r+0x2e>
  for(n = 0; n < 4; n++) {
    i = 0;
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
 800ef00:	4635      	mov	r5, r6
  rp = buf;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
    i = 0;
    do {
      rem = *ap % (u8_t)10;
 800ef02:	fba0 3407 	umull	r3, r4, r0, r7
 800ef06:	08e4      	lsrs	r4, r4, #3
 800ef08:	eb04 0384 	add.w	r3, r4, r4, lsl #2
 800ef0c:	eba7 0343 	sub.w	r3, r7, r3, lsl #1
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
 800ef10:	3330      	adds	r3, #48	; 0x30
 800ef12:	af02      	add	r7, sp, #8
 800ef14:	442f      	add	r7, r5
 800ef16:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 800ef1a:	1c6e      	adds	r6, r5, #1
 800ef1c:	f807 3c08 	strb.w	r3, [r7, #-8]
 800ef20:	b2f6      	uxtb	r6, r6
    } while(*ap);
 800ef22:	f004 07ff 	and.w	r7, r4, #255	; 0xff
 800ef26:	2c00      	cmp	r4, #0
 800ef28:	d1ea      	bne.n	800ef00 <ipaddr_ntoa_r+0x2c>
 800ef2a:	f808 7b01 	strb.w	r7, [r8], #1
    while(i--) {
 800ef2e:	b35e      	cbz	r6, 800ef88 <ipaddr_ntoa_r+0xb4>
      if (len++ >= buflen) {
 800ef30:	455a      	cmp	r2, fp
 800ef32:	f10b 0601 	add.w	r6, fp, #1
 800ef36:	dd21      	ble.n	800ef7c <ipaddr_ntoa_r+0xa8>
 800ef38:	1e6c      	subs	r4, r5, #1
 800ef3a:	b2e4      	uxtb	r4, r4
 800ef3c:	e007      	b.n	800ef4e <ipaddr_ntoa_r+0x7a>
 800ef3e:	3601      	adds	r6, #1
 800ef40:	4566      	cmp	r6, ip
 800ef42:	d01b      	beq.n	800ef7c <ipaddr_ntoa_r+0xa8>
 800ef44:	ad02      	add	r5, sp, #8
 800ef46:	4425      	add	r5, r4
 800ef48:	461c      	mov	r4, r3
 800ef4a:	f815 3c08 	ldrb.w	r3, [r5, #-8]
 800ef4e:	1e65      	subs	r5, r4, #1
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--) {
 800ef50:	2cff      	cmp	r4, #255	; 0xff
      if (len++ >= buflen) {
        return NULL;
      }
      *rp++ = inv[i];
 800ef52:	f80e 3b01 	strb.w	r3, [lr], #1
 800ef56:	b2eb      	uxtb	r3, r5
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--) {
 800ef58:	d1f1      	bne.n	800ef3e <ipaddr_ntoa_r+0x6a>
      if (len++ >= buflen) {
        return NULL;
      }
      *rp++ = inv[i];
    }
    if (len++ >= buflen) {
 800ef5a:	42b2      	cmp	r2, r6
 800ef5c:	f106 0b01 	add.w	fp, r6, #1
 800ef60:	dd0c      	ble.n	800ef7c <ipaddr_ntoa_r+0xa8>

  s_addr = ip4_addr_get_u32(addr);

  rp = buf;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
 800ef62:	45d0      	cmp	r8, sl
      *rp++ = inv[i];
    }
    if (len++ >= buflen) {
      return NULL;
    }
    *rp++ = '.';
 800ef64:	f88e 9000 	strb.w	r9, [lr]
 800ef68:	f10e 0301 	add.w	r3, lr, #1

  s_addr = ip4_addr_get_u32(addr);

  rp = buf;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
 800ef6c:	d10a      	bne.n	800ef84 <ipaddr_ntoa_r+0xb0>
    }
    *rp++ = '.';
    ap++;
  }
  *--rp = 0;
  return buf;
 800ef6e:	4608      	mov	r0, r1
      return NULL;
    }
    *rp++ = '.';
    ap++;
  }
  *--rp = 0;
 800ef70:	2300      	movs	r3, #0
 800ef72:	f88e 3000 	strb.w	r3, [lr]
  return buf;
}
 800ef76:	b003      	add	sp, #12
 800ef78:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--) {
      if (len++ >= buflen) {
        return NULL;
 800ef7c:	2000      	movs	r0, #0
    *rp++ = '.';
    ap++;
  }
  *--rp = 0;
  return buf;
}
 800ef7e:	b003      	add	sp, #12
 800ef80:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      *rp++ = inv[i];
    }
    if (len++ >= buflen) {
      return NULL;
    }
    *rp++ = '.';
 800ef84:	469e      	mov	lr, r3
 800ef86:	e7b7      	b.n	800eef8 <ipaddr_ntoa_r+0x24>
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--) {
 800ef88:	465e      	mov	r6, fp
 800ef8a:	e7e6      	b.n	800ef5a <ipaddr_ntoa_r+0x86>
 800ef8c:	cccccccd 	.word	0xcccccccd

0800ef90 <ipaddr_ntoa>:
 */
char *
ipaddr_ntoa(const ip_addr_t *addr)
{
  static char str[16];
  return ipaddr_ntoa_r(addr, str, 16);
 800ef90:	2210      	movs	r2, #16
 800ef92:	4901      	ldr	r1, [pc, #4]	; (800ef98 <ipaddr_ntoa+0x8>)
 800ef94:	f7ff bf9e 	b.w	800eed4 <ipaddr_ntoa_r>
 800ef98:	200008d0 	.word	0x200008d0

0800ef9c <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
 800ef9c:	b538      	push	{r3, r4, r5, lr}
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
 800ef9e:	4b0f      	ldr	r3, [pc, #60]	; (800efdc <ip_reass_dequeue_datagram+0x40>)
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
 800efa0:	4604      	mov	r4, r0
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
 800efa2:	681a      	ldr	r2, [r3, #0]
 800efa4:	4282      	cmp	r2, r0
 800efa6:	d009      	beq.n	800efbc <ip_reass_dequeue_datagram+0x20>
 800efa8:	460d      	mov	r5, r1
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
 800efaa:	b179      	cbz	r1, 800efcc <ip_reass_dequeue_datagram+0x30>
    prev->next = ipr->next;
 800efac:	6823      	ldr	r3, [r4, #0]
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
 800efae:	4621      	mov	r1, r4
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
    prev->next = ipr->next;
 800efb0:	602b      	str	r3, [r5, #0]
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
 800efb2:	2005      	movs	r0, #5
}
 800efb4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    LWIP_ASSERT("sanity check linked list", prev != NULL);
    prev->next = ipr->next;
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
 800efb8:	f000 bea0 	b.w	800fcfc <memp_free>
{
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
    /* it was the first in the list */
    reassdatagrams = ipr->next;
 800efbc:	6802      	ldr	r2, [r0, #0]
    LWIP_ASSERT("sanity check linked list", prev != NULL);
    prev->next = ipr->next;
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
 800efbe:	4621      	mov	r1, r4
{
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
    /* it was the first in the list */
    reassdatagrams = ipr->next;
 800efc0:	601a      	str	r2, [r3, #0]
    LWIP_ASSERT("sanity check linked list", prev != NULL);
    prev->next = ipr->next;
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
 800efc2:	2005      	movs	r0, #5
}
 800efc4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    LWIP_ASSERT("sanity check linked list", prev != NULL);
    prev->next = ipr->next;
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
 800efc8:	f000 be98 	b.w	800fcfc <memp_free>
  if (reassdatagrams == ipr) {
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
 800efcc:	4b04      	ldr	r3, [pc, #16]	; (800efe0 <ip_reass_dequeue_datagram+0x44>)
 800efce:	f240 1239 	movw	r2, #313	; 0x139
 800efd2:	4904      	ldr	r1, [pc, #16]	; (800efe4 <ip_reass_dequeue_datagram+0x48>)
 800efd4:	4804      	ldr	r0, [pc, #16]	; (800efe8 <ip_reass_dequeue_datagram+0x4c>)
 800efd6:	f005 fecf 	bl	8014d78 <iprintf>
 800efda:	e7e7      	b.n	800efac <ip_reass_dequeue_datagram+0x10>
 800efdc:	200008e0 	.word	0x200008e0
 800efe0:	08017840 	.word	0x08017840
 800efe4:	08017858 	.word	0x08017858
 800efe8:	0801660c 	.word	0x0801660c

0800efec <ip_reass_free_complete_datagram>:
  u16_t pbufs_freed = 0;
  u8_t clen;
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
 800efec:	4281      	cmp	r1, r0
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
 800efee:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800eff2:	4607      	mov	r7, r0
 800eff4:	4688      	mov	r8, r1
  u16_t pbufs_freed = 0;
  u8_t clen;
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
 800eff6:	d05a      	beq.n	800f0ae <ip_reass_free_complete_datagram+0xc2>
  if (prev != NULL) {
 800eff8:	f1b8 0f00 	cmp.w	r8, #0
 800effc:	d009      	beq.n	800f012 <ip_reass_free_complete_datagram+0x26>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
 800effe:	f8d8 3000 	ldr.w	r3, [r8]
 800f002:	429f      	cmp	r7, r3
 800f004:	d005      	beq.n	800f012 <ip_reass_free_complete_datagram+0x26>
 800f006:	4b2d      	ldr	r3, [pc, #180]	; (800f0bc <ip_reass_free_complete_datagram+0xd0>)
 800f008:	22a7      	movs	r2, #167	; 0xa7
 800f00a:	492d      	ldr	r1, [pc, #180]	; (800f0c0 <ip_reass_free_complete_datagram+0xd4>)
 800f00c:	482d      	ldr	r0, [pc, #180]	; (800f0c4 <ip_reass_free_complete_datagram+0xd8>)
 800f00e:	f005 feb3 	bl	8014d78 <iprintf>
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
 800f012:	687d      	ldr	r5, [r7, #4]
 800f014:	6868      	ldr	r0, [r5, #4]
  if (iprh->start == 0) {
 800f016:	8883      	ldrh	r3, [r0, #4]
 800f018:	2b00      	cmp	r3, #0
 800f01a:	d031      	beq.n	800f080 <ip_reass_free_complete_datagram+0x94>
 800f01c:	4603      	mov	r3, r0
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  u16_t pbufs_freed = 0;
 800f01e:	2600      	movs	r6, #0
 800f020:	e006      	b.n	800f030 <ip_reass_free_complete_datagram+0x44>
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
    clen = pbuf_clen(pcur);
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    pbufs_freed += clen;
    pbuf_free(pcur);
 800f022:	4628      	mov	r0, r5
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
    clen = pbuf_clen(pcur);
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    pbufs_freed += clen;
 800f024:	b2b6      	uxth	r6, r6
    pbuf_free(pcur);
 800f026:	f000 ffff 	bl	8010028 <pbuf_free>
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
 800f02a:	b1ac      	cbz	r4, 800f058 <ip_reass_free_complete_datagram+0x6c>
 800f02c:	4625      	mov	r5, r4
 800f02e:	6863      	ldr	r3, [r4, #4]
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
    clen = pbuf_clen(pcur);
 800f030:	4628      	mov	r0, r5
  while (p != NULL) {
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
 800f032:	681c      	ldr	r4, [r3, #0]
    clen = pbuf_clen(pcur);
 800f034:	f001 f99e 	bl	8010374 <pbuf_clen>
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
 800f038:	4406      	add	r6, r0
 800f03a:	f5b6 3f80 	cmp.w	r6, #65536	; 0x10000
 800f03e:	dbf0      	blt.n	800f022 <ip_reass_free_complete_datagram+0x36>
 800f040:	4b1e      	ldr	r3, [pc, #120]	; (800f0bc <ip_reass_free_complete_datagram+0xd0>)
 800f042:	22c6      	movs	r2, #198	; 0xc6
 800f044:	4920      	ldr	r1, [pc, #128]	; (800f0c8 <ip_reass_free_complete_datagram+0xdc>)
 800f046:	481f      	ldr	r0, [pc, #124]	; (800f0c4 <ip_reass_free_complete_datagram+0xd8>)
 800f048:	f005 fe96 	bl	8014d78 <iprintf>
    pbufs_freed += clen;
    pbuf_free(pcur);
 800f04c:	4628      	mov	r0, r5
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
    clen = pbuf_clen(pcur);
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    pbufs_freed += clen;
 800f04e:	b2b6      	uxth	r6, r6
    pbuf_free(pcur);
 800f050:	f000 ffea 	bl	8010028 <pbuf_free>
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
 800f054:	2c00      	cmp	r4, #0
 800f056:	d1e9      	bne.n	800f02c <ip_reass_free_complete_datagram+0x40>
    pbufs_freed += clen;
    pbuf_free(pcur);
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
 800f058:	4c1c      	ldr	r4, [pc, #112]	; (800f0cc <ip_reass_free_complete_datagram+0xe0>)
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    pbufs_freed += clen;
    pbuf_free(pcur);
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
 800f05a:	4641      	mov	r1, r8
 800f05c:	4638      	mov	r0, r7
 800f05e:	f7ff ff9d 	bl	800ef9c <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
 800f062:	88a3      	ldrh	r3, [r4, #4]
 800f064:	42b3      	cmp	r3, r6
 800f066:	d206      	bcs.n	800f076 <ip_reass_free_complete_datagram+0x8a>
 800f068:	4b14      	ldr	r3, [pc, #80]	; (800f0bc <ip_reass_free_complete_datagram+0xd0>)
 800f06a:	22cc      	movs	r2, #204	; 0xcc
 800f06c:	4918      	ldr	r1, [pc, #96]	; (800f0d0 <ip_reass_free_complete_datagram+0xe4>)
 800f06e:	4815      	ldr	r0, [pc, #84]	; (800f0c4 <ip_reass_free_complete_datagram+0xd8>)
 800f070:	f005 fe82 	bl	8014d78 <iprintf>
 800f074:	88a3      	ldrh	r3, [r4, #4]
  ip_reass_pbufcount -= pbufs_freed;
 800f076:	1b9b      	subs	r3, r3, r6
 800f078:	80a3      	strh	r3, [r4, #4]

  return pbufs_freed;
}
 800f07a:	4630      	mov	r0, r6
 800f07c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  if (iprh->start == 0) {
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
    ipr->p = iprh->next_pbuf;
 800f080:	6803      	ldr	r3, [r0, #0]
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
 800f082:	2214      	movs	r2, #20
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  if (iprh->start == 0) {
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
    ipr->p = iprh->next_pbuf;
 800f084:	607b      	str	r3, [r7, #4]
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
 800f086:	f107 0108 	add.w	r1, r7, #8
 800f08a:	f005 fe62 	bl	8014d52 <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
 800f08e:	2101      	movs	r1, #1
 800f090:	4628      	mov	r0, r5
 800f092:	f005 fdab 	bl	8014bec <icmp_time_exceeded>
    clen = pbuf_clen(p);
 800f096:	4628      	mov	r0, r5
 800f098:	f001 f96c 	bl	8010374 <pbuf_clen>
    LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
    pbufs_freed += clen;
 800f09c:	b286      	uxth	r6, r0
    pbuf_free(p);
 800f09e:	4628      	mov	r0, r5
 800f0a0:	f000 ffc2 	bl	8010028 <pbuf_free>
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
 800f0a4:	687d      	ldr	r5, [r7, #4]
  while (p != NULL) {
 800f0a6:	2d00      	cmp	r5, #0
 800f0a8:	d0d6      	beq.n	800f058 <ip_reass_free_complete_datagram+0x6c>
 800f0aa:	686b      	ldr	r3, [r5, #4]
 800f0ac:	e7c0      	b.n	800f030 <ip_reass_free_complete_datagram+0x44>
  u16_t pbufs_freed = 0;
  u8_t clen;
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
 800f0ae:	4b03      	ldr	r3, [pc, #12]	; (800f0bc <ip_reass_free_complete_datagram+0xd0>)
 800f0b0:	22a5      	movs	r2, #165	; 0xa5
 800f0b2:	4908      	ldr	r1, [pc, #32]	; (800f0d4 <ip_reass_free_complete_datagram+0xe8>)
 800f0b4:	4803      	ldr	r0, [pc, #12]	; (800f0c4 <ip_reass_free_complete_datagram+0xd8>)
 800f0b6:	f005 fe5f 	bl	8014d78 <iprintf>
 800f0ba:	e79d      	b.n	800eff8 <ip_reass_free_complete_datagram+0xc>
 800f0bc:	08017840 	.word	0x08017840
 800f0c0:	08017880 	.word	0x08017880
 800f0c4:	0801660c 	.word	0x0801660c
 800f0c8:	08017894 	.word	0x08017894
 800f0cc:	200008e0 	.word	0x200008e0
 800f0d0:	080178b4 	.word	0x080178b4
 800f0d4:	08017874 	.word	0x08017874

0800f0d8 <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
 800f0d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800f0dc:	4607      	mov	r7, r0
 800f0de:	460e      	mov	r6, r1
 800f0e0:	4d1a      	ldr	r5, [pc, #104]	; (800f14c <ip_reass_remove_oldest_datagram+0x74>)
  /* @todo Can't we simply remove the last datagram in the
   *       linked list behind reassdatagrams?
   */
  struct ip_reassdata *r, *oldest, *prev;
  int pbufs_freed = 0, pbufs_freed_current;
 800f0e2:	f04f 0800 	mov.w	r8, #0
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
 800f0e6:	682b      	ldr	r3, [r5, #0]
    while (r != NULL) {
 800f0e8:	b36b      	cbz	r3, 800f146 <ip_reass_remove_oldest_datagram+0x6e>
 800f0ea:	2400      	movs	r4, #0
 800f0ec:	4621      	mov	r1, r4
 800f0ee:	4620      	mov	r0, r4
 800f0f0:	f8d7 c00c 	ldr.w	ip, [r7, #12]
 800f0f4:	e00b      	b.n	800f10e <ip_reass_remove_oldest_datagram+0x36>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
        /* Not the same datagram as fraghdr */
        other_datagrams++;
 800f0f6:	3401      	adds	r4, #1
        if (oldest == NULL) {
 800f0f8:	b1c8      	cbz	r0, 800f12e <ip_reass_remove_oldest_datagram+0x56>
          oldest = r;
        } else if (r->timer <= oldest->timer) {
 800f0fa:	f893 e01f 	ldrb.w	lr, [r3, #31]
 800f0fe:	7fc2      	ldrb	r2, [r0, #31]
 800f100:	4596      	cmp	lr, r2
 800f102:	bf98      	it	ls
 800f104:	4618      	movls	r0, r3
          /* older than the previous oldest */
          oldest = r;
        }
      }
      if (r->next != NULL) {
 800f106:	681a      	ldr	r2, [r3, #0]
 800f108:	b1aa      	cbz	r2, 800f136 <ip_reass_remove_oldest_datagram+0x5e>
 800f10a:	4619      	mov	r1, r3
 800f10c:	4613      	mov	r3, r2
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
 800f10e:	695a      	ldr	r2, [r3, #20]
 800f110:	4562      	cmp	r2, ip
 800f112:	d1f0      	bne.n	800f0f6 <ip_reass_remove_oldest_datagram+0x1e>
 800f114:	f8d7 e010 	ldr.w	lr, [r7, #16]
 800f118:	699a      	ldr	r2, [r3, #24]
 800f11a:	4572      	cmp	r2, lr
 800f11c:	d1eb      	bne.n	800f0f6 <ip_reass_remove_oldest_datagram+0x1e>
 800f11e:	f8b3 e00c 	ldrh.w	lr, [r3, #12]
 800f122:	88ba      	ldrh	r2, [r7, #4]
 800f124:	4596      	cmp	lr, r2
 800f126:	d0ee      	beq.n	800f106 <ip_reass_remove_oldest_datagram+0x2e>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
 800f128:	3401      	adds	r4, #1
        if (oldest == NULL) {
 800f12a:	2800      	cmp	r0, #0
 800f12c:	d1e5      	bne.n	800f0fa <ip_reass_remove_oldest_datagram+0x22>
        } else if (r->timer <= oldest->timer) {
          /* older than the previous oldest */
          oldest = r;
        }
      }
      if (r->next != NULL) {
 800f12e:	681a      	ldr	r2, [r3, #0]
 800f130:	4618      	mov	r0, r3
 800f132:	2a00      	cmp	r2, #0
 800f134:	d1e9      	bne.n	800f10a <ip_reass_remove_oldest_datagram+0x32>
        prev = r;
      }
      r = r->next;
    }
    if (oldest != NULL) {
 800f136:	b110      	cbz	r0, 800f13e <ip_reass_remove_oldest_datagram+0x66>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
 800f138:	f7ff ff58 	bl	800efec <ip_reass_free_complete_datagram>
      pbufs_freed += pbufs_freed_current;
 800f13c:	4480      	add	r8, r0
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
 800f13e:	45b0      	cmp	r8, r6
 800f140:	da01      	bge.n	800f146 <ip_reass_remove_oldest_datagram+0x6e>
 800f142:	2c01      	cmp	r4, #1
 800f144:	dccf      	bgt.n	800f0e6 <ip_reass_remove_oldest_datagram+0xe>
  return pbufs_freed;
}
 800f146:	4640      	mov	r0, r8
 800f148:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800f14c:	200008e0 	.word	0x200008e0

0800f150 <ip_reass_tmr>:
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
 800f150:	b538      	push	{r3, r4, r5, lr}
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
 800f152:	4b0a      	ldr	r3, [pc, #40]	; (800f17c <ip_reass_tmr+0x2c>)
 800f154:	6818      	ldr	r0, [r3, #0]
  while (r != NULL) {
 800f156:	b140      	cbz	r0, 800f16a <ip_reass_tmr+0x1a>
 800f158:	2400      	movs	r4, #0
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
 800f15a:	7fc3      	ldrb	r3, [r0, #31]
      r->timer--;
 800f15c:	1e5a      	subs	r2, r3, #1

  r = reassdatagrams;
  while (r != NULL) {
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
 800f15e:	b12b      	cbz	r3, 800f16c <ip_reass_tmr+0x1c>
      r->timer--;
 800f160:	77c2      	strb	r2, [r0, #31]
 800f162:	4604      	mov	r4, r0
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
      prev = r;
      r = r->next;
 800f164:	6800      	ldr	r0, [r0, #0]
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  while (r != NULL) {
 800f166:	2800      	cmp	r0, #0
 800f168:	d1f7      	bne.n	800f15a <ip_reass_tmr+0xa>
 800f16a:	bd38      	pop	{r3, r4, r5, pc}
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
      /* get the next pointer before freeing */
      r = r->next;
 800f16c:	6805      	ldr	r5, [r0, #0]
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
 800f16e:	4621      	mov	r1, r4
 800f170:	f7ff ff3c 	bl	800efec <ip_reass_free_complete_datagram>
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
      /* get the next pointer before freeing */
      r = r->next;
 800f174:	4628      	mov	r0, r5
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  while (r != NULL) {
 800f176:	2800      	cmp	r0, #0
 800f178:	d1ef      	bne.n	800f15a <ip_reass_tmr+0xa>
 800f17a:	e7f6      	b.n	800f16a <ip_reass_tmr+0x1a>
 800f17c:	200008e0 	.word	0x200008e0

0800f180 <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
 800f180:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  struct ip_reassdata *ipr_prev = NULL;

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
 800f184:	6846      	ldr	r6, [r0, #4]
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
 800f186:	b083      	sub	sp, #12
  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
 800f188:	7833      	ldrb	r3, [r6, #0]
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
 800f18a:	4680      	mov	r8, r0
  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
 800f18c:	f003 030f 	and.w	r3, r3, #15
 800f190:	2b05      	cmp	r3, #5
 800f192:	f040 815e 	bne.w	800f452 <ip_reass+0x2d2>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
 800f196:	88f0      	ldrh	r0, [r6, #6]
 800f198:	f7fe fd02 	bl	800dba0 <lwip_ntohs>
 800f19c:	4682      	mov	sl, r0
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 800f19e:	8870      	ldrh	r0, [r6, #2]
 800f1a0:	f7fe fcfe 	bl	800dba0 <lwip_ntohs>
 800f1a4:	7833      	ldrb	r3, [r6, #0]
 800f1a6:	4683      	mov	fp, r0

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
 800f1a8:	4640      	mov	r0, r8
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 800f1aa:	9300      	str	r3, [sp, #0]

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
 800f1ac:	f001 f8e2 	bl	8010374 <pbuf_clen>
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
 800f1b0:	4fc9      	ldr	r7, [pc, #804]	; (800f4d8 <ip_reass+0x358>)

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
 800f1b2:	4681      	mov	r9, r0
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
 800f1b4:	88bb      	ldrh	r3, [r7, #4]
 800f1b6:	4403      	add	r3, r0
 800f1b8:	2b0a      	cmp	r3, #10
 800f1ba:	f300 8140 	bgt.w	800f43e <ip_reass+0x2be>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
 800f1be:	683c      	ldr	r4, [r7, #0]
 800f1c0:	2c00      	cmp	r4, #0
 800f1c2:	f000 80fd 	beq.w	800f3c0 <ip_reass+0x240>
 800f1c6:	68f2      	ldr	r2, [r6, #12]
 800f1c8:	2500      	movs	r5, #0
 800f1ca:	e005      	b.n	800f1d8 <ip_reass+0x58>
 800f1cc:	6823      	ldr	r3, [r4, #0]
 800f1ce:	4625      	mov	r5, r4
 800f1d0:	2b00      	cmp	r3, #0
 800f1d2:	f000 80f5 	beq.w	800f3c0 <ip_reass+0x240>
 800f1d6:	461c      	mov	r4, r3
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
 800f1d8:	6963      	ldr	r3, [r4, #20]
 800f1da:	4293      	cmp	r3, r2
 800f1dc:	d1f6      	bne.n	800f1cc <ip_reass+0x4c>
 800f1de:	6933      	ldr	r3, [r6, #16]
 800f1e0:	69a1      	ldr	r1, [r4, #24]
 800f1e2:	4299      	cmp	r1, r3
 800f1e4:	d1f2      	bne.n	800f1cc <ip_reass+0x4c>
 800f1e6:	89a1      	ldrh	r1, [r4, #12]
 800f1e8:	88b3      	ldrh	r3, [r6, #4]
 800f1ea:	4299      	cmp	r1, r3
 800f1ec:	d1ee      	bne.n	800f1cc <ip_reass+0x4c>
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
 800f1ee:	88f0      	ldrh	r0, [r6, #6]
 800f1f0:	f7fe fcd6 	bl	800dba0 <lwip_ntohs>
 800f1f4:	f3c0 000c 	ubfx	r0, r0, #0, #13
 800f1f8:	2800      	cmp	r0, #0
 800f1fa:	f000 8133 	beq.w	800f464 <ip_reass+0x2e4>
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
 800f1fe:	88bb      	ldrh	r3, [r7, #4]
 800f200:	4499      	add	r9, r3
 800f202:	f8a7 9004 	strh.w	r9, [r7, #4]

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
 800f206:	88f3      	ldrh	r3, [r6, #6]
 800f208:	0699      	lsls	r1, r3, #26
 800f20a:	f140 80f4 	bpl.w	800f3f6 <ip_reass+0x276>
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
 800f20e:	f8d8 9004 	ldr.w	r9, [r8, #4]
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 800f212:	f8b9 0002 	ldrh.w	r0, [r9, #2]
 800f216:	f7fe fcc3 	bl	800dba0 <lwip_ntohs>
 800f21a:	f899 6000 	ldrb.w	r6, [r9]
 800f21e:	f006 060f 	and.w	r6, r6, #15
 800f222:	eba0 0686 	sub.w	r6, r0, r6, lsl #2
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
 800f226:	f8b9 0006 	ldrh.w	r0, [r9, #6]
 800f22a:	f7fe fcb9 	bl	800dba0 <lwip_ntohs>
 800f22e:	f3c0 000c 	ubfx	r0, r0, #0, #13
 800f232:	00c0      	lsls	r0, r0, #3
  struct ip_hdr *fraghdr;
  int valid = 1;

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
 800f234:	b2b6      	uxth	r6, r6
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
 800f236:	f8d8 a004 	ldr.w	sl, [r8, #4]
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
 800f23a:	6862      	ldr	r2, [r4, #4]
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  iprh->next_pbuf = NULL;
  iprh->start = offset;
  iprh->end = offset + len;
 800f23c:	eb06 0e00 	add.w	lr, r6, r0
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  iprh->next_pbuf = NULL;
 800f240:	2300      	movs	r3, #0
  iprh->start = offset;
  iprh->end = offset + len;
 800f242:	fa1f fe8e 	uxth.w	lr, lr
 800f246:	f8aa e006 	strh.w	lr, [sl, #6]
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  iprh->next_pbuf = NULL;
  iprh->start = offset;
 800f24a:	f8aa 0004 	strh.w	r0, [sl, #4]
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  iprh->next_pbuf = NULL;
 800f24e:	f88a 3000 	strb.w	r3, [sl]
 800f252:	f88a 3001 	strb.w	r3, [sl, #1]
 800f256:	f88a 3002 	strb.w	r3, [sl, #2]
 800f25a:	f88a 3003 	strb.w	r3, [sl, #3]
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
 800f25e:	2a00      	cmp	r2, #0
 800f260:	f000 8131 	beq.w	800f4c6 <ip_reass+0x346>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
 800f264:	6856      	ldr	r6, [r2, #4]
    if (iprh->start < iprh_tmp->start) {
 800f266:	88b3      	ldrh	r3, [r6, #4]
 800f268:	4298      	cmp	r0, r3
 800f26a:	f0c0 810d 	bcc.w	800f488 <ip_reass+0x308>
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
 800f26e:	f000 80d7 	beq.w	800f420 <ip_reass+0x2a0>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
 800f272:	88f3      	ldrh	r3, [r6, #6]
 800f274:	4283      	cmp	r3, r0
 800f276:	f200 80d3 	bhi.w	800f420 <ip_reass+0x2a0>
 800f27a:	f04f 0901 	mov.w	r9, #1
 800f27e:	e010      	b.n	800f2a2 <ip_reass+0x122>
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
 800f280:	6853      	ldr	r3, [r2, #4]
    if (iprh->start < iprh_tmp->start) {
 800f282:	8899      	ldrh	r1, [r3, #4]
 800f284:	4288      	cmp	r0, r1
 800f286:	f0c0 80c4 	bcc.w	800f412 <ip_reass+0x292>
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
 800f28a:	f000 80c9 	beq.w	800f420 <ip_reass+0x2a0>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
 800f28e:	88da      	ldrh	r2, [r3, #6]
 800f290:	4282      	cmp	r2, r0
 800f292:	f200 80c5 	bhi.w	800f420 <ip_reass+0x2a0>
      goto freepbuf;
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
        if (iprh_prev->end != iprh_tmp->start) {
 800f296:	88f2      	ldrh	r2, [r6, #6]
          /* There is a fragment missing between the current
           * and the previous fragment */
          valid = 0;
 800f298:	461e      	mov	r6, r3
 800f29a:	428a      	cmp	r2, r1
 800f29c:	bf18      	it	ne
 800f29e:	f04f 0900 	movne.w	r9, #0
        }
      }
    }
    q = iprh_tmp->next_pbuf;
 800f2a2:	6832      	ldr	r2, [r6, #0]
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
 800f2a4:	2a00      	cmp	r2, #0
 800f2a6:	d1eb      	bne.n	800f280 <ip_reass+0x100>
  if (q == NULL) {
    if (iprh_prev != NULL) {
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
 800f2a8:	88f3      	ldrh	r3, [r6, #6]
 800f2aa:	4298      	cmp	r0, r3
 800f2ac:	f0c0 8100 	bcc.w	800f4b0 <ip_reass+0x330>
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
      if (iprh_prev->end != iprh->start) {
 800f2b0:	4298      	cmp	r0, r3
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
 800f2b2:	f8c6 8000 	str.w	r8, [r6]
      if (iprh_prev->end != iprh->start) {
 800f2b6:	f040 80bc 	bne.w	800f432 <ip_reass+0x2b2>
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
 800f2ba:	7fa3      	ldrb	r3, [r4, #30]
 800f2bc:	07db      	lsls	r3, r3, #31
 800f2be:	f140 80b8 	bpl.w	800f432 <ip_reass+0x2b2>
    /* and had no wholes so far */
    if (valid) {
 800f2c2:	f1b9 0f00 	cmp.w	r9, #0
 800f2c6:	f000 80b4 	beq.w	800f432 <ip_reass+0x2b2>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
 800f2ca:	6863      	ldr	r3, [r4, #4]
 800f2cc:	6858      	ldr	r0, [r3, #4]
 800f2ce:	8883      	ldrh	r3, [r0, #4]
 800f2d0:	2b00      	cmp	r3, #0
 800f2d2:	f040 80ae 	bne.w	800f432 <ip_reass+0x2b2>
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
 800f2d6:	f8da 3000 	ldr.w	r3, [sl]
        while (q != NULL) {
 800f2da:	2b00      	cmp	r3, #0
 800f2dc:	f000 80fa 	beq.w	800f4d4 <ip_reass+0x354>
          iprh = (struct ip_reass_helper*)q->payload;
 800f2e0:	685e      	ldr	r6, [r3, #4]
          if (iprh_prev->end != iprh->start) {
 800f2e2:	f8ba 2006 	ldrh.w	r2, [sl, #6]
 800f2e6:	88b3      	ldrh	r3, [r6, #4]
 800f2e8:	429a      	cmp	r2, r3
 800f2ea:	d007      	beq.n	800f2fc <ip_reass+0x17c>
 800f2ec:	e0a1      	b.n	800f432 <ip_reass+0x2b2>
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
          iprh = (struct ip_reass_helper*)q->payload;
 800f2ee:	685b      	ldr	r3, [r3, #4]
          if (iprh_prev->end != iprh->start) {
 800f2f0:	88f1      	ldrh	r1, [r6, #6]
 800f2f2:	889a      	ldrh	r2, [r3, #4]
 800f2f4:	4291      	cmp	r1, r2
 800f2f6:	f040 809c 	bne.w	800f432 <ip_reass+0x2b2>
 800f2fa:	461e      	mov	r6, r3
            valid = 0;
            break;
          }
          iprh_prev = iprh;
          q = iprh->next_pbuf;
 800f2fc:	6833      	ldr	r3, [r6, #0]
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
 800f2fe:	2b00      	cmp	r3, #0
 800f300:	d1f5      	bne.n	800f2ee <ip_reass+0x16e>
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
          LWIP_ASSERT("sanity check", ipr->p != NULL);
          LWIP_ASSERT("sanity check",
 800f302:	4286      	cmp	r6, r0
 800f304:	d10f      	bne.n	800f326 <ip_reass+0x1a6>
 800f306:	4b75      	ldr	r3, [pc, #468]	; (800f4dc <ip_reass+0x35c>)
 800f308:	f44f 72df 	mov.w	r2, #446	; 0x1be
 800f30c:	4974      	ldr	r1, [pc, #464]	; (800f4e0 <ip_reass+0x360>)
 800f30e:	4875      	ldr	r0, [pc, #468]	; (800f4e4 <ip_reass+0x364>)
 800f310:	f005 fd32 	bl	8014d78 <iprintf>
            ((struct ip_reass_helper*)ipr->p->payload) != iprh);
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
 800f314:	6833      	ldr	r3, [r6, #0]
 800f316:	b133      	cbz	r3, 800f326 <ip_reass+0x1a6>
 800f318:	4b70      	ldr	r3, [pc, #448]	; (800f4dc <ip_reass+0x35c>)
 800f31a:	f44f 72e0 	mov.w	r2, #448	; 0x1c0
 800f31e:	4972      	ldr	r1, [pc, #456]	; (800f4e8 <ip_reass+0x368>)
 800f320:	4870      	ldr	r0, [pc, #448]	; (800f4e4 <ip_reass+0x364>)
 800f322:	f005 fd29 	bl	8014d78 <iprintf>
            iprh->next_pbuf == NULL);
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
 800f326:	88f2      	ldrh	r2, [r6, #6]
 800f328:	8ba3      	ldrh	r3, [r4, #28]
 800f32a:	429a      	cmp	r2, r3
 800f32c:	d007      	beq.n	800f33e <ip_reass+0x1be>
 800f32e:	4b6b      	ldr	r3, [pc, #428]	; (800f4dc <ip_reass+0x35c>)
 800f330:	f44f 72e1 	mov.w	r2, #450	; 0x1c2
 800f334:	496d      	ldr	r1, [pc, #436]	; (800f4ec <ip_reass+0x36c>)
 800f336:	486b      	ldr	r0, [pc, #428]	; (800f4e4 <ip_reass+0x364>)
 800f338:	f005 fd1e 	bl	8014d78 <iprintf>
 800f33c:	8ba3      	ldrh	r3, [r4, #28]
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
 800f33e:	6862      	ldr	r2, [r4, #4]
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
 800f340:	3314      	adds	r3, #20

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
 800f342:	f8d2 8004 	ldr.w	r8, [r2, #4]

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
 800f346:	f104 0108 	add.w	r1, r4, #8
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
 800f34a:	83a3      	strh	r3, [r4, #28]
    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
 800f34c:	2214      	movs	r2, #20
 800f34e:	4640      	mov	r0, r8
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
 800f350:	f8d8 6000 	ldr.w	r6, [r8]

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
 800f354:	f005 fcfd 	bl	8014d52 <memcpy>
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
 800f358:	8ba0      	ldrh	r0, [r4, #28]
 800f35a:	f7fe fc1d 	bl	800db98 <lwip_htons>
    IPH_OFFSET_SET(fraghdr, 0);
 800f35e:	2300      	movs	r3, #0
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
 800f360:	f8a8 0002 	strh.w	r0, [r8, #2]
    IPH_OFFSET_SET(fraghdr, 0);
 800f364:	f888 3006 	strb.w	r3, [r8, #6]
 800f368:	f888 3007 	strb.w	r3, [r8, #7]
    IPH_CHKSUM_SET(fraghdr, 0);
 800f36c:	f888 300a 	strb.w	r3, [r8, #10]
 800f370:	f888 300b 	strb.w	r3, [r8, #11]
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
 800f374:	4640      	mov	r0, r8
 800f376:	2114      	movs	r1, #20
 800f378:	f7ff fae6 	bl	800e948 <inet_chksum>

    p = ipr->p;
 800f37c:	f8d4 9004 	ldr.w	r9, [r4, #4]
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
    IPH_OFFSET_SET(fraghdr, 0);
    IPH_CHKSUM_SET(fraghdr, 0);
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
 800f380:	f8a8 000a 	strh.w	r0, [r8, #10]

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
 800f384:	b176      	cbz	r6, 800f3a4 <ip_reass+0x224>
      iprh = (struct ip_reass_helper*)r->payload;
 800f386:	f8d6 8004 	ldr.w	r8, [r6, #4]

      /* hide the ip header for every succeding fragment */
      pbuf_header(r, -IP_HLEN);
 800f38a:	f06f 0113 	mvn.w	r1, #19
 800f38e:	4630      	mov	r0, r6
 800f390:	f000 fdf2 	bl	800ff78 <pbuf_header>
      pbuf_cat(p, r);
 800f394:	4631      	mov	r1, r6
 800f396:	4648      	mov	r0, r9
 800f398:	f001 f804 	bl	80103a4 <pbuf_cat>
      r = iprh->next_pbuf;
 800f39c:	f8d8 6000 	ldr.w	r6, [r8]
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
 800f3a0:	2e00      	cmp	r6, #0
 800f3a2:	d1f0      	bne.n	800f386 <ip_reass+0x206>
      pbuf_header(r, -IP_HLEN);
      pbuf_cat(p, r);
      r = iprh->next_pbuf;
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
 800f3a4:	4629      	mov	r1, r5
 800f3a6:	4620      	mov	r0, r4
 800f3a8:	f7ff fdf8 	bl	800ef9c <ip_reass_dequeue_datagram>

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
 800f3ac:	4648      	mov	r0, r9
 800f3ae:	f000 ffe1 	bl	8010374 <pbuf_clen>
 800f3b2:	88bb      	ldrh	r3, [r7, #4]
 800f3b4:	1a18      	subs	r0, r3, r0
 800f3b6:	80b8      	strh	r0, [r7, #4]
nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  return NULL;
}
 800f3b8:	4648      	mov	r0, r9
 800f3ba:	b003      	add	sp, #12
 800f3bc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
 800f3c0:	2005      	movs	r0, #5
 800f3c2:	f000 fc65 	bl	800fc90 <memp_malloc>
  if (ipr == NULL) {
 800f3c6:	4603      	mov	r3, r0
 800f3c8:	2800      	cmp	r0, #0
 800f3ca:	d064      	beq.n	800f496 <ip_reass+0x316>
      IPFRAG_STATS_INC(ip_frag.memerr);
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
 800f3cc:	2220      	movs	r2, #32
 800f3ce:	2100      	movs	r1, #0
 800f3d0:	4618      	mov	r0, r3
 800f3d2:	9301      	str	r3, [sp, #4]
 800f3d4:	f005 fcc8 	bl	8014d68 <memset>
  ipr->timer = IP_REASS_MAXAGE;

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
 800f3d8:	9b01      	ldr	r3, [sp, #4]
 800f3da:	6839      	ldr	r1, [r7, #0]
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
  ipr->timer = IP_REASS_MAXAGE;
 800f3dc:	2203      	movs	r2, #3

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
 800f3de:	6019      	str	r1, [r3, #0]
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
  ipr->timer = IP_REASS_MAXAGE;
 800f3e0:	77da      	strb	r2, [r3, #31]
  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
  reassdatagrams = ipr;
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
 800f3e2:	4631      	mov	r1, r6
 800f3e4:	2214      	movs	r2, #20
 800f3e6:	f103 0008 	add.w	r0, r3, #8
 800f3ea:	4625      	mov	r5, r4
  memset(ipr, 0, sizeof(struct ip_reassdata));
  ipr->timer = IP_REASS_MAXAGE;

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
  reassdatagrams = ipr;
 800f3ec:	603b      	str	r3, [r7, #0]
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
 800f3ee:	461c      	mov	r4, r3
 800f3f0:	f005 fcaf 	bl	8014d52 <memcpy>
 800f3f4:	e703      	b.n	800f1fe <ip_reass+0x7e>
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
    ipr->datagram_len = offset + len;
 800f3f6:	9b00      	ldr	r3, [sp, #0]
  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
 800f3f8:	7fa2      	ldrb	r2, [r4, #30]
    ipr->datagram_len = offset + len;
 800f3fa:	f003 030f 	and.w	r3, r3, #15
 800f3fe:	ebab 0b83 	sub.w	fp, fp, r3, lsl #2
 800f402:	eb0b 0aca 	add.w	sl, fp, sl, lsl #3
  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
 800f406:	f042 0301 	orr.w	r3, r2, #1
    ipr->datagram_len = offset + len;
 800f40a:	f8a4 a01c 	strh.w	sl, [r4, #28]
  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0) {
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
 800f40e:	77a3      	strb	r3, [r4, #30]
 800f410:	e6fd      	b.n	800f20e <ip_reass+0x8e>
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
    if (iprh->start < iprh_tmp->start) {
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
 800f412:	f8ca 2000 	str.w	r2, [sl]
      if (iprh_prev != NULL) {
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
 800f416:	88f3      	ldrh	r3, [r6, #6]
 800f418:	4283      	cmp	r3, r0
 800f41a:	d801      	bhi.n	800f420 <ip_reass+0x2a0>
 800f41c:	458e      	cmp	lr, r1
 800f41e:	d930      	bls.n	800f482 <ip_reass+0x302>
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
 800f420:	4640      	mov	r0, r8
 800f422:	f000 ffa7 	bl	8010374 <pbuf_clen>
 800f426:	88bb      	ldrh	r3, [r7, #4]
 800f428:	1a1b      	subs	r3, r3, r0
  pbuf_free(new_p);
 800f42a:	4640      	mov	r0, r8
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
 800f42c:	80bb      	strh	r3, [r7, #4]
  pbuf_free(new_p);
 800f42e:	f000 fdfb 	bl	8010028 <pbuf_free>
    /* Return the pbuf chain */
    return p;
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
 800f432:	f04f 0900 	mov.w	r9, #0
nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  return NULL;
}
 800f436:	4648      	mov	r0, r9
 800f438:	b003      	add	sp, #12
 800f43a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
 800f43e:	4601      	mov	r1, r0
 800f440:	4630      	mov	r0, r6
 800f442:	f7ff fe49 	bl	800f0d8 <ip_reass_remove_oldest_datagram>
 800f446:	b120      	cbz	r0, 800f452 <ip_reass+0x2d2>
 800f448:	88bb      	ldrh	r3, [r7, #4]
 800f44a:	444b      	add	r3, r9
 800f44c:	2b0a      	cmp	r3, #10
 800f44e:	f77f aeb6 	ble.w	800f1be <ip_reass+0x3e>
  return NULL;

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
 800f452:	4640      	mov	r0, r8
  return NULL;
 800f454:	f04f 0900 	mov.w	r9, #0
  return NULL;

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
 800f458:	f000 fde6 	bl	8010028 <pbuf_free>
  return NULL;
}
 800f45c:	4648      	mov	r0, r9
 800f45e:	b003      	add	sp, #12
 800f460:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
 800f464:	89e0      	ldrh	r0, [r4, #14]
 800f466:	f7fe fb9b 	bl	800dba0 <lwip_ntohs>
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
 800f46a:	f3c0 000c 	ubfx	r0, r0, #0, #13
 800f46e:	2800      	cmp	r0, #0
 800f470:	f43f aec5 	beq.w	800f1fe <ip_reass+0x7e>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
 800f474:	2214      	movs	r2, #20
 800f476:	4631      	mov	r1, r6
 800f478:	f104 0008 	add.w	r0, r4, #8
 800f47c:	f005 fc69 	bl	8014d52 <memcpy>
 800f480:	e6bd      	b.n	800f1fe <ip_reass+0x7e>
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
 800f482:	f8c6 8000 	str.w	r8, [r6]
 800f486:	e718      	b.n	800f2ba <ip_reass+0x13a>
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
    if (iprh->start < iprh_tmp->start) {
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
 800f488:	f8ca 2000 	str.w	r2, [sl]
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
 800f48c:	f04f 0901 	mov.w	r9, #1
 800f490:	f8c4 8004 	str.w	r8, [r4, #4]
 800f494:	e711      	b.n	800f2ba <ip_reass+0x13a>
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
  if (ipr == NULL) {
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
 800f496:	4649      	mov	r1, r9
 800f498:	4630      	mov	r0, r6
 800f49a:	f7ff fe1d 	bl	800f0d8 <ip_reass_remove_oldest_datagram>
 800f49e:	4581      	cmp	r9, r0
 800f4a0:	dcd7      	bgt.n	800f452 <ip_reass+0x2d2>
      ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
 800f4a2:	2005      	movs	r0, #5
 800f4a4:	f000 fbf4 	bl	800fc90 <memp_malloc>
    }
    if (ipr == NULL)
 800f4a8:	4603      	mov	r3, r0
 800f4aa:	2800      	cmp	r0, #0
 800f4ac:	d18e      	bne.n	800f3cc <ip_reass+0x24c>
 800f4ae:	e7d0      	b.n	800f452 <ip_reass+0x2d2>
  if (q == NULL) {
    if (iprh_prev != NULL) {
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
 800f4b0:	4b0a      	ldr	r3, [pc, #40]	; (800f4dc <ip_reass+0x35c>)
 800f4b2:	f240 1293 	movw	r2, #403	; 0x193
 800f4b6:	490e      	ldr	r1, [pc, #56]	; (800f4f0 <ip_reass+0x370>)
 800f4b8:	480a      	ldr	r0, [pc, #40]	; (800f4e4 <ip_reass+0x364>)
 800f4ba:	f005 fc5d 	bl	8014d78 <iprintf>
 800f4be:	88f3      	ldrh	r3, [r6, #6]
 800f4c0:	f8ba 0004 	ldrh.w	r0, [sl, #4]
 800f4c4:	e6f4      	b.n	800f2b0 <ip_reass+0x130>
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
 800f4c6:	7fa3      	ldrb	r3, [r4, #30]
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
 800f4c8:	f8c4 8004 	str.w	r8, [r4, #4]
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
 800f4cc:	07da      	lsls	r2, r3, #31
 800f4ce:	f53f aefc 	bmi.w	800f2ca <ip_reass+0x14a>
 800f4d2:	e7ae      	b.n	800f432 <ip_reass+0x2b2>
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
 800f4d4:	4656      	mov	r6, sl
 800f4d6:	e714      	b.n	800f302 <ip_reass+0x182>
 800f4d8:	200008e0 	.word	0x200008e0
 800f4dc:	08017840 	.word	0x08017840
 800f4e0:	080178f0 	.word	0x080178f0
 800f4e4:	0801660c 	.word	0x0801660c
 800f4e8:	08017900 	.word	0x08017900
 800f4ec:	08017924 	.word	0x08017924
 800f4f0:	080178d0 	.word	0x080178d0

0800f4f4 <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, ip_addr_t *dest)
{
 800f4f4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800f4f8:	4689      	mov	r9, r1
 800f4fa:	b089      	sub	sp, #36	; 0x24
 800f4fc:	9205      	str	r2, [sp, #20]
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
 800f4fe:	2202      	movs	r2, #2
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, ip_addr_t *dest)
{
 800f500:	4604      	mov	r4, r0
 800f502:	9002      	str	r0, [sp, #8]
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
 800f504:	2100      	movs	r1, #0
 800f506:	4610      	mov	r0, r2
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
 800f508:	f8b9 7020 	ldrh.w	r7, [r9, #32]
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
 800f50c:	f000 fde4 	bl	80100d8 <pbuf_alloc>
  if (rambuf == NULL) {
 800f510:	2800      	cmp	r0, #0
 800f512:	f000 80ad 	beq.w	800f670 <ip_frag+0x17c>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  }
  rambuf->tot_len = rambuf->len = mtu;
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
 800f516:	4d58      	ldr	r5, [pc, #352]	; (800f678 <ip_frag+0x184>)
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  if (rambuf == NULL) {
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  }
  rambuf->tot_len = rambuf->len = mtu;
 800f518:	8147      	strh	r7, [r0, #10]
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
 800f51a:	f025 0503 	bic.w	r5, r5, #3
 800f51e:	6045      	str	r5, [r0, #4]

  /* Copy the IP header in it */
  iphdr = (struct ip_hdr *)rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
 800f520:	6861      	ldr	r1, [r4, #4]
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  if (rambuf == NULL) {
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  }
  rambuf->tot_len = rambuf->len = mtu;
 800f522:	8107      	strh	r7, [r0, #8]
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);

  /* Copy the IP header in it */
  iphdr = (struct ip_hdr *)rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
 800f524:	2214      	movs	r2, #20
 800f526:	4682      	mov	sl, r0
 800f528:	4628      	mov	r0, r5
 800f52a:	f005 fc12 	bl	8014d52 <memcpy>
  original_iphdr = (struct ip_hdr *)p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
 800f52e:	88e8      	ldrh	r0, [r5, #6]
 800f530:	f7fe fb36 	bl	800dba0 <lwip_ntohs>
  ofo = tmp & IP_OFFMASK;
  omf = tmp & IP_MF;
 800f534:	f400 5300 	and.w	r3, r0, #8192	; 0x2000
 800f538:	b29b      	uxth	r3, r3

  left = p->tot_len - IP_HLEN;
 800f53a:	8924      	ldrh	r4, [r4, #8]
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  ofo = tmp & IP_OFFMASK;
  omf = tmp & IP_MF;
 800f53c:	9301      	str	r3, [sp, #4]

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;
 800f53e:	f1b7 0314 	subs.w	r3, r7, #20
  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  ofo = tmp & IP_OFFMASK;
  omf = tmp & IP_MF;

  left = p->tot_len - IP_HLEN;
 800f542:	f1a4 0414 	sub.w	r4, r4, #20

  nfb = (mtu - IP_HLEN) / 8;
 800f546:	bf48      	it	mi
 800f548:	f1a7 030d 	submi.w	r3, r7, #13
 800f54c:	f3c3 03cf 	ubfx	r3, r3, #3, #16
  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  ofo = tmp & IP_OFFMASK;
  omf = tmp & IP_MF;

  left = p->tot_len - IP_HLEN;
 800f550:	b2a4      	uxth	r4, r4
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  ofo = tmp & IP_OFFMASK;
 800f552:	f3c0 060c 	ubfx	r6, r0, #0, #13
  omf = tmp & IP_MF;

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;
 800f556:	9306      	str	r3, [sp, #24]

  while (left) {
 800f558:	2c00      	cmp	r4, #0
 800f55a:	f000 8082 	beq.w	800f662 <ip_frag+0x16e>
    if (!last) {
      tmp = tmp | IP_MF;
    }

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
 800f55e:	00db      	lsls	r3, r3, #3
 800f560:	fa1f fb83 	uxth.w	fp, r3
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
 800f564:	f10b 0314 	add.w	r3, fp, #20
 800f568:	b29b      	uxth	r3, r3
 800f56a:	f04f 0814 	mov.w	r8, #20
 800f56e:	f1a7 0213 	sub.w	r2, r7, #19
 800f572:	9307      	str	r3, [sp, #28]
 800f574:	eb05 0308 	add.w	r3, r5, r8
 800f578:	9203      	str	r2, [sp, #12]
 800f57a:	9304      	str	r3, [sp, #16]
 800f57c:	e034      	b.n	800f5e8 <ip_frag+0xf4>

    /* Fill this fragment */
    cop = last ? left : nfb * 8;

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
 800f57e:	465a      	mov	r2, fp
 800f580:	9904      	ldr	r1, [sp, #16]
 800f582:	9802      	ldr	r0, [sp, #8]
 800f584:	f001 f832 	bl	80105ec <pbuf_copy_partial>
 800f588:	4480      	add	r8, r0
    poff = newpbuflen;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
 800f58a:	f447 5000 	orr.w	r0, r7, #8192	; 0x2000
 800f58e:	f7fe fb03 	bl	800db98 <lwip_htons>
 800f592:	80e8      	strh	r0, [r5, #6]
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
 800f594:	9807      	ldr	r0, [sp, #28]
 800f596:	f7fe faff 	bl	800db98 <lwip_htons>
    IPH_CHKSUM_SET(iphdr, 0);
 800f59a:	f04f 0300 	mov.w	r3, #0
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
 800f59e:	2114      	movs	r1, #20
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
 800f5a0:	8068      	strh	r0, [r5, #2]
    IPH_CHKSUM_SET(iphdr, 0);
 800f5a2:	816b      	strh	r3, [r5, #10]
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
 800f5a4:	4628      	mov	r0, r5
 800f5a6:	f7ff f9cf 	bl	800e948 <inet_chksum>
    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
 800f5aa:	2200      	movs	r2, #0

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
    IPH_CHKSUM_SET(iphdr, 0);
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
 800f5ac:	8168      	strh	r0, [r5, #10]
    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
 800f5ae:	4611      	mov	r1, r2
 800f5b0:	2002      	movs	r0, #2
 800f5b2:	f000 fd91 	bl	80100d8 <pbuf_alloc>

    /* Fill this fragment */
    cop = last ? left : nfb * 8;

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
 800f5b6:	fa1f f888 	uxth.w	r8, r8
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
    if (header != NULL) {
 800f5ba:	4607      	mov	r7, r0
 800f5bc:	2800      	cmp	r0, #0
 800f5be:	d03c      	beq.n	800f63a <ip_frag+0x146>
      pbuf_chain(header, rambuf);
 800f5c0:	4651      	mov	r1, sl
 800f5c2:	f000 ff2f 	bl	8010424 <pbuf_chain>
      netif->output(netif, header, dest);
 800f5c6:	f8d9 3014 	ldr.w	r3, [r9, #20]
 800f5ca:	9a05      	ldr	r2, [sp, #20]
 800f5cc:	4639      	mov	r1, r7
 800f5ce:	4648      	mov	r0, r9
 800f5d0:	4798      	blx	r3
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
 800f5d2:	4638      	mov	r0, r7
 800f5d4:	f000 fd28 	bl	8010028 <pbuf_free>
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
 800f5d8:	9b06      	ldr	r3, [sp, #24]
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
 800f5da:	ebcb 0404 	rsb	r4, fp, r4
    ofo += nfb;
 800f5de:	441e      	add	r6, r3
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
 800f5e0:	b2a4      	uxth	r4, r4
    ofo += nfb;
 800f5e2:	b2b6      	uxth	r6, r6

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
 800f5e4:	2c00      	cmp	r4, #0
 800f5e6:	d03c      	beq.n	800f662 <ip_frag+0x16e>
    last = (left <= mtu - IP_HLEN);

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
 800f5e8:	9b01      	ldr	r3, [sp, #4]
 800f5ea:	f3c6 070c 	ubfx	r7, r6, #0, #13
 800f5ee:	431f      	orrs	r7, r3
    if (!last) {
 800f5f0:	9b03      	ldr	r3, [sp, #12]
 800f5f2:	42a3      	cmp	r3, r4

    /* Fill this fragment */
    cop = last ? left : nfb * 8;

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
 800f5f4:	4643      	mov	r3, r8
  while (left) {
    last = (left <= mtu - IP_HLEN);

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last) {
 800f5f6:	ddc2      	ble.n	800f57e <ip_frag+0x8a>

    /* Fill this fragment */
    cop = last ? left : nfb * 8;

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
 800f5f8:	4622      	mov	r2, r4
 800f5fa:	9904      	ldr	r1, [sp, #16]
 800f5fc:	9802      	ldr	r0, [sp, #8]
 800f5fe:	f000 fff5 	bl	80105ec <pbuf_copy_partial>
    poff = newpbuflen;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
 800f602:	4638      	mov	r0, r7
 800f604:	f7fe fac8 	bl	800db98 <lwip_htons>
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
 800f608:	3414      	adds	r4, #20
 800f60a:	b2a4      	uxth	r4, r4
    poff = newpbuflen;
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
 800f60c:	80e8      	strh	r0, [r5, #6]
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
 800f60e:	4620      	mov	r0, r4
 800f610:	f7fe fac2 	bl	800db98 <lwip_htons>
    IPH_CHKSUM_SET(iphdr, 0);
 800f614:	2600      	movs	r6, #0
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
 800f616:	8068      	strh	r0, [r5, #2]
    IPH_CHKSUM_SET(iphdr, 0);
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
 800f618:	2114      	movs	r1, #20
 800f61a:	4628      	mov	r0, r5
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
    IPH_CHKSUM_SET(iphdr, 0);
 800f61c:	816e      	strh	r6, [r5, #10]
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
 800f61e:	f7ff f993 	bl	800e948 <inet_chksum>

#if IP_FRAG_USES_STATIC_BUF
    if (last) {
      pbuf_realloc(rambuf, left + IP_HLEN);
 800f622:	4621      	mov	r1, r4

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
    IPH_CHKSUM_SET(iphdr, 0);
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
 800f624:	8168      	strh	r0, [r5, #10]

#if IP_FRAG_USES_STATIC_BUF
    if (last) {
      pbuf_realloc(rambuf, left + IP_HLEN);
 800f626:	4650      	mov	r0, sl
 800f628:	f000 fe38 	bl	801029c <pbuf_realloc>
    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
 800f62c:	4632      	mov	r2, r6
 800f62e:	4631      	mov	r1, r6
 800f630:	2002      	movs	r0, #2
 800f632:	f000 fd51 	bl	80100d8 <pbuf_alloc>
    if (header != NULL) {
 800f636:	4604      	mov	r4, r0
 800f638:	b938      	cbnz	r0, 800f64a <ip_frag+0x156>
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
 800f63a:	4650      	mov	r0, sl
 800f63c:	f000 fcf4 	bl	8010028 <pbuf_free>
      return ERR_MEM;
 800f640:	f04f 30ff 	mov.w	r0, #4294967295
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
}
 800f644:	b009      	add	sp, #36	; 0x24
 800f646:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
    if (header != NULL) {
      pbuf_chain(header, rambuf);
 800f64a:	4651      	mov	r1, sl
 800f64c:	f000 feea 	bl	8010424 <pbuf_chain>
      netif->output(netif, header, dest);
 800f650:	9a05      	ldr	r2, [sp, #20]
 800f652:	f8d9 3014 	ldr.w	r3, [r9, #20]
 800f656:	4648      	mov	r0, r9
 800f658:	4621      	mov	r1, r4
 800f65a:	4798      	blx	r3
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
 800f65c:	4620      	mov	r0, r4
 800f65e:	f000 fce3 	bl	8010028 <pbuf_free>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
 800f662:	4650      	mov	r0, sl
 800f664:	f000 fce0 	bl	8010028 <pbuf_free>
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
 800f668:	2000      	movs	r0, #0
}
 800f66a:	b009      	add	sp, #36	; 0x24
 800f66c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  if (rambuf == NULL) {
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
 800f670:	f04f 30ff 	mov.w	r0, #4294967295
 800f674:	e7e6      	b.n	800f644 <ip_frag+0x150>
 800f676:	bf00      	nop
 800f678:	200008eb 	.word	0x200008eb

0800f67c <ASCII_IsAlpha>:
    CPU_BOOLEAN  alpha;


    alpha = ASCII_IS_ALPHA(c);

    return (alpha);
 800f67c:	f000 00df 	and.w	r0, r0, #223	; 0xdf
 800f680:	3841      	subs	r0, #65	; 0x41
}
 800f682:	2819      	cmp	r0, #25
 800f684:	bf8c      	ite	hi
 800f686:	2000      	movhi	r0, #0
 800f688:	2001      	movls	r0, #1
 800f68a:	4770      	bx	lr

0800f68c <ASCII_IsAlphaNum>:
CPU_BOOLEAN  ASCII_IsAlphaNum (CPU_CHAR  c)
{
    CPU_BOOLEAN  alpha_num;


    alpha_num = ASCII_IS_ALPHA_NUM(c);
 800f68c:	f020 0320 	bic.w	r3, r0, #32
 800f690:	3b41      	subs	r3, #65	; 0x41
 800f692:	2b19      	cmp	r3, #25
 800f694:	d905      	bls.n	800f6a2 <ASCII_IsAlphaNum+0x16>
 800f696:	3830      	subs	r0, #48	; 0x30
 800f698:	2809      	cmp	r0, #9
 800f69a:	bf8c      	ite	hi
 800f69c:	2000      	movhi	r0, #0
 800f69e:	2001      	movls	r0, #1
 800f6a0:	4770      	bx	lr
 800f6a2:	2001      	movs	r0, #1

    return (alpha_num);
}
 800f6a4:	4770      	bx	lr
 800f6a6:	bf00      	nop

0800f6a8 <ASCII_IsLower>:
    CPU_BOOLEAN  lower;


    lower = ASCII_IS_LOWER(c);

    return (lower);
 800f6a8:	3861      	subs	r0, #97	; 0x61
}
 800f6aa:	2819      	cmp	r0, #25
 800f6ac:	bf8c      	ite	hi
 800f6ae:	2000      	movhi	r0, #0
 800f6b0:	2001      	movls	r0, #1
 800f6b2:	4770      	bx	lr

0800f6b4 <ASCII_IsUpper>:
    CPU_BOOLEAN  upper;


    upper = ASCII_IS_UPPER(c);

    return (upper);
 800f6b4:	3841      	subs	r0, #65	; 0x41
}
 800f6b6:	2819      	cmp	r0, #25
 800f6b8:	bf8c      	ite	hi
 800f6ba:	2000      	movhi	r0, #0
 800f6bc:	2001      	movls	r0, #1
 800f6be:	4770      	bx	lr

0800f6c0 <ASCII_IsDig>:
    CPU_BOOLEAN  dig;


    dig = ASCII_IS_DIG(c);

    return (dig);
 800f6c0:	3830      	subs	r0, #48	; 0x30
}
 800f6c2:	2809      	cmp	r0, #9
 800f6c4:	bf8c      	ite	hi
 800f6c6:	2000      	movhi	r0, #0
 800f6c8:	2001      	movls	r0, #1
 800f6ca:	4770      	bx	lr

0800f6cc <ASCII_IsDigOct>:
    CPU_BOOLEAN  dig_oct;


    dig_oct = ASCII_IS_DIG_OCT(c);

    return (dig_oct);
 800f6cc:	3830      	subs	r0, #48	; 0x30
}
 800f6ce:	2807      	cmp	r0, #7
 800f6d0:	bf8c      	ite	hi
 800f6d2:	2000      	movhi	r0, #0
 800f6d4:	2001      	movls	r0, #1
 800f6d6:	4770      	bx	lr

0800f6d8 <ASCII_IsDigHex>:
CPU_BOOLEAN  ASCII_IsDigHex (CPU_CHAR  c)
{
    CPU_BOOLEAN  dig_hex;


    dig_hex = ASCII_IS_DIG_HEX(c);
 800f6d8:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
 800f6dc:	2b09      	cmp	r3, #9
 800f6de:	d907      	bls.n	800f6f0 <ASCII_IsDigHex+0x18>
 800f6e0:	f020 0020 	bic.w	r0, r0, #32
 800f6e4:	3841      	subs	r0, #65	; 0x41
 800f6e6:	2805      	cmp	r0, #5
 800f6e8:	bf8c      	ite	hi
 800f6ea:	2000      	movhi	r0, #0
 800f6ec:	2001      	movls	r0, #1
 800f6ee:	4770      	bx	lr
 800f6f0:	2001      	movs	r0, #1

    return (dig_hex);
}
 800f6f2:	4770      	bx	lr

0800f6f4 <ASCII_IsBlank>:
CPU_BOOLEAN  ASCII_IsBlank (CPU_CHAR  c)
{
    CPU_BOOLEAN  blank;


    blank = ASCII_IS_BLANK(c);
 800f6f4:	2820      	cmp	r0, #32
 800f6f6:	bf1d      	ittte	ne
 800f6f8:	3809      	subne	r0, #9
 800f6fa:	fab0 f080 	clzne	r0, r0
 800f6fe:	0940      	lsrne	r0, r0, #5
 800f700:	2001      	moveq	r0, #1

    return (blank);
}
 800f702:	4770      	bx	lr

0800f704 <ASCII_IsSpace>:
CPU_BOOLEAN  ASCII_IsSpace (CPU_CHAR  c)
{
    CPU_BOOLEAN  space;


    space = ASCII_IS_SPACE(c);
 800f704:	2820      	cmp	r0, #32
 800f706:	d005      	beq.n	800f714 <ASCII_IsSpace+0x10>
 800f708:	3809      	subs	r0, #9
 800f70a:	2804      	cmp	r0, #4
 800f70c:	bf8c      	ite	hi
 800f70e:	2000      	movhi	r0, #0
 800f710:	2001      	movls	r0, #1
 800f712:	4770      	bx	lr
 800f714:	2001      	movs	r0, #1

    return (space);
}
 800f716:	4770      	bx	lr

0800f718 <ASCII_IsPrint>:
    CPU_BOOLEAN  print;


    print = ASCII_IS_PRINT(c);

    return (print);
 800f718:	3820      	subs	r0, #32
}
 800f71a:	285e      	cmp	r0, #94	; 0x5e
 800f71c:	bf8c      	ite	hi
 800f71e:	2000      	movhi	r0, #0
 800f720:	2001      	movls	r0, #1
 800f722:	4770      	bx	lr

0800f724 <ASCII_IsGraph>:
    CPU_BOOLEAN  graph;


    graph = ASCII_IS_GRAPH(c);

    return (graph);
 800f724:	3821      	subs	r0, #33	; 0x21
}
 800f726:	285d      	cmp	r0, #93	; 0x5d
 800f728:	bf8c      	ite	hi
 800f72a:	2000      	movhi	r0, #0
 800f72c:	2001      	movls	r0, #1
 800f72e:	4770      	bx	lr

0800f730 <ASCII_IsPunct>:
CPU_BOOLEAN  ASCII_IsPunct (CPU_CHAR  c)
{
    CPU_BOOLEAN  punct;


    punct = ASCII_IS_PUNCT(c);
 800f730:	f1a0 0321 	sub.w	r3, r0, #33	; 0x21
 800f734:	2b5d      	cmp	r3, #93	; 0x5d
 800f736:	d80a      	bhi.n	800f74e <ASCII_IsPunct+0x1e>
 800f738:	f020 0320 	bic.w	r3, r0, #32
 800f73c:	3b41      	subs	r3, #65	; 0x41
 800f73e:	2b19      	cmp	r3, #25
 800f740:	d905      	bls.n	800f74e <ASCII_IsPunct+0x1e>
 800f742:	3830      	subs	r0, #48	; 0x30
 800f744:	2809      	cmp	r0, #9
 800f746:	bf94      	ite	ls
 800f748:	2000      	movls	r0, #0
 800f74a:	2001      	movhi	r0, #1
 800f74c:	4770      	bx	lr
 800f74e:	2000      	movs	r0, #0

    return (punct);
}
 800f750:	4770      	bx	lr
 800f752:	bf00      	nop

0800f754 <ASCII_IsCtrl>:
CPU_BOOLEAN  ASCII_IsCtrl (CPU_CHAR  c)
{
    CPU_BOOLEAN  ctrl;


    ctrl = ASCII_IS_CTRL(c);
 800f754:	281f      	cmp	r0, #31
 800f756:	bf83      	ittte	hi
 800f758:	387f      	subhi	r0, #127	; 0x7f
 800f75a:	fab0 f080 	clzhi	r0, r0
 800f75e:	0940      	lsrhi	r0, r0, #5
 800f760:	2001      	movls	r0, #1

    return (ctrl);
}
 800f762:	4770      	bx	lr

0800f764 <ASCII_ToLower>:
CPU_CHAR  ASCII_ToLower (CPU_CHAR  c)
{
    CPU_CHAR  lower;


    lower = ASCII_TO_LOWER(c);
 800f764:	f1a0 0341 	sub.w	r3, r0, #65	; 0x41
 800f768:	2b19      	cmp	r3, #25
 800f76a:	bf9c      	itt	ls
 800f76c:	3020      	addls	r0, #32
 800f76e:	b2c0      	uxtbls	r0, r0

    return (lower);
}
 800f770:	4770      	bx	lr
 800f772:	bf00      	nop

0800f774 <ASCII_ToUpper>:
CPU_CHAR  ASCII_ToUpper (CPU_CHAR  c)
{
    CPU_CHAR  upper;


    upper = ASCII_TO_UPPER(c);
 800f774:	f1a0 0361 	sub.w	r3, r0, #97	; 0x61
 800f778:	2b19      	cmp	r3, #25
 800f77a:	bf9c      	itt	ls
 800f77c:	3820      	subls	r0, #32
 800f77e:	b2c0      	uxtbls	r0, r0

    return (upper);
}
 800f780:	4770      	bx	lr
 800f782:	bf00      	nop

0800f784 <ASCII_Cmp>:
CPU_CHAR  ASCII_ToUpper (CPU_CHAR  c)
{
    CPU_CHAR  upper;


    upper = ASCII_TO_UPPER(c);
 800f784:	f1a0 0361 	sub.w	r3, r0, #97	; 0x61
 800f788:	2b19      	cmp	r3, #25
 800f78a:	bf98      	it	ls
 800f78c:	3820      	subls	r0, #32
 800f78e:	f1a1 0361 	sub.w	r3, r1, #97	; 0x61
 800f792:	bf98      	it	ls
 800f794:	b2c0      	uxtbls	r0, r0
 800f796:	2b19      	cmp	r3, #25
 800f798:	bf9c      	itt	ls
 800f79a:	3920      	subls	r1, #32
 800f79c:	b2c9      	uxtbls	r1, r1
    c1_upper =  ASCII_ToUpper(c1);
    c2_upper =  ASCII_ToUpper(c2);
    cmp      = (c1_upper == c2_upper) ? (DEF_YES) : (DEF_NO);

    return (cmp);
}
 800f79e:	1a08      	subs	r0, r1, r0
 800f7a0:	fab0 f080 	clz	r0, r0
 800f7a4:	0940      	lsrs	r0, r0, #5
 800f7a6:	4770      	bx	lr

0800f7a8 <mem_init>:

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
 800f7a8:	4b14      	ldr	r3, [pc, #80]	; (800f7fc <mem_init+0x54>)
 800f7aa:	4a15      	ldr	r2, [pc, #84]	; (800f800 <mem_init+0x58>)
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
 800f7ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
 800f7b0:	f023 0303 	bic.w	r3, r3, #3
  /* initialize the start of the heap */
  mem = (struct mem *)(void *)ram;
  mem->next = MEM_SIZE_ALIGNED;
 800f7b4:	f44f 6480 	mov.w	r4, #1024	; 0x400
  mem->prev = 0;
  mem->used = 0;
  /* initialize the end of the heap */
  ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
  ram_end->used = 1;
 800f7b8:	2501      	movs	r5, #1
  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
  /* initialize the start of the heap */
  mem = (struct mem *)(void *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  mem->prev = 0;
 800f7ba:	2600      	movs	r6, #0
  mem->used = 0;
  /* initialize the end of the heap */
  ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
 800f7bc:	f503 6780 	add.w	r7, r3, #1024	; 0x400
  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)(void *)ram;

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);

  if(sys_mutex_new(&mem_mutex) != ERR_OK) {
 800f7c0:	f102 000c 	add.w	r0, r2, #12
 800f7c4:	4629      	mov	r1, r5

  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
  /* initialize the start of the heap */
  mem = (struct mem *)(void *)ram;
  mem->next = MEM_SIZE_ALIGNED;
 800f7c6:	801c      	strh	r4, [r3, #0]
  mem->prev = 0;
  mem->used = 0;
  /* initialize the end of the heap */
  ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
  ram_end->used = 1;
  ram_end->next = MEM_SIZE_ALIGNED;
 800f7c8:	f8a3 4400 	strh.w	r4, [r3, #1024]	; 0x400
  ram_end->prev = MEM_SIZE_ALIGNED;
 800f7cc:	f8a3 4402 	strh.w	r4, [r3, #1026]	; 0x402
  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
  /* initialize the start of the heap */
  mem = (struct mem *)(void *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  mem->prev = 0;
 800f7d0:	805e      	strh	r6, [r3, #2]
  mem->used = 0;
 800f7d2:	711e      	strb	r6, [r3, #4]
  /* initialize the end of the heap */
  ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
  ram_end->used = 1;
 800f7d4:	f883 5404 	strb.w	r5, [r3, #1028]	; 0x404

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
 800f7d8:	e882 0088 	stmia.w	r2, {r3, r7}
  ram_end->used = 1;
  ram_end->next = MEM_SIZE_ALIGNED;
  ram_end->prev = MEM_SIZE_ALIGNED;

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)(void *)ram;
 800f7dc:	6093      	str	r3, [r2, #8]

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);

  if(sys_mutex_new(&mem_mutex) != ERR_OK) {
 800f7de:	f003 fc91 	bl	8013104 <sys_sem_new>
 800f7e2:	b908      	cbnz	r0, 800f7e8 <mem_init+0x40>
 800f7e4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    LWIP_ASSERT("failed to create mem_mutex", 0);
 800f7e8:	4b06      	ldr	r3, [pc, #24]	; (800f804 <mem_init+0x5c>)
 800f7ea:	f44f 7296 	mov.w	r2, #300	; 0x12c
 800f7ee:	4906      	ldr	r1, [pc, #24]	; (800f808 <mem_init+0x60>)
 800f7f0:	4806      	ldr	r0, [pc, #24]	; (800f80c <mem_init+0x64>)
  }
}
 800f7f2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  lfree = (struct mem *)(void *)ram;

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);

  if(sys_mutex_new(&mem_mutex) != ERR_OK) {
    LWIP_ASSERT("failed to create mem_mutex", 0);
 800f7f6:	f005 babf 	b.w	8014d78 <iprintf>
 800f7fa:	bf00      	nop
 800f7fc:	2000f0af 	.word	0x2000f0af
 800f800:	20000ec8 	.word	0x20000ec8
 800f804:	08017954 	.word	0x08017954
 800f808:	08017964 	.word	0x08017964
 800f80c:	0801660c 	.word	0x0801660c

0800f810 <BSP_mem_free>:
mem_free(void *rmem)
{
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
 800f810:	2800      	cmp	r0, #0
 800f812:	f000 808e 	beq.w	800f932 <BSP_mem_free+0x122>
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
 800f816:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  if (rmem == NULL) {
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
 800f818:	0783      	lsls	r3, r0, #30
 800f81a:	4604      	mov	r4, r0
 800f81c:	d165      	bne.n	800f8ea <BSP_mem_free+0xda>

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
 800f81e:	4d4d      	ldr	r5, [pc, #308]	; (800f954 <BSP_mem_free+0x144>)
 800f820:	682b      	ldr	r3, [r5, #0]
 800f822:	429c      	cmp	r4, r3
 800f824:	d302      	bcc.n	800f82c <BSP_mem_free+0x1c>
 800f826:	686b      	ldr	r3, [r5, #4]
 800f828:	429c      	cmp	r4, r3
 800f82a:	d313      	bcc.n	800f854 <BSP_mem_free+0x44>
 800f82c:	4b4a      	ldr	r3, [pc, #296]	; (800f958 <BSP_mem_free+0x148>)
 800f82e:	f240 1243 	movw	r2, #323	; 0x143
 800f832:	494a      	ldr	r1, [pc, #296]	; (800f95c <BSP_mem_free+0x14c>)
 800f834:	484a      	ldr	r0, [pc, #296]	; (800f960 <BSP_mem_free+0x150>)
 800f836:	f005 fa9f 	bl	8014d78 <iprintf>
    (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 800f83a:	682b      	ldr	r3, [r5, #0]
 800f83c:	4a45      	ldr	r2, [pc, #276]	; (800f954 <BSP_mem_free+0x144>)
 800f83e:	429c      	cmp	r4, r3
 800f840:	d302      	bcc.n	800f848 <BSP_mem_free+0x38>
 800f842:	6853      	ldr	r3, [r2, #4]
 800f844:	429c      	cmp	r4, r3
 800f846:	d305      	bcc.n	800f854 <BSP_mem_free+0x44>
    SYS_ARCH_DECL_PROTECT(lev);
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
 800f848:	f7f1 ff94 	bl	8001774 <CPU_SR_Save>
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
}
 800f84c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    SYS_ARCH_DECL_PROTECT(lev);
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
 800f850:	f7f1 bf94 	b.w	800177c <CPU_SR_Restore>
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
 800f854:	2100      	movs	r1, #0
 800f856:	4843      	ldr	r0, [pc, #268]	; (800f964 <BSP_mem_free+0x154>)
 800f858:	f003 fc72 	bl	8013140 <sys_arch_sem_wait>
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
 800f85c:	f814 3c04 	ldrb.w	r3, [r4, #-4]
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
 800f860:	f1a4 0608 	sub.w	r6, r4, #8
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
 800f864:	2b00      	cmp	r3, #0
 800f866:	d05c      	beq.n	800f922 <BSP_mem_free+0x112>
  /* ... and is now unused. */
  mem->used = 0;

  if (mem < lfree) {
 800f868:	68ab      	ldr	r3, [r5, #8]
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  /* ... and is now unused. */
  mem->used = 0;
 800f86a:	2200      	movs	r2, #0

  if (mem < lfree) {
 800f86c:	429e      	cmp	r6, r3
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  /* ... and is now unused. */
  mem->used = 0;
 800f86e:	f804 2c04 	strb.w	r2, [r4, #-4]
plug_holes(struct mem *mem)
{
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
 800f872:	682b      	ldr	r3, [r5, #0]
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  /* ... and is now unused. */
  mem->used = 0;

  if (mem < lfree) {
 800f874:	4a37      	ldr	r2, [pc, #220]	; (800f954 <BSP_mem_free+0x144>)
plug_holes(struct mem *mem)
{
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
 800f876:	4f37      	ldr	r7, [pc, #220]	; (800f954 <BSP_mem_free+0x144>)
  /* ... and is now unused. */
  mem->used = 0;

  if (mem < lfree) {
    /* the newly freed struct is now the lowest */
    lfree = mem;
 800f878:	bf38      	it	cc
 800f87a:	6096      	strcc	r6, [r2, #8]
plug_holes(struct mem *mem)
{
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
 800f87c:	429e      	cmp	r6, r3
 800f87e:	d33c      	bcc.n	800f8fa <BSP_mem_free+0xea>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
 800f880:	687b      	ldr	r3, [r7, #4]
 800f882:	429e      	cmp	r6, r3
 800f884:	d25f      	bcs.n	800f946 <BSP_mem_free+0x136>
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
 800f886:	f834 3c08 	ldrh.w	r3, [r4, #-8]
 800f88a:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800f88e:	d851      	bhi.n	800f934 <BSP_mem_free+0x124>

  nmem = (struct mem *)(void *)&ram[mem->next];
 800f890:	682a      	ldr	r2, [r5, #0]
 800f892:	4930      	ldr	r1, [pc, #192]	; (800f954 <BSP_mem_free+0x144>)
 800f894:	4413      	add	r3, r2
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
 800f896:	429e      	cmp	r6, r3
 800f898:	d00f      	beq.n	800f8ba <BSP_mem_free+0xaa>
 800f89a:	7918      	ldrb	r0, [r3, #4]
 800f89c:	b968      	cbnz	r0, 800f8ba <BSP_mem_free+0xaa>
 800f89e:	6848      	ldr	r0, [r1, #4]
 800f8a0:	4283      	cmp	r3, r0
 800f8a2:	d00a      	beq.n	800f8ba <BSP_mem_free+0xaa>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
 800f8a4:	6888      	ldr	r0, [r1, #8]
 800f8a6:	4283      	cmp	r3, r0
      lfree = mem;
    }
    mem->next = nmem->next;
 800f8a8:	8818      	ldrh	r0, [r3, #0]

  nmem = (struct mem *)(void *)&ram[mem->next];
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
      lfree = mem;
 800f8aa:	bf08      	it	eq
 800f8ac:	608e      	streq	r6, [r1, #8]
    }
    mem->next = nmem->next;
 800f8ae:	f824 0c08 	strh.w	r0, [r4, #-8]
    ((struct mem *)(void *)&ram[nmem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
 800f8b2:	881b      	ldrh	r3, [r3, #0]
 800f8b4:	1ab1      	subs	r1, r6, r2
 800f8b6:	4413      	add	r3, r2
 800f8b8:	8059      	strh	r1, [r3, #2]
  }

  /* plug hole backward */
  pmem = (struct mem *)(void *)&ram[mem->prev];
 800f8ba:	f834 3c06 	ldrh.w	r3, [r4, #-6]
 800f8be:	18d1      	adds	r1, r2, r3
  if (pmem != mem && pmem->used == 0) {
 800f8c0:	428e      	cmp	r6, r1
 800f8c2:	d00d      	beq.n	800f8e0 <BSP_mem_free+0xd0>
 800f8c4:	7908      	ldrb	r0, [r1, #4]
 800f8c6:	b958      	cbnz	r0, 800f8e0 <BSP_mem_free+0xd0>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
 800f8c8:	68a8      	ldr	r0, [r5, #8]
 800f8ca:	4d22      	ldr	r5, [pc, #136]	; (800f954 <BSP_mem_free+0x144>)
 800f8cc:	4286      	cmp	r6, r0
      lfree = pmem;
 800f8ce:	bf08      	it	eq
 800f8d0:	60a9      	streq	r1, [r5, #8]
    }
    pmem->next = mem->next;
 800f8d2:	f834 1c08 	ldrh.w	r1, [r4, #-8]
 800f8d6:	52d1      	strh	r1, [r2, r3]
    ((struct mem *)(void *)&ram[mem->next])->prev = (mem_size_t)((u8_t *)pmem - ram);
 800f8d8:	f834 1c08 	ldrh.w	r1, [r4, #-8]
 800f8dc:	440a      	add	r2, r1
 800f8de:	8053      	strh	r3, [r2, #2]
  /* finally, see if prev or next are free also */
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
 800f8e0:	4820      	ldr	r0, [pc, #128]	; (800f964 <BSP_mem_free+0x154>)
}
 800f8e2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  /* finally, see if prev or next are free also */
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
 800f8e6:	f003 bc4b 	b.w	8013180 <sys_sem_signal>

  if (rmem == NULL) {
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
 800f8ea:	4b1b      	ldr	r3, [pc, #108]	; (800f958 <BSP_mem_free+0x148>)
 800f8ec:	f44f 72a0 	mov.w	r2, #320	; 0x140
 800f8f0:	491d      	ldr	r1, [pc, #116]	; (800f968 <BSP_mem_free+0x158>)
 800f8f2:	481b      	ldr	r0, [pc, #108]	; (800f960 <BSP_mem_free+0x150>)
 800f8f4:	f005 fa40 	bl	8014d78 <iprintf>
 800f8f8:	e791      	b.n	800f81e <BSP_mem_free+0xe>
plug_holes(struct mem *mem)
{
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
 800f8fa:	4b17      	ldr	r3, [pc, #92]	; (800f958 <BSP_mem_free+0x148>)
 800f8fc:	22f1      	movs	r2, #241	; 0xf1
 800f8fe:	491b      	ldr	r1, [pc, #108]	; (800f96c <BSP_mem_free+0x15c>)
 800f900:	4817      	ldr	r0, [pc, #92]	; (800f960 <BSP_mem_free+0x150>)
 800f902:	f005 fa39 	bl	8014d78 <iprintf>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
 800f906:	687b      	ldr	r3, [r7, #4]
 800f908:	429e      	cmp	r6, r3
 800f90a:	d21c      	bcs.n	800f946 <BSP_mem_free+0x136>
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
 800f90c:	f814 3c04 	ldrb.w	r3, [r4, #-4]
 800f910:	2b00      	cmp	r3, #0
 800f912:	d0b8      	beq.n	800f886 <BSP_mem_free+0x76>
 800f914:	4b10      	ldr	r3, [pc, #64]	; (800f958 <BSP_mem_free+0x148>)
 800f916:	22f3      	movs	r2, #243	; 0xf3
 800f918:	4915      	ldr	r1, [pc, #84]	; (800f970 <BSP_mem_free+0x160>)
 800f91a:	4811      	ldr	r0, [pc, #68]	; (800f960 <BSP_mem_free+0x150>)
 800f91c:	f005 fa2c 	bl	8014d78 <iprintf>
 800f920:	e7b1      	b.n	800f886 <BSP_mem_free+0x76>
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
 800f922:	4b0d      	ldr	r3, [pc, #52]	; (800f958 <BSP_mem_free+0x148>)
 800f924:	f240 1253 	movw	r2, #339	; 0x153
 800f928:	4912      	ldr	r1, [pc, #72]	; (800f974 <BSP_mem_free+0x164>)
 800f92a:	480d      	ldr	r0, [pc, #52]	; (800f960 <BSP_mem_free+0x150>)
 800f92c:	f005 fa24 	bl	8014d78 <iprintf>
 800f930:	e79a      	b.n	800f868 <BSP_mem_free+0x58>
 800f932:	4770      	bx	lr
  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
 800f934:	4b08      	ldr	r3, [pc, #32]	; (800f958 <BSP_mem_free+0x148>)
 800f936:	22f6      	movs	r2, #246	; 0xf6
 800f938:	490f      	ldr	r1, [pc, #60]	; (800f978 <BSP_mem_free+0x168>)
 800f93a:	4809      	ldr	r0, [pc, #36]	; (800f960 <BSP_mem_free+0x150>)
 800f93c:	f005 fa1c 	bl	8014d78 <iprintf>
 800f940:	f834 3c08 	ldrh.w	r3, [r4, #-8]
 800f944:	e7a4      	b.n	800f890 <BSP_mem_free+0x80>
{
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
 800f946:	4b04      	ldr	r3, [pc, #16]	; (800f958 <BSP_mem_free+0x148>)
 800f948:	22f2      	movs	r2, #242	; 0xf2
 800f94a:	490c      	ldr	r1, [pc, #48]	; (800f97c <BSP_mem_free+0x16c>)
 800f94c:	4804      	ldr	r0, [pc, #16]	; (800f960 <BSP_mem_free+0x150>)
 800f94e:	f005 fa13 	bl	8014d78 <iprintf>
 800f952:	e7db      	b.n	800f90c <BSP_mem_free+0xfc>
 800f954:	20000ec8 	.word	0x20000ec8
 800f958:	08017954 	.word	0x08017954
 800f95c:	080179a4 	.word	0x080179a4
 800f960:	0801660c 	.word	0x0801660c
 800f964:	20000ed4 	.word	0x20000ed4
 800f968:	08017980 	.word	0x08017980
 800f96c:	080179d0 	.word	0x080179d0
 800f970:	08017a04 	.word	0x08017a04
 800f974:	080179bc 	.word	0x080179bc
 800f978:	08017a20 	.word	0x08017a20
 800f97c:	080179e8 	.word	0x080179e8

0800f980 <BSP_mem_trim>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_trim(void *rmem, mem_size_t newsize)
{
 800f980:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
 800f984:	f64f 75fc 	movw	r5, #65532	; 0xfffc
 800f988:	3103      	adds	r1, #3
 800f98a:	400d      	ands	r5, r1

  if(newsize < MIN_SIZE_ALIGNED) {
 800f98c:	2d0b      	cmp	r5, #11
 800f98e:	d960      	bls.n	800fa52 <BSP_mem_trim+0xd2>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
 800f990:	f5b5 6f80 	cmp.w	r5, #1024	; 0x400
 800f994:	d879      	bhi.n	800fa8a <BSP_mem_trim+0x10a>
    return NULL;
  }

  LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
 800f996:	f8df 8124 	ldr.w	r8, [pc, #292]	; 800fabc <BSP_mem_trim+0x13c>
 800f99a:	4604      	mov	r4, r0
 800f99c:	f8d8 3000 	ldr.w	r3, [r8]
 800f9a0:	4283      	cmp	r3, r0
 800f9a2:	d840      	bhi.n	800fa26 <BSP_mem_trim+0xa6>
 800f9a4:	f8d8 2004 	ldr.w	r2, [r8, #4]
 800f9a8:	4290      	cmp	r0, r2
 800f9aa:	d23c      	bcs.n	800fa26 <BSP_mem_trim+0xa6>
    return rmem;
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  /* ... and its offset pointer */
  ptr = (mem_size_t)((u8_t *)mem - ram);
 800f9ac:	f1a4 0608 	sub.w	r6, r4, #8

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
 800f9b0:	f834 7c08 	ldrh.w	r7, [r4, #-8]
    return rmem;
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  /* ... and its offset pointer */
  ptr = (mem_size_t)((u8_t *)mem - ram);
 800f9b4:	1af6      	subs	r6, r6, r3
 800f9b6:	b2b6      	uxth	r6, r6

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
 800f9b8:	3f08      	subs	r7, #8
 800f9ba:	1bbf      	subs	r7, r7, r6
 800f9bc:	b2bf      	uxth	r7, r7
  LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
 800f9be:	42af      	cmp	r7, r5
 800f9c0:	d369      	bcc.n	800fa96 <BSP_mem_trim+0x116>
  if (newsize > size) {
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
 800f9c2:	d065      	beq.n	800fa90 <BSP_mem_trim+0x110>
    /* No change in size, simply return */
    return rmem;
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
 800f9c4:	f8df 90f4 	ldr.w	r9, [pc, #244]	; 800fabc <BSP_mem_trim+0x13c>
 800f9c8:	2100      	movs	r1, #0
 800f9ca:	f109 000c 	add.w	r0, r9, #12
 800f9ce:	f003 fbb7 	bl	8013140 <sys_arch_sem_wait>

  mem2 = (struct mem *)(void *)&ram[mem->next];
 800f9d2:	f8d8 3000 	ldr.w	r3, [r8]
 800f9d6:	f834 1c08 	ldrh.w	r1, [r4, #-8]
 800f9da:	1858      	adds	r0, r3, r1
  if(mem2->used == 0) {
 800f9dc:	7902      	ldrb	r2, [r0, #4]
 800f9de:	2a00      	cmp	r2, #0
 800f9e0:	d039      	beq.n	800fa56 <BSP_mem_trim+0xd6>
    if (mem2->next != MEM_SIZE_ALIGNED) {
      ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
    }
    MEM_STATS_DEC_USED(used, (size - newsize));
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
 800f9e2:	f105 0214 	add.w	r2, r5, #20
 800f9e6:	42ba      	cmp	r2, r7
 800f9e8:	d817      	bhi.n	800fa1a <BSP_mem_trim+0x9a>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 800f9ea:	f105 0208 	add.w	r2, r5, #8
 800f9ee:	4432      	add	r2, r6
 800f9f0:	b292      	uxth	r2, r2
    mem2 = (struct mem *)(void *)&ram[ptr2];
    if (mem2 < lfree) {
 800f9f2:	f8d9 5008 	ldr.w	r5, [r9, #8]
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    mem2 = (struct mem *)(void *)&ram[ptr2];
 800f9f6:	1898      	adds	r0, r3, r2
    if (mem2 < lfree) {
 800f9f8:	42a8      	cmp	r0, r5
      lfree = mem2;
    }
    mem2->used = 0;
 800f9fa:	f04f 0500 	mov.w	r5, #0
 800f9fe:	7105      	strb	r5, [r0, #4]
    mem2->next = mem->next;
 800fa00:	5299      	strh	r1, [r3, r2]
    mem2->prev = ptr;
 800fa02:	8046      	strh	r6, [r0, #2]
    mem->next = ptr2;
 800fa04:	f824 2c08 	strh.w	r2, [r4, #-8]
    if (mem2->next != MEM_SIZE_ALIGNED) {
 800fa08:	5a99      	ldrh	r1, [r3, r2]
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    mem2 = (struct mem *)(void *)&ram[ptr2];
    if (mem2 < lfree) {
      lfree = mem2;
 800fa0a:	bf38      	it	cc
 800fa0c:	f8c9 0008 	strcc.w	r0, [r9, #8]
    }
    mem2->used = 0;
    mem2->next = mem->next;
    mem2->prev = ptr;
    mem->next = ptr2;
    if (mem2->next != MEM_SIZE_ALIGNED) {
 800fa10:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
      ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
 800fa14:	bf1c      	itt	ne
 800fa16:	185b      	addne	r3, r3, r1
 800fa18:	805a      	strhne	r2, [r3, #2]
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
 800fa1a:	4824      	ldr	r0, [pc, #144]	; (800faac <BSP_mem_trim+0x12c>)
 800fa1c:	f003 fbb0 	bl	8013180 <sys_sem_signal>
  return rmem;
 800fa20:	4620      	mov	r0, r4
 800fa22:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

  if (newsize > MEM_SIZE_ALIGNED) {
    return NULL;
  }

  LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
 800fa26:	4b22      	ldr	r3, [pc, #136]	; (800fab0 <BSP_mem_trim+0x130>)
 800fa28:	f240 1287 	movw	r2, #391	; 0x187
 800fa2c:	4921      	ldr	r1, [pc, #132]	; (800fab4 <BSP_mem_trim+0x134>)
 800fa2e:	4822      	ldr	r0, [pc, #136]	; (800fab8 <BSP_mem_trim+0x138>)
 800fa30:	f005 f9a2 	bl	8014d78 <iprintf>
   (u8_t *)rmem < (u8_t *)ram_end);

  if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
 800fa34:	f8d8 3000 	ldr.w	r3, [r8]
 800fa38:	4a20      	ldr	r2, [pc, #128]	; (800fabc <BSP_mem_trim+0x13c>)
 800fa3a:	429c      	cmp	r4, r3
 800fa3c:	d302      	bcc.n	800fa44 <BSP_mem_trim+0xc4>
 800fa3e:	6852      	ldr	r2, [r2, #4]
 800fa40:	42a2      	cmp	r2, r4
 800fa42:	d8b3      	bhi.n	800f9ac <BSP_mem_trim+0x2c>
    SYS_ARCH_DECL_PROTECT(lev);
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_trim: illegal memory\n"));
    /* protect mem stats from concurrent access */
    SYS_ARCH_PROTECT(lev);
 800fa44:	f7f1 fe96 	bl	8001774 <CPU_SR_Save>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
 800fa48:	f7f1 fe98 	bl	800177c <CPU_SR_Restore>
    return rmem;
 800fa4c:	4620      	mov	r0, r4
 800fa4e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);

  if(newsize < MIN_SIZE_ALIGNED) {
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
 800fa52:	250c      	movs	r5, #12
 800fa54:	e79f      	b.n	800f996 <BSP_mem_trim+0x16>
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    if (lfree == mem2) {
 800fa56:	f8d9 2008 	ldr.w	r2, [r9, #8]
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 800fa5a:	3508      	adds	r5, #8
 800fa5c:	4435      	add	r5, r6
    if (lfree == mem2) {
 800fa5e:	4290      	cmp	r0, r2
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
 800fa60:	b2ad      	uxth	r5, r5
  mem2 = (struct mem *)(void *)&ram[mem->next];
  if(mem2->used == 0) {
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
 800fa62:	5a5f      	ldrh	r7, [r3, r1]
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    if (lfree == mem2) {
      lfree = (struct mem *)(void *)&ram[ptr2];
 800fa64:	bf05      	ittet	eq
 800fa66:	1959      	addeq	r1, r3, r5
 800fa68:	460a      	moveq	r2, r1
 800fa6a:	195a      	addne	r2, r3, r5
 800fa6c:	f8c9 1008 	streq.w	r1, [r9, #8]
    }
    mem2 = (struct mem *)(void *)&ram[ptr2];
    mem2->used = 0;
 800fa70:	2100      	movs	r1, #0
    /* restore the next pointer */
    mem2->next = next;
 800fa72:	8017      	strh	r7, [r2, #0]
    /* link it back to mem */
    mem2->prev = ptr;
 800fa74:	8056      	strh	r6, [r2, #2]
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
    if (lfree == mem2) {
      lfree = (struct mem *)(void *)&ram[ptr2];
    }
    mem2 = (struct mem *)(void *)&ram[ptr2];
    mem2->used = 0;
 800fa76:	7111      	strb	r1, [r2, #4]
    /* restore the next pointer */
    mem2->next = next;
    /* link it back to mem */
    mem2->prev = ptr;
    /* link mem to it */
    mem->next = ptr2;
 800fa78:	f824 5c08 	strh.w	r5, [r4, #-8]
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
 800fa7c:	8812      	ldrh	r2, [r2, #0]
 800fa7e:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 800fa82:	d0ca      	beq.n	800fa1a <BSP_mem_trim+0x9a>
      ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
 800fa84:	4413      	add	r3, r2
 800fa86:	805d      	strh	r5, [r3, #2]
 800fa88:	e7c7      	b.n	800fa1a <BSP_mem_trim+0x9a>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
    return NULL;
 800fa8a:	2000      	movs	r0, #0
 800fa8c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800fa90:	4620      	mov	r0, r4
 800fa92:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  /* ... and its offset pointer */
  ptr = (mem_size_t)((u8_t *)mem - ram);

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
 800fa96:	4b06      	ldr	r3, [pc, #24]	; (800fab0 <BSP_mem_trim+0x130>)
 800fa98:	f44f 72cc 	mov.w	r2, #408	; 0x198
 800fa9c:	4908      	ldr	r1, [pc, #32]	; (800fac0 <BSP_mem_trim+0x140>)
 800fa9e:	4806      	ldr	r0, [pc, #24]	; (800fab8 <BSP_mem_trim+0x138>)
 800faa0:	f005 f96a 	bl	8014d78 <iprintf>
  if (newsize > size) {
    /* not supported */
    return NULL;
 800faa4:	2000      	movs	r0, #0
 800faa6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800faaa:	bf00      	nop
 800faac:	20000ed4 	.word	0x20000ed4
 800fab0:	08017954 	.word	0x08017954
 800fab4:	08017a4c 	.word	0x08017a4c
 800fab8:	0801660c 	.word	0x0801660c
 800fabc:	20000ec8 	.word	0x20000ec8
 800fac0:	08017a64 	.word	0x08017a64

0800fac4 <BSP_mem_malloc>:
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
 800fac4:	2800      	cmp	r0, #0
 800fac6:	d06e      	beq.n	800fba6 <BSP_mem_malloc+0xe2>
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
 800fac8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    return NULL;
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
 800facc:	f64f 75fc 	movw	r5, #65532	; 0xfffc
 800fad0:	3003      	adds	r0, #3
 800fad2:	4005      	ands	r5, r0

  if(size < MIN_SIZE_ALIGNED) {
 800fad4:	2d0b      	cmp	r5, #11
 800fad6:	d925      	bls.n	800fb24 <BSP_mem_malloc+0x60>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
 800fad8:	f5b5 6f80 	cmp.w	r5, #1024	; 0x400
 800fadc:	d860      	bhi.n	800fba0 <BSP_mem_malloc+0xdc>
 800fade:	f5c5 6680 	rsb	r6, r5, #1024	; 0x400
    return NULL;
  }

  /* protect the heap from concurrent access */
  sys_mutex_lock(&mem_mutex);
 800fae2:	4f41      	ldr	r7, [pc, #260]	; (800fbe8 <BSP_mem_malloc+0x124>)
 800fae4:	2100      	movs	r1, #0
 800fae6:	f107 000c 	add.w	r0, r7, #12
 800faea:	f003 fb29 	bl	8013140 <sys_arch_sem_wait>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
 800faee:	f8d7 c008 	ldr.w	ip, [r7, #8]
 800faf2:	6839      	ldr	r1, [r7, #0]
 800faf4:	ebc1 030c 	rsb	r3, r1, ip
 800faf8:	b29b      	uxth	r3, r3
 800fafa:	42b3      	cmp	r3, r6
 800fafc:	da0c      	bge.n	800fb18 <BSP_mem_malloc+0x54>
         ptr = ((struct mem *)(void *)&ram[ptr])->next) {
      mem = (struct mem *)(void *)&ram[ptr];
 800fafe:	18cc      	adds	r4, r1, r3
        local_mem_free_count = 1;
        break;
      }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
 800fb00:	7920      	ldrb	r0, [r4, #4]
 800fb02:	b998      	cbnz	r0, 800fb2c <BSP_mem_malloc+0x68>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
 800fb04:	f831 e003 	ldrh.w	lr, [r1, r3]
 800fb08:	f1ae 0208 	sub.w	r2, lr, #8
 800fb0c:	1ad2      	subs	r2, r2, r3
        local_mem_free_count = 1;
        break;
      }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
 800fb0e:	42aa      	cmp	r2, r5
 800fb10:	d20e      	bcs.n	800fb30 <BSP_mem_malloc+0x6c>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
 800fb12:	4673      	mov	r3, lr
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
 800fb14:	42b3      	cmp	r3, r6
 800fb16:	dbf2      	blt.n	800fafe <BSP_mem_malloc+0x3a>
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_mutex_unlock(&mem_mutex);
 800fb18:	4834      	ldr	r0, [pc, #208]	; (800fbec <BSP_mem_malloc+0x128>)
 800fb1a:	f003 fb31 	bl	8013180 <sys_sem_signal>
  return NULL;
 800fb1e:	2000      	movs	r0, #0
 800fb20:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800fb24:	f44f 767d 	mov.w	r6, #1012	; 0x3f4
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);

  if(size < MIN_SIZE_ALIGNED) {
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
 800fb28:	250c      	movs	r5, #12
 800fb2a:	e7da      	b.n	800fae2 <BSP_mem_malloc+0x1e>
 800fb2c:	5acb      	ldrh	r3, [r1, r3]
 800fb2e:	e7e4      	b.n	800fafa <BSP_mem_malloc+0x36>
      if ((!mem->used) &&
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
 800fb30:	f105 0614 	add.w	r6, r5, #20
 800fb34:	42b2      	cmp	r2, r6
 800fb36:	d21f      	bcs.n	800fb78 <BSP_mem_malloc+0xb4>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
 800fb38:	2301      	movs	r3, #1
 800fb3a:	3508      	adds	r5, #8
 800fb3c:	7123      	strb	r3, [r4, #4]
          MEM_STATS_INC_USED(used, mem->next - (mem_size_t)((u8_t *)mem - ram));
        }
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
mem_malloc_adjust_lfree:
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
        if (mem == lfree) {
 800fb3e:	45a4      	cmp	ip, r4
 800fb40:	d03a      	beq.n	800fbb8 <BSP_mem_malloc+0xf4>
          }
          lfree = cur;
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_mutex_unlock(&mem_mutex);
 800fb42:	482a      	ldr	r0, [pc, #168]	; (800fbec <BSP_mem_malloc+0x128>)
 800fb44:	f003 fb1c 	bl	8013180 <sys_sem_signal>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
 800fb48:	687b      	ldr	r3, [r7, #4]
 800fb4a:	4425      	add	r5, r4
 800fb4c:	42ab      	cmp	r3, r5
 800fb4e:	d32b      	bcc.n	800fba8 <BSP_mem_malloc+0xe4>
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
 800fb50:	07a3      	lsls	r3, r4, #30
 800fb52:	d00d      	beq.n	800fb70 <BSP_mem_malloc+0xac>
 800fb54:	4b26      	ldr	r3, [pc, #152]	; (800fbf0 <BSP_mem_malloc+0x12c>)
 800fb56:	f240 2269 	movw	r2, #617	; 0x269
 800fb5a:	4926      	ldr	r1, [pc, #152]	; (800fbf4 <BSP_mem_malloc+0x130>)
 800fb5c:	4826      	ldr	r0, [pc, #152]	; (800fbf8 <BSP_mem_malloc+0x134>)
 800fb5e:	f005 f90b 	bl	8014d78 <iprintf>
         ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
 800fb62:	4b23      	ldr	r3, [pc, #140]	; (800fbf0 <BSP_mem_malloc+0x12c>)
 800fb64:	f240 226b 	movw	r2, #619	; 0x26b
 800fb68:	4924      	ldr	r1, [pc, #144]	; (800fbfc <BSP_mem_malloc+0x138>)
 800fb6a:	4823      	ldr	r0, [pc, #140]	; (800fbf8 <BSP_mem_malloc+0x134>)
 800fb6c:	f005 f904 	bl	8014d78 <iprintf>
          (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);

        return (u8_t *)mem + SIZEOF_STRUCT_MEM;
 800fb70:	f104 0008 	add.w	r0, r4, #8
 800fb74:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
 800fb78:	3508      	adds	r5, #8
 800fb7a:	195a      	adds	r2, r3, r5
 800fb7c:	b292      	uxth	r2, r2
          /* create mem2 struct */
          mem2 = (struct mem *)(void *)&ram[ptr2];
 800fb7e:	188e      	adds	r6, r1, r2
          mem2->used = 0;
          mem2->next = mem->next;
          mem2->prev = ptr;
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
          mem->used = 1;
 800fb80:	f04f 0801 	mov.w	r8, #1
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
          /* create mem2 struct */
          mem2 = (struct mem *)(void *)&ram[ptr2];
          mem2->used = 0;
 800fb84:	7130      	strb	r0, [r6, #4]
          mem2->next = mem->next;
 800fb86:	f821 e002 	strh.w	lr, [r1, r2]
          mem2->prev = ptr;
 800fb8a:	8073      	strh	r3, [r6, #2]
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
 800fb8c:	8022      	strh	r2, [r4, #0]
          mem->used = 1;
 800fb8e:	f884 8004 	strb.w	r8, [r4, #4]

          if (mem2->next != MEM_SIZE_ALIGNED) {
 800fb92:	5a8b      	ldrh	r3, [r1, r2]
 800fb94:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800fb98:	d0d1      	beq.n	800fb3e <BSP_mem_malloc+0x7a>
            ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
 800fb9a:	440b      	add	r3, r1
 800fb9c:	805a      	strh	r2, [r3, #2]
 800fb9e:	e7ce      	b.n	800fb3e <BSP_mem_malloc+0x7a>
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
    return NULL;
 800fba0:	2000      	movs	r0, #0
 800fba2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_mutex_unlock(&mem_mutex);
  return NULL;
}
 800fba6:	4770      	bx	lr
          lfree = cur;
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_mutex_unlock(&mem_mutex);
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
 800fba8:	4b11      	ldr	r3, [pc, #68]	; (800fbf0 <BSP_mem_malloc+0x12c>)
 800fbaa:	f240 2267 	movw	r2, #615	; 0x267
 800fbae:	4914      	ldr	r1, [pc, #80]	; (800fc00 <BSP_mem_malloc+0x13c>)
 800fbb0:	4811      	ldr	r0, [pc, #68]	; (800fbf8 <BSP_mem_malloc+0x134>)
 800fbb2:	f005 f8e1 	bl	8014d78 <iprintf>
 800fbb6:	e7cb      	b.n	800fb50 <BSP_mem_malloc+0x8c>
mem_malloc_adjust_lfree:
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
        if (mem == lfree) {
          struct mem *cur = lfree;
          /* Find next free block after mem and update lowest free pointer */
          while (cur->used && cur != ram_end) {
 800fbb8:	f89c 3004 	ldrb.w	r3, [ip, #4]
 800fbbc:	b173      	cbz	r3, 800fbdc <BSP_mem_malloc+0x118>
 800fbbe:	687a      	ldr	r2, [r7, #4]
 800fbc0:	4b09      	ldr	r3, [pc, #36]	; (800fbe8 <BSP_mem_malloc+0x124>)
 800fbc2:	4594      	cmp	ip, r2
 800fbc4:	d00d      	beq.n	800fbe2 <BSP_mem_malloc+0x11e>
 800fbc6:	6819      	ldr	r1, [r3, #0]
 800fbc8:	e001      	b.n	800fbce <BSP_mem_malloc+0x10a>
 800fbca:	4594      	cmp	ip, r2
 800fbcc:	d009      	beq.n	800fbe2 <BSP_mem_malloc+0x11e>
              /* If mem_free or mem_trim have run, we have to restart since they
                 could have altered our current struct mem or lfree. */
              goto mem_malloc_adjust_lfree;
            }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
            cur = (struct mem *)(void *)&ram[cur->next];
 800fbce:	f8bc c000 	ldrh.w	ip, [ip]
 800fbd2:	448c      	add	ip, r1
mem_malloc_adjust_lfree:
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
        if (mem == lfree) {
          struct mem *cur = lfree;
          /* Find next free block after mem and update lowest free pointer */
          while (cur->used && cur != ram_end) {
 800fbd4:	f89c 3004 	ldrb.w	r3, [ip, #4]
 800fbd8:	2b00      	cmp	r3, #0
 800fbda:	d1f6      	bne.n	800fbca <BSP_mem_malloc+0x106>
              goto mem_malloc_adjust_lfree;
            }
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
            cur = (struct mem *)(void *)&ram[cur->next];
          }
          lfree = cur;
 800fbdc:	f8c7 c008 	str.w	ip, [r7, #8]
 800fbe0:	e7af      	b.n	800fb42 <BSP_mem_malloc+0x7e>
 800fbe2:	60ba      	str	r2, [r7, #8]
 800fbe4:	e7ad      	b.n	800fb42 <BSP_mem_malloc+0x7e>
 800fbe6:	bf00      	nop
 800fbe8:	20000ec8 	.word	0x20000ec8
 800fbec:	20000ed4 	.word	0x20000ed4
 800fbf0:	08017954 	.word	0x08017954
 800fbf4:	08017ab4 	.word	0x08017ab4
 800fbf8:	0801660c 	.word	0x0801660c
 800fbfc:	08017ae4 	.word	0x08017ae4
 800fc00:	08017a84 	.word	0x08017a84

0800fc04 <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
 800fc04:	b538      	push	{r3, r4, r5, lr}
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
 800fc06:	fb01 f400 	mul.w	r4, r1, r0
 800fc0a:	b2a0      	uxth	r0, r4
 800fc0c:	f7ff ff5a 	bl	800fac4 <BSP_mem_malloc>
  if (p) {
 800fc10:	4605      	mov	r5, r0
 800fc12:	b118      	cbz	r0, 800fc1c <mem_calloc+0x18>
    /* zero the memory */
    memset(p, 0, count * size);
 800fc14:	4622      	mov	r2, r4
 800fc16:	2100      	movs	r1, #0
 800fc18:	f005 f8a6 	bl	8014d68 <memset>
  }
  return p;
}
 800fc1c:	4628      	mov	r0, r5
 800fc1e:	bd38      	pop	{r3, r4, r5, pc}

0800fc20 <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
 800fc20:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

#if !MEMP_SEPARATE_POOLS
  memp = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
 800fc24:	2600      	movs	r6, #0
#endif /* !MEMP_SEPARATE_POOLS */
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
 800fc26:	46b0      	mov	r8, r6
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

#if !MEMP_SEPARATE_POOLS
  memp = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
 800fc28:	4b16      	ldr	r3, [pc, #88]	; (800fc84 <memp_init+0x64>)
 800fc2a:	f8df c060 	ldr.w	ip, [pc, #96]	; 800fc8c <memp_init+0x6c>
 800fc2e:	4f16      	ldr	r7, [pc, #88]	; (800fc88 <memp_init+0x68>)
 800fc30:	f023 0e03 	bic.w	lr, r3, #3
 800fc34:	f10c 091c 	add.w	r9, ip, #28
 800fc38:	2504      	movs	r5, #4
#endif /* !MEMP_SEPARATE_POOLS */
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
 800fc3a:	f8c7 8000 	str.w	r8, [r7]
#if MEMP_SEPARATE_POOLS
    memp = (struct memp*)memp_bases[i];
#endif /* MEMP_SEPARATE_POOLS */
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
 800fc3e:	b1b5      	cbz	r5, 800fc6e <memp_init+0x4e>
 800fc40:	2200      	movs	r2, #0
 800fc42:	4611      	mov	r1, r2
 800fc44:	f839 a016 	ldrh.w	sl, [r9, r6, lsl #1]
 800fc48:	4673      	mov	r3, lr
 800fc4a:	e000      	b.n	800fc4e <memp_init+0x2e>
      memp->next = memp_tab[i];
      memp_tab[i] = memp;
      memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
 800fc4c:	4623      	mov	r3, r4
 800fc4e:	3201      	adds	r2, #1
    memp_tab[i] = NULL;
#if MEMP_SEPARATE_POOLS
    memp = (struct memp*)memp_bases[i];
#endif /* MEMP_SEPARATE_POOLS */
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
 800fc50:	b290      	uxth	r0, r2
 800fc52:	4285      	cmp	r5, r0
      memp->next = memp_tab[i];
 800fc54:	6019      	str	r1, [r3, #0]
      memp_tab[i] = memp;
      memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
 800fc56:	eb03 040a 	add.w	r4, r3, sl
 800fc5a:	4619      	mov	r1, r3
    memp_tab[i] = NULL;
#if MEMP_SEPARATE_POOLS
    memp = (struct memp*)memp_bases[i];
#endif /* MEMP_SEPARATE_POOLS */
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
 800fc5c:	d8f6      	bhi.n	800fc4c <memp_init+0x2c>
 800fc5e:	3d01      	subs	r5, #1
 800fc60:	b2ad      	uxth	r5, r5
 800fc62:	fb05 a30a 	mla	r3, r5, sl, sl
 800fc66:	fb0a e505 	mla	r5, sl, r5, lr
      memp->next = memp_tab[i];
      memp_tab[i] = memp;
      memp = (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]
 800fc6a:	449e      	add	lr, r3
 800fc6c:	603d      	str	r5, [r7, #0]
 800fc6e:	3601      	adds	r6, #1

#if !MEMP_SEPARATE_POOLS
  memp = (struct memp *)LWIP_MEM_ALIGN(memp_memory);
#endif /* !MEMP_SEPARATE_POOLS */
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
 800fc70:	2e0e      	cmp	r6, #14
 800fc72:	f107 0704 	add.w	r7, r7, #4
 800fc76:	d002      	beq.n	800fc7e <memp_init+0x5e>
 800fc78:	f83c 5f02 	ldrh.w	r5, [ip, #2]!
 800fc7c:	e7dd      	b.n	800fc3a <memp_init+0x1a>
 800fc7e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800fc82:	bf00      	nop
 800fc84:	20000eff 	.word	0x20000eff
 800fc88:	20004c04 	.word	0x20004c04
 800fc8c:	080161ac 	.word	0x080161ac

0800fc90 <memp_malloc>:
#endif
{
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
 800fc90:	280d      	cmp	r0, #13
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
 800fc92:	b538      	push	{r3, r4, r5, lr}
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
 800fc94:	d81f      	bhi.n	800fcd6 <memp_malloc+0x46>
 800fc96:	4604      	mov	r4, r0

  SYS_ARCH_PROTECT(old_level);
 800fc98:	f7f1 fd6c 	bl	8001774 <CPU_SR_Save>
 800fc9c:	4605      	mov	r5, r0
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
 800fc9e:	4812      	ldr	r0, [pc, #72]	; (800fce8 <memp_malloc+0x58>)
 800fca0:	eb00 0084 	add.w	r0, r0, r4, lsl #2
 800fca4:	f8d0 4a20 	ldr.w	r4, [r0, #2592]	; 0xa20
  
  if (memp != NULL) {
 800fca8:	b124      	cbz	r4, 800fcb4 <memp_malloc+0x24>
    memp_tab[type] = memp->next;
 800fcaa:	6823      	ldr	r3, [r4, #0]
 800fcac:	f8c0 3a20 	str.w	r3, [r0, #2592]	; 0xa20
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
 800fcb0:	07a3      	lsls	r3, r4, #30
 800fcb2:	d104      	bne.n	800fcbe <memp_malloc+0x2e>
  } else {
    LWIP_DEBUGF(MEMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("memp_malloc: out of memory in pool %s\n", memp_desc[type]));
    MEMP_STATS_INC(err, type);
  }

  SYS_ARCH_UNPROTECT(old_level);
 800fcb4:	4628      	mov	r0, r5
 800fcb6:	f7f1 fd61 	bl	800177c <CPU_SR_Restore>
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
 800fcba:	4620      	mov	r0, r4
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
}
 800fcbc:	bd38      	pop	{r3, r4, r5, pc}
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
 800fcbe:	4b0b      	ldr	r3, [pc, #44]	; (800fcec <memp_malloc+0x5c>)
 800fcc0:	f44f 72d0 	mov.w	r2, #416	; 0x1a0
 800fcc4:	490a      	ldr	r1, [pc, #40]	; (800fcf0 <memp_malloc+0x60>)
 800fcc6:	480b      	ldr	r0, [pc, #44]	; (800fcf4 <memp_malloc+0x64>)
 800fcc8:	f005 f856 	bl	8014d78 <iprintf>
  } else {
    LWIP_DEBUGF(MEMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("memp_malloc: out of memory in pool %s\n", memp_desc[type]));
    MEMP_STATS_INC(err, type);
  }

  SYS_ARCH_UNPROTECT(old_level);
 800fccc:	4628      	mov	r0, r5
 800fcce:	f7f1 fd55 	bl	800177c <CPU_SR_Restore>
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
 800fcd2:	4620      	mov	r0, r4
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
}
 800fcd4:	bd38      	pop	{r3, r4, r5, pc}
#endif
{
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
 800fcd6:	4b05      	ldr	r3, [pc, #20]	; (800fcec <memp_malloc+0x5c>)
 800fcd8:	f44f 72c7 	mov.w	r2, #398	; 0x18e
 800fcdc:	4906      	ldr	r1, [pc, #24]	; (800fcf8 <memp_malloc+0x68>)
 800fcde:	4805      	ldr	r0, [pc, #20]	; (800fcf4 <memp_malloc+0x64>)
 800fce0:	f005 f84a 	bl	8014d78 <iprintf>
 800fce4:	2000      	movs	r0, #0
 800fce6:	bd38      	pop	{r3, r4, r5, pc}
 800fce8:	200041e4 	.word	0x200041e4
 800fcec:	08017b08 	.word	0x08017b08
 800fcf0:	08017b38 	.word	0x08017b38
 800fcf4:	0801660c 	.word	0x0801660c
 800fcf8:	08017b18 	.word	0x08017b18

0800fcfc <memp_free>:
memp_free(memp_t type, void *mem)
{
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
 800fcfc:	b1d1      	cbz	r1, 800fd34 <memp_free+0x38>
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
 800fcfe:	b538      	push	{r3, r4, r5, lr}
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
 800fd00:	078b      	lsls	r3, r1, #30
 800fd02:	460c      	mov	r4, r1
 800fd04:	4605      	mov	r5, r0
 800fd06:	d10d      	bne.n	800fd24 <memp_free+0x28>
                ((mem_ptr_t)mem % MEM_ALIGNMENT) == 0);

  memp = (struct memp *)(void *)((u8_t*)mem - MEMP_SIZE);

  SYS_ARCH_PROTECT(old_level);
 800fd08:	f7f1 fd34 	bl	8001774 <CPU_SR_Save>
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
  
  memp->next = memp_tab[type]; 
 800fd0c:	4b0a      	ldr	r3, [pc, #40]	; (800fd38 <memp_free+0x3c>)
 800fd0e:	eb03 0385 	add.w	r3, r3, r5, lsl #2
 800fd12:	f8d3 2a20 	ldr.w	r2, [r3, #2592]	; 0xa20
 800fd16:	6022      	str	r2, [r4, #0]
  memp_tab[type] = memp;
 800fd18:	f8c3 4a20 	str.w	r4, [r3, #2592]	; 0xa20
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
 800fd1c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
 800fd20:	f7f1 bd2c 	b.w	800177c <CPU_SR_Restore>
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
 800fd24:	4b05      	ldr	r3, [pc, #20]	; (800fd3c <memp_free+0x40>)
 800fd26:	f44f 72de 	mov.w	r2, #444	; 0x1bc
 800fd2a:	4905      	ldr	r1, [pc, #20]	; (800fd40 <memp_free+0x44>)
 800fd2c:	4805      	ldr	r0, [pc, #20]	; (800fd44 <memp_free+0x48>)
 800fd2e:	f005 f823 	bl	8014d78 <iprintf>
 800fd32:	e7e9      	b.n	800fd08 <memp_free+0xc>
 800fd34:	4770      	bx	lr
 800fd36:	bf00      	nop
 800fd38:	200041e4 	.word	0x200041e4
 800fd3c:	08017b08 	.word	0x08017b08
 800fd40:	08017b5c 	.word	0x08017b5c
 800fd44:	0801660c 	.word	0x0801660c

0800fd48 <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
 800fd48:	b508      	push	{r3, lr}
  struct netbuf *buf;

  buf = (struct netbuf *)memp_malloc(MEMP_NETBUF);
 800fd4a:	2006      	movs	r0, #6
 800fd4c:	f7ff ffa0 	bl	800fc90 <memp_malloc>
  if (buf != NULL) {
 800fd50:	b120      	cbz	r0, 800fd5c <netbuf_new+0x14>
    buf->p = NULL;
 800fd52:	2300      	movs	r3, #0
 800fd54:	6003      	str	r3, [r0, #0]
    buf->ptr = NULL;
 800fd56:	6043      	str	r3, [r0, #4]
    ip_addr_set_any(&buf->addr);
 800fd58:	6083      	str	r3, [r0, #8]
    buf->port = 0;
 800fd5a:	8183      	strh	r3, [r0, #12]
#endif /* LWIP_NETBUF_RECVINFO || LWIP_CHECKSUM_ON_COPY */
    return buf;
  } else {
    return NULL;
  }
}
 800fd5c:	bd08      	pop	{r3, pc}
 800fd5e:	bf00      	nop

0800fd60 <netbuf_delete>:
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
  if (buf != NULL) {
 800fd60:	b170      	cbz	r0, 800fd80 <netbuf_delete+0x20>
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
 800fd62:	b510      	push	{r4, lr}
 800fd64:	4604      	mov	r4, r0
  if (buf != NULL) {
    if (buf->p != NULL) {
 800fd66:	6800      	ldr	r0, [r0, #0]
 800fd68:	b120      	cbz	r0, 800fd74 <netbuf_delete+0x14>
      pbuf_free(buf->p);
 800fd6a:	f000 f95d 	bl	8010028 <pbuf_free>
      buf->p = buf->ptr = NULL;
 800fd6e:	2300      	movs	r3, #0
 800fd70:	6063      	str	r3, [r4, #4]
 800fd72:	6023      	str	r3, [r4, #0]
    }
    memp_free(MEMP_NETBUF, buf);
 800fd74:	4621      	mov	r1, r4
  }
}
 800fd76:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  if (buf != NULL) {
    if (buf->p != NULL) {
      pbuf_free(buf->p);
      buf->p = buf->ptr = NULL;
    }
    memp_free(MEMP_NETBUF, buf);
 800fd7a:	2006      	movs	r0, #6
 800fd7c:	f7ff bfbe 	b.w	800fcfc <memp_free>
 800fd80:	4770      	bx	lr
 800fd82:	bf00      	nop

0800fd84 <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
 800fd84:	b538      	push	{r3, r4, r5, lr}
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
 800fd86:	4604      	mov	r4, r0
 800fd88:	b1c8      	cbz	r0, 800fdbe <netbuf_alloc+0x3a>

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
 800fd8a:	6800      	ldr	r0, [r0, #0]
 800fd8c:	460d      	mov	r5, r1
 800fd8e:	b108      	cbz	r0, 800fd94 <netbuf_alloc+0x10>
    pbuf_free(buf->p);
 800fd90:	f000 f94a 	bl	8010028 <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
 800fd94:	2200      	movs	r2, #0
 800fd96:	4610      	mov	r0, r2
 800fd98:	4629      	mov	r1, r5
 800fd9a:	f000 f99d 	bl	80100d8 <pbuf_alloc>
 800fd9e:	6020      	str	r0, [r4, #0]
  if (buf->p == NULL) {
 800fda0:	b120      	cbz	r0, 800fdac <netbuf_alloc+0x28>
     return NULL;
  }
  LWIP_ASSERT("check that first pbuf can hold size",
 800fda2:	8943      	ldrh	r3, [r0, #10]
 800fda4:	42ab      	cmp	r3, r5
 800fda6:	d302      	bcc.n	800fdae <netbuf_alloc+0x2a>
             (buf->p->len >= size));
  buf->ptr = buf->p;
 800fda8:	6060      	str	r0, [r4, #4]
  return buf->p->payload;
 800fdaa:	6840      	ldr	r0, [r0, #4]
}
 800fdac:	bd38      	pop	{r3, r4, r5, pc}
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  if (buf->p == NULL) {
     return NULL;
  }
  LWIP_ASSERT("check that first pbuf can hold size",
 800fdae:	4b08      	ldr	r3, [pc, #32]	; (800fdd0 <netbuf_alloc+0x4c>)
 800fdb0:	2278      	movs	r2, #120	; 0x78
 800fdb2:	4908      	ldr	r1, [pc, #32]	; (800fdd4 <netbuf_alloc+0x50>)
 800fdb4:	4808      	ldr	r0, [pc, #32]	; (800fdd8 <netbuf_alloc+0x54>)
 800fdb6:	f004 ffdf 	bl	8014d78 <iprintf>
 800fdba:	6820      	ldr	r0, [r4, #0]
 800fdbc:	e7f4      	b.n	800fda8 <netbuf_alloc+0x24>
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
 800fdbe:	4b04      	ldr	r3, [pc, #16]	; (800fdd0 <netbuf_alloc+0x4c>)
 800fdc0:	226d      	movs	r2, #109	; 0x6d
 800fdc2:	4906      	ldr	r1, [pc, #24]	; (800fddc <netbuf_alloc+0x58>)
 800fdc4:	4804      	ldr	r0, [pc, #16]	; (800fdd8 <netbuf_alloc+0x54>)
 800fdc6:	f004 ffd7 	bl	8014d78 <iprintf>
 800fdca:	4620      	mov	r0, r4
 800fdcc:	bd38      	pop	{r3, r4, r5, pc}
 800fdce:	bf00      	nop
 800fdd0:	08017b7c 	.word	0x08017b7c
 800fdd4:	08017bac 	.word	0x08017bac
 800fdd8:	0801660c 	.word	0x0801660c
 800fddc:	08017b90 	.word	0x08017b90

0800fde0 <netbuf_free>:
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
 800fde0:	b148      	cbz	r0, 800fdf6 <netbuf_free+0x16>
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
 800fde2:	b510      	push	{r4, lr}
 800fde4:	4604      	mov	r4, r0
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  if (buf->p != NULL) {
 800fde6:	6800      	ldr	r0, [r0, #0]
 800fde8:	b108      	cbz	r0, 800fdee <netbuf_free+0xe>
    pbuf_free(buf->p);
 800fdea:	f000 f91d 	bl	8010028 <pbuf_free>
  }
  buf->p = buf->ptr = NULL;
 800fdee:	2300      	movs	r3, #0
 800fdf0:	6063      	str	r3, [r4, #4]
 800fdf2:	6023      	str	r3, [r4, #0]
 800fdf4:	bd10      	pop	{r4, pc}
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
 800fdf6:	4b03      	ldr	r3, [pc, #12]	; (800fe04 <netbuf_free+0x24>)
 800fdf8:	2285      	movs	r2, #133	; 0x85
 800fdfa:	4903      	ldr	r1, [pc, #12]	; (800fe08 <netbuf_free+0x28>)
 800fdfc:	4803      	ldr	r0, [pc, #12]	; (800fe0c <netbuf_free+0x2c>)
 800fdfe:	f004 bfbb 	b.w	8014d78 <iprintf>
 800fe02:	bf00      	nop
 800fe04:	08017b7c 	.word	0x08017b7c
 800fe08:	08017bd0 	.word	0x08017bd0
 800fe0c:	0801660c 	.word	0x0801660c

0800fe10 <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
 800fe10:	b570      	push	{r4, r5, r6, lr}
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
 800fe12:	b1c0      	cbz	r0, 800fe46 <netbuf_ref+0x36>
 800fe14:	4604      	mov	r4, r0
  if (buf->p != NULL) {
 800fe16:	6800      	ldr	r0, [r0, #0]
 800fe18:	460e      	mov	r6, r1
 800fe1a:	4615      	mov	r5, r2
 800fe1c:	b108      	cbz	r0, 800fe22 <netbuf_ref+0x12>
    pbuf_free(buf->p);
 800fe1e:	f000 f903 	bl	8010028 <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
 800fe22:	2100      	movs	r1, #0
 800fe24:	4608      	mov	r0, r1
 800fe26:	2202      	movs	r2, #2
 800fe28:	f000 f956 	bl	80100d8 <pbuf_alloc>
 800fe2c:	4603      	mov	r3, r0
 800fe2e:	6020      	str	r0, [r4, #0]
  if (buf->p == NULL) {
 800fe30:	b128      	cbz	r0, 800fe3e <netbuf_ref+0x2e>
    buf->ptr = NULL;
    return ERR_MEM;
  }
  buf->p->payload = (void*)dataptr;
 800fe32:	6046      	str	r6, [r0, #4]
  buf->p->len = buf->p->tot_len = size;
 800fe34:	8105      	strh	r5, [r0, #8]
 800fe36:	8145      	strh	r5, [r0, #10]
  buf->ptr = buf->p;
  return ERR_OK;
 800fe38:	2000      	movs	r0, #0
    buf->ptr = NULL;
    return ERR_MEM;
  }
  buf->p->payload = (void*)dataptr;
  buf->p->len = buf->p->tot_len = size;
  buf->ptr = buf->p;
 800fe3a:	6063      	str	r3, [r4, #4]
  return ERR_OK;
}
 800fe3c:	bd70      	pop	{r4, r5, r6, pc}
  if (buf->p != NULL) {
    pbuf_free(buf->p);
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
  if (buf->p == NULL) {
    buf->ptr = NULL;
 800fe3e:	6060      	str	r0, [r4, #4]
    return ERR_MEM;
 800fe40:	f04f 30ff 	mov.w	r0, #4294967295
 800fe44:	bd70      	pop	{r4, r5, r6, pc}
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
 800fe46:	4b04      	ldr	r3, [pc, #16]	; (800fe58 <netbuf_ref+0x48>)
 800fe48:	2298      	movs	r2, #152	; 0x98
 800fe4a:	4904      	ldr	r1, [pc, #16]	; (800fe5c <netbuf_ref+0x4c>)
 800fe4c:	4804      	ldr	r0, [pc, #16]	; (800fe60 <netbuf_ref+0x50>)
 800fe4e:	f004 ff93 	bl	8014d78 <iprintf>
 800fe52:	f06f 000d 	mvn.w	r0, #13
 800fe56:	bd70      	pop	{r4, r5, r6, pc}
 800fe58:	08017b7c 	.word	0x08017b7c
 800fe5c:	08017bec 	.word	0x08017bec
 800fe60:	0801660c 	.word	0x0801660c

0800fe64 <netbuf_chain>:
 * @param tail netbuf to chain after head, freed by this function, may not be reference after returning
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
 800fe64:	b1a8      	cbz	r0, 800fe92 <netbuf_chain+0x2e>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
 800fe66:	b171      	cbz	r1, 800fe86 <netbuf_chain+0x22>
 * @param head the first netbuf
 * @param tail netbuf to chain after head, freed by this function, may not be reference after returning
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
 800fe68:	b570      	push	{r4, r5, r6, lr}
 800fe6a:	4604      	mov	r4, r0
 800fe6c:	460d      	mov	r5, r1
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  pbuf_cat(head->p, tail->p);
 800fe6e:	6800      	ldr	r0, [r0, #0]
 800fe70:	6809      	ldr	r1, [r1, #0]
 800fe72:	f000 fa97 	bl	80103a4 <pbuf_cat>
  head->ptr = head->p;
 800fe76:	6823      	ldr	r3, [r4, #0]
  memp_free(MEMP_NETBUF, tail);
 800fe78:	4629      	mov	r1, r5
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  pbuf_cat(head->p, tail->p);
  head->ptr = head->p;
 800fe7a:	6063      	str	r3, [r4, #4]
  memp_free(MEMP_NETBUF, tail);
 800fe7c:	2006      	movs	r0, #6
}
 800fe7e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
{
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  pbuf_cat(head->p, tail->p);
  head->ptr = head->p;
  memp_free(MEMP_NETBUF, tail);
 800fe82:	f7ff bf3b 	b.w	800fcfc <memp_free>
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
 800fe86:	4b06      	ldr	r3, [pc, #24]	; (800fea0 <netbuf_chain+0x3c>)
 800fe88:	22b1      	movs	r2, #177	; 0xb1
 800fe8a:	4906      	ldr	r1, [pc, #24]	; (800fea4 <netbuf_chain+0x40>)
 800fe8c:	4806      	ldr	r0, [pc, #24]	; (800fea8 <netbuf_chain+0x44>)
 800fe8e:	f004 bf73 	b.w	8014d78 <iprintf>
 * @param tail netbuf to chain after head, freed by this function, may not be reference after returning
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
 800fe92:	4b03      	ldr	r3, [pc, #12]	; (800fea0 <netbuf_chain+0x3c>)
 800fe94:	22b0      	movs	r2, #176	; 0xb0
 800fe96:	4905      	ldr	r1, [pc, #20]	; (800feac <netbuf_chain+0x48>)
 800fe98:	4803      	ldr	r0, [pc, #12]	; (800fea8 <netbuf_chain+0x44>)
 800fe9a:	f004 bf6d 	b.w	8014d78 <iprintf>
 800fe9e:	bf00      	nop
 800fea0:	08017b7c 	.word	0x08017b7c
 800fea4:	08017c20 	.word	0x08017c20
 800fea8:	0801660c 	.word	0x0801660c
 800feac:	08017c04 	.word	0x08017c04

0800feb0 <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
 800feb0:	b510      	push	{r4, lr}
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
 800feb2:	b300      	cbz	r0, 800fef6 <netbuf_data+0x46>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
 800feb4:	b1b1      	cbz	r1, 800fee4 <netbuf_data+0x34>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
 800feb6:	b162      	cbz	r2, 800fed2 <netbuf_data+0x22>
 800feb8:	4603      	mov	r3, r0

  if (buf->ptr == NULL) {
 800feba:	6840      	ldr	r0, [r0, #4]
 800febc:	b130      	cbz	r0, 800fecc <netbuf_data+0x1c>
    return ERR_BUF;
  }
  *dataptr = buf->ptr->payload;
 800febe:	6844      	ldr	r4, [r0, #4]
  *len = buf->ptr->len;
  return ERR_OK;
 800fec0:	2000      	movs	r0, #0
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);

  if (buf->ptr == NULL) {
    return ERR_BUF;
  }
  *dataptr = buf->ptr->payload;
 800fec2:	600c      	str	r4, [r1, #0]
  *len = buf->ptr->len;
 800fec4:	685b      	ldr	r3, [r3, #4]
 800fec6:	895b      	ldrh	r3, [r3, #10]
 800fec8:	8013      	strh	r3, [r2, #0]
  return ERR_OK;
 800feca:	bd10      	pop	{r4, pc}
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);

  if (buf->ptr == NULL) {
    return ERR_BUF;
 800fecc:	f06f 0001 	mvn.w	r0, #1
  }
  *dataptr = buf->ptr->payload;
  *len = buf->ptr->len;
  return ERR_OK;
}
 800fed0:	bd10      	pop	{r4, pc}
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
 800fed2:	4b0d      	ldr	r3, [pc, #52]	; (800ff08 <netbuf_data+0x58>)
 800fed4:	22c5      	movs	r2, #197	; 0xc5
 800fed6:	490d      	ldr	r1, [pc, #52]	; (800ff0c <netbuf_data+0x5c>)
 800fed8:	480d      	ldr	r0, [pc, #52]	; (800ff10 <netbuf_data+0x60>)
 800feda:	f004 ff4d 	bl	8014d78 <iprintf>
 800fede:	f06f 000d 	mvn.w	r0, #13
 800fee2:	bd10      	pop	{r4, pc}
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
 800fee4:	4b08      	ldr	r3, [pc, #32]	; (800ff08 <netbuf_data+0x58>)
 800fee6:	22c4      	movs	r2, #196	; 0xc4
 800fee8:	490a      	ldr	r1, [pc, #40]	; (800ff14 <netbuf_data+0x64>)
 800feea:	4809      	ldr	r0, [pc, #36]	; (800ff10 <netbuf_data+0x60>)
 800feec:	f004 ff44 	bl	8014d78 <iprintf>
 800fef0:	f06f 000d 	mvn.w	r0, #13
 800fef4:	bd10      	pop	{r4, pc}
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
 800fef6:	4b04      	ldr	r3, [pc, #16]	; (800ff08 <netbuf_data+0x58>)
 800fef8:	22c3      	movs	r2, #195	; 0xc3
 800fefa:	4907      	ldr	r1, [pc, #28]	; (800ff18 <netbuf_data+0x68>)
 800fefc:	4804      	ldr	r0, [pc, #16]	; (800ff10 <netbuf_data+0x60>)
 800fefe:	f004 ff3b 	bl	8014d78 <iprintf>
 800ff02:	f06f 000d 	mvn.w	r0, #13
 800ff06:	bd10      	pop	{r4, pc}
 800ff08:	08017b7c 	.word	0x08017b7c
 800ff0c:	08017c78 	.word	0x08017c78
 800ff10:	0801660c 	.word	0x0801660c
 800ff14:	08017c58 	.word	0x08017c58
 800ff18:	08017c3c 	.word	0x08017c3c

0800ff1c <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
 800ff1c:	b508      	push	{r3, lr}
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
 800ff1e:	b158      	cbz	r0, 800ff38 <netbuf_next+0x1c>
  if (buf->ptr->next == NULL) {
 800ff20:	6843      	ldr	r3, [r0, #4]
 800ff22:	681a      	ldr	r2, [r3, #0]
 800ff24:	b12a      	cbz	r2, 800ff32 <netbuf_next+0x16>
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
 800ff26:	6813      	ldr	r3, [r2, #0]
  if (buf->ptr->next == NULL) {
    return -1;
  }
  buf->ptr = buf->ptr->next;
 800ff28:	6042      	str	r2, [r0, #4]
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
 800ff2a:	fab3 f083 	clz	r0, r3
 800ff2e:	0940      	lsrs	r0, r0, #5
 800ff30:	bd08      	pop	{r3, pc}
  if (buf->ptr->next == NULL) {
    return -1;
 800ff32:	f04f 30ff 	mov.w	r0, #4294967295
  buf->ptr = buf->ptr->next;
  if (buf->ptr->next == NULL) {
    return 1;
  }
  return 0;
}
 800ff36:	bd08      	pop	{r3, pc}
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
 800ff38:	4b04      	ldr	r3, [pc, #16]	; (800ff4c <netbuf_next+0x30>)
 800ff3a:	22dc      	movs	r2, #220	; 0xdc
 800ff3c:	4904      	ldr	r1, [pc, #16]	; (800ff50 <netbuf_next+0x34>)
 800ff3e:	4805      	ldr	r0, [pc, #20]	; (800ff54 <netbuf_next+0x38>)
 800ff40:	f004 ff1a 	bl	8014d78 <iprintf>
 800ff44:	f04f 30ff 	mov.w	r0, #4294967295
 800ff48:	bd08      	pop	{r3, pc}
 800ff4a:	bf00      	nop
 800ff4c:	08017b7c 	.word	0x08017b7c
 800ff50:	08017bd0 	.word	0x08017bd0
 800ff54:	0801660c 	.word	0x0801660c

0800ff58 <netbuf_first>:
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
 800ff58:	b110      	cbz	r0, 800ff60 <netbuf_first+0x8>
  buf->ptr = buf->p;
 800ff5a:	6803      	ldr	r3, [r0, #0]
 800ff5c:	6043      	str	r3, [r0, #4]
 800ff5e:	4770      	bx	lr
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
 800ff60:	4b02      	ldr	r3, [pc, #8]	; (800ff6c <netbuf_first+0x14>)
 800ff62:	22f1      	movs	r2, #241	; 0xf1
 800ff64:	4902      	ldr	r1, [pc, #8]	; (800ff70 <netbuf_first+0x18>)
 800ff66:	4803      	ldr	r0, [pc, #12]	; (800ff74 <netbuf_first+0x1c>)
 800ff68:	f004 bf06 	b.w	8014d78 <iprintf>
 800ff6c:	08017b7c 	.word	0x08017b7c
 800ff70:	08017bd0 	.word	0x08017bd0
 800ff74:	0801660c 	.word	0x0801660c

0800ff78 <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
 800ff78:	b510      	push	{r4, lr}
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
 800ff7a:	4604      	mov	r4, r0
 800ff7c:	2800      	cmp	r0, #0
 800ff7e:	d03a      	beq.n	800fff6 <pbuf_header+0x7e>
  if ((header_size_increment == 0) || (p == NULL)) {
 800ff80:	2900      	cmp	r1, #0
 800ff82:	d01c      	beq.n	800ffbe <pbuf_header+0x46>
    return 0;
  }
 
  if (header_size_increment < 0){
 800ff84:	db1d      	blt.n	800ffc2 <pbuf_header+0x4a>
    increment_magnitude = -header_size_increment;
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  } else {
    increment_magnitude = header_size_increment;
 800ff86:	b28a      	uxth	r2, r1
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
 800ff88:	7b23      	ldrb	r3, [r4, #12]
  /* remember current payload pointer */
  payload = p->payload;
 800ff8a:	6860      	ldr	r0, [r4, #4]

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
 800ff8c:	b143      	cbz	r3, 800ffa0 <pbuf_header+0x28>
 800ff8e:	2b03      	cmp	r3, #3
 800ff90:	d006      	beq.n	800ffa0 <pbuf_header+0x28>
      p->payload = payload;
      /* bail out unsuccesfully */
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
 800ff92:	3b01      	subs	r3, #1
 800ff94:	2b01      	cmp	r3, #1
 800ff96:	d825      	bhi.n	800ffe4 <pbuf_header+0x6c>
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
 800ff98:	2900      	cmp	r1, #0
 800ff9a:	db35      	blt.n	8010008 <pbuf_header+0x90>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
 800ff9c:	2001      	movs	r0, #1
 800ff9e:	bd10      	pop	{r4, pc}
  payload = p->payload;

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
 800ffa0:	1a43      	subs	r3, r0, r1
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
 800ffa2:	f104 0210 	add.w	r2, r4, #16
 800ffa6:	4293      	cmp	r3, r2
  payload = p->payload;

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
 800ffa8:	6063      	str	r3, [r4, #4]
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
 800ffaa:	d318      	bcc.n	800ffde <pbuf_header+0x66>
 800ffac:	8963      	ldrh	r3, [r4, #10]
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
  p->tot_len += header_size_increment;
 800ffae:	8922      	ldrh	r2, [r4, #8]
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
 800ffb0:	b289      	uxth	r1, r1
 800ffb2:	440b      	add	r3, r1
  p->tot_len += header_size_increment;
 800ffb4:	4411      	add	r1, r2
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
 800ffb6:	8163      	strh	r3, [r4, #10]
  p->tot_len += header_size_increment;
 800ffb8:	8121      	strh	r1, [r4, #8]

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
 800ffba:	2000      	movs	r0, #0
 800ffbc:	bd10      	pop	{r4, pc}
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL)) {
    return 0;
 800ffbe:	4608      	mov	r0, r1
 800ffc0:	bd10      	pop	{r4, pc}
  }
 
  if (header_size_increment < 0){
    increment_magnitude = -header_size_increment;
 800ffc2:	424a      	negs	r2, r1
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
 800ffc4:	8963      	ldrh	r3, [r4, #10]
  if ((header_size_increment == 0) || (p == NULL)) {
    return 0;
  }
 
  if (header_size_increment < 0){
    increment_magnitude = -header_size_increment;
 800ffc6:	b292      	uxth	r2, r2
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
 800ffc8:	4293      	cmp	r3, r2
 800ffca:	d2dd      	bcs.n	800ff88 <pbuf_header+0x10>
 800ffcc:	4b11      	ldr	r3, [pc, #68]	; (8010014 <pbuf_header+0x9c>)
 800ffce:	f240 220d 	movw	r2, #525	; 0x20d
 800ffd2:	4911      	ldr	r1, [pc, #68]	; (8010018 <pbuf_header+0xa0>)
 800ffd4:	4811      	ldr	r0, [pc, #68]	; (801001c <pbuf_header+0xa4>)
 800ffd6:	f004 fecf 	bl	8014d78 <iprintf>
 800ffda:	2001      	movs	r0, #1
 800ffdc:	bd10      	pop	{r4, pc}
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
        ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
        (void *)p->payload, (void *)(p + 1)));
      /* restore old payload pointer */
      p->payload = payload;
 800ffde:	6060      	str	r0, [r4, #4]
      /* bail out unsuccesfully */
      return 1;
 800ffe0:	2001      	movs	r0, #1
 800ffe2:	bd10      	pop	{r4, pc}
       * bail out unsuccesfully */
      return 1;
    }
  } else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
 800ffe4:	4b0b      	ldr	r3, [pc, #44]	; (8010014 <pbuf_header+0x9c>)
 800ffe6:	f240 223b 	movw	r2, #571	; 0x23b
 800ffea:	490d      	ldr	r1, [pc, #52]	; (8010020 <pbuf_header+0xa8>)
 800ffec:	480b      	ldr	r0, [pc, #44]	; (801001c <pbuf_header+0xa4>)
 800ffee:	f004 fec3 	bl	8014d78 <iprintf>
    return 1;
 800fff2:	2001      	movs	r0, #1
 800fff4:	bd10      	pop	{r4, pc}
{
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
 800fff6:	4b07      	ldr	r3, [pc, #28]	; (8010014 <pbuf_header+0x9c>)
 800fff8:	f240 2205 	movw	r2, #517	; 0x205
 800fffc:	4909      	ldr	r1, [pc, #36]	; (8010024 <pbuf_header+0xac>)
 800fffe:	4807      	ldr	r0, [pc, #28]	; (801001c <pbuf_header+0xa4>)
 8010000:	f004 feba 	bl	8014d78 <iprintf>
  if ((header_size_increment == 0) || (p == NULL)) {
    return 0;
 8010004:	4620      	mov	r0, r4
 8010006:	bd10      	pop	{r4, pc}
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
 8010008:	8963      	ldrh	r3, [r4, #10]
 801000a:	429a      	cmp	r2, r3
 801000c:	d8c6      	bhi.n	800ff9c <pbuf_header+0x24>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
 801000e:	1a40      	subs	r0, r0, r1
 8010010:	6060      	str	r0, [r4, #4]
 8010012:	e7cc      	b.n	800ffae <pbuf_header+0x36>
 8010014:	08017c94 	.word	0x08017c94
 8010018:	08017ca4 	.word	0x08017ca4
 801001c:	0801660c 	.word	0x0801660c
 8010020:	08017cc4 	.word	0x08017cc4
 8010024:	080172e8 	.word	0x080172e8

08010028 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
 8010028:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
 801002a:	4605      	mov	r5, r0
 801002c:	2800      	cmp	r0, #0
 801002e:	d040      	beq.n	80100b2 <pbuf_free+0x8a>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
 8010030:	7b03      	ldrb	r3, [r0, #12]
 8010032:	2b03      	cmp	r3, #3
 8010034:	d835      	bhi.n	80100a2 <pbuf_free+0x7a>
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
 8010036:	2600      	movs	r6, #0
 8010038:	e015      	b.n	8010066 <pbuf_free+0x3e>
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
 801003a:	3c01      	subs	r4, #1
 801003c:	b2a4      	uxth	r4, r4
 801003e:	81ec      	strh	r4, [r5, #14]
    SYS_ARCH_UNPROTECT(old_level);
 8010040:	4638      	mov	r0, r7
 8010042:	f7f1 fb9b 	bl	800177c <CPU_SR_Restore>
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
 8010046:	bb2c      	cbnz	r4, 8010094 <pbuf_free+0x6c>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
      LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
 8010048:	7b2b      	ldrb	r3, [r5, #12]
    ref = --(p->ref);
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
      /* remember next pbuf in chain for next iteration */
      q = p->next;
 801004a:	682c      	ldr	r4, [r5, #0]
        pc->custom_free_function(p);
      } else
#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
      {
        /* is this a pbuf from the pool? */
        if (type == PBUF_POOL) {
 801004c:	2b03      	cmp	r3, #3
          memp_free(MEMP_PBUF_POOL, p);
        /* is this a ROM or RAM referencing pbuf? */
        } else if (type == PBUF_ROM || type == PBUF_REF) {
 801004e:	f103 32ff 	add.w	r2, r3, #4294967295
        pc->custom_free_function(p);
      } else
#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
      {
        /* is this a pbuf from the pool? */
        if (type == PBUF_POOL) {
 8010052:	d021      	beq.n	8010098 <pbuf_free+0x70>
          memp_free(MEMP_PBUF_POOL, p);
        /* is this a ROM or RAM referencing pbuf? */
        } else if (type == PBUF_ROM || type == PBUF_REF) {
 8010054:	2a01      	cmp	r2, #1
 8010056:	d915      	bls.n	8010084 <pbuf_free+0x5c>
          memp_free(MEMP_PBUF, p);
        /* type == PBUF_RAM */
        } else {
          mem_free(p);
 8010058:	4628      	mov	r0, r5
 801005a:	f7ff fbd9 	bl	800f810 <BSP_mem_free>
        }
      }
      count++;
 801005e:	3601      	adds	r6, #1
 8010060:	b2f6      	uxtb	r6, r6
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
 8010062:	b1bc      	cbz	r4, 8010094 <pbuf_free+0x6c>
 8010064:	4625      	mov	r5, r4
    u16_t ref;
    SYS_ARCH_DECL_PROTECT(old_level);
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
 8010066:	f7f1 fb85 	bl	8001774 <CPU_SR_Save>
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
 801006a:	89ec      	ldrh	r4, [r5, #14]
    u16_t ref;
    SYS_ARCH_DECL_PROTECT(old_level);
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
 801006c:	4607      	mov	r7, r0
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
 801006e:	2c00      	cmp	r4, #0
 8010070:	d1e3      	bne.n	801003a <pbuf_free+0x12>
 8010072:	4b14      	ldr	r3, [pc, #80]	; (80100c4 <pbuf_free+0x9c>)
 8010074:	f240 228a 	movw	r2, #650	; 0x28a
 8010078:	4913      	ldr	r1, [pc, #76]	; (80100c8 <pbuf_free+0xa0>)
 801007a:	4814      	ldr	r0, [pc, #80]	; (80100cc <pbuf_free+0xa4>)
 801007c:	f004 fe7c 	bl	8014d78 <iprintf>
 8010080:	89ec      	ldrh	r4, [r5, #14]
 8010082:	e7da      	b.n	801003a <pbuf_free+0x12>
        /* is this a pbuf from the pool? */
        if (type == PBUF_POOL) {
          memp_free(MEMP_PBUF_POOL, p);
        /* is this a ROM or RAM referencing pbuf? */
        } else if (type == PBUF_ROM || type == PBUF_REF) {
          memp_free(MEMP_PBUF, p);
 8010084:	4629      	mov	r1, r5
 8010086:	200c      	movs	r0, #12
        /* type == PBUF_RAM */
        } else {
          mem_free(p);
        }
      }
      count++;
 8010088:	3601      	adds	r6, #1
        /* is this a pbuf from the pool? */
        if (type == PBUF_POOL) {
          memp_free(MEMP_PBUF_POOL, p);
        /* is this a ROM or RAM referencing pbuf? */
        } else if (type == PBUF_ROM || type == PBUF_REF) {
          memp_free(MEMP_PBUF, p);
 801008a:	f7ff fe37 	bl	800fcfc <memp_free>
        /* type == PBUF_RAM */
        } else {
          mem_free(p);
        }
      }
      count++;
 801008e:	b2f6      	uxtb	r6, r6
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
 8010090:	2c00      	cmp	r4, #0
 8010092:	d1e7      	bne.n	8010064 <pbuf_free+0x3c>
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
 8010094:	4630      	mov	r0, r6
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
}
 8010096:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      } else
#endif /* LWIP_SUPPORT_CUSTOM_PBUF */
      {
        /* is this a pbuf from the pool? */
        if (type == PBUF_POOL) {
          memp_free(MEMP_PBUF_POOL, p);
 8010098:	4629      	mov	r1, r5
 801009a:	200d      	movs	r0, #13
 801009c:	f7ff fe2e 	bl	800fcfc <memp_free>
 80100a0:	e7dd      	b.n	801005e <pbuf_free+0x36>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
 80100a2:	4b08      	ldr	r3, [pc, #32]	; (80100c4 <pbuf_free+0x9c>)
 80100a4:	f240 227d 	movw	r2, #637	; 0x27d
 80100a8:	4909      	ldr	r1, [pc, #36]	; (80100d0 <pbuf_free+0xa8>)
 80100aa:	4808      	ldr	r0, [pc, #32]	; (80100cc <pbuf_free+0xa4>)
 80100ac:	f004 fe64 	bl	8014d78 <iprintf>
 80100b0:	e7c1      	b.n	8010036 <pbuf_free+0xe>
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
    LWIP_ASSERT("p != NULL", p != NULL);
 80100b2:	4b04      	ldr	r3, [pc, #16]	; (80100c4 <pbuf_free+0x9c>)
 80100b4:	f240 2271 	movw	r2, #625	; 0x271
 80100b8:	4906      	ldr	r1, [pc, #24]	; (80100d4 <pbuf_free+0xac>)
 80100ba:	4804      	ldr	r0, [pc, #16]	; (80100cc <pbuf_free+0xa4>)
 80100bc:	f004 fe5c 	bl	8014d78 <iprintf>
    /* if assertions are disabled, proceed with debug output */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
      ("pbuf_free(p == NULL) was called.\n"));
    return 0;
 80100c0:	4628      	mov	r0, r5
 80100c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80100c4:	08017c94 	.word	0x08017c94
 80100c8:	08017cec 	.word	0x08017cec
 80100cc:	0801660c 	.word	0x0801660c
 80100d0:	08017cd4 	.word	0x08017cd4
 80100d4:	080172e8 	.word	0x080172e8

080100d8 <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
 80100d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80100dc:	460f      	mov	r7, r1
 80100de:	b082      	sub	sp, #8
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  switch (layer) {
 80100e0:	2803      	cmp	r0, #3
 80100e2:	f200 80a4 	bhi.w	801022e <pbuf_alloc+0x156>
 80100e6:	e8df f000 	tbb	[pc, r0]
 80100ea:	0291      	.short	0x0291
 80100ec:	9395      	.short	0x9395
    /* add room for transport (often TCP) layer header */
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
    break;
  case PBUF_IP:
    /* add room for IP layer header */
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
 80100ee:	2422      	movs	r4, #34	; 0x22
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    return NULL;
  }

  switch (type) {
 80100f0:	2a03      	cmp	r2, #3
 80100f2:	f200 8091 	bhi.w	8010218 <pbuf_alloc+0x140>
 80100f6:	e8df f002 	tbb	[pc, r2]
 80100fa:	5c6b      	.short	0x5c6b
 80100fc:	025c      	.short	0x025c
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
    p = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
 80100fe:	200d      	movs	r0, #13
 8010100:	f7ff fdc6 	bl	800fc90 <memp_malloc>
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
 8010104:	4606      	mov	r6, r0
 8010106:	2800      	cmp	r0, #0
 8010108:	f000 808d 	beq.w	8010226 <pbuf_alloc+0x14e>
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
 801010c:	1ce5      	adds	r5, r4, #3
 801010e:	f025 0503 	bic.w	r5, r5, #3
 8010112:	f5c5 75fa 	rsb	r5, r5, #500	; 0x1f4
 8010116:	42bd      	cmp	r5, r7
 8010118:	bfa8      	it	ge
 801011a:	463d      	movge	r5, r7
    }
    p->type = type;
    p->next = NULL;

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
 801011c:	4404      	add	r4, r0
 801011e:	3413      	adds	r4, #19
 8010120:	f024 0403 	bic.w	r4, r4, #3
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
 8010124:	1963      	adds	r3, r4, r5
 8010126:	f500 7801 	add.w	r8, r0, #516	; 0x204
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
 801012a:	b2ad      	uxth	r5, r5
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
      PBUF_POOL_IS_EMPTY();
      return NULL;
    }
    p->type = type;
 801012c:	2103      	movs	r1, #3
    p->next = NULL;
 801012e:	2200      	movs	r2, #0
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
 8010130:	4598      	cmp	r8, r3
    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
 8010132:	8107      	strh	r7, [r0, #8]
    }
    p->type = type;
    p->next = NULL;

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
 8010134:	6044      	str	r4, [r0, #4]
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
 8010136:	8145      	strh	r5, [r0, #10]
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
      PBUF_POOL_IS_EMPTY();
      return NULL;
    }
    p->type = type;
 8010138:	7301      	strb	r1, [r0, #12]
    p->next = NULL;
 801013a:	6002      	str	r2, [r0, #0]
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
 801013c:	f0c0 8096 	bcc.w	801026c <pbuf_alloc+0x194>
    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
 8010140:	1b7d      	subs	r5, r7, r5
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
      (PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)) > 0 );
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
 8010142:	2301      	movs	r3, #1
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
 8010144:	2d00      	cmp	r5, #0
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
      (PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)) > 0 );
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
 8010146:	81f3      	strh	r3, [r6, #14]
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
 8010148:	dd58      	ble.n	80101fc <pbuf_alloc+0x124>
 801014a:	4637      	mov	r7, r6
 801014c:	e018      	b.n	8010180 <pbuf_alloc+0xa8>
      q->next = NULL;
      /* make previous pbuf point to this pbuf */
      r->next = q;
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
      q->tot_len = (u16_t)rem_len;
 801014e:	b2aa      	uxth	r2, r5
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
 8010150:	4611      	mov	r1, r2
 8010152:	f5b2 7ffa 	cmp.w	r2, #500	; 0x1f4
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
 8010156:	f104 0310 	add.w	r3, r4, #16
      r->next = q;
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
      q->tot_len = (u16_t)rem_len;
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
 801015a:	bf28      	it	cs
 801015c:	f44f 71fa 	movcs.w	r1, #500	; 0x1f4
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
 8010160:	6063      	str	r3, [r4, #4]
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
 8010162:	079b      	lsls	r3, r3, #30
      q->next = NULL;
      /* make previous pbuf point to this pbuf */
      r->next = q;
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
      q->tot_len = (u16_t)rem_len;
 8010164:	8122      	strh	r2, [r4, #8]
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
 8010166:	8161      	strh	r1, [r4, #10]
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
 8010168:	d173      	bne.n	8010252 <pbuf_alloc+0x17a>
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
 801016a:	8973      	ldrh	r3, [r6, #10]
 801016c:	6872      	ldr	r2, [r6, #4]
 801016e:	4413      	add	r3, r2
 8010170:	4598      	cmp	r8, r3
 8010172:	d366      	bcc.n	8010242 <pbuf_alloc+0x16a>
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
 8010174:	8962      	ldrh	r2, [r4, #10]
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
 8010176:	2301      	movs	r3, #1
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
 8010178:	1aad      	subs	r5, r5, r2
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
 801017a:	2d00      	cmp	r5, #0
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
 801017c:	81e3      	strh	r3, [r4, #14]
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
 801017e:	dd3d      	ble.n	80101fc <pbuf_alloc+0x124>
      q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
 8010180:	200d      	movs	r0, #13
 8010182:	f7ff fd85 	bl	800fc90 <memp_malloc>
        pbuf_free(p);
        /* bail out unsuccesfully */
        return NULL;
      }
      q->type = type;
      q->flags = 0;
 8010186:	2300      	movs	r3, #0
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
      q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
      if (q == NULL) {
 8010188:	4604      	mov	r4, r0
        /* free chain so far allocated */
        pbuf_free(p);
        /* bail out unsuccesfully */
        return NULL;
      }
      q->type = type;
 801018a:	2203      	movs	r2, #3
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
      q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
      if (q == NULL) {
 801018c:	2800      	cmp	r0, #0
 801018e:	d068      	beq.n	8010262 <pbuf_alloc+0x18a>
      q->flags = 0;
      q->next = NULL;
      /* make previous pbuf point to this pbuf */
      r->next = q;
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
 8010190:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8010194:	428d      	cmp	r5, r1
        /* free chain so far allocated */
        pbuf_free(p);
        /* bail out unsuccesfully */
        return NULL;
      }
      q->type = type;
 8010196:	7302      	strb	r2, [r0, #12]
      q->flags = 0;
 8010198:	7343      	strb	r3, [r0, #13]
      q->next = NULL;
 801019a:	6003      	str	r3, [r0, #0]
      /* make previous pbuf point to this pbuf */
      r->next = q;
 801019c:	6038      	str	r0, [r7, #0]
 801019e:	4607      	mov	r7, r0
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
 80101a0:	d1d5      	bne.n	801014e <pbuf_alloc+0x76>
 80101a2:	4b37      	ldr	r3, [pc, #220]	; (8010280 <pbuf_alloc+0x1a8>)
 80101a4:	f44f 728f 	mov.w	r2, #286	; 0x11e
 80101a8:	4936      	ldr	r1, [pc, #216]	; (8010284 <pbuf_alloc+0x1ac>)
 80101aa:	4837      	ldr	r0, [pc, #220]	; (8010288 <pbuf_alloc+0x1b0>)
 80101ac:	f004 fde4 	bl	8014d78 <iprintf>
 80101b0:	e7cd      	b.n	801014e <pbuf_alloc+0x76>
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = (struct pbuf *)memp_malloc(MEMP_PBUF);
 80101b2:	200c      	movs	r0, #12
 80101b4:	9201      	str	r2, [sp, #4]
 80101b6:	f7ff fd6b 	bl	800fc90 <memp_malloc>
    if (p == NULL) {
 80101ba:	4606      	mov	r6, r0
 80101bc:	2800      	cmp	r0, #0
 80101be:	d032      	beq.n	8010226 <pbuf_alloc+0x14e>
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
    p->len = p->tot_len = length;
    p->next = NULL;
    p->type = type;
 80101c0:	9a01      	ldr	r2, [sp, #4]
                  ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
 80101c2:	2300      	movs	r3, #0
    p->len = p->tot_len = length;
 80101c4:	8107      	strh	r7, [r0, #8]
 80101c6:	8147      	strh	r7, [r0, #10]
    p->next = NULL;
    p->type = type;
 80101c8:	7302      	strb	r2, [r0, #12]
                  ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
 80101ca:	6043      	str	r3, [r0, #4]
    p->len = p->tot_len = length;
    p->next = NULL;
 80101cc:	6003      	str	r3, [r0, #0]
    p->type = type;
    break;
 80101ce:	e015      	b.n	80101fc <pbuf_alloc+0x124>
    /*r->next = NULL;*/

    break;
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
 80101d0:	f104 0013 	add.w	r0, r4, #19
 80101d4:	1cfb      	adds	r3, r7, #3
 80101d6:	f023 0303 	bic.w	r3, r3, #3
 80101da:	f020 0003 	bic.w	r0, r0, #3
 80101de:	4418      	add	r0, r3
 80101e0:	f7ff fc70 	bl	800fac4 <BSP_mem_malloc>
    if (p == NULL) {
 80101e4:	4606      	mov	r6, r0
 80101e6:	b1f0      	cbz	r0, 8010226 <pbuf_alloc+0x14e>
      return NULL;
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
 80101e8:	4404      	add	r4, r0
 80101ea:	3413      	adds	r4, #19
    p->len = p->tot_len = length;
    p->next = NULL;
 80101ec:	2300      	movs	r3, #0
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
    if (p == NULL) {
      return NULL;
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
 80101ee:	f024 0403 	bic.w	r4, r4, #3
 80101f2:	6044      	str	r4, [r0, #4]
    p->len = p->tot_len = length;
 80101f4:	8107      	strh	r7, [r0, #8]
 80101f6:	8147      	strh	r7, [r0, #10]
    p->next = NULL;
 80101f8:	6003      	str	r3, [r0, #0]
    p->type = type;
 80101fa:	7303      	strb	r3, [r0, #12]
  /* set reference count */
  p->ref = 1;
  /* set flags */
  p->flags = 0;
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
 80101fc:	4630      	mov	r0, r6
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
    return NULL;
  }
  /* set reference count */
  p->ref = 1;
 80101fe:	2201      	movs	r2, #1
  /* set flags */
  p->flags = 0;
 8010200:	2300      	movs	r3, #0
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
    return NULL;
  }
  /* set reference count */
  p->ref = 1;
 8010202:	81f2      	strh	r2, [r6, #14]
  /* set flags */
  p->flags = 0;
 8010204:	7373      	strb	r3, [r6, #13]
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
}
 8010206:	b002      	add	sp, #8
 8010208:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

  /* determine header offset */
  switch (layer) {
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
 801020c:	2436      	movs	r4, #54	; 0x36
 801020e:	e76f      	b.n	80100f0 <pbuf_alloc+0x18>
  case PBUF_LINK:
    /* add room for link layer header */
    offset = PBUF_LINK_HLEN;
    break;
  case PBUF_RAW:
    offset = 0;
 8010210:	2400      	movs	r4, #0
    break;
 8010212:	e76d      	b.n	80100f0 <pbuf_alloc+0x18>
    /* add room for IP layer header */
    offset = PBUF_LINK_HLEN + PBUF_IP_HLEN;
    break;
  case PBUF_LINK:
    /* add room for link layer header */
    offset = PBUF_LINK_HLEN;
 8010214:	240e      	movs	r4, #14
 8010216:	e76b      	b.n	80100f0 <pbuf_alloc+0x18>
    p->len = p->tot_len = length;
    p->next = NULL;
    p->type = type;
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
 8010218:	4b19      	ldr	r3, [pc, #100]	; (8010280 <pbuf_alloc+0x1a8>)
 801021a:	f44f 72aa 	mov.w	r2, #340	; 0x154
 801021e:	491b      	ldr	r1, [pc, #108]	; (801028c <pbuf_alloc+0x1b4>)
 8010220:	4819      	ldr	r0, [pc, #100]	; (8010288 <pbuf_alloc+0x1b0>)
 8010222:	f004 fda9 	bl	8014d78 <iprintf>
    return NULL;
 8010226:	2000      	movs	r0, #0
  p->ref = 1;
  /* set flags */
  p->flags = 0;
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
}
 8010228:	b002      	add	sp, #8
 801022a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    break;
  case PBUF_RAW:
    offset = 0;
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
 801022e:	4b14      	ldr	r3, [pc, #80]	; (8010280 <pbuf_alloc+0x1a8>)
 8010230:	22e8      	movs	r2, #232	; 0xe8
 8010232:	4917      	ldr	r1, [pc, #92]	; (8010290 <pbuf_alloc+0x1b8>)
 8010234:	4814      	ldr	r0, [pc, #80]	; (8010288 <pbuf_alloc+0x1b0>)
 8010236:	f004 fd9f 	bl	8014d78 <iprintf>
    return NULL;
 801023a:	2000      	movs	r0, #0
  p->ref = 1;
  /* set flags */
  p->flags = 0;
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
}
 801023c:	b002      	add	sp, #8
 801023e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
 8010242:	4b0f      	ldr	r3, [pc, #60]	; (8010280 <pbuf_alloc+0x1a8>)
 8010244:	f240 1227 	movw	r2, #295	; 0x127
 8010248:	4912      	ldr	r1, [pc, #72]	; (8010294 <pbuf_alloc+0x1bc>)
 801024a:	480f      	ldr	r0, [pc, #60]	; (8010288 <pbuf_alloc+0x1b0>)
 801024c:	f004 fd94 	bl	8014d78 <iprintf>
 8010250:	e790      	b.n	8010174 <pbuf_alloc+0x9c>
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
      q->tot_len = (u16_t)rem_len;
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
 8010252:	4b0b      	ldr	r3, [pc, #44]	; (8010280 <pbuf_alloc+0x1a8>)
 8010254:	f44f 7292 	mov.w	r2, #292	; 0x124
 8010258:	490f      	ldr	r1, [pc, #60]	; (8010298 <pbuf_alloc+0x1c0>)
 801025a:	480b      	ldr	r0, [pc, #44]	; (8010288 <pbuf_alloc+0x1b0>)
 801025c:	f004 fd8c 	bl	8014d78 <iprintf>
 8010260:	e783      	b.n	801016a <pbuf_alloc+0x92>
    while (rem_len > 0) {
      q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
      if (q == NULL) {
        PBUF_POOL_IS_EMPTY();
        /* free chain so far allocated */
        pbuf_free(p);
 8010262:	4630      	mov	r0, r6
 8010264:	f7ff fee0 	bl	8010028 <pbuf_free>
        /* bail out unsuccesfully */
        return NULL;
 8010268:	4620      	mov	r0, r4
 801026a:	e7dd      	b.n	8010228 <pbuf_alloc+0x150>
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
 801026c:	4b04      	ldr	r3, [pc, #16]	; (8010280 <pbuf_alloc+0x1a8>)
 801026e:	f44f 7281 	mov.w	r2, #258	; 0x102
 8010272:	4908      	ldr	r1, [pc, #32]	; (8010294 <pbuf_alloc+0x1bc>)
 8010274:	4804      	ldr	r0, [pc, #16]	; (8010288 <pbuf_alloc+0x1b0>)
 8010276:	f004 fd7f 	bl	8014d78 <iprintf>
 801027a:	8975      	ldrh	r5, [r6, #10]
 801027c:	e760      	b.n	8010140 <pbuf_alloc+0x68>
 801027e:	bf00      	nop
 8010280:	08017c94 	.word	0x08017c94
 8010284:	08017d54 	.word	0x08017d54
 8010288:	0801660c 	.word	0x0801660c
 801028c:	08017d98 	.word	0x08017d98
 8010290:	08017d04 	.word	0x08017d04
 8010294:	08017d20 	.word	0x08017d20
 8010298:	08017d68 	.word	0x08017d68

0801029c <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
 801029c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80102a0:	460e      	mov	r6, r1
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  s32_t grow;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
 80102a2:	4604      	mov	r4, r0
 80102a4:	2800      	cmp	r0, #0
 80102a6:	d04f      	beq.n	8010348 <pbuf_realloc+0xac>
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
 80102a8:	7b23      	ldrb	r3, [r4, #12]
 80102aa:	2b03      	cmp	r3, #3
 80102ac:	d906      	bls.n	80102bc <pbuf_realloc+0x20>
 80102ae:	4b2a      	ldr	r3, [pc, #168]	; (8010358 <pbuf_realloc+0xbc>)
 80102b0:	f44f 72dc 	mov.w	r2, #440	; 0x1b8
 80102b4:	4929      	ldr	r1, [pc, #164]	; (801035c <pbuf_realloc+0xc0>)
 80102b6:	482a      	ldr	r0, [pc, #168]	; (8010360 <pbuf_realloc+0xc4>)
 80102b8:	f004 fd5e 	bl	8014d78 <iprintf>
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
 80102bc:	8927      	ldrh	r7, [r4, #8]
 80102be:	42b7      	cmp	r7, r6
 80102c0:	d92f      	bls.n	8010322 <pbuf_realloc+0x86>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
 80102c2:	ebc7 0806 	rsb	r8, r7, r6

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
 80102c6:	4635      	mov	r5, r6
 80102c8:	e005      	b.n	80102d6 <pbuf_realloc+0x3a>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
    q->tot_len += (u16_t)grow;
 80102ca:	8923      	ldrh	r3, [r4, #8]
 80102cc:	1bdb      	subs	r3, r3, r7
 80102ce:	4433      	add	r3, r6
 80102d0:	8123      	strh	r3, [r4, #8]
    /* proceed to next pbuf in chain */
    q = q->next;
 80102d2:	6824      	ldr	r4, [r4, #0]
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
 80102d4:	b33c      	cbz	r4, 8010326 <pbuf_realloc+0x8a>

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
 80102d6:	8963      	ldrh	r3, [r4, #10]
 80102d8:	429d      	cmp	r5, r3
 80102da:	d90d      	bls.n	80102f8 <pbuf_realloc+0x5c>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
 80102dc:	f64f 72fe 	movw	r2, #65534	; 0xfffe
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
 80102e0:	1aed      	subs	r5, r5, r3
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
 80102e2:	4590      	cmp	r8, r2
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
 80102e4:	b2ad      	uxth	r5, r5
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
 80102e6:	ddf0      	ble.n	80102ca <pbuf_realloc+0x2e>
 80102e8:	4b1b      	ldr	r3, [pc, #108]	; (8010358 <pbuf_realloc+0xbc>)
 80102ea:	f44f 72e6 	mov.w	r2, #460	; 0x1cc
 80102ee:	491d      	ldr	r1, [pc, #116]	; (8010364 <pbuf_realloc+0xc8>)
 80102f0:	481b      	ldr	r0, [pc, #108]	; (8010360 <pbuf_realloc+0xc4>)
 80102f2:	f004 fd41 	bl	8014d78 <iprintf>
 80102f6:	e7e8      	b.n	80102ca <pbuf_realloc+0x2e>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
 80102f8:	7b22      	ldrb	r2, [r4, #12]
 80102fa:	b952      	cbnz	r2, 8010312 <pbuf_realloc+0x76>
 80102fc:	429d      	cmp	r5, r3
 80102fe:	d008      	beq.n	8010312 <pbuf_realloc+0x76>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
 8010300:	6863      	ldr	r3, [r4, #4]
 8010302:	4620      	mov	r0, r4
 8010304:	1b1c      	subs	r4, r3, r4
 8010306:	b2a1      	uxth	r1, r4
 8010308:	4429      	add	r1, r5
 801030a:	f7ff fb39 	bl	800f980 <BSP_mem_trim>
    LWIP_ASSERT("mem_trim returned q == NULL", q != NULL);
 801030e:	4604      	mov	r4, r0
 8010310:	b188      	cbz	r0, 8010336 <pbuf_realloc+0x9a>
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
  q->tot_len = q->len;

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
 8010312:	6820      	ldr	r0, [r4, #0]
    /* reallocate and adjust the length of the pbuf that will be split */
    q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
    LWIP_ASSERT("mem_trim returned q == NULL", q != NULL);
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
 8010314:	8165      	strh	r5, [r4, #10]
  q->tot_len = q->len;
 8010316:	8125      	strh	r5, [r4, #8]

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
 8010318:	b108      	cbz	r0, 801031e <pbuf_realloc+0x82>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
 801031a:	f7ff fe85 	bl	8010028 <pbuf_free>
  }
  /* q is last packet in chain */
  q->next = NULL;
 801031e:	2300      	movs	r3, #0
 8010320:	6023      	str	r3, [r4, #0]
 8010322:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
    q->tot_len += (u16_t)grow;
    /* proceed to next pbuf in chain */
    q = q->next;
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
 8010326:	4b0c      	ldr	r3, [pc, #48]	; (8010358 <pbuf_realloc+0xbc>)
 8010328:	f44f 72e8 	mov.w	r2, #464	; 0x1d0
 801032c:	490e      	ldr	r1, [pc, #56]	; (8010368 <pbuf_realloc+0xcc>)
 801032e:	480c      	ldr	r0, [pc, #48]	; (8010360 <pbuf_realloc+0xc4>)
 8010330:	f004 fd22 	bl	8014d78 <iprintf>
 8010334:	e7cf      	b.n	80102d6 <pbuf_realloc+0x3a>
  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
    /* reallocate and adjust the length of the pbuf that will be split */
    q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
    LWIP_ASSERT("mem_trim returned q == NULL", q != NULL);
 8010336:	4b08      	ldr	r3, [pc, #32]	; (8010358 <pbuf_realloc+0xbc>)
 8010338:	f44f 72ed 	mov.w	r2, #474	; 0x1da
 801033c:	490b      	ldr	r1, [pc, #44]	; (801036c <pbuf_realloc+0xd0>)
 801033e:	4808      	ldr	r0, [pc, #32]	; (8010360 <pbuf_realloc+0xc4>)
 8010340:	f004 fd1a 	bl	8014d78 <iprintf>
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
 8010344:	8164      	strh	r4, [r4, #10]
 8010346:	deff      	udf	#255	; 0xff
{
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  s32_t grow;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
 8010348:	4b03      	ldr	r3, [pc, #12]	; (8010358 <pbuf_realloc+0xbc>)
 801034a:	f44f 72da 	mov.w	r2, #436	; 0x1b4
 801034e:	4908      	ldr	r1, [pc, #32]	; (8010370 <pbuf_realloc+0xd4>)
 8010350:	4803      	ldr	r0, [pc, #12]	; (8010360 <pbuf_realloc+0xc4>)
 8010352:	f004 fd11 	bl	8014d78 <iprintf>
 8010356:	e7a7      	b.n	80102a8 <pbuf_realloc+0xc>
 8010358:	08017c94 	.word	0x08017c94
 801035c:	08017dcc 	.word	0x08017dcc
 8010360:	0801660c 	.word	0x0801660c
 8010364:	08017de8 	.word	0x08017de8
 8010368:	08017dfc 	.word	0x08017dfc
 801036c:	08017e14 	.word	0x08017e14
 8010370:	08017db4 	.word	0x08017db4

08010374 <pbuf_clen>:
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
 8010374:	4603      	mov	r3, r0
 8010376:	b130      	cbz	r0, 8010386 <pbuf_clen+0x12>
 8010378:	2000      	movs	r0, #0
    ++len;
    p = p->next;
 801037a:	681b      	ldr	r3, [r3, #0]
{
  u8_t len;

  len = 0;
  while (p != NULL) {
    ++len;
 801037c:	3001      	adds	r0, #1
 801037e:	b2c0      	uxtb	r0, r0
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
 8010380:	2b00      	cmp	r3, #0
 8010382:	d1fa      	bne.n	801037a <pbuf_clen+0x6>
 8010384:	4770      	bx	lr
    ++len;
    p = p->next;
  }
  return len;
}
 8010386:	4770      	bx	lr

08010388 <pbuf_ref>:
void
pbuf_ref(struct pbuf *p)
{
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
 8010388:	b150      	cbz	r0, 80103a0 <pbuf_ref+0x18>
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
 801038a:	b510      	push	{r4, lr}
 801038c:	4604      	mov	r4, r0
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
    SYS_ARCH_PROTECT(old_level);
 801038e:	f7f1 f9f1 	bl	8001774 <CPU_SR_Save>
    ++(p->ref);
 8010392:	89e3      	ldrh	r3, [r4, #14]
 8010394:	3301      	adds	r3, #1
 8010396:	81e3      	strh	r3, [r4, #14]
    SYS_ARCH_UNPROTECT(old_level);
  }
}
 8010398:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
    SYS_ARCH_UNPROTECT(old_level);
 801039c:	f7f1 b9ee 	b.w	800177c <CPU_SR_Restore>
 80103a0:	4770      	bx	lr
 80103a2:	bf00      	nop

080103a4 <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
 80103a4:	b570      	push	{r4, r5, r6, lr}
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
 80103a6:	b338      	cbz	r0, 80103f8 <pbuf_cat+0x54>
 80103a8:	460d      	mov	r5, r1
 80103aa:	b329      	cbz	r1, 80103f8 <pbuf_cat+0x54>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
 80103ac:	6804      	ldr	r4, [r0, #0]
 80103ae:	b90c      	cbnz	r4, 80103b4 <pbuf_cat+0x10>
 80103b0:	e02b      	b.n	801040a <pbuf_cat+0x66>
 80103b2:	4614      	mov	r4, r2
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
 80103b4:	8901      	ldrh	r1, [r0, #8]
 80103b6:	892b      	ldrh	r3, [r5, #8]

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
 80103b8:	6822      	ldr	r2, [r4, #0]
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
 80103ba:	440b      	add	r3, r1
 80103bc:	8103      	strh	r3, [r0, #8]
 80103be:	4620      	mov	r0, r4

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
 80103c0:	2a00      	cmp	r2, #0
 80103c2:	d1f6      	bne.n	80103b2 <pbuf_cat+0xe>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
 80103c4:	8962      	ldrh	r2, [r4, #10]
 80103c6:	8923      	ldrh	r3, [r4, #8]
 80103c8:	4293      	cmp	r3, r2
 80103ca:	d010      	beq.n	80103ee <pbuf_cat+0x4a>
 80103cc:	4b10      	ldr	r3, [pc, #64]	; (8010410 <pbuf_cat+0x6c>)
 80103ce:	f240 22f6 	movw	r2, #758	; 0x2f6
 80103d2:	4910      	ldr	r1, [pc, #64]	; (8010414 <pbuf_cat+0x70>)
 80103d4:	4810      	ldr	r0, [pc, #64]	; (8010418 <pbuf_cat+0x74>)
 80103d6:	f004 fccf 	bl	8014d78 <iprintf>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
 80103da:	6823      	ldr	r3, [r4, #0]
 80103dc:	b133      	cbz	r3, 80103ec <pbuf_cat+0x48>
 80103de:	4b0c      	ldr	r3, [pc, #48]	; (8010410 <pbuf_cat+0x6c>)
 80103e0:	f240 22f7 	movw	r2, #759	; 0x2f7
 80103e4:	490d      	ldr	r1, [pc, #52]	; (801041c <pbuf_cat+0x78>)
 80103e6:	480c      	ldr	r0, [pc, #48]	; (8010418 <pbuf_cat+0x74>)
 80103e8:	f004 fcc6 	bl	8014d78 <iprintf>
 80103ec:	8922      	ldrh	r2, [r4, #8]
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
 80103ee:	892b      	ldrh	r3, [r5, #8]
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
 80103f0:	6025      	str	r5, [r4, #0]
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
 80103f2:	4413      	add	r3, r2
 80103f4:	8123      	strh	r3, [r4, #8]
 80103f6:	bd70      	pop	{r4, r5, r6, pc}
void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
 80103f8:	4b05      	ldr	r3, [pc, #20]	; (8010410 <pbuf_cat+0x6c>)
 80103fa:	f240 22ee 	movw	r2, #750	; 0x2ee
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
 80103fe:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
 8010402:	4907      	ldr	r1, [pc, #28]	; (8010420 <pbuf_cat+0x7c>)
 8010404:	4804      	ldr	r0, [pc, #16]	; (8010418 <pbuf_cat+0x74>)
 8010406:	f004 bcb7 	b.w	8014d78 <iprintf>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
 801040a:	4604      	mov	r4, r0
 801040c:	e7da      	b.n	80103c4 <pbuf_cat+0x20>
 801040e:	bf00      	nop
 8010410:	08017c94 	.word	0x08017c94
 8010414:	08017e68 	.word	0x08017e68
 8010418:	0801660c 	.word	0x0801660c
 801041c:	08017e98 	.word	0x08017e98
 8010420:	08017e30 	.word	0x08017e30

08010424 <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
 8010424:	b510      	push	{r4, lr}
 8010426:	460c      	mov	r4, r1
  pbuf_cat(h, t);
 8010428:	f7ff ffbc 	bl	80103a4 <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
 801042c:	4620      	mov	r0, r4
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
 801042e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
  pbuf_cat(h, t);
  /* t is now referenced by h */
  pbuf_ref(t);
 8010432:	f7ff bfa9 	b.w	8010388 <pbuf_ref>
 8010436:	bf00      	nop

08010438 <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
 8010438:	b570      	push	{r4, r5, r6, lr}
  struct pbuf *q;
  u8_t tail_gone = 1;
  /* tail */
  q = p->next;
 801043a:	6805      	ldr	r5, [r0, #0]
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
 801043c:	4604      	mov	r4, r0
  struct pbuf *q;
  u8_t tail_gone = 1;
  /* tail */
  q = p->next;
  /* pbuf has successor in chain? */
  if (q != NULL) {
 801043e:	b32d      	cbz	r5, 801048c <pbuf_dechain+0x54>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
 8010440:	8903      	ldrh	r3, [r0, #8]
 8010442:	8942      	ldrh	r2, [r0, #10]
 8010444:	8929      	ldrh	r1, [r5, #8]
 8010446:	1a9b      	subs	r3, r3, r2
 8010448:	4299      	cmp	r1, r3
 801044a:	d009      	beq.n	8010460 <pbuf_dechain+0x28>
 801044c:	4b13      	ldr	r3, [pc, #76]	; (801049c <pbuf_dechain+0x64>)
 801044e:	f44f 724b 	mov.w	r2, #812	; 0x32c
 8010452:	4913      	ldr	r1, [pc, #76]	; (80104a0 <pbuf_dechain+0x68>)
 8010454:	4813      	ldr	r0, [pc, #76]	; (80104a4 <pbuf_dechain+0x6c>)
 8010456:	f004 fc8f 	bl	8014d78 <iprintf>
 801045a:	8923      	ldrh	r3, [r4, #8]
 801045c:	8962      	ldrh	r2, [r4, #10]
 801045e:	1a9b      	subs	r3, r3, r2
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
    /* decouple pbuf from remainder */
    p->next = NULL;
 8010460:	2100      	movs	r1, #0
  /* pbuf has successor in chain? */
  if (q != NULL) {
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
 8010462:	812b      	strh	r3, [r5, #8]
    p->next = NULL;
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
 8010464:	4628      	mov	r0, r5
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
    /* decouple pbuf from remainder */
    p->next = NULL;
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
 8010466:	8122      	strh	r2, [r4, #8]
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
    /* decouple pbuf from remainder */
    p->next = NULL;
 8010468:	6021      	str	r1, [r4, #0]
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
 801046a:	f7ff fddd 	bl	8010028 <pbuf_free>
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
 801046e:	8922      	ldrh	r2, [r4, #8]
 8010470:	8963      	ldrh	r3, [r4, #10]
    p->next = NULL;
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
 8010472:	4606      	mov	r6, r0
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
 8010474:	429a      	cmp	r2, r3
 8010476:	d006      	beq.n	8010486 <pbuf_dechain+0x4e>
 8010478:	4b08      	ldr	r3, [pc, #32]	; (801049c <pbuf_dechain+0x64>)
 801047a:	f240 323d 	movw	r2, #829	; 0x33d
 801047e:	490a      	ldr	r1, [pc, #40]	; (80104a8 <pbuf_dechain+0x70>)
 8010480:	4808      	ldr	r0, [pc, #32]	; (80104a4 <pbuf_dechain+0x6c>)
 8010482:	f004 fc79 	bl	8014d78 <iprintf>
  return ((tail_gone > 0) ? NULL : q);
 8010486:	b93e      	cbnz	r6, 8010498 <pbuf_dechain+0x60>
pbuf_dechain(struct pbuf *p)
{
  struct pbuf *q;
  u8_t tail_gone = 1;
  /* tail */
  q = p->next;
 8010488:	4628      	mov	r0, r5
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  return ((tail_gone > 0) ? NULL : q);
 801048a:	bd70      	pop	{r4, r5, r6, pc}
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
 801048c:	8902      	ldrh	r2, [r0, #8]
 801048e:	8943      	ldrh	r3, [r0, #10]
 8010490:	429a      	cmp	r2, r3
 8010492:	d001      	beq.n	8010498 <pbuf_dechain+0x60>
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  struct pbuf *q;
  u8_t tail_gone = 1;
 8010494:	2601      	movs	r6, #1
 8010496:	e7ef      	b.n	8010478 <pbuf_dechain+0x40>
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  return ((tail_gone > 0) ? NULL : q);
 8010498:	2000      	movs	r0, #0
 801049a:	bd70      	pop	{r4, r5, r6, pc}
 801049c:	08017c94 	.word	0x08017c94
 80104a0:	08017ea8 	.word	0x08017ea8
 80104a4:	0801660c 	.word	0x0801660c
 80104a8:	08017ecc 	.word	0x08017ecc

080104ac <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
 80104ac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
 80104b0:	2800      	cmp	r0, #0
 80104b2:	d076      	beq.n	80105a2 <pbuf_copy+0xf6>
 80104b4:	460e      	mov	r6, r1
 80104b6:	2900      	cmp	r1, #0
 80104b8:	d073      	beq.n	80105a2 <pbuf_copy+0xf6>
 80104ba:	8902      	ldrh	r2, [r0, #8]
 80104bc:	890b      	ldrh	r3, [r1, #8]
 80104be:	4607      	mov	r7, r0
 80104c0:	429a      	cmp	r2, r3
 80104c2:	d36e      	bcc.n	80105a2 <pbuf_copy+0xf6>
 80104c4:	f04f 0800 	mov.w	r8, #0
 80104c8:	4645      	mov	r5, r8
 80104ca:	8943      	ldrh	r3, [r0, #10]
 80104cc:	8972      	ldrh	r2, [r6, #10]

  /* iterate through pbuf chain */
  do
  {
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
 80104ce:	ebc8 0402 	rsb	r4, r8, r2
 80104d2:	1b5b      	subs	r3, r3, r5
 80104d4:	42a3      	cmp	r3, r4
      len = p_from->len - offset_from;
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
 80104d6:	6871      	ldr	r1, [r6, #4]
 80104d8:	6878      	ldr	r0, [r7, #4]
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
 80104da:	bfb4      	ite	lt
 80104dc:	b29c      	uxthlt	r4, r3
  do
  {
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
 80104de:	b2a4      	uxthge	r4, r4
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
 80104e0:	4441      	add	r1, r8
 80104e2:	4428      	add	r0, r5
 80104e4:	4622      	mov	r2, r4
 80104e6:	f004 fc34 	bl	8014d52 <memcpy>
    offset_to += len;
 80104ea:	4425      	add	r5, r4
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
 80104ec:	897b      	ldrh	r3, [r7, #10]
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    offset_to += len;
 80104ee:	b2ad      	uxth	r5, r5
    offset_from += len;
 80104f0:	4444      	add	r4, r8
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
 80104f2:	42ab      	cmp	r3, r5
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    offset_to += len;
    offset_from += len;
 80104f4:	fa1f f884 	uxth.w	r8, r4
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
 80104f8:	d339      	bcc.n	801056e <pbuf_copy+0xc2>
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
 80104fa:	8973      	ldrh	r3, [r6, #10]
 80104fc:	4598      	cmp	r8, r3
 80104fe:	d82d      	bhi.n	801055c <pbuf_copy+0xb0>
    if (offset_from >= p_from->len) {
 8010500:	4598      	cmp	r8, r3
      /* on to next p_from (if any) */
      offset_from = 0;
      p_from = p_from->next;
    }
    if (offset_to == p_to->len) {
 8010502:	897b      	ldrh	r3, [r7, #10]
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
    if (offset_from >= p_from->len) {
      /* on to next p_from (if any) */
      offset_from = 0;
      p_from = p_from->next;
 8010504:	bf24      	itt	cs
 8010506:	6836      	ldrcs	r6, [r6, #0]
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
    if (offset_from >= p_from->len) {
      /* on to next p_from (if any) */
      offset_from = 0;
 8010508:	f04f 0800 	movcs.w	r8, #0
      p_from = p_from->next;
    }
    if (offset_to == p_to->len) {
 801050c:	42ab      	cmp	r3, r5
 801050e:	d00d      	beq.n	801052c <pbuf_copy+0x80>
      offset_to = 0;
      p_to = p_to->next;
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
 8010510:	b196      	cbz	r6, 8010538 <pbuf_copy+0x8c>
 8010512:	8972      	ldrh	r2, [r6, #10]
 8010514:	8933      	ldrh	r3, [r6, #8]
 8010516:	429a      	cmp	r2, r3
 8010518:	d031      	beq.n	801057e <pbuf_copy+0xd2>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
 801051a:	897b      	ldrh	r3, [r7, #10]
 801051c:	8939      	ldrh	r1, [r7, #8]
 801051e:	4299      	cmp	r1, r3
 8010520:	d1d5      	bne.n	80104ce <pbuf_copy+0x22>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
 8010522:	683a      	ldr	r2, [r7, #0]
 8010524:	b97a      	cbnz	r2, 8010546 <pbuf_copy+0x9a>
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
 8010526:	2e00      	cmp	r6, #0
 8010528:	d1d0      	bne.n	80104cc <pbuf_copy+0x20>
 801052a:	e037      	b.n	801059c <pbuf_copy+0xf0>
      p_from = p_from->next;
    }
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
 801052c:	683f      	ldr	r7, [r7, #0]
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
 801052e:	2f00      	cmp	r7, #0
 8010530:	d033      	beq.n	801059a <pbuf_copy+0xee>
      offset_from = 0;
      p_from = p_from->next;
    }
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
 8010532:	2500      	movs	r5, #0
      p_to = p_to->next;
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
 8010534:	2e00      	cmp	r6, #0
 8010536:	d1ec      	bne.n	8010512 <pbuf_copy+0x66>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
 8010538:	897b      	ldrh	r3, [r7, #10]
 801053a:	893a      	ldrh	r2, [r7, #8]
 801053c:	429a      	cmp	r2, r3
 801053e:	d12d      	bne.n	801059c <pbuf_copy+0xf0>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
 8010540:	683a      	ldr	r2, [r7, #0]
 8010542:	2a00      	cmp	r2, #0
 8010544:	d0ef      	beq.n	8010526 <pbuf_copy+0x7a>
 8010546:	4b22      	ldr	r3, [pc, #136]	; (80105d0 <pbuf_copy+0x124>)
 8010548:	f240 3283 	movw	r2, #899	; 0x383
 801054c:	4921      	ldr	r1, [pc, #132]	; (80105d4 <pbuf_copy+0x128>)
 801054e:	4822      	ldr	r0, [pc, #136]	; (80105d8 <pbuf_copy+0x12c>)
 8010550:	f004 fc12 	bl	8014d78 <iprintf>
 8010554:	f06f 0005 	mvn.w	r0, #5
 8010558:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    offset_to += len;
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
 801055c:	4b1c      	ldr	r3, [pc, #112]	; (80105d0 <pbuf_copy+0x124>)
 801055e:	f240 326e 	movw	r2, #878	; 0x36e
 8010562:	491e      	ldr	r1, [pc, #120]	; (80105dc <pbuf_copy+0x130>)
 8010564:	481c      	ldr	r0, [pc, #112]	; (80105d8 <pbuf_copy+0x12c>)
 8010566:	f004 fc07 	bl	8014d78 <iprintf>
 801056a:	8973      	ldrh	r3, [r6, #10]
 801056c:	e7c8      	b.n	8010500 <pbuf_copy+0x54>
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    offset_to += len;
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
 801056e:	4b18      	ldr	r3, [pc, #96]	; (80105d0 <pbuf_copy+0x124>)
 8010570:	f240 326d 	movw	r2, #877	; 0x36d
 8010574:	491a      	ldr	r1, [pc, #104]	; (80105e0 <pbuf_copy+0x134>)
 8010576:	4818      	ldr	r0, [pc, #96]	; (80105d8 <pbuf_copy+0x12c>)
 8010578:	f004 fbfe 	bl	8014d78 <iprintf>
 801057c:	e7bd      	b.n	80104fa <pbuf_copy+0x4e>
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
 801057e:	6833      	ldr	r3, [r6, #0]
 8010580:	2b00      	cmp	r3, #0
 8010582:	d0ca      	beq.n	801051a <pbuf_copy+0x6e>
 8010584:	4b12      	ldr	r3, [pc, #72]	; (80105d0 <pbuf_copy+0x124>)
 8010586:	f240 327e 	movw	r2, #894	; 0x37e
 801058a:	4912      	ldr	r1, [pc, #72]	; (80105d4 <pbuf_copy+0x128>)
 801058c:	4812      	ldr	r0, [pc, #72]	; (80105d8 <pbuf_copy+0x12c>)
 801058e:	f004 fbf3 	bl	8014d78 <iprintf>
 8010592:	f06f 0005 	mvn.w	r0, #5
 8010596:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
 801059a:	b96e      	cbnz	r6, 80105b8 <pbuf_copy+0x10c>
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
 801059c:	4630      	mov	r0, r6
 801059e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
 80105a2:	4b0b      	ldr	r3, [pc, #44]	; (80105d0 <pbuf_copy+0x124>)
 80105a4:	f240 325d 	movw	r2, #861	; 0x35d
 80105a8:	490e      	ldr	r1, [pc, #56]	; (80105e4 <pbuf_copy+0x138>)
 80105aa:	480b      	ldr	r0, [pc, #44]	; (80105d8 <pbuf_copy+0x12c>)
 80105ac:	f004 fbe4 	bl	8014d78 <iprintf>
 80105b0:	f06f 000d 	mvn.w	r0, #13
 80105b4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    }
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
      LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
 80105b8:	4b05      	ldr	r3, [pc, #20]	; (80105d0 <pbuf_copy+0x124>)
 80105ba:	f44f 725e 	mov.w	r2, #888	; 0x378
 80105be:	490a      	ldr	r1, [pc, #40]	; (80105e8 <pbuf_copy+0x13c>)
 80105c0:	4805      	ldr	r0, [pc, #20]	; (80105d8 <pbuf_copy+0x12c>)
 80105c2:	f004 fbd9 	bl	8014d78 <iprintf>
 80105c6:	f06f 000d 	mvn.w	r0, #13
 80105ca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80105ce:	bf00      	nop
 80105d0:	08017c94 	.word	0x08017c94
 80105d4:	08017f58 	.word	0x08017f58
 80105d8:	0801660c 	.word	0x0801660c
 80105dc:	08017f2c 	.word	0x08017f2c
 80105e0:	08017f14 	.word	0x08017f14
 80105e4:	08017ee4 	.word	0x08017ee4
 80105e8:	08017f48 	.word	0x08017f48

080105ec <pbuf_copy_partial>:
 * @param offset offset into the packet buffer from where to begin copying len bytes
 * @return the number of bytes copied, or 0 on failure
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
 80105ec:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
 80105f0:	4605      	mov	r5, r0
 80105f2:	2800      	cmp	r0, #0
 80105f4:	d02e      	beq.n	8010654 <pbuf_copy_partial+0x68>
 80105f6:	4688      	mov	r8, r1
  LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
 80105f8:	2900      	cmp	r1, #0
 80105fa:	d035      	beq.n	8010668 <pbuf_copy_partial+0x7c>
 80105fc:	4616      	mov	r6, r2
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
 80105fe:	2a00      	cmp	r2, #0
 8010600:	d03c      	beq.n	801067c <pbuf_copy_partial+0x90>
 8010602:	2700      	movs	r7, #0
 8010604:	46b9      	mov	r9, r7
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
 8010606:	eb08 0009 	add.w	r0, r8, r9
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
    if ((offset != 0) && (offset >= p->len)) {
 801060a:	896a      	ldrh	r2, [r5, #10]
 801060c:	b153      	cbz	r3, 8010624 <pbuf_copy_partial+0x38>
 801060e:	429a      	cmp	r2, r3
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
 8010610:	eba3 0102 	sub.w	r1, r3, r2
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
    if ((offset != 0) && (offset >= p->len)) {
 8010614:	d806      	bhi.n	8010624 <pbuf_copy_partial+0x38>
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
 8010616:	682d      	ldr	r5, [r5, #0]
    if ((offset != 0) && (offset >= p->len)) {
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
 8010618:	b28b      	uxth	r3, r1
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
 801061a:	2d00      	cmp	r5, #0
 801061c:	d1f3      	bne.n	8010606 <pbuf_copy_partial+0x1a>
 801061e:	4638      	mov	r0, r7
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
}
 8010620:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if ((offset != 0) && (offset >= p->len)) {
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
 8010624:	1ad4      	subs	r4, r2, r3
 8010626:	b2a4      	uxth	r4, r4
 8010628:	42b4      	cmp	r4, r6
 801062a:	bf28      	it	cs
 801062c:	4634      	movcs	r4, r6
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
 801062e:	6869      	ldr	r1, [r5, #4]
      copied_total += buf_copy_len;
      left += buf_copy_len;
      len -= buf_copy_len;
 8010630:	1b36      	subs	r6, r6, r4
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
 8010632:	4419      	add	r1, r3
 8010634:	4622      	mov	r2, r4
      copied_total += buf_copy_len;
 8010636:	4427      	add	r7, r4
      left += buf_copy_len;
 8010638:	44a1      	add	r9, r4
      len -= buf_copy_len;
 801063a:	b2b6      	uxth	r6, r6
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
 801063c:	f004 fb89 	bl	8014d52 <memcpy>
      copied_total += buf_copy_len;
 8010640:	b2bf      	uxth	r7, r7
      left += buf_copy_len;
 8010642:	fa1f f989 	uxth.w	r9, r9
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
 8010646:	682d      	ldr	r5, [r5, #0]
 8010648:	2e00      	cmp	r6, #0
 801064a:	d0e8      	beq.n	801061e <pbuf_copy_partial+0x32>
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
      copied_total += buf_copy_len;
      left += buf_copy_len;
      len -= buf_copy_len;
      offset = 0;
 801064c:	2300      	movs	r3, #0
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
 801064e:	2d00      	cmp	r5, #0
 8010650:	d1d9      	bne.n	8010606 <pbuf_copy_partial+0x1a>
 8010652:	e7e4      	b.n	801061e <pbuf_copy_partial+0x32>
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
 8010654:	4b0b      	ldr	r3, [pc, #44]	; (8010684 <pbuf_copy_partial+0x98>)
 8010656:	f240 329d 	movw	r2, #925	; 0x39d
 801065a:	490b      	ldr	r1, [pc, #44]	; (8010688 <pbuf_copy_partial+0x9c>)
 801065c:	480b      	ldr	r0, [pc, #44]	; (801068c <pbuf_copy_partial+0xa0>)
 801065e:	f004 fb8b 	bl	8014d78 <iprintf>
 8010662:	4628      	mov	r0, r5
 8010664:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
 8010668:	4b06      	ldr	r3, [pc, #24]	; (8010684 <pbuf_copy_partial+0x98>)
 801066a:	f240 329e 	movw	r2, #926	; 0x39e
 801066e:	4908      	ldr	r1, [pc, #32]	; (8010690 <pbuf_copy_partial+0xa4>)
 8010670:	4806      	ldr	r0, [pc, #24]	; (801068c <pbuf_copy_partial+0xa0>)
 8010672:	f004 fb81 	bl	8014d78 <iprintf>
 8010676:	4640      	mov	r0, r8
 8010678:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
 801067c:	4610      	mov	r0, r2
 801067e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8010682:	bf00      	nop
 8010684:	08017c94 	.word	0x08017c94
 8010688:	08017f84 	.word	0x08017f84
 801068c:	0801660c 	.word	0x0801660c
 8010690:	08017fa4 	.word	0x08017fa4

08010694 <pbuf_take>:
 *
 * @return ERR_OK if successful, ERR_MEM if the pbuf is not big enough
 */
err_t
pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len)
{
 8010694:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  struct pbuf *p;
  u16_t buf_copy_len;
  u16_t total_copy_len = len;
  u16_t copied_total = 0;

  LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return 0;);
 8010698:	4606      	mov	r6, r0
 801069a:	2800      	cmp	r0, #0
 801069c:	d033      	beq.n	8010706 <pbuf_take+0x72>
 801069e:	4688      	mov	r8, r1
  LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return 0;);
 80106a0:	2900      	cmp	r1, #0
 80106a2:	d03a      	beq.n	801071a <pbuf_take+0x86>

  if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
 80106a4:	8903      	ldrh	r3, [r0, #8]
 80106a6:	4691      	mov	r9, r2
 80106a8:	4293      	cmp	r3, r2
 80106aa:	d340      	bcc.n	801072e <pbuf_take+0x9a>
    return ERR_ARG;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; total_copy_len != 0; p = p->next) {
 80106ac:	b342      	cbz	r2, 8010700 <pbuf_take+0x6c>
 80106ae:	4614      	mov	r4, r2
 80106b0:	2700      	movs	r7, #0
 80106b2:	e000      	b.n	80106b6 <pbuf_take+0x22>
    LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
 80106b4:	b1e6      	cbz	r6, 80106f0 <pbuf_take+0x5c>
    buf_copy_len = total_copy_len;
    if (buf_copy_len > p->len) {
 80106b6:	8975      	ldrh	r5, [r6, #10]
      /* this pbuf cannot hold all remaining data */
      buf_copy_len = p->len;
    }
    /* copy the necessary parts of the buffer */
    MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
 80106b8:	eb08 0107 	add.w	r1, r8, r7
 80106bc:	42a5      	cmp	r5, r4
 80106be:	bf28      	it	cs
 80106c0:	4625      	movcs	r5, r4
    total_copy_len -= buf_copy_len;
 80106c2:	1b64      	subs	r4, r4, r5
    if (buf_copy_len > p->len) {
      /* this pbuf cannot hold all remaining data */
      buf_copy_len = p->len;
    }
    /* copy the necessary parts of the buffer */
    MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
 80106c4:	6870      	ldr	r0, [r6, #4]
 80106c6:	462a      	mov	r2, r5
    total_copy_len -= buf_copy_len;
    copied_total += buf_copy_len;
 80106c8:	442f      	add	r7, r5
      /* this pbuf cannot hold all remaining data */
      buf_copy_len = p->len;
    }
    /* copy the necessary parts of the buffer */
    MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
    total_copy_len -= buf_copy_len;
 80106ca:	b2a4      	uxth	r4, r4
    if (buf_copy_len > p->len) {
      /* this pbuf cannot hold all remaining data */
      buf_copy_len = p->len;
    }
    /* copy the necessary parts of the buffer */
    MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
 80106cc:	f004 fb41 	bl	8014d52 <memcpy>
    total_copy_len -= buf_copy_len;
    copied_total += buf_copy_len;
 80106d0:	b2bf      	uxth	r7, r7
  if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
    return ERR_ARG;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; total_copy_len != 0; p = p->next) {
 80106d2:	6836      	ldr	r6, [r6, #0]
 80106d4:	2c00      	cmp	r4, #0
 80106d6:	d1ed      	bne.n	80106b4 <pbuf_take+0x20>
    /* copy the necessary parts of the buffer */
    MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
    total_copy_len -= buf_copy_len;
    copied_total += buf_copy_len;
  }
  LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
 80106d8:	45b9      	cmp	r9, r7
 80106da:	d011      	beq.n	8010700 <pbuf_take+0x6c>
 80106dc:	4b16      	ldr	r3, [pc, #88]	; (8010738 <pbuf_take+0xa4>)
 80106de:	f240 32e1 	movw	r2, #993	; 0x3e1
 80106e2:	4916      	ldr	r1, [pc, #88]	; (801073c <pbuf_take+0xa8>)
 80106e4:	4816      	ldr	r0, [pc, #88]	; (8010740 <pbuf_take+0xac>)
 80106e6:	f004 fb47 	bl	8014d78 <iprintf>
  return ERR_OK;
 80106ea:	4620      	mov	r0, r4
 80106ec:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    return ERR_ARG;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; total_copy_len != 0; p = p->next) {
    LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
 80106f0:	4b11      	ldr	r3, [pc, #68]	; (8010738 <pbuf_take+0xa4>)
 80106f2:	f240 32d6 	movw	r2, #982	; 0x3d6
 80106f6:	4913      	ldr	r1, [pc, #76]	; (8010744 <pbuf_take+0xb0>)
 80106f8:	4811      	ldr	r0, [pc, #68]	; (8010740 <pbuf_take+0xac>)
 80106fa:	f004 fb3d 	bl	8014d78 <iprintf>
 80106fe:	e7da      	b.n	80106b6 <pbuf_take+0x22>
    MEMCPY(p->payload, &((char*)dataptr)[copied_total], buf_copy_len);
    total_copy_len -= buf_copy_len;
    copied_total += buf_copy_len;
  }
  LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
  return ERR_OK;
 8010700:	2000      	movs	r0, #0
 8010702:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  struct pbuf *p;
  u16_t buf_copy_len;
  u16_t total_copy_len = len;
  u16_t copied_total = 0;

  LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return 0;);
 8010706:	4b0c      	ldr	r3, [pc, #48]	; (8010738 <pbuf_take+0xa4>)
 8010708:	f240 32cd 	movw	r2, #973	; 0x3cd
 801070c:	490e      	ldr	r1, [pc, #56]	; (8010748 <pbuf_take+0xb4>)
 801070e:	480c      	ldr	r0, [pc, #48]	; (8010740 <pbuf_take+0xac>)
 8010710:	f004 fb32 	bl	8014d78 <iprintf>
 8010714:	4630      	mov	r0, r6
 8010716:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return 0;);
 801071a:	4b07      	ldr	r3, [pc, #28]	; (8010738 <pbuf_take+0xa4>)
 801071c:	f240 32ce 	movw	r2, #974	; 0x3ce
 8010720:	490a      	ldr	r1, [pc, #40]	; (801074c <pbuf_take+0xb8>)
 8010722:	4807      	ldr	r0, [pc, #28]	; (8010740 <pbuf_take+0xac>)
 8010724:	f004 fb28 	bl	8014d78 <iprintf>
 8010728:	4640      	mov	r0, r8
 801072a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

  if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
    return ERR_ARG;
 801072e:	f06f 000d 	mvn.w	r0, #13
    total_copy_len -= buf_copy_len;
    copied_total += buf_copy_len;
  }
  LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
  return ERR_OK;
}
 8010732:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8010736:	bf00      	nop
 8010738:	08017c94 	.word	0x08017c94
 801073c:	08018014 	.word	0x08018014
 8010740:	0801660c 	.word	0x0801660c
 8010744:	08017ffc 	.word	0x08017ffc
 8010748:	08017fc8 	.word	0x08017fc8
 801074c:	08017fe0 	.word	0x08017fe0

08010750 <pbuf_coalesce>:
 * @return a new, single pbuf (p->next is NULL)
 *         or the old pbuf if allocation fails
 */
struct pbuf*
pbuf_coalesce(struct pbuf *p, pbuf_layer layer)
{
 8010750:	b538      	push	{r3, r4, r5, lr}
  struct pbuf *q;
  err_t err;
  if (p->next == NULL) {
 8010752:	6803      	ldr	r3, [r0, #0]
 * @return a new, single pbuf (p->next is NULL)
 *         or the old pbuf if allocation fails
 */
struct pbuf*
pbuf_coalesce(struct pbuf *p, pbuf_layer layer)
{
 8010754:	4604      	mov	r4, r0
  struct pbuf *q;
  err_t err;
  if (p->next == NULL) {
 8010756:	b17b      	cbz	r3, 8010778 <pbuf_coalesce+0x28>
    return p;
  }
  q = pbuf_alloc(layer, p->tot_len, PBUF_RAM);
 8010758:	4608      	mov	r0, r1
 801075a:	2200      	movs	r2, #0
 801075c:	8921      	ldrh	r1, [r4, #8]
 801075e:	f7ff fcbb 	bl	80100d8 <pbuf_alloc>
  if (q == NULL) {
 8010762:	4605      	mov	r5, r0
 8010764:	b140      	cbz	r0, 8010778 <pbuf_coalesce+0x28>
    /* @todo: what do we do now? */
    return p;
  }
  err = pbuf_copy(q, p);
 8010766:	4621      	mov	r1, r4
 8010768:	f7ff fea0 	bl	80104ac <pbuf_copy>
  LWIP_ASSERT("pbuf_copy failed", err == ERR_OK);
 801076c:	b930      	cbnz	r0, 801077c <pbuf_coalesce+0x2c>
  pbuf_free(p);
 801076e:	4620      	mov	r0, r4
 8010770:	f7ff fc5a 	bl	8010028 <pbuf_free>
  return q;
 8010774:	4628      	mov	r0, r5
}
 8010776:	bd38      	pop	{r3, r4, r5, pc}
 * @return a new, single pbuf (p->next is NULL)
 *         or the old pbuf if allocation fails
 */
struct pbuf*
pbuf_coalesce(struct pbuf *p, pbuf_layer layer)
{
 8010778:	4620      	mov	r0, r4
 801077a:	bd38      	pop	{r3, r4, r5, pc}
  if (q == NULL) {
    /* @todo: what do we do now? */
    return p;
  }
  err = pbuf_copy(q, p);
  LWIP_ASSERT("pbuf_copy failed", err == ERR_OK);
 801077c:	4b05      	ldr	r3, [pc, #20]	; (8010794 <pbuf_coalesce+0x44>)
 801077e:	f240 32ff 	movw	r2, #1023	; 0x3ff
 8010782:	4905      	ldr	r1, [pc, #20]	; (8010798 <pbuf_coalesce+0x48>)
 8010784:	4805      	ldr	r0, [pc, #20]	; (801079c <pbuf_coalesce+0x4c>)
 8010786:	f004 faf7 	bl	8014d78 <iprintf>
  pbuf_free(p);
 801078a:	4620      	mov	r0, r4
 801078c:	f7ff fc4c 	bl	8010028 <pbuf_free>
  return q;
 8010790:	4628      	mov	r0, r5
}
 8010792:	bd38      	pop	{r3, r4, r5, pc}
 8010794:	08017c94 	.word	0x08017c94
 8010798:	0801802c 	.word	0x0801802c
 801079c:	0801660c 	.word	0x0801660c

080107a0 <pbuf_get_at>:
{
  u16_t copy_from = offset;
  struct pbuf* q = p;

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= copy_from)) {
 80107a0:	b158      	cbz	r0, 80107ba <pbuf_get_at+0x1a>
 80107a2:	8943      	ldrh	r3, [r0, #10]
 80107a4:	4299      	cmp	r1, r3
 80107a6:	d203      	bcs.n	80107b0 <pbuf_get_at+0x10>
 80107a8:	e008      	b.n	80107bc <pbuf_get_at+0x1c>
 80107aa:	8943      	ldrh	r3, [r0, #10]
 80107ac:	428b      	cmp	r3, r1
 80107ae:	d805      	bhi.n	80107bc <pbuf_get_at+0x1c>
    copy_from -= q->len;
    q = q->next;
 80107b0:	6800      	ldr	r0, [r0, #0]
  u16_t copy_from = offset;
  struct pbuf* q = p;

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= copy_from)) {
    copy_from -= q->len;
 80107b2:	1ac9      	subs	r1, r1, r3
 80107b4:	b289      	uxth	r1, r1
{
  u16_t copy_from = offset;
  struct pbuf* q = p;

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= copy_from)) {
 80107b6:	2800      	cmp	r0, #0
 80107b8:	d1f7      	bne.n	80107aa <pbuf_get_at+0xa>
  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->len > copy_from)) {
    return ((u8_t*)q->payload)[copy_from];
  }
  return 0;
}
 80107ba:	4770      	bx	lr
    copy_from -= q->len;
    q = q->next;
  }
  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->len > copy_from)) {
    return ((u8_t*)q->payload)[copy_from];
 80107bc:	6843      	ldr	r3, [r0, #4]
 80107be:	5c58      	ldrb	r0, [r3, r1]
  }
  return 0;
}
 80107c0:	4770      	bx	lr
 80107c2:	bf00      	nop

080107c4 <pbuf_memcmp>:
{
  u16_t start = offset;
  struct pbuf* q = p;

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= start)) {
 80107c4:	2800      	cmp	r0, #0
 80107c6:	d033      	beq.n	8010830 <pbuf_memcmp+0x6c>
 * @return zero if equal, nonzero otherwise
 *         (0xffff if p is too short, diffoffset+1 otherwise)
 */
u16_t
pbuf_memcmp(struct pbuf* p, u16_t offset, const void* s2, u16_t n)
{
 80107c8:	b5f0      	push	{r4, r5, r6, r7, lr}
  u16_t start = offset;
  struct pbuf* q = p;

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= start)) {
 80107ca:	8944      	ldrh	r4, [r0, #10]
 80107cc:	42a1      	cmp	r1, r4
 80107ce:	d203      	bcs.n	80107d8 <pbuf_memcmp+0x14>
 80107d0:	e00a      	b.n	80107e8 <pbuf_memcmp+0x24>
 80107d2:	8944      	ldrh	r4, [r0, #10]
 80107d4:	428c      	cmp	r4, r1
 80107d6:	d807      	bhi.n	80107e8 <pbuf_memcmp+0x24>
    start -= q->len;
    q = q->next;
 80107d8:	6800      	ldr	r0, [r0, #0]
  u16_t start = offset;
  struct pbuf* q = p;

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= start)) {
    start -= q->len;
 80107da:	1b0c      	subs	r4, r1, r4
 80107dc:	b2a1      	uxth	r1, r4
{
  u16_t start = offset;
  struct pbuf* q = p;

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= start)) {
 80107de:	2800      	cmp	r0, #0
 80107e0:	d1f7      	bne.n	80107d2 <pbuf_memcmp+0xe>
        return i+1;
      }
    }
    return 0;
  }
  return 0xffff;
 80107e2:	f64f 70ff 	movw	r0, #65535	; 0xffff
 80107e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
    q = q->next;
  }
  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->len > start)) {
    u16_t i;
    for(i = 0; i < n; i++) {
 80107e8:	b32b      	cbz	r3, 8010836 <pbuf_memcmp+0x72>
 80107ea:	2700      	movs	r7, #0
 80107ec:	463e      	mov	r6, r7
 80107ee:	f102 3eff 	add.w	lr, r2, #4294967295
 80107f2:	4604      	mov	r4, r0
 80107f4:	198d      	adds	r5, r1, r6
 80107f6:	b2ad      	uxth	r5, r5
{
  u16_t copy_from = offset;
  struct pbuf* q = p;

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= copy_from)) {
 80107f8:	8962      	ldrh	r2, [r4, #10]
 80107fa:	42aa      	cmp	r2, r5
    copy_from -= q->len;
 80107fc:	eba5 0202 	sub.w	r2, r5, r2
{
  u16_t copy_from = offset;
  struct pbuf* q = p;

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= copy_from)) {
 8010800:	d80d      	bhi.n	801081e <pbuf_memcmp+0x5a>
    copy_from -= q->len;
    q = q->next;
 8010802:	6824      	ldr	r4, [r4, #0]
  u16_t copy_from = offset;
  struct pbuf* q = p;

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= copy_from)) {
    copy_from -= q->len;
 8010804:	b295      	uxth	r5, r2
{
  u16_t copy_from = offset;
  struct pbuf* q = p;

  /* get the correct pbuf */
  while ((q != NULL) && (q->len <= copy_from)) {
 8010806:	2c00      	cmp	r4, #0
 8010808:	d1f6      	bne.n	80107f8 <pbuf_memcmp+0x34>
  if ((q != NULL) && (q->len > start)) {
    u16_t i;
    for(i = 0; i < n; i++) {
      u8_t a = pbuf_get_at(q, start + i);
      u8_t b = ((u8_t*)s2)[i];
      if (a != b) {
 801080a:	f81e 2f01 	ldrb.w	r2, [lr, #1]!
 801080e:	42a2      	cmp	r2, r4
 8010810:	d10b      	bne.n	801082a <pbuf_memcmp+0x66>
 8010812:	3701      	adds	r7, #1
    q = q->next;
  }
  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->len > start)) {
    u16_t i;
    for(i = 0; i < n; i++) {
 8010814:	b2be      	uxth	r6, r7
 8010816:	429e      	cmp	r6, r3
 8010818:	d3eb      	bcc.n	80107f2 <pbuf_memcmp+0x2e>
      u8_t b = ((u8_t*)s2)[i];
      if (a != b) {
        return i+1;
      }
    }
    return 0;
 801081a:	2000      	movs	r0, #0
 801081c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    copy_from -= q->len;
    q = q->next;
  }
  /* return requested data if pbuf is OK */
  if ((q != NULL) && (q->len > copy_from)) {
    return ((u8_t*)q->payload)[copy_from];
 801081e:	6862      	ldr	r2, [r4, #4]
 8010820:	5d54      	ldrb	r4, [r2, r5]
  if ((q != NULL) && (q->len > start)) {
    u16_t i;
    for(i = 0; i < n; i++) {
      u8_t a = pbuf_get_at(q, start + i);
      u8_t b = ((u8_t*)s2)[i];
      if (a != b) {
 8010822:	f81e 2f01 	ldrb.w	r2, [lr, #1]!
 8010826:	42a2      	cmp	r2, r4
 8010828:	d0f3      	beq.n	8010812 <pbuf_memcmp+0x4e>
        return i+1;
 801082a:	3601      	adds	r6, #1
 801082c:	b2b0      	uxth	r0, r6
 801082e:	bdf0      	pop	{r4, r5, r6, r7, pc}
      }
    }
    return 0;
  }
  return 0xffff;
 8010830:	f64f 70ff 	movw	r0, #65535	; 0xffff
}
 8010834:	4770      	bx	lr
      u8_t b = ((u8_t*)s2)[i];
      if (a != b) {
        return i+1;
      }
    }
    return 0;
 8010836:	4618      	mov	r0, r3
 8010838:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801083a:	bf00      	nop

0801083c <pbuf_memfind>:
 * @param start_offset offset into p at which to start searching
 * @return 0xFFFF if substr was not found in p or the index where it was found
 */
u16_t
pbuf_memfind(struct pbuf* p, const void* mem, u16_t mem_len, u16_t start_offset)
{
 801083c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  u16_t i;
  u16_t max = p->tot_len - mem_len;
 8010840:	8905      	ldrh	r5, [r0, #8]
 * @param start_offset offset into p at which to start searching
 * @return 0xFFFF if substr was not found in p or the index where it was found
 */
u16_t
pbuf_memfind(struct pbuf* p, const void* mem, u16_t mem_len, u16_t start_offset)
{
 8010842:	461c      	mov	r4, r3
  u16_t i;
  u16_t max = p->tot_len - mem_len;
  if (p->tot_len >= mem_len + start_offset) {
 8010844:	18d3      	adds	r3, r2, r3
 8010846:	429d      	cmp	r5, r3
 8010848:	da03      	bge.n	8010852 <pbuf_memfind+0x16>
      } else {
        i += plus;
      }
    }
  }
  return 0xFFFF;
 801084a:	f64f 70ff 	movw	r0, #65535	; 0xffff
 801084e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 */
u16_t
pbuf_memfind(struct pbuf* p, const void* mem, u16_t mem_len, u16_t start_offset)
{
  u16_t i;
  u16_t max = p->tot_len - mem_len;
 8010852:	1aad      	subs	r5, r5, r2
 8010854:	b2ad      	uxth	r5, r5
  if (p->tot_len >= mem_len + start_offset) {
    for(i = start_offset; i <= max; ) {
 8010856:	42a5      	cmp	r5, r4
 8010858:	4607      	mov	r7, r0
 801085a:	4616      	mov	r6, r2
 801085c:	4688      	mov	r8, r1
 801085e:	d203      	bcs.n	8010868 <pbuf_memfind+0x2c>
 8010860:	e7f3      	b.n	801084a <pbuf_memfind+0xe>
      u16_t plus = pbuf_memcmp(p, i, mem, mem_len);
      if (plus == 0) {
        return i;
      } else {
        i += plus;
 8010862:	b29c      	uxth	r4, r3
pbuf_memfind(struct pbuf* p, const void* mem, u16_t mem_len, u16_t start_offset)
{
  u16_t i;
  u16_t max = p->tot_len - mem_len;
  if (p->tot_len >= mem_len + start_offset) {
    for(i = start_offset; i <= max; ) {
 8010864:	42a5      	cmp	r5, r4
 8010866:	d3f0      	bcc.n	801084a <pbuf_memfind+0xe>
      u16_t plus = pbuf_memcmp(p, i, mem, mem_len);
 8010868:	4633      	mov	r3, r6
 801086a:	4642      	mov	r2, r8
 801086c:	4621      	mov	r1, r4
 801086e:	4638      	mov	r0, r7
 8010870:	f7ff ffa8 	bl	80107c4 <pbuf_memcmp>
      if (plus == 0) {
        return i;
      } else {
        i += plus;
 8010874:	1903      	adds	r3, r0, r4
  u16_t i;
  u16_t max = p->tot_len - mem_len;
  if (p->tot_len >= mem_len + start_offset) {
    for(i = start_offset; i <= max; ) {
      u16_t plus = pbuf_memcmp(p, i, mem, mem_len);
      if (plus == 0) {
 8010876:	2800      	cmp	r0, #0
 8010878:	d1f3      	bne.n	8010862 <pbuf_memfind+0x26>
 801087a:	4620      	mov	r0, r4
        i += plus;
      }
    }
  }
  return 0xFFFF;
}
 801087c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08010880 <pbuf_strstr>:
 */
u16_t
pbuf_strstr(struct pbuf* p, const char* substr)
{
  size_t substr_len;
  if ((substr == NULL) || (substr[0] == 0) || (p->tot_len == 0xFFFF)) {
 8010880:	b109      	cbz	r1, 8010886 <pbuf_strstr+0x6>
 8010882:	780b      	ldrb	r3, [r1, #0]
 8010884:	b913      	cbnz	r3, 801088c <pbuf_strstr+0xc>
  substr_len = strlen(substr);
  if (substr_len >= 0xFFFF) {
    return 0xFFFF;
  }
  return pbuf_memfind(p, substr, (u16_t)substr_len, 0);
}
 8010886:	f64f 70ff 	movw	r0, #65535	; 0xffff
 801088a:	4770      	bx	lr
 */
u16_t
pbuf_strstr(struct pbuf* p, const char* substr)
{
  size_t substr_len;
  if ((substr == NULL) || (substr[0] == 0) || (p->tot_len == 0xFFFF)) {
 801088c:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8010890:	8902      	ldrh	r2, [r0, #8]
 8010892:	429a      	cmp	r2, r3
 8010894:	d0f7      	beq.n	8010886 <pbuf_strstr+0x6>
 * @param substr string to search for in p, maximum length is 0xFFFE
 * @return 0xFFFF if substr was not found in p or the index where it was found
 */
u16_t
pbuf_strstr(struct pbuf* p, const char* substr)
{
 8010896:	b570      	push	{r4, r5, r6, lr}
 8010898:	4605      	mov	r5, r0
  size_t substr_len;
  if ((substr == NULL) || (substr[0] == 0) || (p->tot_len == 0xFFFF)) {
    return 0xFFFF;
  }
  substr_len = strlen(substr);
 801089a:	4608      	mov	r0, r1
 801089c:	460c      	mov	r4, r1
 801089e:	f004 f9b3 	bl	8014c08 <strlen>
  if (substr_len >= 0xFFFF) {
 80108a2:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 80108a6:	4298      	cmp	r0, r3
 80108a8:	d902      	bls.n	80108b0 <pbuf_strstr+0x30>
    return 0xFFFF;
  }
  return pbuf_memfind(p, substr, (u16_t)substr_len, 0);
}
 80108aa:	f64f 70ff 	movw	r0, #65535	; 0xffff
 80108ae:	bd70      	pop	{r4, r5, r6, pc}
  }
  substr_len = strlen(substr);
  if (substr_len >= 0xFFFF) {
    return 0xFFFF;
  }
  return pbuf_memfind(p, substr, (u16_t)substr_len, 0);
 80108b0:	b282      	uxth	r2, r0
 80108b2:	4621      	mov	r1, r4
 80108b4:	4628      	mov	r0, r5
}
 80108b6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  }
  substr_len = strlen(substr);
  if (substr_len >= 0xFFFF) {
    return 0xFFFF;
  }
  return pbuf_memfind(p, substr, (u16_t)substr_len, 0);
 80108ba:	2300      	movs	r3, #0
 80108bc:	f7ff bfbe 	b.w	801083c <pbuf_memfind>

080108c0 <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
 80108c0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

  iphdr = (struct ip_hdr *)p->payload;
  proto = IPH_PROTO(iphdr);

  prev = NULL;
  pcb = raw_pcbs;
 80108c4:	f8df 8068 	ldr.w	r8, [pc, #104]	; 8010930 <raw_input+0x70>
  u8_t eaten = 0;

  LWIP_UNUSED_ARG(inp);

  iphdr = (struct ip_hdr *)p->payload;
  proto = IPH_PROTO(iphdr);
 80108c8:	6843      	ldr	r3, [r0, #4]

  prev = NULL;
  pcb = raw_pcbs;
 80108ca:	f8d8 4000 	ldr.w	r4, [r8]
  u8_t eaten = 0;

  LWIP_UNUSED_ARG(inp);

  iphdr = (struct ip_hdr *)p->payload;
  proto = IPH_PROTO(iphdr);
 80108ce:	7a5e      	ldrb	r6, [r3, #9]

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
 80108d0:	b344      	cbz	r4, 8010924 <raw_input+0x64>
 80108d2:	4607      	mov	r7, r0
 80108d4:	2500      	movs	r5, #0
    if ((pcb->protocol == proto) &&
        (ip_addr_isany(&pcb->local_ip) ||
         ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest))) {
 80108d6:	f8df 905c 	ldr.w	r9, [pc, #92]	; 8010934 <raw_input+0x74>
 80108da:	e003      	b.n	80108e4 <raw_input+0x24>
        /* no receive callback function was set for this raw PCB */
      }
      /* drop the packet */
    }
    prev = pcb;
    pcb = pcb->next;
 80108dc:	68e3      	ldr	r3, [r4, #12]
 80108de:	4625      	mov	r5, r4

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
 80108e0:	b303      	cbz	r3, 8010924 <raw_input+0x64>
 80108e2:	461c      	mov	r4, r3
    if ((pcb->protocol == proto) &&
 80108e4:	7c23      	ldrb	r3, [r4, #16]
 80108e6:	42b3      	cmp	r3, r6
 80108e8:	d1f8      	bne.n	80108dc <raw_input+0x1c>
        (ip_addr_isany(&pcb->local_ip) ||
 80108ea:	6822      	ldr	r2, [r4, #0]
#endif /* IP_SOF_BROADCAST_RECV */
      {
        /* receive callback function available? */
        if (pcb->recv != NULL) {
          /* the receive callback function did not eat the packet? */
          if (pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr()) != 0) {
 80108ec:	4b0f      	ldr	r3, [pc, #60]	; (801092c <raw_input+0x6c>)
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    if ((pcb->protocol == proto) &&
        (ip_addr_isany(&pcb->local_ip) ||
 80108ee:	b11a      	cbz	r2, 80108f8 <raw_input+0x38>
 80108f0:	f8d9 1000 	ldr.w	r1, [r9]
 80108f4:	428a      	cmp	r2, r1
 80108f6:	d1f1      	bne.n	80108dc <raw_input+0x1c>
      /* broadcast filter? */
      if (ip_get_option(pcb, SOF_BROADCAST) || !ip_addr_isbroadcast(&current_iphdr_dest, inp))
#endif /* IP_SOF_BROADCAST_RECV */
      {
        /* receive callback function available? */
        if (pcb->recv != NULL) {
 80108f8:	f8d4 a014 	ldr.w	sl, [r4, #20]
 80108fc:	f1ba 0f00 	cmp.w	sl, #0
 8010900:	d0ec      	beq.n	80108dc <raw_input+0x1c>
          /* the receive callback function did not eat the packet? */
          if (pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr()) != 0) {
 8010902:	463a      	mov	r2, r7
 8010904:	4621      	mov	r1, r4
 8010906:	69a0      	ldr	r0, [r4, #24]
 8010908:	47d0      	blx	sl
 801090a:	2800      	cmp	r0, #0
 801090c:	d0e6      	beq.n	80108dc <raw_input+0x1c>
            /* receive function ate the packet */
            p = NULL;
            eaten = 1;
            if (prev != NULL) {
 801090e:	b135      	cbz	r5, 801091e <raw_input+0x5e>
            /* move the pcb to the front of raw_pcbs so that is
               found faster next time */
              prev->next = pcb->next;
 8010910:	68e2      	ldr	r2, [r4, #12]
              pcb->next = raw_pcbs;
 8010912:	f8d8 3000 	ldr.w	r3, [r8]
            p = NULL;
            eaten = 1;
            if (prev != NULL) {
            /* move the pcb to the front of raw_pcbs so that is
               found faster next time */
              prev->next = pcb->next;
 8010916:	60ea      	str	r2, [r5, #12]
              pcb->next = raw_pcbs;
              raw_pcbs = pcb;
 8010918:	f8c8 4000 	str.w	r4, [r8]
            eaten = 1;
            if (prev != NULL) {
            /* move the pcb to the front of raw_pcbs so that is
               found faster next time */
              prev->next = pcb->next;
              pcb->next = raw_pcbs;
 801091c:	60e3      	str	r3, [r4, #12]
 801091e:	2001      	movs	r0, #1
    }
    prev = pcb;
    pcb = pcb->next;
  }
  return eaten;
}
 8010920:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8010924:	2000      	movs	r0, #0
 8010926:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801092a:	bf00      	nop
 801092c:	2000f09c 	.word	0x2000f09c
 8010930:	20004c3c 	.word	0x20004c3c
 8010934:	2000f0a4 	.word	0x2000f0a4

08010938 <raw_bind>:
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, ip_addr_t *ipaddr)
{
  ip_addr_set(&pcb->local_ip, ipaddr);
 8010938:	b101      	cbz	r1, 801093c <raw_bind+0x4>
 801093a:	6809      	ldr	r1, [r1, #0]
 801093c:	6001      	str	r1, [r0, #0]
  return ERR_OK;
}
 801093e:	2000      	movs	r0, #0
 8010940:	4770      	bx	lr
 8010942:	bf00      	nop

08010944 <raw_connect>:
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, ip_addr_t *ipaddr)
{
  ip_addr_set(&pcb->remote_ip, ipaddr);
 8010944:	b101      	cbz	r1, 8010948 <raw_connect+0x4>
 8010946:	6809      	ldr	r1, [r1, #0]
 8010948:	6041      	str	r1, [r0, #4]
  return ERR_OK;
}
 801094a:	2000      	movs	r0, #0
 801094c:	4770      	bx	lr
 801094e:	bf00      	nop

08010950 <raw_recv>:
 */
void
raw_recv(struct raw_pcb *pcb, raw_recv_fn recv, void *recv_arg)
{
  /* remember recv() callback and user data */
  pcb->recv = recv;
 8010950:	6141      	str	r1, [r0, #20]
  pcb->recv_arg = recv_arg;
 8010952:	6182      	str	r2, [r0, #24]
 8010954:	4770      	bx	lr
 8010956:	bf00      	nop

08010958 <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, ip_addr_t *ipaddr)
{
 8010958:	b5f0      	push	{r4, r5, r6, r7, lr}
 801095a:	460d      	mov	r5, r1
 801095c:	b085      	sub	sp, #20
 801095e:	4604      	mov	r4, r0
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
 8010960:	2114      	movs	r1, #20
 8010962:	4628      	mov	r0, r5
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, ip_addr_t *ipaddr)
{
 8010964:	4617      	mov	r7, r2
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
 8010966:	f7ff fb07 	bl	800ff78 <pbuf_header>
 801096a:	b330      	cbz	r0, 80109ba <raw_sendto+0x62>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
 801096c:	2200      	movs	r2, #0
 801096e:	4611      	mov	r1, r2
 8010970:	2001      	movs	r0, #1
 8010972:	f7ff fbb1 	bl	80100d8 <pbuf_alloc>
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
 8010976:	4606      	mov	r6, r0
 8010978:	2800      	cmp	r0, #0
 801097a:	d040      	beq.n	80109fe <raw_sendto+0xa6>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
    }
    if (p->tot_len != 0) {
 801097c:	892b      	ldrh	r3, [r5, #8]
 801097e:	bb8b      	cbnz	r3, 80109e4 <raw_sendto+0x8c>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
      return ERR_MEM;
    }
  }

  if ((netif = ip_route(ipaddr)) == NULL) {
 8010980:	4638      	mov	r0, r7
 8010982:	f7fe f825 	bl	800e9d0 <ip_route>
 8010986:	b320      	cbz	r0, 80109d2 <raw_sendto+0x7a>
    }
    return ERR_VAL;
  }
#endif /* IP_SOF_BROADCAST */

  if (ip_addr_isany(&pcb->local_ip)) {
 8010988:	4621      	mov	r1, r4
 801098a:	b10c      	cbz	r4, 8010990 <raw_sendto+0x38>
 801098c:	6823      	ldr	r3, [r4, #0]
 801098e:	b903      	cbnz	r3, 8010992 <raw_sendto+0x3a>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
 8010990:	1d01      	adds	r1, r0, #4
    /* use RAW PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
  }

  NETIF_SET_HWADDRHINT(netif, &pcb->addr_hint);
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
 8010992:	7aa3      	ldrb	r3, [r4, #10]
 8010994:	f894 e010 	ldrb.w	lr, [r4, #16]
 8010998:	7a64      	ldrb	r4, [r4, #9]
 801099a:	463a      	mov	r2, r7
 801099c:	9002      	str	r0, [sp, #8]
 801099e:	e88d 4010 	stmia.w	sp, {r4, lr}
 80109a2:	4630      	mov	r0, r6
 80109a4:	f7fe f8e4 	bl	800eb70 <ip_output_if>
  NETIF_SET_HWADDRHINT(netif, NULL);

  /* did we chain a header earlier? */
  if (q != p) {
 80109a8:	42b5      	cmp	r5, r6
    /* use RAW PCB local IP address as source address */
    src_ip = &(pcb->local_ip);
  }

  NETIF_SET_HWADDRHINT(netif, &pcb->addr_hint);
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
 80109aa:	4604      	mov	r4, r0
  NETIF_SET_HWADDRHINT(netif, NULL);

  /* did we chain a header earlier? */
  if (q != p) {
 80109ac:	d003      	beq.n	80109b6 <raw_sendto+0x5e>
    /* free the header */
    pbuf_free(q);
 80109ae:	4630      	mov	r0, r6
 80109b0:	f7ff fb3a 	bl	8010028 <pbuf_free>
  }
  return err;
 80109b4:	4620      	mov	r0, r4
}
 80109b6:	b005      	add	sp, #20
 80109b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
    if(pbuf_header(q, -IP_HLEN)) {
 80109ba:	f06f 0113 	mvn.w	r1, #19
 80109be:	4628      	mov	r0, r5
 80109c0:	f7ff fada 	bl	800ff78 <pbuf_header>
 80109c4:	b990      	cbnz	r0, 80109ec <raw_sendto+0x94>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
      return ERR_MEM;
    }
  }

  if ((netif = ip_route(ipaddr)) == NULL) {
 80109c6:	4638      	mov	r0, r7
 80109c8:	f7fe f802 	bl	800e9d0 <ip_route>
 80109cc:	b130      	cbz	r0, 80109dc <raw_sendto+0x84>
 80109ce:	462e      	mov	r6, r5
 80109d0:	e7da      	b.n	8010988 <raw_sendto+0x30>
    LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_LEVEL_WARNING, ("raw_sendto: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(ipaddr), ip4_addr2_16(ipaddr), ip4_addr3_16(ipaddr), ip4_addr4_16(ipaddr)));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
 80109d2:	42b5      	cmp	r5, r6
 80109d4:	d002      	beq.n	80109dc <raw_sendto+0x84>
      pbuf_free(q);
 80109d6:	4630      	mov	r0, r6
 80109d8:	f7ff fb26 	bl	8010028 <pbuf_free>
    }
    return ERR_RTE;
 80109dc:	f06f 0003 	mvn.w	r0, #3
  if (q != p) {
    /* free the header */
    pbuf_free(q);
  }
  return err;
}
 80109e0:	b005      	add	sp, #20
 80109e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
    }
    if (p->tot_len != 0) {
      /* chain header q in front of given pbuf p */
      pbuf_chain(q, p);
 80109e4:	4629      	mov	r1, r5
 80109e6:	f7ff fd1d 	bl	8010424 <pbuf_chain>
 80109ea:	e7c9      	b.n	8010980 <raw_sendto+0x28>
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
    if(pbuf_header(q, -IP_HLEN)) {
      LWIP_ASSERT("Can't restore header we just removed!", 0);
 80109ec:	4b05      	ldr	r3, [pc, #20]	; (8010a04 <raw_sendto+0xac>)
 80109ee:	22e7      	movs	r2, #231	; 0xe7
 80109f0:	4905      	ldr	r1, [pc, #20]	; (8010a08 <raw_sendto+0xb0>)
 80109f2:	4806      	ldr	r0, [pc, #24]	; (8010a0c <raw_sendto+0xb4>)
 80109f4:	f004 f9c0 	bl	8014d78 <iprintf>
      return ERR_MEM;
 80109f8:	f04f 30ff 	mov.w	r0, #4294967295
 80109fc:	e7db      	b.n	80109b6 <raw_sendto+0x5e>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
 80109fe:	f04f 30ff 	mov.w	r0, #4294967295
 8010a02:	e7d8      	b.n	80109b6 <raw_sendto+0x5e>
 8010a04:	08018040 	.word	0x08018040
 8010a08:	08018050 	.word	0x08018050
 8010a0c:	0801660c 	.word	0x0801660c

08010a10 <raw_send>:
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
  return raw_sendto(pcb, p, &pcb->remote_ip);
 8010a10:	1d02      	adds	r2, r0, #4
 8010a12:	f7ff bfa1 	b.w	8010958 <raw_sendto>
 8010a16:	bf00      	nop

08010a18 <raw_remove>:
void
raw_remove(struct raw_pcb *pcb)
{
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
 8010a18:	4b0d      	ldr	r3, [pc, #52]	; (8010a50 <raw_remove+0x38>)
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
 8010a1a:	4601      	mov	r1, r0
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
 8010a1c:	681a      	ldr	r2, [r3, #0]
 8010a1e:	4282      	cmp	r2, r0
 8010a20:	d011      	beq.n	8010a46 <raw_remove+0x2e>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 8010a22:	b13a      	cbz	r2, 8010a34 <raw_remove+0x1c>
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
 8010a24:	68d3      	ldr	r3, [r2, #12]
 8010a26:	b12b      	cbz	r3, 8010a34 <raw_remove+0x1c>
 8010a28:	4299      	cmp	r1, r3
 8010a2a:	d006      	beq.n	8010a3a <raw_remove+0x22>
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
 8010a2c:	461a      	mov	r2, r3
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
 8010a2e:	68d3      	ldr	r3, [r2, #12]
 8010a30:	2b00      	cmp	r3, #0
 8010a32:	d1f9      	bne.n	8010a28 <raw_remove+0x10>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
 8010a34:	2000      	movs	r0, #0
 8010a36:	f7ff b961 	b.w	800fcfc <memp_free>
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
 8010a3a:	68cb      	ldr	r3, [r1, #12]
 8010a3c:	60d3      	str	r3, [r2, #12]
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 8010a3e:	2b00      	cmp	r3, #0
 8010a40:	d0f8      	beq.n	8010a34 <raw_remove+0x1c>
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
 8010a42:	461a      	mov	r2, r3
 8010a44:	e7f3      	b.n	8010a2e <raw_remove+0x16>
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
 8010a46:	68c2      	ldr	r2, [r0, #12]
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
 8010a48:	2000      	movs	r0, #0
{
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
 8010a4a:	601a      	str	r2, [r3, #0]
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
 8010a4c:	f7ff b956 	b.w	800fcfc <memp_free>
 8010a50:	20004c3c 	.word	0x20004c3c

08010a54 <raw_new>:
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto)
{
 8010a54:	b538      	push	{r3, r4, r5, lr}
 8010a56:	4605      	mov	r5, r0
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE, ("raw_new\n"));

  pcb = (struct raw_pcb *)memp_malloc(MEMP_RAW_PCB);
 8010a58:	2000      	movs	r0, #0
 8010a5a:	f7ff f919 	bl	800fc90 <memp_malloc>
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
 8010a5e:	4604      	mov	r4, r0
 8010a60:	b150      	cbz	r0, 8010a78 <raw_new+0x24>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
 8010a62:	221c      	movs	r2, #28
 8010a64:	2100      	movs	r1, #0
 8010a66:	f004 f97f 	bl	8014d68 <memset>
    pcb->protocol = proto;
    pcb->ttl = RAW_TTL;
    pcb->next = raw_pcbs;
 8010a6a:	4b04      	ldr	r3, [pc, #16]	; (8010a7c <raw_new+0x28>)
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
    pcb->protocol = proto;
    pcb->ttl = RAW_TTL;
 8010a6c:	22ff      	movs	r2, #255	; 0xff
    pcb->next = raw_pcbs;
 8010a6e:	6819      	ldr	r1, [r3, #0]
  pcb = (struct raw_pcb *)memp_malloc(MEMP_RAW_PCB);
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
    pcb->protocol = proto;
 8010a70:	7425      	strb	r5, [r4, #16]
    pcb->ttl = RAW_TTL;
    pcb->next = raw_pcbs;
 8010a72:	60e1      	str	r1, [r4, #12]
    raw_pcbs = pcb;
 8010a74:	601c      	str	r4, [r3, #0]
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
    pcb->protocol = proto;
    pcb->ttl = RAW_TTL;
 8010a76:	72a2      	strb	r2, [r4, #10]
    pcb->next = raw_pcbs;
    raw_pcbs = pcb;
  }
  return pcb;
}
 8010a78:	4620      	mov	r0, r4
 8010a7a:	bd38      	pop	{r3, r4, r5, pc}
 8010a7c:	20004c3c 	.word	0x20004c3c

08010a80 <lwip_getaddrname>:
static struct lwip_sock *
get_socket(int s)
{
  struct lwip_sock *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
 8010a80:	2803      	cmp	r0, #3
 8010a82:	d83d      	bhi.n	8010b00 <lwip_getaddrname+0x80>
  return (err == ERR_OK ? 0 : -1);
}

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
 8010a84:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    return NULL;
  }

  sock = &sockets[s];

  if (!sock->conn) {
 8010a88:	ea4f 0a40 	mov.w	sl, r0, lsl #1
 8010a8c:	eb0a 0800 	add.w	r8, sl, r0
 8010a90:	f8df 9080 	ldr.w	r9, [pc, #128]	; 8010b14 <lwip_getaddrname+0x94>
 8010a94:	ea4f 08c8 	mov.w	r8, r8, lsl #3
 8010a98:	f859 4008 	ldr.w	r4, [r9, r8]
  return (err == ERR_OK ? 0 : -1);
}

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
 8010a9c:	b087      	sub	sp, #28
    return NULL;
  }

  sock = &sockets[s];

  if (!sock->conn) {
 8010a9e:	b3b4      	cbz	r4, 8010b0e <lwip_getaddrname+0x8e>
 8010aa0:	461d      	mov	r5, r3
 8010aa2:	4616      	mov	r6, r2
 8010aa4:	460f      	mov	r7, r1
  sock = get_socket(s);
  if (!sock) {
    return -1;
  }

  memset(&sin, 0, sizeof(sin));
 8010aa6:	2210      	movs	r2, #16
 8010aa8:	2100      	movs	r1, #0
 8010aaa:	4604      	mov	r4, r0
 8010aac:	a802      	add	r0, sp, #8
 8010aae:	f004 f95b 	bl	8014d68 <memset>
  sin.sin_len = sizeof(sin);
 8010ab2:	f04f 0b10 	mov.w	fp, #16
  sin.sin_family = AF_INET;

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
 8010ab6:	462b      	mov	r3, r5
 8010ab8:	f10d 020a 	add.w	r2, sp, #10
 8010abc:	a901      	add	r1, sp, #4
 8010abe:	f859 0008 	ldr.w	r0, [r9, r8]
    return -1;
  }

  memset(&sin, 0, sizeof(sin));
  sin.sin_len = sizeof(sin);
  sin.sin_family = AF_INET;
 8010ac2:	2502      	movs	r5, #2
  if (!sock) {
    return -1;
  }

  memset(&sin, 0, sizeof(sin));
  sin.sin_len = sizeof(sin);
 8010ac4:	f88d b008 	strb.w	fp, [sp, #8]
  sin.sin_family = AF_INET;
 8010ac8:	f88d 5009 	strb.w	r5, [sp, #9]

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
 8010acc:	f7fb f818 	bl	800bb00 <netconn_getaddr>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F")\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
 8010ad0:	f8bd 000a 	ldrh.w	r0, [sp, #10]
 8010ad4:	f7fd f860 	bl	800db98 <lwip_htons>
  inet_addr_from_ipaddr(&sin.sin_addr, &naddr);

  if (*namelen > sizeof(sin)) {
 8010ad8:	6832      	ldr	r2, [r6, #0]
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F")\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
  inet_addr_from_ipaddr(&sin.sin_addr, &naddr);
 8010ada:	9b01      	ldr	r3, [sp, #4]

  if (*namelen > sizeof(sin)) {
 8010adc:	455a      	cmp	r2, fp

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F")\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
 8010ade:	f8ad 000a 	strh.w	r0, [sp, #10]
  inet_addr_from_ipaddr(&sin.sin_addr, &naddr);
 8010ae2:	9303      	str	r3, [sp, #12]

  if (*namelen > sizeof(sin)) {
 8010ae4:	d80f      	bhi.n	8010b06 <lwip_getaddrname+0x86>
    *namelen = sizeof(sin);
  }

  MEMCPY(name, &sin, *namelen);
 8010ae6:	a902      	add	r1, sp, #8
 8010ae8:	4638      	mov	r0, r7
 8010aea:	f004 f932 	bl	8014d52 <memcpy>
  sock_set_errno(sock, 0);
 8010aee:	eb0a 0004 	add.w	r0, sl, r4
 8010af2:	eb09 04c0 	add.w	r4, r9, r0, lsl #3
 8010af6:	2000      	movs	r0, #0
 8010af8:	6120      	str	r0, [r4, #16]
  return 0;
}
 8010afa:	b007      	add	sp, #28
 8010afc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  struct sockaddr_in sin;
  ip_addr_t naddr;

  sock = get_socket(s);
  if (!sock) {
    return -1;
 8010b00:	f04f 30ff 	mov.w	r0, #4294967295
  }

  MEMCPY(name, &sin, *namelen);
  sock_set_errno(sock, 0);
  return 0;
}
 8010b04:	4770      	bx	lr

  sin.sin_port = htons(sin.sin_port);
  inet_addr_from_ipaddr(&sin.sin_addr, &naddr);

  if (*namelen > sizeof(sin)) {
    *namelen = sizeof(sin);
 8010b06:	465a      	mov	r2, fp
 8010b08:	f8c6 b000 	str.w	fp, [r6]
 8010b0c:	e7eb      	b.n	8010ae6 <lwip_getaddrname+0x66>
  struct sockaddr_in sin;
  ip_addr_t naddr;

  sock = get_socket(s);
  if (!sock) {
    return -1;
 8010b0e:	f04f 30ff 	mov.w	r0, #4294967295
 8010b12:	e7f2      	b.n	8010afa <lwip_getaddrname+0x7a>
 8010b14:	20004c40 	.word	0x20004c40

08010b18 <alloc_socket>:
 *                 0 if socket has been created by socket()
 * @return the index of the new socket; -1 on error
 */
static int
alloc_socket(struct netconn *newconn, int accepted)
{
 8010b18:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8010b1c:	2500      	movs	r5, #0
 8010b1e:	4681      	mov	r9, r0
 8010b20:	4688      	mov	r8, r1
  int i;
  SYS_ARCH_DECL_PROTECT(lev);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
 8010b22:	462c      	mov	r4, r5
 8010b24:	4f1a      	ldr	r7, [pc, #104]	; (8010b90 <alloc_socket+0x78>)
    /* Protect socket array */
    SYS_ARCH_PROTECT(lev);
 8010b26:	f7f0 fe25 	bl	8001774 <CPU_SR_Save>
    if (!sockets[i].conn) {
 8010b2a:	597e      	ldr	r6, [r7, r5]
 8010b2c:	4b18      	ldr	r3, [pc, #96]	; (8010b90 <alloc_socket+0x78>)
 8010b2e:	3518      	adds	r5, #24
 8010b30:	b146      	cbz	r6, 8010b44 <alloc_socket+0x2c>
{
  int i;
  SYS_ARCH_DECL_PROTECT(lev);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
 8010b32:	3401      	adds	r4, #1
      sockets[i].errevent   = 0;
      sockets[i].err        = 0;
      sockets[i].select_waiting = 0;
      return i;
    }
    SYS_ARCH_UNPROTECT(lev);
 8010b34:	f7f0 fe22 	bl	800177c <CPU_SR_Restore>
{
  int i;
  SYS_ARCH_DECL_PROTECT(lev);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
 8010b38:	2c04      	cmp	r4, #4
 8010b3a:	d1f4      	bne.n	8010b26 <alloc_socket+0xe>
      sockets[i].select_waiting = 0;
      return i;
    }
    SYS_ARCH_UNPROTECT(lev);
  }
  return -1;
 8010b3c:	f04f 30ff 	mov.w	r0, #4294967295
}
 8010b40:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
    /* Protect socket array */
    SYS_ARCH_PROTECT(lev);
    if (!sockets[i].conn) {
      sockets[i].conn       = newconn;
 8010b44:	ea4f 0a44 	mov.w	sl, r4, lsl #1
 8010b48:	eb0a 0504 	add.w	r5, sl, r4
 8010b4c:	00ed      	lsls	r5, r5, #3
 8010b4e:	f843 9005 	str.w	r9, [r3, r5]
 8010b52:	441d      	add	r5, r3
      /* The socket is not yet known to anyone, so no need to protect
         after having marked it as used. */
      SYS_ARCH_UNPROTECT(lev);
 8010b54:	f7f0 fe12 	bl	800177c <CPU_SR_Restore>
      sockets[i].lastdata   = NULL;
      sockets[i].lastoffset = 0;
      sockets[i].rcvevent   = 0;
      /* TCP sendbuf is empty, but the socket is not yet writable until connected
       * (unless it has been created by accept()). */
      sockets[i].sendevent  = (newconn->type == NETCONN_TCP ? (accepted != 0) : 1);
 8010b58:	f899 3000 	ldrb.w	r3, [r9]
    if (!sockets[i].conn) {
      sockets[i].conn       = newconn;
      /* The socket is not yet known to anyone, so no need to protect
         after having marked it as used. */
      SYS_ARCH_UNPROTECT(lev);
      sockets[i].lastdata   = NULL;
 8010b5c:	606e      	str	r6, [r5, #4]
      sockets[i].lastoffset = 0;
      sockets[i].rcvevent   = 0;
      /* TCP sendbuf is empty, but the socket is not yet writable until connected
       * (unless it has been created by accept()). */
      sockets[i].sendevent  = (newconn->type == NETCONN_TCP ? (accepted != 0) : 1);
 8010b5e:	2b10      	cmp	r3, #16
      sockets[i].conn       = newconn;
      /* The socket is not yet known to anyone, so no need to protect
         after having marked it as used. */
      SYS_ARCH_UNPROTECT(lev);
      sockets[i].lastdata   = NULL;
      sockets[i].lastoffset = 0;
 8010b60:	812e      	strh	r6, [r5, #8]
      sockets[i].rcvevent   = 0;
 8010b62:	816e      	strh	r6, [r5, #10]
      /* TCP sendbuf is empty, but the socket is not yet writable until connected
       * (unless it has been created by accept()). */
      sockets[i].sendevent  = (newconn->type == NETCONN_TCP ? (accepted != 0) : 1);
 8010b64:	d00d      	beq.n	8010b82 <alloc_socket+0x6a>
 8010b66:	f04f 0801 	mov.w	r8, #1
 8010b6a:	44a2      	add	sl, r4
 8010b6c:	eb07 07ca 	add.w	r7, r7, sl, lsl #3
      sockets[i].errevent   = 0;
 8010b70:	2300      	movs	r3, #0
      sockets[i].lastdata   = NULL;
      sockets[i].lastoffset = 0;
      sockets[i].rcvevent   = 0;
      /* TCP sendbuf is empty, but the socket is not yet writable until connected
       * (unless it has been created by accept()). */
      sockets[i].sendevent  = (newconn->type == NETCONN_TCP ? (accepted != 0) : 1);
 8010b72:	f8a7 800c 	strh.w	r8, [r7, #12]
      sockets[i].errevent   = 0;
      sockets[i].err        = 0;
      sockets[i].select_waiting = 0;
      return i;
 8010b76:	4620      	mov	r0, r4
      sockets[i].lastoffset = 0;
      sockets[i].rcvevent   = 0;
      /* TCP sendbuf is empty, but the socket is not yet writable until connected
       * (unless it has been created by accept()). */
      sockets[i].sendevent  = (newconn->type == NETCONN_TCP ? (accepted != 0) : 1);
      sockets[i].errevent   = 0;
 8010b78:	81fb      	strh	r3, [r7, #14]
      sockets[i].err        = 0;
 8010b7a:	613b      	str	r3, [r7, #16]
      sockets[i].select_waiting = 0;
 8010b7c:	617b      	str	r3, [r7, #20]
      return i;
 8010b7e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8010b82:	f118 0800 	adds.w	r8, r8, #0
 8010b86:	bf18      	it	ne
 8010b88:	f04f 0801 	movne.w	r8, #1
 8010b8c:	e7ed      	b.n	8010b6a <alloc_socket+0x52>
 8010b8e:	bf00      	nop
 8010b90:	20004c40 	.word	0x20004c40

08010b94 <lwip_selscan>:
 * @return number of sockets that had events (read/write/exception) (>= 0)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset_in, fd_set *writeset_in, fd_set *exceptset_in,
             fd_set *readset_out, fd_set *writeset_out, fd_set *exceptset_out)
{
 8010b94:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);

  /* Go through each socket in each list to count number of sockets which
     currently match */
  for(i = 0; i < maxfdp1; i++) {
 8010b98:	2800      	cmp	r0, #0
 * @return number of sockets that had events (read/write/exception) (>= 0)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset_in, fd_set *writeset_in, fd_set *exceptset_in,
             fd_set *readset_out, fd_set *writeset_out, fd_set *exceptset_out)
{
 8010b9a:	b08b      	sub	sp, #44	; 0x2c
  int i, nready = 0;
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_sock *sock;
  SYS_ARCH_DECL_PROTECT(lev);

  FD_ZERO(&lreadset);
 8010b9c:	f04f 0600 	mov.w	r6, #0
 8010ba0:	f88d 6010 	strb.w	r6, [sp, #16]
 8010ba4:	f88d 6011 	strb.w	r6, [sp, #17]
 8010ba8:	f88d 6012 	strb.w	r6, [sp, #18]
 8010bac:	f88d 6013 	strb.w	r6, [sp, #19]
 8010bb0:	f88d 6014 	strb.w	r6, [sp, #20]
 8010bb4:	f88d 6015 	strb.w	r6, [sp, #21]
 8010bb8:	f88d 6016 	strb.w	r6, [sp, #22]
 8010bbc:	f88d 6017 	strb.w	r6, [sp, #23]
  FD_ZERO(&lwriteset);
 8010bc0:	f88d 6018 	strb.w	r6, [sp, #24]
 8010bc4:	f88d 6019 	strb.w	r6, [sp, #25]
 8010bc8:	f88d 601a 	strb.w	r6, [sp, #26]
 8010bcc:	f88d 601b 	strb.w	r6, [sp, #27]
 8010bd0:	f88d 601c 	strb.w	r6, [sp, #28]
 8010bd4:	f88d 601d 	strb.w	r6, [sp, #29]
 8010bd8:	f88d 601e 	strb.w	r6, [sp, #30]
 8010bdc:	f88d 601f 	strb.w	r6, [sp, #31]
  FD_ZERO(&lexceptset);
 8010be0:	f88d 6020 	strb.w	r6, [sp, #32]
 8010be4:	f88d 6021 	strb.w	r6, [sp, #33]	; 0x21
 8010be8:	f88d 6022 	strb.w	r6, [sp, #34]	; 0x22
 8010bec:	f88d 6023 	strb.w	r6, [sp, #35]	; 0x23
 8010bf0:	f88d 6024 	strb.w	r6, [sp, #36]	; 0x24
 8010bf4:	f88d 6025 	strb.w	r6, [sp, #37]	; 0x25
 8010bf8:	f88d 6026 	strb.w	r6, [sp, #38]	; 0x26
 8010bfc:	f88d 6027 	strb.w	r6, [sp, #39]	; 0x27

  /* Go through each socket in each list to count number of sockets which
     currently match */
  for(i = 0; i < maxfdp1; i++) {
 8010c00:	f340 8084 	ble.w	8010d0c <lwip_selscan+0x178>
 8010c04:	469a      	mov	sl, r3
 8010c06:	4691      	mov	r9, r2
 8010c08:	4688      	mov	r8, r1
 8010c0a:	4634      	mov	r4, r6
 8010c0c:	4d48      	ldr	r5, [pc, #288]	; (8010d30 <lwip_selscan+0x19c>)
 8010c0e:	9003      	str	r0, [sp, #12]
 8010c10:	9602      	str	r6, [sp, #8]
      errevent = sock->errevent;
    }
    SYS_ARCH_UNPROTECT(lev);
    /* ... then examine it: */
    /* See if netconn of this socket is ready for read */
    if (readset_in && FD_ISSET(i, readset_in) && ((lastdata != NULL) || (rcvevent > 0))) {
 8010c12:	2701      	movs	r7, #1
    void* lastdata = NULL;
    s16_t rcvevent = 0;
    u16_t sendevent = 0;
    u16_t errevent = 0;
    /* First get the socket's status (protected)... */
    SYS_ARCH_PROTECT(lev);
 8010c14:	f7f0 fdae 	bl	8001774 <CPU_SR_Save>
 * @return struct lwip_sock for the socket or NULL if not found
 */
static struct lwip_sock *
tryget_socket(int s)
{
  if ((s < 0) || (s >= NUM_SOCKETS)) {
 8010c18:	2c03      	cmp	r4, #3
 8010c1a:	d979      	bls.n	8010d10 <lwip_selscan+0x17c>
     currently match */
  for(i = 0; i < maxfdp1; i++) {
    void* lastdata = NULL;
    s16_t rcvevent = 0;
    u16_t sendevent = 0;
    u16_t errevent = 0;
 8010c1c:	f04f 0b00 	mov.w	fp, #0
  /* Go through each socket in each list to count number of sockets which
     currently match */
  for(i = 0; i < maxfdp1; i++) {
    void* lastdata = NULL;
    s16_t rcvevent = 0;
    u16_t sendevent = 0;
 8010c20:	465a      	mov	r2, fp
  FD_ZERO(&lexceptset);

  /* Go through each socket in each list to count number of sockets which
     currently match */
  for(i = 0; i < maxfdp1; i++) {
    void* lastdata = NULL;
 8010c22:	465e      	mov	r6, fp
    s16_t rcvevent = 0;
 8010c24:	f8cd b004 	str.w	fp, [sp, #4]
 8010c28:	9200      	str	r2, [sp, #0]
      lastdata = sock->lastdata;
      rcvevent = sock->rcvevent;
      sendevent = sock->sendevent;
      errevent = sock->errevent;
    }
    SYS_ARCH_UNPROTECT(lev);
 8010c2a:	f7f0 fda7 	bl	800177c <CPU_SR_Restore>
    /* ... then examine it: */
    /* See if netconn of this socket is ready for read */
    if (readset_in && FD_ISSET(i, readset_in) && ((lastdata != NULL) || (rcvevent > 0))) {
 8010c2e:	9a00      	ldr	r2, [sp, #0]
 8010c30:	f1b8 0f00 	cmp.w	r8, #0
 8010c34:	d018      	beq.n	8010c68 <lwip_selscan+0xd4>
 8010c36:	ea4f 1c54 	mov.w	ip, r4, lsr #5
 8010c3a:	f858 002c 	ldr.w	r0, [r8, ip, lsl #2]
 8010c3e:	f004 0e1f 	and.w	lr, r4, #31
 8010c42:	fa07 fe0e 	lsl.w	lr, r7, lr
 8010c46:	ea1e 0f00 	tst.w	lr, r0
 8010c4a:	d00d      	beq.n	8010c68 <lwip_selscan+0xd4>
 8010c4c:	2e00      	cmp	r6, #0
 8010c4e:	d059      	beq.n	8010d04 <lwip_selscan+0x170>
      FD_SET(i, &lreadset);
 8010c50:	ab0a      	add	r3, sp, #40	; 0x28
 8010c52:	eb03 0c8c 	add.w	ip, r3, ip, lsl #2
 8010c56:	f85c 1c18 	ldr.w	r1, [ip, #-24]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
      nready++;
 8010c5a:	9b02      	ldr	r3, [sp, #8]
    }
    SYS_ARCH_UNPROTECT(lev);
    /* ... then examine it: */
    /* See if netconn of this socket is ready for read */
    if (readset_in && FD_ISSET(i, readset_in) && ((lastdata != NULL) || (rcvevent > 0))) {
      FD_SET(i, &lreadset);
 8010c5c:	ea41 010e 	orr.w	r1, r1, lr
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
      nready++;
 8010c60:	3301      	adds	r3, #1
 8010c62:	9302      	str	r3, [sp, #8]
    }
    SYS_ARCH_UNPROTECT(lev);
    /* ... then examine it: */
    /* See if netconn of this socket is ready for read */
    if (readset_in && FD_ISSET(i, readset_in) && ((lastdata != NULL) || (rcvevent > 0))) {
      FD_SET(i, &lreadset);
 8010c64:	f84c 1c18 	str.w	r1, [ip, #-24]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
      nready++;
    }
    /* See if netconn of this socket is ready for write */
    if (writeset_in && FD_ISSET(i, writeset_in) && (sendevent != 0)) {
 8010c68:	f1b9 0f00 	cmp.w	r9, #0
 8010c6c:	d014      	beq.n	8010c98 <lwip_selscan+0x104>
 8010c6e:	0966      	lsrs	r6, r4, #5
 8010c70:	f859 1026 	ldr.w	r1, [r9, r6, lsl #2]
 8010c74:	f004 001f 	and.w	r0, r4, #31
 8010c78:	fa07 f000 	lsl.w	r0, r7, r0
 8010c7c:	4208      	tst	r0, r1
 8010c7e:	d00b      	beq.n	8010c98 <lwip_selscan+0x104>
 8010c80:	b152      	cbz	r2, 8010c98 <lwip_selscan+0x104>
      FD_SET(i, &lwriteset);
 8010c82:	ab0a      	add	r3, sp, #40	; 0x28
 8010c84:	eb03 0686 	add.w	r6, r3, r6, lsl #2
 8010c88:	f856 2c10 	ldr.w	r2, [r6, #-16]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
      nready++;
 8010c8c:	9b02      	ldr	r3, [sp, #8]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
      nready++;
    }
    /* See if netconn of this socket is ready for write */
    if (writeset_in && FD_ISSET(i, writeset_in) && (sendevent != 0)) {
      FD_SET(i, &lwriteset);
 8010c8e:	4302      	orrs	r2, r0
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
      nready++;
 8010c90:	3301      	adds	r3, #1
 8010c92:	9302      	str	r3, [sp, #8]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
      nready++;
    }
    /* See if netconn of this socket is ready for write */
    if (writeset_in && FD_ISSET(i, writeset_in) && (sendevent != 0)) {
      FD_SET(i, &lwriteset);
 8010c94:	f846 2c10 	str.w	r2, [r6, #-16]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
      nready++;
    }
    /* See if netconn of this socket had an error */
    if (exceptset_in && FD_ISSET(i, exceptset_in) && (errevent != 0)) {
 8010c98:	f1ba 0f00 	cmp.w	sl, #0
 8010c9c:	d016      	beq.n	8010ccc <lwip_selscan+0x138>
 8010c9e:	0960      	lsrs	r0, r4, #5
 8010ca0:	f85a 2020 	ldr.w	r2, [sl, r0, lsl #2]
 8010ca4:	f004 011f 	and.w	r1, r4, #31
 8010ca8:	fa07 f101 	lsl.w	r1, r7, r1
 8010cac:	4211      	tst	r1, r2
 8010cae:	d00d      	beq.n	8010ccc <lwip_selscan+0x138>
 8010cb0:	f1bb 0f00 	cmp.w	fp, #0
 8010cb4:	d00a      	beq.n	8010ccc <lwip_selscan+0x138>
      FD_SET(i, &lexceptset);
 8010cb6:	ab0a      	add	r3, sp, #40	; 0x28
 8010cb8:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8010cbc:	f850 3c08 	ldr.w	r3, [r0, #-8]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for exception\n", i));
      nready++;
 8010cc0:	9a02      	ldr	r2, [sp, #8]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
      nready++;
    }
    /* See if netconn of this socket had an error */
    if (exceptset_in && FD_ISSET(i, exceptset_in) && (errevent != 0)) {
      FD_SET(i, &lexceptset);
 8010cc2:	4319      	orrs	r1, r3
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for exception\n", i));
      nready++;
 8010cc4:	3201      	adds	r2, #1
 8010cc6:	9202      	str	r2, [sp, #8]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
      nready++;
    }
    /* See if netconn of this socket had an error */
    if (exceptset_in && FD_ISSET(i, exceptset_in) && (errevent != 0)) {
      FD_SET(i, &lexceptset);
 8010cc8:	f840 1c08 	str.w	r1, [r0, #-8]
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);

  /* Go through each socket in each list to count number of sockets which
     currently match */
  for(i = 0; i < maxfdp1; i++) {
 8010ccc:	9b03      	ldr	r3, [sp, #12]
 8010cce:	3401      	adds	r4, #1
 8010cd0:	42a3      	cmp	r3, r4
 8010cd2:	f105 0518 	add.w	r5, r5, #24
 8010cd6:	d19d      	bne.n	8010c14 <lwip_selscan+0x80>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for exception\n", i));
      nready++;
    }
  }
  /* copy local sets to the ones provided as arguments */
  *readset_out = lreadset;
 8010cd8:	aa04      	add	r2, sp, #16
 8010cda:	e892 0003 	ldmia.w	r2, {r0, r1}
 8010cde:	9a14      	ldr	r2, [sp, #80]	; 0x50
  *writeset_out = lwriteset;
 8010ce0:	ab06      	add	r3, sp, #24
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for exception\n", i));
      nready++;
    }
  }
  /* copy local sets to the ones provided as arguments */
  *readset_out = lreadset;
 8010ce2:	e882 0003 	stmia.w	r2, {r0, r1}
  *writeset_out = lwriteset;
 8010ce6:	e893 0003 	ldmia.w	r3, {r0, r1}
 8010cea:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8010cec:	e883 0003 	stmia.w	r3, {r0, r1}
  *exceptset_out = lexceptset;
 8010cf0:	ab0a      	add	r3, sp, #40	; 0x28
 8010cf2:	e913 0003 	ldmdb	r3, {r0, r1}
 8010cf6:	9b16      	ldr	r3, [sp, #88]	; 0x58
 8010cf8:	e883 0003 	stmia.w	r3, {r0, r1}

  LWIP_ASSERT("nready >= 0", nready >= 0);
  return nready;
}
 8010cfc:	9802      	ldr	r0, [sp, #8]
 8010cfe:	b00b      	add	sp, #44	; 0x2c
 8010d00:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      errevent = sock->errevent;
    }
    SYS_ARCH_UNPROTECT(lev);
    /* ... then examine it: */
    /* See if netconn of this socket is ready for read */
    if (readset_in && FD_ISSET(i, readset_in) && ((lastdata != NULL) || (rcvevent > 0))) {
 8010d04:	9b01      	ldr	r3, [sp, #4]
 8010d06:	2b00      	cmp	r3, #0
 8010d08:	dca2      	bgt.n	8010c50 <lwip_selscan+0xbc>
 8010d0a:	e7ad      	b.n	8010c68 <lwip_selscan+0xd4>
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);

  /* Go through each socket in each list to count number of sockets which
     currently match */
  for(i = 0; i < maxfdp1; i++) {
 8010d0c:	9602      	str	r6, [sp, #8]
 8010d0e:	e7e3      	b.n	8010cd8 <lwip_selscan+0x144>
tryget_socket(int s)
{
  if ((s < 0) || (s >= NUM_SOCKETS)) {
    return NULL;
  }
  if (!sockets[s].conn) {
 8010d10:	682b      	ldr	r3, [r5, #0]
 8010d12:	b13b      	cbz	r3, 8010d24 <lwip_selscan+0x190>
    /* First get the socket's status (protected)... */
    SYS_ARCH_PROTECT(lev);
    sock = tryget_socket(i);
    if (sock != NULL) {
      lastdata = sock->lastdata;
      rcvevent = sock->rcvevent;
 8010d14:	f9b5 300a 	ldrsh.w	r3, [r5, #10]
    u16_t errevent = 0;
    /* First get the socket's status (protected)... */
    SYS_ARCH_PROTECT(lev);
    sock = tryget_socket(i);
    if (sock != NULL) {
      lastdata = sock->lastdata;
 8010d18:	686e      	ldr	r6, [r5, #4]
      rcvevent = sock->rcvevent;
 8010d1a:	9301      	str	r3, [sp, #4]
      sendevent = sock->sendevent;
 8010d1c:	89aa      	ldrh	r2, [r5, #12]
      errevent = sock->errevent;
 8010d1e:	f8b5 b00e 	ldrh.w	fp, [r5, #14]
 8010d22:	e781      	b.n	8010c28 <lwip_selscan+0x94>
     currently match */
  for(i = 0; i < maxfdp1; i++) {
    void* lastdata = NULL;
    s16_t rcvevent = 0;
    u16_t sendevent = 0;
    u16_t errevent = 0;
 8010d24:	469b      	mov	fp, r3
  /* Go through each socket in each list to count number of sockets which
     currently match */
  for(i = 0; i < maxfdp1; i++) {
    void* lastdata = NULL;
    s16_t rcvevent = 0;
    u16_t sendevent = 0;
 8010d26:	461a      	mov	r2, r3

  /* Go through each socket in each list to count number of sockets which
     currently match */
  for(i = 0; i < maxfdp1; i++) {
    void* lastdata = NULL;
    s16_t rcvevent = 0;
 8010d28:	9301      	str	r3, [sp, #4]
  FD_ZERO(&lexceptset);

  /* Go through each socket in each list to count number of sockets which
     currently match */
  for(i = 0; i < maxfdp1; i++) {
    void* lastdata = NULL;
 8010d2a:	461e      	mov	r6, r3
 8010d2c:	e77c      	b.n	8010c28 <lwip_selscan+0x94>
 8010d2e:	bf00      	nop
 8010d30:	20004c40 	.word	0x20004c40

08010d34 <event_callback>:
  SYS_ARCH_DECL_PROTECT(lev);

  LWIP_UNUSED_ARG(len);

  /* Get socket */
  if (conn) {
 8010d34:	2800      	cmp	r0, #0
 8010d36:	f000 80a3 	beq.w	8010e80 <event_callback+0x14c>
 * Callback registered in the netconn layer for each socket-netconn.
 * Processes recvevent (data available) and wakes up tasks waiting for select.
 */
static void
event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
{
 8010d3a:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

  LWIP_UNUSED_ARG(len);

  /* Get socket */
  if (conn) {
    s = conn->socket;
 8010d3e:	f8d0 4094 	ldr.w	r4, [r0, #148]	; 0x94
 8010d42:	4605      	mov	r5, r0
    if (s < 0) {
 8010d44:	2c00      	cmp	r4, #0
 8010d46:	4688      	mov	r8, r1
 8010d48:	f2c0 8088 	blt.w	8010e5c <event_callback+0x128>
static struct lwip_sock *
get_socket(int s)
{
  struct lwip_sock *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
 8010d4c:	2c03      	cmp	r4, #3
 8010d4e:	dc13      	bgt.n	8010d78 <event_callback+0x44>
    return NULL;
  }

  sock = &sockets[s];

  if (!sock->conn) {
 8010d50:	0067      	lsls	r7, r4, #1
 8010d52:	4d52      	ldr	r5, [pc, #328]	; (8010e9c <event_callback+0x168>)
 8010d54:	193b      	adds	r3, r7, r4
 8010d56:	f855 3033 	ldr.w	r3, [r5, r3, lsl #3]
 8010d5a:	2b00      	cmp	r3, #0
 8010d5c:	f000 8091 	beq.w	8010e82 <event_callback+0x14e>
    }
  } else {
    return;
  }

  SYS_ARCH_PROTECT(lev);
 8010d60:	f7f0 fd08 	bl	8001774 <CPU_SR_Save>
 8010d64:	4606      	mov	r6, r0
  /* Set event as required */
  switch (evt) {
 8010d66:	f1b8 0f04 	cmp.w	r8, #4
 8010d6a:	f200 8081 	bhi.w	8010e70 <event_callback+0x13c>
 8010d6e:	e8df f008 	tbb	[pc, r8]
 8010d72:	5960      	.short	0x5960
 8010d74:	4767      	.short	0x4767
 8010d76:	05          	.byte	0x05
 8010d77:	00          	.byte	0x00
 8010d78:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      break;
    case NETCONN_EVT_SENDMINUS:
      sock->sendevent = 0;
      break;
    case NETCONN_EVT_ERROR:
      sock->errevent = 1;
 8010d7c:	193b      	adds	r3, r7, r4
 8010d7e:	eb05 03c3 	add.w	r3, r5, r3, lsl #3
 8010d82:	2201      	movs	r2, #1
 8010d84:	81da      	strh	r2, [r3, #14]
    default:
      LWIP_ASSERT("unknown event", 0);
      break;
  }

  if (sock->select_waiting == 0) {
 8010d86:	eb07 0804 	add.w	r8, r7, r4
 8010d8a:	eb05 08c8 	add.w	r8, r5, r8, lsl #3
 8010d8e:	f8d8 3014 	ldr.w	r3, [r8, #20]
 8010d92:	2b00      	cmp	r3, #0
 8010d94:	d041      	beq.n	8010e1a <event_callback+0xe6>
    if (scb->sem_signalled == 0) {
      /* semaphore not signalled yet */
      int do_signal = 0;
      /* Test this select call for our socket */
      if (sock->rcvevent > 0) {
        if (scb->readset && FD_ISSET(s, scb->readset)) {
 8010d96:	f04f 0901 	mov.w	r9, #1
 8010d9a:	fa09 f904 	lsl.w	r9, r9, r4
     ONLY IF a select was actually waiting. We go through the list the number
     of waiting select calls + 1. This list is expected to be small. */

  /* At this point, SYS_ARCH is still protected! */
again:
  for (scb = select_cb_list; scb != NULL; scb = scb->next) {
 8010d9e:	6e2c      	ldr	r4, [r5, #96]	; 0x60
 8010da0:	b994      	cbnz	r4, 8010dc8 <event_callback+0x94>
 8010da2:	e03a      	b.n	8010e1a <event_callback+0xe6>
        if (!do_signal && scb->exceptset && FD_ISSET(s, scb->exceptset)) {
          do_signal = 1;
        }
      }
      if (do_signal) {
        scb->sem_signalled = 1;
 8010da4:	2301      	movs	r3, #1
 8010da6:	6163      	str	r3, [r4, #20]
        /* Don't call SYS_ARCH_UNPROTECT() before signaling the semaphore, as this might
           lead to the select thread taking itself off the list, invalidagin the semaphore. */
        sys_sem_signal(&scb->sem);
 8010da8:	f104 0018 	add.w	r0, r4, #24
 8010dac:	f002 f9e8 	bl	8013180 <sys_sem_signal>
      }
    }
    /* unlock interrupts with each step */
    last_select_cb_ctr = select_cb_ctr;
    SYS_ARCH_UNPROTECT(lev);
 8010db0:	4630      	mov	r0, r6
           lead to the select thread taking itself off the list, invalidagin the semaphore. */
        sys_sem_signal(&scb->sem);
      }
    }
    /* unlock interrupts with each step */
    last_select_cb_ctr = select_cb_ctr;
 8010db2:	6e6f      	ldr	r7, [r5, #100]	; 0x64
    SYS_ARCH_UNPROTECT(lev);
 8010db4:	f7f0 fce2 	bl	800177c <CPU_SR_Restore>
    /* this makes sure interrupt protection time is short */
    SYS_ARCH_PROTECT(lev);
 8010db8:	f7f0 fcdc 	bl	8001774 <CPU_SR_Save>
    if (last_select_cb_ctr != select_cb_ctr) {
 8010dbc:	6e6b      	ldr	r3, [r5, #100]	; 0x64
    }
    /* unlock interrupts with each step */
    last_select_cb_ctr = select_cb_ctr;
    SYS_ARCH_UNPROTECT(lev);
    /* this makes sure interrupt protection time is short */
    SYS_ARCH_PROTECT(lev);
 8010dbe:	4606      	mov	r6, r0
    if (last_select_cb_ctr != select_cb_ctr) {
 8010dc0:	429f      	cmp	r7, r3
 8010dc2:	d1ec      	bne.n	8010d9e <event_callback+0x6a>
     ONLY IF a select was actually waiting. We go through the list the number
     of waiting select calls + 1. This list is expected to be small. */

  /* At this point, SYS_ARCH is still protected! */
again:
  for (scb = select_cb_list; scb != NULL; scb = scb->next) {
 8010dc4:	6824      	ldr	r4, [r4, #0]
 8010dc6:	b344      	cbz	r4, 8010e1a <event_callback+0xe6>
    if (scb->sem_signalled == 0) {
 8010dc8:	6963      	ldr	r3, [r4, #20]
 8010dca:	2b00      	cmp	r3, #0
 8010dcc:	d1f0      	bne.n	8010db0 <event_callback+0x7c>
      /* semaphore not signalled yet */
      int do_signal = 0;
      /* Test this select call for our socket */
      if (sock->rcvevent > 0) {
 8010dce:	f9b8 300a 	ldrsh.w	r3, [r8, #10]
 8010dd2:	2b00      	cmp	r3, #0
 8010dd4:	dd05      	ble.n	8010de2 <event_callback+0xae>
        if (scb->readset && FD_ISSET(s, scb->readset)) {
 8010dd6:	68a3      	ldr	r3, [r4, #8]
 8010dd8:	b11b      	cbz	r3, 8010de2 <event_callback+0xae>
 8010dda:	681b      	ldr	r3, [r3, #0]
 8010ddc:	ea19 0f03 	tst.w	r9, r3
 8010de0:	d1e0      	bne.n	8010da4 <event_callback+0x70>
          do_signal = 1;
        }
      }
      if (sock->sendevent != 0) {
 8010de2:	f8b8 300c 	ldrh.w	r3, [r8, #12]
 8010de6:	bb8b      	cbnz	r3, 8010e4c <event_callback+0x118>
        if (!do_signal && scb->writeset && FD_ISSET(s, scb->writeset)) {
          do_signal = 1;
        }
      }
      if (sock->errevent != 0) {
 8010de8:	f8b8 300e 	ldrh.w	r3, [r8, #14]
 8010dec:	2b00      	cmp	r3, #0
 8010dee:	d0df      	beq.n	8010db0 <event_callback+0x7c>
        if (!do_signal && scb->exceptset && FD_ISSET(s, scb->exceptset)) {
 8010df0:	6923      	ldr	r3, [r4, #16]
 8010df2:	2b00      	cmp	r3, #0
 8010df4:	d0dc      	beq.n	8010db0 <event_callback+0x7c>
 8010df6:	681b      	ldr	r3, [r3, #0]
 8010df8:	ea19 0f03 	tst.w	r9, r3
 8010dfc:	d0d8      	beq.n	8010db0 <event_callback+0x7c>
 8010dfe:	e7d1      	b.n	8010da4 <event_callback+0x70>
      break;
    case NETCONN_EVT_SENDPLUS:
      sock->sendevent = 1;
      break;
    case NETCONN_EVT_SENDMINUS:
      sock->sendevent = 0;
 8010e00:	193b      	adds	r3, r7, r4
    default:
      LWIP_ASSERT("unknown event", 0);
      break;
  }

  if (sock->select_waiting == 0) {
 8010e02:	eb07 0804 	add.w	r8, r7, r4
      break;
    case NETCONN_EVT_SENDPLUS:
      sock->sendevent = 1;
      break;
    case NETCONN_EVT_SENDMINUS:
      sock->sendevent = 0;
 8010e06:	eb05 03c3 	add.w	r3, r5, r3, lsl #3
 8010e0a:	2200      	movs	r2, #0
    default:
      LWIP_ASSERT("unknown event", 0);
      break;
  }

  if (sock->select_waiting == 0) {
 8010e0c:	eb05 08c8 	add.w	r8, r5, r8, lsl #3
      break;
    case NETCONN_EVT_SENDPLUS:
      sock->sendevent = 1;
      break;
    case NETCONN_EVT_SENDMINUS:
      sock->sendevent = 0;
 8010e10:	819a      	strh	r2, [r3, #12]
    default:
      LWIP_ASSERT("unknown event", 0);
      break;
  }

  if (sock->select_waiting == 0) {
 8010e12:	f8d8 3014 	ldr.w	r3, [r8, #20]
 8010e16:	2b00      	cmp	r3, #0
 8010e18:	d1bd      	bne.n	8010d96 <event_callback+0x62>
    if (last_select_cb_ctr != select_cb_ctr) {
      /* someone has changed select_cb_list, restart at the beginning */
      goto again;
    }
  }
  SYS_ARCH_UNPROTECT(lev);
 8010e1a:	4630      	mov	r0, r6
}
 8010e1c:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    if (last_select_cb_ctr != select_cb_ctr) {
      /* someone has changed select_cb_list, restart at the beginning */
      goto again;
    }
  }
  SYS_ARCH_UNPROTECT(lev);
 8010e20:	f7f0 bcac 	b.w	800177c <CPU_SR_Restore>
  switch (evt) {
    case NETCONN_EVT_RCVPLUS:
      sock->rcvevent++;
      break;
    case NETCONN_EVT_RCVMINUS:
      sock->rcvevent--;
 8010e24:	193b      	adds	r3, r7, r4
 8010e26:	eb05 03c3 	add.w	r3, r5, r3, lsl #3
 8010e2a:	895a      	ldrh	r2, [r3, #10]
 8010e2c:	3a01      	subs	r2, #1
 8010e2e:	815a      	strh	r2, [r3, #10]
      break;
 8010e30:	e7a9      	b.n	8010d86 <event_callback+0x52>

  SYS_ARCH_PROTECT(lev);
  /* Set event as required */
  switch (evt) {
    case NETCONN_EVT_RCVPLUS:
      sock->rcvevent++;
 8010e32:	193b      	adds	r3, r7, r4
 8010e34:	eb05 03c3 	add.w	r3, r5, r3, lsl #3
 8010e38:	895a      	ldrh	r2, [r3, #10]
 8010e3a:	3201      	adds	r2, #1
 8010e3c:	815a      	strh	r2, [r3, #10]
      break;
 8010e3e:	e7a2      	b.n	8010d86 <event_callback+0x52>
    case NETCONN_EVT_RCVMINUS:
      sock->rcvevent--;
      break;
    case NETCONN_EVT_SENDPLUS:
      sock->sendevent = 1;
 8010e40:	193b      	adds	r3, r7, r4
 8010e42:	eb05 03c3 	add.w	r3, r5, r3, lsl #3
 8010e46:	2201      	movs	r2, #1
 8010e48:	819a      	strh	r2, [r3, #12]
      break;
 8010e4a:	e79c      	b.n	8010d86 <event_callback+0x52>
        if (scb->readset && FD_ISSET(s, scb->readset)) {
          do_signal = 1;
        }
      }
      if (sock->sendevent != 0) {
        if (!do_signal && scb->writeset && FD_ISSET(s, scb->writeset)) {
 8010e4c:	68e3      	ldr	r3, [r4, #12]
 8010e4e:	2b00      	cmp	r3, #0
 8010e50:	d0ca      	beq.n	8010de8 <event_callback+0xb4>
 8010e52:	681b      	ldr	r3, [r3, #0]
 8010e54:	ea19 0f03 	tst.w	r9, r3
 8010e58:	d1a4      	bne.n	8010da4 <event_callback+0x70>
 8010e5a:	e7c5      	b.n	8010de8 <event_callback+0xb4>
      /* Data comes in right away after an accept, even though
       * the server task might not have created a new socket yet.
       * Just count down (or up) if that's the case and we
       * will use the data later. Note that only receive events
       * can happen before the new socket is set up. */
      SYS_ARCH_PROTECT(lev);
 8010e5c:	f7f0 fc8a 	bl	8001774 <CPU_SR_Save>
      if (conn->socket < 0) {
 8010e60:	f8d5 4094 	ldr.w	r4, [r5, #148]	; 0x94
      /* Data comes in right away after an accept, even though
       * the server task might not have created a new socket yet.
       * Just count down (or up) if that's the case and we
       * will use the data later. Note that only receive events
       * can happen before the new socket is set up. */
      SYS_ARCH_PROTECT(lev);
 8010e64:	4603      	mov	r3, r0
      if (conn->socket < 0) {
 8010e66:	2c00      	cmp	r4, #0
 8010e68:	db0d      	blt.n	8010e86 <event_callback+0x152>
        }
        SYS_ARCH_UNPROTECT(lev);
        return;
      }
      s = conn->socket;
      SYS_ARCH_UNPROTECT(lev);
 8010e6a:	f7f0 fc87 	bl	800177c <CPU_SR_Restore>
 8010e6e:	e76d      	b.n	8010d4c <event_callback+0x18>
      break;
    case NETCONN_EVT_ERROR:
      sock->errevent = 1;
      break;
    default:
      LWIP_ASSERT("unknown event", 0);
 8010e70:	4b0b      	ldr	r3, [pc, #44]	; (8010ea0 <event_callback+0x16c>)
 8010e72:	f240 5219 	movw	r2, #1305	; 0x519
 8010e76:	490b      	ldr	r1, [pc, #44]	; (8010ea4 <event_callback+0x170>)
 8010e78:	480b      	ldr	r0, [pc, #44]	; (8010ea8 <event_callback+0x174>)
 8010e7a:	f003 ff7d 	bl	8014d78 <iprintf>
      break;
 8010e7e:	e782      	b.n	8010d86 <event_callback+0x52>
 8010e80:	4770      	bx	lr
 8010e82:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
       * Just count down (or up) if that's the case and we
       * will use the data later. Note that only receive events
       * can happen before the new socket is set up. */
      SYS_ARCH_PROTECT(lev);
      if (conn->socket < 0) {
        if (evt == NETCONN_EVT_RCVPLUS) {
 8010e86:	f1b8 0f00 	cmp.w	r8, #0
 8010e8a:	d102      	bne.n	8010e92 <event_callback+0x15e>
          conn->socket--;
 8010e8c:	3c01      	subs	r4, #1
 8010e8e:	f8c5 4094 	str.w	r4, [r5, #148]	; 0x94
        }
        SYS_ARCH_UNPROTECT(lev);
 8010e92:	4618      	mov	r0, r3
      /* someone has changed select_cb_list, restart at the beginning */
      goto again;
    }
  }
  SYS_ARCH_UNPROTECT(lev);
}
 8010e94:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
      SYS_ARCH_PROTECT(lev);
      if (conn->socket < 0) {
        if (evt == NETCONN_EVT_RCVPLUS) {
          conn->socket--;
        }
        SYS_ARCH_UNPROTECT(lev);
 8010e98:	f7f0 bc70 	b.w	800177c <CPU_SR_Restore>
 8010e9c:	20004c40 	.word	0x20004c40
 8010ea0:	08018078 	.word	0x08018078
 8010ea4:	0801808c 	.word	0x0801808c
 8010ea8:	0801660c 	.word	0x0801660c

08010eac <lwip_getsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_getsockopt_internal(void *arg)
{
 8010eac:	b538      	push	{r3, r4, r5, lr}
#endif /* LWIP_DEBUG */
  int level, optname;
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
 8010eae:	4604      	mov	r4, r0
 8010eb0:	2800      	cmp	r0, #0
 8010eb2:	d07b      	beq.n	8010fac <lwip_getsockopt_internal+0x100>
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
  optval = data->optval;

  switch (level) {
 8010eb4:	6863      	ldr	r3, [r4, #4]
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
 8010eb6:	6825      	ldr	r5, [r4, #0]
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
  optval = data->optval;

  switch (level) {
 8010eb8:	2b06      	cmp	r3, #6
  sock = data->sock;
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
 8010eba:	68a2      	ldr	r2, [r4, #8]
  optval = data->optval;
 8010ebc:	68e1      	ldr	r1, [r4, #12]

  switch (level) {
 8010ebe:	d032      	beq.n	8010f26 <lwip_getsockopt_internal+0x7a>
 8010ec0:	f640 70ff 	movw	r0, #4095	; 0xfff
 8010ec4:	4283      	cmp	r3, r0
 8010ec6:	d016      	beq.n	8010ef6 <lwip_getsockopt_internal+0x4a>
 8010ec8:	b163      	cbz	r3, 8010ee4 <lwip_getsockopt_internal+0x38>
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  default:
    LWIP_ASSERT("unhandled level", 0);
 8010eca:	4b4c      	ldr	r3, [pc, #304]	; (8010ffc <lwip_getsockopt_internal+0x150>)
 8010ecc:	f44f 62e8 	mov.w	r2, #1856	; 0x740
 8010ed0:	494b      	ldr	r1, [pc, #300]	; (8011000 <lwip_getsockopt_internal+0x154>)
 8010ed2:	484c      	ldr	r0, [pc, #304]	; (8011004 <lwip_getsockopt_internal+0x158>)
 8010ed4:	f003 ff50 	bl	8014d78 <iprintf>
 8010ed8:	6828      	ldr	r0, [r5, #0]
    break;
  } /* switch (level) */
  sys_sem_signal(&sock->conn->op_completed);
 8010eda:	300c      	adds	r0, #12
}
 8010edc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
#endif /* LWIP_UDP */
  default:
    LWIP_ASSERT("unhandled level", 0);
    break;
  } /* switch (level) */
  sys_sem_signal(&sock->conn->op_completed);
 8010ee0:	f002 b94e 	b.w	8013180 <sys_sem_signal>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
 8010ee4:	2a01      	cmp	r2, #1
 8010ee6:	d028      	beq.n	8010f3a <lwip_getsockopt_internal+0x8e>
 8010ee8:	2a02      	cmp	r2, #2
 8010eea:	d156      	bne.n	8010f9a <lwip_getsockopt_internal+0xee>
    case IP_TTL:
      *(int*)optval = sock->conn->pcb.ip->ttl;
 8010eec:	6828      	ldr	r0, [r5, #0]
 8010eee:	6843      	ldr	r3, [r0, #4]
 8010ef0:	7a9b      	ldrb	r3, [r3, #10]
 8010ef2:	600b      	str	r3, [r1, #0]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",
                  s, *(int *)optval));
      break;
 8010ef4:	e7f1      	b.n	8010eda <lwip_getsockopt_internal+0x2e>

  switch (level) {

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
 8010ef6:	2a20      	cmp	r2, #32
 8010ef8:	d02f      	beq.n	8010f5a <lwip_getsockopt_internal+0xae>
 8010efa:	dd2a      	ble.n	8010f52 <lwip_getsockopt_internal+0xa6>
 8010efc:	f241 0308 	movw	r3, #4104	; 0x1008
 8010f00:	429a      	cmp	r2, r3
 8010f02:	d062      	beq.n	8010fca <lwip_getsockopt_internal+0x11e>
 8010f04:	f241 030a 	movw	r3, #4106	; 0x100a
 8010f08:	429a      	cmp	r2, r3
 8010f0a:	d057      	beq.n	8010fbc <lwip_getsockopt_internal+0x110>
 8010f0c:	f241 0307 	movw	r3, #4103	; 0x1007
 8010f10:	429a      	cmp	r2, r3
 8010f12:	d028      	beq.n	8010f66 <lwip_getsockopt_internal+0xba>
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
      break;
#endif /* LWIP_UDP*/
    default:
      LWIP_ASSERT("unhandled optname", 0);
 8010f14:	4b39      	ldr	r3, [pc, #228]	; (8010ffc <lwip_getsockopt_internal+0x150>)
 8010f16:	f44f 62db 	mov.w	r2, #1752	; 0x6d8
 8010f1a:	493b      	ldr	r1, [pc, #236]	; (8011008 <lwip_getsockopt_internal+0x15c>)
 8010f1c:	4839      	ldr	r0, [pc, #228]	; (8011004 <lwip_getsockopt_internal+0x158>)
 8010f1e:	f003 ff2b 	bl	8014d78 <iprintf>
 8010f22:	6828      	ldr	r0, [r5, #0]
      break;
 8010f24:	e7d9      	b.n	8010eda <lwip_getsockopt_internal+0x2e>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
 8010f26:	2a01      	cmp	r2, #1
 8010f28:	d00c      	beq.n	8010f44 <lwip_getsockopt_internal+0x98>
 8010f2a:	2a02      	cmp	r2, #2
 8010f2c:	d12c      	bne.n	8010f88 <lwip_getsockopt_internal+0xdc>
      *(int*)optval = tcp_nagle_disabled(sock->conn->pcb.tcp);
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n",
                  s, (*(int*)optval)?"on":"off") );
      break;
    case TCP_KEEPALIVE:
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
 8010f2e:	6828      	ldr	r0, [r5, #0]
 8010f30:	6843      	ldr	r3, [r0, #4]
 8010f32:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8010f36:	600b      	str	r3, [r1, #0]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPALIVE) = %d\n",
                  s, *(int *)optval));
      break;
 8010f38:	e7cf      	b.n	8010eda <lwip_getsockopt_internal+0x2e>
      *(int*)optval = sock->conn->pcb.ip->ttl;
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",
                  s, *(int *)optval));
      break;
    case IP_TOS:
      *(int*)optval = sock->conn->pcb.ip->tos;
 8010f3a:	6828      	ldr	r0, [r5, #0]
 8010f3c:	6843      	ldr	r3, [r0, #4]
 8010f3e:	7a5b      	ldrb	r3, [r3, #9]
 8010f40:	600b      	str	r3, [r1, #0]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TOS) = %d\n",
                  s, *(int *)optval));
      break;
 8010f42:	e7ca      	b.n	8010eda <lwip_getsockopt_internal+0x2e>
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
    case TCP_NODELAY:
      *(int*)optval = tcp_nagle_disabled(sock->conn->pcb.tcp);
 8010f44:	6828      	ldr	r0, [r5, #0]
 8010f46:	6843      	ldr	r3, [r0, #4]
 8010f48:	7f9b      	ldrb	r3, [r3, #30]
 8010f4a:	f3c3 1380 	ubfx	r3, r3, #6, #1
 8010f4e:	600b      	str	r3, [r1, #0]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n",
                  s, (*(int*)optval)?"on":"off") );
      break;
 8010f50:	e7c3      	b.n	8010eda <lwip_getsockopt_internal+0x2e>

  switch (level) {

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
 8010f52:	2a02      	cmp	r2, #2
 8010f54:	d001      	beq.n	8010f5a <lwip_getsockopt_internal+0xae>
 8010f56:	2a08      	cmp	r2, #8
 8010f58:	d1dc      	bne.n	8010f14 <lwip_getsockopt_internal+0x68>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /*case SO_USELOOPBACK: UNIMPL */
      *(int*)optval = ip_get_option(sock->conn->pcb.ip, optname);
 8010f5a:	6828      	ldr	r0, [r5, #0]
 8010f5c:	6843      	ldr	r3, [r0, #4]
 8010f5e:	7a1b      	ldrb	r3, [r3, #8]
 8010f60:	401a      	ands	r2, r3
 8010f62:	600a      	str	r2, [r1, #0]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n",
                                  s, optname, (*(int*)optval?"on":"off")));
      break;
 8010f64:	e7b9      	b.n	8010eda <lwip_getsockopt_internal+0x2e>
                  s, *(int *)optval));
      break;

    case SO_ERROR:
      /* only overwrite ERR_OK or tempoary errors */
      if ((sock->err == 0) || (sock->err == EINPROGRESS)) {
 8010f66:	692b      	ldr	r3, [r5, #16]
        sock_set_errno(sock, err_to_errno(sock->conn->last_err));
 8010f68:	6828      	ldr	r0, [r5, #0]
                  s, *(int *)optval));
      break;

    case SO_ERROR:
      /* only overwrite ERR_OK or tempoary errors */
      if ((sock->err == 0) || (sock->err == EINPROGRESS)) {
 8010f6a:	2b00      	cmp	r3, #0
 8010f6c:	d139      	bne.n	8010fe2 <lwip_getsockopt_internal+0x136>
        sock_set_errno(sock, err_to_errno(sock->conn->last_err));
 8010f6e:	f990 3008 	ldrsb.w	r3, [r0, #8]
 8010f72:	425b      	negs	r3, r3
 8010f74:	2b0f      	cmp	r3, #15
 8010f76:	bf96      	itet	ls
 8010f78:	4a24      	ldrls	r2, [pc, #144]	; (801100c <lwip_getsockopt_internal+0x160>)
 8010f7a:	2305      	movhi	r3, #5
 8010f7c:	f852 3023 	ldrls.w	r3, [r2, r3, lsl #2]
      } 
      *(int *)optval = sock->err;
      sock->err = 0;
 8010f80:	2200      	movs	r2, #0
    case SO_ERROR:
      /* only overwrite ERR_OK or tempoary errors */
      if ((sock->err == 0) || (sock->err == EINPROGRESS)) {
        sock_set_errno(sock, err_to_errno(sock->conn->last_err));
      } 
      *(int *)optval = sock->err;
 8010f82:	600b      	str	r3, [r1, #0]
      sock->err = 0;
 8010f84:	612a      	str	r2, [r5, #16]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_ERROR) = %d\n",
                  s, *(int *)optval));
      break;
 8010f86:	e7a8      	b.n	8010eda <lwip_getsockopt_internal+0x2e>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, TCP_KEEPCNT) = %d\n",
                  s, *(int *)optval));
      break;
#endif /* LWIP_TCP_KEEPALIVE */
    default:
      LWIP_ASSERT("unhandled optname", 0);
 8010f88:	4b1c      	ldr	r3, [pc, #112]	; (8010ffc <lwip_getsockopt_internal+0x150>)
 8010f8a:	f240 7226 	movw	r2, #1830	; 0x726
 8010f8e:	491e      	ldr	r1, [pc, #120]	; (8011008 <lwip_getsockopt_internal+0x15c>)
 8010f90:	481c      	ldr	r0, [pc, #112]	; (8011004 <lwip_getsockopt_internal+0x158>)
 8010f92:	f003 fef1 	bl	8014d78 <iprintf>
 8010f96:	6828      	ldr	r0, [r5, #0]
      break;
 8010f98:	e79f      	b.n	8010eda <lwip_getsockopt_internal+0x2e>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_MULTICAST_LOOP) = %d\n",
                  s, *(int *)optval));
      break;
#endif /* LWIP_IGMP */
    default:
      LWIP_ASSERT("unhandled optname", 0);
 8010f9a:	4b18      	ldr	r3, [pc, #96]	; (8010ffc <lwip_getsockopt_internal+0x150>)
 8010f9c:	f44f 62e0 	mov.w	r2, #1792	; 0x700
 8010fa0:	4919      	ldr	r1, [pc, #100]	; (8011008 <lwip_getsockopt_internal+0x15c>)
 8010fa2:	4818      	ldr	r0, [pc, #96]	; (8011004 <lwip_getsockopt_internal+0x158>)
 8010fa4:	f003 fee8 	bl	8014d78 <iprintf>
 8010fa8:	6828      	ldr	r0, [r5, #0]
      break;
 8010faa:	e796      	b.n	8010eda <lwip_getsockopt_internal+0x2e>
#endif /* LWIP_DEBUG */
  int level, optname;
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
 8010fac:	4b13      	ldr	r3, [pc, #76]	; (8010ffc <lwip_getsockopt_internal+0x150>)
 8010fae:	f240 6281 	movw	r2, #1665	; 0x681
 8010fb2:	4917      	ldr	r1, [pc, #92]	; (8011010 <lwip_getsockopt_internal+0x164>)
 8010fb4:	4813      	ldr	r0, [pc, #76]	; (8011004 <lwip_getsockopt_internal+0x158>)
 8010fb6:	f003 fedf 	bl	8014d78 <iprintf>
 8010fba:	e77b      	b.n	8010eb4 <lwip_getsockopt_internal+0x8>
      *(int *)optval = netconn_get_recvbufsize(sock->conn);
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
 8010fbc:	6828      	ldr	r0, [r5, #0]
 8010fbe:	6843      	ldr	r3, [r0, #4]
 8010fc0:	7c1b      	ldrb	r3, [r3, #16]
 8010fc2:	f003 0301 	and.w	r3, r3, #1
 8010fc6:	600b      	str	r3, [r1, #0]
      break;
 8010fc8:	e787      	b.n	8010eda <lwip_getsockopt_internal+0x2e>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n",
                                  s, optname, (*(int*)optval?"on":"off")));
      break;

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
 8010fca:	6828      	ldr	r0, [r5, #0]
 8010fcc:	7802      	ldrb	r2, [r0, #0]
 8010fce:	f002 03f0 	and.w	r3, r2, #240	; 0xf0
 8010fd2:	2b20      	cmp	r3, #32
 8010fd4:	d008      	beq.n	8010fe8 <lwip_getsockopt_internal+0x13c>
 8010fd6:	2b40      	cmp	r3, #64	; 0x40
 8010fd8:	d00c      	beq.n	8010ff4 <lwip_getsockopt_internal+0x148>
 8010fda:	2b10      	cmp	r3, #16
 8010fdc:	d007      	beq.n	8010fee <lwip_getsockopt_internal+0x142>
        break;
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
        break;
      default: /* unrecognized socket type */
        *(int*)optval = sock->conn->type;
 8010fde:	600a      	str	r2, [r1, #0]
 8010fe0:	e77b      	b.n	8010eda <lwip_getsockopt_internal+0x2e>
                  s, *(int *)optval));
      break;

    case SO_ERROR:
      /* only overwrite ERR_OK or tempoary errors */
      if ((sock->err == 0) || (sock->err == EINPROGRESS)) {
 8010fe2:	2b73      	cmp	r3, #115	; 0x73
 8010fe4:	d1cc      	bne.n	8010f80 <lwip_getsockopt_internal+0xd4>
 8010fe6:	e7c2      	b.n	8010f6e <lwip_getsockopt_internal+0xc2>
        break;
      case NETCONN_TCP:
        *(int*)optval = SOCK_STREAM;
        break;
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
 8010fe8:	2302      	movs	r3, #2
 8010fea:	600b      	str	r3, [r1, #0]
        break;
 8010fec:	e775      	b.n	8010eda <lwip_getsockopt_internal+0x2e>
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
      case NETCONN_RAW:
        *(int*)optval = SOCK_RAW;
        break;
      case NETCONN_TCP:
        *(int*)optval = SOCK_STREAM;
 8010fee:	2301      	movs	r3, #1
 8010ff0:	600b      	str	r3, [r1, #0]
        break;
 8010ff2:	e772      	b.n	8010eda <lwip_getsockopt_internal+0x2e>
      break;

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
      case NETCONN_RAW:
        *(int*)optval = SOCK_RAW;
 8010ff4:	2303      	movs	r3, #3
 8010ff6:	600b      	str	r3, [r1, #0]
        break;
 8010ff8:	e76f      	b.n	8010eda <lwip_getsockopt_internal+0x2e>
 8010ffa:	bf00      	nop
 8010ffc:	08018078 	.word	0x08018078
 8011000:	080180bc 	.word	0x080180bc
 8011004:	0801660c 	.word	0x0801660c
 8011008:	080180a8 	.word	0x080180a8
 801100c:	080161e4 	.word	0x080161e4
 8011010:	0801809c 	.word	0x0801809c

08011014 <lwip_setsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_setsockopt_internal(void *arg)
{
 8011014:	b538      	push	{r3, r4, r5, lr}
#endif /* LWIP_DEBUG */
  int level, optname;
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
 8011016:	4604      	mov	r4, r0
 8011018:	2800      	cmp	r0, #0
 801101a:	d073      	beq.n	8011104 <lwip_setsockopt_internal+0xf0>
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
  optval = data->optval;

  switch (level) {
 801101c:	6863      	ldr	r3, [r4, #4]
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
 801101e:	6825      	ldr	r5, [r4, #0]
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
  optval = data->optval;

  switch (level) {
 8011020:	2b06      	cmp	r3, #6
  sock = data->sock;
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
 8011022:	68a2      	ldr	r2, [r4, #8]
  optval = data->optval;
 8011024:	68e4      	ldr	r4, [r4, #12]

  switch (level) {
 8011026:	d02c      	beq.n	8011082 <lwip_setsockopt_internal+0x6e>
 8011028:	f640 71ff 	movw	r1, #4095	; 0xfff
 801102c:	428b      	cmp	r3, r1
 801102e:	d017      	beq.n	8011060 <lwip_setsockopt_internal+0x4c>
 8011030:	b163      	cbz	r3, 801104c <lwip_setsockopt_internal+0x38>
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  default:
    LWIP_ASSERT("unhandled level", 0);
 8011032:	4b44      	ldr	r3, [pc, #272]	; (8011144 <lwip_setsockopt_internal+0x130>)
 8011034:	f640 02e2 	movw	r2, #2274	; 0x8e2
 8011038:	4943      	ldr	r1, [pc, #268]	; (8011148 <lwip_setsockopt_internal+0x134>)
 801103a:	4844      	ldr	r0, [pc, #272]	; (801114c <lwip_setsockopt_internal+0x138>)
 801103c:	f003 fe9c 	bl	8014d78 <iprintf>
 8011040:	6828      	ldr	r0, [r5, #0]
    break;
  }  /* switch (level) */
  sys_sem_signal(&sock->conn->op_completed);
 8011042:	300c      	adds	r0, #12
}
 8011044:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
#endif /* LWIP_UDP */
  default:
    LWIP_ASSERT("unhandled level", 0);
    break;
  }  /* switch (level) */
  sys_sem_signal(&sock->conn->op_completed);
 8011048:	f002 b89a 	b.w	8013180 <sys_sem_signal>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
 801104c:	2a01      	cmp	r2, #1
 801104e:	d038      	beq.n	80110c2 <lwip_setsockopt_internal+0xae>
 8011050:	2a02      	cmp	r2, #2
 8011052:	d13c      	bne.n	80110ce <lwip_setsockopt_internal+0xba>
    case IP_TTL:
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
 8011054:	682b      	ldr	r3, [r5, #0]
 8011056:	6822      	ldr	r2, [r4, #0]
 8011058:	685b      	ldr	r3, [r3, #4]
 801105a:	729a      	strb	r2, [r3, #10]
 801105c:	6828      	ldr	r0, [r5, #0]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %d\n",
                  s, sock->conn->pcb.ip->ttl));
      break;
 801105e:	e7f0      	b.n	8011042 <lwip_setsockopt_internal+0x2e>

  switch (level) {

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
 8011060:	2a20      	cmp	r2, #32
 8011062:	d03d      	beq.n	80110e0 <lwip_setsockopt_internal+0xcc>
 8011064:	f241 030a 	movw	r3, #4106	; 0x100a
 8011068:	429a      	cmp	r2, r3
 801106a:	d014      	beq.n	8011096 <lwip_setsockopt_internal+0x82>
 801106c:	2a08      	cmp	r2, #8
 801106e:	d037      	beq.n	80110e0 <lwip_setsockopt_internal+0xcc>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
      }
      break;
#endif /* LWIP_UDP */
    default:
      LWIP_ASSERT("unhandled optname", 0);
 8011070:	4b34      	ldr	r3, [pc, #208]	; (8011144 <lwip_setsockopt_internal+0x130>)
 8011072:	f640 025f 	movw	r2, #2143	; 0x85f
 8011076:	4936      	ldr	r1, [pc, #216]	; (8011150 <lwip_setsockopt_internal+0x13c>)
 8011078:	4834      	ldr	r0, [pc, #208]	; (801114c <lwip_setsockopt_internal+0x138>)
 801107a:	f003 fe7d 	bl	8014d78 <iprintf>
 801107e:	6828      	ldr	r0, [r5, #0]
      break;
 8011080:	e7df      	b.n	8011042 <lwip_setsockopt_internal+0x2e>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
 8011082:	2a01      	cmp	r2, #1
 8011084:	d012      	beq.n	80110ac <lwip_setsockopt_internal+0x98>
 8011086:	2a02      	cmp	r2, #2
 8011088:	d133      	bne.n	80110f2 <lwip_setsockopt_internal+0xde>
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
    case TCP_KEEPALIVE:
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
 801108a:	6828      	ldr	r0, [r5, #0]
 801108c:	6822      	ldr	r2, [r4, #0]
 801108e:	6843      	ldr	r3, [r0, #4]
 8011090:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPALIVE) -> %"U32_F"\n",
                  s, sock->conn->pcb.tcp->keep_idle));
      break;
 8011094:	e7d5      	b.n	8011042 <lwip_setsockopt_internal+0x2e>
      netconn_set_recvbufsize(sock->conn, *(int*)optval);
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
 8011096:	6823      	ldr	r3, [r4, #0]
 8011098:	2b00      	cmp	r3, #0
 801109a:	d04b      	beq.n	8011134 <lwip_setsockopt_internal+0x120>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
 801109c:	682b      	ldr	r3, [r5, #0]
 801109e:	685a      	ldr	r2, [r3, #4]
 80110a0:	7c13      	ldrb	r3, [r2, #16]
 80110a2:	f043 0301 	orr.w	r3, r3, #1
 80110a6:	7413      	strb	r3, [r2, #16]
 80110a8:	6828      	ldr	r0, [r5, #0]
 80110aa:	e7ca      	b.n	8011042 <lwip_setsockopt_internal+0x2e>
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
    case TCP_NODELAY:
      if (*(int*)optval) {
 80110ac:	6823      	ldr	r3, [r4, #0]
 80110ae:	2b00      	cmp	r3, #0
 80110b0:	d038      	beq.n	8011124 <lwip_setsockopt_internal+0x110>
        tcp_nagle_disable(sock->conn->pcb.tcp);
 80110b2:	682b      	ldr	r3, [r5, #0]
 80110b4:	685a      	ldr	r2, [r3, #4]
 80110b6:	7f93      	ldrb	r3, [r2, #30]
 80110b8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80110bc:	7793      	strb	r3, [r2, #30]
 80110be:	6828      	ldr	r0, [r5, #0]
 80110c0:	e7bf      	b.n	8011042 <lwip_setsockopt_internal+0x2e>
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %d\n",
                  s, sock->conn->pcb.ip->ttl));
      break;
    case IP_TOS:
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
 80110c2:	682b      	ldr	r3, [r5, #0]
 80110c4:	6822      	ldr	r2, [r4, #0]
 80110c6:	685b      	ldr	r3, [r3, #4]
 80110c8:	725a      	strb	r2, [r3, #9]
 80110ca:	6828      	ldr	r0, [r5, #0]
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TOS, ..)-> %d\n",
                  s, sock->conn->pcb.ip->tos));
      break;
 80110cc:	e7b9      	b.n	8011042 <lwip_setsockopt_internal+0x2e>
        }
      }
      break;
#endif /* LWIP_IGMP */
    default:
      LWIP_ASSERT("unhandled optname", 0);
 80110ce:	4b1d      	ldr	r3, [pc, #116]	; (8011144 <lwip_setsockopt_internal+0x130>)
 80110d0:	f640 0294 	movw	r2, #2196	; 0x894
 80110d4:	491e      	ldr	r1, [pc, #120]	; (8011150 <lwip_setsockopt_internal+0x13c>)
 80110d6:	481d      	ldr	r0, [pc, #116]	; (801114c <lwip_setsockopt_internal+0x138>)
 80110d8:	f003 fe4e 	bl	8014d78 <iprintf>
 80110dc:	6828      	ldr	r0, [r5, #0]
      break;
 80110de:	e7b0      	b.n	8011042 <lwip_setsockopt_internal+0x2e>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
 80110e0:	6823      	ldr	r3, [r4, #0]
 80110e2:	b1bb      	cbz	r3, 8011114 <lwip_setsockopt_internal+0x100>
        ip_set_option(sock->conn->pcb.ip, optname);
 80110e4:	682b      	ldr	r3, [r5, #0]
 80110e6:	685b      	ldr	r3, [r3, #4]
 80110e8:	7a19      	ldrb	r1, [r3, #8]
 80110ea:	430a      	orrs	r2, r1
 80110ec:	721a      	strb	r2, [r3, #8]
 80110ee:	6828      	ldr	r0, [r5, #0]
 80110f0:	e7a7      	b.n	8011042 <lwip_setsockopt_internal+0x2e>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_KEEPCNT) -> %"U32_F"\n",
                  s, sock->conn->pcb.tcp->keep_cnt));
      break;
#endif /* LWIP_TCP_KEEPALIVE */
    default:
      LWIP_ASSERT("unhandled optname", 0);
 80110f2:	4b14      	ldr	r3, [pc, #80]	; (8011144 <lwip_setsockopt_internal+0x130>)
 80110f4:	f640 02be 	movw	r2, #2238	; 0x8be
 80110f8:	4915      	ldr	r1, [pc, #84]	; (8011150 <lwip_setsockopt_internal+0x13c>)
 80110fa:	4814      	ldr	r0, [pc, #80]	; (801114c <lwip_setsockopt_internal+0x138>)
 80110fc:	f003 fe3c 	bl	8014d78 <iprintf>
 8011100:	6828      	ldr	r0, [r5, #0]
      break;
 8011102:	e79e      	b.n	8011042 <lwip_setsockopt_internal+0x2e>
#endif /* LWIP_DEBUG */
  int level, optname;
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
 8011104:	4b0f      	ldr	r3, [pc, #60]	; (8011144 <lwip_setsockopt_internal+0x130>)
 8011106:	f640 0222 	movw	r2, #2082	; 0x822
 801110a:	4912      	ldr	r1, [pc, #72]	; (8011154 <lwip_setsockopt_internal+0x140>)
 801110c:	480f      	ldr	r0, [pc, #60]	; (801114c <lwip_setsockopt_internal+0x138>)
 801110e:	f003 fe33 	bl	8014d78 <iprintf>
 8011112:	e783      	b.n	801101c <lwip_setsockopt_internal+0x8>
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
        ip_set_option(sock->conn->pcb.ip, optname);
      } else {
        ip_reset_option(sock->conn->pcb.ip, optname);
 8011114:	682b      	ldr	r3, [r5, #0]
 8011116:	6859      	ldr	r1, [r3, #4]
 8011118:	7a0b      	ldrb	r3, [r1, #8]
 801111a:	ea23 0202 	bic.w	r2, r3, r2
 801111e:	720a      	strb	r2, [r1, #8]
 8011120:	6828      	ldr	r0, [r5, #0]
 8011122:	e78e      	b.n	8011042 <lwip_setsockopt_internal+0x2e>
    switch (optname) {
    case TCP_NODELAY:
      if (*(int*)optval) {
        tcp_nagle_disable(sock->conn->pcb.tcp);
      } else {
        tcp_nagle_enable(sock->conn->pcb.tcp);
 8011124:	682b      	ldr	r3, [r5, #0]
 8011126:	685a      	ldr	r2, [r3, #4]
 8011128:	7f93      	ldrb	r3, [r2, #30]
 801112a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 801112e:	7793      	strb	r3, [r2, #30]
 8011130:	6828      	ldr	r0, [r5, #0]
 8011132:	e786      	b.n	8011042 <lwip_setsockopt_internal+0x2e>
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
 8011134:	682b      	ldr	r3, [r5, #0]
 8011136:	685a      	ldr	r2, [r3, #4]
 8011138:	7c13      	ldrb	r3, [r2, #16]
 801113a:	f023 0301 	bic.w	r3, r3, #1
 801113e:	7413      	strb	r3, [r2, #16]
 8011140:	6828      	ldr	r0, [r5, #0]
 8011142:	e77e      	b.n	8011042 <lwip_setsockopt_internal+0x2e>
 8011144:	08018078 	.word	0x08018078
 8011148:	080180bc 	.word	0x080180bc
 801114c:	0801660c 	.word	0x0801660c
 8011150:	080180a8 	.word	0x080180a8
 8011154:	0801809c 	.word	0x0801809c

08011158 <lwip_socket_init>:
 * Initialize this module. This function has to be called before any other
 * functions in this module!
 */
void
lwip_socket_init(void)
{
 8011158:	4770      	bx	lr
 801115a:	bf00      	nop

0801115c <lwip_accept>:
static struct lwip_sock *
get_socket(int s)
{
  struct lwip_sock *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
 801115c:	2803      	cmp	r0, #3
 801115e:	f200 8088 	bhi.w	8011272 <lwip_accept+0x116>
 * Exceptions are documented!
 */

int
lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
 8011162:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    return NULL;
  }

  sock = &sockets[s];

  if (!sock->conn) {
 8011166:	0047      	lsls	r7, r0, #1
 8011168:	183c      	adds	r4, r7, r0
 801116a:	4e6d      	ldr	r6, [pc, #436]	; (8011320 <lwip_accept+0x1c4>)
 801116c:	00e4      	lsls	r4, r4, #3
 801116e:	4603      	mov	r3, r0
 8011170:	5930      	ldr	r0, [r6, r4]
 * Exceptions are documented!
 */

int
lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
 8011172:	b089      	sub	sp, #36	; 0x24
    return NULL;
  }

  sock = &sockets[s];

  if (!sock->conn) {
 8011174:	4434      	add	r4, r6
 8011176:	2800      	cmp	r0, #0
 8011178:	f000 808c 	beq.w	8011294 <lwip_accept+0x138>
  sock = get_socket(s);
  if (!sock) {
    return -1;
  }

  if (netconn_is_nonblocking(sock->conn) && (sock->rcvevent <= 0)) {
 801117c:	f890 5098 	ldrb.w	r5, [r0, #152]	; 0x98
 8011180:	07ad      	lsls	r5, r5, #30
 8011182:	d504      	bpl.n	801118e <lwip_accept+0x32>
 8011184:	f9b4 500a 	ldrsh.w	r5, [r4, #10]
 8011188:	2d00      	cmp	r5, #0
 801118a:	f340 809f 	ble.w	80112cc <lwip_accept+0x170>
 801118e:	4688      	mov	r8, r1
    sock_set_errno(sock, EWOULDBLOCK);
    return -1;
  }

  /* wait for a new connection */
  err = netconn_accept(sock->conn, &newconn);
 8011190:	a902      	add	r1, sp, #8
 8011192:	4614      	mov	r4, r2
 8011194:	461d      	mov	r5, r3
 8011196:	f7fa fd9f 	bl	800bcd8 <netconn_accept>
  if (err != ERR_OK) {
 801119a:	2800      	cmp	r0, #0
 801119c:	d16c      	bne.n	8011278 <lwip_accept+0x11c>
      return EOPNOTSUPP;
    }
    sock_set_errno(sock, err_to_errno(err));
    return -1;
  }
  LWIP_ASSERT("newconn != NULL", newconn != NULL);
 801119e:	9b02      	ldr	r3, [sp, #8]
 80111a0:	2b00      	cmp	r3, #0
 80111a2:	f000 8082 	beq.w	80112aa <lwip_accept+0x14e>
  /* Prevent automatic window updates, we do this on our own! */
  netconn_set_noautorecved(newconn, 1);
 80111a6:	f893 2098 	ldrb.w	r2, [r3, #152]	; 0x98

  /* get the IP address and port of the remote host */
  err = netconn_peer(newconn, &naddr, &port);
 80111aa:	4618      	mov	r0, r3
    sock_set_errno(sock, err_to_errno(err));
    return -1;
  }
  LWIP_ASSERT("newconn != NULL", newconn != NULL);
  /* Prevent automatic window updates, we do this on our own! */
  netconn_set_noautorecved(newconn, 1);
 80111ac:	f042 0208 	orr.w	r2, r2, #8
 80111b0:	f883 2098 	strb.w	r2, [r3, #152]	; 0x98

  /* get the IP address and port of the remote host */
  err = netconn_peer(newconn, &naddr, &port);
 80111b4:	a903      	add	r1, sp, #12
 80111b6:	2300      	movs	r3, #0
 80111b8:	f10d 0206 	add.w	r2, sp, #6
 80111bc:	f7fa fca0 	bl	800bb00 <netconn_getaddr>
  if (err != ERR_OK) {
 80111c0:	4681      	mov	r9, r0
 80111c2:	2800      	cmp	r0, #0
 80111c4:	f040 8087 	bne.w	80112d6 <lwip_accept+0x17a>
  }

  /* Note that POSIX only requires us to check addr is non-NULL. addrlen must
   * not be NULL if addr is valid.
   */
  if (NULL != addr) {
 80111c8:	f1b8 0f00 	cmp.w	r8, #0
 80111cc:	d01f      	beq.n	801120e <lwip_accept+0xb2>
    LWIP_ASSERT("addr valid but addrlen NULL", addrlen != NULL);
 80111ce:	2c00      	cmp	r4, #0
 80111d0:	d074      	beq.n	80112bc <lwip_accept+0x160>
    memset(&sin, 0, sizeof(sin));
 80111d2:	2210      	movs	r2, #16
 80111d4:	2100      	movs	r1, #0
 80111d6:	a804      	add	r0, sp, #16
 80111d8:	f003 fdc6 	bl	8014d68 <memset>
    sin.sin_len = sizeof(sin);
 80111dc:	f04f 0910 	mov.w	r9, #16
    sin.sin_family = AF_INET;
 80111e0:	2302      	movs	r3, #2
    sin.sin_port = htons(port);
 80111e2:	f8bd 0006 	ldrh.w	r0, [sp, #6]
   */
  if (NULL != addr) {
    LWIP_ASSERT("addr valid but addrlen NULL", addrlen != NULL);
    memset(&sin, 0, sizeof(sin));
    sin.sin_len = sizeof(sin);
    sin.sin_family = AF_INET;
 80111e6:	f88d 3011 	strb.w	r3, [sp, #17]
   * not be NULL if addr is valid.
   */
  if (NULL != addr) {
    LWIP_ASSERT("addr valid but addrlen NULL", addrlen != NULL);
    memset(&sin, 0, sizeof(sin));
    sin.sin_len = sizeof(sin);
 80111ea:	f88d 9010 	strb.w	r9, [sp, #16]
    sin.sin_family = AF_INET;
    sin.sin_port = htons(port);
 80111ee:	f7fc fcd3 	bl	800db98 <lwip_htons>
    inet_addr_from_ipaddr(&sin.sin_addr, &naddr);

    if (*addrlen > sizeof(sin))
 80111f2:	6822      	ldr	r2, [r4, #0]
    LWIP_ASSERT("addr valid but addrlen NULL", addrlen != NULL);
    memset(&sin, 0, sizeof(sin));
    sin.sin_len = sizeof(sin);
    sin.sin_family = AF_INET;
    sin.sin_port = htons(port);
    inet_addr_from_ipaddr(&sin.sin_addr, &naddr);
 80111f4:	9b03      	ldr	r3, [sp, #12]

    if (*addrlen > sizeof(sin))
 80111f6:	454a      	cmp	r2, r9
  if (NULL != addr) {
    LWIP_ASSERT("addr valid but addrlen NULL", addrlen != NULL);
    memset(&sin, 0, sizeof(sin));
    sin.sin_len = sizeof(sin);
    sin.sin_family = AF_INET;
    sin.sin_port = htons(port);
 80111f8:	f8ad 0012 	strh.w	r0, [sp, #18]
    inet_addr_from_ipaddr(&sin.sin_addr, &naddr);

    if (*addrlen > sizeof(sin))
      *addrlen = sizeof(sin);
 80111fc:	bf84      	itt	hi
 80111fe:	464a      	movhi	r2, r9
 8011200:	f8c4 9000 	strhi.w	r9, [r4]

    MEMCPY(addr, &sin, *addrlen);
 8011204:	a904      	add	r1, sp, #16
 8011206:	4640      	mov	r0, r8
    LWIP_ASSERT("addr valid but addrlen NULL", addrlen != NULL);
    memset(&sin, 0, sizeof(sin));
    sin.sin_len = sizeof(sin);
    sin.sin_family = AF_INET;
    sin.sin_port = htons(port);
    inet_addr_from_ipaddr(&sin.sin_addr, &naddr);
 8011208:	9305      	str	r3, [sp, #20]

    if (*addrlen > sizeof(sin))
      *addrlen = sizeof(sin);

    MEMCPY(addr, &sin, *addrlen);
 801120a:	f003 fda2 	bl	8014d52 <memcpy>
  }

  newsock = alloc_socket(newconn, 1);
 801120e:	2101      	movs	r1, #1
 8011210:	9802      	ldr	r0, [sp, #8]
 8011212:	f7ff fc81 	bl	8010b18 <alloc_socket>
  if (newsock == -1) {
 8011216:	1c43      	adds	r3, r0, #1
      *addrlen = sizeof(sin);

    MEMCPY(addr, &sin, *addrlen);
  }

  newsock = alloc_socket(newconn, 1);
 8011218:	4604      	mov	r4, r0
  if (newsock == -1) {
 801121a:	d077      	beq.n	801130c <lwip_accept+0x1b0>
    netconn_delete(newconn);
    sock_set_errno(sock, ENFILE);
    return -1;
  }
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
 801121c:	2803      	cmp	r0, #3
 801121e:	d83c      	bhi.n	801129a <lwip_accept+0x13e>
  LWIP_ASSERT("newconn->callback == event_callback", newconn->callback == event_callback);
 8011220:	9a02      	ldr	r2, [sp, #8]
 8011222:	4b40      	ldr	r3, [pc, #256]	; (8011324 <lwip_accept+0x1c8>)
 8011224:	f8d2 20a4 	ldr.w	r2, [r2, #164]	; 0xa4
 8011228:	429a      	cmp	r2, r3
 801122a:	d006      	beq.n	801123a <lwip_accept+0xde>
 801122c:	4b3e      	ldr	r3, [pc, #248]	; (8011328 <lwip_accept+0x1cc>)
 801122e:	f240 127f 	movw	r2, #383	; 0x17f
 8011232:	493e      	ldr	r1, [pc, #248]	; (801132c <lwip_accept+0x1d0>)
 8011234:	483e      	ldr	r0, [pc, #248]	; (8011330 <lwip_accept+0x1d4>)
 8011236:	f003 fd9f 	bl	8014d78 <iprintf>
  /* See event_callback: If data comes in right away after an accept, even
   * though the server task might not have created a new socket yet.
   * In that case, newconn->socket is counted down (newconn->socket--),
   * so nsock->rcvevent is >= 1 here!
   */
  SYS_ARCH_PROTECT(lev);
 801123a:	f7f0 fa9b 	bl	8001774 <CPU_SR_Save>
  nsock->rcvevent += (s16_t)(-1 - newconn->socket);
 801123e:	eb04 0144 	add.w	r1, r4, r4, lsl #1
 8011242:	eb06 0ec1 	add.w	lr, r6, r1, lsl #3
 8011246:	9a02      	ldr	r2, [sp, #8]
 8011248:	f8be 300a 	ldrh.w	r3, [lr, #10]
 801124c:	f8d2 1094 	ldr.w	r1, [r2, #148]	; 0x94
 8011250:	3b01      	subs	r3, #1
 8011252:	1a5b      	subs	r3, r3, r1
  newconn->socket = newsock;
 8011254:	f8c2 4094 	str.w	r4, [r2, #148]	; 0x94
   * though the server task might not have created a new socket yet.
   * In that case, newconn->socket is counted down (newconn->socket--),
   * so nsock->rcvevent is >= 1 here!
   */
  SYS_ARCH_PROTECT(lev);
  nsock->rcvevent += (s16_t)(-1 - newconn->socket);
 8011258:	f8ae 300a 	strh.w	r3, [lr, #10]
  newconn->socket = newsock;
  SYS_ARCH_UNPROTECT(lev);
 801125c:	f7f0 fa8e 	bl	800177c <CPU_SR_Restore>
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d addr=", s, newsock));
  ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F"\n", port));

  sock_set_errno(sock, 0);
  return newsock;
 8011260:	4620      	mov	r0, r4

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d addr=", s, newsock));
  ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F"\n", port));

  sock_set_errno(sock, 0);
 8011262:	197b      	adds	r3, r7, r5
 8011264:	eb06 03c3 	add.w	r3, r6, r3, lsl #3
 8011268:	2200      	movs	r2, #0
 801126a:	611a      	str	r2, [r3, #16]
  return newsock;
}
 801126c:	b009      	add	sp, #36	; 0x24
 801126e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  SYS_ARCH_DECL_PROTECT(lev);

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
  if (!sock) {
    return -1;
 8011272:	f04f 30ff 	mov.w	r0, #4294967295
  ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F"\n", port));

  sock_set_errno(sock, 0);
  return newsock;
}
 8011276:	4770      	bx	lr

  /* wait for a new connection */
  err = netconn_accept(sock->conn, &newconn);
  if (err != ERR_OK) {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d): netconn_acept failed, err=%d\n", s, err));
    if (netconn_type(sock->conn) != NETCONN_TCP) {
 8011278:	197b      	adds	r3, r7, r5
 801127a:	00db      	lsls	r3, r3, #3
 801127c:	58f2      	ldr	r2, [r6, r3]
 801127e:	4928      	ldr	r1, [pc, #160]	; (8011320 <lwip_accept+0x1c4>)
 8011280:	7812      	ldrb	r2, [r2, #0]
 8011282:	2a10      	cmp	r2, #16
 8011284:	d03b      	beq.n	80112fe <lwip_accept+0x1a2>
      sock_set_errno(sock, EOPNOTSUPP);
 8011286:	245f      	movs	r4, #95	; 0x5f
      return EOPNOTSUPP;
 8011288:	4620      	mov	r0, r4
  /* wait for a new connection */
  err = netconn_accept(sock->conn, &newconn);
  if (err != ERR_OK) {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d): netconn_acept failed, err=%d\n", s, err));
    if (netconn_type(sock->conn) != NETCONN_TCP) {
      sock_set_errno(sock, EOPNOTSUPP);
 801128a:	440b      	add	r3, r1
 801128c:	611c      	str	r4, [r3, #16]
  ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F"\n", port));

  sock_set_errno(sock, 0);
  return newsock;
}
 801128e:	b009      	add	sp, #36	; 0x24
 8011290:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  SYS_ARCH_DECL_PROTECT(lev);

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
  if (!sock) {
    return -1;
 8011294:	f04f 30ff 	mov.w	r0, #4294967295
 8011298:	e7e8      	b.n	801126c <lwip_accept+0x110>
  if (newsock == -1) {
    netconn_delete(newconn);
    sock_set_errno(sock, ENFILE);
    return -1;
  }
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
 801129a:	4b23      	ldr	r3, [pc, #140]	; (8011328 <lwip_accept+0x1cc>)
 801129c:	f44f 72bf 	mov.w	r2, #382	; 0x17e
 80112a0:	4924      	ldr	r1, [pc, #144]	; (8011334 <lwip_accept+0x1d8>)
 80112a2:	4823      	ldr	r0, [pc, #140]	; (8011330 <lwip_accept+0x1d4>)
 80112a4:	f003 fd68 	bl	8014d78 <iprintf>
 80112a8:	e7ba      	b.n	8011220 <lwip_accept+0xc4>
      return EOPNOTSUPP;
    }
    sock_set_errno(sock, err_to_errno(err));
    return -1;
  }
  LWIP_ASSERT("newconn != NULL", newconn != NULL);
 80112aa:	4b1f      	ldr	r3, [pc, #124]	; (8011328 <lwip_accept+0x1cc>)
 80112ac:	f44f 72ad 	mov.w	r2, #346	; 0x15a
 80112b0:	4921      	ldr	r1, [pc, #132]	; (8011338 <lwip_accept+0x1dc>)
 80112b2:	481f      	ldr	r0, [pc, #124]	; (8011330 <lwip_accept+0x1d4>)
 80112b4:	f003 fd60 	bl	8014d78 <iprintf>
 80112b8:	9b02      	ldr	r3, [sp, #8]
 80112ba:	e774      	b.n	80111a6 <lwip_accept+0x4a>

  /* Note that POSIX only requires us to check addr is non-NULL. addrlen must
   * not be NULL if addr is valid.
   */
  if (NULL != addr) {
    LWIP_ASSERT("addr valid but addrlen NULL", addrlen != NULL);
 80112bc:	4b1a      	ldr	r3, [pc, #104]	; (8011328 <lwip_accept+0x1cc>)
 80112be:	f240 126b 	movw	r2, #363	; 0x16b
 80112c2:	491e      	ldr	r1, [pc, #120]	; (801133c <lwip_accept+0x1e0>)
 80112c4:	481a      	ldr	r0, [pc, #104]	; (8011330 <lwip_accept+0x1d4>)
 80112c6:	f003 fd57 	bl	8014d78 <iprintf>
 80112ca:	e782      	b.n	80111d2 <lwip_accept+0x76>
    return -1;
  }

  if (netconn_is_nonblocking(sock->conn) && (sock->rcvevent <= 0)) {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d): returning EWOULDBLOCK\n", s));
    sock_set_errno(sock, EWOULDBLOCK);
 80112cc:	230b      	movs	r3, #11
 80112ce:	6123      	str	r3, [r4, #16]
    return -1;
 80112d0:	f04f 30ff 	mov.w	r0, #4294967295
 80112d4:	e7ca      	b.n	801126c <lwip_accept+0x110>

  /* get the IP address and port of the remote host */
  err = netconn_peer(newconn, &naddr, &port);
  if (err != ERR_OK) {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d): netconn_peer failed, err=%d\n", s, err));
    netconn_delete(newconn);
 80112d6:	9802      	ldr	r0, [sp, #8]
    sock_set_errno(sock, err_to_errno(err));
 80112d8:	f1c9 0900 	rsb	r9, r9, #0

  /* get the IP address and port of the remote host */
  err = netconn_peer(newconn, &naddr, &port);
  if (err != ERR_OK) {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d): netconn_peer failed, err=%d\n", s, err));
    netconn_delete(newconn);
 80112dc:	f7fa fbfc 	bl	800bad8 <netconn_delete>
    sock_set_errno(sock, err_to_errno(err));
 80112e0:	f1b9 0f0f 	cmp.w	r9, #15
 80112e4:	d809      	bhi.n	80112fa <lwip_accept+0x19e>
 80112e6:	4b16      	ldr	r3, [pc, #88]	; (8011340 <lwip_accept+0x1e4>)
 80112e8:	f853 2029 	ldr.w	r2, [r3, r9, lsl #2]
 80112ec:	197b      	adds	r3, r7, r5
 80112ee:	eb06 03c3 	add.w	r3, r6, r3, lsl #3
 80112f2:	611a      	str	r2, [r3, #16]
    return -1;
 80112f4:	f04f 30ff 	mov.w	r0, #4294967295
 80112f8:	e7b8      	b.n	801126c <lwip_accept+0x110>
  /* get the IP address and port of the remote host */
  err = netconn_peer(newconn, &naddr, &port);
  if (err != ERR_OK) {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d): netconn_peer failed, err=%d\n", s, err));
    netconn_delete(newconn);
    sock_set_errno(sock, err_to_errno(err));
 80112fa:	2205      	movs	r2, #5
 80112fc:	e7f6      	b.n	80112ec <lwip_accept+0x190>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d): netconn_acept failed, err=%d\n", s, err));
    if (netconn_type(sock->conn) != NETCONN_TCP) {
      sock_set_errno(sock, EOPNOTSUPP);
      return EOPNOTSUPP;
    }
    sock_set_errno(sock, err_to_errno(err));
 80112fe:	4240      	negs	r0, r0
 8011300:	280f      	cmp	r0, #15
 8011302:	d8fa      	bhi.n	80112fa <lwip_accept+0x19e>
 8011304:	4b0e      	ldr	r3, [pc, #56]	; (8011340 <lwip_accept+0x1e4>)
 8011306:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
 801130a:	e7ef      	b.n	80112ec <lwip_accept+0x190>
    MEMCPY(addr, &sin, *addrlen);
  }

  newsock = alloc_socket(newconn, 1);
  if (newsock == -1) {
    netconn_delete(newconn);
 801130c:	9802      	ldr	r0, [sp, #8]
 801130e:	f7fa fbe3 	bl	800bad8 <netconn_delete>
    sock_set_errno(sock, ENFILE);
 8011312:	197b      	adds	r3, r7, r5
 8011314:	eb06 03c3 	add.w	r3, r6, r3, lsl #3
 8011318:	2217      	movs	r2, #23
    return -1;
 801131a:	4620      	mov	r0, r4
  }

  newsock = alloc_socket(newconn, 1);
  if (newsock == -1) {
    netconn_delete(newconn);
    sock_set_errno(sock, ENFILE);
 801131c:	611a      	str	r2, [r3, #16]
    return -1;
 801131e:	e7a5      	b.n	801126c <lwip_accept+0x110>
 8011320:	20004c40 	.word	0x20004c40
 8011324:	08010d35 	.word	0x08010d35
 8011328:	08018078 	.word	0x08018078
 801132c:	08018110 	.word	0x08018110
 8011330:	0801660c 	.word	0x0801660c
 8011334:	080180f8 	.word	0x080180f8
 8011338:	080180cc 	.word	0x080180cc
 801133c:	080180dc 	.word	0x080180dc
 8011340:	080161e4 	.word	0x080161e4

08011344 <lwip_bind>:
static struct lwip_sock *
get_socket(int s)
{
  struct lwip_sock *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
 8011344:	2803      	cmp	r0, #3
 8011346:	d827      	bhi.n	8011398 <lwip_bind+0x54>
  return newsock;
}

int
lwip_bind(int s, const struct sockaddr *name, socklen_t namelen)
{
 8011348:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    return NULL;
  }

  sock = &sockets[s];

  if (!sock->conn) {
 801134c:	0046      	lsls	r6, r0, #1
 801134e:	1837      	adds	r7, r6, r0
 8011350:	4d24      	ldr	r5, [pc, #144]	; (80113e4 <lwip_bind+0xa0>)
 8011352:	00ff      	lsls	r7, r7, #3
 8011354:	f855 8007 	ldr.w	r8, [r5, r7]
  return newsock;
}

int
lwip_bind(int s, const struct sockaddr *name, socklen_t namelen)
{
 8011358:	b083      	sub	sp, #12
    return NULL;
  }

  sock = &sockets[s];

  if (!sock->conn) {
 801135a:	f1b8 0f00 	cmp.w	r8, #0
 801135e:	d02f      	beq.n	80113c0 <lwip_bind+0x7c>
  if (!sock) {
    return -1;
  }

  /* check size, familiy and alignment of 'name' */
  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
 8011360:	2a10      	cmp	r2, #16
 8011362:	460b      	mov	r3, r1
 8011364:	4604      	mov	r4, r0
 8011366:	d11a      	bne.n	801139e <lwip_bind+0x5a>
 8011368:	785a      	ldrb	r2, [r3, #1]
 801136a:	2a02      	cmp	r2, #2
 801136c:	d117      	bne.n	801139e <lwip_bind+0x5a>
 801136e:	079a      	lsls	r2, r3, #30
 8011370:	d115      	bne.n	801139e <lwip_bind+0x5a>
             ((name->sa_family) == AF_INET) && ((((mem_ptr_t)name) % 4) == 0)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);
  name_in = (const struct sockaddr_in *)(void*)name;

  inet_addr_to_ipaddr(&local_addr, &name_in->sin_addr);
 8011372:	685a      	ldr	r2, [r3, #4]
 8011374:	f10d 0908 	add.w	r9, sp, #8

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d, addr=", s));
  ip_addr_debug_print(SOCKETS_DEBUG, &local_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F")\n", ntohs(local_port)));

  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
 8011378:	8858      	ldrh	r0, [r3, #2]
  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
             ((name->sa_family) == AF_INET) && ((((mem_ptr_t)name) % 4) == 0)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);
  name_in = (const struct sockaddr_in *)(void*)name;

  inet_addr_to_ipaddr(&local_addr, &name_in->sin_addr);
 801137a:	f849 2d04 	str.w	r2, [r9, #-4]!

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d, addr=", s));
  ip_addr_debug_print(SOCKETS_DEBUG, &local_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F")\n", ntohs(local_port)));

  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
 801137e:	f7fc fc0f 	bl	800dba0 <lwip_ntohs>
 8011382:	4649      	mov	r1, r9
 8011384:	4602      	mov	r2, r0
 8011386:	4640      	mov	r0, r8
 8011388:	f7fa fbfe 	bl	800bb88 <netconn_bind>

  if (err != ERR_OK) {
 801138c:	b9d8      	cbnz	r0, 80113c6 <lwip_bind+0x82>
    sock_set_errno(sock, err_to_errno(err));
    return -1;
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
 801138e:	443d      	add	r5, r7
 8011390:	6128      	str	r0, [r5, #16]
  return 0;
}
 8011392:	b003      	add	sp, #12
 8011394:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  err_t err;
  const struct sockaddr_in *name_in;

  sock = get_socket(s);
  if (!sock) {
    return -1;
 8011398:	f04f 30ff 	mov.w	r0, #4294967295
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  return 0;
}
 801139c:	4770      	bx	lr
  if (!sock) {
    return -1;
  }

  /* check size, familiy and alignment of 'name' */
  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
 801139e:	4b12      	ldr	r3, [pc, #72]	; (80113e8 <lwip_bind+0xa4>)
 80113a0:	f240 12a5 	movw	r2, #421	; 0x1a5
 80113a4:	4911      	ldr	r1, [pc, #68]	; (80113ec <lwip_bind+0xa8>)
 80113a6:	4812      	ldr	r0, [pc, #72]	; (80113f0 <lwip_bind+0xac>)
 80113a8:	f003 fce6 	bl	8014d78 <iprintf>
 80113ac:	4434      	add	r4, r6
 80113ae:	eb05 05c4 	add.w	r5, r5, r4, lsl #3
 80113b2:	2305      	movs	r3, #5
 80113b4:	f04f 30ff 	mov.w	r0, #4294967295
 80113b8:	612b      	str	r3, [r5, #16]
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  return 0;
}
 80113ba:	b003      	add	sp, #12
 80113bc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  err_t err;
  const struct sockaddr_in *name_in;

  sock = get_socket(s);
  if (!sock) {
    return -1;
 80113c0:	f04f 30ff 	mov.w	r0, #4294967295
 80113c4:	e7e5      	b.n	8011392 <lwip_bind+0x4e>

  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));

  if (err != ERR_OK) {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
 80113c6:	4243      	negs	r3, r0
 80113c8:	2b0f      	cmp	r3, #15
 80113ca:	bf98      	it	ls
 80113cc:	4a09      	ldrls	r2, [pc, #36]	; (80113f4 <lwip_bind+0xb0>)
 80113ce:	4434      	add	r4, r6
 80113d0:	bf94      	ite	ls
 80113d2:	f852 3023 	ldrls.w	r3, [r2, r3, lsl #2]
 80113d6:	2305      	movhi	r3, #5
 80113d8:	eb05 05c4 	add.w	r5, r5, r4, lsl #3
 80113dc:	612b      	str	r3, [r5, #16]
    return -1;
 80113de:	f04f 30ff 	mov.w	r0, #4294967295
 80113e2:	e7d6      	b.n	8011392 <lwip_bind+0x4e>
 80113e4:	20004c40 	.word	0x20004c40
 80113e8:	08018078 	.word	0x08018078
 80113ec:	08018134 	.word	0x08018134
 80113f0:	0801660c 	.word	0x0801660c
 80113f4:	080161e4 	.word	0x080161e4

080113f8 <lwip_close>:
static struct lwip_sock *
get_socket(int s)
{
  struct lwip_sock *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
 80113f8:	2803      	cmp	r0, #3
 80113fa:	d825      	bhi.n	8011448 <lwip_close+0x50>
  return 0;
}

int
lwip_close(int s)
{
 80113fc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    return NULL;
  }

  sock = &sockets[s];

  if (!sock->conn) {
 8011400:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 8011404:	f8df 805c 	ldr.w	r8, [pc, #92]	; 8011464 <lwip_close+0x6c>
 8011408:	00c5      	lsls	r5, r0, #3
 801140a:	f858 3005 	ldr.w	r3, [r8, r5]
 801140e:	eb08 0605 	add.w	r6, r8, r5
 8011412:	b30b      	cbz	r3, 8011458 <lwip_close+0x60>
{
  void *lastdata;
  SYS_ARCH_DECL_PROTECT(lev);

  lastdata         = sock->lastdata;
  sock->lastdata   = NULL;
 8011414:	2400      	movs	r4, #0
    is_tcp = netconn_type(sock->conn) == NETCONN_TCP;
  } else {
    LWIP_ASSERT("sock->lastdata == NULL", sock->lastdata == NULL);
  }

  netconn_delete(sock->conn);
 8011416:	4618      	mov	r0, r3
  if (!sock) {
    return -1;
  }

  if(sock->conn != NULL) {
    is_tcp = netconn_type(sock->conn) == NETCONN_TCP;
 8011418:	f893 9000 	ldrb.w	r9, [r3]
  } else {
    LWIP_ASSERT("sock->lastdata == NULL", sock->lastdata == NULL);
  }

  netconn_delete(sock->conn);
 801141c:	f7fa fb5c 	bl	800bad8 <netconn_delete>
free_socket(struct lwip_sock *sock, int is_tcp)
{
  void *lastdata;
  SYS_ARCH_DECL_PROTECT(lev);

  lastdata         = sock->lastdata;
 8011420:	6877      	ldr	r7, [r6, #4]
  sock->lastdata   = NULL;
  sock->lastoffset = 0;
 8011422:	8134      	strh	r4, [r6, #8]
{
  void *lastdata;
  SYS_ARCH_DECL_PROTECT(lev);

  lastdata         = sock->lastdata;
  sock->lastdata   = NULL;
 8011424:	6074      	str	r4, [r6, #4]
  sock->lastoffset = 0;
  sock->err        = 0;
 8011426:	6134      	str	r4, [r6, #16]

  /* Protect socket array */
  SYS_ARCH_PROTECT(lev);
 8011428:	f7f0 f9a4 	bl	8001774 <CPU_SR_Save>
  sock->conn       = NULL;
 801142c:	f848 4005 	str.w	r4, [r8, r5]
  SYS_ARCH_UNPROTECT(lev);
 8011430:	f7f0 f9a4 	bl	800177c <CPU_SR_Restore>
  /* don't use 'sock' after this line, as another task might have allocated it */

  if (lastdata != NULL) {
    if (is_tcp) {
      pbuf_free((struct pbuf *)lastdata);
 8011434:	4638      	mov	r0, r7
  SYS_ARCH_PROTECT(lev);
  sock->conn       = NULL;
  SYS_ARCH_UNPROTECT(lev);
  /* don't use 'sock' after this line, as another task might have allocated it */

  if (lastdata != NULL) {
 8011436:	b19f      	cbz	r7, 8011460 <lwip_close+0x68>
    if (is_tcp) {
 8011438:	f1b9 0f10 	cmp.w	r9, #16
 801143c:	d007      	beq.n	801144e <lwip_close+0x56>
      pbuf_free((struct pbuf *)lastdata);
    } else {
      netbuf_delete((struct netbuf *)lastdata);
 801143e:	f7fe fc8f 	bl	800fd60 <netbuf_delete>

  netconn_delete(sock->conn);

  free_socket(sock, is_tcp);
  set_errno(0);
  return 0;
 8011442:	4620      	mov	r0, r4
 8011444:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
  if (!sock) {
    return -1;
 8011448:	f04f 30ff 	mov.w	r0, #4294967295
  netconn_delete(sock->conn);

  free_socket(sock, is_tcp);
  set_errno(0);
  return 0;
}
 801144c:	4770      	bx	lr
  SYS_ARCH_UNPROTECT(lev);
  /* don't use 'sock' after this line, as another task might have allocated it */

  if (lastdata != NULL) {
    if (is_tcp) {
      pbuf_free((struct pbuf *)lastdata);
 801144e:	f7fe fdeb 	bl	8010028 <pbuf_free>

  netconn_delete(sock->conn);

  free_socket(sock, is_tcp);
  set_errno(0);
  return 0;
 8011452:	4620      	mov	r0, r4
 8011454:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
  if (!sock) {
    return -1;
 8011458:	f04f 30ff 	mov.w	r0, #4294967295
 801145c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  netconn_delete(sock->conn);

  free_socket(sock, is_tcp);
  set_errno(0);
  return 0;
}
 8011460:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8011464:	20004c40 	.word	0x20004c40

08011468 <lwip_connect>:
static struct lwip_sock *
get_socket(int s)
{
  struct lwip_sock *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
 8011468:	2803      	cmp	r0, #3
 801146a:	d827      	bhi.n	80114bc <lwip_connect+0x54>
  return 0;
}

int
lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
 801146c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    return NULL;
  }

  sock = &sockets[s];

  if (!sock->conn) {
 8011470:	0046      	lsls	r6, r0, #1
 8011472:	1837      	adds	r7, r6, r0
 8011474:	4d24      	ldr	r5, [pc, #144]	; (8011508 <lwip_connect+0xa0>)
 8011476:	00ff      	lsls	r7, r7, #3
 8011478:	f855 8007 	ldr.w	r8, [r5, r7]
  return 0;
}

int
lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
 801147c:	b083      	sub	sp, #12
    return NULL;
  }

  sock = &sockets[s];

  if (!sock->conn) {
 801147e:	f1b8 0f00 	cmp.w	r8, #0
 8011482:	d01e      	beq.n	80114c2 <lwip_connect+0x5a>
  if (!sock) {
    return -1;
  }

  /* check size, familiy and alignment of 'name' */
  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
 8011484:	2a10      	cmp	r2, #16
 8011486:	460b      	mov	r3, r1
 8011488:	4604      	mov	r4, r0
 801148a:	d11d      	bne.n	80114c8 <lwip_connect+0x60>
 801148c:	785a      	ldrb	r2, [r3, #1]
 801148e:	2a02      	cmp	r2, #2
 8011490:	d11a      	bne.n	80114c8 <lwip_connect+0x60>
 8011492:	079a      	lsls	r2, r3, #30
 8011494:	d118      	bne.n	80114c8 <lwip_connect+0x60>
    err = netconn_disconnect(sock->conn);
  } else {
    ip_addr_t remote_addr;
    u16_t remote_port;

    inet_addr_to_ipaddr(&remote_addr, &name_in->sin_addr);
 8011496:	685a      	ldr	r2, [r3, #4]
 8011498:	f10d 0908 	add.w	r9, sp, #8

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, addr=", s));
    ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F")\n", ntohs(remote_port)));

    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
 801149c:	8858      	ldrh	r0, [r3, #2]
    err = netconn_disconnect(sock->conn);
  } else {
    ip_addr_t remote_addr;
    u16_t remote_port;

    inet_addr_to_ipaddr(&remote_addr, &name_in->sin_addr);
 801149e:	f849 2d04 	str.w	r2, [r9, #-4]!

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, addr=", s));
    ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%"U16_F")\n", ntohs(remote_port)));

    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
 80114a2:	f7fc fb7d 	bl	800dba0 <lwip_ntohs>
 80114a6:	4649      	mov	r1, r9
 80114a8:	4602      	mov	r2, r0
 80114aa:	4640      	mov	r0, r8
 80114ac:	f7fa fb98 	bl	800bbe0 <netconn_connect>
  }

  if (err != ERR_OK) {
 80114b0:	b9d8      	cbnz	r0, 80114ea <lwip_connect+0x82>
    sock_set_errno(sock, err_to_errno(err));
    return -1;
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
 80114b2:	443d      	add	r5, r7
 80114b4:	6128      	str	r0, [r5, #16]
  return 0;
}
 80114b6:	b003      	add	sp, #12
 80114b8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  err_t err;
  const struct sockaddr_in *name_in;

  sock = get_socket(s);
  if (!sock) {
    return -1;
 80114bc:	f04f 30ff 	mov.w	r0, #4294967295
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  return 0;
}
 80114c0:	4770      	bx	lr
  err_t err;
  const struct sockaddr_in *name_in;

  sock = get_socket(s);
  if (!sock) {
    return -1;
 80114c2:	f04f 30ff 	mov.w	r0, #4294967295
 80114c6:	e7f6      	b.n	80114b6 <lwip_connect+0x4e>
  }

  /* check size, familiy and alignment of 'name' */
  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
 80114c8:	4b10      	ldr	r3, [pc, #64]	; (801150c <lwip_connect+0xa4>)
 80114ca:	f240 12e5 	movw	r2, #485	; 0x1e5
 80114ce:	4910      	ldr	r1, [pc, #64]	; (8011510 <lwip_connect+0xa8>)
 80114d0:	4810      	ldr	r0, [pc, #64]	; (8011514 <lwip_connect+0xac>)
 80114d2:	f003 fc51 	bl	8014d78 <iprintf>
 80114d6:	4434      	add	r4, r6
 80114d8:	eb05 05c4 	add.w	r5, r5, r4, lsl #3
 80114dc:	2305      	movs	r3, #5
 80114de:	f04f 30ff 	mov.w	r0, #4294967295
 80114e2:	612b      	str	r3, [r5, #16]
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  return 0;
}
 80114e4:	b003      	add	sp, #12
 80114e6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
  }

  if (err != ERR_OK) {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
 80114ea:	4243      	negs	r3, r0
 80114ec:	2b0f      	cmp	r3, #15
 80114ee:	bf98      	it	ls
 80114f0:	4a09      	ldrls	r2, [pc, #36]	; (8011518 <lwip_connect+0xb0>)
 80114f2:	4434      	add	r4, r6
 80114f4:	bf94      	ite	ls
 80114f6:	f852 3023 	ldrls.w	r3, [r2, r3, lsl #2]
 80114fa:	2305      	movhi	r3, #5
 80114fc:	eb05 05c4 	add.w	r5, r5, r4, lsl #3
 8011500:	612b      	str	r3, [r5, #16]
    return -1;
 8011502:	f04f 30ff 	mov.w	r0, #4294967295
 8011506:	e7d6      	b.n	80114b6 <lwip_connect+0x4e>
 8011508:	20004c40 	.word	0x20004c40
 801150c:	08018078 	.word	0x08018078
 8011510:	08018150 	.word	0x08018150
 8011514:	0801660c 	.word	0x0801660c
 8011518:	080161e4 	.word	0x080161e4

0801151c <lwip_listen>:
static struct lwip_sock *
get_socket(int s)
{
  struct lwip_sock *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
 801151c:	2803      	cmp	r0, #3
 801151e:	d819      	bhi.n	8011554 <lwip_listen+0x38>
 * @param backlog (ATTENTION: needs TCP_LISTEN_BACKLOG=1)
 * @return 0 on success, non-zero on failure
 */
int
lwip_listen(int s, int backlog)
{
 8011520:	b570      	push	{r4, r5, r6, lr}
    return NULL;
  }

  sock = &sockets[s];

  if (!sock->conn) {
 8011522:	0046      	lsls	r6, r0, #1
 8011524:	4d1d      	ldr	r5, [pc, #116]	; (801159c <lwip_listen+0x80>)
 8011526:	1833      	adds	r3, r6, r0
 8011528:	f855 3033 	ldr.w	r3, [r5, r3, lsl #3]
 801152c:	b31b      	cbz	r3, 8011576 <lwip_listen+0x5a>
  if (!sock) {
    return -1;
  }

  /* limit the "backlog" parameter to fit in an u8_t */
  backlog = LWIP_MIN(LWIP_MAX(backlog, 0), 0xff);
 801152e:	29fe      	cmp	r1, #254	; 0xfe
 8011530:	dd13      	ble.n	801155a <lwip_listen+0x3e>
 8011532:	4604      	mov	r4, r0
 8011534:	21ff      	movs	r1, #255	; 0xff

  err = netconn_listen_with_backlog(sock->conn, (u8_t)backlog);
 8011536:	4618      	mov	r0, r3
 8011538:	f7fa fba6 	bl	800bc88 <netconn_listen_with_backlog>

  if (err != ERR_OK) {
 801153c:	b1b0      	cbz	r0, 801156c <lwip_listen+0x50>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
    if (netconn_type(sock->conn) != NETCONN_TCP) {
 801153e:	1933      	adds	r3, r6, r4
 8011540:	00db      	lsls	r3, r3, #3
 8011542:	58ea      	ldr	r2, [r5, r3]
 8011544:	4915      	ldr	r1, [pc, #84]	; (801159c <lwip_listen+0x80>)
 8011546:	7812      	ldrb	r2, [r2, #0]
 8011548:	2a10      	cmp	r2, #16
 801154a:	d017      	beq.n	801157c <lwip_listen+0x60>
      sock_set_errno(sock, EOPNOTSUPP);
 801154c:	440b      	add	r3, r1
 801154e:	205f      	movs	r0, #95	; 0x5f
 8011550:	6118      	str	r0, [r3, #16]
      return EOPNOTSUPP;
 8011552:	bd70      	pop	{r4, r5, r6, pc}

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
  if (!sock) {
    return -1;
 8011554:	f04f 30ff 	mov.w	r0, #4294967295
    return -1;
  }

  sock_set_errno(sock, 0);
  return 0;
}
 8011558:	4770      	bx	lr
 801155a:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
 801155e:	4604      	mov	r4, r0
 8011560:	b2c9      	uxtb	r1, r1
  }

  /* limit the "backlog" parameter to fit in an u8_t */
  backlog = LWIP_MIN(LWIP_MAX(backlog, 0), 0xff);

  err = netconn_listen_with_backlog(sock->conn, (u8_t)backlog);
 8011562:	4618      	mov	r0, r3
 8011564:	f7fa fb90 	bl	800bc88 <netconn_listen_with_backlog>

  if (err != ERR_OK) {
 8011568:	2800      	cmp	r0, #0
 801156a:	d1e8      	bne.n	801153e <lwip_listen+0x22>
    }
    sock_set_errno(sock, err_to_errno(err));
    return -1;
  }

  sock_set_errno(sock, 0);
 801156c:	4434      	add	r4, r6
 801156e:	eb05 04c4 	add.w	r4, r5, r4, lsl #3
 8011572:	6120      	str	r0, [r4, #16]
  return 0;
 8011574:	bd70      	pop	{r4, r5, r6, pc}

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
  if (!sock) {
    return -1;
 8011576:	f04f 30ff 	mov.w	r0, #4294967295
 801157a:	bd70      	pop	{r4, r5, r6, pc}
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
    if (netconn_type(sock->conn) != NETCONN_TCP) {
      sock_set_errno(sock, EOPNOTSUPP);
      return EOPNOTSUPP;
    }
    sock_set_errno(sock, err_to_errno(err));
 801157c:	4240      	negs	r0, r0
 801157e:	280f      	cmp	r0, #15
 8011580:	bf98      	it	ls
 8011582:	4b07      	ldrls	r3, [pc, #28]	; (80115a0 <lwip_listen+0x84>)
 8011584:	4434      	add	r4, r6
 8011586:	bf94      	ite	ls
 8011588:	f853 3020 	ldrls.w	r3, [r3, r0, lsl #2]
 801158c:	2305      	movhi	r3, #5
 801158e:	eb05 04c4 	add.w	r4, r5, r4, lsl #3
 8011592:	6123      	str	r3, [r4, #16]
    return -1;
 8011594:	f04f 30ff 	mov.w	r0, #4294967295
 8011598:	bd70      	pop	{r4, r5, r6, pc}
 801159a:	bf00      	nop
 801159c:	20004c40 	.word	0x20004c40
 80115a0:	080161e4 	.word	0x080161e4

080115a4 <lwip_recvfrom>:
}

int
lwip_recvfrom(int s, void *mem, size_t len, int flags,
        struct sockaddr *from, socklen_t *fromlen)
{
 80115a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80115a8:	4604      	mov	r4, r0
 80115aa:	b08f      	sub	sp, #60	; 0x3c
 80115ac:	9003      	str	r0, [sp, #12]
static struct lwip_sock *
get_socket(int s)
{
  struct lwip_sock *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
 80115ae:	2c03      	cmp	r4, #3
int
lwip_recvfrom(int s, void *mem, size_t len, int flags,
        struct sockaddr *from, socklen_t *fromlen)
{
  struct lwip_sock *sock;
  void             *buf = NULL;
 80115b0:	f04f 0000 	mov.w	r0, #0
}

int
lwip_recvfrom(int s, void *mem, size_t len, int flags,
        struct sockaddr *from, socklen_t *fromlen)
{
 80115b4:	9101      	str	r1, [sp, #4]
  struct lwip_sock *sock;
  void             *buf = NULL;
 80115b6:	9008      	str	r0, [sp, #32]
static struct lwip_sock *
get_socket(int s)
{
  struct lwip_sock *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
 80115b8:	f200 809c 	bhi.w	80116f4 <lwip_recvfrom+0x150>
 80115bc:	4617      	mov	r7, r2
    return NULL;
  }

  sock = &sockets[s];

  if (!sock->conn) {
 80115be:	0062      	lsls	r2, r4, #1
 80115c0:	4699      	mov	r9, r3
 80115c2:	9204      	str	r2, [sp, #16]
 80115c4:	1913      	adds	r3, r2, r4
 80115c6:	4a9c      	ldr	r2, [pc, #624]	; (8011838 <lwip_recvfrom+0x294>)
 80115c8:	00dc      	lsls	r4, r3, #3
 80115ca:	5912      	ldr	r2, [r2, r4]
 80115cc:	2a00      	cmp	r2, #0
 80115ce:	f000 8091 	beq.w	80116f4 <lwip_recvfrom+0x150>
 80115d2:	4680      	mov	r8, r0
  }

  do {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: top while sock->lastdata=%p\n", sock->lastdata));
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
 80115d4:	9305      	str	r3, [sp, #20]
 80115d6:	4b98      	ldr	r3, [pc, #608]	; (8011838 <lwip_recvfrom+0x294>)
 80115d8:	441c      	add	r4, r3
 80115da:	6863      	ldr	r3, [r4, #4]
 80115dc:	2b00      	cmp	r3, #0
 80115de:	f000 80aa 	beq.w	8011736 <lwip_recvfrom+0x192>
 80115e2:	469a      	mov	sl, r3
      buf = sock->lastdata;
 80115e4:	9308      	str	r3, [sp, #32]
      }
      LWIP_ASSERT("buf != NULL", buf != NULL);
      sock->lastdata = buf;
    }

    if (netconn_type(sock->conn) == NETCONN_TCP) {
 80115e6:	6823      	ldr	r3, [r4, #0]
      copylen = (u16_t)len;
    }

    /* copy the contents of the received buffer into
    the supplied memory pointer mem */
    pbuf_copy_partial(p, (u8_t*)mem + off, copylen, sock->lastoffset);
 80115e8:	9901      	ldr	r1, [sp, #4]
      }
      LWIP_ASSERT("buf != NULL", buf != NULL);
      sock->lastdata = buf;
    }

    if (netconn_type(sock->conn) == NETCONN_TCP) {
 80115ea:	781b      	ldrb	r3, [r3, #0]
      copylen = (u16_t)len;
    }

    /* copy the contents of the received buffer into
    the supplied memory pointer mem */
    pbuf_copy_partial(p, (u8_t*)mem + off, copylen, sock->lastoffset);
 80115ec:	4441      	add	r1, r8
      }
      LWIP_ASSERT("buf != NULL", buf != NULL);
      sock->lastdata = buf;
    }

    if (netconn_type(sock->conn) == NETCONN_TCP) {
 80115ee:	2b10      	cmp	r3, #16
      p = (struct pbuf *)buf;
    } else {
      p = ((struct netbuf *)buf)->p;
 80115f0:	bf18      	it	ne
 80115f2:	f8da a000 	ldrne.w	sl, [sl]
    }
    buflen = p->tot_len;
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: buflen=%"U16_F" len=%"SZT_F" off=%d sock->lastoffset=%"U16_F"\n",
      buflen, len, off, sock->lastoffset));

    buflen -= sock->lastoffset;
 80115f6:	8923      	ldrh	r3, [r4, #8]
 80115f8:	f8ba 5008 	ldrh.w	r5, [sl, #8]
      copylen = (u16_t)len;
    }

    /* copy the contents of the received buffer into
    the supplied memory pointer mem */
    pbuf_copy_partial(p, (u8_t*)mem + off, copylen, sock->lastoffset);
 80115fc:	4650      	mov	r0, sl
    }
    buflen = p->tot_len;
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: buflen=%"U16_F" len=%"SZT_F" off=%d sock->lastoffset=%"U16_F"\n",
      buflen, len, off, sock->lastoffset));

    buflen -= sock->lastoffset;
 80115fe:	1aed      	subs	r5, r5, r3
 8011600:	b2ad      	uxth	r5, r5

    if (len > buflen) {
 8011602:	42af      	cmp	r7, r5
      copylen = buflen;
 8011604:	bf8c      	ite	hi
 8011606:	462e      	movhi	r6, r5
    } else {
      copylen = (u16_t)len;
 8011608:	b2be      	uxthls	r6, r7
    }

    /* copy the contents of the received buffer into
    the supplied memory pointer mem */
    pbuf_copy_partial(p, (u8_t*)mem + off, copylen, sock->lastoffset);
 801160a:	4632      	mov	r2, r6
 801160c:	f7fe ffee 	bl	80105ec <pbuf_copy_partial>

    off += copylen;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
 8011610:	6823      	ldr	r3, [r4, #0]

    /* copy the contents of the received buffer into
    the supplied memory pointer mem */
    pbuf_copy_partial(p, (u8_t*)mem + off, copylen, sock->lastoffset);

    off += copylen;
 8011612:	44b0      	add	r8, r6

    if (netconn_type(sock->conn) == NETCONN_TCP) {
 8011614:	781b      	ldrb	r3, [r3, #0]
 8011616:	2b10      	cmp	r3, #16
 8011618:	d171      	bne.n	80116fe <lwip_recvfrom+0x15a>
      LWIP_ASSERT("invalid copylen, len would underflow", len >= copylen);
 801161a:	42b7      	cmp	r7, r6
 801161c:	f0c0 8083 	bcc.w	8011726 <lwip_recvfrom+0x182>
      len -= copylen;
      if ( (len <= 0) || 
 8011620:	1bbf      	subs	r7, r7, r6
 8011622:	d06c      	beq.n	80116fe <lwip_recvfrom+0x15a>
 8011624:	f89a 300d 	ldrb.w	r3, [sl, #13]
 8011628:	07db      	lsls	r3, r3, #31
 801162a:	d468      	bmi.n	80116fe <lwip_recvfrom+0x15a>
           (p->flags & PBUF_FLAG_PUSH) || 
 801162c:	f9b4 300a 	ldrsh.w	r3, [r4, #10]
 8011630:	2b00      	cmp	r3, #0
 8011632:	dd64      	ble.n	80116fe <lwip_recvfrom+0x15a>
           (sock->rcvevent <= 0) || 
 8011634:	f019 0a01 	ands.w	sl, r9, #1
 8011638:	d037      	beq.n	80116aa <lwip_recvfrom+0x106>
    }

    /* Check to see from where the data was.*/
    if (done) {
      ip_addr_t fromaddr;
      if (from && fromlen) {
 801163a:	9b18      	ldr	r3, [sp, #96]	; 0x60
 801163c:	2b00      	cmp	r3, #0
 801163e:	d041      	beq.n	80116c4 <lwip_recvfrom+0x120>
 8011640:	9b19      	ldr	r3, [sp, #100]	; 0x64
 8011642:	2b00      	cmp	r3, #0
 8011644:	d03e      	beq.n	80116c4 <lwip_recvfrom+0x120>
        struct sockaddr_in sin;

        if (netconn_type(sock->conn) == NETCONN_TCP) {
 8011646:	6820      	ldr	r0, [r4, #0]
    }

    /* Check to see from where the data was.*/
    if (done) {
      ip_addr_t fromaddr;
      if (from && fromlen) {
 8011648:	f04f 0b01 	mov.w	fp, #1
        struct sockaddr_in sin;

        if (netconn_type(sock->conn) == NETCONN_TCP) {
 801164c:	7803      	ldrb	r3, [r0, #0]
 801164e:	2b10      	cmp	r3, #16
 8011650:	d061      	beq.n	8011716 <lwip_recvfrom+0x172>
          addr = &fromaddr;
          netconn_getaddr(sock->conn, addr, &port, 0);
        } else {
          addr = netbuf_fromaddr((struct netbuf *)buf);
 8011652:	9b08      	ldr	r3, [sp, #32]
          port = netbuf_fromport((struct netbuf *)buf);
 8011654:	899a      	ldrh	r2, [r3, #12]

        if (netconn_type(sock->conn) == NETCONN_TCP) {
          addr = &fromaddr;
          netconn_getaddr(sock->conn, addr, &port, 0);
        } else {
          addr = netbuf_fromaddr((struct netbuf *)buf);
 8011656:	f103 0a08 	add.w	sl, r3, #8
          port = netbuf_fromport((struct netbuf *)buf);
 801165a:	f8ad 201e 	strh.w	r2, [sp, #30]
        }

        memset(&sin, 0, sizeof(sin));
 801165e:	2100      	movs	r1, #0
 8011660:	2210      	movs	r2, #16
 8011662:	a80a      	add	r0, sp, #40	; 0x28
 8011664:	f003 fb80 	bl	8014d68 <memset>
        sin.sin_len = sizeof(sin);
 8011668:	2310      	movs	r3, #16
        sin.sin_family = AF_INET;
 801166a:	2202      	movs	r2, #2
        sin.sin_port = htons(port);
 801166c:	f8bd 001e 	ldrh.w	r0, [sp, #30]
          addr = netbuf_fromaddr((struct netbuf *)buf);
          port = netbuf_fromport((struct netbuf *)buf);
        }

        memset(&sin, 0, sizeof(sin));
        sin.sin_len = sizeof(sin);
 8011670:	f88d 3028 	strb.w	r3, [sp, #40]	; 0x28
 8011674:	9302      	str	r3, [sp, #8]
        sin.sin_family = AF_INET;
 8011676:	f88d 2029 	strb.w	r2, [sp, #41]	; 0x29
        sin.sin_port = htons(port);
 801167a:	f7fc fa8d 	bl	800db98 <lwip_htons>
        inet_addr_from_ipaddr(&sin.sin_addr, addr);

        if (*fromlen > sizeof(sin)) {
 801167e:	9b19      	ldr	r3, [sp, #100]	; 0x64

        memset(&sin, 0, sizeof(sin));
        sin.sin_len = sizeof(sin);
        sin.sin_family = AF_INET;
        sin.sin_port = htons(port);
        inet_addr_from_ipaddr(&sin.sin_addr, addr);
 8011680:	f8da 1000 	ldr.w	r1, [sl]

        if (*fromlen > sizeof(sin)) {
 8011684:	681a      	ldr	r2, [r3, #0]
        }

        memset(&sin, 0, sizeof(sin));
        sin.sin_len = sizeof(sin);
        sin.sin_family = AF_INET;
        sin.sin_port = htons(port);
 8011686:	f8ad 002a 	strh.w	r0, [sp, #42]	; 0x2a
        inet_addr_from_ipaddr(&sin.sin_addr, addr);

        if (*fromlen > sizeof(sin)) {
 801168a:	2a10      	cmp	r2, #16

        memset(&sin, 0, sizeof(sin));
        sin.sin_len = sizeof(sin);
        sin.sin_family = AF_INET;
        sin.sin_port = htons(port);
        inet_addr_from_ipaddr(&sin.sin_addr, addr);
 801168c:	910b      	str	r1, [sp, #44]	; 0x2c

        if (*fromlen > sizeof(sin)) {
 801168e:	d903      	bls.n	8011698 <lwip_recvfrom+0xf4>
          *fromlen = sizeof(sin);
 8011690:	9b02      	ldr	r3, [sp, #8]
 8011692:	9919      	ldr	r1, [sp, #100]	; 0x64
 8011694:	461a      	mov	r2, r3
 8011696:	600b      	str	r3, [r1, #0]
        }

        MEMCPY(from, &sin, *fromlen);
 8011698:	a90a      	add	r1, sp, #40	; 0x28
 801169a:	9818      	ldr	r0, [sp, #96]	; 0x60
 801169c:	f003 fb59 	bl	8014d52 <memcpy>
#endif /*  SOCKETS_DEBUG */
      }
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK) == 0) {
 80116a0:	f1bb 0f00 	cmp.w	fp, #0
 80116a4:	d10e      	bne.n	80116c4 <lwip_recvfrom+0x120>
 80116a6:	f04f 0a01 	mov.w	sl, #1
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((netconn_type(sock->conn) == NETCONN_TCP) && (buflen - copylen > 0)) {
 80116aa:	6823      	ldr	r3, [r4, #0]
 80116ac:	781b      	ldrb	r3, [r3, #0]
 80116ae:	2b10      	cmp	r3, #16
 80116b0:	d05c      	beq.n	801176c <lwip_recvfrom+0x1c8>
        sock->lastdata = buf;
        sock->lastoffset += copylen;
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", buf));
      } else {
        sock->lastdata = NULL;
 80116b2:	2300      	movs	r3, #0
        sock->lastoffset = 0;
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: deleting netbuf=%p\n", buf));
        if (netconn_type(sock->conn) == NETCONN_TCP) {
          pbuf_free((struct pbuf *)buf);
        } else {
          netbuf_delete((struct netbuf *)buf);
 80116b4:	9808      	ldr	r0, [sp, #32]
      if ((netconn_type(sock->conn) == NETCONN_TCP) && (buflen - copylen > 0)) {
        sock->lastdata = buf;
        sock->lastoffset += copylen;
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", buf));
      } else {
        sock->lastdata = NULL;
 80116b6:	6063      	str	r3, [r4, #4]
        sock->lastoffset = 0;
 80116b8:	8123      	strh	r3, [r4, #8]
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: deleting netbuf=%p\n", buf));
        if (netconn_type(sock->conn) == NETCONN_TCP) {
          pbuf_free((struct pbuf *)buf);
        } else {
          netbuf_delete((struct netbuf *)buf);
 80116ba:	f7fe fb51 	bl	800fd60 <netbuf_delete>
        }
      }
    }
  } while (!done);
 80116be:	f1ba 0f00 	cmp.w	sl, #0
 80116c2:	d08a      	beq.n	80115da <lwip_recvfrom+0x36>

  if (off > 0) {
 80116c4:	f1b8 0f00 	cmp.w	r8, #0
 80116c8:	d008      	beq.n	80116dc <lwip_recvfrom+0x138>
    /* update receive window */
    netconn_recved(sock->conn, (u32_t)off);
 80116ca:	9a03      	ldr	r2, [sp, #12]
 80116cc:	9b04      	ldr	r3, [sp, #16]
 80116ce:	4641      	mov	r1, r8
 80116d0:	4413      	add	r3, r2
 80116d2:	4a59      	ldr	r2, [pc, #356]	; (8011838 <lwip_recvfrom+0x294>)
 80116d4:	f852 0033 	ldr.w	r0, [r2, r3, lsl #3]
 80116d8:	f7fa fbe8 	bl	800beac <netconn_recved>
  }
  sock_set_errno(sock, 0);
  return off;
 80116dc:	4640      	mov	r0, r8

  if (off > 0) {
    /* update receive window */
    netconn_recved(sock->conn, (u32_t)off);
  }
  sock_set_errno(sock, 0);
 80116de:	9a03      	ldr	r2, [sp, #12]
 80116e0:	9b04      	ldr	r3, [sp, #16]
 80116e2:	4413      	add	r3, r2
 80116e4:	4a54      	ldr	r2, [pc, #336]	; (8011838 <lwip_recvfrom+0x294>)
 80116e6:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 80116ea:	2200      	movs	r2, #0
 80116ec:	611a      	str	r2, [r3, #16]
  return off;
}
 80116ee:	b00f      	add	sp, #60	; 0x3c
 80116f0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  err_t            err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %"SZT_F", 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
  if (!sock) {
    return -1;
 80116f4:	f04f 30ff 	mov.w	r0, #4294967295
    /* update receive window */
    netconn_recved(sock->conn, (u32_t)off);
  }
  sock_set_errno(sock, 0);
  return off;
}
 80116f8:	b00f      	add	sp, #60	; 0x3c
 80116fa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    }

    /* Check to see from where the data was.*/
    if (done) {
      ip_addr_t fromaddr;
      if (from && fromlen) {
 80116fe:	9b18      	ldr	r3, [sp, #96]	; 0x60
 8011700:	f009 0b01 	and.w	fp, r9, #1
 8011704:	2b00      	cmp	r3, #0
 8011706:	d0cb      	beq.n	80116a0 <lwip_recvfrom+0xfc>
 8011708:	9b19      	ldr	r3, [sp, #100]	; 0x64
 801170a:	2b00      	cmp	r3, #0
 801170c:	d0c8      	beq.n	80116a0 <lwip_recvfrom+0xfc>
        struct sockaddr_in sin;

        if (netconn_type(sock->conn) == NETCONN_TCP) {
 801170e:	6820      	ldr	r0, [r4, #0]
 8011710:	7803      	ldrb	r3, [r0, #0]
 8011712:	2b10      	cmp	r3, #16
 8011714:	d19d      	bne.n	8011652 <lwip_recvfrom+0xae>
          addr = &fromaddr;
          netconn_getaddr(sock->conn, addr, &port, 0);
 8011716:	a909      	add	r1, sp, #36	; 0x24
 8011718:	2300      	movs	r3, #0
 801171a:	f10d 021e 	add.w	r2, sp, #30
      ip_addr_t fromaddr;
      if (from && fromlen) {
        struct sockaddr_in sin;

        if (netconn_type(sock->conn) == NETCONN_TCP) {
          addr = &fromaddr;
 801171e:	468a      	mov	sl, r1
          netconn_getaddr(sock->conn, addr, &port, 0);
 8011720:	f7fa f9ee 	bl	800bb00 <netconn_getaddr>
 8011724:	e79b      	b.n	801165e <lwip_recvfrom+0xba>
    pbuf_copy_partial(p, (u8_t*)mem + off, copylen, sock->lastoffset);

    off += copylen;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
      LWIP_ASSERT("invalid copylen, len would underflow", len >= copylen);
 8011726:	4b45      	ldr	r3, [pc, #276]	; (801183c <lwip_recvfrom+0x298>)
 8011728:	f240 228d 	movw	r2, #653	; 0x28d
 801172c:	4944      	ldr	r1, [pc, #272]	; (8011840 <lwip_recvfrom+0x29c>)
 801172e:	4845      	ldr	r0, [pc, #276]	; (8011844 <lwip_recvfrom+0x2a0>)
 8011730:	f003 fb22 	bl	8014d78 <iprintf>
 8011734:	e774      	b.n	8011620 <lwip_recvfrom+0x7c>
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
      buf = sock->lastdata;
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || netconn_is_nonblocking(sock->conn)) && 
 8011736:	f019 0f08 	tst.w	r9, #8
 801173a:	d104      	bne.n	8011746 <lwip_recvfrom+0x1a2>
 801173c:	6820      	ldr	r0, [r4, #0]
 801173e:	f890 3098 	ldrb.w	r3, [r0, #152]	; 0x98
 8011742:	079a      	lsls	r2, r3, #30
 8011744:	d505      	bpl.n	8011752 <lwip_recvfrom+0x1ae>
 8011746:	f9b4 300a 	ldrsh.w	r3, [r4, #10]
          (sock->rcvevent <= 0)) {
 801174a:	4d3b      	ldr	r5, [pc, #236]	; (8011838 <lwip_recvfrom+0x294>)
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
      buf = sock->lastdata;
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || netconn_is_nonblocking(sock->conn)) && 
 801174c:	2b00      	cmp	r3, #0
 801174e:	dd4d      	ble.n	80117ec <lwip_recvfrom+0x248>
 8011750:	6820      	ldr	r0, [r4, #0]
        return -1;
      }

      /* No data was left from the previous operation, so we try to get
         some from the network. */
      if (netconn_type(sock->conn) == NETCONN_TCP) {
 8011752:	7803      	ldrb	r3, [r0, #0]
        err = netconn_recv_tcp_pbuf(sock->conn, (struct pbuf **)&buf);
 8011754:	a908      	add	r1, sp, #32
        return -1;
      }

      /* No data was left from the previous operation, so we try to get
         some from the network. */
      if (netconn_type(sock->conn) == NETCONN_TCP) {
 8011756:	2b10      	cmp	r3, #16
 8011758:	d020      	beq.n	801179c <lwip_recvfrom+0x1f8>
        err = netconn_recv_tcp_pbuf(sock->conn, (struct pbuf **)&buf);
      } else {
        err = netconn_recv(sock->conn, (struct netbuf **)&buf);
 801175a:	f7fa fb33 	bl	800bdc4 <netconn_recv>
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: netconn_recv err=%d, netbuf=%p\n",
        err, buf));

      if (err != ERR_OK) {
 801175e:	bb08      	cbnz	r0, 80117a4 <lwip_recvfrom+0x200>
          return 0;
        } else {
          return -1;
        }
      }
      LWIP_ASSERT("buf != NULL", buf != NULL);
 8011760:	9b08      	ldr	r3, [sp, #32]
 8011762:	2b00      	cmp	r3, #0
 8011764:	d039      	beq.n	80117da <lwip_recvfrom+0x236>
      sock->lastdata = buf;
 8011766:	469a      	mov	sl, r3
 8011768:	6063      	str	r3, [r4, #4]
 801176a:	e73c      	b.n	80115e6 <lwip_recvfrom+0x42>
    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK) == 0) {
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((netconn_type(sock->conn) == NETCONN_TCP) && (buflen - copylen > 0)) {
 801176c:	1bad      	subs	r5, r5, r6
 801176e:	2d00      	cmp	r5, #0
 8011770:	dd09      	ble.n	8011786 <lwip_recvfrom+0x1e2>
        sock->lastdata = buf;
        sock->lastoffset += copylen;
 8011772:	8923      	ldrh	r3, [r4, #8]
    if ((flags & MSG_PEEK) == 0) {
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((netconn_type(sock->conn) == NETCONN_TCP) && (buflen - copylen > 0)) {
        sock->lastdata = buf;
 8011774:	9a08      	ldr	r2, [sp, #32]
        sock->lastoffset += copylen;
 8011776:	441e      	add	r6, r3
 8011778:	8126      	strh	r6, [r4, #8]
    if ((flags & MSG_PEEK) == 0) {
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((netconn_type(sock->conn) == NETCONN_TCP) && (buflen - copylen > 0)) {
        sock->lastdata = buf;
 801177a:	6062      	str	r2, [r4, #4]
        } else {
          netbuf_delete((struct netbuf *)buf);
        }
      }
    }
  } while (!done);
 801177c:	f1ba 0f00 	cmp.w	sl, #0
 8011780:	f43f af2b 	beq.w	80115da <lwip_recvfrom+0x36>
 8011784:	e79e      	b.n	80116c4 <lwip_recvfrom+0x120>
      if ((netconn_type(sock->conn) == NETCONN_TCP) && (buflen - copylen > 0)) {
        sock->lastdata = buf;
        sock->lastoffset += copylen;
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", buf));
      } else {
        sock->lastdata = NULL;
 8011786:	2300      	movs	r3, #0
        sock->lastoffset = 0;
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: deleting netbuf=%p\n", buf));
        if (netconn_type(sock->conn) == NETCONN_TCP) {
          pbuf_free((struct pbuf *)buf);
 8011788:	9808      	ldr	r0, [sp, #32]
      if ((netconn_type(sock->conn) == NETCONN_TCP) && (buflen - copylen > 0)) {
        sock->lastdata = buf;
        sock->lastoffset += copylen;
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", buf));
      } else {
        sock->lastdata = NULL;
 801178a:	6063      	str	r3, [r4, #4]
        sock->lastoffset = 0;
 801178c:	8123      	strh	r3, [r4, #8]
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: deleting netbuf=%p\n", buf));
        if (netconn_type(sock->conn) == NETCONN_TCP) {
          pbuf_free((struct pbuf *)buf);
 801178e:	f7fe fc4b 	bl	8010028 <pbuf_free>
        } else {
          netbuf_delete((struct netbuf *)buf);
        }
      }
    }
  } while (!done);
 8011792:	f1ba 0f00 	cmp.w	sl, #0
 8011796:	f43f af20 	beq.w	80115da <lwip_recvfrom+0x36>
 801179a:	e793      	b.n	80116c4 <lwip_recvfrom+0x120>
      }

      /* No data was left from the previous operation, so we try to get
         some from the network. */
      if (netconn_type(sock->conn) == NETCONN_TCP) {
        err = netconn_recv_tcp_pbuf(sock->conn, (struct pbuf **)&buf);
 801179c:	f7fa fafa 	bl	800bd94 <netconn_recv_tcp_pbuf>
        err = netconn_recv(sock->conn, (struct netbuf **)&buf);
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: netconn_recv err=%d, netbuf=%p\n",
        err, buf));

      if (err != ERR_OK) {
 80117a0:	2800      	cmp	r0, #0
 80117a2:	d0dd      	beq.n	8011760 <lwip_recvfrom+0x1bc>
        if (off > 0) {
 80117a4:	f1b8 0f00 	cmp.w	r8, #0
 80117a8:	d12e      	bne.n	8011808 <lwip_recvfrom+0x264>
          return off;
        }
        /* We should really do some error checking here. */
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): buf == NULL, error is \"%s\"!\n",
          s, lwip_strerr(err)));
        sock_set_errno(sock, err_to_errno(err));
 80117aa:	4243      	negs	r3, r0
 80117ac:	2b0f      	cmp	r3, #15
 80117ae:	bf98      	it	ls
 80117b0:	4a25      	ldrls	r2, [pc, #148]	; (8011848 <lwip_recvfrom+0x2a4>)
 80117b2:	9903      	ldr	r1, [sp, #12]
 80117b4:	bf98      	it	ls
 80117b6:	f852 2023 	ldrls.w	r2, [r2, r3, lsl #2]
 80117ba:	9b04      	ldr	r3, [sp, #16]
 80117bc:	bf88      	it	hi
 80117be:	2205      	movhi	r2, #5
 80117c0:	440b      	add	r3, r1
 80117c2:	491d      	ldr	r1, [pc, #116]	; (8011838 <lwip_recvfrom+0x294>)
        if (err == ERR_CLSD) {
 80117c4:	f110 080c 	adds.w	r8, r0, #12
 80117c8:	bf18      	it	ne
 80117ca:	f04f 0801 	movne.w	r8, #1
          return off;
        }
        /* We should really do some error checking here. */
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): buf == NULL, error is \"%s\"!\n",
          s, lwip_strerr(err)));
        sock_set_errno(sock, err_to_errno(err));
 80117ce:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
 80117d2:	611a      	str	r2, [r3, #16]
        if (err == ERR_CLSD) {
 80117d4:	f1c8 0000 	rsb	r0, r8, #0
 80117d8:	e78e      	b.n	80116f8 <lwip_recvfrom+0x154>
          return 0;
        } else {
          return -1;
        }
      }
      LWIP_ASSERT("buf != NULL", buf != NULL);
 80117da:	4b18      	ldr	r3, [pc, #96]	; (801183c <lwip_recvfrom+0x298>)
 80117dc:	f240 2271 	movw	r2, #625	; 0x271
 80117e0:	491a      	ldr	r1, [pc, #104]	; (801184c <lwip_recvfrom+0x2a8>)
 80117e2:	4818      	ldr	r0, [pc, #96]	; (8011844 <lwip_recvfrom+0x2a0>)
 80117e4:	f003 fac8 	bl	8014d78 <iprintf>
 80117e8:	9b08      	ldr	r3, [sp, #32]
 80117ea:	e7bc      	b.n	8011766 <lwip_recvfrom+0x1c2>
      buf = sock->lastdata;
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || netconn_is_nonblocking(sock->conn)) && 
          (sock->rcvevent <= 0)) {
        if (off > 0) {
 80117ec:	f1b8 0f00 	cmp.w	r8, #0
 80117f0:	d019      	beq.n	8011826 <lwip_recvfrom+0x282>
          /* update receive window */
          netconn_recved(sock->conn, (u32_t)off);
 80117f2:	6820      	ldr	r0, [r4, #0]
 80117f4:	4641      	mov	r1, r8
 80117f6:	f7fa fb59 	bl	800beac <netconn_recved>
          /* already received data, return that */
          sock_set_errno(sock, 0);
 80117fa:	9b05      	ldr	r3, [sp, #20]
          return off;
 80117fc:	4640      	mov	r0, r8
          (sock->rcvevent <= 0)) {
        if (off > 0) {
          /* update receive window */
          netconn_recved(sock->conn, (u32_t)off);
          /* already received data, return that */
          sock_set_errno(sock, 0);
 80117fe:	eb05 05c3 	add.w	r5, r5, r3, lsl #3
 8011802:	2300      	movs	r3, #0
 8011804:	612b      	str	r3, [r5, #16]
          return off;
 8011806:	e777      	b.n	80116f8 <lwip_recvfrom+0x154>
        err, buf));

      if (err != ERR_OK) {
        if (off > 0) {
          /* update receive window */
          netconn_recved(sock->conn, (u32_t)off);
 8011808:	9b04      	ldr	r3, [sp, #16]
 801180a:	9a03      	ldr	r2, [sp, #12]
 801180c:	4641      	mov	r1, r8
 801180e:	4413      	add	r3, r2
 8011810:	00dc      	lsls	r4, r3, #3
 8011812:	4b09      	ldr	r3, [pc, #36]	; (8011838 <lwip_recvfrom+0x294>)
 8011814:	5918      	ldr	r0, [r3, r4]
 8011816:	f7fa fb49 	bl	800beac <netconn_recved>
          /* already received data, return that */
          sock_set_errno(sock, 0);
 801181a:	4b07      	ldr	r3, [pc, #28]	; (8011838 <lwip_recvfrom+0x294>)
          return off;
 801181c:	4640      	mov	r0, r8
      if (err != ERR_OK) {
        if (off > 0) {
          /* update receive window */
          netconn_recved(sock->conn, (u32_t)off);
          /* already received data, return that */
          sock_set_errno(sock, 0);
 801181e:	441c      	add	r4, r3
 8011820:	2300      	movs	r3, #0
 8011822:	6123      	str	r3, [r4, #16]
          return off;
 8011824:	e768      	b.n	80116f8 <lwip_recvfrom+0x154>
          /* already received data, return that */
          sock_set_errno(sock, 0);
          return off;
        }
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): returning EWOULDBLOCK\n", s));
        sock_set_errno(sock, EWOULDBLOCK);
 8011826:	9b05      	ldr	r3, [sp, #20]
        return -1;
 8011828:	f04f 30ff 	mov.w	r0, #4294967295
          /* already received data, return that */
          sock_set_errno(sock, 0);
          return off;
        }
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): returning EWOULDBLOCK\n", s));
        sock_set_errno(sock, EWOULDBLOCK);
 801182c:	eb05 05c3 	add.w	r5, r5, r3, lsl #3
 8011830:	230b      	movs	r3, #11
 8011832:	612b      	str	r3, [r5, #16]
        return -1;
 8011834:	e760      	b.n	80116f8 <lwip_recvfrom+0x154>
 8011836:	bf00      	nop
 8011838:	20004c40 	.word	0x20004c40
 801183c:	08018078 	.word	0x08018078
 8011840:	08018170 	.word	0x08018170
 8011844:	0801660c 	.word	0x0801660c
 8011848:	080161e4 	.word	0x080161e4
 801184c:	08016f58 	.word	0x08016f58

08011850 <lwip_read>:
  return off;
}

int
lwip_read(int s, void *mem, size_t len)
{
 8011850:	b500      	push	{lr}
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
 8011852:	2300      	movs	r3, #0
  return off;
}

int
lwip_read(int s, void *mem, size_t len)
{
 8011854:	b083      	sub	sp, #12
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
 8011856:	9301      	str	r3, [sp, #4]
 8011858:	9300      	str	r3, [sp, #0]
 801185a:	f7ff fea3 	bl	80115a4 <lwip_recvfrom>
}
 801185e:	b003      	add	sp, #12
 8011860:	f85d fb04 	ldr.w	pc, [sp], #4

08011864 <lwip_recv>:

int
lwip_recv(int s, void *mem, size_t len, int flags)
{
 8011864:	b510      	push	{r4, lr}
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
 8011866:	2400      	movs	r4, #0
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
}

int
lwip_recv(int s, void *mem, size_t len, int flags)
{
 8011868:	b082      	sub	sp, #8
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
 801186a:	9401      	str	r4, [sp, #4]
 801186c:	9400      	str	r4, [sp, #0]
 801186e:	f7ff fe99 	bl	80115a4 <lwip_recvfrom>
}
 8011872:	b002      	add	sp, #8
 8011874:	bd10      	pop	{r4, pc}
 8011876:	bf00      	nop

08011878 <lwip_sendto>:
}

int
lwip_sendto(int s, const void *data, size_t size, int flags,
       const struct sockaddr *to, socklen_t tolen)
{
 8011878:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
static struct lwip_sock *
get_socket(int s)
{
  struct lwip_sock *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
 801187c:	2803      	cmp	r0, #3
}

int
lwip_sendto(int s, const void *data, size_t size, int flags,
       const struct sockaddr *to, socklen_t tolen)
{
 801187e:	b084      	sub	sp, #16
 8011880:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 8011882:	f8dd 8034 	ldr.w	r8, [sp, #52]	; 0x34
static struct lwip_sock *
get_socket(int s)
{
  struct lwip_sock *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
 8011886:	d852      	bhi.n	801192e <lwip_sendto+0xb6>
    return NULL;
  }

  sock = &sockets[s];

  if (!sock->conn) {
 8011888:	ea4f 0940 	mov.w	r9, r0, lsl #1
 801188c:	f8df a120 	ldr.w	sl, [pc, #288]	; 80119b0 <lwip_sendto+0x138>
 8011890:	eb09 0e00 	add.w	lr, r9, r0
 8011894:	f85a e03e 	ldr.w	lr, [sl, lr, lsl #3]
 8011898:	4605      	mov	r5, r0
 801189a:	f1be 0f00 	cmp.w	lr, #0
 801189e:	d046      	beq.n	801192e <lwip_sendto+0xb6>
  sock = get_socket(s);
  if (!sock) {
    return -1;
  }

  if (sock->conn->type == NETCONN_TCP) {
 80118a0:	f89e e000 	ldrb.w	lr, [lr]
 80118a4:	f1be 0f10 	cmp.w	lr, #16
 80118a8:	d074      	beq.n	8011994 <lwip_sendto+0x11c>
    return -1;
#endif /* LWIP_TCP */
  }

  /* @todo: split into multiple sendto's? */
  LWIP_ASSERT("lwip_sendto: size must fit in u16_t", size <= 0xffff);
 80118aa:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 80118ae:	460f      	mov	r7, r1
 80118b0:	4614      	mov	r4, r2
 80118b2:	d241      	bcs.n	8011938 <lwip_sendto+0xc0>
  short_size = (u16_t)size;
 80118b4:	b2a4      	uxth	r4, r4
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
 80118b6:	2e00      	cmp	r6, #0
 80118b8:	d048      	beq.n	801194c <lwip_sendto+0xd4>
 80118ba:	f1b8 0f10 	cmp.w	r8, #16
 80118be:	d129      	bne.n	8011914 <lwip_sendto+0x9c>
 80118c0:	7873      	ldrb	r3, [r6, #1]
 80118c2:	2b02      	cmp	r3, #2
 80118c4:	d126      	bne.n	8011914 <lwip_sendto+0x9c>
 80118c6:	f016 0303 	ands.w	r3, r6, #3
 80118ca:	d123      	bne.n	8011914 <lwip_sendto+0x9c>
  buf.p = buf.ptr = NULL;
#if LWIP_CHECKSUM_ON_COPY
  buf.flags = 0;
#endif /* LWIP_CHECKSUM_ON_COPY */
  if (to) {
    inet_addr_to_ipaddr(&buf.addr, &to_in->sin_addr);
 80118cc:	6872      	ldr	r2, [r6, #4]
    remote_port           = ntohs(to_in->sin_port);
 80118ce:	8870      	ldrh	r0, [r6, #2]
      err = ERR_MEM;
    }
  }
#else /* LWIP_TCPIP_CORE_LOCKING */
  /* initialize a buffer */
  buf.p = buf.ptr = NULL;
 80118d0:	9301      	str	r3, [sp, #4]
 80118d2:	9300      	str	r3, [sp, #0]
#if LWIP_CHECKSUM_ON_COPY
  buf.flags = 0;
#endif /* LWIP_CHECKSUM_ON_COPY */
  if (to) {
    inet_addr_to_ipaddr(&buf.addr, &to_in->sin_addr);
 80118d4:	9202      	str	r2, [sp, #8]
    remote_port           = ntohs(to_in->sin_port);
 80118d6:	f7fc f963 	bl	800dba0 <lwip_ntohs>
    {
      err = netbuf_take(&buf, data, short_size);
    }
  }
#else /* LWIP_NETIF_TX_SINGLE_PBUF */
  err = netbuf_ref(&buf, data, short_size);
 80118da:	4639      	mov	r1, r7
  buf.flags = 0;
#endif /* LWIP_CHECKSUM_ON_COPY */
  if (to) {
    inet_addr_to_ipaddr(&buf.addr, &to_in->sin_addr);
    remote_port           = ntohs(to_in->sin_port);
    netbuf_fromport(&buf) = remote_port;
 80118dc:	f8ad 000c 	strh.w	r0, [sp, #12]
    {
      err = netbuf_take(&buf, data, short_size);
    }
  }
#else /* LWIP_NETIF_TX_SINGLE_PBUF */
  err = netbuf_ref(&buf, data, short_size);
 80118e0:	4622      	mov	r2, r4
 80118e2:	4668      	mov	r0, sp
 80118e4:	f7fe fa94 	bl	800fe10 <netbuf_ref>
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
  if (err == ERR_OK) {
 80118e8:	4606      	mov	r6, r0
 80118ea:	2800      	cmp	r0, #0
 80118ec:	d041      	beq.n	8011972 <lwip_sendto+0xfa>
    /* send the data */
    err = netconn_send(sock->conn, &buf);
  }

  /* deallocated the buffer */
  netbuf_free(&buf);
 80118ee:	4668      	mov	r0, sp
 80118f0:	f7fe fa76 	bl	800fde0 <netbuf_free>
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
 80118f4:	4273      	negs	r3, r6
 80118f6:	2b0f      	cmp	r3, #15
 80118f8:	d813      	bhi.n	8011922 <lwip_sendto+0xaa>
 80118fa:	4a28      	ldr	r2, [pc, #160]	; (801199c <lwip_sendto+0x124>)
 80118fc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8011900:	444d      	add	r5, r9
 8011902:	eb0a 0ac5 	add.w	sl, sl, r5, lsl #3
 8011906:	f8ca 3010 	str.w	r3, [sl, #16]
  return (err == ERR_OK ? short_size : -1);
 801190a:	b986      	cbnz	r6, 801192e <lwip_sendto+0xb6>
 801190c:	4620      	mov	r0, r4
}
 801190e:	b004      	add	sp, #16
 8011910:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  }

  /* @todo: split into multiple sendto's? */
  LWIP_ASSERT("lwip_sendto: size must fit in u16_t", size <= 0xffff);
  short_size = (u16_t)size;
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
 8011914:	4b22      	ldr	r3, [pc, #136]	; (80119a0 <lwip_sendto+0x128>)
 8011916:	f240 3237 	movw	r2, #823	; 0x337
 801191a:	4922      	ldr	r1, [pc, #136]	; (80119a4 <lwip_sendto+0x12c>)
 801191c:	4822      	ldr	r0, [pc, #136]	; (80119a8 <lwip_sendto+0x130>)
 801191e:	f003 fa2b 	bl	8014d78 <iprintf>
  }

  /* deallocated the buffer */
  netbuf_free(&buf);
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
 8011922:	444d      	add	r5, r9
 8011924:	eb0a 0ac5 	add.w	sl, sl, r5, lsl #3
 8011928:	2305      	movs	r3, #5
 801192a:	f8ca 3010 	str.w	r3, [sl, #16]
  return (err == ERR_OK ? short_size : -1);
 801192e:	f04f 30ff 	mov.w	r0, #4294967295
}
 8011932:	b004      	add	sp, #16
 8011934:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    return -1;
#endif /* LWIP_TCP */
  }

  /* @todo: split into multiple sendto's? */
  LWIP_ASSERT("lwip_sendto: size must fit in u16_t", size <= 0xffff);
 8011938:	4b19      	ldr	r3, [pc, #100]	; (80119a0 <lwip_sendto+0x128>)
 801193a:	f240 3232 	movw	r2, #818	; 0x332
 801193e:	491b      	ldr	r1, [pc, #108]	; (80119ac <lwip_sendto+0x134>)
 8011940:	4819      	ldr	r0, [pc, #100]	; (80119a8 <lwip_sendto+0x130>)
 8011942:	f003 fa19 	bl	8014d78 <iprintf>
  short_size = (u16_t)size;
 8011946:	b2a4      	uxth	r4, r4
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
 8011948:	2e00      	cmp	r6, #0
 801194a:	d1b6      	bne.n	80118ba <lwip_sendto+0x42>
 801194c:	f1b8 0f00 	cmp.w	r8, #0
 8011950:	d1b3      	bne.n	80118ba <lwip_sendto+0x42>
    {
      err = netbuf_take(&buf, data, short_size);
    }
  }
#else /* LWIP_NETIF_TX_SINGLE_PBUF */
  err = netbuf_ref(&buf, data, short_size);
 8011952:	4639      	mov	r1, r7
 8011954:	4668      	mov	r0, sp
 8011956:	4622      	mov	r2, r4
      err = ERR_MEM;
    }
  }
#else /* LWIP_TCPIP_CORE_LOCKING */
  /* initialize a buffer */
  buf.p = buf.ptr = NULL;
 8011958:	f8cd 8004 	str.w	r8, [sp, #4]
 801195c:	f8cd 8000 	str.w	r8, [sp]
    inet_addr_to_ipaddr(&buf.addr, &to_in->sin_addr);
    remote_port           = ntohs(to_in->sin_port);
    netbuf_fromport(&buf) = remote_port;
  } else {
    remote_port           = 0;
    ip_addr_set_any(&buf.addr);
 8011960:	f8cd 8008 	str.w	r8, [sp, #8]
    netbuf_fromport(&buf) = 0;
 8011964:	f8ad 800c 	strh.w	r8, [sp, #12]
    {
      err = netbuf_take(&buf, data, short_size);
    }
  }
#else /* LWIP_NETIF_TX_SINGLE_PBUF */
  err = netbuf_ref(&buf, data, short_size);
 8011968:	f7fe fa52 	bl	800fe10 <netbuf_ref>
#endif /* LWIP_NETIF_TX_SINGLE_PBUF */
  if (err == ERR_OK) {
 801196c:	4606      	mov	r6, r0
 801196e:	2800      	cmp	r0, #0
 8011970:	d1bd      	bne.n	80118ee <lwip_sendto+0x76>
    /* send the data */
    err = netconn_send(sock->conn, &buf);
 8011972:	eb09 0305 	add.w	r3, r9, r5
 8011976:	f85a 0033 	ldr.w	r0, [sl, r3, lsl #3]
 801197a:	4669      	mov	r1, sp
 801197c:	f7fa faae 	bl	800bedc <netconn_send>
 8011980:	4606      	mov	r6, r0
  }

  /* deallocated the buffer */
  netbuf_free(&buf);
 8011982:	4668      	mov	r0, sp
 8011984:	f7fe fa2c 	bl	800fde0 <netbuf_free>
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
 8011988:	4273      	negs	r3, r6
 801198a:	2b0f      	cmp	r3, #15
 801198c:	bf88      	it	hi
 801198e:	2305      	movhi	r3, #5
 8011990:	d8b6      	bhi.n	8011900 <lwip_sendto+0x88>
 8011992:	e7b2      	b.n	80118fa <lwip_sendto+0x82>
    return -1;
  }

  if (sock->conn->type == NETCONN_TCP) {
#if LWIP_TCP
    return lwip_send(s, data, size, flags);
 8011994:	f000 f80e 	bl	80119b4 <lwip_send>
 8011998:	e7b9      	b.n	801190e <lwip_sendto+0x96>
 801199a:	bf00      	nop
 801199c:	080161e4 	.word	0x080161e4
 80119a0:	08018078 	.word	0x08018078
 80119a4:	080181bc 	.word	0x080181bc
 80119a8:	0801660c 	.word	0x0801660c
 80119ac:	08018198 	.word	0x08018198
 80119b0:	20004c40 	.word	0x20004c40

080119b4 <lwip_send>:
static struct lwip_sock *
get_socket(int s)
{
  struct lwip_sock *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
 80119b4:	2803      	cmp	r0, #3
 80119b6:	d902      	bls.n	80119be <lwip_send+0xa>
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%"SZT_F", flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
  if (!sock) {
    return -1;
 80119b8:	f04f 30ff 	mov.w	r0, #4294967295
  err = netconn_write_partly(sock->conn, data, size, write_flags, &written);

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d written=%"SZT_F"\n", s, err, written));
  sock_set_errno(sock, err_to_errno(err));
  return (err == ERR_OK ? (int)written : -1);
}
 80119bc:	4770      	bx	lr
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
}

int
lwip_send(int s, const void *data, size_t size, int flags)
{
 80119be:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    return NULL;
  }

  sock = &sockets[s];

  if (!sock->conn) {
 80119c2:	ea4f 0940 	mov.w	r9, r0, lsl #1
 80119c6:	f8df 8084 	ldr.w	r8, [pc, #132]	; 8011a4c <lwip_send+0x98>
 80119ca:	eb09 0600 	add.w	r6, r9, r0
 80119ce:	f858 6036 	ldr.w	r6, [r8, r6, lsl #3]
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
}

int
lwip_send(int s, const void *data, size_t size, int flags)
{
 80119d2:	b085      	sub	sp, #20
 80119d4:	4605      	mov	r5, r0
    return NULL;
  }

  sock = &sockets[s];

  if (!sock->conn) {
 80119d6:	2e00      	cmp	r6, #0
 80119d8:	d032      	beq.n	8011a40 <lwip_send+0x8c>
  sock = get_socket(s);
  if (!sock) {
    return -1;
  }

  if (sock->conn->type != NETCONN_TCP) {
 80119da:	7837      	ldrb	r7, [r6, #0]
 80119dc:	2f10      	cmp	r7, #16
 80119de:	d127      	bne.n	8011a30 <lwip_send+0x7c>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  write_flags = NETCONN_COPY |
 80119e0:	f013 0f10 	tst.w	r3, #16
 80119e4:	bf0c      	ite	eq
 80119e6:	f04f 0e01 	moveq.w	lr, #1
 80119ea:	f04f 0e03 	movne.w	lr, #3
    ((flags & MSG_MORE)     ? NETCONN_MORE      : 0) |
    ((flags & MSG_DONTWAIT) ? NETCONN_DONTBLOCK : 0);
  written = 0;
 80119ee:	af04      	add	r7, sp, #16
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  write_flags = NETCONN_COPY |
 80119f0:	f013 0f08 	tst.w	r3, #8
    ((flags & MSG_MORE)     ? NETCONN_MORE      : 0) |
    ((flags & MSG_DONTWAIT) ? NETCONN_DONTBLOCK : 0);
  written = 0;
 80119f4:	f04f 0000 	mov.w	r0, #0
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  write_flags = NETCONN_COPY |
 80119f8:	bf0c      	ite	eq
 80119fa:	2300      	moveq	r3, #0
 80119fc:	2304      	movne	r3, #4
    ((flags & MSG_MORE)     ? NETCONN_MORE      : 0) |
    ((flags & MSG_DONTWAIT) ? NETCONN_DONTBLOCK : 0);
  written = 0;
 80119fe:	f847 0d04 	str.w	r0, [r7, #-4]!
  err = netconn_write_partly(sock->conn, data, size, write_flags, &written);
 8011a02:	ea4e 0303 	orr.w	r3, lr, r3
 8011a06:	4630      	mov	r0, r6
 8011a08:	9700      	str	r7, [sp, #0]
 8011a0a:	f7fa fa9b 	bl	800bf44 <netconn_write_partly>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d written=%"SZT_F"\n", s, err, written));
  sock_set_errno(sock, err_to_errno(err));
 8011a0e:	4243      	negs	r3, r0
 8011a10:	2b0f      	cmp	r3, #15
 8011a12:	bf98      	it	ls
 8011a14:	4a0c      	ldrls	r2, [pc, #48]	; (8011a48 <lwip_send+0x94>)
 8011a16:	444d      	add	r5, r9
 8011a18:	bf94      	ite	ls
 8011a1a:	f852 3023 	ldrls.w	r3, [r2, r3, lsl #2]
 8011a1e:	2305      	movhi	r3, #5
 8011a20:	eb08 05c5 	add.w	r5, r8, r5, lsl #3
 8011a24:	612b      	str	r3, [r5, #16]
  return (err == ERR_OK ? (int)written : -1);
 8011a26:	b958      	cbnz	r0, 8011a40 <lwip_send+0x8c>
 8011a28:	9803      	ldr	r0, [sp, #12]
}
 8011a2a:	b005      	add	sp, #20
 8011a2c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    return -1;
  }

  if (sock->conn->type != NETCONN_TCP) {
#if (LWIP_UDP || LWIP_RAW)
    return lwip_sendto(s, data, size, flags, NULL, 0);
 8011a30:	2400      	movs	r4, #0
 8011a32:	9401      	str	r4, [sp, #4]
 8011a34:	9400      	str	r4, [sp, #0]
 8011a36:	f7ff ff1f 	bl	8011878 <lwip_sendto>
  err = netconn_write_partly(sock->conn, data, size, write_flags, &written);

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d written=%"SZT_F"\n", s, err, written));
  sock_set_errno(sock, err_to_errno(err));
  return (err == ERR_OK ? (int)written : -1);
}
 8011a3a:	b005      	add	sp, #20
 8011a3c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%"SZT_F", flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
  if (!sock) {
    return -1;
 8011a40:	f04f 30ff 	mov.w	r0, #4294967295
 8011a44:	e7f1      	b.n	8011a2a <lwip_send+0x76>
 8011a46:	bf00      	nop
 8011a48:	080161e4 	.word	0x080161e4
 8011a4c:	20004c40 	.word	0x20004c40

08011a50 <lwip_socket>:
  int i;

  LWIP_UNUSED_ARG(domain);

  /* create a netconn */
  switch (type) {
 8011a50:	2902      	cmp	r1, #2
  return (err == ERR_OK ? short_size : -1);
}

int
lwip_socket(int domain, int type, int protocol)
{
 8011a52:	b538      	push	{r3, r4, r5, lr}
  int i;

  LWIP_UNUSED_ARG(domain);

  /* create a netconn */
  switch (type) {
 8011a54:	d027      	beq.n	8011aa6 <lwip_socket+0x56>
 8011a56:	2903      	cmp	r1, #3
 8011a58:	d01c      	beq.n	8011a94 <lwip_socket+0x44>
 8011a5a:	2901      	cmp	r1, #1
 8011a5c:	d002      	beq.n	8011a64 <lwip_socket+0x14>
    break;
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n",
                                 domain, type, protocol));
    set_errno(EINVAL);
    return -1;
 8011a5e:	f04f 30ff 	mov.w	r0, #4294967295
  }
  conn->socket = i;
  LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
  set_errno(0);
  return i;
}
 8011a62:	bd38      	pop	{r3, r4, r5, pc}
                 NETCONN_UDPLITE : NETCONN_UDP, event_callback);
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_DGRAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  case SOCK_STREAM:
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
 8011a64:	4a18      	ldr	r2, [pc, #96]	; (8011ac8 <lwip_socket+0x78>)
 8011a66:	2100      	movs	r1, #0
 8011a68:	2010      	movs	r0, #16
 8011a6a:	f7f9 ffd7 	bl	800ba1c <netconn_new_with_proto_and_callback>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_STREAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    if (conn != NULL) {
 8011a6e:	4605      	mov	r5, r0
 8011a70:	2800      	cmp	r0, #0
 8011a72:	d0f4      	beq.n	8011a5e <lwip_socket+0xe>
      /* Prevent automatic window updates, we do this on our own! */
      netconn_set_noautorecved(conn, 1);
 8011a74:	f890 3098 	ldrb.w	r3, [r0, #152]	; 0x98
 8011a78:	f043 0308 	orr.w	r3, r3, #8
 8011a7c:	f880 3098 	strb.w	r3, [r0, #152]	; 0x98
    LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
    set_errno(ENOBUFS);
    return -1;
  }

  i = alloc_socket(conn, 0);
 8011a80:	2100      	movs	r1, #0
 8011a82:	4628      	mov	r0, r5
 8011a84:	f7ff f848 	bl	8010b18 <alloc_socket>

  if (i == -1) {
 8011a88:	1c43      	adds	r3, r0, #1
    LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
    set_errno(ENOBUFS);
    return -1;
  }

  i = alloc_socket(conn, 0);
 8011a8a:	4604      	mov	r4, r0

  if (i == -1) {
 8011a8c:	d017      	beq.n	8011abe <lwip_socket+0x6e>
    netconn_delete(conn);
    set_errno(ENFILE);
    return -1;
  }
  conn->socket = i;
 8011a8e:	f8c5 0094 	str.w	r0, [r5, #148]	; 0x94
  LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
  set_errno(0);
  return i;
 8011a92:	bd38      	pop	{r3, r4, r5, pc}
  LWIP_UNUSED_ARG(domain);

  /* create a netconn */
  switch (type) {
  case SOCK_RAW:
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
 8011a94:	b2d1      	uxtb	r1, r2
 8011a96:	2040      	movs	r0, #64	; 0x40
 8011a98:	4a0b      	ldr	r2, [pc, #44]	; (8011ac8 <lwip_socket+0x78>)
 8011a9a:	f7f9 ffbf 	bl	800ba1c <netconn_new_with_proto_and_callback>
 8011a9e:	4605      	mov	r5, r0
                                 domain, type, protocol));
    set_errno(EINVAL);
    return -1;
  }

  if (!conn) {
 8011aa0:	2d00      	cmp	r5, #0
 8011aa2:	d1ed      	bne.n	8011a80 <lwip_socket+0x30>
 8011aa4:	e7db      	b.n	8011a5e <lwip_socket+0xe>
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  case SOCK_DGRAM:
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
 8011aa6:	2a88      	cmp	r2, #136	; 0x88
 8011aa8:	bf0c      	ite	eq
 8011aaa:	2021      	moveq	r0, #33	; 0x21
 8011aac:	2020      	movne	r0, #32
 8011aae:	4a06      	ldr	r2, [pc, #24]	; (8011ac8 <lwip_socket+0x78>)
 8011ab0:	2100      	movs	r1, #0
 8011ab2:	f7f9 ffb3 	bl	800ba1c <netconn_new_with_proto_and_callback>
 8011ab6:	4605      	mov	r5, r0
                                 domain, type, protocol));
    set_errno(EINVAL);
    return -1;
  }

  if (!conn) {
 8011ab8:	2d00      	cmp	r5, #0
 8011aba:	d1e1      	bne.n	8011a80 <lwip_socket+0x30>
 8011abc:	e7cf      	b.n	8011a5e <lwip_socket+0xe>
  }

  i = alloc_socket(conn, 0);

  if (i == -1) {
    netconn_delete(conn);
 8011abe:	4628      	mov	r0, r5
 8011ac0:	f7fa f80a 	bl	800bad8 <netconn_delete>
    set_errno(ENFILE);
    return -1;
 8011ac4:	4620      	mov	r0, r4
 8011ac6:	bd38      	pop	{r3, r4, r5, pc}
 8011ac8:	08010d35 	.word	0x08010d35

08011acc <lwip_write>:
}

int
lwip_write(int s, const void *data, size_t size)
{
  return lwip_send(s, data, size, 0);
 8011acc:	2300      	movs	r3, #0
 8011ace:	f7ff bf71 	b.w	80119b4 <lwip_send>
 8011ad2:	bf00      	nop

08011ad4 <lwip_select>:
 * Processing exceptset is not yet implemented.
 */
int
lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
            struct timeval *timeout)
{
 8011ad4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8011ad8:	b09d      	sub	sp, #116	; 0x74
                  timeout ? (s32_t)timeout->tv_sec : (s32_t)-1,
                  timeout ? (s32_t)timeout->tv_usec : (s32_t)-1));

  /* Go through each socket in each list to count number of sockets which
     currently match */
  nready = lwip_selscan(maxfdp1, readset, writeset, exceptset, &lreadset, &lwriteset, &lexceptset);
 8011ada:	ac0a      	add	r4, sp, #40	; 0x28
 8011adc:	9402      	str	r4, [sp, #8]
 8011ade:	ac08      	add	r4, sp, #32
 8011ae0:	9401      	str	r4, [sp, #4]
 8011ae2:	ac06      	add	r4, sp, #24
 8011ae4:	9400      	str	r4, [sp, #0]
 * Processing exceptset is not yet implemented.
 */
int
lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
            struct timeval *timeout)
{
 8011ae6:	4699      	mov	r9, r3
 8011ae8:	4680      	mov	r8, r0
 8011aea:	460d      	mov	r5, r1
 8011aec:	4617      	mov	r7, r2
                  timeout ? (s32_t)timeout->tv_sec : (s32_t)-1,
                  timeout ? (s32_t)timeout->tv_usec : (s32_t)-1));

  /* Go through each socket in each list to count number of sockets which
     currently match */
  nready = lwip_selscan(maxfdp1, readset, writeset, exceptset, &lreadset, &lwriteset, &lexceptset);
 8011aee:	f7ff f851 	bl	8010b94 <lwip_selscan>

  /* If we don't have any current events, then suspend if we are supposed to */
  if (!nready) {
 8011af2:	4603      	mov	r3, r0
 8011af4:	2800      	cmp	r0, #0
 8011af6:	f040 8092 	bne.w	8011c1e <lwip_select+0x14a>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
 8011afa:	9a26      	ldr	r2, [sp, #152]	; 0x98
 8011afc:	b132      	cbz	r2, 8011b0c <lwip_select+0x38>
 8011afe:	6812      	ldr	r2, [r2, #0]
 8011b00:	b922      	cbnz	r2, 8011b0c <lwip_select+0x38>
 8011b02:	9a26      	ldr	r2, [sp, #152]	; 0x98
 8011b04:	6852      	ldr	r2, [r2, #4]
 8011b06:	2a00      	cmp	r2, #0
 8011b08:	f000 8089 	beq.w	8011c1e <lwip_select+0x14a>
    /* None ready: add our semaphore to list:
       We don't actually need any dynamic memory. Our entry on the
       list is only valid while we are in this function, so it's ok
       to use local variables. */

    select_cb.next = NULL;
 8011b0c:	2300      	movs	r3, #0
    select_cb.prev = NULL;
    select_cb.readset = readset;
    select_cb.writeset = writeset;
    select_cb.exceptset = exceptset;
    select_cb.sem_signalled = 0;
    err = sys_sem_new(&select_cb.sem, 0);
 8011b0e:	4619      	mov	r1, r3
 8011b10:	a812      	add	r0, sp, #72	; 0x48
       list is only valid while we are in this function, so it's ok
       to use local variables. */

    select_cb.next = NULL;
    select_cb.prev = NULL;
    select_cb.readset = readset;
 8011b12:	950e      	str	r5, [sp, #56]	; 0x38
    select_cb.writeset = writeset;
 8011b14:	970f      	str	r7, [sp, #60]	; 0x3c
    select_cb.exceptset = exceptset;
 8011b16:	f8cd 9040 	str.w	r9, [sp, #64]	; 0x40
    /* None ready: add our semaphore to list:
       We don't actually need any dynamic memory. Our entry on the
       list is only valid while we are in this function, so it's ok
       to use local variables. */

    select_cb.next = NULL;
 8011b1a:	930c      	str	r3, [sp, #48]	; 0x30
    select_cb.prev = NULL;
 8011b1c:	930d      	str	r3, [sp, #52]	; 0x34
    select_cb.readset = readset;
    select_cb.writeset = writeset;
    select_cb.exceptset = exceptset;
    select_cb.sem_signalled = 0;
 8011b1e:	9311      	str	r3, [sp, #68]	; 0x44
    err = sys_sem_new(&select_cb.sem, 0);
 8011b20:	f001 faf0 	bl	8013104 <sys_sem_new>
    if (err != ERR_OK) {
 8011b24:	2800      	cmp	r0, #0
 8011b26:	f040 811a 	bne.w	8011d5e <lwip_select+0x28a>

    /* Protect the select_cb_list */
    SYS_ARCH_PROTECT(lev);

    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
 8011b2a:	f8df b2bc 	ldr.w	fp, [pc, #700]	; 8011de8 <lwip_select+0x314>
      set_errno(ENOMEM);
      return -1;
    }

    /* Protect the select_cb_list */
    SYS_ARCH_PROTECT(lev);
 8011b2e:	f7ef fe21 	bl	8001774 <CPU_SR_Save>

    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
 8011b32:	f8db 3060 	ldr.w	r3, [fp, #96]	; 0x60
 8011b36:	930c      	str	r3, [sp, #48]	; 0x30
    if (select_cb_list != NULL) {
 8011b38:	b10b      	cbz	r3, 8011b3e <lwip_select+0x6a>
      select_cb_list->prev = &select_cb;
 8011b3a:	aa0c      	add	r2, sp, #48	; 0x30
 8011b3c:	605a      	str	r2, [r3, #4]
    }
    select_cb_list = &select_cb;
    /* Increasing this counter tells even_callback that the list has changed. */
    select_cb_ctr++;
 8011b3e:	f8db 3064 	ldr.w	r3, [fp, #100]	; 0x64
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
    if (select_cb_list != NULL) {
      select_cb_list->prev = &select_cb;
    }
    select_cb_list = &select_cb;
 8011b42:	aa0c      	add	r2, sp, #48	; 0x30
    /* Increasing this counter tells even_callback that the list has changed. */
    select_cb_ctr++;
 8011b44:	3301      	adds	r3, #1
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
    if (select_cb_list != NULL) {
      select_cb_list->prev = &select_cb;
    }
    select_cb_list = &select_cb;
 8011b46:	f8cb 2060 	str.w	r2, [fp, #96]	; 0x60
    /* Increasing this counter tells even_callback that the list has changed. */
    select_cb_ctr++;
 8011b4a:	f8cb 3064 	str.w	r3, [fp, #100]	; 0x64

    /* Now we can safely unprotect */
    SYS_ARCH_UNPROTECT(lev);
 8011b4e:	f7ef fe15 	bl	800177c <CPU_SR_Restore>

    /* Increase select_waiting for each socket we are interested in */
    for(i = 0; i < maxfdp1; i++) {
 8011b52:	f1b8 0f00 	cmp.w	r8, #0
 8011b56:	dd1b      	ble.n	8011b90 <lwip_select+0xbc>
 8011b58:	4ea3      	ldr	r6, [pc, #652]	; (8011de8 <lwip_select+0x314>)
 8011b5a:	2400      	movs	r4, #0
      if ((readset && FD_ISSET(i, readset)) ||
 8011b5c:	2d00      	cmp	r5, #0
 8011b5e:	d076      	beq.n	8011c4e <lwip_select+0x17a>
 8011b60:	0963      	lsrs	r3, r4, #5
 8011b62:	f855 2023 	ldr.w	r2, [r5, r3, lsl #2]
 8011b66:	f004 011f 	and.w	r1, r4, #31
 8011b6a:	2301      	movs	r3, #1
 8011b6c:	408b      	lsls	r3, r1
 8011b6e:	4213      	tst	r3, r2
 8011b70:	d06d      	beq.n	8011c4e <lwip_select+0x17a>
 * @return struct lwip_sock for the socket or NULL if not found
 */
static struct lwip_sock *
tryget_socket(int s)
{
  if ((s < 0) || (s >= NUM_SOCKETS)) {
 8011b72:	2c03      	cmp	r4, #3
 8011b74:	f240 811d 	bls.w	8011db2 <lwip_select+0x2de>
    for(i = 0; i < maxfdp1; i++) {
      if ((readset && FD_ISSET(i, readset)) ||
          (writeset && FD_ISSET(i, writeset)) ||
          (exceptset && FD_ISSET(i, exceptset))) {
        struct lwip_sock *sock = tryget_socket(i);
        LWIP_ASSERT("sock != NULL", sock != NULL);
 8011b78:	f240 4285 	movw	r2, #1157	; 0x485
 8011b7c:	4b9b      	ldr	r3, [pc, #620]	; (8011dec <lwip_select+0x318>)
    for(i = 0; i < maxfdp1; i++) {
      if ((readset && FD_ISSET(i, readset)) ||
          (writeset && FD_ISSET(i, writeset)) ||
          (exceptset && FD_ISSET(i, exceptset))) {
        struct lwip_sock *sock = tryget_socket(i);
        LWIP_ASSERT("sock != NULL", sock != NULL);
 8011b7e:	499c      	ldr	r1, [pc, #624]	; (8011df0 <lwip_select+0x31c>)
 8011b80:	489c      	ldr	r0, [pc, #624]	; (8011df4 <lwip_select+0x320>)
 8011b82:	f003 f8f9 	bl	8014d78 <iprintf>
        SYS_ARCH_PROTECT(lev);
 8011b86:	f7ef fdf5 	bl	8001774 <CPU_SR_Save>
        sock->select_waiting--;
 8011b8a:	2300      	movs	r3, #0
 8011b8c:	695b      	ldr	r3, [r3, #20]
 8011b8e:	deff      	udf	#255	; 0xff
      }
    }

    /* Call lwip_selscan again: there could have been events between
       the last scan (whithout us on the list) and putting us on the list! */
    nready = lwip_selscan(maxfdp1, readset, writeset, exceptset, &lreadset, &lwriteset, &lexceptset);
 8011b90:	ab0a      	add	r3, sp, #40	; 0x28
 8011b92:	9302      	str	r3, [sp, #8]
 8011b94:	ab08      	add	r3, sp, #32
 8011b96:	9301      	str	r3, [sp, #4]
 8011b98:	ab06      	add	r3, sp, #24
 8011b9a:	9300      	str	r3, [sp, #0]
 8011b9c:	463a      	mov	r2, r7
 8011b9e:	464b      	mov	r3, r9
 8011ba0:	4629      	mov	r1, r5
 8011ba2:	4640      	mov	r0, r8
 8011ba4:	f7fe fff6 	bl	8010b94 <lwip_selscan>
    if (!nready) {
 8011ba8:	9005      	str	r0, [sp, #20]
 8011baa:	2800      	cmp	r0, #0
 8011bac:	f040 8119 	bne.w	8011de2 <lwip_select+0x30e>
      /* Still none ready, just wait to be woken */
      if (timeout == 0) {
 8011bb0:	9b26      	ldr	r3, [sp, #152]	; 0x98
 8011bb2:	2b00      	cmp	r3, #0
 8011bb4:	f040 80a8 	bne.w	8011d08 <lwip_select+0x234>
          /* Wait 1ms at least (0 means wait forever) */
          msectimeout = 1;
        }
      }

      waitres = sys_arch_sem_wait(&select_cb.sem, msectimeout);
 8011bb8:	9905      	ldr	r1, [sp, #20]
 8011bba:	a812      	add	r0, sp, #72	; 0x48
 8011bbc:	f001 fac0 	bl	8013140 <sys_arch_sem_wait>
 8011bc0:	9004      	str	r0, [sp, #16]
        LWIP_ASSERT("sock->select_waiting >= 0", sock->select_waiting >= 0);
        SYS_ARCH_UNPROTECT(lev);
      }
    }
    /* Take us off the list */
    SYS_ARCH_PROTECT(lev);
 8011bc2:	f7ef fdd7 	bl	8001774 <CPU_SR_Save>
    if (select_cb.next != NULL) {
 8011bc6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
        LWIP_ASSERT("sock->select_waiting >= 0", sock->select_waiting >= 0);
        SYS_ARCH_UNPROTECT(lev);
      }
    }
    /* Take us off the list */
    SYS_ARCH_PROTECT(lev);
 8011bc8:	4604      	mov	r4, r0
    if (select_cb.next != NULL) {
 8011bca:	b10b      	cbz	r3, 8011bd0 <lwip_select+0xfc>
      select_cb.next->prev = select_cb.prev;
 8011bcc:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8011bce:	605a      	str	r2, [r3, #4]
    }
    if (select_cb_list == &select_cb) {
 8011bd0:	f8db 2060 	ldr.w	r2, [fp, #96]	; 0x60
 8011bd4:	a90c      	add	r1, sp, #48	; 0x30
 8011bd6:	428a      	cmp	r2, r1
      LWIP_ASSERT("select_cb.prev == NULL", select_cb.prev == NULL);
 8011bd8:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    /* Take us off the list */
    SYS_ARCH_PROTECT(lev);
    if (select_cb.next != NULL) {
      select_cb.next->prev = select_cb.prev;
    }
    if (select_cb_list == &select_cb) {
 8011bda:	f000 80b4 	beq.w	8011d46 <lwip_select+0x272>
      LWIP_ASSERT("select_cb.prev == NULL", select_cb.prev == NULL);
      select_cb_list = select_cb.next;
    } else {
      LWIP_ASSERT("select_cb.prev != NULL", select_cb.prev != NULL);
 8011bde:	2a00      	cmp	r2, #0
 8011be0:	f000 80c6 	beq.w	8011d70 <lwip_select+0x29c>
      select_cb.prev->next = select_cb.next;
 8011be4:	6013      	str	r3, [r2, #0]
    }
    /* Increasing this counter tells even_callback that the list has changed. */
    select_cb_ctr++;
 8011be6:	f8db 3064 	ldr.w	r3, [fp, #100]	; 0x64
    SYS_ARCH_UNPROTECT(lev);
 8011bea:	4620      	mov	r0, r4
    } else {
      LWIP_ASSERT("select_cb.prev != NULL", select_cb.prev != NULL);
      select_cb.prev->next = select_cb.next;
    }
    /* Increasing this counter tells even_callback that the list has changed. */
    select_cb_ctr++;
 8011bec:	3301      	adds	r3, #1
 8011bee:	f8cb 3064 	str.w	r3, [fp, #100]	; 0x64
    SYS_ARCH_UNPROTECT(lev);
 8011bf2:	f7ef fdc3 	bl	800177c <CPU_SR_Restore>

    sys_sem_free(&select_cb.sem);
 8011bf6:	a812      	add	r0, sp, #72	; 0x48
 8011bf8:	f001 fadc 	bl	80131b4 <sys_sem_free>
    if (waitres == SYS_ARCH_TIMEOUT)  {
 8011bfc:	9b04      	ldr	r3, [sp, #16]
 8011bfe:	3301      	adds	r3, #1
 8011c00:	f000 809f 	beq.w	8011d42 <lwip_select+0x26e>
         or we would have returned earlier. */
      goto return_copy_fdsets;
    }

    /* See what's set */
    nready = lwip_selscan(maxfdp1, readset, writeset, exceptset, &lreadset, &lwriteset, &lexceptset);
 8011c04:	ab0a      	add	r3, sp, #40	; 0x28
 8011c06:	9302      	str	r3, [sp, #8]
 8011c08:	ab08      	add	r3, sp, #32
 8011c0a:	9301      	str	r3, [sp, #4]
 8011c0c:	ab06      	add	r3, sp, #24
 8011c0e:	9300      	str	r3, [sp, #0]
 8011c10:	4640      	mov	r0, r8
 8011c12:	464b      	mov	r3, r9
 8011c14:	463a      	mov	r2, r7
 8011c16:	4629      	mov	r1, r5
 8011c18:	f7fe ffbc 	bl	8010b94 <lwip_selscan>
 8011c1c:	4603      	mov	r3, r0
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
return_copy_fdsets:
  set_errno(0);
  if (readset) {
 8011c1e:	b125      	cbz	r5, 8011c2a <lwip_select+0x156>
    *readset = lreadset;
 8011c20:	aa06      	add	r2, sp, #24
 8011c22:	e892 0003 	ldmia.w	r2, {r0, r1}
 8011c26:	e885 0003 	stmia.w	r5, {r0, r1}
  }
  if (writeset) {
 8011c2a:	b127      	cbz	r7, 8011c36 <lwip_select+0x162>
    *writeset = lwriteset;
 8011c2c:	aa08      	add	r2, sp, #32
 8011c2e:	e892 0003 	ldmia.w	r2, {r0, r1}
 8011c32:	e887 0003 	stmia.w	r7, {r0, r1}
  }
  if (exceptset) {
 8011c36:	f1b9 0f00 	cmp.w	r9, #0
 8011c3a:	d004      	beq.n	8011c46 <lwip_select+0x172>
    *exceptset = lexceptset;
 8011c3c:	aa0a      	add	r2, sp, #40	; 0x28
 8011c3e:	e892 0003 	ldmia.w	r2, {r0, r1}
 8011c42:	e889 0003 	stmia.w	r9, {r0, r1}
  }


  return nready;
}
 8011c46:	4618      	mov	r0, r3
 8011c48:	b01d      	add	sp, #116	; 0x74
 8011c4a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    /* Now we can safely unprotect */
    SYS_ARCH_UNPROTECT(lev);

    /* Increase select_waiting for each socket we are interested in */
    for(i = 0; i < maxfdp1; i++) {
      if ((readset && FD_ISSET(i, readset)) ||
 8011c4e:	b147      	cbz	r7, 8011c62 <lwip_select+0x18e>
          (writeset && FD_ISSET(i, writeset)) ||
 8011c50:	0963      	lsrs	r3, r4, #5
 8011c52:	f857 2023 	ldr.w	r2, [r7, r3, lsl #2]
 8011c56:	f004 011f 	and.w	r1, r4, #31
 8011c5a:	2301      	movs	r3, #1
 8011c5c:	408b      	lsls	r3, r1
 8011c5e:	4213      	tst	r3, r2
 8011c60:	d187      	bne.n	8011b72 <lwip_select+0x9e>
 8011c62:	f1b9 0f00 	cmp.w	r9, #0
 8011c66:	d009      	beq.n	8011c7c <lwip_select+0x1a8>
          (exceptset && FD_ISSET(i, exceptset))) {
 8011c68:	0963      	lsrs	r3, r4, #5
 8011c6a:	f859 2023 	ldr.w	r2, [r9, r3, lsl #2]
 8011c6e:	f004 011f 	and.w	r1, r4, #31
 8011c72:	2301      	movs	r3, #1
 8011c74:	408b      	lsls	r3, r1
 8011c76:	4213      	tst	r3, r2
 8011c78:	f47f af7b 	bne.w	8011b72 <lwip_select+0x9e>

    /* Now we can safely unprotect */
    SYS_ARCH_UNPROTECT(lev);

    /* Increase select_waiting for each socket we are interested in */
    for(i = 0; i < maxfdp1; i++) {
 8011c7c:	3401      	adds	r4, #1
 8011c7e:	45a0      	cmp	r8, r4
 8011c80:	f106 0618 	add.w	r6, r6, #24
 8011c84:	f47f af6a 	bne.w	8011b5c <lwip_select+0x88>
      }
    }

    /* Call lwip_selscan again: there could have been events between
       the last scan (whithout us on the list) and putting us on the list! */
    nready = lwip_selscan(maxfdp1, readset, writeset, exceptset, &lreadset, &lwriteset, &lexceptset);
 8011c88:	ab0a      	add	r3, sp, #40	; 0x28
 8011c8a:	9302      	str	r3, [sp, #8]
 8011c8c:	ab08      	add	r3, sp, #32
 8011c8e:	9301      	str	r3, [sp, #4]
 8011c90:	ab06      	add	r3, sp, #24
 8011c92:	9300      	str	r3, [sp, #0]
 8011c94:	463a      	mov	r2, r7
 8011c96:	464b      	mov	r3, r9
 8011c98:	4629      	mov	r1, r5
 8011c9a:	4640      	mov	r0, r8
 8011c9c:	f7fe ff7a 	bl	8010b94 <lwip_selscan>
    if (!nready) {
 8011ca0:	9005      	str	r0, [sp, #20]
 8011ca2:	b378      	cbz	r0, 8011d04 <lwip_select+0x230>
 */
int
lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
            struct timeval *timeout)
{
  u32_t waitres = 0;
 8011ca4:	2300      	movs	r3, #0
 8011ca6:	9304      	str	r3, [sp, #16]
 8011ca8:	4e4f      	ldr	r6, [pc, #316]	; (8011de8 <lwip_select+0x314>)
 8011caa:	2400      	movs	r4, #0

      waitres = sys_arch_sem_wait(&select_cb.sem, msectimeout);
    }
    /* Increase select_waiting for each socket we are interested in */
    for(i = 0; i < maxfdp1; i++) {
      if ((readset && FD_ISSET(i, readset)) ||
 8011cac:	b175      	cbz	r5, 8011ccc <lwip_select+0x1f8>
 8011cae:	0963      	lsrs	r3, r4, #5
 8011cb0:	f855 2023 	ldr.w	r2, [r5, r3, lsl #2]
 8011cb4:	f004 011f 	and.w	r1, r4, #31
 8011cb8:	2301      	movs	r3, #1
 8011cba:	408b      	lsls	r3, r1
 8011cbc:	4213      	tst	r3, r2
 8011cbe:	d005      	beq.n	8011ccc <lwip_select+0x1f8>
 * @return struct lwip_sock for the socket or NULL if not found
 */
static struct lwip_sock *
tryget_socket(int s)
{
  if ((s < 0) || (s >= NUM_SOCKETS)) {
 8011cc0:	2c03      	cmp	r4, #3
 8011cc2:	d95f      	bls.n	8011d84 <lwip_select+0x2b0>
    for(i = 0; i < maxfdp1; i++) {
      if ((readset && FD_ISSET(i, readset)) ||
          (writeset && FD_ISSET(i, writeset)) ||
          (exceptset && FD_ISSET(i, exceptset))) {
        struct lwip_sock *sock = tryget_socket(i);
        LWIP_ASSERT("sock != NULL", sock != NULL);
 8011cc4:	4b49      	ldr	r3, [pc, #292]	; (8011dec <lwip_select+0x318>)
 8011cc6:	f240 42a5 	movw	r2, #1189	; 0x4a5
 8011cca:	e758      	b.n	8011b7e <lwip_select+0xaa>

      waitres = sys_arch_sem_wait(&select_cb.sem, msectimeout);
    }
    /* Increase select_waiting for each socket we are interested in */
    for(i = 0; i < maxfdp1; i++) {
      if ((readset && FD_ISSET(i, readset)) ||
 8011ccc:	b147      	cbz	r7, 8011ce0 <lwip_select+0x20c>
          (writeset && FD_ISSET(i, writeset)) ||
 8011cce:	0963      	lsrs	r3, r4, #5
 8011cd0:	f857 2023 	ldr.w	r2, [r7, r3, lsl #2]
 8011cd4:	f004 011f 	and.w	r1, r4, #31
 8011cd8:	2301      	movs	r3, #1
 8011cda:	408b      	lsls	r3, r1
 8011cdc:	4213      	tst	r3, r2
 8011cde:	d1ef      	bne.n	8011cc0 <lwip_select+0x1ec>
 8011ce0:	f1b9 0f00 	cmp.w	r9, #0
 8011ce4:	d008      	beq.n	8011cf8 <lwip_select+0x224>
          (exceptset && FD_ISSET(i, exceptset))) {
 8011ce6:	0963      	lsrs	r3, r4, #5
 8011ce8:	f859 2023 	ldr.w	r2, [r9, r3, lsl #2]
 8011cec:	f004 011f 	and.w	r1, r4, #31
 8011cf0:	2301      	movs	r3, #1
 8011cf2:	408b      	lsls	r3, r1
 8011cf4:	4213      	tst	r3, r2
 8011cf6:	d1e3      	bne.n	8011cc0 <lwip_select+0x1ec>
      }

      waitres = sys_arch_sem_wait(&select_cb.sem, msectimeout);
    }
    /* Increase select_waiting for each socket we are interested in */
    for(i = 0; i < maxfdp1; i++) {
 8011cf8:	3401      	adds	r4, #1
 8011cfa:	45a0      	cmp	r8, r4
 8011cfc:	f106 0618 	add.w	r6, r6, #24
 8011d00:	dcd4      	bgt.n	8011cac <lwip_select+0x1d8>
 8011d02:	e75e      	b.n	8011bc2 <lwip_select+0xee>
    /* Call lwip_selscan again: there could have been events between
       the last scan (whithout us on the list) and putting us on the list! */
    nready = lwip_selscan(maxfdp1, readset, writeset, exceptset, &lreadset, &lwriteset, &lexceptset);
    if (!nready) {
      /* Still none ready, just wait to be woken */
      if (timeout == 0) {
 8011d04:	9b26      	ldr	r3, [sp, #152]	; 0x98
 8011d06:	b36b      	cbz	r3, 8011d64 <lwip_select+0x290>
        /* Wait forever */
        msectimeout = 0;
      } else {
        msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
 8011d08:	9b26      	ldr	r3, [sp, #152]	; 0x98
 8011d0a:	493b      	ldr	r1, [pc, #236]	; (8011df8 <lwip_select+0x324>)
 8011d0c:	685b      	ldr	r3, [r3, #4]
          /* Wait 1ms at least (0 means wait forever) */
          msectimeout = 1;
        }
      }

      waitres = sys_arch_sem_wait(&select_cb.sem, msectimeout);
 8011d0e:	a812      	add	r0, sp, #72	; 0x48
      /* Still none ready, just wait to be woken */
      if (timeout == 0) {
        /* Wait forever */
        msectimeout = 0;
      } else {
        msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
 8011d10:	f503 73fa 	add.w	r3, r3, #500	; 0x1f4
 8011d14:	fb81 2103 	smull	r2, r1, r1, r3
 8011d18:	9a26      	ldr	r2, [sp, #152]	; 0x98
 8011d1a:	17db      	asrs	r3, r3, #31
 8011d1c:	6812      	ldr	r2, [r2, #0]
 8011d1e:	ebc3 13a1 	rsb	r3, r3, r1, asr #6
 8011d22:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8011d26:	fb01 3102 	mla	r1, r1, r2, r3
        if (msectimeout == 0) {
          /* Wait 1ms at least (0 means wait forever) */
          msectimeout = 1;
 8011d2a:	2900      	cmp	r1, #0
        }
      }

      waitres = sys_arch_sem_wait(&select_cb.sem, msectimeout);
 8011d2c:	bf08      	it	eq
 8011d2e:	2101      	moveq	r1, #1
 8011d30:	f001 fa06 	bl	8013140 <sys_arch_sem_wait>
    }
    /* Increase select_waiting for each socket we are interested in */
    for(i = 0; i < maxfdp1; i++) {
 8011d34:	2300      	movs	r3, #0
 8011d36:	f1b8 0f00 	cmp.w	r8, #0
          /* Wait 1ms at least (0 means wait forever) */
          msectimeout = 1;
        }
      }

      waitres = sys_arch_sem_wait(&select_cb.sem, msectimeout);
 8011d3a:	9004      	str	r0, [sp, #16]
    }
    /* Increase select_waiting for each socket we are interested in */
    for(i = 0; i < maxfdp1; i++) {
 8011d3c:	9305      	str	r3, [sp, #20]
 8011d3e:	dcb3      	bgt.n	8011ca8 <lwip_select+0x1d4>
 8011d40:	e73f      	b.n	8011bc2 <lwip_select+0xee>
 8011d42:	9b05      	ldr	r3, [sp, #20]
 8011d44:	e76b      	b.n	8011c1e <lwip_select+0x14a>
    SYS_ARCH_PROTECT(lev);
    if (select_cb.next != NULL) {
      select_cb.next->prev = select_cb.prev;
    }
    if (select_cb_list == &select_cb) {
      LWIP_ASSERT("select_cb.prev == NULL", select_cb.prev == NULL);
 8011d46:	b13a      	cbz	r2, 8011d58 <lwip_select+0x284>
 8011d48:	4b28      	ldr	r3, [pc, #160]	; (8011dec <lwip_select+0x318>)
 8011d4a:	f240 42b2 	movw	r2, #1202	; 0x4b2
 8011d4e:	492b      	ldr	r1, [pc, #172]	; (8011dfc <lwip_select+0x328>)
 8011d50:	4828      	ldr	r0, [pc, #160]	; (8011df4 <lwip_select+0x320>)
 8011d52:	f003 f811 	bl	8014d78 <iprintf>
 8011d56:	9b0c      	ldr	r3, [sp, #48]	; 0x30
      select_cb_list = select_cb.next;
 8011d58:	f8cb 3060 	str.w	r3, [fp, #96]	; 0x60
 8011d5c:	e743      	b.n	8011be6 <lwip_select+0x112>
    select_cb.sem_signalled = 0;
    err = sys_sem_new(&select_cb.sem, 0);
    if (err != ERR_OK) {
      /* failed to create semaphore */
      set_errno(ENOMEM);
      return -1;
 8011d5e:	f04f 33ff 	mov.w	r3, #4294967295
 8011d62:	e770      	b.n	8011c46 <lwip_select+0x172>
          /* Wait 1ms at least (0 means wait forever) */
          msectimeout = 1;
        }
      }

      waitres = sys_arch_sem_wait(&select_cb.sem, msectimeout);
 8011d64:	9905      	ldr	r1, [sp, #20]
 8011d66:	a812      	add	r0, sp, #72	; 0x48
 8011d68:	f001 f9ea 	bl	8013140 <sys_arch_sem_wait>
 8011d6c:	9004      	str	r0, [sp, #16]
 8011d6e:	e79b      	b.n	8011ca8 <lwip_select+0x1d4>
    }
    if (select_cb_list == &select_cb) {
      LWIP_ASSERT("select_cb.prev == NULL", select_cb.prev == NULL);
      select_cb_list = select_cb.next;
    } else {
      LWIP_ASSERT("select_cb.prev != NULL", select_cb.prev != NULL);
 8011d70:	4b1e      	ldr	r3, [pc, #120]	; (8011dec <lwip_select+0x318>)
 8011d72:	f240 42b5 	movw	r2, #1205	; 0x4b5
 8011d76:	4922      	ldr	r1, [pc, #136]	; (8011e00 <lwip_select+0x32c>)
 8011d78:	481e      	ldr	r0, [pc, #120]	; (8011df4 <lwip_select+0x320>)
 8011d7a:	f002 fffd 	bl	8014d78 <iprintf>
 8011d7e:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 8011d80:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8011d82:	e72f      	b.n	8011be4 <lwip_select+0x110>
tryget_socket(int s)
{
  if ((s < 0) || (s >= NUM_SOCKETS)) {
    return NULL;
  }
  if (!sockets[s].conn) {
 8011d84:	6833      	ldr	r3, [r6, #0]
 8011d86:	2b00      	cmp	r3, #0
 8011d88:	d09c      	beq.n	8011cc4 <lwip_select+0x1f0>
      if ((readset && FD_ISSET(i, readset)) ||
          (writeset && FD_ISSET(i, writeset)) ||
          (exceptset && FD_ISSET(i, exceptset))) {
        struct lwip_sock *sock = tryget_socket(i);
        LWIP_ASSERT("sock != NULL", sock != NULL);
        SYS_ARCH_PROTECT(lev);
 8011d8a:	f7ef fcf3 	bl	8001774 <CPU_SR_Save>
        sock->select_waiting--;
 8011d8e:	6973      	ldr	r3, [r6, #20]
      if ((readset && FD_ISSET(i, readset)) ||
          (writeset && FD_ISSET(i, writeset)) ||
          (exceptset && FD_ISSET(i, exceptset))) {
        struct lwip_sock *sock = tryget_socket(i);
        LWIP_ASSERT("sock != NULL", sock != NULL);
        SYS_ARCH_PROTECT(lev);
 8011d90:	4682      	mov	sl, r0
        sock->select_waiting--;
 8011d92:	3b01      	subs	r3, #1
        LWIP_ASSERT("sock->select_waiting >= 0", sock->select_waiting >= 0);
 8011d94:	2b00      	cmp	r3, #0
          (writeset && FD_ISSET(i, writeset)) ||
          (exceptset && FD_ISSET(i, exceptset))) {
        struct lwip_sock *sock = tryget_socket(i);
        LWIP_ASSERT("sock != NULL", sock != NULL);
        SYS_ARCH_PROTECT(lev);
        sock->select_waiting--;
 8011d96:	6173      	str	r3, [r6, #20]
        LWIP_ASSERT("sock->select_waiting >= 0", sock->select_waiting >= 0);
 8011d98:	db03      	blt.n	8011da2 <lwip_select+0x2ce>
        SYS_ARCH_UNPROTECT(lev);
 8011d9a:	4650      	mov	r0, sl
 8011d9c:	f7ef fcee 	bl	800177c <CPU_SR_Restore>
 8011da0:	e7aa      	b.n	8011cf8 <lwip_select+0x224>
          (exceptset && FD_ISSET(i, exceptset))) {
        struct lwip_sock *sock = tryget_socket(i);
        LWIP_ASSERT("sock != NULL", sock != NULL);
        SYS_ARCH_PROTECT(lev);
        sock->select_waiting--;
        LWIP_ASSERT("sock->select_waiting >= 0", sock->select_waiting >= 0);
 8011da2:	4b12      	ldr	r3, [pc, #72]	; (8011dec <lwip_select+0x318>)
 8011da4:	f44f 6295 	mov.w	r2, #1192	; 0x4a8
 8011da8:	4916      	ldr	r1, [pc, #88]	; (8011e04 <lwip_select+0x330>)
 8011daa:	4812      	ldr	r0, [pc, #72]	; (8011df4 <lwip_select+0x320>)
 8011dac:	f002 ffe4 	bl	8014d78 <iprintf>
 8011db0:	e7f3      	b.n	8011d9a <lwip_select+0x2c6>
tryget_socket(int s)
{
  if ((s < 0) || (s >= NUM_SOCKETS)) {
    return NULL;
  }
  if (!sockets[s].conn) {
 8011db2:	6833      	ldr	r3, [r6, #0]
 8011db4:	2b00      	cmp	r3, #0
 8011db6:	f43f aedf 	beq.w	8011b78 <lwip_select+0xa4>
      if ((readset && FD_ISSET(i, readset)) ||
          (writeset && FD_ISSET(i, writeset)) ||
          (exceptset && FD_ISSET(i, exceptset))) {
        struct lwip_sock *sock = tryget_socket(i);
        LWIP_ASSERT("sock != NULL", sock != NULL);
        SYS_ARCH_PROTECT(lev);
 8011dba:	f7ef fcdb 	bl	8001774 <CPU_SR_Save>
        sock->select_waiting++;
 8011dbe:	6973      	ldr	r3, [r6, #20]
      if ((readset && FD_ISSET(i, readset)) ||
          (writeset && FD_ISSET(i, writeset)) ||
          (exceptset && FD_ISSET(i, exceptset))) {
        struct lwip_sock *sock = tryget_socket(i);
        LWIP_ASSERT("sock != NULL", sock != NULL);
        SYS_ARCH_PROTECT(lev);
 8011dc0:	4682      	mov	sl, r0
        sock->select_waiting++;
 8011dc2:	3301      	adds	r3, #1
        LWIP_ASSERT("sock->select_waiting > 0", sock->select_waiting > 0);
 8011dc4:	2b00      	cmp	r3, #0
          (writeset && FD_ISSET(i, writeset)) ||
          (exceptset && FD_ISSET(i, exceptset))) {
        struct lwip_sock *sock = tryget_socket(i);
        LWIP_ASSERT("sock != NULL", sock != NULL);
        SYS_ARCH_PROTECT(lev);
        sock->select_waiting++;
 8011dc6:	6173      	str	r3, [r6, #20]
        LWIP_ASSERT("sock->select_waiting > 0", sock->select_waiting > 0);
 8011dc8:	dd03      	ble.n	8011dd2 <lwip_select+0x2fe>
        SYS_ARCH_UNPROTECT(lev);
 8011dca:	4650      	mov	r0, sl
 8011dcc:	f7ef fcd6 	bl	800177c <CPU_SR_Restore>
 8011dd0:	e754      	b.n	8011c7c <lwip_select+0x1a8>
          (exceptset && FD_ISSET(i, exceptset))) {
        struct lwip_sock *sock = tryget_socket(i);
        LWIP_ASSERT("sock != NULL", sock != NULL);
        SYS_ARCH_PROTECT(lev);
        sock->select_waiting++;
        LWIP_ASSERT("sock->select_waiting > 0", sock->select_waiting > 0);
 8011dd2:	4b06      	ldr	r3, [pc, #24]	; (8011dec <lwip_select+0x318>)
 8011dd4:	f44f 6291 	mov.w	r2, #1160	; 0x488
 8011dd8:	490b      	ldr	r1, [pc, #44]	; (8011e08 <lwip_select+0x334>)
 8011dda:	4806      	ldr	r0, [pc, #24]	; (8011df4 <lwip_select+0x320>)
 8011ddc:	f002 ffcc 	bl	8014d78 <iprintf>
 8011de0:	e7f3      	b.n	8011dca <lwip_select+0x2f6>
 */
int
lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
            struct timeval *timeout)
{
  u32_t waitres = 0;
 8011de2:	2300      	movs	r3, #0
 8011de4:	9304      	str	r3, [sp, #16]
 8011de6:	e6ec      	b.n	8011bc2 <lwip_select+0xee>
 8011de8:	20004c40 	.word	0x20004c40
 8011dec:	08018078 	.word	0x08018078
 8011df0:	08018244 	.word	0x08018244
 8011df4:	0801660c 	.word	0x0801660c
 8011df8:	10624dd3 	.word	0x10624dd3
 8011dfc:	08018214 	.word	0x08018214
 8011e00:	0801822c 	.word	0x0801822c
 8011e04:	080181f8 	.word	0x080181f8
 8011e08:	080181dc 	.word	0x080181dc

08011e0c <lwip_shutdown>:
static struct lwip_sock *
get_socket(int s)
{
  struct lwip_sock *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
 8011e0c:	2803      	cmp	r0, #3
 8011e0e:	d80d      	bhi.n	8011e2c <lwip_shutdown+0x20>
 * Unimplemented: Close one end of a full-duplex connection.
 * Currently, the full connection is closed.
 */
int
lwip_shutdown(int s, int how)
{
 8011e10:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    return NULL;
  }

  sock = &sockets[s];

  if (!sock->conn) {
 8011e12:	0047      	lsls	r7, r0, #1
 8011e14:	183c      	adds	r4, r7, r0
 8011e16:	4d1b      	ldr	r5, [pc, #108]	; (8011e84 <lwip_shutdown+0x78>)
 8011e18:	00e3      	lsls	r3, r4, #3
 8011e1a:	58ee      	ldr	r6, [r5, r3]
 8011e1c:	b14e      	cbz	r6, 8011e32 <lwip_shutdown+0x26>
  if (!sock) {
    return -1;
  }

  if (sock->conn != NULL) {
    if (netconn_type(sock->conn) != NETCONN_TCP) {
 8011e1e:	7834      	ldrb	r4, [r6, #0]
 8011e20:	2c10      	cmp	r4, #16
 8011e22:	d009      	beq.n	8011e38 <lwip_shutdown+0x2c>
      sock_set_errno(sock, EOPNOTSUPP);
 8011e24:	442b      	add	r3, r5
 8011e26:	205f      	movs	r0, #95	; 0x5f
 8011e28:	6118      	str	r0, [r3, #16]
      return EOPNOTSUPP;
 8011e2a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));

  sock = get_socket(s);
  if (!sock) {
    return -1;
 8011e2c:	f04f 30ff 	mov.w	r0, #4294967295
  }
  err = netconn_shutdown(sock->conn, shut_rx, shut_tx);

  sock_set_errno(sock, err_to_errno(err));
  return (err == ERR_OK ? 0 : -1);
}
 8011e30:	4770      	bx	lr

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));

  sock = get_socket(s);
  if (!sock) {
    return -1;
 8011e32:	f04f 30ff 	mov.w	r0, #4294967295
  }
  err = netconn_shutdown(sock->conn, shut_rx, shut_tx);

  sock_set_errno(sock, err_to_errno(err));
  return (err == ERR_OK ? 0 : -1);
}
 8011e36:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  } else {
    sock_set_errno(sock, ENOTCONN);
    return ENOTCONN;
  }

  if (how == SHUT_RD) {
 8011e38:	b139      	cbz	r1, 8011e4a <lwip_shutdown+0x3e>
    shut_rx = 1;
  } else if (how == SHUT_WR) {
 8011e3a:	2901      	cmp	r1, #1
 8011e3c:	d01c      	beq.n	8011e78 <lwip_shutdown+0x6c>
    shut_tx = 1;
  } else if(how == SHUT_RDWR) {
 8011e3e:	2902      	cmp	r1, #2
 8011e40:	d01d      	beq.n	8011e7e <lwip_shutdown+0x72>
    shut_rx = 1;
    shut_tx = 1;
  } else {
    sock_set_errno(sock, EINVAL);
 8011e42:	442b      	add	r3, r5
 8011e44:	2016      	movs	r0, #22
 8011e46:	6118      	str	r0, [r3, #16]
    return EINVAL;
 8011e48:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
int
lwip_shutdown(int s, int how)
{
  struct lwip_sock *sock;
  err_t err;
  u8_t shut_rx = 0, shut_tx = 0;
 8011e4a:	460a      	mov	r2, r1
    sock_set_errno(sock, ENOTCONN);
    return ENOTCONN;
  }

  if (how == SHUT_RD) {
    shut_rx = 1;
 8011e4c:	2101      	movs	r1, #1
 8011e4e:	4604      	mov	r4, r0
    shut_tx = 1;
  } else {
    sock_set_errno(sock, EINVAL);
    return EINVAL;
  }
  err = netconn_shutdown(sock->conn, shut_rx, shut_tx);
 8011e50:	4630      	mov	r0, r6
 8011e52:	f7fa f8e1 	bl	800c018 <netconn_shutdown>

  sock_set_errno(sock, err_to_errno(err));
 8011e56:	4243      	negs	r3, r0
 8011e58:	2b0f      	cmp	r3, #15
 8011e5a:	bf96      	itet	ls
 8011e5c:	4a0a      	ldrls	r2, [pc, #40]	; (8011e88 <lwip_shutdown+0x7c>)
 8011e5e:	2205      	movhi	r2, #5
 8011e60:	f852 2023 	ldrls.w	r2, [r2, r3, lsl #2]
  return (err == ERR_OK ? 0 : -1);
 8011e64:	3000      	adds	r0, #0
    sock_set_errno(sock, EINVAL);
    return EINVAL;
  }
  err = netconn_shutdown(sock->conn, shut_rx, shut_tx);

  sock_set_errno(sock, err_to_errno(err));
 8011e66:	eb07 0304 	add.w	r3, r7, r4
  return (err == ERR_OK ? 0 : -1);
 8011e6a:	bf18      	it	ne
 8011e6c:	2001      	movne	r0, #1
    sock_set_errno(sock, EINVAL);
    return EINVAL;
  }
  err = netconn_shutdown(sock->conn, shut_rx, shut_tx);

  sock_set_errno(sock, err_to_errno(err));
 8011e6e:	eb05 03c3 	add.w	r3, r5, r3, lsl #3
 8011e72:	611a      	str	r2, [r3, #16]
  return (err == ERR_OK ? 0 : -1);
 8011e74:	4240      	negs	r0, r0
 8011e76:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  }

  if (how == SHUT_RD) {
    shut_rx = 1;
  } else if (how == SHUT_WR) {
    shut_tx = 1;
 8011e78:	460a      	mov	r2, r1
int
lwip_shutdown(int s, int how)
{
  struct lwip_sock *sock;
  err_t err;
  u8_t shut_rx = 0, shut_tx = 0;
 8011e7a:	2100      	movs	r1, #0
 8011e7c:	e7e7      	b.n	8011e4e <lwip_shutdown+0x42>
    shut_rx = 1;
  } else if (how == SHUT_WR) {
    shut_tx = 1;
  } else if(how == SHUT_RDWR) {
    shut_rx = 1;
    shut_tx = 1;
 8011e7e:	2201      	movs	r2, #1
  if (how == SHUT_RD) {
    shut_rx = 1;
  } else if (how == SHUT_WR) {
    shut_tx = 1;
  } else if(how == SHUT_RDWR) {
    shut_rx = 1;
 8011e80:	4611      	mov	r1, r2
 8011e82:	e7e4      	b.n	8011e4e <lwip_shutdown+0x42>
 8011e84:	20004c40 	.word	0x20004c40
 8011e88:	080161e4 	.word	0x080161e4

08011e8c <lwip_getpeername>:
}

int
lwip_getpeername(int s, struct sockaddr *name, socklen_t *namelen)
{
  return lwip_getaddrname(s, name, namelen, 0);
 8011e8c:	2300      	movs	r3, #0
 8011e8e:	f7fe bdf7 	b.w	8010a80 <lwip_getaddrname>
 8011e92:	bf00      	nop

08011e94 <lwip_getsockname>:
}

int
lwip_getsockname(int s, struct sockaddr *name, socklen_t *namelen)
{
  return lwip_getaddrname(s, name, namelen, 1);
 8011e94:	2301      	movs	r3, #1
 8011e96:	f7fe bdf3 	b.w	8010a80 <lwip_getaddrname>
 8011e9a:	bf00      	nop

08011e9c <lwip_getsockopt>:
}

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
 8011e9c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
static struct lwip_sock *
get_socket(int s)
{
  struct lwip_sock *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
 8011ea0:	2803      	cmp	r0, #3
  return lwip_getaddrname(s, name, namelen, 1);
}

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
 8011ea2:	b086      	sub	sp, #24
 8011ea4:	f8dd e030 	ldr.w	lr, [sp, #48]	; 0x30
static struct lwip_sock *
get_socket(int s)
{
  struct lwip_sock *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
 8011ea8:	d81d      	bhi.n	8011ee6 <lwip_getsockopt+0x4a>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
    return NULL;
  }

  sock = &sockets[s];
 8011eaa:	0044      	lsls	r4, r0, #1
 8011eac:	4e48      	ldr	r6, [pc, #288]	; (8011fd0 <lwip_getsockopt+0x134>)
 8011eae:	1827      	adds	r7, r4, r0
 8011eb0:	00ff      	lsls	r7, r7, #3

  if (!sock->conn) {
 8011eb2:	f856 c007 	ldr.w	ip, [r6, r7]
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
    return NULL;
  }

  sock = &sockets[s];
 8011eb6:	4437      	add	r7, r6

  if (!sock->conn) {
 8011eb8:	f1bc 0f00 	cmp.w	ip, #0
 8011ebc:	d013      	beq.n	8011ee6 <lwip_getsockopt+0x4a>

  if (!sock) {
    return -1;
  }

  if ((NULL == optval) || (NULL == optlen)) {
 8011ebe:	2b00      	cmp	r3, #0
 8011ec0:	d07d      	beq.n	8011fbe <lwip_getsockopt+0x122>
 8011ec2:	f1be 0f00 	cmp.w	lr, #0
 8011ec6:	d07a      	beq.n	8011fbe <lwip_getsockopt+0x122>
    sock_set_errno(sock, EFAULT);
    return -1;
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
 8011ec8:	2906      	cmp	r1, #6
 8011eca:	d05e      	beq.n	8011f8a <lwip_getsockopt+0xee>
 8011ecc:	f640 75ff 	movw	r5, #4095	; 0xfff
 8011ed0:	42a9      	cmp	r1, r5
 8011ed2:	d00d      	beq.n	8011ef0 <lwip_getsockopt+0x54>
 8011ed4:	b341      	cbz	r1, 8011f28 <lwip_getsockopt+0x8c>
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
      return 0;

    switch (optname) {
 8011ed6:	235c      	movs	r3, #92	; 0x5c
      err = ENOPROTOOPT;
  }  /* switch */

   
  if (err != ERR_OK) {
    sock_set_errno(sock, err);
 8011ed8:	4420      	add	r0, r4
 8011eda:	eb06 04c0 	add.w	r4, r6, r0, lsl #3
 8011ede:	6123      	str	r3, [r4, #16]
    return -1;
 8011ee0:	f04f 30ff 	mov.w	r0, #4294967295
 8011ee4:	e001      	b.n	8011eea <lwip_getsockopt+0x4e>
  err_t err = ERR_OK;
  struct lwip_sock *sock = get_socket(s);
  struct lwip_setgetsockopt_data data;

  if (!sock) {
    return -1;
 8011ee6:	f04f 30ff 	mov.w	r0, #4294967295
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;

  sock_set_errno(sock, err);
  return err ? -1 : 0;
}
 8011eea:	b006      	add	sp, #24
 8011eec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
 8011ef0:	2a20      	cmp	r2, #32
 8011ef2:	d01c      	beq.n	8011f2e <lwip_getsockopt+0x92>
 8011ef4:	dd53      	ble.n	8011f9e <lwip_getsockopt+0x102>
 8011ef6:	f241 0507 	movw	r5, #4103	; 0x1007
 8011efa:	42aa      	cmp	r2, r5
 8011efc:	dbeb      	blt.n	8011ed6 <lwip_getsockopt+0x3a>
 8011efe:	f241 0508 	movw	r5, #4104	; 0x1008
 8011f02:	42aa      	cmp	r2, r5
 8011f04:	dd13      	ble.n	8011f2e <lwip_getsockopt+0x92>
 8011f06:	f241 050a 	movw	r5, #4106	; 0x100a
 8011f0a:	42aa      	cmp	r2, r5
 8011f0c:	d1e3      	bne.n	8011ed6 <lwip_getsockopt+0x3a>
        err = EINVAL;
      }
      break;

    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
 8011f0e:	f8de 5000 	ldr.w	r5, [lr]
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
 8011f12:	f89c 8000 	ldrb.w	r8, [ip]
}

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  err_t err = ERR_OK;
 8011f16:	2d04      	cmp	r5, #4
 8011f18:	bf34      	ite	cc
 8011f1a:	2516      	movcc	r5, #22
 8011f1c:	2500      	movcs	r5, #0
    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
 8011f1e:	f1b8 0f20 	cmp.w	r8, #32
 8011f22:	d041      	beq.n	8011fa8 <lwip_getsockopt+0x10c>
 8011f24:	2361      	movs	r3, #97	; 0x61
 8011f26:	e7d7      	b.n	8011ed8 <lwip_getsockopt+0x3c>
    }  /* switch (optname) */
    break;
                     
/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
 8011f28:	1e55      	subs	r5, r2, #1
 8011f2a:	2d01      	cmp	r5, #1
 8011f2c:	d8d3      	bhi.n	8011ed6 <lwip_getsockopt+0x3a>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
 8011f2e:	f8de 5000 	ldr.w	r5, [lr]
 8011f32:	2d03      	cmp	r5, #3
 8011f34:	d804      	bhi.n	8011f40 <lwip_getsockopt+0xa4>
 8011f36:	2316      	movs	r3, #22
 8011f38:	e7ce      	b.n	8011ed8 <lwip_getsockopt+0x3c>
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
      return 0;

    switch (optname) {
 8011f3a:	1e55      	subs	r5, r2, #1
 8011f3c:	2d01      	cmp	r5, #1
 8011f3e:	d8ca      	bhi.n	8011ed6 <lwip_getsockopt+0x3a>
 8011f40:	4694      	mov	ip, r2
 8011f42:	4605      	mov	r5, r0
#endif /* LWIP_DEBUG */
  data.level = level;
  data.optname = optname;
  data.optval = optval;
  data.optlen = optlen;
  data.err = err;
 8011f44:	f04f 0800 	mov.w	r8, #0
  tcpip_callback(lwip_getsockopt_internal, &data);
 8011f48:	2201      	movs	r2, #1
  /* Now do the actual option processing */
  data.sock = sock;
#ifdef LWIP_DEBUG
  data.s = s;
#endif /* LWIP_DEBUG */
  data.level = level;
 8011f4a:	9101      	str	r1, [sp, #4]
  data.optname = optname;
  data.optval = optval;
  data.optlen = optlen;
  data.err = err;
  tcpip_callback(lwip_getsockopt_internal, &data);
 8011f4c:	4821      	ldr	r0, [pc, #132]	; (8011fd4 <lwip_getsockopt+0x138>)
 8011f4e:	4669      	mov	r1, sp
#ifdef LWIP_DEBUG
  data.s = s;
#endif /* LWIP_DEBUG */
  data.level = level;
  data.optname = optname;
  data.optval = optval;
 8011f50:	9303      	str	r3, [sp, #12]
  data.sock = sock;
#ifdef LWIP_DEBUG
  data.s = s;
#endif /* LWIP_DEBUG */
  data.level = level;
  data.optname = optname;
 8011f52:	f8cd c008 	str.w	ip, [sp, #8]
  data.optval = optval;
  data.optlen = optlen;
 8011f56:	f8cd e010 	str.w	lr, [sp, #16]
    sock_set_errno(sock, err);
    return -1;
  }

  /* Now do the actual option processing */
  data.sock = sock;
 8011f5a:	9700      	str	r7, [sp, #0]
#endif /* LWIP_DEBUG */
  data.level = level;
  data.optname = optname;
  data.optval = optval;
  data.optlen = optlen;
  data.err = err;
 8011f5c:	f88d 8014 	strb.w	r8, [sp, #20]
  tcpip_callback(lwip_getsockopt_internal, &data);
 8011f60:	f7f9 fa38 	bl	800b3d4 <tcpip_callback_with_block>
  sys_arch_sem_wait(&sock->conn->op_completed, 0);
 8011f64:	1960      	adds	r0, r4, r5
 8011f66:	00c4      	lsls	r4, r0, #3
 8011f68:	5930      	ldr	r0, [r6, r4]
 8011f6a:	4641      	mov	r1, r8
 8011f6c:	300c      	adds	r0, #12
 8011f6e:	f001 f8e7 	bl	8013140 <sys_arch_sem_wait>
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;
 8011f72:	f99d 3014 	ldrsb.w	r3, [sp, #20]

  sock_set_errno(sock, err);
 8011f76:	4434      	add	r4, r6
  return err ? -1 : 0;
 8011f78:	ebb3 0008 	subs.w	r0, r3, r8
 8011f7c:	bf18      	it	ne
 8011f7e:	2001      	movne	r0, #1
 8011f80:	4240      	negs	r0, r0
  tcpip_callback(lwip_getsockopt_internal, &data);
  sys_arch_sem_wait(&sock->conn->op_completed, 0);
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;

  sock_set_errno(sock, err);
 8011f82:	6123      	str	r3, [r4, #16]
  return err ? -1 : 0;
}
 8011f84:	b006      	add	sp, #24
 8011f86:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    break;
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
 8011f8a:	f8de 5000 	ldr.w	r5, [lr]
 8011f8e:	2d03      	cmp	r5, #3
 8011f90:	d9d1      	bls.n	8011f36 <lwip_getsockopt+0x9a>
      err = EINVAL;
      break;
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
 8011f92:	f89c 5000 	ldrb.w	r5, [ip]
 8011f96:	2d10      	cmp	r5, #16
 8011f98:	d0cf      	beq.n	8011f3a <lwip_getsockopt+0x9e>
      return 0;
 8011f9a:	2000      	movs	r0, #0
 8011f9c:	e7a5      	b.n	8011eea <lwip_getsockopt+0x4e>
  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
 8011f9e:	2a02      	cmp	r2, #2
 8011fa0:	d0c5      	beq.n	8011f2e <lwip_getsockopt+0x92>
 8011fa2:	2a08      	cmp	r2, #8
 8011fa4:	d197      	bne.n	8011ed6 <lwip_getsockopt+0x3a>
 8011fa6:	e7c2      	b.n	8011f2e <lwip_getsockopt+0x92>
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
 8011fa8:	f8dc c004 	ldr.w	ip, [ip, #4]
    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
 8011fac:	f89c c010 	ldrb.w	ip, [ip, #16]
 8011fb0:	f01c 0f02 	tst.w	ip, #2
 8011fb4:	d1b6      	bne.n	8011f24 <lwip_getsockopt+0x88>
                                  s, level, optname));
      err = ENOPROTOOPT;
  }  /* switch */

   
  if (err != ERR_OK) {
 8011fb6:	2d00      	cmp	r5, #0
 8011fb8:	d0c2      	beq.n	8011f40 <lwip_getsockopt+0xa4>
 8011fba:	462b      	mov	r3, r5
 8011fbc:	e78c      	b.n	8011ed8 <lwip_getsockopt+0x3c>
  if (!sock) {
    return -1;
  }

  if ((NULL == optval) || (NULL == optlen)) {
    sock_set_errno(sock, EFAULT);
 8011fbe:	4420      	add	r0, r4
 8011fc0:	eb06 04c0 	add.w	r4, r6, r0, lsl #3
 8011fc4:	230e      	movs	r3, #14
 8011fc6:	6123      	str	r3, [r4, #16]
    return -1;
 8011fc8:	f04f 30ff 	mov.w	r0, #4294967295
 8011fcc:	e78d      	b.n	8011eea <lwip_getsockopt+0x4e>
 8011fce:	bf00      	nop
 8011fd0:	20004c40 	.word	0x20004c40
 8011fd4:	08010ead 	.word	0x08010ead

08011fd8 <lwip_setsockopt>:
static struct lwip_sock *
get_socket(int s)
{
  struct lwip_sock *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
 8011fd8:	2803      	cmp	r0, #3
 8011fda:	d81f      	bhi.n	801201c <lwip_setsockopt+0x44>
  sys_sem_signal(&sock->conn->op_completed);
}

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
 8011fdc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
    return NULL;
  }

  sock = &sockets[s];
 8011fe0:	0044      	lsls	r4, r0, #1
 8011fe2:	4f42      	ldr	r7, [pc, #264]	; (80120ec <lwip_setsockopt+0x114>)
 8011fe4:	1826      	adds	r6, r4, r0
 8011fe6:	00f6      	lsls	r6, r6, #3

  if (!sock->conn) {
 8011fe8:	f857 e006 	ldr.w	lr, [r7, r6]
  sys_sem_signal(&sock->conn->op_completed);
}

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
 8011fec:	b086      	sub	sp, #24
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
    return NULL;
  }

  sock = &sockets[s];
 8011fee:	443e      	add	r6, r7

  if (!sock->conn) {
 8011ff0:	f1be 0f00 	cmp.w	lr, #0
 8011ff4:	d066      	beq.n	80120c4 <lwip_setsockopt+0xec>

  if (!sock) {
    return -1;
  }

  if (NULL == optval) {
 8011ff6:	2b00      	cmp	r3, #0
 8011ff8:	d072      	beq.n	80120e0 <lwip_setsockopt+0x108>
    sock_set_errno(sock, EFAULT);
    return -1;
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
 8011ffa:	2906      	cmp	r1, #6
 8011ffc:	d01e      	beq.n	801203c <lwip_setsockopt+0x64>
 8011ffe:	f640 75ff 	movw	r5, #4095	; 0xfff
 8012002:	42a9      	cmp	r1, r5
 8012004:	d00d      	beq.n	8012022 <lwip_setsockopt+0x4a>
 8012006:	b311      	cbz	r1, 801204e <lwip_setsockopt+0x76>

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
      return 0;

    switch (optname) {
 8012008:	235c      	movs	r3, #92	; 0x5c
    err = ENOPROTOOPT;
  }  /* switch (level) */


  if (err != ERR_OK) {
    sock_set_errno(sock, err);
 801200a:	4420      	add	r0, r4
 801200c:	eb07 04c0 	add.w	r4, r7, r0, lsl #3
 8012010:	6123      	str	r3, [r4, #16]
    return -1;
 8012012:	f04f 30ff 	mov.w	r0, #4294967295
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;

  sock_set_errno(sock, err);
  return err ? -1 : 0;
}
 8012016:	b006      	add	sp, #24
 8012018:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  struct lwip_sock *sock = get_socket(s);
  err_t err = ERR_OK;
  struct lwip_setgetsockopt_data data;

  if (!sock) {
    return -1;
 801201c:	f04f 30ff 	mov.w	r0, #4294967295
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;

  sock_set_errno(sock, err);
  return err ? -1 : 0;
}
 8012020:	4770      	bx	lr
  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
 8012022:	2a20      	cmp	r2, #32
 8012024:	d005      	beq.n	8012032 <lwip_setsockopt+0x5a>
 8012026:	f241 050a 	movw	r5, #4106	; 0x100a
 801202a:	42aa      	cmp	r2, r5
 801202c:	d03e      	beq.n	80120ac <lwip_setsockopt+0xd4>
 801202e:	2a08      	cmp	r2, #8
 8012030:	d1ea      	bne.n	8012008 <lwip_setsockopt+0x30>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
 8012032:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8012034:	2d03      	cmp	r5, #3
 8012036:	d814      	bhi.n	8012062 <lwip_setsockopt+0x8a>
 8012038:	2316      	movs	r3, #22
 801203a:	e7e6      	b.n	801200a <lwip_setsockopt+0x32>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
 801203c:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 801203e:	2d03      	cmp	r5, #3
 8012040:	d9fa      	bls.n	8012038 <lwip_setsockopt+0x60>
      err = EINVAL;
      break;
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
 8012042:	f89e 5000 	ldrb.w	r5, [lr]
 8012046:	2d10      	cmp	r5, #16
 8012048:	d008      	beq.n	801205c <lwip_setsockopt+0x84>
      return 0;
 801204a:	2000      	movs	r0, #0
 801204c:	e7e3      	b.n	8012016 <lwip_setsockopt+0x3e>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
 801204e:	1e55      	subs	r5, r2, #1
 8012050:	2d01      	cmp	r5, #1
 8012052:	d8d9      	bhi.n	8012008 <lwip_setsockopt+0x30>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
 8012054:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8012056:	2d03      	cmp	r5, #3
 8012058:	d9ee      	bls.n	8012038 <lwip_setsockopt+0x60>
 801205a:	e002      	b.n	8012062 <lwip_setsockopt+0x8a>

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
      return 0;

    switch (optname) {
 801205c:	1e55      	subs	r5, r2, #1
 801205e:	2d01      	cmp	r5, #1
 8012060:	d8d2      	bhi.n	8012008 <lwip_setsockopt+0x30>
 8012062:	4696      	mov	lr, r2
 8012064:	4605      	mov	r5, r0
#endif /* LWIP_DEBUG */
  data.level = level;
  data.optname = optname;
  data.optval = (void*)optval;
  data.optlen = &optlen;
  data.err = err;
 8012066:	f04f 0800 	mov.w	r8, #0
  tcpip_callback(lwip_setsockopt_internal, &data);
 801206a:	2201      	movs	r2, #1
  /* Now do the actual option processing */
  data.sock = sock;
#ifdef LWIP_DEBUG
  data.s = s;
#endif /* LWIP_DEBUG */
  data.level = level;
 801206c:	9101      	str	r1, [sp, #4]
  data.optname = optname;
  data.optval = (void*)optval;
 801206e:	9303      	str	r3, [sp, #12]
  data.optlen = &optlen;
  data.err = err;
  tcpip_callback(lwip_setsockopt_internal, &data);
 8012070:	4669      	mov	r1, sp
  data.s = s;
#endif /* LWIP_DEBUG */
  data.level = level;
  data.optname = optname;
  data.optval = (void*)optval;
  data.optlen = &optlen;
 8012072:	ab0c      	add	r3, sp, #48	; 0x30
  data.err = err;
  tcpip_callback(lwip_setsockopt_internal, &data);
 8012074:	481e      	ldr	r0, [pc, #120]	; (80120f0 <lwip_setsockopt+0x118>)
  data.s = s;
#endif /* LWIP_DEBUG */
  data.level = level;
  data.optname = optname;
  data.optval = (void*)optval;
  data.optlen = &optlen;
 8012076:	9304      	str	r3, [sp, #16]
  data.sock = sock;
#ifdef LWIP_DEBUG
  data.s = s;
#endif /* LWIP_DEBUG */
  data.level = level;
  data.optname = optname;
 8012078:	f8cd e008 	str.w	lr, [sp, #8]
    return -1;
  }


  /* Now do the actual option processing */
  data.sock = sock;
 801207c:	9600      	str	r6, [sp, #0]
#endif /* LWIP_DEBUG */
  data.level = level;
  data.optname = optname;
  data.optval = (void*)optval;
  data.optlen = &optlen;
  data.err = err;
 801207e:	f88d 8014 	strb.w	r8, [sp, #20]
  tcpip_callback(lwip_setsockopt_internal, &data);
 8012082:	f7f9 f9a7 	bl	800b3d4 <tcpip_callback_with_block>
  sys_arch_sem_wait(&sock->conn->op_completed, 0);
 8012086:	1960      	adds	r0, r4, r5
 8012088:	00c4      	lsls	r4, r0, #3
 801208a:	5938      	ldr	r0, [r7, r4]
 801208c:	4641      	mov	r1, r8
 801208e:	300c      	adds	r0, #12
 8012090:	f001 f856 	bl	8013140 <sys_arch_sem_wait>
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;
 8012094:	f99d 3014 	ldrsb.w	r3, [sp, #20]

  sock_set_errno(sock, err);
 8012098:	443c      	add	r4, r7
  return err ? -1 : 0;
 801209a:	ebb3 0008 	subs.w	r0, r3, r8
 801209e:	bf18      	it	ne
 80120a0:	2001      	movne	r0, #1
 80120a2:	4240      	negs	r0, r0
  tcpip_callback(lwip_setsockopt_internal, &data);
  sys_arch_sem_wait(&sock->conn->op_completed, 0);
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;

  sock_set_errno(sock, err);
 80120a4:	6123      	str	r3, [r4, #16]
  return err ? -1 : 0;
}
 80120a6:	b006      	add	sp, #24
 80120a8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
      break;
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
 80120ac:	9d0c      	ldr	r5, [sp, #48]	; 0x30
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
 80120ae:	f89e c000 	ldrb.w	ip, [lr]

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  struct lwip_sock *sock = get_socket(s);
  err_t err = ERR_OK;
 80120b2:	2d04      	cmp	r5, #4
 80120b4:	bf34      	ite	cc
 80120b6:	2516      	movcc	r5, #22
 80120b8:	2500      	movcs	r5, #0
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
 80120ba:	f1bc 0f20 	cmp.w	ip, #32
 80120be:	d004      	beq.n	80120ca <lwip_setsockopt+0xf2>
 80120c0:	2361      	movs	r3, #97	; 0x61
 80120c2:	e7a2      	b.n	801200a <lwip_setsockopt+0x32>
  struct lwip_sock *sock = get_socket(s);
  err_t err = ERR_OK;
  struct lwip_setgetsockopt_data data;

  if (!sock) {
    return -1;
 80120c4:	f04f 30ff 	mov.w	r0, #4294967295
 80120c8:	e7a5      	b.n	8012016 <lwip_setsockopt+0x3e>
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
 80120ca:	f8de e004 	ldr.w	lr, [lr, #4]
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
 80120ce:	f89e e010 	ldrb.w	lr, [lr, #16]
 80120d2:	f01e 0f02 	tst.w	lr, #2
 80120d6:	d1f3      	bne.n	80120c0 <lwip_setsockopt+0xe8>
                s, level, optname));
    err = ENOPROTOOPT;
  }  /* switch (level) */


  if (err != ERR_OK) {
 80120d8:	2d00      	cmp	r5, #0
 80120da:	d0c2      	beq.n	8012062 <lwip_setsockopt+0x8a>
 80120dc:	462b      	mov	r3, r5
 80120de:	e794      	b.n	801200a <lwip_setsockopt+0x32>
  if (!sock) {
    return -1;
  }

  if (NULL == optval) {
    sock_set_errno(sock, EFAULT);
 80120e0:	230e      	movs	r3, #14
 80120e2:	6133      	str	r3, [r6, #16]
    return -1;
 80120e4:	f04f 30ff 	mov.w	r0, #4294967295
 80120e8:	e795      	b.n	8012016 <lwip_setsockopt+0x3e>
 80120ea:	bf00      	nop
 80120ec:	20004c40 	.word	0x20004c40
 80120f0:	08011015 	.word	0x08011015

080120f4 <lwip_ioctl>:
static struct lwip_sock *
get_socket(int s)
{
  struct lwip_sock *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
 80120f4:	2803      	cmp	r0, #3
 80120f6:	d819      	bhi.n	801212c <lwip_ioctl+0x38>
    return NULL;
  }

  sock = &sockets[s];

  if (!sock->conn) {
 80120f8:	0043      	lsls	r3, r0, #1
  sys_sem_signal(&sock->conn->op_completed);
}

int
lwip_ioctl(int s, long cmd, void *argp)
{
 80120fa:	b4f0      	push	{r4, r5, r6, r7}
    return NULL;
  }

  sock = &sockets[s];

  if (!sock->conn) {
 80120fc:	181d      	adds	r5, r3, r0
 80120fe:	4e15      	ldr	r6, [pc, #84]	; (8012154 <lwip_ioctl+0x60>)
 8012100:	00ed      	lsls	r5, r5, #3
 8012102:	5974      	ldr	r4, [r6, r5]
 8012104:	b1e4      	cbz	r4, 8012140 <lwip_ioctl+0x4c>

  if (!sock) {
    return -1;
  }

  switch (cmd) {
 8012106:	4f14      	ldr	r7, [pc, #80]	; (8012158 <lwip_ioctl+0x64>)
 8012108:	42b9      	cmp	r1, r7
 801210a:	d11c      	bne.n	8012146 <lwip_ioctl+0x52>
    return 0;
#endif /* LWIP_SO_RCVBUF */

  case FIONBIO:
    val = 0;
    if (argp && *(u32_t*)argp) {
 801210c:	b10a      	cbz	r2, 8012112 <lwip_ioctl+0x1e>
 801210e:	6812      	ldr	r2, [r2, #0]
 8012110:	b97a      	cbnz	r2, 8012132 <lwip_ioctl+0x3e>
      val = 1;
    }
    netconn_set_nonblocking(sock->conn, val);
 8012112:	f894 2098 	ldrb.w	r2, [r4, #152]	; 0x98
 8012116:	f022 0202 	bic.w	r2, r2, #2
 801211a:	f884 2098 	strb.w	r2, [r4, #152]	; 0x98
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, val));
    sock_set_errno(sock, 0);
 801211e:	4403      	add	r3, r0
 8012120:	eb06 03c3 	add.w	r3, r6, r3, lsl #3
 8012124:	2000      	movs	r0, #0
 8012126:	6118      	str	r0, [r3, #16]
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
    return -1;
  } /* switch (cmd) */
}
 8012128:	bcf0      	pop	{r4, r5, r6, r7}
 801212a:	4770      	bx	lr
  u16_t buflen = 0;
  s16_t recv_avail;
#endif /* LWIP_SO_RCVBUF */

  if (!sock) {
    return -1;
 801212c:	f04f 30ff 	mov.w	r0, #4294967295
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
    return -1;
  } /* switch (cmd) */
}
 8012130:	4770      	bx	lr
  case FIONBIO:
    val = 0;
    if (argp && *(u32_t*)argp) {
      val = 1;
    }
    netconn_set_nonblocking(sock->conn, val);
 8012132:	f894 2098 	ldrb.w	r2, [r4, #152]	; 0x98
 8012136:	f042 0202 	orr.w	r2, r2, #2
 801213a:	f884 2098 	strb.w	r2, [r4, #152]	; 0x98
 801213e:	e7ee      	b.n	801211e <lwip_ioctl+0x2a>
  u16_t buflen = 0;
  s16_t recv_avail;
#endif /* LWIP_SO_RCVBUF */

  if (!sock) {
    return -1;
 8012140:	f04f 30ff 	mov.w	r0, #4294967295
 8012144:	e7f0      	b.n	8012128 <lwip_ioctl+0x34>
    sock_set_errno(sock, 0);
    return 0;

  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
 8012146:	4435      	add	r5, r6
 8012148:	2326      	movs	r3, #38	; 0x26
 801214a:	612b      	str	r3, [r5, #16]
    return -1;
 801214c:	f04f 30ff 	mov.w	r0, #4294967295
 8012150:	e7ea      	b.n	8012128 <lwip_ioctl+0x34>
 8012152:	bf00      	nop
 8012154:	20004c40 	.word	0x20004c40
 8012158:	8004667e 	.word	0x8004667e

0801215c <lwip_fcntl>:
static struct lwip_sock *
get_socket(int s)
{
  struct lwip_sock *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
 801215c:	2803      	cmp	r0, #3
 801215e:	d814      	bhi.n	801218a <lwip_fcntl+0x2e>
    return NULL;
  }

  sock = &sockets[s];

  if (!sock->conn) {
 8012160:	4b11      	ldr	r3, [pc, #68]	; (80121a8 <lwip_fcntl+0x4c>)
 8012162:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 8012166:	f853 3030 	ldr.w	r3, [r3, r0, lsl #3]
 801216a:	b173      	cbz	r3, 801218a <lwip_fcntl+0x2e>

  if (!sock || !sock->conn) {
    return -1;
  }

  switch (cmd) {
 801216c:	2903      	cmp	r1, #3
 801216e:	d00f      	beq.n	8012190 <lwip_fcntl+0x34>
 8012170:	2904      	cmp	r1, #4
 8012172:	d10a      	bne.n	801218a <lwip_fcntl+0x2e>
  case F_GETFL:
    ret = netconn_is_nonblocking(sock->conn) ? O_NONBLOCK : 0;
    break;
  case F_SETFL:
    if ((val & ~O_NONBLOCK) == 0) {
 8012174:	f032 0001 	bics.w	r0, r2, #1
 8012178:	d107      	bne.n	801218a <lwip_fcntl+0x2e>
      /* only O_NONBLOCK, all other bits are zero */
      netconn_set_nonblocking(sock->conn, val & O_NONBLOCK);
 801217a:	b972      	cbnz	r2, 801219a <lwip_fcntl+0x3e>
 801217c:	f893 2098 	ldrb.w	r2, [r3, #152]	; 0x98
 8012180:	f022 0202 	bic.w	r2, r2, #2
 8012184:	f883 2098 	strb.w	r2, [r3, #152]	; 0x98
 8012188:	4770      	bx	lr
{
  struct lwip_sock *sock = get_socket(s);
  int ret = -1;

  if (!sock || !sock->conn) {
    return -1;
 801218a:	f04f 30ff 	mov.w	r0, #4294967295
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_fcntl(%d, UNIMPL: %d, %d)\n", s, cmd, val));
    break;
  }
  return ret;
}
 801218e:	4770      	bx	lr
    return -1;
  }

  switch (cmd) {
  case F_GETFL:
    ret = netconn_is_nonblocking(sock->conn) ? O_NONBLOCK : 0;
 8012190:	f893 0098 	ldrb.w	r0, [r3, #152]	; 0x98
 8012194:	f3c0 0040 	ubfx	r0, r0, #1, #1
    break;
 8012198:	4770      	bx	lr
  case F_SETFL:
    if ((val & ~O_NONBLOCK) == 0) {
      /* only O_NONBLOCK, all other bits are zero */
      netconn_set_nonblocking(sock->conn, val & O_NONBLOCK);
 801219a:	f893 2098 	ldrb.w	r2, [r3, #152]	; 0x98
 801219e:	f042 0202 	orr.w	r2, r2, #2
 80121a2:	f883 2098 	strb.w	r2, [r3, #152]	; 0x98
 80121a6:	4770      	bx	lr
 80121a8:	20004c40 	.word	0x20004c40

080121ac <ETH_DeInit>:
  * @brief  Deinitializes the ETHERNET peripheral registers to their default reset values.
  * @param  None 
  * @retval None
  */
void ETH_DeInit(void)
{
 80121ac:	b508      	push	{r3, lr}
  RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_ETH_MAC, ENABLE);
 80121ae:	2101      	movs	r1, #1
 80121b0:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
 80121b4:	f7f6 fe6e 	bl	8008e94 <RCC_AHB1PeriphResetCmd>
  RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_ETH_MAC, DISABLE);
}
 80121b8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  * @retval None
  */
void ETH_DeInit(void)
{
  RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_ETH_MAC, ENABLE);
  RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_ETH_MAC, DISABLE);
 80121bc:	2100      	movs	r1, #0
 80121be:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
 80121c2:	f7f6 be67 	b.w	8008e94 <RCC_AHB1PeriphResetCmd>
 80121c6:	bf00      	nop

080121c8 <ETH_StructInit>:
  * @brief  Fills each ETH_InitStruct member with its default value.
  * @param  ETH_InitStruct: pointer to a ETH_InitTypeDef structure which will be initialized.
  * @retval None
  */
void ETH_StructInit(ETH_InitTypeDef* ETH_InitStruct)
{
 80121c8:	b4f0      	push	{r4, r5, r6, r7}
  /* Source address filtering (on the optional MAC addresses) disabled */
  ETH_InitStruct->ETH_SourceAddrFilter = ETH_SourceAddrFilter_Disable;   
  /* Do not forward control frames that do not pass the address filtering */
  ETH_InitStruct->ETH_PassControlFrames = ETH_PassControlFrames_BlockAll;   
  /* Disable reception of Broadcast frames */
  ETH_InitStruct->ETH_BroadcastFramesReception = ETH_BroadcastFramesReception_Disable;
 80121ca:	2120      	movs	r1, #32
{
  /* ETH_InitStruct members default value */
  /*------------------------   MAC Configuration   ---------------------------*/
  
  /* PHY Auto-negotiation enabled */
  ETH_InitStruct->ETH_AutoNegotiation = ETH_AutoNegotiation_Enable;           
 80121cc:	2701      	movs	r7, #1
  /* Ethernet interframe gap set to 96 bits */
  ETH_InitStruct->ETH_InterFrameGap = ETH_InterFrameGap_96Bit;                                                                                                                             
  /* Carrier Sense Enabled in Half-Duplex mode */ 
  ETH_InitStruct->ETH_CarrierSense = ETH_CarrierSense_Enable;                                
  /* PHY speed configured to 100Mbit/s */
  ETH_InitStruct->ETH_Speed = ETH_Speed_100M; 
 80121ce:	f44f 4680 	mov.w	r6, #16384	; 0x4000
  /* Receive own Frames in Half-Duplex mode enabled */
  ETH_InitStruct->ETH_ReceiveOwn = ETH_ReceiveOwn_Enable;                
  /* MAC MII loopback disabled */ 
  ETH_InitStruct->ETH_LoopbackMode = ETH_LoopbackMode_Disable;              
  /* Full-Duplex mode selected */
  ETH_InitStruct->ETH_Mode = ETH_Mode_FullDuplex;                      
 80121d2:	f44f 6500 	mov.w	r5, #2048	; 0x800
  /* Receive all frames disabled */ 
  ETH_InitStruct->ETH_ReceiveAll = ETH_ReceiveAll_Disable;
  /* Source address filtering (on the optional MAC addresses) disabled */
  ETH_InitStruct->ETH_SourceAddrFilter = ETH_SourceAddrFilter_Disable;   
  /* Do not forward control frames that do not pass the address filtering */
  ETH_InitStruct->ETH_PassControlFrames = ETH_PassControlFrames_BlockAll;   
 80121d6:	2440      	movs	r4, #64	; 0x40
  /* Initialize hash table high and low regs */
  ETH_InitStruct->ETH_HashTableHigh = 0x0;                
  ETH_InitStruct->ETH_HashTableLow = 0x0;                     
  /* Flow control config (flow control disabled)*/
  ETH_InitStruct->ETH_PauseTime = 0x0;                 
  ETH_InitStruct->ETH_ZeroQuantaPause = ETH_ZeroQuantaPause_Disable;            
 80121d8:	2280      	movs	r2, #128	; 0x80
  /*------------------------   MAC Configuration   ---------------------------*/
  
  /* PHY Auto-negotiation enabled */
  ETH_InitStruct->ETH_AutoNegotiation = ETH_AutoNegotiation_Enable;           
  /* MAC watchdog enabled: cuts-off long frame */
  ETH_InitStruct->ETH_Watchdog = ETH_Watchdog_Enable;
 80121da:	2300      	movs	r3, #0
{
  /* ETH_InitStruct members default value */
  /*------------------------   MAC Configuration   ---------------------------*/
  
  /* PHY Auto-negotiation enabled */
  ETH_InitStruct->ETH_AutoNegotiation = ETH_AutoNegotiation_Enable;           
 80121dc:	6007      	str	r7, [r0, #0]
  /* Ethernet interframe gap set to 96 bits */
  ETH_InitStruct->ETH_InterFrameGap = ETH_InterFrameGap_96Bit;                                                                                                                             
  /* Carrier Sense Enabled in Half-Duplex mode */ 
  ETH_InitStruct->ETH_CarrierSense = ETH_CarrierSense_Enable;                                
  /* PHY speed configured to 100Mbit/s */
  ETH_InitStruct->ETH_Speed = ETH_Speed_100M; 
 80121de:	6146      	str	r6, [r0, #20]
  ETH_InitStruct->ETH_VLANTagIdentifier = 0x0;          
  
  /*---------------------- DMA Configuration   -------------------------------*/

  /* Drops frames with with TCP/IP checksum errors */
  ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Disable; 
 80121e0:	f04f 6780 	mov.w	r7, #67108864	; 0x4000000
  /* Store and forward mode enabled for receive */
  ETH_InitStruct->ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;       
  /* Flush received frame that created FIFO overflow */
  ETH_InitStruct->ETH_FlushReceivedFrame = ETH_FlushReceivedFrame_Enable; 
  /* Store and forward mode enabled for transmit */
  ETH_InitStruct->ETH_TransmitStoreForward = ETH_TransmitStoreForward_Enable;  
 80121e4:	f44f 1600 	mov.w	r6, #2097152	; 0x200000
  /* Receive own Frames in Half-Duplex mode enabled */
  ETH_InitStruct->ETH_ReceiveOwn = ETH_ReceiveOwn_Enable;                
  /* MAC MII loopback disabled */ 
  ETH_InitStruct->ETH_LoopbackMode = ETH_LoopbackMode_Disable;              
  /* Full-Duplex mode selected */
  ETH_InitStruct->ETH_Mode = ETH_Mode_FullDuplex;                      
 80121e8:	6205      	str	r5, [r0, #32]
  /* Receive all frames disabled */ 
  ETH_InitStruct->ETH_ReceiveAll = ETH_ReceiveAll_Disable;
  /* Source address filtering (on the optional MAC addresses) disabled */
  ETH_InitStruct->ETH_SourceAddrFilter = ETH_SourceAddrFilter_Disable;   
  /* Do not forward control frames that do not pass the address filtering */
  ETH_InitStruct->ETH_PassControlFrames = ETH_PassControlFrames_BlockAll;   
 80121ea:	6404      	str	r4, [r0, #64]	; 0x40
  waiting status of previous frame*/                           
  ETH_InitStruct->ETH_SecondFrameOperate = ETH_SecondFrameOperate_Disable;
  /* DMA works on 32-bit aligned start source and destinations addresses */
  ETH_InitStruct->ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable;
  /* Enabled Fixed Burst Mode (mix of INC4, INC8, INC16 and SINGLE DMA transactions */
  ETH_InitStruct->ETH_FixedBurst = ETH_FixedBurst_Enable;
 80121ec:	f44f 3580 	mov.w	r5, #65536	; 0x10000
  /* DMA transfer max burst length = 32 beats = 32 x 32bits */
  ETH_InitStruct->ETH_RxDMABurstLength = ETH_RxDMABurstLength_32Beat;
 80121f0:	f44f 0480 	mov.w	r4, #4194304	; 0x400000
  /* Source address filtering (on the optional MAC addresses) disabled */
  ETH_InitStruct->ETH_SourceAddrFilter = ETH_SourceAddrFilter_Disable;   
  /* Do not forward control frames that do not pass the address filtering */
  ETH_InitStruct->ETH_PassControlFrames = ETH_PassControlFrames_BlockAll;   
  /* Disable reception of Broadcast frames */
  ETH_InitStruct->ETH_BroadcastFramesReception = ETH_BroadcastFramesReception_Disable;
 80121f4:	6441      	str	r1, [r0, #68]	; 0x44
  /* Initialize hash table high and low regs */
  ETH_InitStruct->ETH_HashTableHigh = 0x0;                
  ETH_InitStruct->ETH_HashTableLow = 0x0;                     
  /* Flow control config (flow control disabled)*/
  ETH_InitStruct->ETH_PauseTime = 0x0;                 
  ETH_InitStruct->ETH_ZeroQuantaPause = ETH_ZeroQuantaPause_Disable;            
 80121f6:	6642      	str	r2, [r0, #100]	; 0x64
  ETH_InitStruct->ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable;
  /* Enabled Fixed Burst Mode (mix of INC4, INC8, INC16 and SINGLE DMA transactions */
  ETH_InitStruct->ETH_FixedBurst = ETH_FixedBurst_Enable;
  /* DMA transfer max burst length = 32 beats = 32 x 32bits */
  ETH_InitStruct->ETH_RxDMABurstLength = ETH_RxDMABurstLength_32Beat;
  ETH_InitStruct->ETH_TxDMABurstLength = ETH_TxDMABurstLength_32Beat;
 80121f8:	f44f 5100 	mov.w	r1, #8192	; 0x2000
  /*---------------------- DMA Configuration   -------------------------------*/

  /* Drops frames with with TCP/IP checksum errors */
  ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Disable; 
  /* Store and forward mode enabled for receive */
  ETH_InitStruct->ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;       
 80121fc:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
  /*------------------------   MAC Configuration   ---------------------------*/
  
  /* PHY Auto-negotiation enabled */
  ETH_InitStruct->ETH_AutoNegotiation = ETH_AutoNegotiation_Enable;           
  /* MAC watchdog enabled: cuts-off long frame */
  ETH_InitStruct->ETH_Watchdog = ETH_Watchdog_Enable;
 8012200:	6043      	str	r3, [r0, #4]
  /* MAC Jabber enabled in Half-duplex mode */
  ETH_InitStruct->ETH_Jabber = ETH_Jabber_Enable;                                                       
 8012202:	6083      	str	r3, [r0, #8]
  /* Ethernet interframe gap set to 96 bits */
  ETH_InitStruct->ETH_InterFrameGap = ETH_InterFrameGap_96Bit;                                                                                                                             
 8012204:	60c3      	str	r3, [r0, #12]
  /* Carrier Sense Enabled in Half-Duplex mode */ 
  ETH_InitStruct->ETH_CarrierSense = ETH_CarrierSense_Enable;                                
 8012206:	6103      	str	r3, [r0, #16]
  /* PHY speed configured to 100Mbit/s */
  ETH_InitStruct->ETH_Speed = ETH_Speed_100M; 
  /* Receive own Frames in Half-Duplex mode enabled */
  ETH_InitStruct->ETH_ReceiveOwn = ETH_ReceiveOwn_Enable;                
 8012208:	6183      	str	r3, [r0, #24]
  /* MAC MII loopback disabled */ 
  ETH_InitStruct->ETH_LoopbackMode = ETH_LoopbackMode_Disable;              
 801220a:	61c3      	str	r3, [r0, #28]
  /* Full-Duplex mode selected */
  ETH_InitStruct->ETH_Mode = ETH_Mode_FullDuplex;                      
  /* IPv4 and TCP/UDP/ICMP frame Checksum Offload disabled */
  ETH_InitStruct->ETH_ChecksumOffload = ETH_ChecksumOffload_Disable;                                                             
 801220c:	6243      	str	r3, [r0, #36]	; 0x24
  /* Retry Transmission enabled for half-duplex mode */ 
  ETH_InitStruct->ETH_RetryTransmission = ETH_RetryTransmission_Enable;                                                                                   
 801220e:	6283      	str	r3, [r0, #40]	; 0x28
  /* Automatic PAD/CRC strip disabled*/
  ETH_InitStruct->ETH_AutomaticPadCRCStrip = ETH_AutomaticPadCRCStrip_Disable;                                                          
 8012210:	62c3      	str	r3, [r0, #44]	; 0x2c
  /* half-duplex mode retransmission Backoff time_limit = 10 slot times*/ 
  ETH_InitStruct->ETH_BackOffLimit = ETH_BackOffLimit_10;     
 8012212:	6303      	str	r3, [r0, #48]	; 0x30
  /* half-duplex mode Deferral check disabled */
  ETH_InitStruct->ETH_DeferralCheck = ETH_DeferralCheck_Disable;                                                                                                                  
 8012214:	6343      	str	r3, [r0, #52]	; 0x34
  /* Receive all frames disabled */ 
  ETH_InitStruct->ETH_ReceiveAll = ETH_ReceiveAll_Disable;
 8012216:	6383      	str	r3, [r0, #56]	; 0x38
  /* Source address filtering (on the optional MAC addresses) disabled */
  ETH_InitStruct->ETH_SourceAddrFilter = ETH_SourceAddrFilter_Disable;   
 8012218:	63c3      	str	r3, [r0, #60]	; 0x3c
  /* Do not forward control frames that do not pass the address filtering */
  ETH_InitStruct->ETH_PassControlFrames = ETH_PassControlFrames_BlockAll;   
  /* Disable reception of Broadcast frames */
  ETH_InitStruct->ETH_BroadcastFramesReception = ETH_BroadcastFramesReception_Disable;
  /* Normal Destination address filtering (not reverse addressing) */
  ETH_InitStruct->ETH_DestinationAddrFilter = ETH_DestinationAddrFilter_Normal;
 801221a:	6483      	str	r3, [r0, #72]	; 0x48
  /* Promiscuous address filtering mode disabled */
  ETH_InitStruct->ETH_PromiscuousMode = ETH_PromiscuousMode_Disable;                                                             
 801221c:	64c3      	str	r3, [r0, #76]	; 0x4c
  /* Perfect address filtering for multicast addresses */
  ETH_InitStruct->ETH_MulticastFramesFilter = ETH_MulticastFramesFilter_Perfect;       
 801221e:	6503      	str	r3, [r0, #80]	; 0x50
  /* Perfect address filtering for unicast addresses */
  ETH_InitStruct->ETH_UnicastFramesFilter = ETH_UnicastFramesFilter_Perfect;      
 8012220:	6543      	str	r3, [r0, #84]	; 0x54
  /* Initialize hash table high and low regs */
  ETH_InitStruct->ETH_HashTableHigh = 0x0;                
 8012222:	6583      	str	r3, [r0, #88]	; 0x58
  ETH_InitStruct->ETH_HashTableLow = 0x0;                     
 8012224:	65c3      	str	r3, [r0, #92]	; 0x5c
  /* Flow control config (flow control disabled)*/
  ETH_InitStruct->ETH_PauseTime = 0x0;                 
 8012226:	6603      	str	r3, [r0, #96]	; 0x60
  ETH_InitStruct->ETH_ZeroQuantaPause = ETH_ZeroQuantaPause_Disable;            
  ETH_InitStruct->ETH_PauseLowThreshold = ETH_PauseLowThreshold_Minus4;         
 8012228:	6683      	str	r3, [r0, #104]	; 0x68
  ETH_InitStruct->ETH_UnicastPauseFrameDetect = ETH_UnicastPauseFrameDetect_Disable;   
 801222a:	66c3      	str	r3, [r0, #108]	; 0x6c
  ETH_InitStruct->ETH_ReceiveFlowControl = ETH_ReceiveFlowControl_Disable;        
 801222c:	6703      	str	r3, [r0, #112]	; 0x70
  ETH_InitStruct->ETH_TransmitFlowControl = ETH_TransmitFlowControl_Disable;
 801222e:	6743      	str	r3, [r0, #116]	; 0x74
  /* VLANtag config (VLAN field not checked) */
  ETH_InitStruct->ETH_VLANTagComparison = ETH_VLANTagComparison_16Bit;          
 8012230:	6783      	str	r3, [r0, #120]	; 0x78
  ETH_InitStruct->ETH_VLANTagIdentifier = 0x0;          
 8012232:	67c3      	str	r3, [r0, #124]	; 0x7c
  
  /*---------------------- DMA Configuration   -------------------------------*/

  /* Drops frames with with TCP/IP checksum errors */
  ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Disable; 
 8012234:	f8c0 7080 	str.w	r7, [r0, #128]	; 0x80
  /* Store and forward mode enabled for receive */
  ETH_InitStruct->ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;       
  /* Flush received frame that created FIFO overflow */
  ETH_InitStruct->ETH_FlushReceivedFrame = ETH_FlushReceivedFrame_Enable; 
  /* Store and forward mode enabled for transmit */
  ETH_InitStruct->ETH_TransmitStoreForward = ETH_TransmitStoreForward_Enable;  
 8012238:	f8c0 608c 	str.w	r6, [r0, #140]	; 0x8c
  waiting status of previous frame*/                           
  ETH_InitStruct->ETH_SecondFrameOperate = ETH_SecondFrameOperate_Disable;
  /* DMA works on 32-bit aligned start source and destinations addresses */
  ETH_InitStruct->ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable;
  /* Enabled Fixed Burst Mode (mix of INC4, INC8, INC16 and SINGLE DMA transactions */
  ETH_InitStruct->ETH_FixedBurst = ETH_FixedBurst_Enable;
 801223c:	f8c0 50a8 	str.w	r5, [r0, #168]	; 0xa8
  /* DMA transfer max burst length = 32 beats = 32 x 32bits */
  ETH_InitStruct->ETH_RxDMABurstLength = ETH_RxDMABurstLength_32Beat;
 8012240:	f8c0 40ac 	str.w	r4, [r0, #172]	; 0xac
  /* Drops frames with with TCP/IP checksum errors */
  ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Disable; 
  /* Store and forward mode enabled for receive */
  ETH_InitStruct->ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;       
  /* Flush received frame that created FIFO overflow */
  ETH_InitStruct->ETH_FlushReceivedFrame = ETH_FlushReceivedFrame_Enable; 
 8012244:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
  /* Store and forward mode enabled for transmit */
  ETH_InitStruct->ETH_TransmitStoreForward = ETH_TransmitStoreForward_Enable;  
  /* Threshold TXFIFO level set to 64 bytes (used when threshold mode is enabled) */
  ETH_InitStruct->ETH_TransmitThresholdControl = ETH_TransmitThresholdControl_64Bytes;  
 8012248:	f8c0 3090 	str.w	r3, [r0, #144]	; 0x90
  /* Disable forwarding frames with errors (short frames, CRC,...)*/
  ETH_InitStruct->ETH_ForwardErrorFrames = ETH_ForwardErrorFrames_Disable; 
 801224c:	f8c0 3094 	str.w	r3, [r0, #148]	; 0x94
  /* Disable undersized good frames */
  ETH_InitStruct->ETH_ForwardUndersizedGoodFrames = ETH_ForwardUndersizedGoodFrames_Disable; 
 8012250:	f8c0 3098 	str.w	r3, [r0, #152]	; 0x98
  /* Threshold RXFIFO level set to 64 bytes (used when Cut-through mode is enabled) */
  ETH_InitStruct->ETH_ReceiveThresholdControl = ETH_ReceiveThresholdControl_64Bytes;                             
 8012254:	f8c0 309c 	str.w	r3, [r0, #156]	; 0x9c
  /* Disable Operate on second frame (transmit a second frame to FIFO without 
  waiting status of previous frame*/                           
  ETH_InitStruct->ETH_SecondFrameOperate = ETH_SecondFrameOperate_Disable;
 8012258:	f8c0 30a0 	str.w	r3, [r0, #160]	; 0xa0
  ETH_InitStruct->ETH_FixedBurst = ETH_FixedBurst_Enable;
  /* DMA transfer max burst length = 32 beats = 32 x 32bits */
  ETH_InitStruct->ETH_RxDMABurstLength = ETH_RxDMABurstLength_32Beat;
  ETH_InitStruct->ETH_TxDMABurstLength = ETH_TxDMABurstLength_32Beat;
  /* DMA Ring mode skip length = 0 */
  ETH_InitStruct->ETH_DescriptorSkipLength = 0x0; 
 801225c:	f8c0 30b4 	str.w	r3, [r0, #180]	; 0xb4
  /* Equal priority (round-robin) between transmit and receive DMA engines */
  ETH_InitStruct->ETH_DMAArbitration = ETH_DMAArbitration_RoundRobin_RxTx_1_1;
 8012260:	f8c0 30b8 	str.w	r3, [r0, #184]	; 0xb8
  ETH_InitStruct->ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable;
  /* Enabled Fixed Burst Mode (mix of INC4, INC8, INC16 and SINGLE DMA transactions */
  ETH_InitStruct->ETH_FixedBurst = ETH_FixedBurst_Enable;
  /* DMA transfer max burst length = 32 beats = 32 x 32bits */
  ETH_InitStruct->ETH_RxDMABurstLength = ETH_RxDMABurstLength_32Beat;
  ETH_InitStruct->ETH_TxDMABurstLength = ETH_TxDMABurstLength_32Beat;
 8012264:	f8c0 10b0 	str.w	r1, [r0, #176]	; 0xb0
  /*---------------------- DMA Configuration   -------------------------------*/

  /* Drops frames with with TCP/IP checksum errors */
  ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Disable; 
  /* Store and forward mode enabled for receive */
  ETH_InitStruct->ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;       
 8012268:	f8c0 2084 	str.w	r2, [r0, #132]	; 0x84
  ETH_InitStruct->ETH_ReceiveThresholdControl = ETH_ReceiveThresholdControl_64Bytes;                             
  /* Disable Operate on second frame (transmit a second frame to FIFO without 
  waiting status of previous frame*/                           
  ETH_InitStruct->ETH_SecondFrameOperate = ETH_SecondFrameOperate_Disable;
  /* DMA works on 32-bit aligned start source and destinations addresses */
  ETH_InitStruct->ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable;
 801226c:	f8c0 20a4 	str.w	r2, [r0, #164]	; 0xa4
  ETH_InitStruct->ETH_TxDMABurstLength = ETH_TxDMABurstLength_32Beat;
  /* DMA Ring mode skip length = 0 */
  ETH_InitStruct->ETH_DescriptorSkipLength = 0x0; 
  /* Equal priority (round-robin) between transmit and receive DMA engines */
  ETH_InitStruct->ETH_DMAArbitration = ETH_DMAArbitration_RoundRobin_RxTx_1_1;
}
 8012270:	bcf0      	pop	{r4, r5, r6, r7}
 8012272:	4770      	bx	lr

08012274 <ETH_Start>:
  * @retval None
  */
void ETH_FlushTransmitFIFO(void)
{
  /* Set the Flush Transmit FIFO bit */
  ETH->DMAOMR |= ETH_DMAOMR_FTF;  
 8012274:	f241 0218 	movw	r2, #4120	; 0x1018
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the MAC transmission */
    ETH->MACCR |= ETH_MACCR_TE;  
 8012278:	4b0a      	ldr	r3, [pc, #40]	; (80122a4 <ETH_Start+0x30>)
 801227a:	6819      	ldr	r1, [r3, #0]
 801227c:	f041 0108 	orr.w	r1, r1, #8
 8012280:	6019      	str	r1, [r3, #0]
  * @retval None
  */
void ETH_FlushTransmitFIFO(void)
{
  /* Set the Flush Transmit FIFO bit */
  ETH->DMAOMR |= ETH_DMAOMR_FTF;  
 8012282:	5899      	ldr	r1, [r3, r2]
 8012284:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8012288:	5099      	str	r1, [r3, r2]
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the MAC reception */
    ETH->MACCR |= ETH_MACCR_RE;  
 801228a:	6819      	ldr	r1, [r3, #0]
 801228c:	f041 0104 	orr.w	r1, r1, #4
 8012290:	6019      	str	r1, [r3, #0]
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the DMA transmission */
    ETH->DMAOMR |= ETH_DMAOMR_ST;  
 8012292:	5899      	ldr	r1, [r3, r2]
 8012294:	f441 5100 	orr.w	r1, r1, #8192	; 0x2000
 8012298:	5099      	str	r1, [r3, r2]
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the DMA reception */
    ETH->DMAOMR |= ETH_DMAOMR_SR;  
 801229a:	5899      	ldr	r1, [r3, r2]
 801229c:	f041 0102 	orr.w	r1, r1, #2
 80122a0:	5099      	str	r1, [r3, r2]
 80122a2:	4770      	bx	lr
 80122a4:	40028000 	.word	0x40028000

080122a8 <ETH_MACTransmissionCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the MAC transmission */
    ETH->MACCR |= ETH_MACCR_TE;  
 80122a8:	4a05      	ldr	r2, [pc, #20]	; (80122c0 <ETH_MACTransmissionCmd+0x18>)
 80122aa:	6813      	ldr	r3, [r2, #0]
void ETH_MACTransmissionCmd(FunctionalState NewState)
{ 
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80122ac:	b918      	cbnz	r0, 80122b6 <ETH_MACTransmissionCmd+0xe>
    ETH->MACCR |= ETH_MACCR_TE;  
  }
  else
  {
    /* Disable the MAC transmission */
    ETH->MACCR &= ~ETH_MACCR_TE;
 80122ae:	f023 0308 	bic.w	r3, r3, #8
 80122b2:	6013      	str	r3, [r2, #0]
 80122b4:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the MAC transmission */
    ETH->MACCR |= ETH_MACCR_TE;  
 80122b6:	f043 0308 	orr.w	r3, r3, #8
 80122ba:	6013      	str	r3, [r2, #0]
 80122bc:	4770      	bx	lr
 80122be:	bf00      	nop
 80122c0:	40028000 	.word	0x40028000

080122c4 <ETH_MACReceptionCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the MAC reception */
    ETH->MACCR |= ETH_MACCR_RE;  
 80122c4:	4a05      	ldr	r2, [pc, #20]	; (80122dc <ETH_MACReceptionCmd+0x18>)
 80122c6:	6813      	ldr	r3, [r2, #0]
void ETH_MACReceptionCmd(FunctionalState NewState)
{ 
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80122c8:	b918      	cbnz	r0, 80122d2 <ETH_MACReceptionCmd+0xe>
    ETH->MACCR |= ETH_MACCR_RE;  
  }
  else
  {
    /* Disable the MAC reception */
    ETH->MACCR &= ~ETH_MACCR_RE;
 80122ca:	f023 0304 	bic.w	r3, r3, #4
 80122ce:	6013      	str	r3, [r2, #0]
 80122d0:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the MAC reception */
    ETH->MACCR |= ETH_MACCR_RE;  
 80122d2:	f043 0304 	orr.w	r3, r3, #4
 80122d6:	6013      	str	r3, [r2, #0]
 80122d8:	4770      	bx	lr
 80122da:	bf00      	nop
 80122dc:	40028000 	.word	0x40028000

080122e0 <ETH_GetFlowControlBusyStatus>:
  */
FlagStatus ETH_GetFlowControlBusyStatus(void)
{
  FlagStatus bitstatus = RESET;
  /* The Flow Control register should not be written to until this bit is cleared */
  if ((ETH->MACFCR & ETH_MACFCR_FCBBPA) != (uint32_t)RESET)
 80122e0:	4b02      	ldr	r3, [pc, #8]	; (80122ec <ETH_GetFlowControlBusyStatus+0xc>)
 80122e2:	6998      	ldr	r0, [r3, #24]
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 80122e4:	f000 0001 	and.w	r0, r0, #1
 80122e8:	4770      	bx	lr
 80122ea:	bf00      	nop
 80122ec:	40028000 	.word	0x40028000

080122f0 <ETH_InitiatePauseControlFrame>:
  * @retval None
  */
void ETH_InitiatePauseControlFrame(void)  
{ 
  /* When Set In full duplex MAC initiates pause control frame */
  ETH->MACFCR |= ETH_MACFCR_FCBBPA;  
 80122f0:	4a02      	ldr	r2, [pc, #8]	; (80122fc <ETH_InitiatePauseControlFrame+0xc>)
 80122f2:	6993      	ldr	r3, [r2, #24]
 80122f4:	f043 0301 	orr.w	r3, r3, #1
 80122f8:	6193      	str	r3, [r2, #24]
 80122fa:	4770      	bx	lr
 80122fc:	40028000 	.word	0x40028000

08012300 <ETH_BackPressureActivationCmd>:
  if (NewState != DISABLE)
  {
    /* Activate the MAC BackPressure operation */
    /* In Half duplex: during backpressure, when the MAC receives a new frame,
    the transmitter starts sending a JAM pattern resulting in a collision */
    ETH->MACFCR |= ETH_MACFCR_FCBBPA; 
 8012300:	4a05      	ldr	r2, [pc, #20]	; (8012318 <ETH_BackPressureActivationCmd+0x18>)
 8012302:	6993      	ldr	r3, [r2, #24]
void ETH_BackPressureActivationCmd(FunctionalState NewState)   
{ 
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  if (NewState != DISABLE)
 8012304:	b918      	cbnz	r0, 801230e <ETH_BackPressureActivationCmd+0xe>
    ETH->MACFCR |= ETH_MACFCR_FCBBPA; 
  }
  else
  {
    /* Desactivate the MAC BackPressure operation */
    ETH->MACFCR &= ~ETH_MACFCR_FCBBPA; 
 8012306:	f023 0301 	bic.w	r3, r3, #1
 801230a:	6193      	str	r3, [r2, #24]
 801230c:	4770      	bx	lr
  if (NewState != DISABLE)
  {
    /* Activate the MAC BackPressure operation */
    /* In Half duplex: during backpressure, when the MAC receives a new frame,
    the transmitter starts sending a JAM pattern resulting in a collision */
    ETH->MACFCR |= ETH_MACFCR_FCBBPA; 
 801230e:	f043 0301 	orr.w	r3, r3, #1
 8012312:	6193      	str	r3, [r2, #24]
 8012314:	4770      	bx	lr
 8012316:	bf00      	nop
 8012318:	40028000 	.word	0x40028000

0801231c <ETH_GetMACITStatus>:
ITStatus ETH_GetMACITStatus(uint32_t ETH_MAC_IT)
{
  ITStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ETH_MAC_GET_IT(ETH_MAC_IT)); 
  if ((ETH->MACSR & ETH_MAC_IT) != (uint32_t)RESET)
 801231c:	4b03      	ldr	r3, [pc, #12]	; (801232c <ETH_GetMACITStatus+0x10>)
 801231e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  }
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
 8012320:	4203      	tst	r3, r0
}
 8012322:	bf14      	ite	ne
 8012324:	2001      	movne	r0, #1
 8012326:	2000      	moveq	r0, #0
 8012328:	4770      	bx	lr
 801232a:	bf00      	nop
 801232c:	40028000 	.word	0x40028000

08012330 <ETH_GetMACFlagStatus>:
 8012330:	f7ff bff4 	b.w	801231c <ETH_GetMACITStatus>

08012334 <ETH_MACITConfig>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
  {
    /* Enable the selected ETHERNET MAC interrupts */
    ETH->MACIMR &= (~(uint32_t)ETH_MAC_IT);
 8012334:	4a04      	ldr	r2, [pc, #16]	; (8012348 <ETH_MACITConfig+0x14>)
 8012336:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
{
  /* Check the parameters */
  assert_param(IS_ETH_MAC_IT(ETH_MAC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
 8012338:	b911      	cbnz	r1, 8012340 <ETH_MACITConfig+0xc>
    ETH->MACIMR &= (~(uint32_t)ETH_MAC_IT);
  }
  else
  {
    /* Disable the selected ETHERNET MAC interrupts */
    ETH->MACIMR |= ETH_MAC_IT;
 801233a:	4318      	orrs	r0, r3
 801233c:	63d0      	str	r0, [r2, #60]	; 0x3c
 801233e:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
  {
    /* Enable the selected ETHERNET MAC interrupts */
    ETH->MACIMR &= (~(uint32_t)ETH_MAC_IT);
 8012340:	ea23 0000 	bic.w	r0, r3, r0
 8012344:	63d0      	str	r0, [r2, #60]	; 0x3c
 8012346:	4770      	bx	lr
 8012348:	40028000 	.word	0x40028000

0801234c <ETH_MACAddressConfig>:
  *     @arg ETH_MAC_Address3 : MAC Address3
  * @param  Addr: Pointer on MAC address buffer data (6 bytes).
  * @retval None
  */
void ETH_MACAddressConfig(uint32_t MacAddr, uint8_t *Addr)
{
 801234c:	b410      	push	{r4}
  assert_param(IS_ETH_MAC_ADDRESS0123(MacAddr));
  
  /* Calculate the selected MAC address high register */
  tmpreg = ((uint32_t)Addr[5] << 8) | (uint32_t)Addr[4];
  /* Load the selected MAC address high register */
  (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) = tmpreg;
 801234e:	4a04      	ldr	r2, [pc, #16]	; (8012360 <ETH_MACAddressConfig+0x14>)
  uint32_t tmpreg;
  /* Check the parameters */
  assert_param(IS_ETH_MAC_ADDRESS0123(MacAddr));
  
  /* Calculate the selected MAC address high register */
  tmpreg = ((uint32_t)Addr[5] << 8) | (uint32_t)Addr[4];
 8012350:	888c      	ldrh	r4, [r1, #4]
  (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) = tmpreg;
  /* Calculate the selected MAC address low register */
  tmpreg = ((uint32_t)Addr[3] << 24) | ((uint32_t)Addr[2] << 16) | ((uint32_t)Addr[1] << 8) | Addr[0];
 
  /* Load the selected MAC address low register */
  (*(__IO uint32_t *) (ETH_MAC_ADDR_LBASE + MacAddr)) = tmpreg;
 8012352:	4b04      	ldr	r3, [pc, #16]	; (8012364 <ETH_MACAddressConfig+0x18>)
  assert_param(IS_ETH_MAC_ADDRESS0123(MacAddr));
  
  /* Calculate the selected MAC address high register */
  tmpreg = ((uint32_t)Addr[5] << 8) | (uint32_t)Addr[4];
  /* Load the selected MAC address high register */
  (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) = tmpreg;
 8012354:	5084      	str	r4, [r0, r2]
  /* Calculate the selected MAC address low register */
  tmpreg = ((uint32_t)Addr[3] << 24) | ((uint32_t)Addr[2] << 16) | ((uint32_t)Addr[1] << 8) | Addr[0];
 8012356:	680a      	ldr	r2, [r1, #0]
 
  /* Load the selected MAC address low register */
  (*(__IO uint32_t *) (ETH_MAC_ADDR_LBASE + MacAddr)) = tmpreg;
}
 8012358:	bc10      	pop	{r4}
  (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) = tmpreg;
  /* Calculate the selected MAC address low register */
  tmpreg = ((uint32_t)Addr[3] << 24) | ((uint32_t)Addr[2] << 16) | ((uint32_t)Addr[1] << 8) | Addr[0];
 
  /* Load the selected MAC address low register */
  (*(__IO uint32_t *) (ETH_MAC_ADDR_LBASE + MacAddr)) = tmpreg;
 801235a:	50c2      	str	r2, [r0, r3]
}
 801235c:	4770      	bx	lr
 801235e:	bf00      	nop
 8012360:	40028040 	.word	0x40028040
 8012364:	40028044 	.word	0x40028044

08012368 <ETH_GetMACAddress>:
  uint32_t tmpreg;
  /* Check the parameters */
  assert_param(IS_ETH_MAC_ADDRESS0123(MacAddr));
  
  /* Get the selected MAC address high register */
  tmpreg =(*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr));
 8012368:	4b08      	ldr	r3, [pc, #32]	; (801238c <ETH_GetMACAddress+0x24>)
  *     @arg ETH_MAC_Address3 : MAC Address3
  * @param  Addr: Pointer on MAC address buffer data (6 bytes).
  * @retval None
  */
void ETH_GetMACAddress(uint32_t MacAddr, uint8_t *Addr)
{
 801236a:	b410      	push	{r4}
  uint32_t tmpreg;
  /* Check the parameters */
  assert_param(IS_ETH_MAC_ADDRESS0123(MacAddr));
  
  /* Get the selected MAC address high register */
  tmpreg =(*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr));
 801236c:	58c3      	ldr	r3, [r0, r3]
 
  /* Calculate the selected MAC address buffer */
  Addr[5] = ((tmpreg >> 8) & (uint8_t)0xFF);
  Addr[4] = (tmpreg & (uint8_t)0xFF);
  /* Load the selected MAC address low register */
  tmpreg =(*(__IO uint32_t *) (ETH_MAC_ADDR_LBASE + MacAddr));
 801236e:	4a08      	ldr	r2, [pc, #32]	; (8012390 <ETH_GetMACAddress+0x28>)
  
  /* Get the selected MAC address high register */
  tmpreg =(*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr));
 
  /* Calculate the selected MAC address buffer */
  Addr[5] = ((tmpreg >> 8) & (uint8_t)0xFF);
 8012370:	0a1c      	lsrs	r4, r3, #8
 8012372:	714c      	strb	r4, [r1, #5]
  Addr[4] = (tmpreg & (uint8_t)0xFF);
 8012374:	710b      	strb	r3, [r1, #4]
  /* Load the selected MAC address low register */
  tmpreg =(*(__IO uint32_t *) (ETH_MAC_ADDR_LBASE + MacAddr));
 8012376:	5883      	ldr	r3, [r0, r2]
  /* Calculate the selected MAC address buffer */
  Addr[3] = ((tmpreg >> 24) & (uint8_t)0xFF);
 8012378:	0e1c      	lsrs	r4, r3, #24
  Addr[2] = ((tmpreg >> 16) & (uint8_t)0xFF);
 801237a:	0c18      	lsrs	r0, r3, #16
  Addr[1] = ((tmpreg >> 8 ) & (uint8_t)0xFF);
 801237c:	0a1a      	lsrs	r2, r3, #8
  Addr[5] = ((tmpreg >> 8) & (uint8_t)0xFF);
  Addr[4] = (tmpreg & (uint8_t)0xFF);
  /* Load the selected MAC address low register */
  tmpreg =(*(__IO uint32_t *) (ETH_MAC_ADDR_LBASE + MacAddr));
  /* Calculate the selected MAC address buffer */
  Addr[3] = ((tmpreg >> 24) & (uint8_t)0xFF);
 801237e:	70cc      	strb	r4, [r1, #3]
  Addr[2] = ((tmpreg >> 16) & (uint8_t)0xFF);
  Addr[1] = ((tmpreg >> 8 ) & (uint8_t)0xFF);
  Addr[0] = (tmpreg & (uint8_t)0xFF);
 8012380:	700b      	strb	r3, [r1, #0]
  Addr[4] = (tmpreg & (uint8_t)0xFF);
  /* Load the selected MAC address low register */
  tmpreg =(*(__IO uint32_t *) (ETH_MAC_ADDR_LBASE + MacAddr));
  /* Calculate the selected MAC address buffer */
  Addr[3] = ((tmpreg >> 24) & (uint8_t)0xFF);
  Addr[2] = ((tmpreg >> 16) & (uint8_t)0xFF);
 8012382:	7088      	strb	r0, [r1, #2]
  Addr[1] = ((tmpreg >> 8 ) & (uint8_t)0xFF);
 8012384:	704a      	strb	r2, [r1, #1]
  Addr[0] = (tmpreg & (uint8_t)0xFF);
}
 8012386:	bc10      	pop	{r4}
 8012388:	4770      	bx	lr
 801238a:	bf00      	nop
 801238c:	40028040 	.word	0x40028040
 8012390:	40028044 	.word	0x40028044

08012394 <ETH_MACAddressPerfectFilterCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  if (NewState != DISABLE)
  {
    /* Enable the selected ETHERNET MAC address for perfect filtering */
    (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) |= ETH_MACA1HR_AE;
 8012394:	4a05      	ldr	r2, [pc, #20]	; (80123ac <ETH_MACAddressPerfectFilterCmd+0x18>)
 8012396:	5883      	ldr	r3, [r0, r2]
{
  /* Check the parameters */
  assert_param(IS_ETH_MAC_ADDRESS123(MacAddr));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  if (NewState != DISABLE)
 8012398:	b919      	cbnz	r1, 80123a2 <ETH_MACAddressPerfectFilterCmd+0xe>
    (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) |= ETH_MACA1HR_AE;
  }
  else
  {
    /* Disable the selected ETHERNET MAC address for perfect filtering */
    (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) &=(~(uint32_t)ETH_MACA1HR_AE);
 801239a:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 801239e:	5083      	str	r3, [r0, r2]
 80123a0:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  if (NewState != DISABLE)
  {
    /* Enable the selected ETHERNET MAC address for perfect filtering */
    (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) |= ETH_MACA1HR_AE;
 80123a2:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80123a6:	5083      	str	r3, [r0, r2]
 80123a8:	4770      	bx	lr
 80123aa:	bf00      	nop
 80123ac:	40028040 	.word	0x40028040

080123b0 <ETH_MACAddressFilterConfig>:
  
  if (Filter != ETH_MAC_AddressFilter_DA)
  {
    /* The selected ETHERNET MAC address is used to compare with the SA fields of the
       received frame. */
    (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) |= ETH_MACA1HR_SA;
 80123b0:	4a04      	ldr	r2, [pc, #16]	; (80123c4 <ETH_MACAddressFilterConfig+0x14>)
{
  /* Check the parameters */
  assert_param(IS_ETH_MAC_ADDRESS123(MacAddr));
  assert_param(IS_ETH_MAC_ADDRESS_FILTER(Filter));
  
  if (Filter != ETH_MAC_AddressFilter_DA)
 80123b2:	2908      	cmp	r1, #8
  {
    /* The selected ETHERNET MAC address is used to compare with the SA fields of the
       received frame. */
    (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) |= ETH_MACA1HR_SA;
 80123b4:	5883      	ldr	r3, [r0, r2]
 80123b6:	bf14      	ite	ne
 80123b8:	f043 4380 	orrne.w	r3, r3, #1073741824	; 0x40000000
  }
  else
  {
    /* The selected ETHERNET MAC address is used to compare with the DA fields of the
       received frame. */
    (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) &=(~(uint32_t)ETH_MACA1HR_SA);
 80123bc:	f023 4380 	biceq.w	r3, r3, #1073741824	; 0x40000000
 80123c0:	5083      	str	r3, [r0, r2]
 80123c2:	4770      	bx	lr
 80123c4:	40028040 	.word	0x40028040

080123c8 <ETH_MACAddressMaskBytesFilterConfig>:
  /* Check the parameters */
  assert_param(IS_ETH_MAC_ADDRESS123(MacAddr));
  assert_param(IS_ETH_MAC_ADDRESS_MASK(MaskByte));
  
  /* Clear MBC bits in the selected MAC address  high register */
  (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) &=(~(uint32_t)ETH_MACA1HR_MBC);
 80123c8:	4b04      	ldr	r3, [pc, #16]	; (80123dc <ETH_MACAddressMaskBytesFilterConfig+0x14>)
 80123ca:	58c2      	ldr	r2, [r0, r3]
 80123cc:	f022 527c 	bic.w	r2, r2, #1056964608	; 0x3f000000
 80123d0:	50c2      	str	r2, [r0, r3]
  /* Set the selected Filter mask bytes */
  (*(__IO uint32_t *) (ETH_MAC_ADDR_HBASE + MacAddr)) |= MaskByte;
 80123d2:	58c2      	ldr	r2, [r0, r3]
 80123d4:	4311      	orrs	r1, r2
 80123d6:	50c1      	str	r1, [r0, r3]
 80123d8:	4770      	bx	lr
 80123da:	bf00      	nop
 80123dc:	40028040 	.word	0x40028040

080123e0 <ETH_Get_Received_Frame>:
{ 
  uint32_t framelength = 0;
  FrameTypeDef frame = {0,0,0}; 
  
  /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */
  framelength = ((DMARxDescToGet->Status & ETH_DMARxDesc_FL) >> ETH_DMARxDesc_FrameLengthShift) - 4;
 80123e0:	490a      	ldr	r1, [pc, #40]	; (801240c <ETH_Get_Received_Frame+0x2c>)
  frame.length = framelength;
  
  /* Get the address of the buffer start address */ 
  /* Check if more than one segment in the frame */
  if (DMA_RX_FRAME_infos->Seg_Count >1)
 80123e2:	4b0b      	ldr	r3, [pc, #44]	; (8012410 <ETH_Get_Received_Frame+0x30>)
{ 
  uint32_t framelength = 0;
  FrameTypeDef frame = {0,0,0}; 
  
  /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */
  framelength = ((DMARxDescToGet->Status & ETH_DMARxDesc_FL) >> ETH_DMARxDesc_FrameLengthShift) - 4;
 80123e4:	680a      	ldr	r2, [r1, #0]
  * with polling method only).
  * @param  none
  * @retval Structure of type FrameTypeDef
  */
FrameTypeDef ETH_Get_Received_Frame(void)
{ 
 80123e6:	b430      	push	{r4, r5}
  framelength = ((DMARxDescToGet->Status & ETH_DMARxDesc_FL) >> ETH_DMARxDesc_FrameLengthShift) - 4;
  frame.length = framelength;
  
  /* Get the address of the buffer start address */ 
  /* Check if more than one segment in the frame */
  if (DMA_RX_FRAME_infos->Seg_Count >1)
 80123e8:	681c      	ldr	r4, [r3, #0]
{ 
  uint32_t framelength = 0;
  FrameTypeDef frame = {0,0,0}; 
  
  /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */
  framelength = ((DMARxDescToGet->Status & ETH_DMARxDesc_FL) >> ETH_DMARxDesc_FrameLengthShift) - 4;
 80123ea:	6813      	ldr	r3, [r2, #0]
  frame.length = framelength;
  
  /* Get the address of the buffer start address */ 
  /* Check if more than one segment in the frame */
  if (DMA_RX_FRAME_infos->Seg_Count >1)
 80123ec:	68a5      	ldr	r5, [r4, #8]
{ 
  uint32_t framelength = 0;
  FrameTypeDef frame = {0,0,0}; 
  
  /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */
  framelength = ((DMARxDescToGet->Status & ETH_DMARxDesc_FL) >> ETH_DMARxDesc_FrameLengthShift) - 4;
 80123ee:	f3c3 430d 	ubfx	r3, r3, #16, #14
  frame.length = framelength;
  
  /* Get the address of the buffer start address */ 
  /* Check if more than one segment in the frame */
  if (DMA_RX_FRAME_infos->Seg_Count >1)
 80123f2:	2d01      	cmp	r5, #1
  {
    frame.buffer =(DMA_RX_FRAME_infos->FS_Rx_Desc)->Buffer1Addr;
 80123f4:	bf8a      	itet	hi
 80123f6:	6824      	ldrhi	r4, [r4, #0]
  }
  else 
  {
    frame.buffer = DMARxDescToGet->Buffer1Addr;
 80123f8:	6895      	ldrls	r5, [r2, #8]
  
  /* Get the address of the buffer start address */ 
  /* Check if more than one segment in the frame */
  if (DMA_RX_FRAME_infos->Seg_Count >1)
  {
    frame.buffer =(DMA_RX_FRAME_infos->FS_Rx_Desc)->Buffer1Addr;
 80123fa:	68a5      	ldrhi	r5, [r4, #8]
  frame.descriptor = DMARxDescToGet;
  
  /* Update the ETHERNET DMA global Rx descriptor with next Rx descriptor */      
  /* Chained Mode */    
  /* Selects the next DMA Rx descriptor list for next buffer to read */ 
  DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);    
 80123fc:	68d4      	ldr	r4, [r2, #12]
{ 
  uint32_t framelength = 0;
  FrameTypeDef frame = {0,0,0}; 
  
  /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */
  framelength = ((DMARxDescToGet->Status & ETH_DMARxDesc_FL) >> ETH_DMARxDesc_FrameLengthShift) - 4;
 80123fe:	3b04      	subs	r3, #4
  /* Chained Mode */    
  /* Selects the next DMA Rx descriptor list for next buffer to read */ 
  DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);    
  
  /* Return Frame */
  return (frame);  
 8012400:	e880 0028 	stmia.w	r0, {r3, r5}
  frame.descriptor = DMARxDescToGet;
  
  /* Update the ETHERNET DMA global Rx descriptor with next Rx descriptor */      
  /* Chained Mode */    
  /* Selects the next DMA Rx descriptor list for next buffer to read */ 
  DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);    
 8012404:	600c      	str	r4, [r1, #0]
  
  /* Return Frame */
  return (frame);  
 8012406:	6082      	str	r2, [r0, #8]
}
 8012408:	bc30      	pop	{r4, r5}
 801240a:	4770      	bx	lr
 801240c:	2000f4cc 	.word	0x2000f4cc
 8012410:	2001133c 	.word	0x2001133c

08012414 <ETH_Get_Received_Frame_interrupt>:
  *         the receive frame (should be used with interrupt mode only)
  * @param  None
  * @retval Structure of type FrameTypeDef
  */
FrameTypeDef ETH_Get_Received_Frame_interrupt(void)
{ 
 8012414:	b4f0      	push	{r4, r5, r6, r7}
 8012416:	4c27      	ldr	r4, [pc, #156]	; (80124b4 <ETH_Get_Received_Frame_interrupt+0xa0>)
    
    /* check if first segment in frame */
    if(((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET)&&
      ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) == (uint32_t)RESET))
    {
      DMA_RX_FRAME_infos->FS_Rx_Desc = DMARxDescToGet;
 8012418:	4d27      	ldr	r5, [pc, #156]	; (80124b8 <ETH_Get_Received_Frame_interrupt+0xa4>)
  *         the receive frame (should be used with interrupt mode only)
  * @param  None
  * @retval Structure of type FrameTypeDef
  */
FrameTypeDef ETH_Get_Received_Frame_interrupt(void)
{ 
 801241a:	b082      	sub	sp, #8
  FrameTypeDef frame={0,0,0};
  __IO uint32_t descriptor_scan_counter = 0; 
 801241c:	2700      	movs	r7, #0
 801241e:	6823      	ldr	r3, [r4, #0]
    
    /* check if first segment in frame */
    if(((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET)&&
      ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) == (uint32_t)RESET))
    {
      DMA_RX_FRAME_infos->FS_Rx_Desc = DMARxDescToGet;
 8012420:	6829      	ldr	r1, [r5, #0]
  * @retval Structure of type FrameTypeDef
  */
FrameTypeDef ETH_Get_Received_Frame_interrupt(void)
{ 
  FrameTypeDef frame={0,0,0};
  __IO uint32_t descriptor_scan_counter = 0; 
 8012422:	9701      	str	r7, [sp, #4]
    /* check if first segment in frame */
    if(((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET)&&
      ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) == (uint32_t)RESET))
    {
      DMA_RX_FRAME_infos->FS_Rx_Desc = DMARxDescToGet;
      DMA_RX_FRAME_infos->Seg_Count = 1;   
 8012424:	2601      	movs	r6, #1
{ 
  FrameTypeDef frame={0,0,0};
  __IO uint32_t descriptor_scan_counter = 0; 
  
  /* scan descriptors owned by CPU */
  while (((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET)&&
 8012426:	e006      	b.n	8012436 <ETH_Get_Received_Frame_interrupt+0x22>
    /* Just by security */
    descriptor_scan_counter++;
    
    /* check if first segment in frame */
    if(((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET)&&
      ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) == (uint32_t)RESET))
 8012428:	681a      	ldr	r2, [r3, #0]
    
    /* Just by security */
    descriptor_scan_counter++;
    
    /* check if first segment in frame */
    if(((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET)&&
 801242a:	05d2      	lsls	r2, r2, #23
 801242c:	d40f      	bmi.n	801244e <ETH_Get_Received_Frame_interrupt+0x3a>
      ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) == (uint32_t)RESET))
    {
      DMA_RX_FRAME_infos->FS_Rx_Desc = DMARxDescToGet;
 801242e:	600b      	str	r3, [r1, #0]
      DMA_RX_FRAME_infos->Seg_Count = 1;   
 8012430:	608e      	str	r6, [r1, #8]
      DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
 8012432:	68db      	ldr	r3, [r3, #12]
 8012434:	2701      	movs	r7, #1
{ 
  FrameTypeDef frame={0,0,0};
  __IO uint32_t descriptor_scan_counter = 0; 
  
  /* scan descriptors owned by CPU */
  while (((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET)&&
 8012436:	681a      	ldr	r2, [r3, #0]
 8012438:	2a00      	cmp	r2, #0
 801243a:	db13      	blt.n	8012464 <ETH_Get_Received_Frame_interrupt+0x50>
        (descriptor_scan_counter<ETH_RXBUFNB))
 801243c:	9a01      	ldr	r2, [sp, #4]
{ 
  FrameTypeDef frame={0,0,0};
  __IO uint32_t descriptor_scan_counter = 0; 
  
  /* scan descriptors owned by CPU */
  while (((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET)&&
 801243e:	2a04      	cmp	r2, #4
 8012440:	d810      	bhi.n	8012464 <ETH_Get_Received_Frame_interrupt+0x50>
        (descriptor_scan_counter<ETH_RXBUFNB))
  {
    
    /* Just by security */
    descriptor_scan_counter++;
 8012442:	9a01      	ldr	r2, [sp, #4]
 8012444:	3201      	adds	r2, #1
 8012446:	9201      	str	r2, [sp, #4]
    
    /* check if first segment in frame */
    if(((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET)&&
 8012448:	681a      	ldr	r2, [r3, #0]
 801244a:	0592      	lsls	r2, r2, #22
 801244c:	d4ec      	bmi.n	8012428 <ETH_Get_Received_Frame_interrupt+0x14>
      DMA_RX_FRAME_infos->Seg_Count = 1;   
      DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
    }
    
    /* check if intermediate segment */
    else if (((DMARxDescToGet->Status & ETH_DMARxDesc_LS) == (uint32_t)RESET)&&
 801244e:	681a      	ldr	r2, [r3, #0]
 8012450:	05d2      	lsls	r2, r2, #23
 8012452:	d40f      	bmi.n	8012474 <ETH_Get_Received_Frame_interrupt+0x60>
            ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) == (uint32_t)RESET))
 8012454:	681a      	ldr	r2, [r3, #0]
      DMA_RX_FRAME_infos->Seg_Count = 1;   
      DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
    }
    
    /* check if intermediate segment */
    else if (((DMARxDescToGet->Status & ETH_DMARxDesc_LS) == (uint32_t)RESET)&&
 8012456:	0592      	lsls	r2, r2, #22
 8012458:	d40c      	bmi.n	8012474 <ETH_Get_Received_Frame_interrupt+0x60>
            ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) == (uint32_t)RESET))
    {
      (DMA_RX_FRAME_infos->Seg_Count) ++;
 801245a:	688a      	ldr	r2, [r1, #8]
 801245c:	3201      	adds	r2, #1
 801245e:	608a      	str	r2, [r1, #8]
      DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
 8012460:	68db      	ldr	r3, [r3, #12]
 8012462:	e7e7      	b.n	8012434 <ETH_Get_Received_Frame_interrupt+0x20>
 8012464:	bb27      	cbnz	r7, 80124b0 <ETH_Get_Received_Frame_interrupt+0x9c>
     
      /* Return Frame */
      return (frame);  
    }
  }
  return (frame); 
 8012466:	2300      	movs	r3, #0
 8012468:	6003      	str	r3, [r0, #0]
 801246a:	6043      	str	r3, [r0, #4]
 801246c:	6083      	str	r3, [r0, #8]
}
 801246e:	b002      	add	sp, #8
 8012470:	bcf0      	pop	{r4, r5, r6, r7}
 8012472:	4770      	bx	lr
 8012474:	b9d7      	cbnz	r7, 80124ac <ETH_Get_Received_Frame_interrupt+0x98>

    /* should be last segment */
    else
    { 
      /* last segment */
      DMA_RX_FRAME_infos->LS_Rx_Desc = DMARxDescToGet;
 8012476:	682a      	ldr	r2, [r5, #0]
  
      /* Update the ETHERNET DMA global Rx descriptor with next Rx descriptor */      
      DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
     
      /* Return Frame */
      return (frame);  
 8012478:	6083      	str	r3, [r0, #8]

    /* should be last segment */
    else
    { 
      /* last segment */
      DMA_RX_FRAME_infos->LS_Rx_Desc = DMARxDescToGet;
 801247a:	6053      	str	r3, [r2, #4]
      
      (DMA_RX_FRAME_infos->Seg_Count)++;
 801247c:	6891      	ldr	r1, [r2, #8]
 801247e:	3101      	adds	r1, #1
 8012480:	6091      	str	r1, [r2, #8]
        
      /* first segment is last segment */
      if ((DMA_RX_FRAME_infos->Seg_Count)==1)
 8012482:	6891      	ldr	r1, [r2, #8]
 8012484:	2901      	cmp	r1, #1
        DMA_RX_FRAME_infos->FS_Rx_Desc = DMARxDescToGet;
 8012486:	bf08      	it	eq
 8012488:	6013      	streq	r3, [r2, #0]
      
      /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */
      frame.length = ((DMARxDescToGet->Status & ETH_DMARxDesc_FL) >> ETH_DMARxDesc_FrameLengthShift) - 4;
 801248a:	6819      	ldr	r1, [r3, #0]

  
      /* Get the address of the buffer start address */ 
      /* Check if more than one segment in the frame */
      if (DMA_RX_FRAME_infos->Seg_Count >1)
 801248c:	6895      	ldr	r5, [r2, #8]
      /* first segment is last segment */
      if ((DMA_RX_FRAME_infos->Seg_Count)==1)
        DMA_RX_FRAME_infos->FS_Rx_Desc = DMARxDescToGet;
      
      /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */
      frame.length = ((DMARxDescToGet->Status & ETH_DMARxDesc_FL) >> ETH_DMARxDesc_FrameLengthShift) - 4;
 801248e:	f3c1 410d 	ubfx	r1, r1, #16, #14

  
      /* Get the address of the buffer start address */ 
      /* Check if more than one segment in the frame */
      if (DMA_RX_FRAME_infos->Seg_Count >1)
 8012492:	2d01      	cmp	r5, #1
      {
        frame.buffer =(DMA_RX_FRAME_infos->FS_Rx_Desc)->Buffer1Addr;
 8012494:	bf8a      	itet	hi
 8012496:	6812      	ldrhi	r2, [r2, #0]
      }
      else 
      {
        frame.buffer = DMARxDescToGet->Buffer1Addr;
 8012498:	689d      	ldrls	r5, [r3, #8]
  
      /* Get the address of the buffer start address */ 
      /* Check if more than one segment in the frame */
      if (DMA_RX_FRAME_infos->Seg_Count >1)
      {
        frame.buffer =(DMA_RX_FRAME_infos->FS_Rx_Desc)->Buffer1Addr;
 801249a:	6895      	ldrhi	r5, [r2, #8]
      }
      
      frame.descriptor = DMARxDescToGet;
  
      /* Update the ETHERNET DMA global Rx descriptor with next Rx descriptor */      
      DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
 801249c:	68da      	ldr	r2, [r3, #12]
      /* first segment is last segment */
      if ((DMA_RX_FRAME_infos->Seg_Count)==1)
        DMA_RX_FRAME_infos->FS_Rx_Desc = DMARxDescToGet;
      
      /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */
      frame.length = ((DMARxDescToGet->Status & ETH_DMARxDesc_FL) >> ETH_DMARxDesc_FrameLengthShift) - 4;
 801249e:	3904      	subs	r1, #4
  
      /* Update the ETHERNET DMA global Rx descriptor with next Rx descriptor */      
      DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
     
      /* Return Frame */
      return (frame);  
 80124a0:	e880 0022 	stmia.w	r0, {r1, r5}
      }
      
      frame.descriptor = DMARxDescToGet;
  
      /* Update the ETHERNET DMA global Rx descriptor with next Rx descriptor */      
      DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
 80124a4:	6022      	str	r2, [r4, #0]
      /* Return Frame */
      return (frame);  
    }
  }
  return (frame); 
}
 80124a6:	b002      	add	sp, #8
 80124a8:	bcf0      	pop	{r4, r5, r6, r7}
 80124aa:	4770      	bx	lr
 80124ac:	6023      	str	r3, [r4, #0]
 80124ae:	e7e2      	b.n	8012476 <ETH_Get_Received_Frame_interrupt+0x62>
 80124b0:	6023      	str	r3, [r4, #0]
 80124b2:	e7d8      	b.n	8012466 <ETH_Get_Received_Frame_interrupt+0x52>
 80124b4:	2000f4cc 	.word	0x2000f4cc
 80124b8:	2001133c 	.word	0x2001133c

080124bc <ETH_Prepare_Transmit_Descriptors>:
  * @brief  Prepares DMA Tx descriptors to transmit an ethernet frame
  * @param  FrameLength : length of the frame to send
  * @retval error status
  */
uint32_t ETH_Prepare_Transmit_Descriptors(u16 FrameLength)
{   
 80124bc:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t buf_count =0, size=0,i=0;
  __IO ETH_DMADESCTypeDef *DMATxNextDesc;
  
  /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */
  if((DMATxDescToSet->Status & ETH_DMATxDesc_OWN) != (u32)RESET)
 80124be:	4e2e      	ldr	r6, [pc, #184]	; (8012578 <ETH_Prepare_Transmit_Descriptors+0xbc>)
 80124c0:	6837      	ldr	r7, [r6, #0]
 80124c2:	683b      	ldr	r3, [r7, #0]
 80124c4:	2b00      	cmp	r3, #0
 80124c6:	db4e      	blt.n	8012566 <ETH_Prepare_Transmit_Descriptors+0xaa>
    return ETH_ERROR;
  }
  
  DMATxNextDesc = DMATxDescToSet;
  
  if (FrameLength > ETH_TX_BUF_SIZE)
 80124c8:	f240 53f4 	movw	r3, #1524	; 0x5f4
 80124cc:	4298      	cmp	r0, r3
 80124ce:	d933      	bls.n	8012538 <ETH_Prepare_Transmit_Descriptors+0x7c>
  {
    buf_count = FrameLength/ETH_TX_BUF_SIZE;
 80124d0:	4c2a      	ldr	r4, [pc, #168]	; (801257c <ETH_Prepare_Transmit_Descriptors+0xc0>)
 80124d2:	fba4 2400 	umull	r2, r4, r4, r0
 80124d6:	0aa4      	lsrs	r4, r4, #10
    if (FrameLength%ETH_TX_BUF_SIZE) buf_count++;
 80124d8:	fb03 0314 	mls	r3, r3, r4, r0
 80124dc:	b29b      	uxth	r3, r3
  
  DMATxNextDesc = DMATxDescToSet;
  
  if (FrameLength > ETH_TX_BUF_SIZE)
  {
    buf_count = FrameLength/ETH_TX_BUF_SIZE;
 80124de:	b2a4      	uxth	r4, r4
    if (FrameLength%ETH_TX_BUF_SIZE) buf_count++;
 80124e0:	b343      	cbz	r3, 8012534 <ETH_Prepare_Transmit_Descriptors+0x78>
 80124e2:	3401      	adds	r4, #1
      if (i== (buf_count-1))
      {
        /* Setting the last segment bit */
        DMATxNextDesc->Status |= ETH_DMATxDesc_LS;
        size = FrameLength - (buf_count-1)*ETH_TX_BUF_SIZE;
        DMATxNextDesc->ControlBufferSize = (size & ETH_DMATxDesc_TBS1);
 80124e4:	4b26      	ldr	r3, [pc, #152]	; (8012580 <ETH_Prepare_Transmit_Descriptors+0xc4>)
 80124e6:	f200 50f4 	addw	r0, r0, #1524	; 0x5f4
 80124ea:	fb03 0004 	mla	r0, r3, r4, r0
 80124ee:	463b      	mov	r3, r7
 80124f0:	f3c0 0e0c 	ubfx	lr, r0, #0, #13
        /* Setting the first segment bit */
        DMATxDescToSet->Status |= ETH_DMATxDesc_FS;  
      }
      
      /* Program size */
      DMATxNextDesc->ControlBufferSize = (ETH_TX_BUF_SIZE & ETH_DMATxDesc_TBS1);
 80124f4:	f240 50f4 	movw	r0, #1524	; 0x5f4
      if (i== (buf_count-1))
      {
        /* Setting the last segment bit */
        DMATxNextDesc->Status |= ETH_DMATxDesc_LS;
        size = FrameLength - (buf_count-1)*ETH_TX_BUF_SIZE;
        DMATxNextDesc->ControlBufferSize = (size & ETH_DMATxDesc_TBS1);
 80124f8:	2200      	movs	r2, #0
      }
      
      /* Program size */
      DMATxNextDesc->ControlBufferSize = (ETH_TX_BUF_SIZE & ETH_DMATxDesc_TBS1);
       
      if (i== (buf_count-1))
 80124fa:	1e65      	subs	r5, r4, #1
  }
  else
  {
    for (i=0; i< buf_count; i++)
    {
      if (i==0) 
 80124fc:	2a00      	cmp	r2, #0
 80124fe:	d034      	beq.n	801256a <ETH_Prepare_Transmit_Descriptors+0xae>
      }
      
      /* Program size */
      DMATxNextDesc->ControlBufferSize = (ETH_TX_BUF_SIZE & ETH_DMATxDesc_TBS1);
       
      if (i== (buf_count-1))
 8012500:	4295      	cmp	r5, r2
        /* Setting the first segment bit */
        DMATxDescToSet->Status |= ETH_DMATxDesc_FS;  
      }
      
      /* Program size */
      DMATxNextDesc->ControlBufferSize = (ETH_TX_BUF_SIZE & ETH_DMATxDesc_TBS1);
 8012502:	6058      	str	r0, [r3, #4]
       
      if (i== (buf_count-1))
 8012504:	d026      	beq.n	8012554 <ETH_Prepare_Transmit_Descriptors+0x98>
        size = FrameLength - (buf_count-1)*ETH_TX_BUF_SIZE;
        DMATxNextDesc->ControlBufferSize = (size & ETH_DMATxDesc_TBS1);
      }
        
      /*give back descriptor to DMA */
      DMATxNextDesc->Status |= ETH_DMATxDesc_OWN;
 8012506:	6819      	ldr	r1, [r3, #0]
    DMATxDescToSet->Status |= ETH_DMATxDesc_OWN;
    DMATxDescToSet= (ETH_DMADESCTypeDef *)(DMATxDescToSet->Buffer2NextDescAddr);
  }
  else
  {
    for (i=0; i< buf_count; i++)
 8012508:	3201      	adds	r2, #1
        size = FrameLength - (buf_count-1)*ETH_TX_BUF_SIZE;
        DMATxNextDesc->ControlBufferSize = (size & ETH_DMATxDesc_TBS1);
      }
        
      /*give back descriptor to DMA */
      DMATxNextDesc->Status |= ETH_DMATxDesc_OWN;
 801250a:	f041 4100 	orr.w	r1, r1, #2147483648	; 0x80000000
 801250e:	6019      	str	r1, [r3, #0]
    DMATxDescToSet->Status |= ETH_DMATxDesc_OWN;
    DMATxDescToSet= (ETH_DMADESCTypeDef *)(DMATxDescToSet->Buffer2NextDescAddr);
  }
  else
  {
    for (i=0; i< buf_count; i++)
 8012510:	42a2      	cmp	r2, r4
      }
        
      /*give back descriptor to DMA */
      DMATxNextDesc->Status |= ETH_DMATxDesc_OWN;
      
      DMATxNextDesc = (ETH_DMADESCTypeDef *)(DMATxNextDesc->Buffer2NextDescAddr);
 8012512:	68db      	ldr	r3, [r3, #12]
    DMATxDescToSet->Status |= ETH_DMATxDesc_OWN;
    DMATxDescToSet= (ETH_DMADESCTypeDef *)(DMATxDescToSet->Buffer2NextDescAddr);
  }
  else
  {
    for (i=0; i< buf_count; i++)
 8012514:	d1f2      	bne.n	80124fc <ETH_Prepare_Transmit_Descriptors+0x40>
      DMATxNextDesc->Status |= ETH_DMATxDesc_OWN;
      
      DMATxNextDesc = (ETH_DMADESCTypeDef *)(DMATxNextDesc->Buffer2NextDescAddr);
      /* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */
     }
    DMATxDescToSet = DMATxNextDesc ;
 8012516:	6033      	str	r3, [r6, #0]
  }
    
  /* When Tx Buffer unavailable flag is set: clear it and resume transmission */
  if ((ETH->DMASR & ETH_DMASR_TBUS) != (u32)RESET)
 8012518:	f241 0214 	movw	r2, #4116	; 0x1014
 801251c:	4b19      	ldr	r3, [pc, #100]	; (8012584 <ETH_Prepare_Transmit_Descriptors+0xc8>)
 801251e:	5899      	ldr	r1, [r3, r2]
 8012520:	0749      	lsls	r1, r1, #29
 8012522:	d51e      	bpl.n	8012562 <ETH_Prepare_Transmit_Descriptors+0xa6>
  {
    /* Clear TBUS ETHERNET DMA flag */
    ETH->DMASR = ETH_DMASR_TBUS;
    /* Resume DMA transmission*/
    ETH->DMATPDR = 0;
 8012524:	f241 0104 	movw	r1, #4100	; 0x1004
    
  /* When Tx Buffer unavailable flag is set: clear it and resume transmission */
  if ((ETH->DMASR & ETH_DMASR_TBUS) != (u32)RESET)
  {
    /* Clear TBUS ETHERNET DMA flag */
    ETH->DMASR = ETH_DMASR_TBUS;
 8012528:	2004      	movs	r0, #4
    /* Resume DMA transmission*/
    ETH->DMATPDR = 0;
 801252a:	2400      	movs	r4, #0
    
  /* When Tx Buffer unavailable flag is set: clear it and resume transmission */
  if ((ETH->DMASR & ETH_DMASR_TBUS) != (u32)RESET)
  {
    /* Clear TBUS ETHERNET DMA flag */
    ETH->DMASR = ETH_DMASR_TBUS;
 801252c:	5098      	str	r0, [r3, r2]
    /* Resume DMA transmission*/
    ETH->DMATPDR = 0;
  }
  
  /* Return SUCCESS */
  return ETH_SUCCESS;   
 801252e:	2001      	movs	r0, #1
  if ((ETH->DMASR & ETH_DMASR_TBUS) != (u32)RESET)
  {
    /* Clear TBUS ETHERNET DMA flag */
    ETH->DMASR = ETH_DMASR_TBUS;
    /* Resume DMA transmission*/
    ETH->DMATPDR = 0;
 8012530:	505c      	str	r4, [r3, r1]
 8012532:	bdf0      	pop	{r4, r5, r6, r7, pc}
    buf_count = FrameLength/ETH_TX_BUF_SIZE;
    if (FrameLength%ETH_TX_BUF_SIZE) buf_count++;
  }
  else buf_count =1;
  
  if (buf_count ==1)
 8012534:	2c01      	cmp	r4, #1
 8012536:	d1d5      	bne.n	80124e4 <ETH_Prepare_Transmit_Descriptors+0x28>
  {
    /*set LAST and FIRST segment */
    DMATxDescToSet->Status |=ETH_DMATxDesc_FS|ETH_DMATxDesc_LS;
 8012538:	683b      	ldr	r3, [r7, #0]
    /* Set frame size */
    DMATxDescToSet->ControlBufferSize = (FrameLength& ETH_DMATxDesc_TBS1);
 801253a:	f3c0 000c 	ubfx	r0, r0, #0, #13
  else buf_count =1;
  
  if (buf_count ==1)
  {
    /*set LAST and FIRST segment */
    DMATxDescToSet->Status |=ETH_DMATxDesc_FS|ETH_DMATxDesc_LS;
 801253e:	f043 5340 	orr.w	r3, r3, #805306368	; 0x30000000
 8012542:	603b      	str	r3, [r7, #0]
    /* Set frame size */
    DMATxDescToSet->ControlBufferSize = (FrameLength& ETH_DMATxDesc_TBS1);
 8012544:	6078      	str	r0, [r7, #4]
    /* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */
    DMATxDescToSet->Status |= ETH_DMATxDesc_OWN;
 8012546:	683b      	ldr	r3, [r7, #0]
 8012548:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 801254c:	603b      	str	r3, [r7, #0]
    DMATxDescToSet= (ETH_DMADESCTypeDef *)(DMATxDescToSet->Buffer2NextDescAddr);
 801254e:	68fb      	ldr	r3, [r7, #12]
 8012550:	6033      	str	r3, [r6, #0]
 8012552:	e7e1      	b.n	8012518 <ETH_Prepare_Transmit_Descriptors+0x5c>
      DMATxNextDesc->ControlBufferSize = (ETH_TX_BUF_SIZE & ETH_DMATxDesc_TBS1);
       
      if (i== (buf_count-1))
      {
        /* Setting the last segment bit */
        DMATxNextDesc->Status |= ETH_DMATxDesc_LS;
 8012554:	6819      	ldr	r1, [r3, #0]
 8012556:	f041 5100 	orr.w	r1, r1, #536870912	; 0x20000000
 801255a:	6019      	str	r1, [r3, #0]
        size = FrameLength - (buf_count-1)*ETH_TX_BUF_SIZE;
        DMATxNextDesc->ControlBufferSize = (size & ETH_DMATxDesc_TBS1);
 801255c:	f8c3 e004 	str.w	lr, [r3, #4]
 8012560:	e7d1      	b.n	8012506 <ETH_Prepare_Transmit_Descriptors+0x4a>
    /* Resume DMA transmission*/
    ETH->DMATPDR = 0;
  }
  
  /* Return SUCCESS */
  return ETH_SUCCESS;   
 8012562:	2001      	movs	r0, #1
}
 8012564:	bdf0      	pop	{r4, r5, r6, r7, pc}
  
  /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */
  if((DMATxDescToSet->Status & ETH_DMATxDesc_OWN) != (u32)RESET)
  {  
    /* Return ERROR: OWN bit set */
    return ETH_ERROR;
 8012566:	2000      	movs	r0, #0
 8012568:	bdf0      	pop	{r4, r5, r6, r7, pc}
    for (i=0; i< buf_count; i++)
    {
      if (i==0) 
      {
        /* Setting the first segment bit */
        DMATxDescToSet->Status |= ETH_DMATxDesc_FS;  
 801256a:	6839      	ldr	r1, [r7, #0]
 801256c:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 8012570:	6039      	str	r1, [r7, #0]
      }
      
      /* Program size */
      DMATxNextDesc->ControlBufferSize = (ETH_TX_BUF_SIZE & ETH_DMATxDesc_TBS1);
 8012572:	6058      	str	r0, [r3, #4]
 8012574:	e7c7      	b.n	8012506 <ETH_Prepare_Transmit_Descriptors+0x4a>
 8012576:	bf00      	nop
 8012578:	2000f4d0 	.word	0x2000f4d0
 801257c:	ac02b00b 	.word	0xac02b00b
 8012580:	fffffa0c 	.word	0xfffffa0c
 8012584:	40028000 	.word	0x40028000

08012588 <ETH_DMARxDescChainInit>:
{
  uint32_t i = 0;
  ETH_DMADESCTypeDef *DMARxDesc;
  
  /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */
  DMARxDescToGet = DMARxDescTab; 
 8012588:	4b16      	ldr	r3, [pc, #88]	; (80125e4 <ETH_DMARxDescChainInit+0x5c>)
  * @param  RxBuff: Pointer on the first RxBuffer list
  * @param  RxBuffCount: Number of the used Rx desc in the list
  * @retval None
  */
void ETH_DMARxDescChainInit(ETH_DMADESCTypeDef *DMARxDescTab, uint8_t *RxBuff, uint32_t RxBuffCount)
{
 801258a:	b5f0      	push	{r4, r5, r6, r7, lr}
 801258c:	4686      	mov	lr, r0
  uint32_t i = 0;
  ETH_DMADESCTypeDef *DMARxDesc;
  
  /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */
  DMARxDescToGet = DMARxDescTab; 
 801258e:	6018      	str	r0, [r3, #0]
  /* Fill each DMARxDesc descriptor with the right values */
  for(i=0; i < RxBuffCount; i++)
 8012590:	b1f2      	cbz	r2, 80125d0 <ETH_DMARxDescChainInit+0x48>
    DMARxDesc = DMARxDescTab+i;
    /* Set Own bit of the Rx descriptor Status */
    DMARxDesc->Status = ETH_DMARxDesc_OWN;

    /* Set Buffer1 size and Second Address Chained bit */
    DMARxDesc->ControlBufferSize = ETH_DMARxDesc_RCH | (uint32_t)ETH_RX_BUF_SIZE;  
 8012592:	f244 50f4 	movw	r0, #17908	; 0x45f4
 8012596:	1e57      	subs	r7, r2, #1
 8012598:	f10e 0320 	add.w	r3, lr, #32
  ETH_DMADESCTypeDef *DMARxDesc;
  
  /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */
  DMARxDescToGet = DMARxDescTab; 
  /* Fill each DMARxDesc descriptor with the right values */
  for(i=0; i < RxBuffCount; i++)
 801259c:	2401      	movs	r4, #1
  {
    /* Get the pointer on the ith member of the Rx Desc list */
    DMARxDesc = DMARxDescTab+i;
    /* Set Own bit of the Rx descriptor Status */
    DMARxDesc->Status = ETH_DMARxDesc_OWN;
 801259e:	f04f 4600 	mov.w	r6, #2147483648	; 0x80000000
    DMARxDesc->ControlBufferSize = ETH_DMARxDesc_RCH | (uint32_t)ETH_RX_BUF_SIZE;  
    /* Set Buffer1 address pointer */
    DMARxDesc->Buffer1Addr = (uint32_t)(&RxBuff[i*ETH_RX_BUF_SIZE]);
    
    /* Initialize the next descriptor with the Next Descriptor Polling Enable */
    if(i < (RxBuffCount-1))
 80125a2:	1e65      	subs	r5, r4, #1
 80125a4:	42af      	cmp	r7, r5
 80125a6:	bf8b      	itete	hi
 80125a8:	4625      	movhi	r5, r4
 80125aa:	4625      	movls	r5, r4
    {
      /* Set next descriptor address register with next descriptor base address */
      DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab+i+1); 
 80125ac:	f843 3c14 	strhi.w	r3, [r3, #-20]
    }
    else
    {
      /* For last descriptor, set next descriptor address register equal to the first descriptor base address */ 
      DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab); 
 80125b0:	f843 ec14 	strls.w	lr, [r3, #-20]
  ETH_DMADESCTypeDef *DMARxDesc;
  
  /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */
  DMARxDescToGet = DMARxDescTab; 
  /* Fill each DMARxDesc descriptor with the right values */
  for(i=0; i < RxBuffCount; i++)
 80125b4:	42aa      	cmp	r2, r5
    DMARxDesc->Status = ETH_DMARxDesc_OWN;

    /* Set Buffer1 size and Second Address Chained bit */
    DMARxDesc->ControlBufferSize = ETH_DMARxDesc_RCH | (uint32_t)ETH_RX_BUF_SIZE;  
    /* Set Buffer1 address pointer */
    DMARxDesc->Buffer1Addr = (uint32_t)(&RxBuff[i*ETH_RX_BUF_SIZE]);
 80125b6:	f843 1c18 	str.w	r1, [r3, #-24]
  for(i=0; i < RxBuffCount; i++)
  {
    /* Get the pointer on the ith member of the Rx Desc list */
    DMARxDesc = DMARxDescTab+i;
    /* Set Own bit of the Rx descriptor Status */
    DMARxDesc->Status = ETH_DMARxDesc_OWN;
 80125ba:	f843 6c20 	str.w	r6, [r3, #-32]

    /* Set Buffer1 size and Second Address Chained bit */
    DMARxDesc->ControlBufferSize = ETH_DMARxDesc_RCH | (uint32_t)ETH_RX_BUF_SIZE;  
 80125be:	f843 0c1c 	str.w	r0, [r3, #-28]
 80125c2:	f201 51f4 	addw	r1, r1, #1524	; 0x5f4
 80125c6:	f104 0401 	add.w	r4, r4, #1
 80125ca:	f103 0320 	add.w	r3, r3, #32
  ETH_DMADESCTypeDef *DMARxDesc;
  
  /* Set the DMARxDescToGet pointer with the first one of the DMARxDescTab list */
  DMARxDescToGet = DMARxDescTab; 
  /* Fill each DMARxDesc descriptor with the right values */
  for(i=0; i < RxBuffCount; i++)
 80125ce:	d8e8      	bhi.n	80125a2 <ETH_DMARxDescChainInit+0x1a>
      DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab); 
    }
  }
   
  /* Set Receive Descriptor List Address Register */
  ETH->DMARDLAR = (uint32_t) DMARxDescTab; 
 80125d0:	f241 010c 	movw	r1, #4108	; 0x100c
 80125d4:	4804      	ldr	r0, [pc, #16]	; (80125e8 <ETH_DMARxDescChainInit+0x60>)
  

  DMA_RX_FRAME_infos = &RX_Frame_Descriptor;
 80125d6:	4b05      	ldr	r3, [pc, #20]	; (80125ec <ETH_DMARxDescChainInit+0x64>)
 80125d8:	4a05      	ldr	r2, [pc, #20]	; (80125f0 <ETH_DMARxDescChainInit+0x68>)
      DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab); 
    }
  }
   
  /* Set Receive Descriptor List Address Register */
  ETH->DMARDLAR = (uint32_t) DMARxDescTab; 
 80125da:	f840 e001 	str.w	lr, [r0, r1]
  

  DMA_RX_FRAME_infos = &RX_Frame_Descriptor;
 80125de:	601a      	str	r2, [r3, #0]

}
 80125e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80125e2:	bf00      	nop
 80125e4:	2000f4cc 	.word	0x2000f4cc
 80125e8:	40028000 	.word	0x40028000
 80125ec:	2001133c 	.word	0x2001133c
 80125f0:	2000f4c0 	.word	0x2000f4c0

080125f4 <ETH_CheckFrameReceived>:
  * @retval Returns 1 when a frame is received, 0 if none.
  */
uint32_t ETH_CheckFrameReceived(void)
{ 
  /* check if last segment */
  if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
 80125f4:	491d      	ldr	r1, [pc, #116]	; (801266c <ETH_CheckFrameReceived+0x78>)
  * @brief  This function polls for a frame reception
  * @param  None
  * @retval Returns 1 when a frame is received, 0 if none.
  */
uint32_t ETH_CheckFrameReceived(void)
{ 
 80125f6:	b410      	push	{r4}
  /* check if last segment */
  if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
 80125f8:	680b      	ldr	r3, [r1, #0]
 80125fa:	681a      	ldr	r2, [r3, #0]
 80125fc:	2a00      	cmp	r2, #0
 80125fe:	db02      	blt.n	8012606 <ETH_CheckFrameReceived+0x12>
     ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) != (uint32_t)RESET)) 
 8012600:	681a      	ldr	r2, [r3, #0]
  * @retval Returns 1 when a frame is received, 0 if none.
  */
uint32_t ETH_CheckFrameReceived(void)
{ 
  /* check if last segment */
  if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
 8012602:	05d4      	lsls	r4, r2, #23
 8012604:	d41c      	bmi.n	8012640 <ETH_CheckFrameReceived+0x4c>
      DMA_RX_FRAME_infos->Seg_Count++;
      return 1;
    }
  
    /* check if first segment */
    else if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
 8012606:	681a      	ldr	r2, [r3, #0]
 8012608:	2a00      	cmp	r2, #0
 801260a:	db06      	blt.n	801261a <ETH_CheckFrameReceived+0x26>
     ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET)&&
 801260c:	681a      	ldr	r2, [r3, #0]
      DMA_RX_FRAME_infos->Seg_Count++;
      return 1;
    }
  
    /* check if first segment */
    else if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
 801260e:	0590      	lsls	r0, r2, #22
 8012610:	d503      	bpl.n	801261a <ETH_CheckFrameReceived+0x26>
     ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET)&&
     ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) == (uint32_t)RESET))      
 8012612:	6818      	ldr	r0, [r3, #0]
      return 1;
    }
  
    /* check if first segment */
    else if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
     ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET)&&
 8012614:	f410 7080 	ands.w	r0, r0, #256	; 0x100
 8012618:	d01e      	beq.n	8012658 <ETH_CheckFrameReceived+0x64>
      DMA_RX_FRAME_infos->Seg_Count = 1;   
      DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
    }
    
    /* check if intermediate segment */ 
    else if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
 801261a:	681a      	ldr	r2, [r3, #0]
 801261c:	2a00      	cmp	r2, #0
 801261e:	db18      	blt.n	8012652 <ETH_CheckFrameReceived+0x5e>
     ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) == (uint32_t)RESET)&&
 8012620:	6818      	ldr	r0, [r3, #0]
      DMA_RX_FRAME_infos->Seg_Count = 1;   
      DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
    }
    
    /* check if intermediate segment */ 
    else if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
 8012622:	f410 7000 	ands.w	r0, r0, #512	; 0x200
 8012626:	d114      	bne.n	8012652 <ETH_CheckFrameReceived+0x5e>
     ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) == (uint32_t)RESET)&&
     ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) == (uint32_t)RESET))
 8012628:	681a      	ldr	r2, [r3, #0]
      DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
    }
    
    /* check if intermediate segment */ 
    else if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
     ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) == (uint32_t)RESET)&&
 801262a:	05d2      	lsls	r2, r2, #23
 801262c:	d40f      	bmi.n	801264e <ETH_CheckFrameReceived+0x5a>
     ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) == (uint32_t)RESET))
    {
      (DMA_RX_FRAME_infos->Seg_Count) ++;
 801262e:	4a10      	ldr	r2, [pc, #64]	; (8012670 <ETH_CheckFrameReceived+0x7c>)
 8012630:	6814      	ldr	r4, [r2, #0]
 8012632:	68a2      	ldr	r2, [r4, #8]
 8012634:	3201      	adds	r2, #1
 8012636:	60a2      	str	r2, [r4, #8]
      DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
 8012638:	68db      	ldr	r3, [r3, #12]
    } 
    return 0;
}
 801263a:	bc10      	pop	{r4}
    else if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
     ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) == (uint32_t)RESET)&&
     ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) == (uint32_t)RESET))
    {
      (DMA_RX_FRAME_infos->Seg_Count) ++;
      DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
 801263c:	600b      	str	r3, [r1, #0]
    } 
    return 0;
}
 801263e:	4770      	bx	lr
{ 
  /* check if last segment */
  if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
     ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) != (uint32_t)RESET)) 
    {   
      DMA_RX_FRAME_infos->LS_Rx_Desc = DMARxDescToGet;
 8012640:	4a0b      	ldr	r2, [pc, #44]	; (8012670 <ETH_CheckFrameReceived+0x7c>)
      DMA_RX_FRAME_infos->Seg_Count++;
      return 1;
 8012642:	2001      	movs	r0, #1
{ 
  /* check if last segment */
  if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
     ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) != (uint32_t)RESET)) 
    {   
      DMA_RX_FRAME_infos->LS_Rx_Desc = DMARxDescToGet;
 8012644:	6812      	ldr	r2, [r2, #0]
 8012646:	6053      	str	r3, [r2, #4]
      DMA_RX_FRAME_infos->Seg_Count++;
 8012648:	6893      	ldr	r3, [r2, #8]
 801264a:	4403      	add	r3, r0
 801264c:	6093      	str	r3, [r2, #8]
    {
      (DMA_RX_FRAME_infos->Seg_Count) ++;
      DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
    } 
    return 0;
}
 801264e:	bc10      	pop	{r4}
 8012650:	4770      	bx	lr
     ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) == (uint32_t)RESET))
    {
      (DMA_RX_FRAME_infos->Seg_Count) ++;
      DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
    } 
    return 0;
 8012652:	2000      	movs	r0, #0
}
 8012654:	bc10      	pop	{r4}
 8012656:	4770      	bx	lr
    /* check if first segment */
    else if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
     ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET)&&
     ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) == (uint32_t)RESET))      
    {
      DMA_RX_FRAME_infos->FS_Rx_Desc = DMARxDescToGet;
 8012658:	4a05      	ldr	r2, [pc, #20]	; (8012670 <ETH_CheckFrameReceived+0x7c>)
      DMA_RX_FRAME_infos->LS_Rx_Desc = NULL;
      DMA_RX_FRAME_infos->Seg_Count = 1;   
 801265a:	2401      	movs	r4, #1
    /* check if first segment */
    else if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
     ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (uint32_t)RESET)&&
     ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) == (uint32_t)RESET))      
    {
      DMA_RX_FRAME_infos->FS_Rx_Desc = DMARxDescToGet;
 801265c:	6812      	ldr	r2, [r2, #0]
 801265e:	6013      	str	r3, [r2, #0]
      DMA_RX_FRAME_infos->LS_Rx_Desc = NULL;
 8012660:	6050      	str	r0, [r2, #4]
      DMA_RX_FRAME_infos->Seg_Count = 1;   
 8012662:	6094      	str	r4, [r2, #8]
      DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
 8012664:	68db      	ldr	r3, [r3, #12]
    {
      (DMA_RX_FRAME_infos->Seg_Count) ++;
      DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
    } 
    return 0;
}
 8012666:	bc10      	pop	{r4}
     ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) == (uint32_t)RESET))      
    {
      DMA_RX_FRAME_infos->FS_Rx_Desc = DMARxDescToGet;
      DMA_RX_FRAME_infos->LS_Rx_Desc = NULL;
      DMA_RX_FRAME_infos->Seg_Count = 1;   
      DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
 8012668:	600b      	str	r3, [r1, #0]
    {
      (DMA_RX_FRAME_infos->Seg_Count) ++;
      DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);
    } 
    return 0;
}
 801266a:	4770      	bx	lr
 801266c:	2000f4cc 	.word	0x2000f4cc
 8012670:	2001133c 	.word	0x2001133c

08012674 <ETH_DMATxDescChainInit>:
{
  uint32_t i = 0;
  ETH_DMADESCTypeDef *DMATxDesc;
  
  /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
  DMATxDescToSet = DMATxDescTab;
 8012674:	4b14      	ldr	r3, [pc, #80]	; (80126c8 <ETH_DMATxDescChainInit+0x54>)
 8012676:	6018      	str	r0, [r3, #0]
  /* Fill each DMATxDesc descriptor with the right values */   
  for(i=0; i < TxBuffCount; i++)
 8012678:	b30a      	cbz	r2, 80126be <ETH_DMATxDescChainInit+0x4a>
  * @param  TxBuff: Pointer on the first TxBuffer list
  * @param  TxBuffCount: Number of the used Tx desc in the list
  * @retval None
  */
void ETH_DMATxDescChainInit(ETH_DMADESCTypeDef *DMATxDescTab, uint8_t* TxBuff, uint32_t TxBuffCount)
{
 801267a:	b4f0      	push	{r4, r5, r6, r7}
 801267c:	f100 0320 	add.w	r3, r0, #32
 8012680:	1e57      	subs	r7, r2, #1
  ETH_DMADESCTypeDef *DMATxDesc;
  
  /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
  DMATxDescToSet = DMATxDescTab;
  /* Fill each DMATxDesc descriptor with the right values */   
  for(i=0; i < TxBuffCount; i++)
 8012682:	2401      	movs	r4, #1
  {
    /* Get the pointer on the ith member of the Tx Desc list */
    DMATxDesc = DMATxDescTab + i;
    /* Set Second Address Chained bit */
    DMATxDesc->Status = ETH_DMATxDesc_TCH;  
 8012684:	f44f 1680 	mov.w	r6, #1048576	; 0x100000
       
    /* Set Buffer1 address pointer */
    DMATxDesc->Buffer1Addr = (uint32_t)(&TxBuff[i*ETH_TX_BUF_SIZE]);
    
    /* Initialize the next descriptor with the Next Descriptor Polling Enable */
    if(i < (TxBuffCount-1))
 8012688:	1e65      	subs	r5, r4, #1
 801268a:	42bd      	cmp	r5, r7
 801268c:	bf35      	itete	cc
 801268e:	4625      	movcc	r5, r4
 8012690:	4625      	movcs	r5, r4
    {
      /* Set next descriptor address register with next descriptor base address */
      DMATxDesc->Buffer2NextDescAddr = (uint32_t)(DMATxDescTab+i+1);
 8012692:	f843 3c14 	strcc.w	r3, [r3, #-20]
    }
    else
    {
      /* For last descriptor, set next descriptor address register equal to the first descriptor base address */ 
      DMATxDesc->Buffer2NextDescAddr = (uint32_t) DMATxDescTab;  
 8012696:	f843 0c14 	strcs.w	r0, [r3, #-20]
  ETH_DMADESCTypeDef *DMATxDesc;
  
  /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
  DMATxDescToSet = DMATxDescTab;
  /* Fill each DMATxDesc descriptor with the right values */   
  for(i=0; i < TxBuffCount; i++)
 801269a:	42aa      	cmp	r2, r5
    DMATxDesc = DMATxDescTab + i;
    /* Set Second Address Chained bit */
    DMATxDesc->Status = ETH_DMATxDesc_TCH;  
       
    /* Set Buffer1 address pointer */
    DMATxDesc->Buffer1Addr = (uint32_t)(&TxBuff[i*ETH_TX_BUF_SIZE]);
 801269c:	f843 1c18 	str.w	r1, [r3, #-24]
  for(i=0; i < TxBuffCount; i++)
  {
    /* Get the pointer on the ith member of the Tx Desc list */
    DMATxDesc = DMATxDescTab + i;
    /* Set Second Address Chained bit */
    DMATxDesc->Status = ETH_DMATxDesc_TCH;  
 80126a0:	f843 6c20 	str.w	r6, [r3, #-32]
 80126a4:	f201 51f4 	addw	r1, r1, #1524	; 0x5f4
 80126a8:	f104 0401 	add.w	r4, r4, #1
 80126ac:	f103 0320 	add.w	r3, r3, #32
  ETH_DMADESCTypeDef *DMATxDesc;
  
  /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
  DMATxDescToSet = DMATxDescTab;
  /* Fill each DMATxDesc descriptor with the right values */   
  for(i=0; i < TxBuffCount; i++)
 80126b0:	d8ea      	bhi.n	8012688 <ETH_DMATxDescChainInit+0x14>
      DMATxDesc->Buffer2NextDescAddr = (uint32_t) DMATxDescTab;  
    }
  }
   
  /* Set Transmit Desciptor List Address Register */
  ETH->DMATDLAR = (uint32_t) DMATxDescTab;
 80126b2:	f241 0310 	movw	r3, #4112	; 0x1010
}
 80126b6:	bcf0      	pop	{r4, r5, r6, r7}
      DMATxDesc->Buffer2NextDescAddr = (uint32_t) DMATxDescTab;  
    }
  }
   
  /* Set Transmit Desciptor List Address Register */
  ETH->DMATDLAR = (uint32_t) DMATxDescTab;
 80126b8:	4a04      	ldr	r2, [pc, #16]	; (80126cc <ETH_DMATxDescChainInit+0x58>)
 80126ba:	50d0      	str	r0, [r2, r3]
}
 80126bc:	4770      	bx	lr
      DMATxDesc->Buffer2NextDescAddr = (uint32_t) DMATxDescTab;  
    }
  }
   
  /* Set Transmit Desciptor List Address Register */
  ETH->DMATDLAR = (uint32_t) DMATxDescTab;
 80126be:	f241 0310 	movw	r3, #4112	; 0x1010
 80126c2:	4a02      	ldr	r2, [pc, #8]	; (80126cc <ETH_DMATxDescChainInit+0x58>)
 80126c4:	50d0      	str	r0, [r2, r3]
 80126c6:	4770      	bx	lr
 80126c8:	2000f4d0 	.word	0x2000f4d0
 80126cc:	40028000 	.word	0x40028000

080126d0 <ETH_GetDMATxDescFlagStatus>:
 80126d0:	6803      	ldr	r3, [r0, #0]
 80126d2:	4219      	tst	r1, r3
 80126d4:	bf14      	ite	ne
 80126d6:	2001      	movne	r0, #1
 80126d8:	2000      	moveq	r0, #0
 80126da:	4770      	bx	lr

080126dc <ETH_GetDMATxDescCollisionCount>:
  * @retval The Transmit descriptor collision counter value.
  */
uint32_t ETH_GetDMATxDescCollisionCount(ETH_DMADESCTypeDef *DMATxDesc)
{
  /* Return the Receive descriptor frame length */
  return ((DMATxDesc->Status & ETH_DMATxDesc_CC) >> ETH_DMATXDESC_COLLISION_COUNTSHIFT);
 80126dc:	6800      	ldr	r0, [r0, #0]
}
 80126de:	f3c0 00c3 	ubfx	r0, r0, #3, #4
 80126e2:	4770      	bx	lr

080126e4 <ETH_SetDMATxDescOwnBit>:
 80126e4:	6803      	ldr	r3, [r0, #0]
 80126e6:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80126ea:	6003      	str	r3, [r0, #0]
 80126ec:	4770      	bx	lr
 80126ee:	bf00      	nop

080126f0 <ETH_DMATxDescTransmitITConfig>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the DMA Tx Desc Transmit interrupt */
    DMATxDesc->Status |= ETH_DMATxDesc_IC;
 80126f0:	6803      	ldr	r3, [r0, #0]
void ETH_DMATxDescTransmitITConfig(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80126f2:	b919      	cbnz	r1, 80126fc <ETH_DMATxDescTransmitITConfig+0xc>
    DMATxDesc->Status |= ETH_DMATxDesc_IC;
  }
  else
  {
    /* Disable the DMA Tx Desc Transmit interrupt */
    DMATxDesc->Status &=(~(uint32_t)ETH_DMATxDesc_IC);
 80126f4:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 80126f8:	6003      	str	r3, [r0, #0]
 80126fa:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the DMA Tx Desc Transmit interrupt */
    DMATxDesc->Status |= ETH_DMATxDesc_IC;
 80126fc:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8012700:	6003      	str	r3, [r0, #0]
 8012702:	4770      	bx	lr

08012704 <ETH_DMATxDescFrameSegmentConfig>:
 8012704:	6803      	ldr	r3, [r0, #0]
 8012706:	4319      	orrs	r1, r3
 8012708:	6001      	str	r1, [r0, #0]
 801270a:	4770      	bx	lr

0801270c <ETH_DMATxDescChecksumInsertionConfig>:
{
  /* Check the parameters */
  assert_param(IS_ETH_DMA_TXDESC_CHECKSUM(DMATxDesc_Checksum));
  
  /* Set the selected DMA Tx desc checksum insertion control */
  DMATxDesc->Status |= DMATxDesc_Checksum;
 801270c:	6803      	ldr	r3, [r0, #0]
 801270e:	4319      	orrs	r1, r3
 8012710:	6001      	str	r1, [r0, #0]
 8012712:	4770      	bx	lr

08012714 <ETH_DMATxDescCRCCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected DMA Tx Desc CRC */
    DMATxDesc->Status &= (~(uint32_t)ETH_DMATxDesc_DC);
 8012714:	6803      	ldr	r3, [r0, #0]
void ETH_DMATxDescCRCCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8012716:	b919      	cbnz	r1, 8012720 <ETH_DMATxDescCRCCmd+0xc>
    DMATxDesc->Status &= (~(uint32_t)ETH_DMATxDesc_DC);
  }
  else
  {
    /* Disable the selected DMA Tx Desc CRC */
    DMATxDesc->Status |= ETH_DMATxDesc_DC; 
 8012718:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 801271c:	6003      	str	r3, [r0, #0]
 801271e:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected DMA Tx Desc CRC */
    DMATxDesc->Status &= (~(uint32_t)ETH_DMATxDesc_DC);
 8012720:	f023 6300 	bic.w	r3, r3, #134217728	; 0x8000000
 8012724:	6003      	str	r3, [r0, #0]
 8012726:	4770      	bx	lr

08012728 <ETH_DMATxDescSecondAddressChainedCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected DMA Tx Desc second address chained */
    DMATxDesc->Status |= ETH_DMATxDesc_TCH;  
 8012728:	6803      	ldr	r3, [r0, #0]
void ETH_DMATxDescSecondAddressChainedCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 801272a:	b919      	cbnz	r1, 8012734 <ETH_DMATxDescSecondAddressChainedCmd+0xc>
    DMATxDesc->Status |= ETH_DMATxDesc_TCH;  
  }
  else
  {
    /* Disable the selected DMA Tx Desc second address chained */
    DMATxDesc->Status &=(~(uint32_t)ETH_DMATxDesc_TCH); 
 801272c:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 8012730:	6003      	str	r3, [r0, #0]
 8012732:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected DMA Tx Desc second address chained */
    DMATxDesc->Status |= ETH_DMATxDesc_TCH;  
 8012734:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8012738:	6003      	str	r3, [r0, #0]
 801273a:	4770      	bx	lr

0801273c <ETH_DMATxDescShortFramePaddingCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected DMA Tx Desc padding for frame shorter than 64 bytes */
    DMATxDesc->Status &= (~(uint32_t)ETH_DMATxDesc_DP);
 801273c:	6803      	ldr	r3, [r0, #0]
void ETH_DMATxDescShortFramePaddingCmd(ETH_DMADESCTypeDef *DMATxDesc, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 801273e:	b919      	cbnz	r1, 8012748 <ETH_DMATxDescShortFramePaddingCmd+0xc>
    DMATxDesc->Status &= (~(uint32_t)ETH_DMATxDesc_DP);
  }
  else
  {
    /* Disable the selected DMA Tx Desc padding for frame shorter than 64 bytes*/
    DMATxDesc->Status |= ETH_DMATxDesc_DP; 
 8012740:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8012744:	6003      	str	r3, [r0, #0]
 8012746:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected DMA Tx Desc padding for frame shorter than 64 bytes */
    DMATxDesc->Status &= (~(uint32_t)ETH_DMATxDesc_DP);
 8012748:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 801274c:	6003      	str	r3, [r0, #0]
 801274e:	4770      	bx	lr

08012750 <ETH_DMATxDescBufferSizeConfig>:
  /* Check the parameters */
  assert_param(IS_ETH_DMATxDESC_BUFFER_SIZE(BufferSize1));
  assert_param(IS_ETH_DMATxDESC_BUFFER_SIZE(BufferSize2));
  
  /* Set the DMA Tx Desc buffer1 and buffer2 sizes values */
  DMATxDesc->ControlBufferSize |= (BufferSize1 | (BufferSize2 << ETH_DMATXDESC_BUFFER2_SIZESHIFT));
 8012750:	6843      	ldr	r3, [r0, #4]
 8012752:	4319      	orrs	r1, r3
 8012754:	ea41 4202 	orr.w	r2, r1, r2, lsl #16
 8012758:	6042      	str	r2, [r0, #4]
 801275a:	4770      	bx	lr

0801275c <ETH_GetDMARxDescFlagStatus>:
FlagStatus ETH_GetDMARxDescFlagStatus(ETH_DMADESCTypeDef *DMARxDesc, uint32_t ETH_DMARxDescFlag)
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ETH_DMARxDESC_GET_FLAG(ETH_DMARxDescFlag));
  if ((DMARxDesc->Status & ETH_DMARxDescFlag) != (uint32_t)RESET)
 801275c:	6803      	ldr	r3, [r0, #0]
  }
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
 801275e:	420b      	tst	r3, r1
}
 8012760:	bf14      	ite	ne
 8012762:	2001      	movne	r0, #1
 8012764:	2000      	moveq	r0, #0
 8012766:	4770      	bx	lr

08012768 <ETH_GetDMAPTPRxDescExtendedFlagStatus>:
  }
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
 8012768:	6903      	ldr	r3, [r0, #16]
 801276a:	4219      	tst	r1, r3
}
 801276c:	bf14      	ite	ne
 801276e:	2001      	movne	r0, #1
 8012770:	2000      	moveq	r0, #0
 8012772:	4770      	bx	lr

08012774 <ETH_SetDMARxDescOwnBit>:
  * @retval None
  */
void ETH_SetDMARxDescOwnBit(ETH_DMADESCTypeDef *DMARxDesc)
{
  /* Set the DMA Rx Desc Own bit */
  DMARxDesc->Status |= ETH_DMARxDesc_OWN;
 8012774:	6803      	ldr	r3, [r0, #0]
 8012776:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 801277a:	6003      	str	r3, [r0, #0]
 801277c:	4770      	bx	lr
 801277e:	bf00      	nop

08012780 <ETH_GetDMARxDescFrameLength>:
  * @retval The Rx descriptor received frame length.
  */
uint32_t ETH_GetDMARxDescFrameLength(ETH_DMADESCTypeDef *DMARxDesc)
{
  /* Return the Receive descriptor frame length */
  return ((DMARxDesc->Status & ETH_DMARxDesc_FL) >> ETH_DMARXDESC_FRAME_LENGTHSHIFT);
 8012780:	6800      	ldr	r0, [r0, #0]
}
 8012782:	f3c0 400d 	ubfx	r0, r0, #16, #14
 8012786:	4770      	bx	lr

08012788 <ETH_DMARxDescReceiveITConfig>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the DMA Rx Desc receive interrupt */
    DMARxDesc->ControlBufferSize &=(~(uint32_t)ETH_DMARxDesc_DIC);
 8012788:	6843      	ldr	r3, [r0, #4]
void ETH_DMARxDescReceiveITConfig(ETH_DMADESCTypeDef *DMARxDesc, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 801278a:	b919      	cbnz	r1, 8012794 <ETH_DMARxDescReceiveITConfig+0xc>
    DMARxDesc->ControlBufferSize &=(~(uint32_t)ETH_DMARxDesc_DIC);
  }
  else
  {
    /* Disable the DMA Rx Desc receive interrupt */
    DMARxDesc->ControlBufferSize |= ETH_DMARxDesc_DIC;
 801278c:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8012790:	6043      	str	r3, [r0, #4]
 8012792:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the DMA Rx Desc receive interrupt */
    DMARxDesc->ControlBufferSize &=(~(uint32_t)ETH_DMARxDesc_DIC);
 8012794:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8012798:	6043      	str	r3, [r0, #4]
 801279a:	4770      	bx	lr

0801279c <ETH_GetDMARxDescBufferSize>:
uint32_t ETH_GetDMARxDescBufferSize(ETH_DMADESCTypeDef *DMARxDesc, uint32_t DMARxDesc_Buffer)
{
  /* Check the parameters */
  assert_param(IS_ETH_DMA_RXDESC_BUFFER(DMARxDesc_Buffer));
  
  if(DMARxDesc_Buffer != ETH_DMARxDesc_Buffer1)
 801279c:	b919      	cbnz	r1, 80127a6 <ETH_GetDMARxDescBufferSize+0xa>
    return ((DMARxDesc->ControlBufferSize & ETH_DMARxDesc_RBS2) >> ETH_DMARXDESC_BUFFER2_SIZESHIFT); 
  }
  else
  {
    /* Return the DMA Rx Desc buffer1 size */
    return (DMARxDesc->ControlBufferSize & ETH_DMARxDesc_RBS1); 
 801279e:	6840      	ldr	r0, [r0, #4]
 80127a0:	f3c0 000c 	ubfx	r0, r0, #0, #13
  }
}
 80127a4:	4770      	bx	lr
  assert_param(IS_ETH_DMA_RXDESC_BUFFER(DMARxDesc_Buffer));
  
  if(DMARxDesc_Buffer != ETH_DMARxDesc_Buffer1)
  {
    /* Return the DMA Rx Desc buffer2 size */
    return ((DMARxDesc->ControlBufferSize & ETH_DMARxDesc_RBS2) >> ETH_DMARXDESC_BUFFER2_SIZESHIFT); 
 80127a6:	88c0      	ldrh	r0, [r0, #6]
 80127a8:	f3c0 000c 	ubfx	r0, r0, #0, #13
 80127ac:	4770      	bx	lr
 80127ae:	bf00      	nop

080127b0 <ETH_GetRxPktSize>:
  * @retval framelength: received packet size 
  */
uint32_t ETH_GetRxPktSize(ETH_DMADESCTypeDef *DMARxDesc)
{
  uint32_t frameLength = 0;
  if(((DMARxDesc->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
 80127b0:	6803      	ldr	r3, [r0, #0]
 80127b2:	2b00      	cmp	r3, #0
 80127b4:	db0a      	blt.n	80127cc <ETH_GetRxPktSize+0x1c>
     ((DMARxDesc->Status & ETH_DMARxDesc_ES) == (uint32_t)RESET) &&
 80127b6:	6803      	ldr	r3, [r0, #0]
  * @retval framelength: received packet size 
  */
uint32_t ETH_GetRxPktSize(ETH_DMADESCTypeDef *DMARxDesc)
{
  uint32_t frameLength = 0;
  if(((DMARxDesc->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
 80127b8:	041b      	lsls	r3, r3, #16
 80127ba:	d407      	bmi.n	80127cc <ETH_GetRxPktSize+0x1c>
     ((DMARxDesc->Status & ETH_DMARxDesc_ES) == (uint32_t)RESET) &&
     ((DMARxDesc->Status & ETH_DMARxDesc_LS) != (uint32_t)RESET)) 
 80127bc:	6803      	ldr	r3, [r0, #0]
  */
uint32_t ETH_GetRxPktSize(ETH_DMADESCTypeDef *DMARxDesc)
{
  uint32_t frameLength = 0;
  if(((DMARxDesc->Status & ETH_DMARxDesc_OWN) == (uint32_t)RESET) &&
     ((DMARxDesc->Status & ETH_DMARxDesc_ES) == (uint32_t)RESET) &&
 80127be:	f413 7380 	ands.w	r3, r3, #256	; 0x100
 80127c2:	d005      	beq.n	80127d0 <ETH_GetRxPktSize+0x20>
  * @retval The Rx descriptor received frame length.
  */
uint32_t ETH_GetDMARxDescFrameLength(ETH_DMADESCTypeDef *DMARxDesc)
{
  /* Return the Receive descriptor frame length */
  return ((DMARxDesc->Status & ETH_DMARxDesc_FL) >> ETH_DMARXDESC_FRAME_LENGTHSHIFT);
 80127c4:	6800      	ldr	r0, [r0, #0]
 80127c6:	f3c0 400d 	ubfx	r0, r0, #16, #14
 80127ca:	4770      	bx	lr
  * @param  None
  * @retval framelength: received packet size 
  */
uint32_t ETH_GetRxPktSize(ETH_DMADESCTypeDef *DMARxDesc)
{
  uint32_t frameLength = 0;
 80127cc:	2000      	movs	r0, #0
 80127ce:	4770      	bx	lr
 80127d0:	4618      	mov	r0, r3
    frameLength =  ETH_GetDMARxDescFrameLength(DMARxDesc);
  }
  
  /* Return Frame Length */ 
  return frameLength;
}
 80127d2:	4770      	bx	lr

080127d4 <ETH_EnhancedDescriptorCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable enhanced descriptor structure */
    ETH->DMABMR |= ETH_DMABMR_EDE;  
 80127d4:	4a05      	ldr	r2, [pc, #20]	; (80127ec <ETH_EnhancedDescriptorCmd+0x18>)
 80127d6:	6813      	ldr	r3, [r2, #0]
void ETH_EnhancedDescriptorCmd(FunctionalState NewState)
{ 
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80127d8:	b918      	cbnz	r0, 80127e2 <ETH_EnhancedDescriptorCmd+0xe>
    ETH->DMABMR |= ETH_DMABMR_EDE;  
  }
  else
  {
    /* Disable enhanced descriptor structure */
    ETH->DMABMR &= ~ETH_DMABMR_EDE;
 80127da:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80127de:	6013      	str	r3, [r2, #0]
 80127e0:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable enhanced descriptor structure */
    ETH->DMABMR |= ETH_DMABMR_EDE;  
 80127e2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80127e6:	6013      	str	r3, [r2, #0]
 80127e8:	4770      	bx	lr
 80127ea:	bf00      	nop
 80127ec:	40029000 	.word	0x40029000

080127f0 <ETH_SoftwareReset>:
  */
void ETH_SoftwareReset(void)
{
  /* Set the SWR bit: resets all MAC subsystem internal registers and logic */
  /* After reset all the registers holds their respective reset values */
  ETH->DMABMR |= ETH_DMABMR_SR;
 80127f0:	4a02      	ldr	r2, [pc, #8]	; (80127fc <ETH_SoftwareReset+0xc>)
 80127f2:	6813      	ldr	r3, [r2, #0]
 80127f4:	f043 0301 	orr.w	r3, r3, #1
 80127f8:	6013      	str	r3, [r2, #0]
 80127fa:	4770      	bx	lr
 80127fc:	40029000 	.word	0x40029000

08012800 <ETH_GetSoftwareResetStatus>:
  * @retval The new state of DMA Bus Mode register SR bit (SET or RESET).
  */
FlagStatus ETH_GetSoftwareResetStatus(void)
{
  FlagStatus bitstatus = RESET;
  if((ETH->DMABMR & ETH_DMABMR_SR) != (uint32_t)RESET)
 8012800:	4b02      	ldr	r3, [pc, #8]	; (801280c <ETH_GetSoftwareResetStatus+0xc>)
 8012802:	6818      	ldr	r0, [r3, #0]
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 8012804:	f000 0001 	and.w	r0, r0, #1
 8012808:	4770      	bx	lr
 801280a:	bf00      	nop
 801280c:	40029000 	.word	0x40029000

08012810 <ETH_DMAClearFlag>:
 8012810:	f241 0314 	movw	r3, #4116	; 0x1014
 8012814:	4a01      	ldr	r2, [pc, #4]	; (801281c <ETH_DMAClearFlag+0xc>)
 8012816:	50d0      	str	r0, [r2, r3]
 8012818:	4770      	bx	lr
 801281a:	bf00      	nop
 801281c:	40028000 	.word	0x40028000

08012820 <ETH_DMAITConfig>:
{
  /* Check the parameters */
  assert_param(IS_ETH_DMA_IT(ETH_DMA_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
 8012820:	b939      	cbnz	r1, 8012832 <ETH_DMAITConfig+0x12>
    ETH->DMAIER |= ETH_DMA_IT;
  }
  else
  {
    /* Disable the selected ETHERNET DMA interrupts */
    ETH->DMAIER &=(~(uint32_t)ETH_DMA_IT);
 8012822:	f241 021c 	movw	r2, #4124	; 0x101c
 8012826:	4906      	ldr	r1, [pc, #24]	; (8012840 <ETH_DMAITConfig+0x20>)
 8012828:	588b      	ldr	r3, [r1, r2]
 801282a:	ea23 0000 	bic.w	r0, r3, r0
 801282e:	5088      	str	r0, [r1, r2]
 8012830:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
  {
    /* Enable the selected ETHERNET DMA interrupts */
    ETH->DMAIER |= ETH_DMA_IT;
 8012832:	f241 031c 	movw	r3, #4124	; 0x101c
 8012836:	4a02      	ldr	r2, [pc, #8]	; (8012840 <ETH_DMAITConfig+0x20>)
 8012838:	58d1      	ldr	r1, [r2, r3]
 801283a:	4308      	orrs	r0, r1
 801283c:	50d0      	str	r0, [r2, r3]
 801283e:	4770      	bx	lr
 8012840:	40028000 	.word	0x40028000

08012844 <ETH_GetDMAITStatus>:
ITStatus ETH_GetDMAITStatus(uint32_t ETH_DMA_IT)
{  
  ITStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ETH_DMA_GET_IT(ETH_DMA_IT));
  if ((ETH->DMASR & ETH_DMA_IT) != (uint32_t)RESET)
 8012844:	f241 0314 	movw	r3, #4116	; 0x1014
 8012848:	4a03      	ldr	r2, [pc, #12]	; (8012858 <ETH_GetDMAITStatus+0x14>)
 801284a:	58d3      	ldr	r3, [r2, r3]
  }
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
 801284c:	4203      	tst	r3, r0
}
 801284e:	bf14      	ite	ne
 8012850:	2001      	movne	r0, #1
 8012852:	2000      	moveq	r0, #0
 8012854:	4770      	bx	lr
 8012856:	bf00      	nop
 8012858:	40028000 	.word	0x40028000

0801285c <ETH_GetDMAFlagStatus>:
 801285c:	f7ff bff2 	b.w	8012844 <ETH_GetDMAITStatus>

08012860 <ETH_DMAClearITPendingBit>:
{
  /* Check the parameters */
  assert_param(IS_ETH_DMA_IT(ETH_DMA_IT));
  
  /* Clear the selected ETHERNET DMA IT */
  ETH->DMASR = (uint32_t) ETH_DMA_IT;
 8012860:	f241 0314 	movw	r3, #4116	; 0x1014
 8012864:	4a01      	ldr	r2, [pc, #4]	; (801286c <ETH_DMAClearITPendingBit+0xc>)
 8012866:	50d0      	str	r0, [r2, r3]
 8012868:	4770      	bx	lr
 801286a:	bf00      	nop
 801286c:	40028000 	.word	0x40028000

08012870 <ETH_GetTransmitProcessState>:
  *     - ETH_DMA_TransmitProcess_Suspended : Suspended - Tx Descriptor unavailable
  *     - ETH_DMA_TransmitProcess_Closing   : Running - closing Rx descriptor  
  */
uint32_t ETH_GetTransmitProcessState(void)
{
  return ((uint32_t)(ETH->DMASR & ETH_DMASR_TS)); 
 8012870:	f241 0314 	movw	r3, #4116	; 0x1014
 8012874:	4a02      	ldr	r2, [pc, #8]	; (8012880 <ETH_GetTransmitProcessState+0x10>)
 8012876:	58d0      	ldr	r0, [r2, r3]
}
 8012878:	f000 0001 	and.w	r0, r0, #1
 801287c:	4770      	bx	lr
 801287e:	bf00      	nop
 8012880:	40028000 	.word	0x40028000

08012884 <ETH_GetReceiveProcessState>:
  *     - ETH_DMA_ReceiveProcess_Closing   : Running - closing descriptor
  *     - ETH_DMA_ReceiveProcess_Queuing   : Running - queuing the receive frame into host memory  
  */
uint32_t ETH_GetReceiveProcessState(void)
{
  return ((uint32_t)(ETH->DMASR & ETH_DMASR_RS)); 
 8012884:	f241 0314 	movw	r3, #4116	; 0x1014
 8012888:	4a02      	ldr	r2, [pc, #8]	; (8012894 <ETH_GetReceiveProcessState+0x10>)
 801288a:	58d0      	ldr	r0, [r2, r3]
}
 801288c:	f000 0040 	and.w	r0, r0, #64	; 0x40
 8012890:	4770      	bx	lr
 8012892:	bf00      	nop
 8012894:	40028000 	.word	0x40028000

08012898 <ETH_FlushTransmitFIFO>:
  * @retval None
  */
void ETH_FlushTransmitFIFO(void)
{
  /* Set the Flush Transmit FIFO bit */
  ETH->DMAOMR |= ETH_DMAOMR_FTF;  
 8012898:	f241 0218 	movw	r2, #4120	; 0x1018
 801289c:	4902      	ldr	r1, [pc, #8]	; (80128a8 <ETH_FlushTransmitFIFO+0x10>)
 801289e:	588b      	ldr	r3, [r1, r2]
 80128a0:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80128a4:	508b      	str	r3, [r1, r2]
 80128a6:	4770      	bx	lr
 80128a8:	40028000 	.word	0x40028000

080128ac <ETH_GetFlushTransmitFIFOStatus>:
  * @retval The new state of ETHERNET flush transmit FIFO bit (SET or RESET).
  */
FlagStatus ETH_GetFlushTransmitFIFOStatus(void)
{   
  FlagStatus bitstatus = RESET;
  if ((ETH->DMAOMR & ETH_DMAOMR_FTF) != (uint32_t)RESET)
 80128ac:	f241 0318 	movw	r3, #4120	; 0x1018
 80128b0:	4a02      	ldr	r2, [pc, #8]	; (80128bc <ETH_GetFlushTransmitFIFOStatus+0x10>)
 80128b2:	58d0      	ldr	r0, [r2, r3]
  else
  {
    bitstatus = RESET;
  }
  return bitstatus; 
}
 80128b4:	f3c0 5000 	ubfx	r0, r0, #20, #1
 80128b8:	4770      	bx	lr
 80128ba:	bf00      	nop
 80128bc:	40028000 	.word	0x40028000

080128c0 <ETH_DMATransmissionCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the DMA transmission */
    ETH->DMAOMR |= ETH_DMAOMR_ST;  
 80128c0:	f241 0218 	movw	r2, #4120	; 0x1018
 80128c4:	4905      	ldr	r1, [pc, #20]	; (80128dc <ETH_DMATransmissionCmd+0x1c>)
 80128c6:	588b      	ldr	r3, [r1, r2]
void ETH_DMATransmissionCmd(FunctionalState NewState)
{ 
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80128c8:	b918      	cbnz	r0, 80128d2 <ETH_DMATransmissionCmd+0x12>
    ETH->DMAOMR |= ETH_DMAOMR_ST;  
  }
  else
  {
    /* Disable the DMA transmission */
    ETH->DMAOMR &= ~ETH_DMAOMR_ST;
 80128ca:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 80128ce:	508b      	str	r3, [r1, r2]
 80128d0:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the DMA transmission */
    ETH->DMAOMR |= ETH_DMAOMR_ST;  
 80128d2:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80128d6:	508b      	str	r3, [r1, r2]
 80128d8:	4770      	bx	lr
 80128da:	bf00      	nop
 80128dc:	40028000 	.word	0x40028000

080128e0 <ETH_DMAReceptionCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the DMA reception */
    ETH->DMAOMR |= ETH_DMAOMR_SR;  
 80128e0:	f241 0218 	movw	r2, #4120	; 0x1018
 80128e4:	4905      	ldr	r1, [pc, #20]	; (80128fc <ETH_DMAReceptionCmd+0x1c>)
 80128e6:	588b      	ldr	r3, [r1, r2]
void ETH_DMAReceptionCmd(FunctionalState NewState)
{ 
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80128e8:	b918      	cbnz	r0, 80128f2 <ETH_DMAReceptionCmd+0x12>
    ETH->DMAOMR |= ETH_DMAOMR_SR;  
  }
  else
  {
    /* Disable the DMA reception */
    ETH->DMAOMR &= ~ETH_DMAOMR_SR;
 80128ea:	f023 0302 	bic.w	r3, r3, #2
 80128ee:	508b      	str	r3, [r1, r2]
 80128f0:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the DMA reception */
    ETH->DMAOMR |= ETH_DMAOMR_SR;  
 80128f2:	f043 0302 	orr.w	r3, r3, #2
 80128f6:	508b      	str	r3, [r1, r2]
 80128f8:	4770      	bx	lr
 80128fa:	bf00      	nop
 80128fc:	40028000 	.word	0x40028000

08012900 <ETH_GetDMAOverflowStatus>:
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ETH_DMA_GET_OVERFLOW(ETH_DMA_Overflow));
  
  if ((ETH->DMAMFBOCR & ETH_DMA_Overflow) != (uint32_t)RESET)
 8012900:	4b03      	ldr	r3, [pc, #12]	; (8012910 <ETH_GetDMAOverflowStatus+0x10>)
 8012902:	681b      	ldr	r3, [r3, #0]
  }
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
 8012904:	4203      	tst	r3, r0
}
 8012906:	bf14      	ite	ne
 8012908:	2001      	movne	r0, #1
 801290a:	2000      	moveq	r0, #0
 801290c:	4770      	bx	lr
 801290e:	bf00      	nop
 8012910:	40029020 	.word	0x40029020

08012914 <ETH_GetRxOverflowMissedFrameCounter>:
  * @param  None
  * @retval The value of Rx overflow Missed Frame Counter.
  */
uint32_t ETH_GetRxOverflowMissedFrameCounter(void)
{
  return ((uint32_t)((ETH->DMAMFBOCR & ETH_DMAMFBOCR_MFA)>>ETH_DMA_RX_OVERFLOW_MISSEDFRAMES_COUNTERSHIFT));
 8012914:	4b02      	ldr	r3, [pc, #8]	; (8012920 <ETH_GetRxOverflowMissedFrameCounter+0xc>)
 8012916:	6818      	ldr	r0, [r3, #0]
}
 8012918:	f3c0 404a 	ubfx	r0, r0, #17, #11
 801291c:	4770      	bx	lr
 801291e:	bf00      	nop
 8012920:	40029020 	.word	0x40029020

08012924 <ETH_GetBufferUnavailableMissedFrameCounter>:
  * @param  None
  * @retval The value of Buffer unavailable Missed Frame Counter.
  */
uint32_t ETH_GetBufferUnavailableMissedFrameCounter(void)
{
  return ((uint32_t)(ETH->DMAMFBOCR) & ETH_DMAMFBOCR_MFC);
 8012924:	4b01      	ldr	r3, [pc, #4]	; (801292c <ETH_GetBufferUnavailableMissedFrameCounter+0x8>)
 8012926:	6818      	ldr	r0, [r3, #0]
}
 8012928:	b280      	uxth	r0, r0
 801292a:	4770      	bx	lr
 801292c:	40029020 	.word	0x40029020

08012930 <ETH_GetCurrentTxDescStartAddress>:
  * @param  None
  * @retval The value of the current Tx desc start address.
  */
uint32_t ETH_GetCurrentTxDescStartAddress(void)
{
  return ((uint32_t)(ETH->DMACHTDR));
 8012930:	f241 0348 	movw	r3, #4168	; 0x1048
 8012934:	4a01      	ldr	r2, [pc, #4]	; (801293c <ETH_GetCurrentTxDescStartAddress+0xc>)
 8012936:	58d0      	ldr	r0, [r2, r3]
}
 8012938:	4770      	bx	lr
 801293a:	bf00      	nop
 801293c:	40028000 	.word	0x40028000

08012940 <ETH_GetCurrentRxDescStartAddress>:
  * @param  None
  * @retval The value of the current Rx desc start address.
  */
uint32_t ETH_GetCurrentRxDescStartAddress(void)
{
  return ((uint32_t)(ETH->DMACHRDR));
 8012940:	f241 034c 	movw	r3, #4172	; 0x104c
 8012944:	4a01      	ldr	r2, [pc, #4]	; (801294c <ETH_GetCurrentRxDescStartAddress+0xc>)
 8012946:	58d0      	ldr	r0, [r2, r3]
}
 8012948:	4770      	bx	lr
 801294a:	bf00      	nop
 801294c:	40028000 	.word	0x40028000

08012950 <ETH_GetCurrentTxBufferAddress>:
  * @param  None
  * @retval The value of the current transmit descriptor data buffer address.
  */
uint32_t ETH_GetCurrentTxBufferAddress(void)
{
  return ((uint32_t)(ETH->DMACHTBAR));
 8012950:	f241 0350 	movw	r3, #4176	; 0x1050
 8012954:	4a01      	ldr	r2, [pc, #4]	; (801295c <ETH_GetCurrentTxBufferAddress+0xc>)
 8012956:	58d0      	ldr	r0, [r2, r3]
}
 8012958:	4770      	bx	lr
 801295a:	bf00      	nop
 801295c:	40028000 	.word	0x40028000

08012960 <ETH_GetCurrentRxBufferAddress>:
  * @param  None
  * @retval The value of the current receive descriptor data buffer address.
  */
uint32_t ETH_GetCurrentRxBufferAddress(void)
{
  return ((uint32_t)(ETH->DMACHRBAR));
 8012960:	f241 0354 	movw	r3, #4180	; 0x1054
 8012964:	4a01      	ldr	r2, [pc, #4]	; (801296c <ETH_GetCurrentRxBufferAddress+0xc>)
 8012966:	58d0      	ldr	r0, [r2, r3]
}
 8012968:	4770      	bx	lr
 801296a:	bf00      	nop
 801296c:	40028000 	.word	0x40028000

08012970 <ETH_ResumeDMATransmission>:
  * @param  None
  * @retval None.
  */
void ETH_ResumeDMATransmission(void)
{
  ETH->DMATPDR = 0;
 8012970:	f241 0304 	movw	r3, #4100	; 0x1004
 8012974:	4a01      	ldr	r2, [pc, #4]	; (801297c <ETH_ResumeDMATransmission+0xc>)
 8012976:	2100      	movs	r1, #0
 8012978:	50d1      	str	r1, [r2, r3]
 801297a:	4770      	bx	lr
 801297c:	40028000 	.word	0x40028000

08012980 <ETH_ResumeDMAReception>:
  * @param  None
  * @retval None.
  */
void ETH_ResumeDMAReception(void)
{
  ETH->DMARPDR = 0;
 8012980:	f241 0308 	movw	r3, #4104	; 0x1008
 8012984:	4a01      	ldr	r2, [pc, #4]	; (801298c <ETH_ResumeDMAReception+0xc>)
 8012986:	2100      	movs	r1, #0
 8012988:	50d1      	str	r1, [r2, r3]
 801298a:	4770      	bx	lr
 801298c:	40028000 	.word	0x40028000

08012990 <ETH_SetReceiveWatchdogTimer>:
  * @retval None
  */
void ETH_SetReceiveWatchdogTimer(uint8_t Value)
{
  /* Set the DMA Receive status watchdog timer register */
  ETH->DMARSWTR = Value;
 8012990:	f241 0324 	movw	r3, #4132	; 0x1024
 8012994:	4a01      	ldr	r2, [pc, #4]	; (801299c <ETH_SetReceiveWatchdogTimer+0xc>)
 8012996:	50d0      	str	r0, [r2, r3]
 8012998:	4770      	bx	lr
 801299a:	bf00      	nop
 801299c:	40028000 	.word	0x40028000

080129a0 <ETH_ReadPHYRegister>:
  *     @arg More PHY register could be read depending on the used PHY
  * @retval ETH_ERROR: in case of timeout
  *         MAC MIIDR register value: Data read from the selected PHY register (correct read )
  */
uint16_t ETH_ReadPHYRegister(uint16_t PHYAddress, uint16_t PHYReg)
{
 80129a0:	b430      	push	{r4, r5}
  uint32_t tmpreg = 0;     
__IO uint32_t timeout = 0;
 80129a2:	2300      	movs	r3, #0
  /* Check the parameters */
  assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
  assert_param(IS_ETH_PHY_REG(PHYReg));
  
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
 80129a4:	4d13      	ldr	r5, [pc, #76]	; (80129f4 <ETH_ReadPHYRegister+0x54>)
  *     @arg More PHY register could be read depending on the used PHY
  * @retval ETH_ERROR: in case of timeout
  *         MAC MIIDR register value: Data read from the selected PHY register (correct read )
  */
uint16_t ETH_ReadPHYRegister(uint16_t PHYAddress, uint16_t PHYReg)
{
 80129a6:	b082      	sub	sp, #8
  uint32_t tmpreg = 0;     
__IO uint32_t timeout = 0;
 80129a8:	9301      	str	r3, [sp, #4]
  /* Check the parameters */
  assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
  assert_param(IS_ETH_PHY_REG(PHYReg));
  
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
 80129aa:	692b      	ldr	r3, [r5, #16]
 80129ac:	0189      	lsls	r1, r1, #6
 80129ae:	f401 61f8 	and.w	r1, r1, #1984	; 0x7c0
  /* Keep only the CSR Clock Range CR[2:0] bits value */
  tmpreg &= ~MACMIIAR_CR_MASK;
  /* Prepare the MII address register value */
  tmpreg |=(((uint32_t)PHYAddress<<11) & ETH_MACMIIAR_PA); /* Set the PHY device address */
  tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);      /* Set the PHY register address */
 80129b2:	02c0      	lsls	r0, r0, #11
 80129b4:	f003 041c 	and.w	r4, r3, #28
 80129b8:	ea41 0304 	orr.w	r3, r1, r4
 80129bc:	b280      	uxth	r0, r0
  tmpreg &= ~ETH_MACMIIAR_MW;                              /* Set the read mode */
 80129be:	4303      	orrs	r3, r0
  tmpreg |= ETH_MACMIIAR_MB;                               /* Set the MII Busy bit */
 80129c0:	f043 0301 	orr.w	r3, r3, #1
  ETH->MACMIIAR = tmpreg;
  /* Check for the Busy flag */
  do
  {
    timeout++;
    tmpreg = ETH->MACMIIAR;
 80129c4:	462a      	mov	r2, r5
  } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_READ_TO));
 80129c6:	490c      	ldr	r1, [pc, #48]	; (80129f8 <ETH_ReadPHYRegister+0x58>)
  tmpreg |=(((uint32_t)PHYAddress<<11) & ETH_MACMIIAR_PA); /* Set the PHY device address */
  tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);      /* Set the PHY register address */
  tmpreg &= ~ETH_MACMIIAR_MW;                              /* Set the read mode */
  tmpreg |= ETH_MACMIIAR_MB;                               /* Set the MII Busy bit */
  /* Write the result value into the MII Address register */
  ETH->MACMIIAR = tmpreg;
 80129c8:	612b      	str	r3, [r5, #16]
 80129ca:	e002      	b.n	80129d2 <ETH_ReadPHYRegister+0x32>
  /* Check for the Busy flag */
  do
  {
    timeout++;
    tmpreg = ETH->MACMIIAR;
  } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_READ_TO));
 80129cc:	9b01      	ldr	r3, [sp, #4]
 80129ce:	428b      	cmp	r3, r1
 80129d0:	d805      	bhi.n	80129de <ETH_ReadPHYRegister+0x3e>
  /* Write the result value into the MII Address register */
  ETH->MACMIIAR = tmpreg;
  /* Check for the Busy flag */
  do
  {
    timeout++;
 80129d2:	9b01      	ldr	r3, [sp, #4]
 80129d4:	3301      	adds	r3, #1
 80129d6:	9301      	str	r3, [sp, #4]
    tmpreg = ETH->MACMIIAR;
 80129d8:	6913      	ldr	r3, [r2, #16]
  } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_READ_TO));
 80129da:	07db      	lsls	r3, r3, #31
 80129dc:	d4f6      	bmi.n	80129cc <ETH_ReadPHYRegister+0x2c>
  /* Return ERROR in case of timeout */
  if(timeout == PHY_READ_TO)
 80129de:	4b07      	ldr	r3, [pc, #28]	; (80129fc <ETH_ReadPHYRegister+0x5c>)
 80129e0:	9a01      	ldr	r2, [sp, #4]
 80129e2:	429a      	cmp	r2, r3
  {
    return (uint16_t)ETH_ERROR;
  }
  //DUG_PRINTF("\n\r PHYAddress 0x%X, PHYReg 0x%X is 0x%X;",PHYAddress, PHYReg, ETH->MACMIIDR);
  /* Return data register value */
  return (uint16_t)(ETH->MACMIIDR);
 80129e4:	bf17      	itett	ne
 80129e6:	4b03      	ldrne	r3, [pc, #12]	; (80129f4 <ETH_ReadPHYRegister+0x54>)
    tmpreg = ETH->MACMIIAR;
  } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_READ_TO));
  /* Return ERROR in case of timeout */
  if(timeout == PHY_READ_TO)
  {
    return (uint16_t)ETH_ERROR;
 80129e8:	2000      	moveq	r0, #0
  }
  //DUG_PRINTF("\n\r PHYAddress 0x%X, PHYReg 0x%X is 0x%X;",PHYAddress, PHYReg, ETH->MACMIIDR);
  /* Return data register value */
  return (uint16_t)(ETH->MACMIIDR);
 80129ea:	6958      	ldrne	r0, [r3, #20]
 80129ec:	b280      	uxthne	r0, r0
}
 80129ee:	b002      	add	sp, #8
 80129f0:	bc30      	pop	{r4, r5}
 80129f2:	4770      	bx	lr
 80129f4:	40028000 	.word	0x40028000
 80129f8:	0004fffe 	.word	0x0004fffe
 80129fc:	0004ffff 	.word	0x0004ffff

08012a00 <ETH_WritePHYRegister>:
  * @param  PHYValue: the value to write
  * @retval ETH_ERROR: in case of timeout
  *         ETH_SUCCESS: for correct write
  */
uint32_t ETH_WritePHYRegister(uint16_t PHYAddress, uint16_t PHYReg, uint16_t PHYValue)
{
 8012a00:	b430      	push	{r4, r5}
  uint32_t tmpreg = 0;     
  __IO uint32_t timeout = 0;
 8012a02:	2300      	movs	r3, #0
  assert_param(IS_ETH_PHY_REG(PHYReg));

  //DUG_PRINTF("\n\r Armjishu WritePHYRegister PHYReg 0x%X is 0x%X;", PHYReg, PHYValue);
  
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
 8012a04:	4d12      	ldr	r5, [pc, #72]	; (8012a50 <ETH_WritePHYRegister+0x50>)
  * @param  PHYValue: the value to write
  * @retval ETH_ERROR: in case of timeout
  *         ETH_SUCCESS: for correct write
  */
uint32_t ETH_WritePHYRegister(uint16_t PHYAddress, uint16_t PHYReg, uint16_t PHYValue)
{
 8012a06:	b082      	sub	sp, #8
  uint32_t tmpreg = 0;     
  __IO uint32_t timeout = 0;
 8012a08:	9301      	str	r3, [sp, #4]
  assert_param(IS_ETH_PHY_REG(PHYReg));

  //DUG_PRINTF("\n\r Armjishu WritePHYRegister PHYReg 0x%X is 0x%X;", PHYReg, PHYValue);
  
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
 8012a0a:	692b      	ldr	r3, [r5, #16]
 8012a0c:	0189      	lsls	r1, r1, #6
 8012a0e:	f003 031c 	and.w	r3, r3, #28
 8012a12:	f401 61f8 	and.w	r1, r1, #1984	; 0x7c0
  tmpreg &= ~MACMIIAR_CR_MASK;
  /* Prepare the MII register address value */
  tmpreg |=(((uint32_t)PHYAddress<<11) & ETH_MACMIIAR_PA); /* Set the PHY device address */
  tmpreg |=(((uint32_t)PHYReg<<6) & ETH_MACMIIAR_MR);      /* Set the PHY register address */
  tmpreg |= ETH_MACMIIAR_MW;                               /* Set the write mode */
  tmpreg |= ETH_MACMIIAR_MB;                               /* Set the MII Busy bit */
 8012a16:	02c0      	lsls	r0, r0, #11
 8012a18:	f043 0303 	orr.w	r3, r3, #3
 8012a1c:	4319      	orrs	r1, r3
 8012a1e:	b280      	uxth	r0, r0
 8012a20:	4308      	orrs	r0, r1
  /* Give the value to the MII data register */
  ETH->MACMIIDR = PHYValue;
 8012a22:	616a      	str	r2, [r5, #20]
  ETH->MACMIIAR = tmpreg;
  /* Check for the Busy flag */
  do
  {
    timeout++;
    tmpreg = ETH->MACMIIAR;
 8012a24:	462c      	mov	r4, r5
  } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_WRITE_TO));
 8012a26:	490b      	ldr	r1, [pc, #44]	; (8012a54 <ETH_WritePHYRegister+0x54>)
  tmpreg |= ETH_MACMIIAR_MW;                               /* Set the write mode */
  tmpreg |= ETH_MACMIIAR_MB;                               /* Set the MII Busy bit */
  /* Give the value to the MII data register */
  ETH->MACMIIDR = PHYValue;
  /* Write the result value into the MII Address register */
  ETH->MACMIIAR = tmpreg;
 8012a28:	6128      	str	r0, [r5, #16]
 8012a2a:	e002      	b.n	8012a32 <ETH_WritePHYRegister+0x32>
  /* Check for the Busy flag */
  do
  {
    timeout++;
    tmpreg = ETH->MACMIIAR;
  } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_WRITE_TO));
 8012a2c:	9b01      	ldr	r3, [sp, #4]
 8012a2e:	428b      	cmp	r3, r1
 8012a30:	d805      	bhi.n	8012a3e <ETH_WritePHYRegister+0x3e>
  /* Write the result value into the MII Address register */
  ETH->MACMIIAR = tmpreg;
  /* Check for the Busy flag */
  do
  {
    timeout++;
 8012a32:	9b01      	ldr	r3, [sp, #4]
 8012a34:	3301      	adds	r3, #1
 8012a36:	9301      	str	r3, [sp, #4]
    tmpreg = ETH->MACMIIAR;
 8012a38:	6923      	ldr	r3, [r4, #16]
  } while ((tmpreg & ETH_MACMIIAR_MB) && (timeout < (uint32_t)PHY_WRITE_TO));
 8012a3a:	07db      	lsls	r3, r3, #31
 8012a3c:	d4f6      	bmi.n	8012a2c <ETH_WritePHYRegister+0x2c>
  /* Return ERROR in case of timeout */
  if(timeout == PHY_WRITE_TO)
 8012a3e:	9801      	ldr	r0, [sp, #4]
 8012a40:	4b05      	ldr	r3, [pc, #20]	; (8012a58 <ETH_WritePHYRegister+0x58>)
    return ETH_ERROR;
  }
  
  /* Return SUCCESS */
  return ETH_SUCCESS;  
}
 8012a42:	1ac0      	subs	r0, r0, r3
 8012a44:	bf18      	it	ne
 8012a46:	2001      	movne	r0, #1
 8012a48:	b002      	add	sp, #8
 8012a4a:	bc30      	pop	{r4, r5}
 8012a4c:	4770      	bx	lr
 8012a4e:	bf00      	nop
 8012a50:	40028000 	.word	0x40028000
 8012a54:	0004fffe 	.word	0x0004fffe
 8012a58:	0004ffff 	.word	0x0004ffff

08012a5c <ETH_Init>:
  * @param PHYAddress: external PHY address                    
  * @retval ETH_ERROR: Ethernet initialization failed
  *         ETH_SUCCESS: Ethernet successfully initialized                 
  */
uint32_t ETH_Init(ETH_InitTypeDef* ETH_InitStruct, uint16_t PHYAddress)
{
 8012a5c:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t RegValue = 0, tmpreg = 0;
  __IO uint32_t i = 0;
 8012a5e:	2300      	movs	r3, #0
  * @param PHYAddress: external PHY address                    
  * @retval ETH_ERROR: Ethernet initialization failed
  *         ETH_SUCCESS: Ethernet successfully initialized                 
  */
uint32_t ETH_Init(ETH_InitTypeDef* ETH_InitStruct, uint16_t PHYAddress)
{
 8012a60:	b089      	sub	sp, #36	; 0x24
  assert_param(IS_ETH_DMA_DESC_SKIP_LENGTH(ETH_InitStruct->ETH_DescriptorSkipLength));  
  assert_param(IS_ETH_DMA_ARBITRATION_ROUNDROBIN_RXTX(ETH_InitStruct->ETH_DMAArbitration));       
  /*-------------------------------- MAC Config ------------------------------*/   
  /*---------------------- ETHERNET MACMIIAR Configuration -------------------*/
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
 8012a62:	4a92      	ldr	r2, [pc, #584]	; (8012cac <ETH_Init+0x250>)
  *         ETH_SUCCESS: Ethernet successfully initialized                 
  */
uint32_t ETH_Init(ETH_InitTypeDef* ETH_InitStruct, uint16_t PHYAddress)
{
  uint32_t RegValue = 0, tmpreg = 0;
  __IO uint32_t i = 0;
 8012a64:	9300      	str	r3, [sp, #0]
  * @param PHYAddress: external PHY address                    
  * @retval ETH_ERROR: Ethernet initialization failed
  *         ETH_SUCCESS: Ethernet successfully initialized                 
  */
uint32_t ETH_Init(ETH_InitTypeDef* ETH_InitStruct, uint16_t PHYAddress)
{
 8012a66:	4604      	mov	r4, r0
  uint32_t RegValue = 0, tmpreg = 0;
  __IO uint32_t i = 0;
  RCC_ClocksTypeDef  rcc_clocks;
  uint32_t hclk = 60000000;
  __IO uint32_t timeout = 0;
 8012a68:	9301      	str	r3, [sp, #4]
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
  /* Clear CSR Clock Range CR[2:0] bits */
  tmpreg &= MACMIIAR_CR_MASK;
  /* Get hclk frequency value */
  RCC_GetClocksFreq(&rcc_clocks);
 8012a6a:	a804      	add	r0, sp, #16
  assert_param(IS_ETH_DMA_DESC_SKIP_LENGTH(ETH_InitStruct->ETH_DescriptorSkipLength));  
  assert_param(IS_ETH_DMA_ARBITRATION_ROUNDROBIN_RXTX(ETH_InitStruct->ETH_DMAArbitration));       
  /*-------------------------------- MAC Config ------------------------------*/   
  /*---------------------- ETHERNET MACMIIAR Configuration -------------------*/
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
 8012a6c:	6916      	ldr	r6, [r2, #16]
  * @param PHYAddress: external PHY address                    
  * @retval ETH_ERROR: Ethernet initialization failed
  *         ETH_SUCCESS: Ethernet successfully initialized                 
  */
uint32_t ETH_Init(ETH_InitTypeDef* ETH_InitStruct, uint16_t PHYAddress)
{
 8012a6e:	460d      	mov	r5, r1
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
  /* Clear CSR Clock Range CR[2:0] bits */
  tmpreg &= MACMIIAR_CR_MASK;
  /* Get hclk frequency value */
  RCC_GetClocksFreq(&rcc_clocks);
 8012a70:	f7f6 f94c 	bl	8008d0c <RCC_GetClocksFreq>
  hclk = rcc_clocks.HCLK_Frequency;
 8012a74:	9a05      	ldr	r2, [sp, #20]
  /* Set CR bits depending on hclk value */
  if((hclk >= 20000000)&&(hclk < 35000000))
 8012a76:	4b8e      	ldr	r3, [pc, #568]	; (8012cb0 <ETH_Init+0x254>)
 8012a78:	498e      	ldr	r1, [pc, #568]	; (8012cb4 <ETH_Init+0x258>)
 8012a7a:	4413      	add	r3, r2
 8012a7c:	428b      	cmp	r3, r1
  /*-------------------------------- MAC Config ------------------------------*/   
  /*---------------------- ETHERNET MACMIIAR Configuration -------------------*/
  /* Get the ETHERNET MACMIIAR value */
  tmpreg = ETH->MACMIIAR;
  /* Clear CSR Clock Range CR[2:0] bits */
  tmpreg &= MACMIIAR_CR_MASK;
 8012a7e:	f026 061c 	bic.w	r6, r6, #28
  /* Get hclk frequency value */
  RCC_GetClocksFreq(&rcc_clocks);
  hclk = rcc_clocks.HCLK_Frequency;
  /* Set CR bits depending on hclk value */
  if((hclk >= 20000000)&&(hclk < 35000000))
 8012a82:	d860      	bhi.n	8012b46 <ETH_Init+0xea>
  {
    /* CSR Clock Range between 20-35 MHz */
    tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div16;
 8012a84:	f046 0608 	orr.w	r6, r6, #8
    /* CSR Clock Range between 100-120 MHz */ 
    tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div62;    
  }
  
  /* Write to ETHERNET MAC MIIAR: Configure the ETHERNET CSR Clock Range */
  ETH->MACMIIAR = (uint32_t)tmpreg;  
 8012a88:	4b88      	ldr	r3, [pc, #544]	; (8012cac <ETH_Init+0x250>)
  /*-------------------- PHY initialization and configuration ----------------*/
  /* Put the PHY in reset mode */
  if(!(ETH_WritePHYRegister(PHYAddress, PHY_BCR, PHY_Reset)))
 8012a8a:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    /* CSR Clock Range between 100-120 MHz */ 
    tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div62;    
  }
  
  /* Write to ETHERNET MAC MIIAR: Configure the ETHERNET CSR Clock Range */
  ETH->MACMIIAR = (uint32_t)tmpreg;  
 8012a8e:	611e      	str	r6, [r3, #16]
  /*-------------------- PHY initialization and configuration ----------------*/
  /* Put the PHY in reset mode */
  if(!(ETH_WritePHYRegister(PHYAddress, PHY_BCR, PHY_Reset)))
 8012a90:	2100      	movs	r1, #0
 8012a92:	4628      	mov	r0, r5
 8012a94:	f7ff ffb4 	bl	8012a00 <ETH_WritePHYRegister>
 8012a98:	2800      	cmp	r0, #0
 8012a9a:	d051      	beq.n	8012b40 <ETH_Init+0xe4>
 8012a9c:	4b86      	ldr	r3, [pc, #536]	; (8012cb8 <ETH_Init+0x25c>)
  * @param  nCount: specifies the delay time length.
  * @retval None
  */
static void ETH_Delay(__IO uint32_t nCount)
{
  __IO uint32_t index = 0; 
 8012a9e:	2200      	movs	r2, #0
 8012aa0:	9202      	str	r2, [sp, #8]
  for(index = nCount; index != 0; index--)
 8012aa2:	9302      	str	r3, [sp, #8]
 8012aa4:	9b02      	ldr	r3, [sp, #8]
 8012aa6:	b12b      	cbz	r3, 8012ab4 <ETH_Init+0x58>
 8012aa8:	9b02      	ldr	r3, [sp, #8]
 8012aaa:	3b01      	subs	r3, #1
 8012aac:	9302      	str	r3, [sp, #8]
 8012aae:	9b02      	ldr	r3, [sp, #8]
 8012ab0:	2b00      	cmp	r3, #0
 8012ab2:	d1f9      	bne.n	8012aa8 <ETH_Init+0x4c>
  }
  
  /* Delay to assure PHY reset */
  _eth_delay_(PHY_RESET_DELAY);
    
  if(ETH_InitStruct->ETH_AutoNegotiation != ETH_AutoNegotiation_Disable)
 8012ab4:	6826      	ldr	r6, [r4, #0]
 8012ab6:	2e00      	cmp	r6, #0
 8012ab8:	d055      	beq.n	8012b66 <ETH_Init+0x10a>
  {  
    /* We wait for linked status... */
    do
    {
      timeout++;
    } while (!(ETH_ReadPHYRegister(PHYAddress, PHY_BSR) & PHY_Linked_Status) && (timeout < PHY_READ_TO));
 8012aba:	4e80      	ldr	r6, [pc, #512]	; (8012cbc <ETH_Init+0x260>)
 8012abc:	e002      	b.n	8012ac4 <ETH_Init+0x68>
 8012abe:	9b01      	ldr	r3, [sp, #4]
 8012ac0:	42b3      	cmp	r3, r6
 8012ac2:	d808      	bhi.n	8012ad6 <ETH_Init+0x7a>
  if(ETH_InitStruct->ETH_AutoNegotiation != ETH_AutoNegotiation_Disable)
  {  
    /* We wait for linked status... */
    do
    {
      timeout++;
 8012ac4:	9b01      	ldr	r3, [sp, #4]
    } while (!(ETH_ReadPHYRegister(PHYAddress, PHY_BSR) & PHY_Linked_Status) && (timeout < PHY_READ_TO));
 8012ac6:	2101      	movs	r1, #1
  if(ETH_InitStruct->ETH_AutoNegotiation != ETH_AutoNegotiation_Disable)
  {  
    /* We wait for linked status... */
    do
    {
      timeout++;
 8012ac8:	440b      	add	r3, r1
    } while (!(ETH_ReadPHYRegister(PHYAddress, PHY_BSR) & PHY_Linked_Status) && (timeout < PHY_READ_TO));
 8012aca:	4628      	mov	r0, r5
  if(ETH_InitStruct->ETH_AutoNegotiation != ETH_AutoNegotiation_Disable)
  {  
    /* We wait for linked status... */
    do
    {
      timeout++;
 8012acc:	9301      	str	r3, [sp, #4]
    } while (!(ETH_ReadPHYRegister(PHYAddress, PHY_BSR) & PHY_Linked_Status) && (timeout < PHY_READ_TO));
 8012ace:	f7ff ff67 	bl	80129a0 <ETH_ReadPHYRegister>
 8012ad2:	0741      	lsls	r1, r0, #29
 8012ad4:	d5f3      	bpl.n	8012abe <ETH_Init+0x62>

    /* Return ERROR in case of timeout */
    if(timeout == PHY_READ_TO)
 8012ad6:	9a01      	ldr	r2, [sp, #4]
 8012ad8:	4b79      	ldr	r3, [pc, #484]	; (8012cc0 <ETH_Init+0x264>)
 8012ada:	429a      	cmp	r2, r3
 8012adc:	d030      	beq.n	8012b40 <ETH_Init+0xe4>
    {
      return ETH_ERROR;
    }

    /* Reset Timeout counter */
    timeout = 0; 
 8012ade:	2300      	movs	r3, #0
    /* Enable Auto-Negotiation */
    if(!(ETH_WritePHYRegister(PHYAddress, PHY_BCR, PHY_AutoNegotiation)))
 8012ae0:	4619      	mov	r1, r3
 8012ae2:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8012ae6:	4628      	mov	r0, r5
    {
      return ETH_ERROR;
    }

    /* Reset Timeout counter */
    timeout = 0; 
 8012ae8:	9301      	str	r3, [sp, #4]
    /* Enable Auto-Negotiation */
    if(!(ETH_WritePHYRegister(PHYAddress, PHY_BCR, PHY_AutoNegotiation)))
 8012aea:	f7ff ff89 	bl	8012a00 <ETH_WritePHYRegister>
 8012aee:	b338      	cbz	r0, 8012b40 <ETH_Init+0xe4>

    /* Wait until the auto-negotiation will be completed */
    do
    {
      timeout++;
    } while (!(ETH_ReadPHYRegister(PHYAddress, PHY_BSR) & PHY_AutoNego_Complete) && (timeout < (uint32_t)PHY_READ_TO));  
 8012af0:	4e72      	ldr	r6, [pc, #456]	; (8012cbc <ETH_Init+0x260>)
 8012af2:	e002      	b.n	8012afa <ETH_Init+0x9e>
 8012af4:	9b01      	ldr	r3, [sp, #4]
 8012af6:	42b3      	cmp	r3, r6
 8012af8:	d808      	bhi.n	8012b0c <ETH_Init+0xb0>
    }

    /* Wait until the auto-negotiation will be completed */
    do
    {
      timeout++;
 8012afa:	9b01      	ldr	r3, [sp, #4]
    } while (!(ETH_ReadPHYRegister(PHYAddress, PHY_BSR) & PHY_AutoNego_Complete) && (timeout < (uint32_t)PHY_READ_TO));  
 8012afc:	2101      	movs	r1, #1
    }

    /* Wait until the auto-negotiation will be completed */
    do
    {
      timeout++;
 8012afe:	440b      	add	r3, r1
    } while (!(ETH_ReadPHYRegister(PHYAddress, PHY_BSR) & PHY_AutoNego_Complete) && (timeout < (uint32_t)PHY_READ_TO));  
 8012b00:	4628      	mov	r0, r5
    }

    /* Wait until the auto-negotiation will be completed */
    do
    {
      timeout++;
 8012b02:	9301      	str	r3, [sp, #4]
    } while (!(ETH_ReadPHYRegister(PHYAddress, PHY_BSR) & PHY_AutoNego_Complete) && (timeout < (uint32_t)PHY_READ_TO));  
 8012b04:	f7ff ff4c 	bl	80129a0 <ETH_ReadPHYRegister>
 8012b08:	0682      	lsls	r2, r0, #26
 8012b0a:	d5f3      	bpl.n	8012af4 <ETH_Init+0x98>

    /* Return ERROR in case of timeout */
    if(timeout == PHY_READ_TO)
 8012b0c:	9a01      	ldr	r2, [sp, #4]
 8012b0e:	4b6c      	ldr	r3, [pc, #432]	; (8012cc0 <ETH_Init+0x264>)
 8012b10:	429a      	cmp	r2, r3
 8012b12:	d015      	beq.n	8012b40 <ETH_Init+0xe4>
    {
      return ETH_ERROR;
    }

    /* Reset Timeout counter */
    timeout = 0;
 8012b14:	2300      	movs	r3, #0
    
    /* Read the result of the auto-negotiation */
    RegValue = ETH_ReadPHYRegister(PHYAddress, PHY_SR);
 8012b16:	4628      	mov	r0, r5
 8012b18:	2110      	movs	r1, #16
    {
      return ETH_ERROR;
    }

    /* Reset Timeout counter */
    timeout = 0;
 8012b1a:	9301      	str	r3, [sp, #4]
    
    /* Read the result of the auto-negotiation */
    RegValue = ETH_ReadPHYRegister(PHYAddress, PHY_SR);
 8012b1c:	f7ff ff40 	bl	80129a0 <ETH_ReadPHYRegister>
  
    /* Configure the MAC with the Duplex Mode fixed by the auto-negotiation process */
    if((RegValue & PHY_DUPLEX_STATUS) != (uint32_t)RESET)
 8012b20:	f000 0304 	and.w	r3, r0, #4
 8012b24:	b29b      	uxth	r3, r3
 8012b26:	2b00      	cmp	r3, #0
 8012b28:	f000 80bd 	beq.w	8012ca6 <ETH_Init+0x24a>
    {
      /* Set Ethernet duplex mode to Full-duplex following the auto-negotiation */
      ETH_InitStruct->ETH_Mode = ETH_Mode_FullDuplex;  
 8012b2c:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8012b30:	6223      	str	r3, [r4, #32]
      /* Set Ethernet duplex mode to Half-duplex following the auto-negotiation */
      ETH_InitStruct->ETH_Mode = ETH_Mode_HalfDuplex;           
    }

    /* Configure the MAC with the speed fixed by the auto-negotiation process */
    if(RegValue & PHY_SPEED_STATUS)
 8012b32:	0783      	lsls	r3, r0, #30
    {  
      /* Set Ethernet speed to 10M following the auto-negotiation */    
      ETH_InitStruct->ETH_Speed = ETH_Speed_10M; 
 8012b34:	bf4c      	ite	mi
 8012b36:	2000      	movmi	r0, #0
    }
    else
    {   
      /* Set Ethernet speed to 100M following the auto-negotiation */ 
      ETH_InitStruct->ETH_Speed = ETH_Speed_100M;      
 8012b38:	f44f 4080 	movpl.w	r0, #16384	; 0x4000
 8012b3c:	6160      	str	r0, [r4, #20]
 8012b3e:	e02b      	b.n	8012b98 <ETH_Init+0x13c>
  /*-------------------- PHY initialization and configuration ----------------*/
  /* Put the PHY in reset mode */
  if(!(ETH_WritePHYRegister(PHYAddress, PHY_BCR, PHY_Reset)))
  {
    /* Return ERROR in case of write timeout */
    return ETH_ERROR;
 8012b40:	2000      	movs	r0, #0
    ETH->DMABMR |= ETH_DMABMR_EDE;
  #endif /* USE_ENHANCED_DMA_DESCRIPTORS */
                              
  /* Return Ethernet configuration success */
  return ETH_SUCCESS;
}
 8012b42:	b009      	add	sp, #36	; 0x24
 8012b44:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if((hclk >= 20000000)&&(hclk < 35000000))
  {
    /* CSR Clock Range between 20-35 MHz */
    tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div16;
  }
  else if((hclk >= 35000000)&&(hclk < 60000000))
 8012b46:	4b5f      	ldr	r3, [pc, #380]	; (8012cc4 <ETH_Init+0x268>)
 8012b48:	495f      	ldr	r1, [pc, #380]	; (8012cc8 <ETH_Init+0x26c>)
 8012b4a:	4413      	add	r3, r2
 8012b4c:	428b      	cmp	r3, r1
 8012b4e:	d802      	bhi.n	8012b56 <ETH_Init+0xfa>
  {
    /* CSR Clock Range between 35-60 MHz */ 
    tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div26;    
 8012b50:	f046 060c 	orr.w	r6, r6, #12
 8012b54:	e798      	b.n	8012a88 <ETH_Init+0x2c>
  }  
  else if((hclk >= 60000000)&&(hclk < 100000000))
 8012b56:	4b5d      	ldr	r3, [pc, #372]	; (8012ccc <ETH_Init+0x270>)
 8012b58:	495d      	ldr	r1, [pc, #372]	; (8012cd0 <ETH_Init+0x274>)
 8012b5a:	4413      	add	r3, r2
 8012b5c:	428b      	cmp	r3, r1
    tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div42;    
  }  
  else /* ((hclk >= 100000000)&&(hclk <= 120000000)) */
  {
    /* CSR Clock Range between 100-120 MHz */ 
    tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div62;    
 8012b5e:	bf88      	it	hi
 8012b60:	f046 0604 	orrhi.w	r6, r6, #4
 8012b64:	e790      	b.n	8012a88 <ETH_Init+0x2c>
      ETH_InitStruct->ETH_Speed = ETH_Speed_100M;      
    }    
  }
  else
  {
    if(!ETH_WritePHYRegister(PHYAddress, PHY_BCR, ((uint16_t)(ETH_InitStruct->ETH_Mode >> 3) |
 8012b66:	6963      	ldr	r3, [r4, #20]
 8012b68:	6a22      	ldr	r2, [r4, #32]
 8012b6a:	085b      	lsrs	r3, r3, #1
 8012b6c:	ea43 02d2 	orr.w	r2, r3, r2, lsr #3
 8012b70:	4628      	mov	r0, r5
 8012b72:	b292      	uxth	r2, r2
 8012b74:	4631      	mov	r1, r6
 8012b76:	f7ff ff43 	bl	8012a00 <ETH_WritePHYRegister>
 8012b7a:	2800      	cmp	r0, #0
 8012b7c:	d0e0      	beq.n	8012b40 <ETH_Init+0xe4>
 8012b7e:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
  * @param  nCount: specifies the delay time length.
  * @retval None
  */
static void ETH_Delay(__IO uint32_t nCount)
{
  __IO uint32_t index = 0; 
 8012b82:	9603      	str	r6, [sp, #12]
  for(index = nCount; index != 0; index--)
 8012b84:	9303      	str	r3, [sp, #12]
 8012b86:	9b03      	ldr	r3, [sp, #12]
 8012b88:	b12b      	cbz	r3, 8012b96 <ETH_Init+0x13a>
 8012b8a:	9b03      	ldr	r3, [sp, #12]
 8012b8c:	3b01      	subs	r3, #1
 8012b8e:	9303      	str	r3, [sp, #12]
 8012b90:	9b03      	ldr	r3, [sp, #12]
 8012b92:	2b00      	cmp	r3, #0
 8012b94:	d1f9      	bne.n	8012b8a <ETH_Init+0x12e>
 8012b96:	6960      	ldr	r0, [r4, #20]
 8012b98:	68a3      	ldr	r3, [r4, #8]
 8012b9a:	6866      	ldr	r6, [r4, #4]
 8012b9c:	68e2      	ldr	r2, [r4, #12]
 8012b9e:	431e      	orrs	r6, r3
 8012ba0:	6923      	ldr	r3, [r4, #16]
 8012ba2:	4316      	orrs	r6, r2
 8012ba4:	69a2      	ldr	r2, [r4, #24]
 8012ba6:	431e      	orrs	r6, r3
 8012ba8:	69e3      	ldr	r3, [r4, #28]
 8012baa:	6a21      	ldr	r1, [r4, #32]
 8012bac:	4316      	orrs	r6, r2
 8012bae:	431e      	orrs	r6, r3
 8012bb0:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8012bb2:	430e      	orrs	r6, r1
 8012bb4:	f64f 7241 	movw	r2, #65345	; 0xff41
 8012bb8:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8012bba:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
 8012bbc:	431e      	orrs	r6, r3
 8012bbe:	430e      	orrs	r6, r1
    _eth_delay_(PHY_CONFIG_DELAY);
    
  }
  /*------------------------ ETHERNET MACCR Configuration --------------------*/
  /* Get the ETHERNET MACCR value */  
  tmpreg = ETH->MACCR;
 8012bc0:	4b3a      	ldr	r3, [pc, #232]	; (8012cac <ETH_Init+0x250>)
 8012bc2:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8012bc4:	432e      	orrs	r6, r5
 8012bc6:	681f      	ldr	r7, [r3, #0]
 8012bc8:	6b65      	ldr	r5, [r4, #52]	; 0x34
 8012bca:	430e      	orrs	r6, r1
 8012bcc:	4941      	ldr	r1, [pc, #260]	; (8012cd4 <ETH_Init+0x278>)
 8012bce:	4335      	orrs	r5, r6
 8012bd0:	4039      	ands	r1, r7
 8012bd2:	4329      	orrs	r1, r5
  /* Set the IPCO bit according to ETH_ChecksumOffload value */                   
  /* Set the DR bit according to ETH_RetryTransmission value */ 
  /* Set the ACS bit according to ETH_AutomaticPadCRCStrip value */ 
  /* Set the BL bit according to ETH_BackOffLimit value */ 
  /* Set the DC bit according to ETH_DeferralCheck value */                          
  tmpreg |= (uint32_t)(ETH_InitStruct->ETH_Watchdog | 
 8012bd4:	4301      	orrs	r1, r0
                  ETH_InitStruct->ETH_RetryTransmission | 
                  ETH_InitStruct->ETH_AutomaticPadCRCStrip | 
                  ETH_InitStruct->ETH_BackOffLimit | 
                  ETH_InitStruct->ETH_DeferralCheck);
  /* Write to ETHERNET MACCR */
  ETH->MACCR = (uint32_t)tmpreg;
 8012bd6:	6019      	str	r1, [r3, #0]
                          ETH_InitStruct->ETH_SourceAddrFilter |
                          ETH_InitStruct->ETH_PassControlFrames |
                          ETH_InitStruct->ETH_BroadcastFramesReception | 
                          ETH_InitStruct->ETH_DestinationAddrFilter |
                          ETH_InitStruct->ETH_PromiscuousMode |
                          ETH_InitStruct->ETH_MulticastFramesFilter |
 8012bd8:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8012bda:	6ba5      	ldr	r5, [r4, #56]	; 0x38
 8012bdc:	6c20      	ldr	r0, [r4, #64]	; 0x40
 8012bde:	430d      	orrs	r5, r1
 8012be0:	6c61      	ldr	r1, [r4, #68]	; 0x44
 8012be2:	4305      	orrs	r5, r0
 8012be4:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 8012be6:	430d      	orrs	r5, r1
 8012be8:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
 8012bea:	4305      	orrs	r5, r0
 8012bec:	6d20      	ldr	r0, [r4, #80]	; 0x50
                             ETH_InitStruct->ETH_VLANTagIdentifier); 
       
  /*-------------------------------- DMA Config ------------------------------*/
  /*----------------------- ETHERNET DMAOMR Configuration --------------------*/
  /* Get the ETHERNET DMAOMR value */  
  tmpreg = ETH->DMAOMR;
 8012bee:	f241 0618 	movw	r6, #4120	; 0x1018
                          ETH_InitStruct->ETH_SourceAddrFilter |
                          ETH_InitStruct->ETH_PassControlFrames |
                          ETH_InitStruct->ETH_BroadcastFramesReception | 
                          ETH_InitStruct->ETH_DestinationAddrFilter |
                          ETH_InitStruct->ETH_PromiscuousMode |
                          ETH_InitStruct->ETH_MulticastFramesFilter |
 8012bf2:	430d      	orrs	r5, r1
 8012bf4:	6d61      	ldr	r1, [r4, #84]	; 0x54
 8012bf6:	4328      	orrs	r0, r5
 8012bf8:	4301      	orrs	r1, r0
  /* Set the DAIF bit according to ETH_DestinationAddrFilter value */
  /* Set the PR bit according to ETH_PromiscuousMode value */
  /* Set the PM, HMC and HPF bits according to ETH_MulticastFramesFilter value */
  /* Set the HUC and HPF bits according to ETH_UnicastFramesFilter value */
  /* Write to ETHERNET MACFFR */  
  ETH->MACFFR = (uint32_t)(ETH_InitStruct->ETH_ReceiveAll | 
 8012bfa:	6059      	str	r1, [r3, #4]
                          ETH_InitStruct->ETH_PromiscuousMode |
                          ETH_InitStruct->ETH_MulticastFramesFilter |
                          ETH_InitStruct->ETH_UnicastFramesFilter); 
  /*--------------- ETHERNET MACHTHR and MACHTLR Configuration ---------------*/
  /* Write to ETHERNET MACHTHR */
  ETH->MACHTHR = (uint32_t)ETH_InitStruct->ETH_HashTableHigh;
 8012bfc:	6da0      	ldr	r0, [r4, #88]	; 0x58
  /*-------------------------------- DMA Config ------------------------------*/
  /*----------------------- ETHERNET DMAOMR Configuration --------------------*/
  /* Get the ETHERNET DMAOMR value */  
  tmpreg = ETH->DMAOMR;
  /* Clear xx bits */
  tmpreg &= DMAOMR_CLEAR_MASK;
 8012bfe:	4936      	ldr	r1, [pc, #216]	; (8012cd8 <ETH_Init+0x27c>)
                          ETH_InitStruct->ETH_PromiscuousMode |
                          ETH_InitStruct->ETH_MulticastFramesFilter |
                          ETH_InitStruct->ETH_UnicastFramesFilter); 
  /*--------------- ETHERNET MACHTHR and MACHTLR Configuration ---------------*/
  /* Write to ETHERNET MACHTHR */
  ETH->MACHTHR = (uint32_t)ETH_InitStruct->ETH_HashTableHigh;
 8012c00:	6098      	str	r0, [r3, #8]
  /* Write to ETHERNET MACHTLR */
  ETH->MACHTLR = (uint32_t)ETH_InitStruct->ETH_HashTableLow;
 8012c02:	6de0      	ldr	r0, [r4, #92]	; 0x5c
 8012c04:	60d8      	str	r0, [r3, #12]
 8012c06:	6ea0      	ldr	r0, [r4, #104]	; 0x68
 8012c08:	6e67      	ldr	r7, [r4, #100]	; 0x64
 8012c0a:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
 8012c0c:	4307      	orrs	r7, r0
 8012c0e:	6f20      	ldr	r0, [r4, #112]	; 0x70
 8012c10:	433d      	orrs	r5, r7
 8012c12:	4305      	orrs	r5, r0
  /*----------------------- ETHERNET MACFCR Configuration --------------------*/
  /* Get the ETHERNET MACFCR value */  
  tmpreg = ETH->MACFCR;
 8012c14:	699f      	ldr	r7, [r3, #24]
 8012c16:	6f60      	ldr	r0, [r4, #116]	; 0x74
 8012c18:	403a      	ands	r2, r7
 8012c1a:	4328      	orrs	r0, r5
  /* Set the DZPQ bit according to ETH_ZeroQuantaPause value */
  /* Set the PLT bit according to ETH_PauseLowThreshold value */
  /* Set the UP bit according to ETH_UnicastPauseFrameDetect value */
  /* Set the RFE bit according to ETH_ReceiveFlowControl value */
  /* Set the TFE bit according to ETH_TransmitFlowControl value */  
  tmpreg |= (uint32_t)((ETH_InitStruct->ETH_PauseTime << 16) | 
 8012c1c:	6e25      	ldr	r5, [r4, #96]	; 0x60
 8012c1e:	4302      	orrs	r2, r0
 8012c20:	ea42 4205 	orr.w	r2, r2, r5, lsl #16
                   ETH_InitStruct->ETH_PauseLowThreshold |
                   ETH_InitStruct->ETH_UnicastPauseFrameDetect | 
                   ETH_InitStruct->ETH_ReceiveFlowControl |
                   ETH_InitStruct->ETH_TransmitFlowControl); 
  /* Write to ETHERNET MACFCR */
  ETH->MACFCR = (uint32_t)tmpreg;
 8012c24:	619a      	str	r2, [r3, #24]
  /*----------------------- ETHERNET MACVLANTR Configuration -----------------*/
  /* Set the ETV bit according to ETH_VLANTagComparison value */
  /* Set the VL bit according to ETH_VLANTagIdentifier value */  
  ETH->MACVLANTR = (uint32_t)(ETH_InitStruct->ETH_VLANTagComparison | 
 8012c26:	6fa0      	ldr	r0, [r4, #120]	; 0x78
 8012c28:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
  /* Set the FB bit according to ETH_FixedBurst value */
  /* Set the RPBL and 4*PBL bits according to ETH_RxDMABurstLength value */
  /* Set the PBL and 4*PBL bits according to ETH_TxDMABurstLength value */
  /* Set the DSL bit according to ETH_DesciptorSkipLength value */
  /* Set the PR and DA bits according to ETH_DMAArbitration value */         
  ETH->DMABMR = (uint32_t)(ETH_InitStruct->ETH_AddressAlignedBeats | 
 8012c2a:	4d2c      	ldr	r5, [pc, #176]	; (8012cdc <ETH_Init+0x280>)
  /* Write to ETHERNET MACFCR */
  ETH->MACFCR = (uint32_t)tmpreg;
  /*----------------------- ETHERNET MACVLANTR Configuration -----------------*/
  /* Set the ETV bit according to ETH_VLANTagComparison value */
  /* Set the VL bit according to ETH_VLANTagIdentifier value */  
  ETH->MACVLANTR = (uint32_t)(ETH_InitStruct->ETH_VLANTagComparison | 
 8012c2c:	4302      	orrs	r2, r0
 8012c2e:	61da      	str	r2, [r3, #28]
  /* Set the TTC bit according to ETH_TransmitThresholdControl value */
  /* Set the FEF bit according to ETH_ForwardErrorFrames value */
  /* Set the FUF bit according to ETH_ForwardUndersizedGoodFrames value */
  /* Set the RTC bit according to ETH_ReceiveThresholdControl value */
  /* Set the OSF bit according to ETH_SecondFrameOperate value */
  tmpreg |= (uint32_t)(ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame | 
 8012c30:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
 8012c34:	f8d4 7080 	ldr.w	r7, [r4, #128]	; 0x80
 8012c38:	f8d4 2088 	ldr.w	r2, [r4, #136]	; 0x88
 8012c3c:	4307      	orrs	r7, r0
 8012c3e:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
 8012c42:	4317      	orrs	r7, r2
 8012c44:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
 8012c48:	4307      	orrs	r7, r0
 8012c4a:	f8d4 0094 	ldr.w	r0, [r4, #148]	; 0x94
 8012c4e:	4317      	orrs	r7, r2
 8012c50:	f8d4 2098 	ldr.w	r2, [r4, #152]	; 0x98
 8012c54:	4307      	orrs	r7, r0
 8012c56:	f8d4 009c 	ldr.w	r0, [r4, #156]	; 0x9c
 8012c5a:	4317      	orrs	r7, r2
 8012c5c:	4338      	orrs	r0, r7
 8012c5e:	f8d4 20a0 	ldr.w	r2, [r4, #160]	; 0xa0
                             ETH_InitStruct->ETH_VLANTagIdentifier); 
       
  /*-------------------------------- DMA Config ------------------------------*/
  /*----------------------- ETHERNET DMAOMR Configuration --------------------*/
  /* Get the ETHERNET DMAOMR value */  
  tmpreg = ETH->DMAOMR;
 8012c62:	599f      	ldr	r7, [r3, r6]
  /* Set the TTC bit according to ETH_TransmitThresholdControl value */
  /* Set the FEF bit according to ETH_ForwardErrorFrames value */
  /* Set the FUF bit according to ETH_ForwardUndersizedGoodFrames value */
  /* Set the RTC bit according to ETH_ReceiveThresholdControl value */
  /* Set the OSF bit according to ETH_SecondFrameOperate value */
  tmpreg |= (uint32_t)(ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame | 
 8012c64:	4302      	orrs	r2, r0
  /*-------------------------------- DMA Config ------------------------------*/
  /*----------------------- ETHERNET DMAOMR Configuration --------------------*/
  /* Get the ETHERNET DMAOMR value */  
  tmpreg = ETH->DMAOMR;
  /* Clear xx bits */
  tmpreg &= DMAOMR_CLEAR_MASK;
 8012c66:	4039      	ands	r1, r7
  /* Set the TTC bit according to ETH_TransmitThresholdControl value */
  /* Set the FEF bit according to ETH_ForwardErrorFrames value */
  /* Set the FUF bit according to ETH_ForwardUndersizedGoodFrames value */
  /* Set the RTC bit according to ETH_ReceiveThresholdControl value */
  /* Set the OSF bit according to ETH_SecondFrameOperate value */
  tmpreg |= (uint32_t)(ETH_InitStruct->ETH_DropTCPIPChecksumErrorFrame | 
 8012c68:	4311      	orrs	r1, r2
                  ETH_InitStruct->ETH_ForwardErrorFrames |
                  ETH_InitStruct->ETH_ForwardUndersizedGoodFrames |
                  ETH_InitStruct->ETH_ReceiveThresholdControl |                                   
                  ETH_InitStruct->ETH_SecondFrameOperate); 
  /* Write to ETHERNET DMAOMR */
  ETH->DMAOMR = (uint32_t)tmpreg;
 8012c6a:	5199      	str	r1, [r3, r6]
  /* Set the FB bit according to ETH_FixedBurst value */
  /* Set the RPBL and 4*PBL bits according to ETH_RxDMABurstLength value */
  /* Set the PBL and 4*PBL bits according to ETH_TxDMABurstLength value */
  /* Set the DSL bit according to ETH_DesciptorSkipLength value */
  /* Set the PR and DA bits according to ETH_DMAArbitration value */         
  ETH->DMABMR = (uint32_t)(ETH_InitStruct->ETH_AddressAlignedBeats | 
 8012c6c:	f8d4 20a4 	ldr.w	r2, [r4, #164]	; 0xa4
 8012c70:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
 8012c74:	f8d4 00ac 	ldr.w	r0, [r4, #172]	; 0xac
 8012c78:	4313      	orrs	r3, r2
 8012c7a:	f8d4 10b0 	ldr.w	r1, [r4, #176]	; 0xb0
 8012c7e:	f443 0200 	orr.w	r2, r3, #8388608	; 0x800000
 8012c82:	ea42 0300 	orr.w	r3, r2, r0
 8012c86:	f8d4 20b8 	ldr.w	r2, [r4, #184]	; 0xb8
 8012c8a:	430b      	orrs	r3, r1
 8012c8c:	f8d4 10b4 	ldr.w	r1, [r4, #180]	; 0xb4
 8012c90:	4313      	orrs	r3, r2
 8012c92:	ea43 0381 	orr.w	r3, r3, r1, lsl #2
 8012c96:	602b      	str	r3, [r5, #0]
                          ETH_InitStruct->ETH_DMAArbitration |
                          ETH_DMABMR_USP); /* Enable use of separate PBL for Rx and Tx */
                          
  #ifdef USE_ENHANCED_DMA_DESCRIPTORS
    /* Enable the Enhanced DMA descriptors */
    ETH->DMABMR |= ETH_DMABMR_EDE;
 8012c98:	682b      	ldr	r3, [r5, #0]
  #endif /* USE_ENHANCED_DMA_DESCRIPTORS */
                              
  /* Return Ethernet configuration success */
  return ETH_SUCCESS;
 8012c9a:	2001      	movs	r0, #1
                          ETH_InitStruct->ETH_DMAArbitration |
                          ETH_DMABMR_USP); /* Enable use of separate PBL for Rx and Tx */
                          
  #ifdef USE_ENHANCED_DMA_DESCRIPTORS
    /* Enable the Enhanced DMA descriptors */
    ETH->DMABMR |= ETH_DMABMR_EDE;
 8012c9c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8012ca0:	602b      	str	r3, [r5, #0]
  #endif /* USE_ENHANCED_DMA_DESCRIPTORS */
                              
  /* Return Ethernet configuration success */
  return ETH_SUCCESS;
}
 8012ca2:	b009      	add	sp, #36	; 0x24
 8012ca4:	bdf0      	pop	{r4, r5, r6, r7, pc}
      ETH_InitStruct->ETH_Mode = ETH_Mode_FullDuplex;  
    }
    else
    {
      /* Set Ethernet duplex mode to Half-duplex following the auto-negotiation */
      ETH_InitStruct->ETH_Mode = ETH_Mode_HalfDuplex;           
 8012ca6:	6223      	str	r3, [r4, #32]
 8012ca8:	e743      	b.n	8012b32 <ETH_Init+0xd6>
 8012caa:	bf00      	nop
 8012cac:	40028000 	.word	0x40028000
 8012cb0:	feced300 	.word	0xfeced300
 8012cb4:	00e4e1bf 	.word	0x00e4e1bf
 8012cb8:	000fffff 	.word	0x000fffff
 8012cbc:	0004fffe 	.word	0x0004fffe
 8012cc0:	0004ffff 	.word	0x0004ffff
 8012cc4:	fde9f140 	.word	0xfde9f140
 8012cc8:	017d783f 	.word	0x017d783f
 8012ccc:	fc6c7900 	.word	0xfc6c7900
 8012cd0:	026259ff 	.word	0x026259ff
 8012cd4:	ff20810f 	.word	0xff20810f
 8012cd8:	f8de3f23 	.word	0xf8de3f23
 8012cdc:	40029000 	.word	0x40029000

08012ce0 <ETH_PHYLoopBackCmd>:
  *   This parameter can be: ENABLE or DISABLE.    
  * @retval ETH_ERROR: in case of bad PHY configuration
  *         ETH_SUCCESS: for correct PHY configuration
  */
uint32_t ETH_PHYLoopBackCmd(uint16_t PHYAddress, FunctionalState NewState)
{
 8012ce0:	b538      	push	{r3, r4, r5, lr}
 8012ce2:	460d      	mov	r5, r1
  /* Check the parameters */
  assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  /* Get the PHY configuration to update it */
  tmpreg = ETH_ReadPHYRegister(PHYAddress, PHY_BCR); 
 8012ce4:	2100      	movs	r1, #0
  *   This parameter can be: ENABLE or DISABLE.    
  * @retval ETH_ERROR: in case of bad PHY configuration
  *         ETH_SUCCESS: for correct PHY configuration
  */
uint32_t ETH_PHYLoopBackCmd(uint16_t PHYAddress, FunctionalState NewState)
{
 8012ce6:	4604      	mov	r4, r0
  /* Check the parameters */
  assert_param(IS_ETH_PHY_ADDRESS(PHYAddress));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
    
  /* Get the PHY configuration to update it */
  tmpreg = ETH_ReadPHYRegister(PHYAddress, PHY_BCR); 
 8012ce8:	f7ff fe5a 	bl	80129a0 <ETH_ReadPHYRegister>
  
  if (NewState != DISABLE)
 8012cec:	b155      	cbz	r5, 8012d04 <ETH_PHYLoopBackCmd+0x24>
  {
    /* Enable the PHY loopback mode */
    tmpreg |= PHY_Loopback;  
 8012cee:	f440 4280 	orr.w	r2, r0, #16384	; 0x4000
 8012cf2:	b292      	uxth	r2, r2
  {
    /* Disable the PHY loopback mode: normal mode */
    tmpreg &= (uint16_t)(~(uint16_t)PHY_Loopback);
  }
  /* Update the PHY control register with the new configuration */
  if(ETH_WritePHYRegister(PHYAddress, PHY_BCR, tmpreg) != (uint32_t)RESET)
 8012cf4:	4620      	mov	r0, r4
 8012cf6:	2100      	movs	r1, #0
 8012cf8:	f7ff fe82 	bl	8012a00 <ETH_WritePHYRegister>
  else
  {
    /* Return SUCCESS */
    return ETH_ERROR; 
  }   
} 
 8012cfc:	3000      	adds	r0, #0
 8012cfe:	bf18      	it	ne
 8012d00:	2001      	movne	r0, #1
 8012d02:	bd38      	pop	{r3, r4, r5, pc}
    tmpreg |= PHY_Loopback;  
  }
  else
  {
    /* Disable the PHY loopback mode: normal mode */
    tmpreg &= (uint16_t)(~(uint16_t)PHY_Loopback);
 8012d04:	f420 4280 	bic.w	r2, r0, #16384	; 0x4000
 8012d08:	b292      	uxth	r2, r2
 8012d0a:	e7f3      	b.n	8012cf4 <ETH_PHYLoopBackCmd+0x14>

08012d0c <ETH_ResetWakeUpFrameFilterRegisterPointer>:
  * @retval None
  */
void ETH_ResetWakeUpFrameFilterRegisterPointer(void)
{  
  /* Resets the Remote Wake-up Frame Filter register pointer to 0x0000 */
  ETH->MACPMTCSR |= ETH_MACPMTCSR_WFFRPR;  
 8012d0c:	4a02      	ldr	r2, [pc, #8]	; (8012d18 <ETH_ResetWakeUpFrameFilterRegisterPointer+0xc>)
 8012d0e:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 8012d10:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8012d14:	62d3      	str	r3, [r2, #44]	; 0x2c
 8012d16:	4770      	bx	lr
 8012d18:	40028000 	.word	0x40028000

08012d1c <ETH_SetWakeUpFrameFilterRegister>:
  
  /* Fill Remote Wake-up Frame Filter register with Buffer data */
  for(i =0; i<ETH_WAKEUP_REGISTER_LENGTH; i++)
  {
    /* Write each time to the same register */ 
    ETH->MACRWUFFR = Buffer[i];
 8012d1c:	4904      	ldr	r1, [pc, #16]	; (8012d30 <ETH_SetWakeUpFrameFilterRegister+0x14>)
 8012d1e:	1f03      	subs	r3, r0, #4
 8012d20:	301c      	adds	r0, #28
 8012d22:	f853 2f04 	ldr.w	r2, [r3, #4]!
void ETH_SetWakeUpFrameFilterRegister(uint32_t *Buffer)
{
  uint32_t i = 0;
  
  /* Fill Remote Wake-up Frame Filter register with Buffer data */
  for(i =0; i<ETH_WAKEUP_REGISTER_LENGTH; i++)
 8012d26:	4283      	cmp	r3, r0
  {
    /* Write each time to the same register */ 
    ETH->MACRWUFFR = Buffer[i];
 8012d28:	628a      	str	r2, [r1, #40]	; 0x28
void ETH_SetWakeUpFrameFilterRegister(uint32_t *Buffer)
{
  uint32_t i = 0;
  
  /* Fill Remote Wake-up Frame Filter register with Buffer data */
  for(i =0; i<ETH_WAKEUP_REGISTER_LENGTH; i++)
 8012d2a:	d1fa      	bne.n	8012d22 <ETH_SetWakeUpFrameFilterRegister+0x6>
  {
    /* Write each time to the same register */ 
    ETH->MACRWUFFR = Buffer[i];
  }
}
 8012d2c:	4770      	bx	lr
 8012d2e:	bf00      	nop
 8012d30:	40028000 	.word	0x40028000

08012d34 <ETH_GlobalUnicastWakeUpCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the MAC Global Unicast Wake-Up */
    ETH->MACPMTCSR |= ETH_MACPMTCSR_GU;  
 8012d34:	4a05      	ldr	r2, [pc, #20]	; (8012d4c <ETH_GlobalUnicastWakeUpCmd+0x18>)
 8012d36:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
void ETH_GlobalUnicastWakeUpCmd(FunctionalState NewState)
{ 
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8012d38:	b918      	cbnz	r0, 8012d42 <ETH_GlobalUnicastWakeUpCmd+0xe>
    ETH->MACPMTCSR |= ETH_MACPMTCSR_GU;  
  }
  else
  {
    /* Disable the MAC Global Unicast Wake-Up */ 
    ETH->MACPMTCSR &= ~ETH_MACPMTCSR_GU;
 8012d3a:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8012d3e:	62d3      	str	r3, [r2, #44]	; 0x2c
 8012d40:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the MAC Global Unicast Wake-Up */
    ETH->MACPMTCSR |= ETH_MACPMTCSR_GU;  
 8012d42:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8012d46:	62d3      	str	r3, [r2, #44]	; 0x2c
 8012d48:	4770      	bx	lr
 8012d4a:	bf00      	nop
 8012d4c:	40028000 	.word	0x40028000

08012d50 <ETH_GetPMTFlagStatus>:
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ETH_PMT_GET_FLAG(ETH_PMT_FLAG));
  
  if ((ETH->MACPMTCSR & ETH_PMT_FLAG) != (uint32_t)RESET)
 8012d50:	4b03      	ldr	r3, [pc, #12]	; (8012d60 <ETH_GetPMTFlagStatus+0x10>)
 8012d52:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  }
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
 8012d54:	4203      	tst	r3, r0
}
 8012d56:	bf14      	ite	ne
 8012d58:	2001      	movne	r0, #1
 8012d5a:	2000      	moveq	r0, #0
 8012d5c:	4770      	bx	lr
 8012d5e:	bf00      	nop
 8012d60:	40028000 	.word	0x40028000

08012d64 <ETH_WakeUpFrameDetectionCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the MAC Wake-Up Frame Detection */
    ETH->MACPMTCSR |= ETH_MACPMTCSR_WFE;  
 8012d64:	4a05      	ldr	r2, [pc, #20]	; (8012d7c <ETH_WakeUpFrameDetectionCmd+0x18>)
 8012d66:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
void ETH_WakeUpFrameDetectionCmd(FunctionalState NewState)
{ 
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8012d68:	b918      	cbnz	r0, 8012d72 <ETH_WakeUpFrameDetectionCmd+0xe>
    ETH->MACPMTCSR |= ETH_MACPMTCSR_WFE;  
  }
  else
  {
    /* Disable the MAC Wake-Up Frame Detection */ 
    ETH->MACPMTCSR &= ~ETH_MACPMTCSR_WFE;
 8012d6a:	f023 0304 	bic.w	r3, r3, #4
 8012d6e:	62d3      	str	r3, [r2, #44]	; 0x2c
 8012d70:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the MAC Wake-Up Frame Detection */
    ETH->MACPMTCSR |= ETH_MACPMTCSR_WFE;  
 8012d72:	f043 0304 	orr.w	r3, r3, #4
 8012d76:	62d3      	str	r3, [r2, #44]	; 0x2c
 8012d78:	4770      	bx	lr
 8012d7a:	bf00      	nop
 8012d7c:	40028000 	.word	0x40028000

08012d80 <ETH_MagicPacketDetectionCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the MAC Magic Packet Detection */
    ETH->MACPMTCSR |= ETH_MACPMTCSR_MPE;  
 8012d80:	4a05      	ldr	r2, [pc, #20]	; (8012d98 <ETH_MagicPacketDetectionCmd+0x18>)
 8012d82:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
void ETH_MagicPacketDetectionCmd(FunctionalState NewState)
{ 
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8012d84:	b918      	cbnz	r0, 8012d8e <ETH_MagicPacketDetectionCmd+0xe>
    ETH->MACPMTCSR |= ETH_MACPMTCSR_MPE;  
  }
  else
  {
    /* Disable the MAC Magic Packet Detection */ 
    ETH->MACPMTCSR &= ~ETH_MACPMTCSR_MPE;
 8012d86:	f023 0302 	bic.w	r3, r3, #2
 8012d8a:	62d3      	str	r3, [r2, #44]	; 0x2c
 8012d8c:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the MAC Magic Packet Detection */
    ETH->MACPMTCSR |= ETH_MACPMTCSR_MPE;  
 8012d8e:	f043 0302 	orr.w	r3, r3, #2
 8012d92:	62d3      	str	r3, [r2, #44]	; 0x2c
 8012d94:	4770      	bx	lr
 8012d96:	bf00      	nop
 8012d98:	40028000 	.word	0x40028000

08012d9c <ETH_PowerDownCmd>:
  
  if (NewState != DISABLE)
  {
    /* Enable the MAC Power Down */
    /* This puts the MAC in power down mode */
    ETH->MACPMTCSR |= ETH_MACPMTCSR_PD;  
 8012d9c:	4a05      	ldr	r2, [pc, #20]	; (8012db4 <ETH_PowerDownCmd+0x18>)
 8012d9e:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
void ETH_PowerDownCmd(FunctionalState NewState)
{ 
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8012da0:	b918      	cbnz	r0, 8012daa <ETH_PowerDownCmd+0xe>
    ETH->MACPMTCSR |= ETH_MACPMTCSR_PD;  
  }
  else
  {
    /* Disable the MAC Power Down */ 
    ETH->MACPMTCSR &= ~ETH_MACPMTCSR_PD;
 8012da2:	f023 0301 	bic.w	r3, r3, #1
 8012da6:	62d3      	str	r3, [r2, #44]	; 0x2c
 8012da8:	4770      	bx	lr
  
  if (NewState != DISABLE)
  {
    /* Enable the MAC Power Down */
    /* This puts the MAC in power down mode */
    ETH->MACPMTCSR |= ETH_MACPMTCSR_PD;  
 8012daa:	f043 0301 	orr.w	r3, r3, #1
 8012dae:	62d3      	str	r3, [r2, #44]	; 0x2c
 8012db0:	4770      	bx	lr
 8012db2:	bf00      	nop
 8012db4:	40028000 	.word	0x40028000

08012db8 <ETH_MMCCounterFullPreset>:
  * @retval None
  */
void ETH_MMCCounterFullPreset(void)
{
  /* Preset and Initialize the MMC counters to almost-full value */
  ETH->MMCCR |= ETH_MMCCR_MCFHP | ETH_MMCCR_MCP;
 8012db8:	4a03      	ldr	r2, [pc, #12]	; (8012dc8 <ETH_MMCCounterFullPreset+0x10>)
 8012dba:	f8d2 3100 	ldr.w	r3, [r2, #256]	; 0x100
 8012dbe:	f043 0330 	orr.w	r3, r3, #48	; 0x30
 8012dc2:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
 8012dc6:	4770      	bx	lr
 8012dc8:	40028000 	.word	0x40028000

08012dcc <ETH_MMCCounterHalfPreset>:
  * @retval None
  */
void ETH_MMCCounterHalfPreset(void)
{
  /* Preset the MMC counters to almost-full value */
  ETH->MMCCR &= ~ETH_MMCCR_MCFHP;
 8012dcc:	4b06      	ldr	r3, [pc, #24]	; (8012de8 <ETH_MMCCounterHalfPreset+0x1c>)
 8012dce:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
 8012dd2:	f022 0220 	bic.w	r2, r2, #32
 8012dd6:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
  /* Initialize the MMC counters to almost-half value */
  ETH->MMCCR |= ETH_MMCCR_MCP;
 8012dda:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
 8012dde:	f042 0210 	orr.w	r2, r2, #16
 8012de2:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
 8012de6:	4770      	bx	lr
 8012de8:	40028000 	.word	0x40028000

08012dec <ETH_MMCCounterFreezeCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the MMC Counter Freeze */
    ETH->MMCCR |= ETH_MMCCR_MCF;
 8012dec:	4a06      	ldr	r2, [pc, #24]	; (8012e08 <ETH_MMCCounterFreezeCmd+0x1c>)
 8012dee:	f8d2 3100 	ldr.w	r3, [r2, #256]	; 0x100
void ETH_MMCCounterFreezeCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8012df2:	b920      	cbnz	r0, 8012dfe <ETH_MMCCounterFreezeCmd+0x12>
    ETH->MMCCR |= ETH_MMCCR_MCF;
  }
  else
  {
    /* Disable the MMC Counter Freeze */
    ETH->MMCCR &= ~ETH_MMCCR_MCF;
 8012df4:	f023 0308 	bic.w	r3, r3, #8
 8012df8:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
 8012dfc:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the MMC Counter Freeze */
    ETH->MMCCR |= ETH_MMCCR_MCF;
 8012dfe:	f043 0308 	orr.w	r3, r3, #8
 8012e02:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
 8012e06:	4770      	bx	lr
 8012e08:	40028000 	.word	0x40028000

08012e0c <ETH_MMCResetOnReadCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the MMC Counter reset on read */
    ETH->MMCCR |= ETH_MMCCR_ROR; 
 8012e0c:	4a06      	ldr	r2, [pc, #24]	; (8012e28 <ETH_MMCResetOnReadCmd+0x1c>)
 8012e0e:	f8d2 3100 	ldr.w	r3, [r2, #256]	; 0x100
void ETH_MMCResetOnReadCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8012e12:	b920      	cbnz	r0, 8012e1e <ETH_MMCResetOnReadCmd+0x12>
    ETH->MMCCR |= ETH_MMCCR_ROR; 
  }
  else
  {
    /* Disable the MMC Counter reset on read */
    ETH->MMCCR &= ~ETH_MMCCR_ROR;
 8012e14:	f023 0304 	bic.w	r3, r3, #4
 8012e18:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
 8012e1c:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the MMC Counter reset on read */
    ETH->MMCCR |= ETH_MMCCR_ROR; 
 8012e1e:	f043 0304 	orr.w	r3, r3, #4
 8012e22:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
 8012e26:	4770      	bx	lr
 8012e28:	40028000 	.word	0x40028000

08012e2c <ETH_MMCCounterRolloverCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Disable the MMC Counter Stop Rollover  */
    ETH->MMCCR &= ~ETH_MMCCR_CSR;
 8012e2c:	4a06      	ldr	r2, [pc, #24]	; (8012e48 <ETH_MMCCounterRolloverCmd+0x1c>)
 8012e2e:	f8d2 3100 	ldr.w	r3, [r2, #256]	; 0x100
void ETH_MMCCounterRolloverCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8012e32:	b920      	cbnz	r0, 8012e3e <ETH_MMCCounterRolloverCmd+0x12>
    ETH->MMCCR &= ~ETH_MMCCR_CSR;
  }
  else
  {
    /* Enable the MMC Counter Stop Rollover */
    ETH->MMCCR |= ETH_MMCCR_CSR; 
 8012e34:	f043 0302 	orr.w	r3, r3, #2
 8012e38:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
 8012e3c:	4770      	bx	lr
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Disable the MMC Counter Stop Rollover  */
    ETH->MMCCR &= ~ETH_MMCCR_CSR;
 8012e3e:	f023 0302 	bic.w	r3, r3, #2
 8012e42:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
 8012e46:	4770      	bx	lr
 8012e48:	40028000 	.word	0x40028000

08012e4c <ETH_MMCCountersReset>:
  * @retval None
  */
void ETH_MMCCountersReset(void)
{
  /* Resets the MMC Counters */
  ETH->MMCCR |= ETH_MMCCR_CR; 
 8012e4c:	4a03      	ldr	r2, [pc, #12]	; (8012e5c <ETH_MMCCountersReset+0x10>)
 8012e4e:	f8d2 3100 	ldr.w	r3, [r2, #256]	; 0x100
 8012e52:	f043 0301 	orr.w	r3, r3, #1
 8012e56:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
 8012e5a:	4770      	bx	lr
 8012e5c:	40028000 	.word	0x40028000

08012e60 <ETH_MMCITConfig>:
{ 
  /* Check the parameters */
  assert_param(IS_ETH_MMC_IT(ETH_MMC_IT));  
  assert_param(IS_FUNCTIONAL_STATE(NewState));
   
  if ((ETH_MMC_IT & (uint32_t)0x10000000) != (uint32_t)RESET)
 8012e60:	00c3      	lsls	r3, r0, #3
 8012e62:	d50a      	bpl.n	8012e7a <ETH_MMCITConfig+0x1a>
  
    /* ETHERNET MMC Rx interrupts selected */
    if (NewState != DISABLE)
    {
      /* Enable the selected ETHERNET MMC interrupts */
      ETH->MMCRIMR &=(~(uint32_t)ETH_MMC_IT);
 8012e64:	4a0d      	ldr	r2, [pc, #52]	; (8012e9c <ETH_MMCITConfig+0x3c>)
  assert_param(IS_FUNCTIONAL_STATE(NewState));
   
  if ((ETH_MMC_IT & (uint32_t)0x10000000) != (uint32_t)RESET)
  {
    /* Remove Register mak from IT */
    ETH_MMC_IT &= 0xEFFFFFFF;
 8012e66:	f020 5080 	bic.w	r0, r0, #268435456	; 0x10000000
  
    /* ETHERNET MMC Rx interrupts selected */
    if (NewState != DISABLE)
    {
      /* Enable the selected ETHERNET MMC interrupts */
      ETH->MMCRIMR &=(~(uint32_t)ETH_MMC_IT);
 8012e6a:	f8d2 310c 	ldr.w	r3, [r2, #268]	; 0x10c
  {
    /* Remove Register mak from IT */
    ETH_MMC_IT &= 0xEFFFFFFF;
  
    /* ETHERNET MMC Rx interrupts selected */
    if (NewState != DISABLE)
 8012e6e:	b161      	cbz	r1, 8012e8a <ETH_MMCITConfig+0x2a>
    {
      /* Enable the selected ETHERNET MMC interrupts */
      ETH->MMCRIMR &=(~(uint32_t)ETH_MMC_IT);
 8012e70:	ea23 0000 	bic.w	r0, r3, r0
 8012e74:	f8c2 010c 	str.w	r0, [r2, #268]	; 0x10c
 8012e78:	4770      	bx	lr
  {
    /* ETHERNET MMC Tx interrupts selected */
    if (NewState != DISABLE)
    {
      /* Enable the selected ETHERNET MMC interrupts */
      ETH->MMCTIMR &=(~(uint32_t)ETH_MMC_IT);
 8012e7a:	4a08      	ldr	r2, [pc, #32]	; (8012e9c <ETH_MMCITConfig+0x3c>)
 8012e7c:	f8d2 3110 	ldr.w	r3, [r2, #272]	; 0x110
    }
  }
  else
  {
    /* ETHERNET MMC Tx interrupts selected */
    if (NewState != DISABLE)
 8012e80:	b939      	cbnz	r1, 8012e92 <ETH_MMCITConfig+0x32>
      ETH->MMCTIMR &=(~(uint32_t)ETH_MMC_IT);
    }
    else
    {
      /* Disable the selected ETHERNET MMC interrupts */
      ETH->MMCTIMR |= ETH_MMC_IT;    
 8012e82:	4318      	orrs	r0, r3
 8012e84:	f8c2 0110 	str.w	r0, [r2, #272]	; 0x110
 8012e88:	4770      	bx	lr
      ETH->MMCRIMR &=(~(uint32_t)ETH_MMC_IT);
    }
    else
    {
      /* Disable the selected ETHERNET MMC interrupts */
      ETH->MMCRIMR |= ETH_MMC_IT;    
 8012e8a:	4318      	orrs	r0, r3
 8012e8c:	f8c2 010c 	str.w	r0, [r2, #268]	; 0x10c
 8012e90:	4770      	bx	lr
  {
    /* ETHERNET MMC Tx interrupts selected */
    if (NewState != DISABLE)
    {
      /* Enable the selected ETHERNET MMC interrupts */
      ETH->MMCTIMR &=(~(uint32_t)ETH_MMC_IT);
 8012e92:	ea23 0000 	bic.w	r0, r3, r0
 8012e96:	f8c2 0110 	str.w	r0, [r2, #272]	; 0x110
 8012e9a:	4770      	bx	lr
 8012e9c:	40028000 	.word	0x40028000

08012ea0 <ETH_GetMMCITStatus>:
{
  ITStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ETH_MMC_GET_IT(ETH_MMC_IT)); 
  
  if ((ETH_MMC_IT & (uint32_t)0x10000000) != (uint32_t)RESET)
 8012ea0:	00c3      	lsls	r3, r0, #3
  {
    /* ETHERNET MMC Rx interrupts selected */
    /* Check if the ETHERNET MMC Rx selected interrupt is enabled and occurred */ 
    if ((((ETH->MMCRIR & ETH_MMC_IT) != (uint32_t)RESET)) && ((ETH->MMCRIMR & ETH_MMC_IT) == (uint32_t)RESET))
 8012ea2:	4a09      	ldr	r2, [pc, #36]	; (8012ec8 <ETH_GetMMCITStatus+0x28>)
{
  ITStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ETH_MMC_GET_IT(ETH_MMC_IT)); 
  
  if ((ETH_MMC_IT & (uint32_t)0x10000000) != (uint32_t)RESET)
 8012ea4:	d50a      	bpl.n	8012ebc <ETH_GetMMCITStatus+0x1c>
  {
    /* ETHERNET MMC Rx interrupts selected */
    /* Check if the ETHERNET MMC Rx selected interrupt is enabled and occurred */ 
    if ((((ETH->MMCRIR & ETH_MMC_IT) != (uint32_t)RESET)) && ((ETH->MMCRIMR & ETH_MMC_IT) == (uint32_t)RESET))
 8012ea6:	f8d2 3104 	ldr.w	r3, [r2, #260]	; 0x104
 8012eaa:	4003      	ands	r3, r0
 8012eac:	d00a      	beq.n	8012ec4 <ETH_GetMMCITStatus+0x24>
  }
  else
  {
    /* ETHERNET MMC Tx interrupts selected */
    /* Check if the ETHERNET MMC Tx selected interrupt is enabled and occurred */  
    if ((((ETH->MMCTIR & ETH_MMC_IT) != (uint32_t)RESET)) && ((ETH->MMCRIMR & ETH_MMC_IT) == (uint32_t)RESET))
 8012eae:	f8d2 310c 	ldr.w	r3, [r2, #268]	; 0x10c
    {
      bitstatus = SET;
    }
    else
    {
      bitstatus = RESET;
 8012eb2:	4218      	tst	r0, r3
 8012eb4:	bf0c      	ite	eq
 8012eb6:	2001      	moveq	r0, #1
 8012eb8:	2000      	movne	r0, #0
 8012eba:	4770      	bx	lr
  }
  else
  {
    /* ETHERNET MMC Tx interrupts selected */
    /* Check if the ETHERNET MMC Tx selected interrupt is enabled and occurred */  
    if ((((ETH->MMCTIR & ETH_MMC_IT) != (uint32_t)RESET)) && ((ETH->MMCRIMR & ETH_MMC_IT) == (uint32_t)RESET))
 8012ebc:	f8d2 3108 	ldr.w	r3, [r2, #264]	; 0x108
 8012ec0:	4003      	ands	r3, r0
 8012ec2:	d1f4      	bne.n	8012eae <ETH_GetMMCITStatus+0xe>
    {
      bitstatus = SET;
    }
    else
    {
      bitstatus = RESET;
 8012ec4:	4618      	mov	r0, r3
      bitstatus = RESET;
    }  
  }    
    
  return bitstatus;
}
 8012ec6:	4770      	bx	lr
 8012ec8:	40028000 	.word	0x40028000

08012ecc <ETH_GetMMCRegister>:
{
  /* Check the parameters */
  assert_param(IS_ETH_MMC_REGISTER(ETH_MMCReg));
  
  /* Return the selected register value */
  return (*(__IO uint32_t *)(ETH_MAC_BASE + ETH_MMCReg));
 8012ecc:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
 8012ed0:	f500 3020 	add.w	r0, r0, #163840	; 0x28000
 8012ed4:	6800      	ldr	r0, [r0, #0]
}
 8012ed6:	4770      	bx	lr

08012ed8 <SYSCFG_DeInit>:
  *   registers to their default reset values.
  * @param  None
  * @retval None
  */
void SYSCFG_DeInit(void)
{
 8012ed8:	b508      	push	{r3, lr}
   RCC_APB2PeriphResetCmd(RCC_APB2Periph_SYSCFG, ENABLE);
 8012eda:	2101      	movs	r1, #1
 8012edc:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8012ee0:	f7f6 f810 	bl	8008f04 <RCC_APB2PeriphResetCmd>
   RCC_APB2PeriphResetCmd(RCC_APB2Periph_SYSCFG, DISABLE);
}
 8012ee4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  * @retval None
  */
void SYSCFG_DeInit(void)
{
   RCC_APB2PeriphResetCmd(RCC_APB2Periph_SYSCFG, ENABLE);
   RCC_APB2PeriphResetCmd(RCC_APB2Periph_SYSCFG, DISABLE);
 8012ee8:	2100      	movs	r1, #0
 8012eea:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8012eee:	f7f6 b809 	b.w	8008f04 <RCC_APB2PeriphResetCmd>
 8012ef2:	bf00      	nop

08012ef4 <SYSCFG_MemoryRemapConfig>:
void SYSCFG_MemoryRemapConfig(uint8_t SYSCFG_MemoryRemap)
{
  /* Check the parameters */
  assert_param(IS_SYSCFG_MEMORY_REMAP_CONFING(SYSCFG_MemoryRemap));

  SYSCFG->MEMRMP = SYSCFG_MemoryRemap;
 8012ef4:	4b01      	ldr	r3, [pc, #4]	; (8012efc <SYSCFG_MemoryRemapConfig+0x8>)
 8012ef6:	6018      	str	r0, [r3, #0]
 8012ef8:	4770      	bx	lr
 8012efa:	bf00      	nop
 8012efc:	40013800 	.word	0x40013800

08012f00 <SYSCFG_EXTILineConfig>:
  *           This parameter can be EXTI_PinSourcex where x can be (0..15, except
  *           for EXTI_PortSourceGPIOI x can be (0..11).
  * @retval None
  */
void SYSCFG_EXTILineConfig(uint8_t EXTI_PortSourceGPIOx, uint8_t EXTI_PinSourcex)
{
 8012f00:	f001 03fc 	and.w	r3, r1, #252	; 0xfc
 8012f04:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8012f08:	f503 339c 	add.w	r3, r3, #79872	; 0x13800

  /* Check the parameters */
  assert_param(IS_EXTI_PORT_SOURCE(EXTI_PortSourceGPIOx));
  assert_param(IS_EXTI_PIN_SOURCE(EXTI_PinSourcex));

  tmp = ((uint32_t)0x0F) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03));
 8012f0c:	f001 0103 	and.w	r1, r1, #3
  *           This parameter can be EXTI_PinSourcex where x can be (0..15, except
  *           for EXTI_PortSourceGPIOI x can be (0..11).
  * @retval None
  */
void SYSCFG_EXTILineConfig(uint8_t EXTI_PortSourceGPIOx, uint8_t EXTI_PinSourcex)
{
 8012f10:	b410      	push	{r4}

  /* Check the parameters */
  assert_param(IS_EXTI_PORT_SOURCE(EXTI_PortSourceGPIOx));
  assert_param(IS_EXTI_PIN_SOURCE(EXTI_PinSourcex));

  tmp = ((uint32_t)0x0F) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03));
 8012f12:	0089      	lsls	r1, r1, #2
  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] &= ~tmp;
 8012f14:	689c      	ldr	r4, [r3, #8]
 8012f16:	220f      	movs	r2, #15
 8012f18:	408a      	lsls	r2, r1
 8012f1a:	ea24 0202 	bic.w	r2, r4, r2
 8012f1e:	609a      	str	r2, [r3, #8]
  SYSCFG->EXTICR[EXTI_PinSourcex >> 0x02] |= (((uint32_t)EXTI_PortSourceGPIOx) << (0x04 * (EXTI_PinSourcex & (uint8_t)0x03)));
 8012f20:	689a      	ldr	r2, [r3, #8]
 8012f22:	4088      	lsls	r0, r1
 8012f24:	4310      	orrs	r0, r2
 8012f26:	6098      	str	r0, [r3, #8]
}
 8012f28:	bc10      	pop	{r4}
 8012f2a:	4770      	bx	lr

08012f2c <SYSCFG_ETH_MediaInterfaceConfig>:
  */
void SYSCFG_ETH_MediaInterfaceConfig(uint32_t SYSCFG_ETH_MediaInterface) 
{ 
  assert_param(IS_SYSCFG_ETH_MEDIA_INTERFACE(SYSCFG_ETH_MediaInterface)); 
  /* Configure MII_RMII selection bit */ 
  *(__IO uint32_t *) PMC_MII_RMII_SEL_BB = SYSCFG_ETH_MediaInterface; 
 8012f2c:	4b01      	ldr	r3, [pc, #4]	; (8012f34 <SYSCFG_ETH_MediaInterfaceConfig+0x8>)
 8012f2e:	6018      	str	r0, [r3, #0]
 8012f30:	4770      	bx	lr
 8012f32:	bf00      	nop
 8012f34:	422700dc 	.word	0x422700dc

08012f38 <SYSCFG_CompensationCellCmd>:
void SYSCFG_CompensationCellCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CMPCR_CMP_PD_BB = (uint32_t)NewState;
 8012f38:	4b01      	ldr	r3, [pc, #4]	; (8012f40 <SYSCFG_CompensationCellCmd+0x8>)
 8012f3a:	6018      	str	r0, [r3, #0]
 8012f3c:	4770      	bx	lr
 8012f3e:	bf00      	nop
 8012f40:	42270400 	.word	0x42270400

08012f44 <SYSCFG_GetCompensationCellStatus>:
  */
FlagStatus SYSCFG_GetCompensationCellStatus(void)
{
  FlagStatus bitstatus = RESET;
    
  if ((SYSCFG->CMPCR & SYSCFG_CMPCR_READY ) != (uint32_t)RESET)
 8012f44:	4b02      	ldr	r3, [pc, #8]	; (8012f50 <SYSCFG_GetCompensationCellStatus+0xc>)
 8012f46:	6a18      	ldr	r0, [r3, #32]
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 8012f48:	f3c0 2000 	ubfx	r0, r0, #8, #1
 8012f4c:	4770      	bx	lr
 8012f4e:	bf00      	nop
 8012f50:	40013800 	.word	0x40013800

08012f54 <sys_mbox_new>:
/*----------------------------------------------------------------------------*/
/*--------------------Creates an empty mailbox.-------------------------------*/
  

err_t sys_mbox_new( sys_mbox_t *mbox, int size)
{
 8012f54:	b500      	push	{lr}
 8012f56:	b083      	sub	sp, #12
  OS_ERR       ucErr;
      
  OSQCreate(mbox,"LWIP quiue", size, &ucErr); 
 8012f58:	b28a      	uxth	r2, r1
 8012f5a:	f10d 0306 	add.w	r3, sp, #6
 8012f5e:	490b      	ldr	r1, [pc, #44]	; (8012f8c <sys_mbox_new+0x38>)
 8012f60:	f7f2 fc50 	bl	8005804 <OSQCreate>
  LWIP_ASSERT( "OSQCreate ", ucErr == OS_ERR_NONE );
 8012f64:	f8bd 0006 	ldrh.w	r0, [sp, #6]
 8012f68:	b930      	cbnz	r0, 8012f78 <sys_mbox_new+0x24>
 8012f6a:	3000      	adds	r0, #0
 8012f6c:	bf18      	it	ne
 8012f6e:	2001      	movne	r0, #1
  
  if( ucErr == OS_ERR_NONE){ 
    return 0; 
  }
  return -1;
}
 8012f70:	4240      	negs	r0, r0
 8012f72:	b003      	add	sp, #12
 8012f74:	f85d fb04 	ldr.w	pc, [sp], #4
err_t sys_mbox_new( sys_mbox_t *mbox, int size)
{
  OS_ERR       ucErr;
      
  OSQCreate(mbox,"LWIP quiue", size, &ucErr); 
  LWIP_ASSERT( "OSQCreate ", ucErr == OS_ERR_NONE );
 8012f78:	4b05      	ldr	r3, [pc, #20]	; (8012f90 <sys_mbox_new+0x3c>)
 8012f7a:	224f      	movs	r2, #79	; 0x4f
 8012f7c:	4905      	ldr	r1, [pc, #20]	; (8012f94 <sys_mbox_new+0x40>)
 8012f7e:	4806      	ldr	r0, [pc, #24]	; (8012f98 <sys_mbox_new+0x44>)
 8012f80:	f001 fefa 	bl	8014d78 <iprintf>
 8012f84:	f8bd 0006 	ldrh.w	r0, [sp, #6]
 8012f88:	e7ef      	b.n	8012f6a <sys_mbox_new+0x16>
 8012f8a:	bf00      	nop
 8012f8c:	08018254 	.word	0x08018254
 8012f90:	08018260 	.word	0x08018260
 8012f94:	08018284 	.word	0x08018284
 8012f98:	0801660c 	.word	0x0801660c

08012f9c <sys_mbox_free>:
  mailbox when the mailbox is deallocated, it is an indication of a
  programming error in lwIP and the developer should be notified.
*/
void
sys_mbox_free(sys_mbox_t * mbox)
{
 8012f9c:	b510      	push	{r4, lr}
    OS_ERR     ucErr;
    LWIP_ASSERT( "sys_mbox_free ", mbox != SYS_MBOX_NULL );      
 8012f9e:	4604      	mov	r4, r0
  mailbox when the mailbox is deallocated, it is an indication of a
  programming error in lwIP and the developer should be notified.
*/
void
sys_mbox_free(sys_mbox_t * mbox)
{
 8012fa0:	b082      	sub	sp, #8
    OS_ERR     ucErr;
    LWIP_ASSERT( "sys_mbox_free ", mbox != SYS_MBOX_NULL );      
 8012fa2:	b1a8      	cbz	r0, 8012fd0 <sys_mbox_free+0x34>
        
    OSQFlush(mbox,& ucErr);
 8012fa4:	f10d 0106 	add.w	r1, sp, #6
 8012fa8:	4620      	mov	r0, r4
 8012faa:	f7f2 fc75 	bl	8005898 <OSQFlush>
    
    OSQDel(mbox, OS_OPT_DEL_ALWAYS, &ucErr);
 8012fae:	f10d 0206 	add.w	r2, sp, #6
 8012fb2:	4620      	mov	r0, r4
 8012fb4:	2101      	movs	r1, #1
 8012fb6:	f7f2 fdd7 	bl	8005b68 <OSQDel>
    LWIP_ASSERT( "OSQDel ", ucErr == OS_ERR_NONE );
 8012fba:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8012fbe:	b12b      	cbz	r3, 8012fcc <sys_mbox_free+0x30>
 8012fc0:	4b07      	ldr	r3, [pc, #28]	; (8012fe0 <sys_mbox_free+0x44>)
 8012fc2:	2266      	movs	r2, #102	; 0x66
 8012fc4:	4907      	ldr	r1, [pc, #28]	; (8012fe4 <sys_mbox_free+0x48>)
 8012fc6:	4808      	ldr	r0, [pc, #32]	; (8012fe8 <sys_mbox_free+0x4c>)
 8012fc8:	f001 fed6 	bl	8014d78 <iprintf>
}
 8012fcc:	b002      	add	sp, #8
 8012fce:	bd10      	pop	{r4, pc}
*/
void
sys_mbox_free(sys_mbox_t * mbox)
{
    OS_ERR     ucErr;
    LWIP_ASSERT( "sys_mbox_free ", mbox != SYS_MBOX_NULL );      
 8012fd0:	4b03      	ldr	r3, [pc, #12]	; (8012fe0 <sys_mbox_free+0x44>)
 8012fd2:	2261      	movs	r2, #97	; 0x61
 8012fd4:	4905      	ldr	r1, [pc, #20]	; (8012fec <sys_mbox_free+0x50>)
 8012fd6:	4804      	ldr	r0, [pc, #16]	; (8012fe8 <sys_mbox_free+0x4c>)
 8012fd8:	f001 fece 	bl	8014d78 <iprintf>
 8012fdc:	e7e2      	b.n	8012fa4 <sys_mbox_free+0x8>
 8012fde:	bf00      	nop
 8012fe0:	08018260 	.word	0x08018260
 8012fe4:	080182a0 	.word	0x080182a0
 8012fe8:	0801660c 	.word	0x0801660c
 8012fec:	08018290 	.word	0x08018290

08012ff0 <sys_mbox_post>:
/*-----------------------------------------------------------------------------------
 *   Posts the "msg" to the mailbox.
 */
void
sys_mbox_post(sys_mbox_t *mbox, void *msg)
{
 8012ff0:	b5f0      	push	{r4, r5, r6, r7, lr}
  OS_ERR     ucErr;
  CPU_INT08U  i=0; 
  if( msg == NULL ) msg = (void*)&pvNullPointer;
 8012ff2:	4e12      	ldr	r6, [pc, #72]	; (801303c <sys_mbox_post+0x4c>)
/*-----------------------------------------------------------------------------------
 *   Posts the "msg" to the mailbox.
 */
void
sys_mbox_post(sys_mbox_t *mbox, void *msg)
{
 8012ff4:	4607      	mov	r7, r0
  OS_ERR     ucErr;
  CPU_INT08U  i=0; 
  if( msg == NULL ) msg = (void*)&pvNullPointer;
 8012ff6:	2900      	cmp	r1, #0
 8012ff8:	bf18      	it	ne
 8012ffa:	460e      	movne	r6, r1
/*-----------------------------------------------------------------------------------
 *   Posts the "msg" to the mailbox.
 */
void
sys_mbox_post(sys_mbox_t *mbox, void *msg)
{
 8012ffc:	b085      	sub	sp, #20
  OS_ERR     ucErr;
  CPU_INT08U  i=0; 
  if( msg == NULL ) msg = (void*)&pvNullPointer;
 8012ffe:	240a      	movs	r4, #10
 8013000:	f10d 050e 	add.w	r5, sp, #14
  /* try 10 times */
  while(i<10){
    OSQPost(mbox, msg,0,OS_OPT_POST_ALL,&ucErr);
 8013004:	f44f 7300 	mov.w	r3, #512	; 0x200
 8013008:	4631      	mov	r1, r6
 801300a:	4638      	mov	r0, r7
 801300c:	9500      	str	r5, [sp, #0]
 801300e:	2200      	movs	r2, #0
 8013010:	f7f2 feb4 	bl	8005d7c <OSQPost>
    if(ucErr == OS_ERR_NONE)
 8013014:	f8bd 300e 	ldrh.w	r3, [sp, #14]
      break;
    i++;
    OSTimeDly(5,OS_OPT_TIME_DLY,&ucErr);
 8013018:	2100      	movs	r1, #0
 801301a:	2005      	movs	r0, #5
  CPU_INT08U  i=0; 
  if( msg == NULL ) msg = (void*)&pvNullPointer;
  /* try 10 times */
  while(i<10){
    OSQPost(mbox, msg,0,OS_OPT_POST_ALL,&ucErr);
    if(ucErr == OS_ERR_NONE)
 801301c:	b163      	cbz	r3, 8013038 <sys_mbox_post+0x48>
      break;
    i++;
    OSTimeDly(5,OS_OPT_TIME_DLY,&ucErr);
 801301e:	462a      	mov	r2, r5
 8013020:	f7f4 fd22 	bl	8007a68 <OSTimeDly>
 8013024:	1e63      	subs	r3, r4, #1
{
  OS_ERR     ucErr;
  CPU_INT08U  i=0; 
  if( msg == NULL ) msg = (void*)&pvNullPointer;
  /* try 10 times */
  while(i<10){
 8013026:	f013 04ff 	ands.w	r4, r3, #255	; 0xff
 801302a:	d1eb      	bne.n	8013004 <sys_mbox_post+0x14>
    if(ucErr == OS_ERR_NONE)
      break;
    i++;
    OSTimeDly(5,OS_OPT_TIME_DLY,&ucErr);
  }
  LWIP_ASSERT( "sys_mbox_post error!\n", i !=10 );  
 801302c:	4b04      	ldr	r3, [pc, #16]	; (8013040 <sys_mbox_post+0x50>)
 801302e:	227a      	movs	r2, #122	; 0x7a
 8013030:	4904      	ldr	r1, [pc, #16]	; (8013044 <sys_mbox_post+0x54>)
 8013032:	4805      	ldr	r0, [pc, #20]	; (8013048 <sys_mbox_post+0x58>)
 8013034:	f001 fea0 	bl	8014d78 <iprintf>
}
 8013038:	b005      	add	sp, #20
 801303a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 801303c:	08016224 	.word	0x08016224
 8013040:	08018260 	.word	0x08018260
 8013044:	080182a8 	.word	0x080182a8
 8013048:	0801660c 	.word	0x0801660c

0801304c <sys_mbox_trypost>:

/* Try to post the "msg" to the mailbox. */
err_t sys_mbox_trypost(sys_mbox_t *mbox, void *msg)
{
 801304c:	b500      	push	{lr}
  OS_ERR     ucErr;
  if(msg == NULL ) msg = (void*)&pvNullPointer;  
 801304e:	4a0b      	ldr	r2, [pc, #44]	; (801307c <sys_mbox_trypost+0x30>)
  LWIP_ASSERT( "sys_mbox_post error!\n", i !=10 );  
}

/* Try to post the "msg" to the mailbox. */
err_t sys_mbox_trypost(sys_mbox_t *mbox, void *msg)
{
 8013050:	b085      	sub	sp, #20
  OS_ERR     ucErr;
  if(msg == NULL ) msg = (void*)&pvNullPointer;  
  OSQPost(mbox, msg,0,OS_OPT_POST_ALL,&ucErr);    
 8013052:	f10d 030e 	add.w	r3, sp, #14
 8013056:	2900      	cmp	r1, #0
 8013058:	bf08      	it	eq
 801305a:	4611      	moveq	r1, r2
 801305c:	9300      	str	r3, [sp, #0]
 801305e:	2200      	movs	r2, #0
 8013060:	f44f 7300 	mov.w	r3, #512	; 0x200
 8013064:	f7f2 fe8a 	bl	8005d7c <OSQPost>
  if(ucErr != OS_ERR_NONE){
 8013068:	f8bd 000e 	ldrh.w	r0, [sp, #14]
 801306c:	3000      	adds	r0, #0
 801306e:	bf18      	it	ne
 8013070:	2001      	movne	r0, #1
    return ERR_MEM;
  }
  return ERR_OK;
}
 8013072:	4240      	negs	r0, r0
 8013074:	b005      	add	sp, #20
 8013076:	f85d fb04 	ldr.w	pc, [sp], #4
 801307a:	bf00      	nop
 801307c:	08016224 	.word	0x08016224

08013080 <sys_arch_mbox_fetch>:
u32_t sys_arch_mbox_fetch(sys_mbox_t *mbox, void **msg, u32_t timeout)
{ 
  OS_ERR	ucErr;
  OS_MSG_SIZE   msg_size;
  CPU_TS        ucos_timeout;  
  CPU_TS        in_timeout = timeout/LWIP_ARCH_TICK_PER_MS;
 8013080:	4b0f      	ldr	r3, [pc, #60]	; (80130c0 <sys_arch_mbox_fetch+0x40>)

  Note that a function with a similar name, sys_mbox_fetch(), is
  implemented by lwIP. 
*/
u32_t sys_arch_mbox_fetch(sys_mbox_t *mbox, void **msg, u32_t timeout)
{ 
 8013082:	b510      	push	{r4, lr}
  OS_ERR	ucErr;
  OS_MSG_SIZE   msg_size;
  CPU_TS        ucos_timeout;  
  CPU_TS        in_timeout = timeout/LWIP_ARCH_TICK_PER_MS;
 8013084:	fba3 4302 	umull	r4, r3, r3, r2

  Note that a function with a similar name, sys_mbox_fetch(), is
  implemented by lwIP. 
*/
u32_t sys_arch_mbox_fetch(sys_mbox_t *mbox, void **msg, u32_t timeout)
{ 
 8013088:	b084      	sub	sp, #16
 801308a:	460c      	mov	r4, r1
  OS_ERR	ucErr;
  OS_MSG_SIZE   msg_size;
  CPU_TS        ucos_timeout;  
  CPU_TS        in_timeout = timeout/LWIP_ARCH_TICK_PER_MS;
 801308c:	0c99      	lsrs	r1, r3, #18
  if(timeout && in_timeout == 0)
 801308e:	b112      	cbz	r2, 8013096 <sys_arch_mbox_fetch+0x16>
    in_timeout = 1;
 8013090:	2900      	cmp	r1, #0
 8013092:	bf08      	it	eq
 8013094:	2101      	moveq	r1, #1
  *msg  = OSQPend (mbox,in_timeout,OS_OPT_PEND_BLOCKING,&msg_size, 
 8013096:	aa02      	add	r2, sp, #8
 8013098:	ab03      	add	r3, sp, #12
 801309a:	9201      	str	r2, [sp, #4]
 801309c:	9300      	str	r3, [sp, #0]
 801309e:	2200      	movs	r2, #0
 80130a0:	f10d 030a 	add.w	r3, sp, #10
 80130a4:	f7f2 fc24 	bl	80058f0 <OSQPend>
                          &ucos_timeout,&ucErr);

  if ( ucErr == OS_ERR_TIMEOUT ) 
 80130a8:	f247 23d9 	movw	r3, #29401	; 0x72d9
 80130ac:	f8bd 2008 	ldrh.w	r2, [sp, #8]
  OS_MSG_SIZE   msg_size;
  CPU_TS        ucos_timeout;  
  CPU_TS        in_timeout = timeout/LWIP_ARCH_TICK_PER_MS;
  if(timeout && in_timeout == 0)
    in_timeout = 1;
  *msg  = OSQPend (mbox,in_timeout,OS_OPT_PEND_BLOCKING,&msg_size, 
 80130b0:	6020      	str	r0, [r4, #0]
                          &ucos_timeout,&ucErr);

  if ( ucErr == OS_ERR_TIMEOUT ) 
 80130b2:	429a      	cmp	r2, r3
 80130b4:	bf14      	ite	ne
 80130b6:	9803      	ldrne	r0, [sp, #12]
 80130b8:	f04f 30ff 	moveq.w	r0, #4294967295
      ucos_timeout = SYS_ARCH_TIMEOUT;  
  return ucos_timeout; 
}
 80130bc:	b004      	add	sp, #16
 80130be:	bd10      	pop	{r4, pc}
 80130c0:	431bde83 	.word	0x431bde83

080130c4 <sys_mbox_valid>:
  * @param sys_mbox_t *mbox pointer mail box
  * @return 1 for valid, 0 for invalid 
  */ 
int sys_mbox_valid(sys_mbox_t *mbox)
{
  if(mbox->NamePtr)  
 80130c4:	6840      	ldr	r0, [r0, #4]
 80130c6:	b138      	cbz	r0, 80130d8 <sys_mbox_valid+0x14>
  * Check if an mbox is valid/allocated: 
  * @param sys_mbox_t *mbox pointer mail box
  * @return 1 for valid, 0 for invalid 
  */ 
int sys_mbox_valid(sys_mbox_t *mbox)
{
 80130c8:	b508      	push	{r3, lr}
  if(mbox->NamePtr)  
    return (strcmp(mbox->NamePtr,"?Q"))? 1:0;
 80130ca:	4904      	ldr	r1, [pc, #16]	; (80130dc <sys_mbox_valid+0x18>)
 80130cc:	f001 fd92 	bl	8014bf4 <strcmp>
 80130d0:	3000      	adds	r0, #0
 80130d2:	bf18      	it	ne
 80130d4:	2001      	movne	r0, #1
  else
    return 0;
}
 80130d6:	bd08      	pop	{r3, pc}
 80130d8:	4770      	bx	lr
 80130da:	bf00      	nop
 80130dc:	0801666c 	.word	0x0801666c

080130e0 <sys_mbox_set_invalid>:
  * @param sys_mbox_t *mbox pointer mail box
  * @return 1 for valid, 0 for invalid 
  */ 
int sys_mbox_valid(sys_mbox_t *mbox)
{
  if(mbox->NamePtr)  
 80130e0:	6843      	ldr	r3, [r0, #4]
 80130e2:	b163      	cbz	r3, 80130fe <sys_mbox_set_invalid+0x1e>
}
/** 
  * Set an mbox invalid so that sys_mbox_valid returns 0 
  */      
void sys_mbox_set_invalid(sys_mbox_t *mbox)
{
 80130e4:	b510      	push	{r4, lr}
  * @return 1 for valid, 0 for invalid 
  */ 
int sys_mbox_valid(sys_mbox_t *mbox)
{
  if(mbox->NamePtr)  
    return (strcmp(mbox->NamePtr,"?Q"))? 1:0;
 80130e6:	4906      	ldr	r1, [pc, #24]	; (8013100 <sys_mbox_set_invalid+0x20>)
 80130e8:	4604      	mov	r4, r0
 80130ea:	4618      	mov	r0, r3
 80130ec:	f001 fd82 	bl	8014bf4 <strcmp>
/** 
  * Set an mbox invalid so that sys_mbox_valid returns 0 
  */      
void sys_mbox_set_invalid(sys_mbox_t *mbox)
{
  if(sys_mbox_valid(mbox))
 80130f0:	b120      	cbz	r0, 80130fc <sys_mbox_set_invalid+0x1c>
    sys_mbox_free(mbox);
 80130f2:	4620      	mov	r0, r4
}
 80130f4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  * Set an mbox invalid so that sys_mbox_valid returns 0 
  */      
void sys_mbox_set_invalid(sys_mbox_t *mbox)
{
  if(sys_mbox_valid(mbox))
    sys_mbox_free(mbox);
 80130f8:	f7ff bf50 	b.w	8012f9c <sys_mbox_free>
 80130fc:	bd10      	pop	{r4, pc}
 80130fe:	4770      	bx	lr
 8013100:	0801666c 	.word	0x0801666c

08013104 <sys_sem_new>:
 *  Creates and returns a new semaphore. The "count" argument specifies
 *  the initial state of the semaphore. TBD finish and test
 */

err_t sys_sem_new(sys_sem_t * sem, u8_t count)
{  
 8013104:	b500      	push	{lr}
 8013106:	b083      	sub	sp, #12
  OS_ERR	ucErr;
  OSSemCreate (sem,"LWIP Sem",count,&ucErr);
 8013108:	460a      	mov	r2, r1
 801310a:	f10d 0306 	add.w	r3, sp, #6
 801310e:	4908      	ldr	r1, [pc, #32]	; (8013130 <sys_sem_new+0x2c>)
 8013110:	f7f2 fe80 	bl	8005e14 <OSSemCreate>
  if(ucErr != OS_ERR_NONE ){
 8013114:	f8bd 0006 	ldrh.w	r0, [sp, #6]
 8013118:	b138      	cbz	r0, 801312a <sys_sem_new+0x26>
    LWIP_ASSERT("OSSemCreate ",ucErr == OS_ERR_NONE );
 801311a:	4b06      	ldr	r3, [pc, #24]	; (8013134 <sys_sem_new+0x30>)
 801311c:	22c6      	movs	r2, #198	; 0xc6
 801311e:	4906      	ldr	r1, [pc, #24]	; (8013138 <sys_sem_new+0x34>)
 8013120:	4806      	ldr	r0, [pc, #24]	; (801313c <sys_sem_new+0x38>)
 8013122:	f001 fe29 	bl	8014d78 <iprintf>
    return -1;    
 8013126:	f04f 30ff 	mov.w	r0, #4294967295
  }
  return 0;
}
 801312a:	b003      	add	sp, #12
 801312c:	f85d fb04 	ldr.w	pc, [sp], #4
 8013130:	080182c0 	.word	0x080182c0
 8013134:	08018260 	.word	0x08018260
 8013138:	080182cc 	.word	0x080182cc
 801313c:	0801660c 	.word	0x0801660c

08013140 <sys_arch_sem_wait>:
u32_t
sys_arch_sem_wait(sys_sem_t *sem, u32_t timeout)
{ 
  OS_ERR	ucErr;
  CPU_TS        ucos_timeout;
  CPU_TS        in_timeout = timeout/LWIP_ARCH_TICK_PER_MS;
 8013140:	4b0e      	ldr	r3, [pc, #56]	; (801317c <sys_arch_sem_wait+0x3c>)
  Notice that lwIP implements a function with a similar name,
  sys_sem_wait(), that uses the sys_arch_sem_wait() function.
*/
u32_t
sys_arch_sem_wait(sys_sem_t *sem, u32_t timeout)
{ 
 8013142:	b500      	push	{lr}
  OS_ERR	ucErr;
  CPU_TS        ucos_timeout;
  CPU_TS        in_timeout = timeout/LWIP_ARCH_TICK_PER_MS;
 8013144:	fba3 2301 	umull	r2, r3, r3, r1
  Notice that lwIP implements a function with a similar name,
  sys_sem_wait(), that uses the sys_arch_sem_wait() function.
*/
u32_t
sys_arch_sem_wait(sys_sem_t *sem, u32_t timeout)
{ 
 8013148:	b085      	sub	sp, #20
  OS_ERR	ucErr;
  CPU_TS        ucos_timeout;
  CPU_TS        in_timeout = timeout/LWIP_ARCH_TICK_PER_MS;
 801314a:	0c9b      	lsrs	r3, r3, #18
  if(timeout && in_timeout == 0)
 801314c:	b111      	cbz	r1, 8013154 <sys_arch_sem_wait+0x14>
    in_timeout = 1;  
 801314e:	2b00      	cmp	r3, #0
 8013150:	bf08      	it	eq
 8013152:	2301      	moveq	r3, #1
  OSSemPend (sem,in_timeout,OS_OPT_PEND_BLOCKING,&ucos_timeout,&ucErr);
 8013154:	f10d 020a 	add.w	r2, sp, #10
 8013158:	4619      	mov	r1, r3
 801315a:	9200      	str	r2, [sp, #0]
 801315c:	ab03      	add	r3, sp, #12
 801315e:	2200      	movs	r2, #0
 8013160:	f7f2 ff3e 	bl	8005fe0 <OSSemPend>
    /*  only when timeout! */
  if(ucErr == OS_ERR_TIMEOUT)
 8013164:	f247 23d9 	movw	r3, #29401	; 0x72d9
 8013168:	f8bd 200a 	ldrh.w	r2, [sp, #10]
 801316c:	429a      	cmp	r2, r3
 801316e:	bf14      	ite	ne
 8013170:	9803      	ldrne	r0, [sp, #12]
 8013172:	f04f 30ff 	moveq.w	r0, #4294967295
      ucos_timeout = SYS_ARCH_TIMEOUT;	
  return ucos_timeout;
}
 8013176:	b005      	add	sp, #20
 8013178:	f85d fb04 	ldr.w	pc, [sp], #4
 801317c:	431bde83 	.word	0x431bde83

08013180 <sys_sem_signal>:
 *       Signals a semaphore
 */

void
sys_sem_signal(sys_sem_t *sem)
{
 8013180:	b500      	push	{lr}
 8013182:	b083      	sub	sp, #12
  OS_ERR	ucErr;  
  OSSemPost(sem,OS_OPT_POST_ALL,&ucErr);
 8013184:	f10d 0206 	add.w	r2, sp, #6
 8013188:	f44f 7100 	mov.w	r1, #512	; 0x200
 801318c:	f7f3 f900 	bl	8006390 <OSSemPost>
  LWIP_ASSERT("OSSemPost ",ucErr == OS_ERR_NONE );  
 8013190:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8013194:	b12b      	cbz	r3, 80131a2 <sys_sem_signal+0x22>
 8013196:	4b04      	ldr	r3, [pc, #16]	; (80131a8 <sys_sem_signal+0x28>)
 8013198:	22f2      	movs	r2, #242	; 0xf2
 801319a:	4904      	ldr	r1, [pc, #16]	; (80131ac <sys_sem_signal+0x2c>)
 801319c:	4804      	ldr	r0, [pc, #16]	; (80131b0 <sys_sem_signal+0x30>)
 801319e:	f001 fdeb 	bl	8014d78 <iprintf>
}
 80131a2:	b003      	add	sp, #12
 80131a4:	f85d fb04 	ldr.w	pc, [sp], #4
 80131a8:	08018260 	.word	0x08018260
 80131ac:	080182dc 	.word	0x080182dc
 80131b0:	0801660c 	.word	0x0801660c

080131b4 <sys_sem_free>:
/*
 *      Deallocates a semaphore
 */
void
sys_sem_free(sys_sem_t *sem)
{
 80131b4:	b500      	push	{lr}
 80131b6:	b083      	sub	sp, #12
    OS_ERR     ucErr;
    OSSemDel(sem, OS_OPT_DEL_ALWAYS, &ucErr );
 80131b8:	f10d 0206 	add.w	r2, sp, #6
 80131bc:	2101      	movs	r1, #1
 80131be:	f7f2 fe69 	bl	8005e94 <OSSemDel>
    LWIP_ASSERT( "OSSemDel ", ucErr == OS_ERR_NONE );
 80131c2:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 80131c6:	b12b      	cbz	r3, 80131d4 <sys_sem_free+0x20>
 80131c8:	4b04      	ldr	r3, [pc, #16]	; (80131dc <sys_sem_free+0x28>)
 80131ca:	22fd      	movs	r2, #253	; 0xfd
 80131cc:	4904      	ldr	r1, [pc, #16]	; (80131e0 <sys_sem_free+0x2c>)
 80131ce:	4805      	ldr	r0, [pc, #20]	; (80131e4 <sys_sem_free+0x30>)
 80131d0:	f001 fdd2 	bl	8014d78 <iprintf>
}
 80131d4:	b003      	add	sp, #12
 80131d6:	f85d fb04 	ldr.w	pc, [sp], #4
 80131da:	bf00      	nop
 80131dc:	08018260 	.word	0x08018260
 80131e0:	080182e8 	.word	0x080182e8
 80131e4:	0801660c 	.word	0x0801660c

080131e8 <sys_sem_valid>:
int sys_sem_valid(sys_sem_t *sem)
{
  if(sem->NamePtr)
 80131e8:	6840      	ldr	r0, [r0, #4]
 80131ea:	b138      	cbz	r0, 80131fc <sys_sem_valid+0x14>
    OS_ERR     ucErr;
    OSSemDel(sem, OS_OPT_DEL_ALWAYS, &ucErr );
    LWIP_ASSERT( "OSSemDel ", ucErr == OS_ERR_NONE );
}
int sys_sem_valid(sys_sem_t *sem)
{
 80131ec:	b508      	push	{r3, lr}
  if(sem->NamePtr)
    return (strcmp(sem->NamePtr,"?SEM"))? 1:0;
 80131ee:	4904      	ldr	r1, [pc, #16]	; (8013200 <sys_sem_valid+0x18>)
 80131f0:	f001 fd00 	bl	8014bf4 <strcmp>
 80131f4:	3000      	adds	r0, #0
 80131f6:	bf18      	it	ne
 80131f8:	2001      	movne	r0, #1
  else
    return 0;
}
 80131fa:	bd08      	pop	{r3, pc}
 80131fc:	4770      	bx	lr
 80131fe:	bf00      	nop
 8013200:	08016670 	.word	0x08016670

08013204 <sys_sem_set_invalid>:
    OSSemDel(sem, OS_OPT_DEL_ALWAYS, &ucErr );
    LWIP_ASSERT( "OSSemDel ", ucErr == OS_ERR_NONE );
}
int sys_sem_valid(sys_sem_t *sem)
{
  if(sem->NamePtr)
 8013204:	6843      	ldr	r3, [r0, #4]
 8013206:	b163      	cbz	r3, 8013222 <sys_sem_set_invalid+0x1e>
    return 0;
}

/** Set a semaphore invalid so that sys_sem_valid returns 0 */
void sys_sem_set_invalid(sys_sem_t *sem)
{
 8013208:	b510      	push	{r4, lr}
    LWIP_ASSERT( "OSSemDel ", ucErr == OS_ERR_NONE );
}
int sys_sem_valid(sys_sem_t *sem)
{
  if(sem->NamePtr)
    return (strcmp(sem->NamePtr,"?SEM"))? 1:0;
 801320a:	4906      	ldr	r1, [pc, #24]	; (8013224 <sys_sem_set_invalid+0x20>)
 801320c:	4604      	mov	r4, r0
 801320e:	4618      	mov	r0, r3
 8013210:	f001 fcf0 	bl	8014bf4 <strcmp>
}

/** Set a semaphore invalid so that sys_sem_valid returns 0 */
void sys_sem_set_invalid(sys_sem_t *sem)
{
  if(sys_sem_valid(sem))
 8013214:	b120      	cbz	r0, 8013220 <sys_sem_set_invalid+0x1c>
    sys_sem_free(sem);
 8013216:	4620      	mov	r0, r4
}
 8013218:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

/** Set a semaphore invalid so that sys_sem_valid returns 0 */
void sys_sem_set_invalid(sys_sem_t *sem)
{
  if(sys_sem_valid(sem))
    sys_sem_free(sem);
 801321c:	f7ff bfca 	b.w	80131b4 <sys_sem_free>
 8013220:	bd10      	pop	{r4, pc}
 8013222:	4770      	bx	lr
 8013224:	08016670 	.word	0x08016670

08013228 <sys_init>:
/*
 * Initialize sys arch
 */
void
sys_init(void)
{
 8013228:	b500      	push	{lr}
  OS_ERR ucErr;
  memset(LwIP_task_priopity_stask,0,sizeof(LwIP_task_priopity_stask));
 801322a:	2203      	movs	r2, #3
/*
 * Initialize sys arch
 */
void
sys_init(void)
{
 801322c:	b085      	sub	sp, #20
  OS_ERR ucErr;
  memset(LwIP_task_priopity_stask,0,sizeof(LwIP_task_priopity_stask));
 801322e:	2100      	movs	r1, #0
 8013230:	480d      	ldr	r0, [pc, #52]	; (8013268 <sys_init+0x40>)
 8013232:	f001 fd99 	bl	8014d68 <memset>
  /* init mem used by sys_mbox_t, use ucosII functions */
  OSMemCreate(&StackMem,"LWIP TASK STK",(void*)LwIP_Task_Stk,LWIP_TASK_MAX,LWIP_STK_SIZE*sizeof(CPU_STK),&ucErr);
 8013236:	f10d 020e 	add.w	r2, sp, #14
 801323a:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 801323e:	9201      	str	r2, [sp, #4]
 8013240:	9300      	str	r3, [sp, #0]
 8013242:	4a0a      	ldr	r2, [pc, #40]	; (801326c <sys_init+0x44>)
 8013244:	2303      	movs	r3, #3
 8013246:	490a      	ldr	r1, [pc, #40]	; (8013270 <sys_init+0x48>)
 8013248:	480a      	ldr	r0, [pc, #40]	; (8013274 <sys_init+0x4c>)
 801324a:	f7f1 fec9 	bl	8004fe0 <OSMemCreate>
  LWIP_ASSERT( "sys_init: failed OSMemCreate STK", ucErr == OS_ERR_NONE );
 801324e:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 8013252:	b133      	cbz	r3, 8013262 <sys_init+0x3a>
 8013254:	4b08      	ldr	r3, [pc, #32]	; (8013278 <sys_init+0x50>)
 8013256:	f44f 728e 	mov.w	r2, #284	; 0x11c
 801325a:	4908      	ldr	r1, [pc, #32]	; (801327c <sys_init+0x54>)
 801325c:	4808      	ldr	r0, [pc, #32]	; (8013280 <sys_init+0x58>)
 801325e:	f001 fd8b 	bl	8014d78 <iprintf>
}
 8013262:	b005      	add	sp, #20
 8013264:	f85d fb04 	ldr.w	pc, [sp], #4
 8013268:	200131a4 	.word	0x200131a4
 801326c:	200133f4 	.word	0x200133f4
 8013270:	080182f4 	.word	0x080182f4
 8013274:	20004ca8 	.word	0x20004ca8
 8013278:	08018260 	.word	0x08018260
 801327c:	08018304 	.word	0x08018304
 8013280:	0801660c 	.word	0x0801660c

08013284 <sys_thread_new>:
  function "thread()". The "arg" argument will be passed as an argument to the
  thread() function. The id of the new thread is returned. Both the id and
  the priority are system dependent.
*/
sys_thread_t sys_thread_new(const char *name, lwip_thread_fn thread, void *arg, int stacksize, int prio)
{
 8013284:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8013288:	b08d      	sub	sp, #52	; 0x34
 801328a:	9c14      	ldr	r4, [sp, #80]	; 0x50
 801328c:	4607      	mov	r7, r0
 801328e:	4688      	mov	r8, r1
 8013290:	4699      	mov	r9, r3

    arg = arg;
    if(prio){
      ubPrio +=(prio-1);
      for(i=0; i<LWIP_TASK_MAX; ++i)
        if(LwIP_task_priopity_stask[i] == ubPrio)
 8013292:	4e41      	ldr	r6, [pc, #260]	; (8013398 <sys_thread_new+0x114>)
    int tsk_prio;
    
    int i; 

    arg = arg;
    if(prio){
 8013294:	b1d4      	cbz	r4, 80132cc <sys_thread_new+0x48>
      ubPrio +=(prio-1);
 8013296:	340a      	adds	r4, #10
      for(i=0; i<LWIP_TASK_MAX; ++i)
        if(LwIP_task_priopity_stask[i] == ubPrio)
 8013298:	7833      	ldrb	r3, [r6, #0]
    
    int i; 

    arg = arg;
    if(prio){
      ubPrio +=(prio-1);
 801329a:	b2e4      	uxtb	r4, r4
      for(i=0; i<LWIP_TASK_MAX; ++i)
        if(LwIP_task_priopity_stask[i] == ubPrio)
 801329c:	42a3      	cmp	r3, r4
 801329e:	d015      	beq.n	80132cc <sys_thread_new+0x48>
 80132a0:	7872      	ldrb	r2, [r6, #1]
 80132a2:	42a2      	cmp	r2, r4
 80132a4:	d012      	beq.n	80132cc <sys_thread_new+0x48>
 80132a6:	78b1      	ldrb	r1, [r6, #2]
 80132a8:	428c      	cmp	r4, r1
 80132aa:	d00f      	beq.n	80132cc <sys_thread_new+0x48>
          break;
      if(i == LWIP_TASK_MAX){
        for(i=0; i<LWIP_TASK_MAX; ++i)
          if(LwIP_task_priopity_stask[i]==0){
 80132ac:	2b00      	cmp	r3, #0
 80132ae:	d02e      	beq.n	801330e <sys_thread_new+0x8a>
 80132b0:	b362      	cbz	r2, 801330c <sys_thread_new+0x88>
      ubPrio +=(prio-1);
      for(i=0; i<LWIP_TASK_MAX; ++i)
        if(LwIP_task_priopity_stask[i] == ubPrio)
          break;
      if(i == LWIP_TASK_MAX){
        for(i=0; i<LWIP_TASK_MAX; ++i)
 80132b2:	2302      	movs	r3, #2
          if(LwIP_task_priopity_stask[i]==0){
 80132b4:	b359      	cbz	r1, 801330e <sys_thread_new+0x8a>
            LwIP_task_priopity_stask[i] = ubPrio;
            break;
          }
        if(i == LWIP_TASK_MAX){
          LWIP_ASSERT( "sys_thread_new: there is no space for priority", 0 );
 80132b6:	4b39      	ldr	r3, [pc, #228]	; (801339c <sys_thread_new+0x118>)
 80132b8:	f240 1241 	movw	r2, #321	; 0x141
 80132bc:	4938      	ldr	r1, [pc, #224]	; (80133a0 <sys_thread_new+0x11c>)
 80132be:	4839      	ldr	r0, [pc, #228]	; (80133a4 <sys_thread_new+0x120>)
 80132c0:	f001 fd5a 	bl	8014d78 <iprintf>
          return (-1);
 80132c4:	20ff      	movs	r0, #255	; 0xff
                 (void      *)0,
                 (OS_OPT     )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR),
                 (OS_ERR    *)&ucErr);    
    
    return ubPrio;
}
 80132c6:	b00d      	add	sp, #52	; 0x34
 80132c8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  /* Search for a suitable priority */     
    if(!prio){
      ubPrio = LWIP_TASK_START_PRIO;
      while(ubPrio < (LWIP_TASK_START_PRIO+LWIP_TASK_MAX)){ 
        for(i=0; i<LWIP_TASK_MAX; ++i)
          if(LwIP_task_priopity_stask[i] == ubPrio){
 80132cc:	7831      	ldrb	r1, [r6, #0]
 80132ce:	7870      	ldrb	r0, [r6, #1]
 80132d0:	78b5      	ldrb	r5, [r6, #2]
 80132d2:	240b      	movs	r4, #11
 80132d4:	428c      	cmp	r4, r1
 80132d6:	d014      	beq.n	8013302 <sys_thread_new+0x7e>
 80132d8:	4284      	cmp	r4, r0
 80132da:	d012      	beq.n	8013302 <sys_thread_new+0x7e>
 80132dc:	42ac      	cmp	r4, r5
 80132de:	d010      	beq.n	8013302 <sys_thread_new+0x7e>
        if(i == LWIP_TASK_MAX)
          break;
      }
      if(ubPrio < (LWIP_TASK_START_PRIO+LWIP_TASK_MAX))
        for(i=0; i<LWIP_TASK_MAX; ++i)
          if(LwIP_task_priopity_stask[i]==0){
 80132e0:	2900      	cmp	r1, #0
 80132e2:	d053      	beq.n	801338c <sys_thread_new+0x108>
 80132e4:	2800      	cmp	r0, #0
 80132e6:	d053      	beq.n	8013390 <sys_thread_new+0x10c>
 80132e8:	2d00      	cmp	r5, #0
 80132ea:	d04e      	beq.n	801338a <sys_thread_new+0x106>
            LwIP_task_priopity_stask[i] = ubPrio;
            break;
          }
      if(ubPrio >= (LWIP_TASK_START_PRIO+LWIP_TASK_MAX) || i == LWIP_TASK_MAX){
        LWIP_ASSERT( "sys_thread_new: there is no free priority", 0 );
 80132ec:	4b2b      	ldr	r3, [pc, #172]	; (801339c <sys_thread_new+0x118>)
 80132ee:	f44f 72ad 	mov.w	r2, #346	; 0x15a
 80132f2:	492d      	ldr	r1, [pc, #180]	; (80133a8 <sys_thread_new+0x124>)
 80132f4:	482b      	ldr	r0, [pc, #172]	; (80133a4 <sys_thread_new+0x120>)
 80132f6:	f001 fd3f 	bl	8014d78 <iprintf>
        return (-1);
 80132fa:	20ff      	movs	r0, #255	; 0xff
                 (void      *)0,
                 (OS_OPT     )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR),
                 (OS_ERR    *)&ucErr);    
    
    return ubPrio;
}
 80132fc:	b00d      	add	sp, #52	; 0x34
 80132fe:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if(!prio){
      ubPrio = LWIP_TASK_START_PRIO;
      while(ubPrio < (LWIP_TASK_START_PRIO+LWIP_TASK_MAX)){ 
        for(i=0; i<LWIP_TASK_MAX; ++i)
          if(LwIP_task_priopity_stask[i] == ubPrio){
            ++ubPrio;
 8013302:	3401      	adds	r4, #1
 8013304:	b2e4      	uxtb	r4, r4
        prio = 0;
    }
  /* Search for a suitable priority */     
    if(!prio){
      ubPrio = LWIP_TASK_START_PRIO;
      while(ubPrio < (LWIP_TASK_START_PRIO+LWIP_TASK_MAX)){ 
 8013306:	2c0e      	cmp	r4, #14
 8013308:	d1e4      	bne.n	80132d4 <sys_thread_new+0x50>
 801330a:	e7ef      	b.n	80132ec <sys_thread_new+0x68>
      ubPrio +=(prio-1);
      for(i=0; i<LWIP_TASK_MAX; ++i)
        if(LwIP_task_priopity_stask[i] == ubPrio)
          break;
      if(i == LWIP_TASK_MAX){
        for(i=0; i<LWIP_TASK_MAX; ++i)
 801330c:	2301      	movs	r3, #1
          if(LwIP_task_priopity_stask[i]==0){
            LwIP_task_priopity_stask[i] = ubPrio;
 801330e:	54f4      	strb	r4, [r6, r3]
      if(ubPrio >= (LWIP_TASK_START_PRIO+LWIP_TASK_MAX) || i == LWIP_TASK_MAX){
        LWIP_ASSERT( "sys_thread_new: there is no free priority", 0 );
        return (-1);
      }
    }
    if(stacksize > LWIP_STK_SIZE || !stacksize)   
 8013310:	f5b9 6fa0 	cmp.w	r9, #1280	; 0x500
 8013314:	dc17      	bgt.n	8013346 <sys_thread_new+0xc2>
        stacksize = LWIP_STK_SIZE;
 8013316:	f1b9 0f00 	cmp.w	r9, #0
 801331a:	bf08      	it	eq
 801331c:	f44f 69a0 	moveq.w	r9, #1280	; 0x500
  /* get Stack from pool */
    task_stk = OSMemGet( &StackMem, &ucErr );
 8013320:	f10d 012e 	add.w	r1, sp, #46	; 0x2e
 8013324:	4821      	ldr	r0, [pc, #132]	; (80133ac <sys_thread_new+0x128>)
 8013326:	f7f1 fec7 	bl	80050b8 <OSMemGet>
    if(ucErr != OS_ERR_NONE){
 801332a:	f8bd 302e 	ldrh.w	r3, [sp, #46]	; 0x2e
 801332e:	b16b      	cbz	r3, 801334c <sys_thread_new+0xc8>
      LWIP_ASSERT( "sys_thread_new: impossible to get a stack", 0 );
 8013330:	4b1a      	ldr	r3, [pc, #104]	; (801339c <sys_thread_new+0x118>)
 8013332:	f240 1263 	movw	r2, #355	; 0x163
 8013336:	491e      	ldr	r1, [pc, #120]	; (80133b0 <sys_thread_new+0x12c>)
 8013338:	481a      	ldr	r0, [pc, #104]	; (80133a4 <sys_thread_new+0x120>)
 801333a:	f001 fd1d 	bl	8014d78 <iprintf>
      return (-1);
 801333e:	20ff      	movs	r0, #255	; 0xff
                 (void      *)0,
                 (OS_OPT     )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR),
                 (OS_ERR    *)&ucErr);    
    
    return ubPrio;
}
 8013340:	b00d      	add	sp, #52	; 0x34
 8013342:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        LWIP_ASSERT( "sys_thread_new: there is no free priority", 0 );
        return (-1);
      }
    }
    if(stacksize > LWIP_STK_SIZE || !stacksize)   
        stacksize = LWIP_STK_SIZE;
 8013346:	f44f 69a0 	mov.w	r9, #1280	; 0x500
 801334a:	e7e9      	b.n	8013320 <sys_thread_new+0x9c>
      LWIP_ASSERT( "sys_thread_new: impossible to get a stack", 0 );
      return (-1);
    } 

    tsk_prio = ubPrio-LWIP_TASK_START_PRIO;
    OSTaskCreate(&LwIP_task_TCB[tsk_prio],
 801334c:	4d19      	ldr	r5, [pc, #100]	; (80133b4 <sys_thread_new+0x130>)
 801334e:	f10d 022e 	add.w	r2, sp, #46	; 0x2e
 8013352:	9208      	str	r2, [sp, #32]
 8013354:	fba5 2509 	umull	r2, r5, r5, r9
 8013358:	4e17      	ldr	r6, [pc, #92]	; (80133b8 <sys_thread_new+0x134>)
 801335a:	08ed      	lsrs	r5, r5, #3
 801335c:	f1a4 0e0b 	sub.w	lr, r4, #11
 8013360:	9001      	str	r0, [sp, #4]
 8013362:	9502      	str	r5, [sp, #8]
 8013364:	20c4      	movs	r0, #196	; 0xc4
 8013366:	2503      	movs	r5, #3
 8013368:	fb00 600e 	mla	r0, r0, lr, r6
 801336c:	9306      	str	r3, [sp, #24]
 801336e:	9305      	str	r3, [sp, #20]
 8013370:	9304      	str	r3, [sp, #16]
 8013372:	f8cd 900c 	str.w	r9, [sp, #12]
 8013376:	9400      	str	r4, [sp, #0]
 8013378:	4642      	mov	r2, r8
 801337a:	4639      	mov	r1, r7
 801337c:	9507      	str	r5, [sp, #28]
 801337e:	f7f3 fe45 	bl	800700c <OSTaskCreate>
                 (OS_TICK    )0,
                 (void      *)0,
                 (OS_OPT     )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR),
                 (OS_ERR    *)&ucErr);    
    
    return ubPrio;
 8013382:	4620      	mov	r0, r4
}
 8013384:	b00d      	add	sp, #52	; 0x34
 8013386:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
          }
        if(i == LWIP_TASK_MAX)
          break;
      }
      if(ubPrio < (LWIP_TASK_START_PRIO+LWIP_TASK_MAX))
        for(i=0; i<LWIP_TASK_MAX; ++i)
 801338a:	2102      	movs	r1, #2
          if(LwIP_task_priopity_stask[i]==0){
            LwIP_task_priopity_stask[i] = ubPrio;
 801338c:	5474      	strb	r4, [r6, r1]
 801338e:	e7bf      	b.n	8013310 <sys_thread_new+0x8c>
          }
        if(i == LWIP_TASK_MAX)
          break;
      }
      if(ubPrio < (LWIP_TASK_START_PRIO+LWIP_TASK_MAX))
        for(i=0; i<LWIP_TASK_MAX; ++i)
 8013390:	2101      	movs	r1, #1
          if(LwIP_task_priopity_stask[i]==0){
            LwIP_task_priopity_stask[i] = ubPrio;
 8013392:	5474      	strb	r4, [r6, r1]
 8013394:	e7bc      	b.n	8013310 <sys_thread_new+0x8c>
 8013396:	bf00      	nop
 8013398:	200131a4 	.word	0x200131a4
 801339c:	08018260 	.word	0x08018260
 80133a0:	08018328 	.word	0x08018328
 80133a4:	0801660c 	.word	0x0801660c
 80133a8:	08018358 	.word	0x08018358
 80133ac:	20004ca8 	.word	0x20004ca8
 80133b0:	08018384 	.word	0x08018384
 80133b4:	cccccccd 	.word	0xcccccccd
 80133b8:	200131a8 	.word	0x200131a8

080133bc <sys_msleep>:
 *
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
 80133bc:	b500      	push	{lr}
 80133be:	b083      	sub	sp, #12
  OS_ERR      ucErr;  
  OSTimeDly(ms,OS_OPT_TIME_DLY,&ucErr);  
 80133c0:	f10d 0206 	add.w	r2, sp, #6
 80133c4:	2100      	movs	r1, #0
 80133c6:	f7f4 fb4f 	bl	8007a68 <OSTimeDly>
}
 80133ca:	b003      	add	sp, #12
 80133cc:	f85d fb04 	ldr.w	pc, [sp], #4

080133d0 <tcp_receive>:
 *
 * Called from tcp_process().
 */
static void
tcp_receive(struct tcp_pcb *pcb)
{
 80133d0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
#if TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS
  u32_t ooseq_blen;
  u16_t ooseq_qlen;
#endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */

  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
 80133d4:	7e03      	ldrb	r3, [r0, #24]
 *
 * Called from tcp_process().
 */
static void
tcp_receive(struct tcp_pcb *pcb)
{
 80133d6:	4604      	mov	r4, r0
#if TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS
  u32_t ooseq_blen;
  u16_t ooseq_qlen;
#endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */

  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
 80133d8:	2b03      	cmp	r3, #3
 80133da:	f240 80c9 	bls.w	8013570 <tcp_receive+0x1a0>

  if (flags & TCP_ACK) {
 80133de:	4fb1      	ldr	r7, [pc, #708]	; (80136a4 <tcp_receive+0x2d4>)
 80133e0:	783b      	ldrb	r3, [r7, #0]
 80133e2:	06dd      	lsls	r5, r3, #27
 80133e4:	d56a      	bpl.n	80134bc <tcp_receive+0xec>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 80133e6:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80133e8:	687a      	ldr	r2, [r7, #4]
#endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */

  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
 80133ea:	f8b4 5060 	ldrh.w	r5, [r4, #96]	; 0x60

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 80133ee:	1a99      	subs	r1, r3, r2
 80133f0:	2900      	cmp	r1, #0
#endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */

  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
 80133f2:	6da0      	ldr	r0, [r4, #88]	; 0x58

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 80133f4:	f2c0 80c4 	blt.w	8013580 <tcp_receive+0x1b0>
 80133f8:	4293      	cmp	r3, r2
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 80133fa:	68bb      	ldr	r3, [r7, #8]

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
 80133fc:	f000 81af 	beq.w	801375e <tcp_receive+0x38e>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 8013400:	4298      	cmp	r0, r3
 8013402:	f000 81b3 	beq.w	801376c <tcp_receive+0x39c>
     * If it only passes 1, should reset dupack counter
     *
     */

    /* Clause 1 */
    if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
 8013406:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 8013408:	1a5a      	subs	r2, r3, r1
 801340a:	2a00      	cmp	r2, #0
 801340c:	f340 818f 	ble.w	801372e <tcp_receive+0x35e>
      /* If Clause (1) or more is true, but not a duplicate ack, reset
       * count of consecutive duplicate acks */
      if (!found_dupack) {
        pcb->dupacks = 0;
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)){
 8013410:	6d21      	ldr	r1, [r4, #80]	; 0x50
 8013412:	1a59      	subs	r1, r3, r1
 8013414:	2900      	cmp	r1, #0
 8013416:	f340 80ce 	ble.w	80135b6 <tcp_receive+0x1e6>
        pcb->rtime = 0;

      pcb->polltmr = 0;
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
 801341a:	2300      	movs	r3, #0
 801341c:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
 8013420:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
 8013422:	f8df 8280 	ldr.w	r8, [pc, #640]	; 80136a4 <tcp_receive+0x2d4>
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
 8013426:	2b00      	cmp	r3, #0
 8013428:	d040      	beq.n	80134ac <tcp_receive+0xdc>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
 801342a:	68db      	ldr	r3, [r3, #12]
 801342c:	68bd      	ldr	r5, [r7, #8]
 801342e:	6858      	ldr	r0, [r3, #4]
 8013430:	f7fa fbba 	bl	800dba8 <lwip_ntohl>
 8013434:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8013436:	4681      	mov	r9, r0
 8013438:	68da      	ldr	r2, [r3, #12]
 801343a:	891e      	ldrh	r6, [r3, #8]
 801343c:	8990      	ldrh	r0, [r2, #12]
 801343e:	f7fa fbaf 	bl	800dba0 <lwip_ntohs>
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
 8013442:	f010 0003 	ands.w	r0, r0, #3
 8013446:	bf18      	it	ne
 8013448:	2001      	movne	r0, #1
 801344a:	ebc9 0505 	rsb	r5, r9, r5
 801344e:	4406      	add	r6, r0
 8013450:	1bad      	subs	r5, r5, r6
 8013452:	2d00      	cmp	r5, #0
 8013454:	db2a      	blt.n	80134ac <tcp_receive+0xdc>
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + 
 8013456:	f8d8 3008 	ldr.w	r3, [r8, #8]
 801345a:	6d22      	ldr	r2, [r4, #80]	; 0x50
 801345c:	1a9b      	subs	r3, r3, r2
 801345e:	2b00      	cmp	r3, #0
 8013460:	dc24      	bgt.n	80134ac <tcp_receive+0xdc>
                           TCP_TCPLEN(pcb->unsent), pcb->snd_nxt)) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
 8013462:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
      pcb->unsent = pcb->unsent->next;
 8013464:	682b      	ldr	r3, [r5, #0]
 8013466:	66e3      	str	r3, [r4, #108]	; 0x6c
#if TCP_OVERSIZE
      if (pcb->unsent == NULL) {
 8013468:	2b00      	cmp	r3, #0
 801346a:	d072      	beq.n	8013552 <tcp_receive+0x182>
        pcb->unsent_oversize = 0;
      }
#endif /* TCP_OVERSIZE */ 
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 801346c:	6868      	ldr	r0, [r5, #4]
 801346e:	f8b4 6068 	ldrh.w	r6, [r4, #104]	; 0x68
 8013472:	f7fc ff7f 	bl	8010374 <pbuf_clen>
 8013476:	b280      	uxth	r0, r0
 8013478:	4286      	cmp	r6, r0
 801347a:	d362      	bcc.n	8013542 <tcp_receive+0x172>
      /* Prevent ACK for FIN to generate a sent event */
      if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
 801347c:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
 8013480:	2b00      	cmp	r3, #0
 8013482:	d152      	bne.n	801352a <tcp_receive+0x15a>
        pcb->acked--;
      }
      pcb->snd_queuelen -= pbuf_clen(next->p);
 8013484:	6868      	ldr	r0, [r5, #4]
 8013486:	f7fc ff75 	bl	8010374 <pbuf_clen>
 801348a:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
 801348e:	1a18      	subs	r0, r3, r0
 8013490:	f8a4 0068 	strh.w	r0, [r4, #104]	; 0x68
      tcp_seg_free(next);
 8013494:	4628      	mov	r0, r5
 8013496:	f7f6 f9e3 	bl	8009860 <tcp_seg_free>
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
      if (pcb->snd_queuelen != 0) {
 801349a:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
 801349e:	b113      	cbz	r3, 80134a6 <tcp_receive+0xd6>
        LWIP_ASSERT("tcp_receive: valid queue length",
 80134a0:	6f23      	ldr	r3, [r4, #112]	; 0x70
 80134a2:	2b00      	cmp	r3, #0
 80134a4:	d058      	beq.n	8013558 <tcp_receive+0x188>
 80134a6:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
 80134a8:	2b00      	cmp	r3, #0
 80134aa:	d1be      	bne.n	801342a <tcp_receive+0x5a>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
 80134ac:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80134ae:	b12b      	cbz	r3, 80134bc <tcp_receive+0xec>
 80134b0:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 80134b2:	68b9      	ldr	r1, [r7, #8]
 80134b4:	1a52      	subs	r2, r2, r1
 80134b6:	2a00      	cmp	r2, #0
 80134b8:	f2c0 8100 	blt.w	80136bc <tcp_receive+0x2ec>

  /* If the incoming segment contains data, we must process it
     further unless the pcb already received a FIN.
     (RFC 793, chapeter 3.9, "SEGMENT ARRIVES" in states CLOSE-WAIT, CLOSING,
     LAST-ACK and TIME-WAIT: "Ignore the segment text.") */
  if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
 80134bc:	8a3b      	ldrh	r3, [r7, #16]
 80134be:	4a79      	ldr	r2, [pc, #484]	; (80136a4 <tcp_receive+0x2d4>)
 80134c0:	b113      	cbz	r3, 80134c8 <tcp_receive+0xf8>
 80134c2:	7e21      	ldrb	r1, [r4, #24]
 80134c4:	2906      	cmp	r1, #6
 80134c6:	d912      	bls.n	80134ee <tcp_receive+0x11e>
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
 80134c8:	687b      	ldr	r3, [r7, #4]
 80134ca:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 80134cc:	1a5a      	subs	r2, r3, r1
 80134ce:	2a00      	cmp	r2, #0
 80134d0:	db05      	blt.n	80134de <tcp_receive+0x10e>
 80134d2:	1c5a      	adds	r2, r3, #1
 80134d4:	8da0      	ldrh	r0, [r4, #44]	; 0x2c
 80134d6:	1a53      	subs	r3, r2, r1
 80134d8:	1a1b      	subs	r3, r3, r0
 80134da:	2b00      	cmp	r3, #0
 80134dc:	dd05      	ble.n	80134ea <tcp_receive+0x11a>
      tcp_ack_now(pcb);
 80134de:	7fa3      	ldrb	r3, [r4, #30]
 80134e0:	f043 0302 	orr.w	r3, r3, #2
 80134e4:	77a3      	strb	r3, [r4, #30]
    }
  }
}
 80134e6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80134ea:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
 80134ee:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 80134f0:	6850      	ldr	r0, [r2, #4]
 80134f2:	ebc0 0801 	rsb	r8, r0, r1
 80134f6:	f1b8 0f01 	cmp.w	r8, #1
 80134fa:	d405      	bmi.n	8013508 <tcp_receive+0x138>
 80134fc:	1c4d      	adds	r5, r1, #1
 80134fe:	1a2d      	subs	r5, r5, r0
 8013500:	1aeb      	subs	r3, r5, r3
 8013502:	2b00      	cmp	r3, #0
 8013504:	f340 813d 	ble.w	8013782 <tcp_receive+0x3b2>
      }
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
 8013508:	1a43      	subs	r3, r0, r1
 801350a:	2b00      	cmp	r3, #0
 801350c:	f2c0 80f6 	blt.w	80136fc <tcp_receive+0x32c>
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
 8013510:	8da3      	ldrh	r3, [r4, #44]	; 0x2c
 8013512:	f1c3 0301 	rsb	r3, r3, #1
 8013516:	4403      	add	r3, r0
 8013518:	1a5b      	subs	r3, r3, r1
 801351a:	2b00      	cmp	r3, #0
 801351c:	f340 812d 	ble.w	801377a <tcp_receive+0x3aa>
        /* Acknowledge the segment(s). */
        tcp_ack(pcb);

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_send_empty_ack(pcb);
 8013520:	4620      	mov	r0, r4
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
      tcp_ack_now(pcb);
    }
  }
}
 8013522:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
        /* Acknowledge the segment(s). */
        tcp_ack(pcb);

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_send_empty_ack(pcb);
 8013526:	f7f7 bbed 	b.w	800ad04 <tcp_send_empty_ack>
      }
#endif /* TCP_OVERSIZE */ 
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
      /* Prevent ACK for FIN to generate a sent event */
      if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
 801352a:	68eb      	ldr	r3, [r5, #12]
 801352c:	8998      	ldrh	r0, [r3, #12]
 801352e:	f7fa fb37 	bl	800dba0 <lwip_ntohs>
 8013532:	07c3      	lsls	r3, r0, #31
 8013534:	d5a6      	bpl.n	8013484 <tcp_receive+0xb4>
        pcb->acked--;
 8013536:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
 801353a:	3b01      	subs	r3, #1
 801353c:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
 8013540:	e7a0      	b.n	8013484 <tcp_receive+0xb4>
      if (pcb->unsent == NULL) {
        pcb->unsent_oversize = 0;
      }
#endif /* TCP_OVERSIZE */ 
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 8013542:	4b59      	ldr	r3, [pc, #356]	; (80136a8 <tcp_receive+0x2d8>)
 8013544:	f240 422e 	movw	r2, #1070	; 0x42e
 8013548:	4958      	ldr	r1, [pc, #352]	; (80136ac <tcp_receive+0x2dc>)
 801354a:	4859      	ldr	r0, [pc, #356]	; (80136b0 <tcp_receive+0x2e0>)
 801354c:	f001 fc14 	bl	8014d78 <iprintf>
 8013550:	e794      	b.n	801347c <tcp_receive+0xac>

      next = pcb->unsent;
      pcb->unsent = pcb->unsent->next;
#if TCP_OVERSIZE
      if (pcb->unsent == NULL) {
        pcb->unsent_oversize = 0;
 8013552:	f8a4 306a 	strh.w	r3, [r4, #106]	; 0x6a
 8013556:	e789      	b.n	801346c <tcp_receive+0x9c>
      }
      pcb->snd_queuelen -= pbuf_clen(next->p);
      tcp_seg_free(next);
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
      if (pcb->snd_queuelen != 0) {
        LWIP_ASSERT("tcp_receive: valid queue length",
 8013558:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 801355a:	2b00      	cmp	r3, #0
 801355c:	f47f af63 	bne.w	8013426 <tcp_receive+0x56>
 8013560:	4b51      	ldr	r3, [pc, #324]	; (80136a8 <tcp_receive+0x2d8>)
 8013562:	f44f 6287 	mov.w	r2, #1080	; 0x438
 8013566:	4953      	ldr	r1, [pc, #332]	; (80136b4 <tcp_receive+0x2e4>)
 8013568:	4851      	ldr	r0, [pc, #324]	; (80136b0 <tcp_receive+0x2e0>)
 801356a:	f001 fc05 	bl	8014d78 <iprintf>
 801356e:	e79a      	b.n	80134a6 <tcp_receive+0xd6>
#if TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS
  u32_t ooseq_blen;
  u16_t ooseq_qlen;
#endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */

  LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
 8013570:	4b4d      	ldr	r3, [pc, #308]	; (80136a8 <tcp_receive+0x2d8>)
 8013572:	f44f 7258 	mov.w	r2, #864	; 0x360
 8013576:	4950      	ldr	r1, [pc, #320]	; (80136b8 <tcp_receive+0x2e8>)
 8013578:	484d      	ldr	r0, [pc, #308]	; (80136b0 <tcp_receive+0x2e0>)
 801357a:	f001 fbfd 	bl	8014d78 <iprintf>
 801357e:	e72e      	b.n	80133de <tcp_receive+0xe>
 8013580:	68f9      	ldr	r1, [r7, #12]
 8013582:	68bb      	ldr	r3, [r7, #8]
 8013584:	89c9      	ldrh	r1, [r1, #14]
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
      pcb->snd_wnd = tcphdr->wnd;
      /* keep track of the biggest window announced by the remote host to calculate
         the maximum segment size */
      if (pcb->snd_wnd_max < tcphdr->wnd) {
 8013586:	f8b4 6062 	ldrh.w	r6, [r4, #98]	; 0x62
        pcb->snd_wnd_max = tcphdr->wnd;
      }
      pcb->snd_wl1 = seqno;
 801358a:	6562      	str	r2, [r4, #84]	; 0x54
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
      pcb->snd_wnd = tcphdr->wnd;
      /* keep track of the biggest window announced by the remote host to calculate
         the maximum segment size */
      if (pcb->snd_wnd_max < tcphdr->wnd) {
 801358c:	428e      	cmp	r6, r1

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
      pcb->snd_wnd = tcphdr->wnd;
 801358e:	f8a4 1060 	strh.w	r1, [r4, #96]	; 0x60
      /* keep track of the biggest window announced by the remote host to calculate
         the maximum segment size */
      if (pcb->snd_wnd_max < tcphdr->wnd) {
        pcb->snd_wnd_max = tcphdr->wnd;
 8013592:	bf38      	it	cc
 8013594:	f8a4 1062 	strhcc.w	r1, [r4, #98]	; 0x62
      }
      pcb->snd_wl1 = seqno;
      pcb->snd_wl2 = ackno;
 8013598:	65a3      	str	r3, [r4, #88]	; 0x58
      if (pcb->snd_wnd == 0) {
        if (pcb->persist_backoff == 0) {
 801359a:	f894 2091 	ldrb.w	r2, [r4, #145]	; 0x91
      if (pcb->snd_wnd_max < tcphdr->wnd) {
        pcb->snd_wnd_max = tcphdr->wnd;
      }
      pcb->snd_wl1 = seqno;
      pcb->snd_wl2 = ackno;
      if (pcb->snd_wnd == 0) {
 801359e:	2900      	cmp	r1, #0
 80135a0:	f040 80d6 	bne.w	8013750 <tcp_receive+0x380>
        if (pcb->persist_backoff == 0) {
 80135a4:	2a00      	cmp	r2, #0
 80135a6:	f47f af2e 	bne.w	8013406 <tcp_receive+0x36>
          /* start persist timer */
          pcb->persist_cnt = 0;
          pcb->persist_backoff = 1;
 80135aa:	2201      	movs	r2, #1
      pcb->snd_wl1 = seqno;
      pcb->snd_wl2 = ackno;
      if (pcb->snd_wnd == 0) {
        if (pcb->persist_backoff == 0) {
          /* start persist timer */
          pcb->persist_cnt = 0;
 80135ac:	f884 1090 	strb.w	r1, [r4, #144]	; 0x90
          pcb->persist_backoff = 1;
 80135b0:	f884 2091 	strb.w	r2, [r4, #145]	; 0x91
 80135b4:	e727      	b.n	8013406 <tcp_receive+0x36>
      /* We come here when the ACK acknowledges new data. */

      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
 80135b6:	7fa1      	ldrb	r1, [r4, #30]
 80135b8:	0748      	lsls	r0, r1, #29
 80135ba:	d506      	bpl.n	80135ca <tcp_receive+0x1fa>
        pcb->flags &= ~TF_INFR;
        pcb->cwnd = pcb->ssthresh;
 80135bc:	f8b4 004e 	ldrh.w	r0, [r4, #78]	; 0x4e

      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
        pcb->flags &= ~TF_INFR;
 80135c0:	f021 0104 	bic.w	r1, r1, #4
 80135c4:	77a1      	strb	r1, [r4, #30]
        pcb->cwnd = pcb->ssthresh;
 80135c6:	f8a4 004c 	strh.w	r0, [r4, #76]	; 0x4c
      pcb->rto = (pcb->sa >> 3) + pcb->sv;

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);

      pcb->snd_buf += pcb->acked;
 80135ca:	f8b4 0066 	ldrh.w	r0, [r4, #102]	; 0x66

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 80135ce:	f9b4 5040 	ldrsh.w	r5, [r4, #64]	; 0x40
 80135d2:	f8b4 1042 	ldrh.w	r1, [r4, #66]	; 0x42
      pcb->dupacks = 0;
      pcb->lastack = ackno;

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
 80135d6:	7e26      	ldrb	r6, [r4, #24]

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
 80135d8:	b292      	uxth	r2, r2

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 80135da:	eb01 01e5 	add.w	r1, r1, r5, asr #3

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);

      pcb->snd_buf += pcb->acked;
 80135de:	4410      	add	r0, r2
        pcb->flags &= ~TF_INFR;
        pcb->cwnd = pcb->ssthresh;
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
 80135e0:	2500      	movs	r5, #0
      pcb->dupacks = 0;
      pcb->lastack = ackno;

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
 80135e2:	2e03      	cmp	r6, #3

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
 80135e4:	f8a4 2064 	strh.w	r2, [r4, #100]	; 0x64

      pcb->snd_buf += pcb->acked;

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
      pcb->lastack = ackno;
 80135e8:	64a3      	str	r3, [r4, #72]	; 0x48
      pcb->rto = (pcb->sa >> 3) + pcb->sv;

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);

      pcb->snd_buf += pcb->acked;
 80135ea:	f8a4 0066 	strh.w	r0, [r4, #102]	; 0x66

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 80135ee:	f8a4 1044 	strh.w	r1, [r4, #68]	; 0x44
        pcb->flags &= ~TF_INFR;
        pcb->cwnd = pcb->ssthresh;
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
 80135f2:	f884 5046 	strb.w	r5, [r4, #70]	; 0x46
      pcb->acked = (u16_t)(ackno - pcb->lastack);

      pcb->snd_buf += pcb->acked;

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
 80135f6:	f884 5047 	strb.w	r5, [r4, #71]	; 0x47
      pcb->lastack = ackno;

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
 80135fa:	d90f      	bls.n	801361c <tcp_receive+0x24c>
        if (pcb->cwnd < pcb->ssthresh) {
 80135fc:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
 8013600:	f8b4 304e 	ldrh.w	r3, [r4, #78]	; 0x4e
 8013604:	4293      	cmp	r3, r2
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
 8013606:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
            pcb->cwnd += pcb->mss;
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
 8013608:	bf9c      	itt	ls
 801360a:	435b      	mulls	r3, r3
 801360c:	fb93 f3f2 	sdivls	r3, r3, r2
 8013610:	4413      	add	r3, r2
 8013612:	b29b      	uxth	r3, r3
          if (new_cwnd > pcb->cwnd) {
 8013614:	429a      	cmp	r2, r3
 8013616:	d201      	bcs.n	801361c <tcp_receive+0x24c>
            pcb->cwnd = new_cwnd;
 8013618:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
 801361c:	6f23      	ldr	r3, [r4, #112]	; 0x70
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
 801361e:	2b00      	cmp	r3, #0
 8013620:	d03a      	beq.n	8013698 <tcp_receive+0x2c8>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
 8013622:	68db      	ldr	r3, [r3, #12]
 8013624:	6858      	ldr	r0, [r3, #4]
 8013626:	f7fa fabf 	bl	800dba8 <lwip_ntohl>
 801362a:	6f23      	ldr	r3, [r4, #112]	; 0x70
 801362c:	4605      	mov	r5, r0
 801362e:	68da      	ldr	r2, [r3, #12]
 8013630:	891e      	ldrh	r6, [r3, #8]
 8013632:	8990      	ldrh	r0, [r2, #12]
 8013634:	f7fa fab4 	bl	800dba0 <lwip_ntohs>
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
 8013638:	68bb      	ldr	r3, [r7, #8]
 801363a:	f010 0003 	ands.w	r0, r0, #3
 801363e:	bf18      	it	ne
 8013640:	2001      	movne	r0, #1
 8013642:	4406      	add	r6, r0
 8013644:	1aed      	subs	r5, r5, r3
 8013646:	4435      	add	r5, r6
 8013648:	2d00      	cmp	r5, #0
 801364a:	f300 812b 	bgt.w	80138a4 <tcp_receive+0x4d4>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
 801364e:	6f25      	ldr	r5, [r4, #112]	; 0x70
        pcb->unacked = pcb->unacked->next;

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 8013650:	f8b4 6068 	ldrh.w	r6, [r4, #104]	; 0x68
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
        pcb->unacked = pcb->unacked->next;
 8013654:	682b      	ldr	r3, [r5, #0]

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 8013656:	6868      	ldr	r0, [r5, #4]
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
        pcb->unacked = pcb->unacked->next;
 8013658:	6723      	str	r3, [r4, #112]	; 0x70

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 801365a:	f7fc fe8b 	bl	8010374 <pbuf_clen>
 801365e:	b280      	uxth	r0, r0
 8013660:	4286      	cmp	r6, r0
 8013662:	d35c      	bcc.n	801371e <tcp_receive+0x34e>
        /* Prevent ACK for FIN to generate a sent event */
        if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
 8013664:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
 8013668:	2b00      	cmp	r3, #0
 801366a:	d14c      	bne.n	8013706 <tcp_receive+0x336>
          pcb->acked--;
        }

        pcb->snd_queuelen -= pbuf_clen(next->p);
 801366c:	6868      	ldr	r0, [r5, #4]
 801366e:	f7fc fe81 	bl	8010374 <pbuf_clen>
 8013672:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
 8013676:	1a18      	subs	r0, r3, r0
 8013678:	f8a4 0068 	strh.w	r0, [r4, #104]	; 0x68
        tcp_seg_free(next);
 801367c:	4628      	mov	r0, r5
 801367e:	f7f6 f8ef 	bl	8009860 <tcp_seg_free>

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
        if (pcb->snd_queuelen != 0) {
 8013682:	f8b4 3068 	ldrh.w	r3, [r4, #104]	; 0x68
 8013686:	2b00      	cmp	r3, #0
 8013688:	d0c8      	beq.n	801361c <tcp_receive+0x24c>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
 801368a:	6f23      	ldr	r3, [r4, #112]	; 0x70
 801368c:	2b00      	cmp	r3, #0
 801368e:	d1c6      	bne.n	801361e <tcp_receive+0x24e>
 8013690:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8013692:	2b00      	cmp	r3, #0
 8013694:	f000 818e 	beq.w	80139b4 <tcp_receive+0x5e4>
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
        pcb->rtime = -1;
 8013698:	f64f 73ff 	movw	r3, #65535	; 0xffff
 801369c:	86a3      	strh	r3, [r4, #52]	; 0x34
      else
        pcb->rtime = 0;

      pcb->polltmr = 0;
 801369e:	2300      	movs	r3, #0
 80136a0:	77e3      	strb	r3, [r4, #31]
 80136a2:	e6bd      	b.n	8013420 <tcp_receive+0x50>
 80136a4:	20004cc8 	.word	0x20004cc8
 80136a8:	080183b0 	.word	0x080183b0
 80136ac:	080183e0 	.word	0x080183e0
 80136b0:	0801660c 	.word	0x0801660c
 80136b4:	08018408 	.word	0x08018408
 80136b8:	080183c4 	.word	0x080183c4
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
      /* diff between this shouldn't exceed 32K since this are tcp timer ticks
         and a round-trip shouldn't be that long... */
      m = (s16_t)(tcp_ticks - pcb->rttest);
 80136bc:	49b3      	ldr	r1, [pc, #716]	; (801398c <tcp_receive+0x5bc>)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
 80136be:	f9b4 2040 	ldrsh.w	r2, [r4, #64]	; 0x40
 80136c2:	6809      	ldr	r1, [r1, #0]
      pcb->rto = (pcb->sa >> 3) + pcb->sv;

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
 80136c4:	2000      	movs	r0, #0

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
 80136c6:	1ac9      	subs	r1, r1, r3
 80136c8:	eba1 01e2 	sub.w	r1, r1, r2, asr #3
 80136cc:	b289      	uxth	r1, r1
      pcb->sa += m;
 80136ce:	188b      	adds	r3, r1, r2

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
 80136d0:	b20a      	sxth	r2, r1
      pcb->sa += m;
      if (m < 0) {
 80136d2:	2a00      	cmp	r2, #0
        m = -m;
 80136d4:	bfbc      	itt	lt
 80136d6:	4249      	neglt	r1, r1
 80136d8:	b20a      	sxthlt	r2, r1
      }
      m = m - (pcb->sv >> 2);
 80136da:	f9b4 1042 	ldrsh.w	r1, [r4, #66]	; 0x42
      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
      pcb->sa += m;
 80136de:	b21b      	sxth	r3, r3
      if (m < 0) {
        m = -m;
      }
      m = m - (pcb->sv >> 2);
      pcb->sv += m;
 80136e0:	eba1 01a1 	sub.w	r1, r1, r1, asr #2
 80136e4:	440a      	add	r2, r1
 80136e6:	b292      	uxth	r2, r2
      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
      pcb->sa += m;
 80136e8:	f8a4 3040 	strh.w	r3, [r4, #64]	; 0x40
      if (m < 0) {
        m = -m;
      }
      m = m - (pcb->sv >> 2);
      pcb->sv += m;
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
 80136ec:	eb02 03e3 	add.w	r3, r2, r3, asr #3
 80136f0:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
      pcb->sa += m;
      if (m < 0) {
        m = -m;
      }
      m = m - (pcb->sv >> 2);
      pcb->sv += m;
 80136f4:	f8a4 2042 	strh.w	r2, [r4, #66]	; 0x42
      pcb->rto = (pcb->sa >> 3) + pcb->sv;

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
 80136f8:	63a0      	str	r0, [r4, #56]	; 0x38
 80136fa:	e6df      	b.n	80134bc <tcp_receive+0xec>
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
 80136fc:	7fa3      	ldrb	r3, [r4, #30]
 80136fe:	f043 0302 	orr.w	r3, r3, #2
 8013702:	77a3      	strb	r3, [r4, #30]
 8013704:	e70c      	b.n	8013520 <tcp_receive+0x150>
        pcb->unacked = pcb->unacked->next;

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
        /* Prevent ACK for FIN to generate a sent event */
        if ((pcb->acked != 0) && ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0)) {
 8013706:	68eb      	ldr	r3, [r5, #12]
 8013708:	8998      	ldrh	r0, [r3, #12]
 801370a:	f7fa fa49 	bl	800dba0 <lwip_ntohs>
 801370e:	07c2      	lsls	r2, r0, #31
 8013710:	d5ac      	bpl.n	801366c <tcp_receive+0x29c>
          pcb->acked--;
 8013712:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
 8013716:	3b01      	subs	r3, #1
 8013718:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
 801371c:	e7a6      	b.n	801366c <tcp_receive+0x29c>

        next = pcb->unacked;
        pcb->unacked = pcb->unacked->next;

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
 801371e:	4b9c      	ldr	r3, [pc, #624]	; (8013990 <tcp_receive+0x5c0>)
 8013720:	f44f 727f 	mov.w	r2, #1020	; 0x3fc
 8013724:	499b      	ldr	r1, [pc, #620]	; (8013994 <tcp_receive+0x5c4>)
 8013726:	489c      	ldr	r0, [pc, #624]	; (8013998 <tcp_receive+0x5c8>)
 8013728:	f001 fb26 	bl	8014d78 <iprintf>
 801372c:	e79a      	b.n	8013664 <tcp_receive+0x294>

    /* Clause 1 */
    if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
      pcb->acked = 0;
      /* Clause 2 */
      if (tcplen == 0) {
 801372e:	8a3a      	ldrh	r2, [r7, #16]
     *
     */

    /* Clause 1 */
    if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
      pcb->acked = 0;
 8013730:	2600      	movs	r6, #0
 8013732:	f8a4 6064 	strh.w	r6, [r4, #100]	; 0x64
      /* Clause 2 */
      if (tcplen == 0) {
 8013736:	b93a      	cbnz	r2, 8013748 <tcp_receive+0x378>
        /* Clause 3 */
        if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge){
 8013738:	f8b4 6060 	ldrh.w	r6, [r4, #96]	; 0x60
 801373c:	6da2      	ldr	r2, [r4, #88]	; 0x58
 801373e:	4428      	add	r0, r5
 8013740:	4432      	add	r2, r6
 8013742:	4290      	cmp	r0, r2
 8013744:	f000 808f 	beq.w	8013866 <tcp_receive+0x496>
        }
      }
      /* If Clause (1) or more is true, but not a duplicate ack, reset
       * count of consecutive duplicate acks */
      if (!found_dupack) {
        pcb->dupacks = 0;
 8013748:	2300      	movs	r3, #0
 801374a:	f884 3047 	strb.w	r3, [r4, #71]	; 0x47
 801374e:	e667      	b.n	8013420 <tcp_receive+0x50>
        if (pcb->persist_backoff == 0) {
          /* start persist timer */
          pcb->persist_cnt = 0;
          pcb->persist_backoff = 1;
        }
      } else if (pcb->persist_backoff > 0) {
 8013750:	2a00      	cmp	r2, #0
 8013752:	f43f ae58 	beq.w	8013406 <tcp_receive+0x36>
        /* stop persist timer */
          pcb->persist_backoff = 0;
 8013756:	2200      	movs	r2, #0
 8013758:	f884 2091 	strb.w	r2, [r4, #145]	; 0x91
 801375c:	e653      	b.n	8013406 <tcp_receive+0x36>
  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
 801375e:	1ac1      	subs	r1, r0, r3
 8013760:	2900      	cmp	r1, #0
 8013762:	f6bf ae4d 	bge.w	8013400 <tcp_receive+0x30>
 8013766:	68f9      	ldr	r1, [r7, #12]
 8013768:	89c9      	ldrh	r1, [r1, #14]
 801376a:	e70c      	b.n	8013586 <tcp_receive+0x1b6>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
 801376c:	68fb      	ldr	r3, [r7, #12]
 801376e:	89d9      	ldrh	r1, [r3, #14]
 8013770:	4603      	mov	r3, r0
 8013772:	428d      	cmp	r5, r1
 8013774:	f4bf ae47 	bcs.w	8013406 <tcp_receive+0x36>
 8013778:	e705      	b.n	8013586 <tcp_receive+0x1b6>
    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
 801377a:	4281      	cmp	r1, r0
 801377c:	f47f aed0 	bne.w	8013520 <tcp_receive+0x150>
 8013780:	e039      	b.n	80137f6 <tcp_receive+0x426>
         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
      p = inseg.p;
 8013782:	6995      	ldr	r5, [r2, #24]

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
 8013784:	4646      	mov	r6, r8
      p = inseg.p;
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
 8013786:	2d00      	cmp	r5, #0
 8013788:	f000 811c 	beq.w	80139c4 <tcp_receive+0x5f4>
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
 801378c:	f647 73fe 	movw	r3, #32766	; 0x7ffe
 8013790:	4598      	cmp	r8, r3
 8013792:	f300 809d 	bgt.w	80138d0 <tcp_receive+0x500>
      if (inseg.p->len < off) {
 8013796:	69b8      	ldr	r0, [r7, #24]
 8013798:	f8df 9200 	ldr.w	r9, [pc, #512]	; 801399c <tcp_receive+0x5cc>
 801379c:	8943      	ldrh	r3, [r0, #10]
 801379e:	4598      	cmp	r8, r3
 80137a0:	f340 8087 	ble.w	80138b2 <tcp_receive+0x4e2>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
 80137a4:	8902      	ldrh	r2, [r0, #8]
 80137a6:	4590      	cmp	r8, r2
 80137a8:	f300 809a 	bgt.w	80138e0 <tcp_receive+0x510>
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
 80137ac:	896b      	ldrh	r3, [r5, #10]
      p = inseg.p;
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
 80137ae:	ebc8 0202 	rsb	r2, r8, r2
        while (p->len < off) {
 80137b2:	4598      	cmp	r8, r3
      p = inseg.p;
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
 80137b4:	b292      	uxth	r2, r2
        while (p->len < off) {
 80137b6:	dd07      	ble.n	80137c8 <tcp_receive+0x3f8>
          off -= p->len;
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
 80137b8:	2100      	movs	r1, #0
 80137ba:	8169      	strh	r1, [r5, #10]
        while (p->len < off) {
          off -= p->len;
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
 80137bc:	812a      	strh	r2, [r5, #8]
          p->len = 0;
          p = p->next;
 80137be:	682d      	ldr	r5, [r5, #0]
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
          off -= p->len;
 80137c0:	1af6      	subs	r6, r6, r3
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
 80137c2:	896b      	ldrh	r3, [r5, #10]
 80137c4:	42b3      	cmp	r3, r6
 80137c6:	dbf8      	blt.n	80137ba <tcp_receive+0x3ea>
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
          p = p->next;
        }
        if(pbuf_header(p, (s16_t)-off)) {
 80137c8:	4271      	negs	r1, r6
 80137ca:	b209      	sxth	r1, r1
 80137cc:	4628      	mov	r0, r5
 80137ce:	f7fc fbd3 	bl	800ff78 <pbuf_header>
 80137d2:	2800      	cmp	r0, #0
 80137d4:	f040 808f 	bne.w	80138f6 <tcp_receive+0x526>
        if(pbuf_header(inseg.p, (s16_t)-off)) {
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
        }
      }
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
 80137d8:	6878      	ldr	r0, [r7, #4]
 80137da:	8bbb      	ldrh	r3, [r7, #28]
 80137dc:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
 80137de:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 80137e0:	4403      	add	r3, r0
 80137e2:	f1c2 0201 	rsb	r2, r2, #1
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
 80137e6:	6a38      	ldr	r0, [r7, #32]
        if(pbuf_header(inseg.p, (s16_t)-off)) {
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
        }
      }
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
 80137e8:	1a5b      	subs	r3, r3, r1
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
 80137ea:	2a00      	cmp	r2, #0
        if(pbuf_header(inseg.p, (s16_t)-off)) {
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
        }
      }
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
 80137ec:	83bb      	strh	r3, [r7, #28]
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
 80137ee:	6079      	str	r1, [r7, #4]
 80137f0:	6041      	str	r1, [r0, #4]
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
 80137f2:	f73f ae95 	bgt.w	8013520 <tcp_receive+0x150>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
        tcplen = TCP_TCPLEN(&inseg);
 80137f6:	6a3b      	ldr	r3, [r7, #32]
 80137f8:	8bbd      	ldrh	r5, [r7, #28]
 80137fa:	8998      	ldrh	r0, [r3, #12]
 80137fc:	f7fa f9d0 	bl	800dba0 <lwip_ntohs>
 8013800:	f010 0003 	ands.w	r0, r0, #3
 8013804:	bf18      	it	ne
 8013806:	2001      	movne	r0, #1
 8013808:	182b      	adds	r3, r5, r0

        if (tcplen > pcb->rcv_wnd) {
 801380a:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
        tcplen = TCP_TCPLEN(&inseg);
 801380c:	b29b      	uxth	r3, r3

        if (tcplen > pcb->rcv_wnd) {
 801380e:	4293      	cmp	r3, r2
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
        tcplen = TCP_TCPLEN(&inseg);
 8013810:	823b      	strh	r3, [r7, #16]
 8013812:	4d62      	ldr	r5, [pc, #392]	; (801399c <tcp_receive+0x5cc>)

        if (tcplen > pcb->rcv_wnd) {
 8013814:	d877      	bhi.n	8013906 <tcp_receive+0x536>
            pcb->ooseq = next;
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        pcb->rcv_nxt = seqno + tcplen;
 8013816:	6869      	ldr	r1, [r5, #4]
 8013818:	4419      	add	r1, r3
 801381a:	62a1      	str	r1, [r4, #40]	; 0x28

        /* Update the receiver's (our) window. */
        LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
        pcb->rcv_wnd -= tcplen;
 801381c:	1ad3      	subs	r3, r2, r3
 801381e:	85a3      	strh	r3, [r4, #44]	; 0x2c

        tcp_update_rcv_ann_wnd(pcb);
 8013820:	4620      	mov	r0, r4
 8013822:	f7f5 ff03 	bl	800962c <tcp_update_rcv_ann_wnd>
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
 8013826:	69bb      	ldr	r3, [r7, #24]
 8013828:	495c      	ldr	r1, [pc, #368]	; (801399c <tcp_receive+0x5cc>)
 801382a:	891a      	ldrh	r2, [r3, #8]
 801382c:	b112      	cbz	r2, 8013834 <tcp_receive+0x464>
          recv_data = inseg.p;
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
 801382e:	2200      	movs	r2, #0

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
          recv_data = inseg.p;
 8013830:	624b      	str	r3, [r1, #36]	; 0x24
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
 8013832:	618a      	str	r2, [r1, #24]
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 8013834:	6a3b      	ldr	r3, [r7, #32]
 8013836:	4d59      	ldr	r5, [pc, #356]	; (801399c <tcp_receive+0x5cc>)
 8013838:	8998      	ldrh	r0, [r3, #12]
 801383a:	f7fa f9b1 	bl	800dba0 <lwip_ntohs>
 801383e:	07c1      	lsls	r1, r0, #31
 8013840:	d505      	bpl.n	801384e <tcp_receive+0x47e>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags |= TF_GOT_FIN;
 8013842:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
 8013846:	f043 0320 	orr.w	r3, r3, #32
 801384a:	f885 3028 	strb.w	r3, [r5, #40]	; 0x28
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
 801384e:	7fa3      	ldrb	r3, [r4, #30]
 8013850:	07da      	lsls	r2, r3, #31
 8013852:	bf46      	itte	mi
 8013854:	f023 0301 	bicmi.w	r3, r3, #1
 8013858:	f043 0302 	orrmi.w	r3, r3, #2
 801385c:	f043 0301 	orrpl.w	r3, r3, #1
 8013860:	77a3      	strb	r3, [r4, #30]
 8013862:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      /* Clause 2 */
      if (tcplen == 0) {
        /* Clause 3 */
        if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge){
          /* Clause 4 */
          if (pcb->rtime >= 0) {
 8013866:	f9b4 2034 	ldrsh.w	r2, [r4, #52]	; 0x34
 801386a:	2a00      	cmp	r2, #0
 801386c:	f6ff af6c 	blt.w	8013748 <tcp_receive+0x378>
            /* Clause 5 */
            if (pcb->lastack == ackno) {
 8013870:	4299      	cmp	r1, r3
 8013872:	f47f af69 	bne.w	8013748 <tcp_receive+0x378>
              found_dupack = 1;
              if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
 8013876:	f894 2047 	ldrb.w	r2, [r4, #71]	; 0x47
 801387a:	1c53      	adds	r3, r2, #1
 801387c:	b2db      	uxtb	r3, r3
 801387e:	429a      	cmp	r2, r3
                ++pcb->dupacks;
 8013880:	bf3c      	itt	cc
 8013882:	461a      	movcc	r2, r3
 8013884:	f884 3047 	strbcc.w	r3, [r4, #71]	; 0x47
              }
              if (pcb->dupacks > 3) {
 8013888:	2a03      	cmp	r2, #3
 801388a:	f240 80b1 	bls.w	80139f0 <tcp_receive+0x620>
                /* Inflate the congestion window, but not if it means that
                   the value overflows. */
                if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
 801388e:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
 8013892:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8013894:	4413      	add	r3, r2
 8013896:	b29b      	uxth	r3, r3
 8013898:	429a      	cmp	r2, r3
 801389a:	f4bf adc1 	bcs.w	8013420 <tcp_receive+0x50>
                  pcb->cwnd += pcb->mss;
 801389e:	f8a4 304c 	strh.w	r3, [r4, #76]	; 0x4c
 80138a2:	e5bd      	b.n	8013420 <tcp_receive+0x50>
        }
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
 80138a4:	6f23      	ldr	r3, [r4, #112]	; 0x70
 80138a6:	2b00      	cmp	r3, #0
 80138a8:	f43f aef6 	beq.w	8013698 <tcp_receive+0x2c8>
        pcb->rtime = -1;
      else
        pcb->rtime = 0;
 80138ac:	2300      	movs	r3, #0
 80138ae:	86a3      	strh	r3, [r4, #52]	; 0x34
 80138b0:	e6f5      	b.n	801369e <tcp_receive+0x2ce>
        if(pbuf_header(p, (s16_t)-off)) {
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
 80138b2:	f1c8 0100 	rsb	r1, r8, #0
 80138b6:	b209      	sxth	r1, r1
 80138b8:	f7fc fb5e 	bl	800ff78 <pbuf_header>
 80138bc:	2800      	cmp	r0, #0
 80138be:	d08b      	beq.n	80137d8 <tcp_receive+0x408>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
 80138c0:	4b33      	ldr	r3, [pc, #204]	; (8013990 <tcp_receive+0x5c0>)
 80138c2:	f240 42ab 	movw	r2, #1195	; 0x4ab
 80138c6:	4936      	ldr	r1, [pc, #216]	; (80139a0 <tcp_receive+0x5d0>)
 80138c8:	4833      	ldr	r0, [pc, #204]	; (8013998 <tcp_receive+0x5c8>)
 80138ca:	f001 fa55 	bl	8014d78 <iprintf>
 80138ce:	e783      	b.n	80137d8 <tcp_receive+0x408>
         length.*/

      off = pcb->rcv_nxt - seqno;
      p = inseg.p;
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
 80138d0:	4b2f      	ldr	r3, [pc, #188]	; (8013990 <tcp_receive+0x5c0>)
 80138d2:	f240 4297 	movw	r2, #1175	; 0x497
 80138d6:	4933      	ldr	r1, [pc, #204]	; (80139a4 <tcp_receive+0x5d4>)
 80138d8:	482f      	ldr	r0, [pc, #188]	; (8013998 <tcp_receive+0x5c8>)
 80138da:	f001 fa4d 	bl	8014d78 <iprintf>
 80138de:	e75a      	b.n	8013796 <tcp_receive+0x3c6>
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
 80138e0:	4b2b      	ldr	r3, [pc, #172]	; (8013990 <tcp_receive+0x5c0>)
 80138e2:	f240 4299 	movw	r2, #1177	; 0x499
 80138e6:	4930      	ldr	r1, [pc, #192]	; (80139a8 <tcp_receive+0x5d8>)
 80138e8:	482b      	ldr	r0, [pc, #172]	; (8013998 <tcp_receive+0x5c8>)
 80138ea:	f001 fa45 	bl	8014d78 <iprintf>
 80138ee:	f8d9 3018 	ldr.w	r3, [r9, #24]
 80138f2:	891a      	ldrh	r2, [r3, #8]
 80138f4:	e75a      	b.n	80137ac <tcp_receive+0x3dc>
          p->len = 0;
          p = p->next;
        }
        if(pbuf_header(p, (s16_t)-off)) {
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
 80138f6:	4b26      	ldr	r3, [pc, #152]	; (8013990 <tcp_receive+0x5c0>)
 80138f8:	f240 42a6 	movw	r2, #1190	; 0x4a6
 80138fc:	4928      	ldr	r1, [pc, #160]	; (80139a0 <tcp_receive+0x5d0>)
 80138fe:	4826      	ldr	r0, [pc, #152]	; (8013998 <tcp_receive+0x5c8>)
 8013900:	f001 fa3a 	bl	8014d78 <iprintf>
 8013904:	e768      	b.n	80137d8 <tcp_receive+0x408>
        if (tcplen > pcb->rcv_wnd) {
          LWIP_DEBUGF(TCP_INPUT_DEBUG, 
                      ("tcp_receive: other end overran receive window"
                       "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
                       seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
 8013906:	6a2b      	ldr	r3, [r5, #32]
 8013908:	8998      	ldrh	r0, [r3, #12]
 801390a:	f7fa f949 	bl	800dba0 <lwip_ntohs>
 801390e:	07c6      	lsls	r6, r0, #31
 8013910:	d460      	bmi.n	80139d4 <tcp_receive+0x604>
            /* Must remove the FIN from the header as we're trimming 
             * that byte of sequence-space from the packet */
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) &~ TCP_FIN);
          }
          /* Adjust length of segment to fit in the window. */
          inseg.len = pcb->rcv_wnd;
 8013912:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 8013914:	6a3b      	ldr	r3, [r7, #32]
            /* Must remove the FIN from the header as we're trimming 
             * that byte of sequence-space from the packet */
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) &~ TCP_FIN);
          }
          /* Adjust length of segment to fit in the window. */
          inseg.len = pcb->rcv_wnd;
 8013916:	83ba      	strh	r2, [r7, #28]
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 8013918:	8998      	ldrh	r0, [r3, #12]
 801391a:	f7fa f941 	bl	800dba0 <lwip_ntohs>
            /* Must remove the FIN from the header as we're trimming 
             * that byte of sequence-space from the packet */
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) &~ TCP_FIN);
          }
          /* Adjust length of segment to fit in the window. */
          inseg.len = pcb->rcv_wnd;
 801391e:	4d1f      	ldr	r5, [pc, #124]	; (801399c <tcp_receive+0x5cc>)
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 8013920:	0780      	lsls	r0, r0, #30
            inseg.len -= 1;
 8013922:	8ba9      	ldrh	r1, [r5, #28]
             * that byte of sequence-space from the packet */
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) &~ TCP_FIN);
          }
          /* Adjust length of segment to fit in the window. */
          inseg.len = pcb->rcv_wnd;
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
 8013924:	d502      	bpl.n	801392c <tcp_receive+0x55c>
            inseg.len -= 1;
 8013926:	3901      	subs	r1, #1
 8013928:	b289      	uxth	r1, r1
 801392a:	83a9      	strh	r1, [r5, #28]
          }
          pbuf_realloc(inseg.p, inseg.len);
 801392c:	69b8      	ldr	r0, [r7, #24]
 801392e:	f7fc fcb5 	bl	801029c <pbuf_realloc>
          tcplen = TCP_TCPLEN(&inseg);
 8013932:	6a3b      	ldr	r3, [r7, #32]
 8013934:	8bbe      	ldrh	r6, [r7, #28]
 8013936:	8998      	ldrh	r0, [r3, #12]
 8013938:	f7fa f932 	bl	800dba0 <lwip_ntohs>
 801393c:	f010 0003 	ands.w	r0, r0, #3
 8013940:	bf18      	it	ne
 8013942:	2001      	movne	r0, #1
 8013944:	1833      	adds	r3, r6, r0
          LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
 8013946:	687d      	ldr	r5, [r7, #4]
 8013948:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
 801394a:	6aa1      	ldr	r1, [r4, #40]	; 0x28
          inseg.len = pcb->rcv_wnd;
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
            inseg.len -= 1;
          }
          pbuf_realloc(inseg.p, inseg.len);
          tcplen = TCP_TCPLEN(&inseg);
 801394c:	b29b      	uxth	r3, r3
          LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
 801394e:	441d      	add	r5, r3
 8013950:	4411      	add	r1, r2
 8013952:	428d      	cmp	r5, r1
          inseg.len = pcb->rcv_wnd;
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
            inseg.len -= 1;
          }
          pbuf_realloc(inseg.p, inseg.len);
          tcplen = TCP_TCPLEN(&inseg);
 8013954:	823b      	strh	r3, [r7, #16]
          /* Adjust length of segment to fit in the window. */
          inseg.len = pcb->rcv_wnd;
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
            inseg.len -= 1;
          }
          pbuf_realloc(inseg.p, inseg.len);
 8013956:	4e11      	ldr	r6, [pc, #68]	; (801399c <tcp_receive+0x5cc>)
          tcplen = TCP_TCPLEN(&inseg);
          LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
 8013958:	d00a      	beq.n	8013970 <tcp_receive+0x5a0>
 801395a:	4b0d      	ldr	r3, [pc, #52]	; (8013990 <tcp_receive+0x5c0>)
 801395c:	f44f 629b 	mov.w	r2, #1240	; 0x4d8
 8013960:	4912      	ldr	r1, [pc, #72]	; (80139ac <tcp_receive+0x5dc>)
 8013962:	480d      	ldr	r0, [pc, #52]	; (8013998 <tcp_receive+0x5c8>)
 8013964:	f001 fa08 	bl	8014d78 <iprintf>
 8013968:	8a33      	ldrh	r3, [r6, #16]
 801396a:	6871      	ldr	r1, [r6, #4]
 801396c:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
 801396e:	4419      	add	r1, r3
#endif /* TCP_QUEUE_OOSEQ */

        pcb->rcv_nxt = seqno + tcplen;

        /* Update the receiver's (our) window. */
        LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
 8013970:	4293      	cmp	r3, r2
            pcb->ooseq = next;
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        pcb->rcv_nxt = seqno + tcplen;
 8013972:	62a1      	str	r1, [r4, #40]	; 0x28

        /* Update the receiver's (our) window. */
        LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
 8013974:	f67f af52 	bls.w	801381c <tcp_receive+0x44c>
 8013978:	4b05      	ldr	r3, [pc, #20]	; (8013990 <tcp_receive+0x5c0>)
 801397a:	f240 5212 	movw	r2, #1298	; 0x512
 801397e:	490c      	ldr	r1, [pc, #48]	; (80139b0 <tcp_receive+0x5e0>)
 8013980:	4805      	ldr	r0, [pc, #20]	; (8013998 <tcp_receive+0x5c8>)
 8013982:	f001 f9f9 	bl	8014d78 <iprintf>
 8013986:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
 8013988:	8a3b      	ldrh	r3, [r7, #16]
 801398a:	e747      	b.n	801381c <tcp_receive+0x44c>
 801398c:	2000f044 	.word	0x2000f044
 8013990:	080183b0 	.word	0x080183b0
 8013994:	080183e0 	.word	0x080183e0
 8013998:	0801660c 	.word	0x0801660c
 801399c:	20004cc8 	.word	0x20004cc8
 80139a0:	08018458 	.word	0x08018458
 80139a4:	08018438 	.word	0x08018438
 80139a8:	08018448 	.word	0x08018448
 80139ac:	0801846c 	.word	0x0801846c
 80139b0:	080184a4 	.word	0x080184a4
        pcb->snd_queuelen -= pbuf_clen(next->p);
        tcp_seg_free(next);

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
        if (pcb->snd_queuelen != 0) {
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
 80139b4:	4b11      	ldr	r3, [pc, #68]	; (80139fc <tcp_receive+0x62c>)
 80139b6:	f44f 6281 	mov.w	r2, #1032	; 0x408
 80139ba:	4911      	ldr	r1, [pc, #68]	; (8013a00 <tcp_receive+0x630>)
 80139bc:	4811      	ldr	r0, [pc, #68]	; (8013a04 <tcp_receive+0x634>)
 80139be:	f001 f9db 	bl	8014d78 <iprintf>
 80139c2:	e62b      	b.n	801361c <tcp_receive+0x24c>
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
      p = inseg.p;
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
 80139c4:	4b0d      	ldr	r3, [pc, #52]	; (80139fc <tcp_receive+0x62c>)
 80139c6:	f240 4296 	movw	r2, #1174	; 0x496
 80139ca:	490f      	ldr	r1, [pc, #60]	; (8013a08 <tcp_receive+0x638>)
 80139cc:	480d      	ldr	r0, [pc, #52]	; (8013a04 <tcp_receive+0x634>)
 80139ce:	f001 f9d3 	bl	8014d78 <iprintf>
 80139d2:	e6db      	b.n	801378c <tcp_receive+0x3bc>
                       "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
                       seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
          if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
            /* Must remove the FIN from the header as we're trimming 
             * that byte of sequence-space from the packet */
            TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) &~ TCP_FIN);
 80139d4:	6a2e      	ldr	r6, [r5, #32]
 80139d6:	89b5      	ldrh	r5, [r6, #12]
 80139d8:	4628      	mov	r0, r5
 80139da:	f7fa f8e1 	bl	800dba0 <lwip_ntohs>
 80139de:	f000 003e 	and.w	r0, r0, #62	; 0x3e
 80139e2:	f7fa f8d9 	bl	800db98 <lwip_htons>
 80139e6:	f425 557c 	bic.w	r5, r5, #16128	; 0x3f00
 80139ea:	4328      	orrs	r0, r5
 80139ec:	81b0      	strh	r0, [r6, #12]
 80139ee:	e790      	b.n	8013912 <tcp_receive+0x542>
                /* Inflate the congestion window, but not if it means that
                   the value overflows. */
                if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
                  pcb->cwnd += pcb->mss;
                }
              } else if (pcb->dupacks == 3) {
 80139f0:	f47f ad16 	bne.w	8013420 <tcp_receive+0x50>
                /* Do fast retransmit */
                tcp_rexmit_fast(pcb);
 80139f4:	4620      	mov	r0, r4
 80139f6:	f7f7 fbc7 	bl	800b188 <tcp_rexmit_fast>
 80139fa:	e511      	b.n	8013420 <tcp_receive+0x50>
 80139fc:	080183b0 	.word	0x080183b0
 8013a00:	08018408 	.word	0x08018408
 8013a04:	0801660c 	.word	0x0801660c
 8013a08:	08018428 	.word	0x08018428

08013a0c <tcp_parseopt.isra.0>:
 * Currently, only the MSS option is supported!
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
 8013a0c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  u8_t *opts, opt;
#if LWIP_TCP_TIMESTAMPS
  u32_t tsval;
#endif

  opts = (u8_t *)tcphdr + TCP_HLEN;
 8013a0e:	4d22      	ldr	r5, [pc, #136]	; (8013a98 <tcp_parseopt.isra.0+0x8c>)
 * Currently, only the MSS option is supported!
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
 8013a10:	4606      	mov	r6, r0
  u8_t *opts, opt;
#if LWIP_TCP_TIMESTAMPS
  u32_t tsval;
#endif

  opts = (u8_t *)tcphdr + TCP_HLEN;
 8013a12:	68ec      	ldr	r4, [r5, #12]

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
 8013a14:	89a0      	ldrh	r0, [r4, #12]
 8013a16:	f7fa f8c3 	bl	800dba0 <lwip_ntohs>
 8013a1a:	f3c0 300f 	ubfx	r0, r0, #12, #16
 8013a1e:	2805      	cmp	r0, #5
 8013a20:	d800      	bhi.n	8013a24 <tcp_parseopt.isra.0+0x18>
 8013a22:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
 8013a24:	68eb      	ldr	r3, [r5, #12]
 8013a26:	8998      	ldrh	r0, [r3, #12]
 8013a28:	f7fa f8ba 	bl	800dba0 <lwip_ntohs>
 8013a2c:	0b00      	lsrs	r0, r0, #12
 8013a2e:	3805      	subs	r0, #5
 8013a30:	0080      	lsls	r0, r0, #2
 8013a32:	b280      	uxth	r0, r0
    for (c = 0; c < max_c; ) {
 8013a34:	2800      	cmp	r0, #0
 8013a36:	d0f4      	beq.n	8013a22 <tcp_parseopt.isra.0+0x16>
  u8_t *opts, opt;
#if LWIP_TCP_TIMESTAMPS
  u32_t tsval;
#endif

  opts = (u8_t *)tcphdr + TCP_HLEN;
 8013a38:	f104 0114 	add.w	r1, r4, #20
 8013a3c:	2300      	movs	r3, #0
  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
    for (c = 0; c < max_c; ) {
      opt = opts[c];
      switch (opt) {
 8013a3e:	5cca      	ldrb	r2, [r1, r3]
          return;
        }
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
 8013a40:	f240 57b3 	movw	r7, #1459	; 0x5b3
  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
    for (c = 0; c < max_c; ) {
      opt = opts[c];
      switch (opt) {
 8013a44:	2a01      	cmp	r2, #1
          return;
        }
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
 8013a46:	f240 55b4 	movw	r5, #1460	; 0x5b4
  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
    for (c = 0; c < max_c; ) {
      opt = opts[c];
      switch (opt) {
 8013a4a:	d01b      	beq.n	8013a84 <tcp_parseopt.isra.0+0x78>
 8013a4c:	d3e9      	bcc.n	8013a22 <tcp_parseopt.isra.0+0x16>
 8013a4e:	2a02      	cmp	r2, #2
 8013a50:	d11b      	bne.n	8013a8a <tcp_parseopt.isra.0+0x7e>
        ++c;
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: NOP\n"));
        break;
      case 0x02:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
        if (opts[c + 1] != 0x04 || c + 0x04 > max_c) {
 8013a52:	18cc      	adds	r4, r1, r3
 8013a54:	7862      	ldrb	r2, [r4, #1]
 8013a56:	2a04      	cmp	r2, #4
 8013a58:	d1e3      	bne.n	8013a22 <tcp_parseopt.isra.0+0x16>
 8013a5a:	1cda      	adds	r2, r3, #3
 8013a5c:	4282      	cmp	r2, r0
 8013a5e:	dae0      	bge.n	8013a22 <tcp_parseopt.isra.0+0x16>
          /* Bad length */
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
          return;
        }
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
 8013a60:	f894 e002 	ldrb.w	lr, [r4, #2]
 8013a64:	78e2      	ldrb	r2, [r4, #3]
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
        /* Advance to next option */
        c += 0x04;
 8013a66:	3304      	adds	r3, #4
          /* Bad length */
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
          return;
        }
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
 8013a68:	ea42 220e 	orr.w	r2, r2, lr, lsl #8
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
 8013a6c:	1e54      	subs	r4, r2, #1
 8013a6e:	b2a4      	uxth	r4, r4
 8013a70:	42bc      	cmp	r4, r7
 8013a72:	bf88      	it	hi
 8013a74:	462a      	movhi	r2, r5
        /* Advance to next option */
        c += 0x04;
 8013a76:	b29b      	uxth	r3, r3
          return;
        }
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
 8013a78:	8032      	strh	r2, [r6, #0]
  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    max_c = (TCPH_HDRLEN(tcphdr) - 5) << 2;
    for (c = 0; c < max_c; ) {
 8013a7a:	4298      	cmp	r0, r3
 8013a7c:	d9d1      	bls.n	8013a22 <tcp_parseopt.isra.0+0x16>
      opt = opts[c];
      switch (opt) {
 8013a7e:	5cca      	ldrb	r2, [r1, r3]
 8013a80:	2a01      	cmp	r2, #1
 8013a82:	d1e3      	bne.n	8013a4c <tcp_parseopt.isra.0+0x40>
        /* End of options. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
        return;
      case 0x01:
        /* NOP option. */
        ++c;
 8013a84:	3301      	adds	r3, #1
 8013a86:	b29b      	uxth	r3, r3
 8013a88:	e7f7      	b.n	8013a7a <tcp_parseopt.isra.0+0x6e>
        c += 0x0A;
        break;
#endif
      default:
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
        if (opts[c + 1] == 0) {
 8013a8a:	18ca      	adds	r2, r1, r3
 8013a8c:	7852      	ldrb	r2, [r2, #1]
 8013a8e:	2a00      	cmp	r2, #0
 8013a90:	d0c7      	beq.n	8013a22 <tcp_parseopt.isra.0+0x16>
             and we don't process them further. */
          return;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
 8013a92:	4413      	add	r3, r2
 8013a94:	b29b      	uxth	r3, r3
 8013a96:	e7f0      	b.n	8013a7a <tcp_parseopt.isra.0+0x6e>
 8013a98:	20004cc8 	.word	0x20004cc8

08013a9c <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
 8013a9c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  PERF_START;

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = (struct ip_hdr *)p->payload;
 8013aa0:	6842      	ldr	r2, [r0, #4]
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
 8013aa2:	460e      	mov	r6, r1
 8013aa4:	7813      	ldrb	r3, [r2, #0]

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = (struct ip_hdr *)p->payload;
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
 8013aa6:	4dab      	ldr	r5, [pc, #684]	; (8013d54 <tcp_input+0x2b8>)
 8013aa8:	f003 010f 	and.w	r1, r3, #15
 8013aac:	0089      	lsls	r1, r1, #2
 8013aae:	440a      	add	r2, r1
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
 8013ab0:	b082      	sub	sp, #8
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
 8013ab2:	4249      	negs	r1, r1
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
 8013ab4:	4604      	mov	r4, r0

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = (struct ip_hdr *)p->payload;
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
 8013ab6:	60ea      	str	r2, [r5, #12]
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
 8013ab8:	f7fc fa5e 	bl	800ff78 <pbuf_header>
 8013abc:	b910      	cbnz	r0, 8013ac4 <tcp_input+0x28>
 8013abe:	8923      	ldrh	r3, [r4, #8]
 8013ac0:	2b13      	cmp	r3, #19
 8013ac2:	d805      	bhi.n	8013ad0 <tcp_input+0x34>
  PERF_STOP("tcp_input");
  return;
dropped:
  TCP_STATS_INC(tcp.drop);
  snmp_inc_tcpinerrs();
  pbuf_free(p);
 8013ac4:	4620      	mov	r0, r4
}
 8013ac6:	b002      	add	sp, #8
 8013ac8:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  PERF_STOP("tcp_input");
  return;
dropped:
  TCP_STATS_INC(tcp.drop);
  snmp_inc_tcpinerrs();
  pbuf_free(p);
 8013acc:	f7fc baac 	b.w	8010028 <pbuf_free>
    TCP_STATS_INC(tcp.lenerr);
    goto dropped;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&current_iphdr_dest, inp) ||
 8013ad0:	4fa1      	ldr	r7, [pc, #644]	; (8013d58 <tcp_input+0x2bc>)
 8013ad2:	4631      	mov	r1, r6
 8013ad4:	6838      	ldr	r0, [r7, #0]
 8013ad6:	f7fb f911 	bl	800ecfc <ip4_addr_isbroadcast>
 8013ada:	2800      	cmp	r0, #0
 8013adc:	d1f2      	bne.n	8013ac4 <tcp_input+0x28>
 8013ade:	683b      	ldr	r3, [r7, #0]
 8013ae0:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8013ae4:	2be0      	cmp	r3, #224	; 0xe0
 8013ae6:	d0ed      	beq.n	8013ac4 <tcp_input+0x28>
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
 8013ae8:	68eb      	ldr	r3, [r5, #12]
 8013aea:	8998      	ldrh	r0, [r3, #12]
 8013aec:	f7fa f858 	bl	800dba0 <lwip_ntohs>
  if(pbuf_header(p, -(hdrlen * 4))){
 8013af0:	0b00      	lsrs	r0, r0, #12
 8013af2:	ebc0 3080 	rsb	r0, r0, r0, lsl #14
 8013af6:	0081      	lsls	r1, r0, #2
 8013af8:	b209      	sxth	r1, r1
 8013afa:	4620      	mov	r0, r4
 8013afc:	f7fc fa3c 	bl	800ff78 <pbuf_header>
 8013b00:	4680      	mov	r8, r0
 8013b02:	2800      	cmp	r0, #0
 8013b04:	d1de      	bne.n	8013ac4 <tcp_input+0x28>
    TCP_STATS_INC(tcp.lenerr);
    goto dropped;
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
 8013b06:	68ee      	ldr	r6, [r5, #12]
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8013b08:	f8df 9264 	ldr.w	r9, [pc, #612]	; 8013d70 <tcp_input+0x2d4>
    TCP_STATS_INC(tcp.lenerr);
    goto dropped;
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
 8013b0c:	8830      	ldrh	r0, [r6, #0]
 8013b0e:	f7fa f847 	bl	800dba0 <lwip_ntohs>
  tcphdr->dest = ntohs(tcphdr->dest);
 8013b12:	f8d5 a00c 	ldr.w	sl, [r5, #12]
    TCP_STATS_INC(tcp.lenerr);
    goto dropped;
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
 8013b16:	8030      	strh	r0, [r6, #0]
  tcphdr->dest = ntohs(tcphdr->dest);
 8013b18:	f8ba 0002 	ldrh.w	r0, [sl, #2]
 8013b1c:	f7fa f840 	bl	800dba0 <lwip_ntohs>
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
 8013b20:	68ee      	ldr	r6, [r5, #12]
    goto dropped;
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  tcphdr->dest = ntohs(tcphdr->dest);
 8013b22:	f8aa 0002 	strh.w	r0, [sl, #2]
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
 8013b26:	6870      	ldr	r0, [r6, #4]
 8013b28:	f7fa f83e 	bl	800dba8 <lwip_ntohl>
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
 8013b2c:	f8d5 a00c 	ldr.w	sl, [r5, #12]
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  tcphdr->dest = ntohs(tcphdr->dest);
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
 8013b30:	6070      	str	r0, [r6, #4]
 8013b32:	6068      	str	r0, [r5, #4]
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
 8013b34:	f8da 0008 	ldr.w	r0, [sl, #8]
 8013b38:	f7fa f836 	bl	800dba8 <lwip_ntohl>
  tcphdr->wnd = ntohs(tcphdr->wnd);
 8013b3c:	68ee      	ldr	r6, [r5, #12]

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  tcphdr->dest = ntohs(tcphdr->dest);
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
 8013b3e:	f8ca 0008 	str.w	r0, [sl, #8]
 8013b42:	60a8      	str	r0, [r5, #8]
  tcphdr->wnd = ntohs(tcphdr->wnd);
 8013b44:	89f0      	ldrh	r0, [r6, #14]
 8013b46:	f7fa f82b 	bl	800dba0 <lwip_ntohs>

  flags = TCPH_FLAGS(tcphdr);
 8013b4a:	68eb      	ldr	r3, [r5, #12]
  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  tcphdr->dest = ntohs(tcphdr->dest);
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  tcphdr->wnd = ntohs(tcphdr->wnd);
 8013b4c:	81f0      	strh	r0, [r6, #14]

  flags = TCPH_FLAGS(tcphdr);
 8013b4e:	8998      	ldrh	r0, [r3, #12]
 8013b50:	f7fa f826 	bl	800dba0 <lwip_ntohs>
 8013b54:	b2c0      	uxtb	r0, r0
  tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
 8013b56:	f010 0203 	ands.w	r2, r0, #3
 8013b5a:	8923      	ldrh	r3, [r4, #8]
 8013b5c:	bf18      	it	ne
 8013b5e:	2201      	movne	r2, #1
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8013b60:	f8d9 6000 	ldr.w	r6, [r9]
  tcphdr->dest = ntohs(tcphdr->dest);
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  tcphdr->wnd = ntohs(tcphdr->wnd);

  flags = TCPH_FLAGS(tcphdr);
 8013b64:	f000 003f 	and.w	r0, r0, #63	; 0x3f
  tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
 8013b68:	4413      	add	r3, r2
  tcphdr->dest = ntohs(tcphdr->dest);
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  tcphdr->wnd = ntohs(tcphdr->wnd);

  flags = TCPH_FLAGS(tcphdr);
 8013b6a:	7028      	strb	r0, [r5, #0]
  tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
 8013b6c:	822b      	strh	r3, [r5, #16]
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8013b6e:	b98e      	cbnz	r6, 8013b94 <tcp_input+0xf8>
 8013b70:	e09b      	b.n	8013caa <tcp_input+0x20e>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
 8013b72:	2b0a      	cmp	r3, #10
 8013b74:	f000 8091 	beq.w	8013c9a <tcp_input+0x1fe>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
 8013b78:	2b01      	cmp	r3, #1
 8013b7a:	f000 8087 	beq.w	8013c8c <tcp_input+0x1f0>
    if (pcb->remote_port == tcphdr->src &&
 8013b7e:	68eb      	ldr	r3, [r5, #12]
 8013b80:	8bb1      	ldrh	r1, [r6, #28]
 8013b82:	881a      	ldrh	r2, [r3, #0]
 8013b84:	4291      	cmp	r1, r2
 8013b86:	d010      	beq.n	8013baa <tcp_input+0x10e>
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
 8013b88:	68f3      	ldr	r3, [r6, #12]
 8013b8a:	46b0      	mov	r8, r6
 8013b8c:	2b00      	cmp	r3, #0
 8013b8e:	f000 808c 	beq.w	8013caa <tcp_input+0x20e>
 8013b92:	461e      	mov	r6, r3
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
 8013b94:	7e33      	ldrb	r3, [r6, #24]
 8013b96:	2b00      	cmp	r3, #0
 8013b98:	d1eb      	bne.n	8013b72 <tcp_input+0xd6>
 8013b9a:	4b70      	ldr	r3, [pc, #448]	; (8013d5c <tcp_input+0x2c0>)
 8013b9c:	22ab      	movs	r2, #171	; 0xab
 8013b9e:	4970      	ldr	r1, [pc, #448]	; (8013d60 <tcp_input+0x2c4>)
 8013ba0:	4870      	ldr	r0, [pc, #448]	; (8013d64 <tcp_input+0x2c8>)
 8013ba2:	f001 f8e9 	bl	8014d78 <iprintf>
 8013ba6:	7e33      	ldrb	r3, [r6, #24]
 8013ba8:	e7e3      	b.n	8013b72 <tcp_input+0xd6>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
 8013baa:	885b      	ldrh	r3, [r3, #2]
 8013bac:	8b72      	ldrh	r2, [r6, #26]
 8013bae:	429a      	cmp	r2, r3
 8013bb0:	d1ea      	bne.n	8013b88 <tcp_input+0xec>
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
 8013bb2:	4b6d      	ldr	r3, [pc, #436]	; (8013d68 <tcp_input+0x2cc>)
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
       pcb->local_port == tcphdr->dest &&
 8013bb4:	6872      	ldr	r2, [r6, #4]
 8013bb6:	681b      	ldr	r3, [r3, #0]
 8013bb8:	429a      	cmp	r2, r3
 8013bba:	d1e5      	bne.n	8013b88 <tcp_input+0xec>
       ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
 8013bbc:	6832      	ldr	r2, [r6, #0]
 8013bbe:	683b      	ldr	r3, [r7, #0]
 8013bc0:	429a      	cmp	r2, r3
 8013bc2:	d1e1      	bne.n	8013b88 <tcp_input+0xec>
       ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
 8013bc4:	68f3      	ldr	r3, [r6, #12]
 8013bc6:	42b3      	cmp	r3, r6
 8013bc8:	f000 8330 	beq.w	801422c <tcp_input+0x790>
      if (prev != NULL) {
 8013bcc:	f1b8 0f00 	cmp.w	r8, #0
 8013bd0:	d00a      	beq.n	8013be8 <tcp_input+0x14c>
        prev->next = pcb->next;
        pcb->next = tcp_active_pcbs;
 8013bd2:	f8d9 2000 	ldr.w	r2, [r9]
      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
      if (prev != NULL) {
        prev->next = pcb->next;
 8013bd6:	f8c8 300c 	str.w	r3, [r8, #12]
        pcb->next = tcp_active_pcbs;
        tcp_active_pcbs = pcb;
 8013bda:	f8c9 6000 	str.w	r6, [r9]
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
      if (prev != NULL) {
        prev->next = pcb->next;
        pcb->next = tcp_active_pcbs;
 8013bde:	60f2      	str	r2, [r6, #12]
        tcp_active_pcbs = pcb;
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
 8013be0:	68f3      	ldr	r3, [r6, #12]
 8013be2:	42b3      	cmp	r3, r6
 8013be4:	f000 8314 	beq.w	8014210 <tcp_input+0x774>
    inseg.tcphdr = tcphdr;

    recv_data = NULL;
    recv_flags = 0;

    if (flags & TCP_PSH) {
 8013be8:	782a      	ldrb	r2, [r5, #0]
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
 8013bea:	2300      	movs	r3, #0
    inseg.len = p->tot_len;
 8013bec:	8920      	ldrh	r0, [r4, #8]
    inseg.p = p;
    inseg.tcphdr = tcphdr;
 8013bee:	68e9      	ldr	r1, [r5, #12]
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
 8013bf0:	616b      	str	r3, [r5, #20]
    inseg.len = p->tot_len;
    inseg.p = p;
    inseg.tcphdr = tcphdr;

    recv_data = NULL;
 8013bf2:	626b      	str	r3, [r5, #36]	; 0x24
    recv_flags = 0;
 8013bf4:	f885 3028 	strb.w	r3, [r5, #40]	; 0x28

    if (flags & TCP_PSH) {
 8013bf8:	0713      	lsls	r3, r2, #28
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
    inseg.len = p->tot_len;
    inseg.p = p;
 8013bfa:	61ac      	str	r4, [r5, #24]
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
    inseg.len = p->tot_len;
 8013bfc:	83a8      	strh	r0, [r5, #28]
    inseg.p = p;
    inseg.tcphdr = tcphdr;
 8013bfe:	6229      	str	r1, [r5, #32]

    recv_data = NULL;
    recv_flags = 0;

    if (flags & TCP_PSH) {
 8013c00:	d503      	bpl.n	8013c0a <tcp_input+0x16e>
      p->flags |= PBUF_FLAG_PUSH;
 8013c02:	7b63      	ldrb	r3, [r4, #13]
 8013c04:	f043 0301 	orr.w	r3, r3, #1
 8013c08:	7363      	strb	r3, [r4, #13]
    }

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
 8013c0a:	6f73      	ldr	r3, [r6, #116]	; 0x74
 8013c0c:	b163      	cbz	r3, 8013c28 <tcp_input+0x18c>
      if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
 8013c0e:	4630      	mov	r0, r6
 8013c10:	f7f6 fa4e 	bl	800a0b0 <tcp_process_refused_data>
 8013c14:	300a      	adds	r0, #10
 8013c16:	f000 808e 	beq.w	8013d36 <tcp_input+0x29a>
 8013c1a:	6f73      	ldr	r3, [r6, #116]	; 0x74
 8013c1c:	b11b      	cbz	r3, 8013c26 <tcp_input+0x18a>
        ((pcb->refused_data != NULL) && (tcplen > 0))) {
 8013c1e:	8a2b      	ldrh	r3, [r5, #16]
 8013c20:	2b00      	cmp	r3, #0
 8013c22:	f040 8088 	bne.w	8013d36 <tcp_input+0x29a>
 8013c26:	782a      	ldrb	r2, [r5, #0]
        TCP_STATS_INC(tcp.drop);
        snmp_inc_tcpinerrs();
        goto aborted;
      }
    }
    tcp_input_pcb = pcb;
 8013c28:	4f50      	ldr	r7, [pc, #320]	; (8013d6c <tcp_input+0x2d0>)
  err_t err;

  err = ERR_OK;

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
 8013c2a:	0751      	lsls	r1, r2, #29
        TCP_STATS_INC(tcp.drop);
        snmp_inc_tcpinerrs();
        goto aborted;
      }
    }
    tcp_input_pcb = pcb;
 8013c2c:	603e      	str	r6, [r7, #0]
  err_t err;

  err = ERR_OK;

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
 8013c2e:	f140 8084 	bpl.w	8013d3a <tcp_input+0x29e>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
 8013c32:	7e32      	ldrb	r2, [r6, #24]
 8013c34:	2a02      	cmp	r2, #2
 8013c36:	f000 8275 	beq.w	8014124 <tcp_input+0x688>
      if (ackno == pcb->snd_nxt) {
        acceptable = 1;
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
 8013c3a:	686b      	ldr	r3, [r5, #4]
 8013c3c:	6ab1      	ldr	r1, [r6, #40]	; 0x28
 8013c3e:	1a5b      	subs	r3, r3, r1
 8013c40:	d404      	bmi.n	8013c4c <tcp_input+0x1b0>
 8013c42:	8db1      	ldrh	r1, [r6, #44]	; 0x2c
 8013c44:	1a5b      	subs	r3, r3, r1
 8013c46:	2b00      	cmp	r3, #0
 8013c48:	f340 827c 	ble.w	8014144 <tcp_input+0x6a8>
    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
      if (recv_flags & TF_RESET) {
 8013c4c:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
 8013c50:	071a      	lsls	r2, r3, #28
 8013c52:	f140 8117 	bpl.w	8013e84 <tcp_input+0x3e8>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
 8013c56:	f8d6 3088 	ldr.w	r3, [r6, #136]	; 0x88
 8013c5a:	b11b      	cbz	r3, 8013c64 <tcp_input+0x1c8>
 8013c5c:	f06f 010a 	mvn.w	r1, #10
 8013c60:	6930      	ldr	r0, [r6, #16]
 8013c62:	4798      	blx	r3
          /* Connection closed although the application has only shut down the
             tx side: call the PCB's err callback and indicate the closure to
             ensure the application doesn't continue using the PCB. */
          TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_CLSD);
        }
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
 8013c64:	4631      	mov	r1, r6
 8013c66:	4842      	ldr	r0, [pc, #264]	; (8013d70 <tcp_input+0x2d4>)
 8013c68:	f7f6 f8d6 	bl	8009e18 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
 8013c6c:	4631      	mov	r1, r6
 8013c6e:	2002      	movs	r0, #2
 8013c70:	f7fc f844 	bl	800fcfc <memp_free>
aborted:
    tcp_input_pcb = NULL;
    recv_data = NULL;

    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
 8013c74:	69a8      	ldr	r0, [r5, #24]
      }
    }
    /* Jump target if pcb has been aborted in a callback (by calling tcp_abort()).
       Below this line, 'pcb' may not be dereferenced! */
aborted:
    tcp_input_pcb = NULL;
 8013c76:	2400      	movs	r4, #0
    recv_data = NULL;
 8013c78:	626c      	str	r4, [r5, #36]	; 0x24
      }
    }
    /* Jump target if pcb has been aborted in a callback (by calling tcp_abort()).
       Below this line, 'pcb' may not be dereferenced! */
aborted:
    tcp_input_pcb = NULL;
 8013c7a:	603c      	str	r4, [r7, #0]
    recv_data = NULL;
 8013c7c:	4d35      	ldr	r5, [pc, #212]	; (8013d54 <tcp_input+0x2b8>)

    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
 8013c7e:	b110      	cbz	r0, 8013c86 <tcp_input+0x1ea>
    {
      pbuf_free(inseg.p);
 8013c80:	f7fc f9d2 	bl	8010028 <pbuf_free>
      inseg.p = NULL;
 8013c84:	61ac      	str	r4, [r5, #24]
  return;
dropped:
  TCP_STATS_INC(tcp.drop);
  snmp_inc_tcpinerrs();
  pbuf_free(p);
}
 8013c86:	b002      	add	sp, #8
 8013c88:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
 8013c8c:	4b33      	ldr	r3, [pc, #204]	; (8013d5c <tcp_input+0x2c0>)
 8013c8e:	22ad      	movs	r2, #173	; 0xad
 8013c90:	4938      	ldr	r1, [pc, #224]	; (8013d74 <tcp_input+0x2d8>)
 8013c92:	4834      	ldr	r0, [pc, #208]	; (8013d64 <tcp_input+0x2c8>)
 8013c94:	f001 f870 	bl	8014d78 <iprintf>
 8013c98:	e771      	b.n	8013b7e <tcp_input+0xe2>
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
 8013c9a:	4b30      	ldr	r3, [pc, #192]	; (8013d5c <tcp_input+0x2c0>)
 8013c9c:	22ac      	movs	r2, #172	; 0xac
 8013c9e:	4936      	ldr	r1, [pc, #216]	; (8013d78 <tcp_input+0x2dc>)
 8013ca0:	4830      	ldr	r0, [pc, #192]	; (8013d64 <tcp_input+0x2c8>)
 8013ca2:	f001 f869 	bl	8014d78 <iprintf>
 8013ca6:	7e33      	ldrb	r3, [r6, #24]
 8013ca8:	e766      	b.n	8013b78 <tcp_input+0xdc>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
 8013caa:	4b34      	ldr	r3, [pc, #208]	; (8013d7c <tcp_input+0x2e0>)
 8013cac:	681e      	ldr	r6, [r3, #0]
 8013cae:	b91e      	cbnz	r6, 8013cb8 <tcp_input+0x21c>
 8013cb0:	e068      	b.n	8013d84 <tcp_input+0x2e8>
 8013cb2:	68f6      	ldr	r6, [r6, #12]
 8013cb4:	2e00      	cmp	r6, #0
 8013cb6:	d066      	beq.n	8013d86 <tcp_input+0x2ea>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
 8013cb8:	7e32      	ldrb	r2, [r6, #24]
 8013cba:	4b28      	ldr	r3, [pc, #160]	; (8013d5c <tcp_input+0x2c0>)
 8013cbc:	2a0a      	cmp	r2, #10
 8013cbe:	4930      	ldr	r1, [pc, #192]	; (8013d80 <tcp_input+0x2e4>)
 8013cc0:	f04f 02c6 	mov.w	r2, #198	; 0xc6
 8013cc4:	4827      	ldr	r0, [pc, #156]	; (8013d64 <tcp_input+0x2c8>)
 8013cc6:	d001      	beq.n	8013ccc <tcp_input+0x230>
 8013cc8:	f001 f856 	bl	8014d78 <iprintf>
      if (pcb->remote_port == tcphdr->src &&
 8013ccc:	68ea      	ldr	r2, [r5, #12]
 8013cce:	8bb3      	ldrh	r3, [r6, #28]
 8013cd0:	8810      	ldrh	r0, [r2, #0]
 8013cd2:	f8df e080 	ldr.w	lr, [pc, #128]	; 8013d54 <tcp_input+0x2b8>
 8013cd6:	4298      	cmp	r0, r3
 8013cd8:	d1eb      	bne.n	8013cb2 <tcp_input+0x216>
         pcb->local_port == tcphdr->dest &&
 8013cda:	8b73      	ldrh	r3, [r6, #26]
  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
 8013cdc:	f8b2 c002 	ldrh.w	ip, [r2, #2]
 8013ce0:	459c      	cmp	ip, r3
 8013ce2:	d1e6      	bne.n	8013cb2 <tcp_input+0x216>
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
 8013ce4:	f8df 8080 	ldr.w	r8, [pc, #128]	; 8013d68 <tcp_input+0x2cc>
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
         pcb->local_port == tcphdr->dest &&
 8013ce8:	6873      	ldr	r3, [r6, #4]
 8013cea:	f8d8 1000 	ldr.w	r1, [r8]
 8013cee:	428b      	cmp	r3, r1
 8013cf0:	d1df      	bne.n	8013cb2 <tcp_input+0x216>
         ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src) &&
 8013cf2:	6839      	ldr	r1, [r7, #0]
 8013cf4:	6833      	ldr	r3, [r6, #0]
 8013cf6:	428b      	cmp	r3, r1
 8013cf8:	d1db      	bne.n	8013cb2 <tcp_input+0x216>
  /* RFC 1337: in TIME_WAIT, ignore RST and ACK FINs + any 'acceptable' segments */
  /* RFC 793 3.9 Event Processing - Segment Arrives:
   * - first check sequence number - we skip that one in TIME_WAIT (always
   *   acceptable since we only send ACKs)
   * - second check the RST bit (... return) */
  if (flags & TCP_RST)  {
 8013cfa:	f89e 2000 	ldrb.w	r2, [lr]
 8013cfe:	0751      	lsls	r1, r2, #29
 8013d00:	f53f aee0 	bmi.w	8013ac4 <tcp_input+0x28>
    return ERR_OK;
  }
  /* - fourth, check the SYN bit, */
  if (flags & TCP_SYN) {
 8013d04:	0793      	lsls	r3, r2, #30
 8013d06:	f140 828a 	bpl.w	801421e <tcp_input+0x782>
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
 8013d0a:	f8de 1004 	ldr.w	r1, [lr, #4]
 8013d0e:	6ab2      	ldr	r2, [r6, #40]	; 0x28
 8013d10:	1a8a      	subs	r2, r1, r2
 8013d12:	d404      	bmi.n	8013d1e <tcp_input+0x282>
 8013d14:	8db7      	ldrh	r7, [r6, #44]	; 0x2c
 8013d16:	1bd2      	subs	r2, r2, r7
 8013d18:	2a00      	cmp	r2, #0
 8013d1a:	f340 8269 	ble.w	80141f0 <tcp_input+0x754>
    /* - eighth, check the FIN bit: Remain in the TIME-WAIT state.
         Restart the 2 MSL time-wait timeout.*/
    pcb->tmr = tcp_ticks;
  }

  if ((tcplen > 0))  {
 8013d1e:	8a2b      	ldrh	r3, [r5, #16]
 8013d20:	2b00      	cmp	r3, #0
 8013d22:	f43f aecf 	beq.w	8013ac4 <tcp_input+0x28>
    /* Acknowledge data, FIN or out-of-window SYN */
    pcb->flags |= TF_ACK_NOW;
 8013d26:	7fb3      	ldrb	r3, [r6, #30]
    return tcp_output(pcb);
 8013d28:	4630      	mov	r0, r6
    pcb->tmr = tcp_ticks;
  }

  if ((tcplen > 0))  {
    /* Acknowledge data, FIN or out-of-window SYN */
    pcb->flags |= TF_ACK_NOW;
 8013d2a:	f043 0302 	orr.w	r3, r3, #2
 8013d2e:	77b3      	strb	r3, [r6, #30]
    return tcp_output(pcb);
 8013d30:	f7f7 f816 	bl	800ad60 <tcp_output>
 8013d34:	e6c6      	b.n	8013ac4 <tcp_input+0x28>
 8013d36:	4f0d      	ldr	r7, [pc, #52]	; (8013d6c <tcp_input+0x2d0>)
 8013d38:	e79c      	b.n	8013c74 <tcp_input+0x1d8>
       seqno, pcb->rcv_nxt));
      return ERR_OK;
    }
  }

  if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) { 
 8013d3a:	0793      	lsls	r3, r2, #30
 8013d3c:	f140 80b3 	bpl.w	8013ea6 <tcp_input+0x40a>
 8013d40:	7e33      	ldrb	r3, [r6, #24]
 8013d42:	3b02      	subs	r3, #2
 8013d44:	2b01      	cmp	r3, #1
 8013d46:	f240 80ae 	bls.w	8013ea6 <tcp_input+0x40a>
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
      if (err == ERR_ABRT) {
        return ERR_ABRT;
      }
      tcp_ack_now(pcb);
 8013d4a:	7fb3      	ldrb	r3, [r6, #30]
 8013d4c:	f043 0302 	orr.w	r3, r3, #2
 8013d50:	77b3      	strb	r3, [r6, #30]
 8013d52:	e77b      	b.n	8013c4c <tcp_input+0x1b0>
 8013d54:	20004cc8 	.word	0x20004cc8
 8013d58:	2000f0a4 	.word	0x2000f0a4
 8013d5c:	080183b0 	.word	0x080183b0
 8013d60:	080184c4 	.word	0x080184c4
 8013d64:	0801660c 	.word	0x0801660c
 8013d68:	2000f09c 	.word	0x2000f09c
 8013d6c:	20016ff4 	.word	0x20016ff4
 8013d70:	2000f040 	.word	0x2000f040
 8013d74:	08018518 	.word	0x08018518
 8013d78:	080184ec 	.word	0x080184ec
 8013d7c:	2000f054 	.word	0x2000f054
 8013d80:	08018598 	.word	0x08018598
 8013d84:	68ea      	ldr	r2, [r5, #12]
    }

    /* Finally, if we still did not get a match, we check all PCBs that
       are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 8013d86:	f8df c2f8 	ldr.w	ip, [pc, #760]	; 8014080 <tcp_input+0x5e4>
 8013d8a:	f8dc e000 	ldr.w	lr, [ip]
 8013d8e:	f1be 0f00 	cmp.w	lr, #0
 8013d92:	f000 81b3 	beq.w	80140fc <tcp_input+0x660>
 8013d96:	8850      	ldrh	r0, [r2, #2]
          /* found an ANY-match */
          lpcb_any = lpcb;
          lpcb_prev = prev;
        }
#else /* SO_REUSE */
        if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest) ||
 8013d98:	f8d7 8000 	ldr.w	r8, [r7]
 8013d9c:	4676      	mov	r6, lr
 8013d9e:	2100      	movs	r1, #0
 8013da0:	e005      	b.n	8013dae <tcp_input+0x312>
    }

    /* Finally, if we still did not get a match, we check all PCBs that
       are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
 8013da2:	68f3      	ldr	r3, [r6, #12]
 8013da4:	4631      	mov	r1, r6
 8013da6:	2b00      	cmp	r3, #0
 8013da8:	f000 81a8 	beq.w	80140fc <tcp_input+0x660>
 8013dac:	461e      	mov	r6, r3
      if (lpcb->local_port == tcphdr->dest) {
 8013dae:	8b73      	ldrh	r3, [r6, #26]
 8013db0:	4283      	cmp	r3, r0
 8013db2:	d1f6      	bne.n	8013da2 <tcp_input+0x306>
          /* found an ANY-match */
          lpcb_any = lpcb;
          lpcb_prev = prev;
        }
#else /* SO_REUSE */
        if (ip_addr_cmp(&(lpcb->local_ip), &current_iphdr_dest) ||
 8013db4:	6833      	ldr	r3, [r6, #0]
 8013db6:	4543      	cmp	r3, r8
 8013db8:	d001      	beq.n	8013dbe <tcp_input+0x322>
            ip_addr_isany(&(lpcb->local_ip))) {
 8013dba:	2b00      	cmp	r3, #0
 8013dbc:	d1f1      	bne.n	8013da2 <tcp_input+0x306>
#endif /* SO_REUSE */
    if (lpcb != NULL) {
      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      if (prev != NULL) {
 8013dbe:	b129      	cbz	r1, 8013dcc <tcp_input+0x330>
        ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
 8013dc0:	68f3      	ldr	r3, [r6, #12]
              /* our successor is the remainder of the listening list */
        lpcb->next = tcp_listen_pcbs.listen_pcbs;
              /* put this listening pcb at the head of the listening list */
        tcp_listen_pcbs.listen_pcbs = lpcb;
 8013dc2:	f8cc 6000 	str.w	r6, [ip]
    if (lpcb != NULL) {
      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      if (prev != NULL) {
        ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
 8013dc6:	60cb      	str	r3, [r1, #12]
              /* our successor is the remainder of the listening list */
        lpcb->next = tcp_listen_pcbs.listen_pcbs;
 8013dc8:	f8c6 e00c 	str.w	lr, [r6, #12]
tcp_listen_input(struct tcp_pcb_listen *pcb)
{
  struct tcp_pcb *npcb;
  err_t rc;

  if (flags & TCP_RST) {
 8013dcc:	782b      	ldrb	r3, [r5, #0]
 8013dce:	f8df a29c 	ldr.w	sl, [pc, #668]	; 801406c <tcp_input+0x5d0>
 8013dd2:	075d      	lsls	r5, r3, #29
 8013dd4:	f53f ae76 	bmi.w	8013ac4 <tcp_input+0x28>
    return ERR_OK;
  }

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
 8013dd8:	f003 0110 	and.w	r1, r3, #16
 8013ddc:	f001 08ff 	and.w	r8, r1, #255	; 0xff
 8013de0:	2900      	cmp	r1, #0
 8013de2:	f040 81b9 	bne.w	8014158 <tcp_input+0x6bc>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
      ip_current_src_addr(), tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
 8013de6:	0798      	lsls	r0, r3, #30
 8013de8:	f57f ae6c 	bpl.w	8013ac4 <tcp_input+0x28>
    if (pcb->accepts_pending >= pcb->backlog) {
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: listen backlog exceeded for port %"U16_F"\n", tcphdr->dest));
      return ERR_ABRT;
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
 8013dec:	7e70      	ldrb	r0, [r6, #25]
 8013dee:	f7f6 fa6f 	bl	800a2d0 <tcp_alloc>
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
 8013df2:	4605      	mov	r5, r0
 8013df4:	2800      	cmp	r0, #0
 8013df6:	f43f ae65 	beq.w	8013ac4 <tcp_input+0x28>
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
    npcb->local_port = pcb->local_port;
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
    npcb->remote_port = tcphdr->src;
 8013dfa:	f8da 000c 	ldr.w	r0, [sl, #12]
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
 8013dfe:	6839      	ldr	r1, [r7, #0]
    npcb->local_port = pcb->local_port;
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
    npcb->remote_port = tcphdr->src;
 8013e00:	f890 e000 	ldrb.w	lr, [r0]
 8013e04:	7847      	ldrb	r7, [r0, #1]
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
    npcb->local_port = pcb->local_port;
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
 8013e06:	4a96      	ldr	r2, [pc, #600]	; (8014060 <tcp_input+0x5c4>)
    npcb->remote_port = tcphdr->src;
    npcb->state = SYN_RCVD;
    npcb->rcv_nxt = seqno + 1;
 8013e08:	f8da 3004 	ldr.w	r3, [sl, #4]
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
    npcb->local_port = pcb->local_port;
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
 8013e0c:	6812      	ldr	r2, [r2, #0]
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
 8013e0e:	6029      	str	r1, [r5, #0]
    npcb->local_port = pcb->local_port;
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
    npcb->remote_port = tcphdr->src;
 8013e10:	ea4e 2107 	orr.w	r1, lr, r7, lsl #8
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
    npcb->local_port = pcb->local_port;
 8013e14:	8b77      	ldrh	r7, [r6, #26]
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
    npcb->remote_port = tcphdr->src;
 8013e16:	83a9      	strh	r1, [r5, #28]
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
    npcb->local_port = pcb->local_port;
 8013e18:	836f      	strh	r7, [r5, #26]
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
    npcb->remote_port = tcphdr->src;
    npcb->state = SYN_RCVD;
    npcb->rcv_nxt = seqno + 1;
 8013e1a:	1c59      	adds	r1, r3, #1
    /* Set up the new PCB. */
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
    npcb->local_port = pcb->local_port;
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
    npcb->remote_port = tcphdr->src;
    npcb->state = SYN_RCVD;
 8013e1c:	2703      	movs	r7, #3
    npcb->rcv_nxt = seqno + 1;
 8013e1e:	62a9      	str	r1, [r5, #40]	; 0x28
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
 8013e20:	6329      	str	r1, [r5, #48]	; 0x30
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_copy(npcb->local_ip, current_iphdr_dest);
    npcb->local_port = pcb->local_port;
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
 8013e22:	606a      	str	r2, [r5, #4]
    npcb->remote_port = tcphdr->src;
    npcb->state = SYN_RCVD;
 8013e24:	762f      	strb	r7, [r5, #24]
    npcb->rcv_nxt = seqno + 1;
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
    npcb->snd_wnd = tcphdr->wnd;
 8013e26:	89c0      	ldrh	r0, [r0, #14]
    npcb->snd_wnd_max = tcphdr->wnd;
    npcb->ssthresh = npcb->snd_wnd;
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
    npcb->callback_arg = pcb->callback_arg;
 8013e28:	6931      	ldr	r1, [r6, #16]
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
 8013e2a:	6972      	ldr	r2, [r6, #20]
    npcb->rcv_nxt = seqno + 1;
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
    npcb->snd_wnd = tcphdr->wnd;
    npcb->snd_wnd_max = tcphdr->wnd;
    npcb->ssthresh = npcb->snd_wnd;
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
 8013e2c:	3b01      	subs	r3, #1
    npcb->callback_arg = pcb->callback_arg;
 8013e2e:	6129      	str	r1, [r5, #16]
    ip_addr_copy(npcb->remote_ip, current_iphdr_src);
    npcb->remote_port = tcphdr->src;
    npcb->state = SYN_RCVD;
    npcb->rcv_nxt = seqno + 1;
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
    npcb->snd_wnd = tcphdr->wnd;
 8013e30:	f8a5 0060 	strh.w	r0, [r5, #96]	; 0x60
    npcb->snd_wnd_max = tcphdr->wnd;
 8013e34:	f8a5 0062 	strh.w	r0, [r5, #98]	; 0x62
    npcb->ssthresh = npcb->snd_wnd;
 8013e38:	f8a5 004e 	strh.w	r0, [r5, #78]	; 0x4e
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
    npcb->callback_arg = pcb->callback_arg;
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
 8013e3c:	616a      	str	r2, [r5, #20]
    npcb->rcv_nxt = seqno + 1;
    npcb->rcv_ann_right_edge = npcb->rcv_nxt;
    npcb->snd_wnd = tcphdr->wnd;
    npcb->snd_wnd_max = tcphdr->wnd;
    npcb->ssthresh = npcb->snd_wnd;
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
 8013e3e:	656b      	str	r3, [r5, #84]	; 0x54
    npcb->callback_arg = pcb->callback_arg;
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & SOF_INHERITED;
 8013e40:	7a33      	ldrb	r3, [r6, #8]
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG_ACTIVE(npcb);
 8013e42:	f8d9 2000 	ldr.w	r2, [r9]
    npcb->callback_arg = pcb->callback_arg;
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & SOF_INHERITED;
 8013e46:	f023 0373 	bic.w	r3, r3, #115	; 0x73
 8013e4a:	722b      	strb	r3, [r5, #8]
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG_ACTIVE(npcb);
 8013e4c:	60ea      	str	r2, [r5, #12]
 8013e4e:	f8c9 5000 	str.w	r5, [r9]
 8013e52:	f7f7 fbeb 	bl	800b62c <tcp_timer_needed>
 8013e56:	4b83      	ldr	r3, [pc, #524]	; (8014064 <tcp_input+0x5c8>)
 8013e58:	2201      	movs	r2, #1

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
 8013e5a:	f105 0036 	add.w	r0, r5, #54	; 0x36
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & SOF_INHERITED;
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG_ACTIVE(npcb);
 8013e5e:	701a      	strb	r2, [r3, #0]

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
 8013e60:	f7ff fdd4 	bl	8013a0c <tcp_parseopt.isra.0>
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
 8013e64:	1d29      	adds	r1, r5, #4
 8013e66:	8ee8      	ldrh	r0, [r5, #54]	; 0x36
 8013e68:	f7f6 fad4 	bl	800a414 <tcp_eff_send_mss>
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Send a SYN|ACK together with the MSS option. */
    rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
 8013e6c:	2112      	movs	r1, #18
    TCP_REG_ACTIVE(npcb);

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
 8013e6e:	86e8      	strh	r0, [r5, #54]	; 0x36
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Send a SYN|ACK together with the MSS option. */
    rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
 8013e70:	4628      	mov	r0, r5
 8013e72:	f7f6 fe73 	bl	800ab5c <tcp_enqueue_flags>
    if (rc != ERR_OK) {
 8013e76:	2800      	cmp	r0, #0
 8013e78:	f040 81a8 	bne.w	80141cc <tcp_input+0x730>
      tcp_abandon(npcb, 0);
      return rc;
    }
    return tcp_output(npcb);
 8013e7c:	4628      	mov	r0, r5
 8013e7e:	f7f6 ff6f 	bl	800ad60 <tcp_output>
 8013e82:	e61f      	b.n	8013ac4 <tcp_input+0x28>
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
        memp_free(MEMP_TCP_PCB, pcb);
      } else if (recv_flags & TF_CLOSED) {
 8013e84:	06dc      	lsls	r4, r3, #27
 8013e86:	f140 80fd 	bpl.w	8014084 <tcp_input+0x5e8>
        /* The connection has been closed and we will deallocate the
           PCB. */
        if (!(pcb->flags & TF_RXCLOSED)) {
 8013e8a:	7fb3      	ldrb	r3, [r6, #30]
 8013e8c:	06d8      	lsls	r0, r3, #27
 8013e8e:	f53f aee9 	bmi.w	8013c64 <tcp_input+0x1c8>
          /* Connection closed although the application has only shut down the
             tx side: call the PCB's err callback and indicate the closure to
             ensure the application doesn't continue using the PCB. */
          TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_CLSD);
 8013e92:	f8d6 3088 	ldr.w	r3, [r6, #136]	; 0x88
 8013e96:	2b00      	cmp	r3, #0
 8013e98:	f43f aee4 	beq.w	8013c64 <tcp_input+0x1c8>
 8013e9c:	f06f 010b 	mvn.w	r1, #11
 8013ea0:	6930      	ldr	r0, [r6, #16]
 8013ea2:	4798      	blx	r3
 8013ea4:	e6de      	b.n	8013c64 <tcp_input+0x1c8>
    /* Cope with new connection attempt after remote end crashed */
    tcp_ack_now(pcb);
    return ERR_OK;
  }
  
  if ((pcb->flags & TF_RXCLOSED) == 0) {
 8013ea6:	7fb3      	ldrb	r3, [r6, #30]
 8013ea8:	06dc      	lsls	r4, r3, #27
 8013eaa:	d402      	bmi.n	8013eb2 <tcp_input+0x416>
    /* Update the PCB (in)activity timer unless rx is closed (see tcp_shutdown) */
    pcb->tmr = tcp_ticks;
 8013eac:	4b6e      	ldr	r3, [pc, #440]	; (8014068 <tcp_input+0x5cc>)
 8013eae:	681b      	ldr	r3, [r3, #0]
 8013eb0:	6273      	str	r3, [r6, #36]	; 0x24
  }
  pcb->keep_cnt_sent = 0;
 8013eb2:	2300      	movs	r3, #0
 8013eb4:	f886 3092 	strb.w	r3, [r6, #146]	; 0x92

  tcp_parseopt(pcb);
 8013eb8:	f106 0036 	add.w	r0, r6, #54	; 0x36
 8013ebc:	f7ff fda6 	bl	8013a0c <tcp_parseopt.isra.0>

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
 8013ec0:	7e33      	ldrb	r3, [r6, #24]
 8013ec2:	3b02      	subs	r3, #2
 8013ec4:	2b07      	cmp	r3, #7
 8013ec6:	f63f aec1 	bhi.w	8013c4c <tcp_input+0x1b0>
 8013eca:	e8df f003 	tbb	[pc, r3]
 8013ece:	ad84      	.short	0xad84
 8013ed0:	9e3b6b9e 	.word	0x9e3b6b9e
 8013ed4:	0418      	.short	0x0418
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
    }
    break;
  case LAST_ACK:
    tcp_receive(pcb);
 8013ed6:	4630      	mov	r0, r6
 8013ed8:	f7ff fa7a 	bl	80133d0 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
 8013edc:	782a      	ldrb	r2, [r5, #0]
 8013ede:	4b63      	ldr	r3, [pc, #396]	; (801406c <tcp_input+0x5d0>)
 8013ee0:	06d1      	lsls	r1, r2, #27
 8013ee2:	f57f aeb3 	bpl.w	8013c4c <tcp_input+0x1b0>
 8013ee6:	6d31      	ldr	r1, [r6, #80]	; 0x50
 8013ee8:	689a      	ldr	r2, [r3, #8]
 8013eea:	4291      	cmp	r1, r2
 8013eec:	f47f aeae 	bne.w	8013c4c <tcp_input+0x1b0>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags |= TF_CLOSED;
 8013ef0:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
 8013ef4:	f042 0210 	orr.w	r2, r2, #16
 8013ef8:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
 8013efc:	e6a6      	b.n	8013c4c <tcp_input+0x1b0>
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
    }
    break;
  case CLOSING:
    tcp_receive(pcb);
 8013efe:	4630      	mov	r0, r6
 8013f00:	f7ff fa66 	bl	80133d0 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
 8013f04:	782a      	ldrb	r2, [r5, #0]
 8013f06:	4b59      	ldr	r3, [pc, #356]	; (801406c <tcp_input+0x5d0>)
 8013f08:	06d0      	lsls	r0, r2, #27
 8013f0a:	f57f ae9f 	bpl.w	8013c4c <tcp_input+0x1b0>
 8013f0e:	689b      	ldr	r3, [r3, #8]
 8013f10:	6d32      	ldr	r2, [r6, #80]	; 0x50
 8013f12:	429a      	cmp	r2, r3
 8013f14:	f47f ae9a 	bne.w	8013c4c <tcp_input+0x1b0>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_pcb_purge(pcb);
 8013f18:	4630      	mov	r0, r6
 8013f1a:	f7f5 ff75 	bl	8009e08 <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
 8013f1e:	f8d9 2000 	ldr.w	r2, [r9]
 8013f22:	4b53      	ldr	r3, [pc, #332]	; (8014070 <tcp_input+0x5d4>)
 8013f24:	42b2      	cmp	r2, r6
 8013f26:	f000 8170 	beq.w	801420a <tcp_input+0x76e>
 8013f2a:	4b52      	ldr	r3, [pc, #328]	; (8014074 <tcp_input+0x5d8>)
 8013f2c:	2100      	movs	r1, #0
 8013f2e:	601a      	str	r2, [r3, #0]
 8013f30:	2a00      	cmp	r2, #0
 8013f32:	f000 824b 	beq.w	80143cc <tcp_input+0x930>
 8013f36:	68d0      	ldr	r0, [r2, #12]
 8013f38:	42b0      	cmp	r0, r6
 8013f3a:	f000 819b 	beq.w	8014274 <tcp_input+0x7d8>
 8013f3e:	4602      	mov	r2, r0
 8013f40:	2101      	movs	r1, #1
 8013f42:	e7f5      	b.n	8013f30 <tcp_input+0x494>
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
      pcb->state = FIN_WAIT_2;
    }
    break;
  case FIN_WAIT_2:
    tcp_receive(pcb);
 8013f44:	4630      	mov	r0, r6
 8013f46:	f7ff fa43 	bl	80133d0 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) {
 8013f4a:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
 8013f4e:	069c      	lsls	r4, r3, #26
 8013f50:	f57f ae7c 	bpl.w	8013c4c <tcp_input+0x1b0>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: FIN_WAIT_2 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
 8013f54:	7fb3      	ldrb	r3, [r6, #30]
      tcp_pcb_purge(pcb);
 8013f56:	4630      	mov	r0, r6
    break;
  case FIN_WAIT_2:
    tcp_receive(pcb);
    if (recv_flags & TF_GOT_FIN) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: FIN_WAIT_2 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
 8013f58:	f043 0302 	orr.w	r3, r3, #2
 8013f5c:	77b3      	strb	r3, [r6, #30]
      tcp_pcb_purge(pcb);
 8013f5e:	f7f5 ff53 	bl	8009e08 <tcp_pcb_purge>
      TCP_RMV_ACTIVE(pcb);
 8013f62:	f8d9 2000 	ldr.w	r2, [r9]
 8013f66:	4b42      	ldr	r3, [pc, #264]	; (8014070 <tcp_input+0x5d4>)
 8013f68:	42b2      	cmp	r2, r6
 8013f6a:	f000 814e 	beq.w	801420a <tcp_input+0x76e>
 8013f6e:	4b41      	ldr	r3, [pc, #260]	; (8014074 <tcp_input+0x5d8>)
 8013f70:	601a      	str	r2, [r3, #0]
 8013f72:	b15a      	cbz	r2, 8013f8c <tcp_input+0x4f0>
 8013f74:	68d1      	ldr	r1, [r2, #12]
 8013f76:	42b1      	cmp	r1, r6
 8013f78:	d104      	bne.n	8013f84 <tcp_input+0x4e8>
 8013f7a:	e17c      	b.n	8014276 <tcp_input+0x7da>
 8013f7c:	68d1      	ldr	r1, [r2, #12]
 8013f7e:	42b1      	cmp	r1, r6
 8013f80:	f000 817c 	beq.w	801427c <tcp_input+0x7e0>
 8013f84:	460a      	mov	r2, r1
 8013f86:	2900      	cmp	r1, #0
 8013f88:	d1f8      	bne.n	8013f7c <tcp_input+0x4e0>
 8013f8a:	601a      	str	r2, [r3, #0]
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
 8013f8c:	4b3a      	ldr	r3, [pc, #232]	; (8014078 <tcp_input+0x5dc>)
  case CLOSING:
    tcp_receive(pcb);
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
 8013f8e:	4a35      	ldr	r2, [pc, #212]	; (8014064 <tcp_input+0x5c8>)
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
 8013f90:	6819      	ldr	r1, [r3, #0]
    tcp_receive(pcb);
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
      pcb->state = TIME_WAIT;
 8013f92:	200a      	movs	r0, #10
      TCP_REG(&tcp_tw_pcbs, pcb);
 8013f94:	60f1      	str	r1, [r6, #12]
    tcp_receive(pcb);
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
      pcb->state = TIME_WAIT;
 8013f96:	7630      	strb	r0, [r6, #24]
  case CLOSING:
    tcp_receive(pcb);
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
 8013f98:	2101      	movs	r1, #1
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
 8013f9a:	601e      	str	r6, [r3, #0]
  case CLOSING:
    tcp_receive(pcb);
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
 8013f9c:	7011      	strb	r1, [r2, #0]
      pcb->state = TIME_WAIT;
      TCP_REG(&tcp_tw_pcbs, pcb);
 8013f9e:	f7f7 fb45 	bl	800b62c <tcp_timer_needed>
 8013fa2:	e653      	b.n	8013c4c <tcp_input+0x1b0>
      tcp_ack_now(pcb);
      pcb->state = CLOSE_WAIT;
    }
    break;
  case FIN_WAIT_1:
    tcp_receive(pcb);
 8013fa4:	4630      	mov	r0, r6
 8013fa6:	f7ff fa13 	bl	80133d0 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) {
 8013faa:	f895 2028 	ldrb.w	r2, [r5, #40]	; 0x28
 8013fae:	4b2f      	ldr	r3, [pc, #188]	; (801406c <tcp_input+0x5d0>)
 8013fb0:	f012 0f20 	tst.w	r2, #32
      if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
 8013fb4:	781a      	ldrb	r2, [r3, #0]
      pcb->state = CLOSE_WAIT;
    }
    break;
  case FIN_WAIT_1:
    tcp_receive(pcb);
    if (recv_flags & TF_GOT_FIN) {
 8013fb6:	f000 80ec 	beq.w	8014192 <tcp_input+0x6f6>
      if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
 8013fba:	06d1      	lsls	r1, r2, #27
 8013fbc:	d504      	bpl.n	8013fc8 <tcp_input+0x52c>
 8013fbe:	689b      	ldr	r3, [r3, #8]
 8013fc0:	6d32      	ldr	r2, [r6, #80]	; 0x50
 8013fc2:	429a      	cmp	r2, r3
 8013fc4:	f000 813e 	beq.w	8014244 <tcp_input+0x7a8>
        tcp_pcb_purge(pcb);
        TCP_RMV_ACTIVE(pcb);
        pcb->state = TIME_WAIT;
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        tcp_ack_now(pcb);
 8013fc8:	7fb3      	ldrb	r3, [r6, #30]
        pcb->state = CLOSING;
 8013fca:	2208      	movs	r2, #8
        tcp_pcb_purge(pcb);
        TCP_RMV_ACTIVE(pcb);
        pcb->state = TIME_WAIT;
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        tcp_ack_now(pcb);
 8013fcc:	f043 0302 	orr.w	r3, r3, #2
 8013fd0:	77b3      	strb	r3, [r6, #30]
        pcb->state = CLOSING;
 8013fd2:	7632      	strb	r2, [r6, #24]
 8013fd4:	e63a      	b.n	8013c4c <tcp_input+0x1b0>
  switch (pcb->state) {
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
 8013fd6:	782b      	ldrb	r3, [r5, #0]
 8013fd8:	4c24      	ldr	r4, [pc, #144]	; (801406c <tcp_input+0x5d0>)
 8013fda:	f003 0312 	and.w	r3, r3, #18
 8013fde:	2b12      	cmp	r3, #18
 8013fe0:	f000 814e 	beq.w	8014280 <tcp_input+0x7e4>
        return ERR_ABRT;
      }
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
 8013fe4:	782a      	ldrb	r2, [r5, #0]
 8013fe6:	4b21      	ldr	r3, [pc, #132]	; (801406c <tcp_input+0x5d0>)
 8013fe8:	06d0      	lsls	r0, r2, #27
 8013fea:	f57f ae2f 	bpl.w	8013c4c <tcp_input+0x1b0>
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
        tcphdr->dest, tcphdr->src);
 8013fee:	68da      	ldr	r2, [r3, #12]
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
 8013ff0:	8a18      	ldrh	r0, [r3, #16]
 8013ff2:	8814      	ldrh	r4, [r2, #0]
 8013ff4:	6859      	ldr	r1, [r3, #4]
 8013ff6:	9401      	str	r4, [sp, #4]
 8013ff8:	8852      	ldrh	r2, [r2, #2]
 8013ffa:	4401      	add	r1, r0
 8013ffc:	9200      	str	r2, [sp, #0]
 8013ffe:	6898      	ldr	r0, [r3, #8]
 8014000:	4a1e      	ldr	r2, [pc, #120]	; (801407c <tcp_input+0x5e0>)
 8014002:	4b17      	ldr	r3, [pc, #92]	; (8014060 <tcp_input+0x5c4>)
 8014004:	f7f7 f81e 	bl	800b044 <tcp_rst>
 8014008:	e620      	b.n	8013c4c <tcp_input+0x1b0>
    }
    break;
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    tcp_receive(pcb);
 801400a:	4630      	mov	r0, r6
 801400c:	f7ff f9e0 	bl	80133d0 <tcp_receive>
    if (recv_flags & TF_GOT_FIN) { /* passive close */
 8014010:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
 8014014:	0698      	lsls	r0, r3, #26
 8014016:	f57f ae19 	bpl.w	8013c4c <tcp_input+0x1b0>
      tcp_ack_now(pcb);
 801401a:	7fb3      	ldrb	r3, [r6, #30]
      pcb->state = CLOSE_WAIT;
 801401c:	2207      	movs	r2, #7
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    tcp_receive(pcb);
    if (recv_flags & TF_GOT_FIN) { /* passive close */
      tcp_ack_now(pcb);
 801401e:	f043 0302 	orr.w	r3, r3, #2
 8014022:	77b3      	strb	r3, [r6, #30]
      pcb->state = CLOSE_WAIT;
 8014024:	7632      	strb	r2, [r6, #24]
 8014026:	e611      	b.n	8013c4c <tcp_input+0x1b0>
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
        tcphdr->dest, tcphdr->src);
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK) {
 8014028:	782b      	ldrb	r3, [r5, #0]
 801402a:	4a10      	ldr	r2, [pc, #64]	; (801406c <tcp_input+0x5d0>)
 801402c:	06d9      	lsls	r1, r3, #27
 801402e:	f140 80d2 	bpl.w	80141d6 <tcp_input+0x73a>
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
 8014032:	6cb3      	ldr	r3, [r6, #72]	; 0x48
 8014034:	6890      	ldr	r0, [r2, #8]
 8014036:	43db      	mvns	r3, r3
 8014038:	42c3      	cmn	r3, r0
 801403a:	d404      	bmi.n	8014046 <tcp_input+0x5aa>
 801403c:	6d33      	ldr	r3, [r6, #80]	; 0x50
 801403e:	1ac3      	subs	r3, r0, r3
 8014040:	2b00      	cmp	r3, #0
 8014042:	f340 8175 	ble.w	8014330 <tcp_input+0x894>
          pcb->state = CLOSE_WAIT;
        }
      } else {
        /* incorrect ACK number, send RST */
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
                tcphdr->dest, tcphdr->src);
 8014046:	68eb      	ldr	r3, [r5, #12]
          tcp_ack_now(pcb);
          pcb->state = CLOSE_WAIT;
        }
      } else {
        /* incorrect ACK number, send RST */
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
 8014048:	8a29      	ldrh	r1, [r5, #16]
 801404a:	881a      	ldrh	r2, [r3, #0]
 801404c:	9201      	str	r2, [sp, #4]
 801404e:	885a      	ldrh	r2, [r3, #2]
 8014050:	686b      	ldr	r3, [r5, #4]
 8014052:	9200      	str	r2, [sp, #0]
 8014054:	4419      	add	r1, r3
 8014056:	4a09      	ldr	r2, [pc, #36]	; (801407c <tcp_input+0x5e0>)
 8014058:	4b01      	ldr	r3, [pc, #4]	; (8014060 <tcp_input+0x5c4>)
 801405a:	f7f6 fff3 	bl	800b044 <tcp_rst>
 801405e:	e5f5      	b.n	8013c4c <tcp_input+0x1b0>
 8014060:	2000f09c 	.word	0x2000f09c
 8014064:	2000f03c 	.word	0x2000f03c
 8014068:	2000f044 	.word	0x2000f044
 801406c:	20004cc8 	.word	0x20004cc8
 8014070:	2000f040 	.word	0x2000f040
 8014074:	2000f04c 	.word	0x2000f04c
 8014078:	2000f054 	.word	0x2000f054
 801407c:	2000f0a4 	.word	0x2000f0a4
 8014080:	2000f048 	.word	0x2000f048
      } else {
        err = ERR_OK;
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
 8014084:	f8b6 2064 	ldrh.w	r2, [r6, #100]	; 0x64
 8014088:	b13a      	cbz	r2, 801409a <tcp_input+0x5fe>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
 801408a:	6fb3      	ldr	r3, [r6, #120]	; 0x78
 801408c:	b12b      	cbz	r3, 801409a <tcp_input+0x5fe>
 801408e:	4631      	mov	r1, r6
 8014090:	6930      	ldr	r0, [r6, #16]
 8014092:	4798      	blx	r3
          if (err == ERR_ABRT) {
 8014094:	300a      	adds	r0, #10
 8014096:	f43f aded 	beq.w	8013c74 <tcp_input+0x1d8>
            goto aborted;
          }
        }

        if (recv_data != NULL) {
 801409a:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 801409c:	b1eb      	cbz	r3, 80140da <tcp_input+0x63e>
          LWIP_ASSERT("pcb->refused_data == NULL", pcb->refused_data == NULL);
 801409e:	6f73      	ldr	r3, [r6, #116]	; 0x74
 80140a0:	b133      	cbz	r3, 80140b0 <tcp_input+0x614>
 80140a2:	4bac      	ldr	r3, [pc, #688]	; (8014354 <tcp_input+0x8b8>)
 80140a4:	f44f 72aa 	mov.w	r2, #340	; 0x154
 80140a8:	49ab      	ldr	r1, [pc, #684]	; (8014358 <tcp_input+0x8bc>)
 80140aa:	48ac      	ldr	r0, [pc, #688]	; (801435c <tcp_input+0x8c0>)
 80140ac:	f000 fe64 	bl	8014d78 <iprintf>
          if (pcb->flags & TF_RXCLOSED) {
 80140b0:	7fb2      	ldrb	r2, [r6, #30]
 80140b2:	f002 0210 	and.w	r2, r2, #16
 80140b6:	f002 03ff 	and.w	r3, r2, #255	; 0xff
 80140ba:	2a00      	cmp	r2, #0
 80140bc:	d15b      	bne.n	8014176 <tcp_input+0x6da>
            tcp_abort(pcb);
            goto aborted;
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
 80140be:	6ff4      	ldr	r4, [r6, #124]	; 0x7c
 80140c0:	2c00      	cmp	r4, #0
 80140c2:	d05f      	beq.n	8014184 <tcp_input+0x6e8>
 80140c4:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 80140c6:	4631      	mov	r1, r6
 80140c8:	6930      	ldr	r0, [r6, #16]
 80140ca:	47a0      	blx	r4
          if (err == ERR_ABRT) {
 80140cc:	f110 0f0a 	cmn.w	r0, #10
 80140d0:	f43f add0 	beq.w	8013c74 <tcp_input+0x1d8>
            goto aborted;
          }

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
 80140d4:	b108      	cbz	r0, 80140da <tcp_input+0x63e>
            pcb->refused_data = recv_data;
 80140d6:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 80140d8:	6773      	str	r3, [r6, #116]	; 0x74
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
 80140da:	f895 3028 	ldrb.w	r3, [r5, #40]	; 0x28
 80140de:	0699      	lsls	r1, r3, #26
 80140e0:	d506      	bpl.n	80140f0 <tcp_input+0x654>
          if (pcb->refused_data != NULL) {
 80140e2:	6f73      	ldr	r3, [r6, #116]	; 0x74
 80140e4:	2b00      	cmp	r3, #0
 80140e6:	d05f      	beq.n	80141a8 <tcp_input+0x70c>
            /* Delay this if we have refused data. */
            pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
 80140e8:	7b5a      	ldrb	r2, [r3, #13]
 80140ea:	f042 0220 	orr.w	r2, r2, #32
 80140ee:	735a      	strb	r2, [r3, #13]
              goto aborted;
            }
          }
        }

        tcp_input_pcb = NULL;
 80140f0:	2300      	movs	r3, #0
        /* Try to send something out. */
        tcp_output(pcb);
 80140f2:	4630      	mov	r0, r6
              goto aborted;
            }
          }
        }

        tcp_input_pcb = NULL;
 80140f4:	603b      	str	r3, [r7, #0]
        /* Try to send something out. */
        tcp_output(pcb);
 80140f6:	f7f6 fe33 	bl	800ad60 <tcp_output>
 80140fa:	e5bb      	b.n	8013c74 <tcp_input+0x1d8>
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
 80140fc:	8990      	ldrh	r0, [r2, #12]
 80140fe:	f7f9 fd4f 	bl	800dba0 <lwip_ntohs>
 8014102:	0742      	lsls	r2, r0, #29
 8014104:	f53f acde 	bmi.w	8013ac4 <tcp_input+0x28>
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
        ip_current_dest_addr(), ip_current_src_addr(),
        tcphdr->dest, tcphdr->src);
 8014108:	68eb      	ldr	r3, [r5, #12]
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
 801410a:	686a      	ldr	r2, [r5, #4]
 801410c:	8818      	ldrh	r0, [r3, #0]
 801410e:	8a29      	ldrh	r1, [r5, #16]
 8014110:	9001      	str	r0, [sp, #4]
 8014112:	885b      	ldrh	r3, [r3, #2]
 8014114:	4411      	add	r1, r2
 8014116:	9300      	str	r3, [sp, #0]
 8014118:	68a8      	ldr	r0, [r5, #8]
 801411a:	4b91      	ldr	r3, [pc, #580]	; (8014360 <tcp_input+0x8c4>)
 801411c:	4a91      	ldr	r2, [pc, #580]	; (8014364 <tcp_input+0x8c8>)
 801411e:	f7f6 ff91 	bl	800b044 <tcp_rst>
 8014122:	e4cf      	b.n	8013ac4 <tcp_input+0x28>

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
      if (ackno == pcb->snd_nxt) {
 8014124:	6d32      	ldr	r2, [r6, #80]	; 0x50
 8014126:	68ab      	ldr	r3, [r5, #8]
 8014128:	429a      	cmp	r2, r3
 801412a:	f47f ad8f 	bne.w	8013c4c <tcp_input+0x1b0>
    }

    if (acceptable) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
      recv_flags |= TF_RESET;
 801412e:	f895 2028 	ldrb.w	r2, [r5, #40]	; 0x28
      pcb->flags &= ~TF_ACK_DELAY;
 8014132:	7fb3      	ldrb	r3, [r6, #30]
    }

    if (acceptable) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
      recv_flags |= TF_RESET;
 8014134:	f042 0208 	orr.w	r2, r2, #8
      pcb->flags &= ~TF_ACK_DELAY;
 8014138:	f023 0301 	bic.w	r3, r3, #1
    }

    if (acceptable) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
      recv_flags |= TF_RESET;
 801413c:	f885 2028 	strb.w	r2, [r5, #40]	; 0x28
      pcb->flags &= ~TF_ACK_DELAY;
 8014140:	77b3      	strb	r3, [r6, #30]
 8014142:	e583      	b.n	8013c4c <tcp_input+0x1b0>
      }
    }

    if (acceptable) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
 8014144:	2a00      	cmp	r2, #0
 8014146:	d1f2      	bne.n	801412e <tcp_input+0x692>
 8014148:	4b82      	ldr	r3, [pc, #520]	; (8014354 <tcp_input+0x8b8>)
 801414a:	f240 2257 	movw	r2, #599	; 0x257
 801414e:	4986      	ldr	r1, [pc, #536]	; (8014368 <tcp_input+0x8cc>)
 8014150:	4882      	ldr	r0, [pc, #520]	; (801435c <tcp_input+0x8c0>)
 8014152:	f000 fe11 	bl	8014d78 <iprintf>
 8014156:	e7ea      	b.n	801412e <tcp_input+0x692>
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
 8014158:	8812      	ldrh	r2, [r2, #0]
 801415a:	f8da 3004 	ldr.w	r3, [sl, #4]
 801415e:	f8ba 1010 	ldrh.w	r1, [sl, #16]
 8014162:	e88d 0005 	stmia.w	sp, {r0, r2}
 8014166:	4419      	add	r1, r3
 8014168:	f8da 0008 	ldr.w	r0, [sl, #8]
 801416c:	4b7c      	ldr	r3, [pc, #496]	; (8014360 <tcp_input+0x8c4>)
 801416e:	4a7d      	ldr	r2, [pc, #500]	; (8014364 <tcp_input+0x8c8>)
 8014170:	f7f6 ff68 	bl	800b044 <tcp_rst>
 8014174:	e4a6      	b.n	8013ac4 <tcp_input+0x28>
        if (recv_data != NULL) {
          LWIP_ASSERT("pcb->refused_data == NULL", pcb->refused_data == NULL);
          if (pcb->flags & TF_RXCLOSED) {
            /* received data although already closed -> abort (send RST) to
               notify the remote host that not all data has been processed */
            pbuf_free(recv_data);
 8014176:	6a68      	ldr	r0, [r5, #36]	; 0x24
 8014178:	f7fb ff56 	bl	8010028 <pbuf_free>
            tcp_abort(pcb);
 801417c:	4630      	mov	r0, r6
 801417e:	f7f6 f8a3 	bl	800a2c8 <tcp_abort>
            goto aborted;
 8014182:	e577      	b.n	8013c74 <tcp_input+0x1d8>
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
 8014184:	4623      	mov	r3, r4
 8014186:	4620      	mov	r0, r4
 8014188:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 801418a:	4631      	mov	r1, r6
 801418c:	f7f5 ff76 	bl	800a07c <tcp_recv_null>
 8014190:	e79c      	b.n	80140cc <tcp_input+0x630>
        TCP_REG(&tcp_tw_pcbs, pcb);
      } else {
        tcp_ack_now(pcb);
        pcb->state = CLOSING;
      }
    } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
 8014192:	06d2      	lsls	r2, r2, #27
 8014194:	f57f ad5a 	bpl.w	8013c4c <tcp_input+0x1b0>
 8014198:	689b      	ldr	r3, [r3, #8]
 801419a:	6d32      	ldr	r2, [r6, #80]	; 0x50
 801419c:	429a      	cmp	r2, r3
 801419e:	f47f ad55 	bne.w	8013c4c <tcp_input+0x1b0>
      pcb->state = FIN_WAIT_2;
 80141a2:	2306      	movs	r3, #6
 80141a4:	7633      	strb	r3, [r6, #24]
 80141a6:	e551      	b.n	8013c4c <tcp_input+0x1b0>
            /* Delay this if we have refused data. */
            pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
          } else {
            /* correct rcv_wnd as the application won't call tcp_recved()
               for the FIN's seqno */
            if (pcb->rcv_wnd != TCP_WND) {
 80141a8:	f640 3268 	movw	r2, #2920	; 0xb68
 80141ac:	8db3      	ldrh	r3, [r6, #44]	; 0x2c
              pcb->rcv_wnd++;
            }
            TCP_EVENT_CLOSED(pcb, err);
 80141ae:	6ff4      	ldr	r4, [r6, #124]	; 0x7c
            /* Delay this if we have refused data. */
            pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
          } else {
            /* correct rcv_wnd as the application won't call tcp_recved()
               for the FIN's seqno */
            if (pcb->rcv_wnd != TCP_WND) {
 80141b0:	4293      	cmp	r3, r2
              pcb->rcv_wnd++;
 80141b2:	bf1c      	itt	ne
 80141b4:	3301      	addne	r3, #1
 80141b6:	85b3      	strhne	r3, [r6, #44]	; 0x2c
            }
            TCP_EVENT_CLOSED(pcb, err);
 80141b8:	2c00      	cmp	r4, #0
 80141ba:	d099      	beq.n	80140f0 <tcp_input+0x654>
 80141bc:	2300      	movs	r3, #0
 80141be:	461a      	mov	r2, r3
 80141c0:	4631      	mov	r1, r6
 80141c2:	6930      	ldr	r0, [r6, #16]
 80141c4:	47a0      	blx	r4
            if (err == ERR_ABRT) {
 80141c6:	300a      	adds	r0, #10
 80141c8:	d192      	bne.n	80140f0 <tcp_input+0x654>
 80141ca:	e553      	b.n	8013c74 <tcp_input+0x1d8>
    snmp_inc_tcppassiveopens();

    /* Send a SYN|ACK together with the MSS option. */
    rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
    if (rc != ERR_OK) {
      tcp_abandon(npcb, 0);
 80141cc:	4641      	mov	r1, r8
 80141ce:	4628      	mov	r0, r5
 80141d0:	f7f6 f810 	bl	800a1f4 <tcp_abandon>
 80141d4:	e476      	b.n	8013ac4 <tcp_input+0x28>
      } else {
        /* incorrect ACK number, send RST */
        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
                tcphdr->dest, tcphdr->src);
      }
    } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
 80141d6:	079c      	lsls	r4, r3, #30
 80141d8:	f57f ad38 	bpl.w	8013c4c <tcp_input+0x1b0>
 80141dc:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 80141de:	6852      	ldr	r2, [r2, #4]
 80141e0:	3b01      	subs	r3, #1
 80141e2:	4293      	cmp	r3, r2
 80141e4:	f47f ad32 	bne.w	8013c4c <tcp_input+0x1b0>
      /* Looks like another copy of the SYN - retransmit our SYN-ACK */
      tcp_rexmit(pcb);
 80141e8:	4630      	mov	r0, r6
 80141ea:	f7f6 ffa3 	bl	800b134 <tcp_rexmit>
 80141ee:	e52d      	b.n	8013c4c <tcp_input+0x1b0>
  if (flags & TCP_SYN) {
    /* If an incoming segment is not acceptable, an acknowledgment
       should be sent in reply */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt+pcb->rcv_wnd)) {
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
 80141f0:	f8be 2010 	ldrh.w	r2, [lr, #16]
 80141f4:	9001      	str	r0, [sp, #4]
 80141f6:	f8cd c000 	str.w	ip, [sp]
 80141fa:	4411      	add	r1, r2
 80141fc:	4643      	mov	r3, r8
 80141fe:	f8de 0008 	ldr.w	r0, [lr, #8]
 8014202:	4a58      	ldr	r2, [pc, #352]	; (8014364 <tcp_input+0x8c8>)
 8014204:	f7f6 ff1e 	bl	800b044 <tcp_rst>
 8014208:	e45c      	b.n	8013ac4 <tcp_input+0x28>
  case CLOSING:
    tcp_receive(pcb);
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
 801420a:	68f2      	ldr	r2, [r6, #12]
 801420c:	601a      	str	r2, [r3, #0]
 801420e:	e6bd      	b.n	8013f8c <tcp_input+0x4f0>
      if (prev != NULL) {
        prev->next = pcb->next;
        pcb->next = tcp_active_pcbs;
        tcp_active_pcbs = pcb;
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
 8014210:	4b50      	ldr	r3, [pc, #320]	; (8014354 <tcp_input+0x8b8>)
 8014212:	22bc      	movs	r2, #188	; 0xbc
 8014214:	4955      	ldr	r1, [pc, #340]	; (801436c <tcp_input+0x8d0>)
 8014216:	4851      	ldr	r0, [pc, #324]	; (801435c <tcp_input+0x8c0>)
 8014218:	f000 fdae 	bl	8014d78 <iprintf>
 801421c:	e4e4      	b.n	8013be8 <tcp_input+0x14c>
      /* If the SYN is in the window it is an error, send a reset */
      tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(), ip_current_src_addr(),
        tcphdr->dest, tcphdr->src);
      return ERR_OK;
    }
  } else if (flags & TCP_FIN) {
 801421e:	07d7      	lsls	r7, r2, #31
 8014220:	f57f ad7d 	bpl.w	8013d1e <tcp_input+0x282>
    /* - eighth, check the FIN bit: Remain in the TIME-WAIT state.
         Restart the 2 MSL time-wait timeout.*/
    pcb->tmr = tcp_ticks;
 8014224:	4b52      	ldr	r3, [pc, #328]	; (8014370 <tcp_input+0x8d4>)
 8014226:	681b      	ldr	r3, [r3, #0]
 8014228:	6273      	str	r3, [r6, #36]	; 0x24
 801422a:	e578      	b.n	8013d1e <tcp_input+0x282>
       ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest)) {

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
 801422c:	4b49      	ldr	r3, [pc, #292]	; (8014354 <tcp_input+0x8b8>)
 801422e:	22b6      	movs	r2, #182	; 0xb6
 8014230:	4950      	ldr	r1, [pc, #320]	; (8014374 <tcp_input+0x8d8>)
 8014232:	484a      	ldr	r0, [pc, #296]	; (801435c <tcp_input+0x8c0>)
 8014234:	f000 fda0 	bl	8014d78 <iprintf>
      if (prev != NULL) {
 8014238:	f1b8 0f00 	cmp.w	r8, #0
 801423c:	f43f acd0 	beq.w	8013be0 <tcp_input+0x144>
 8014240:	68f3      	ldr	r3, [r6, #12]
 8014242:	e4c6      	b.n	8013bd2 <tcp_input+0x136>
    tcp_receive(pcb);
    if (recv_flags & TF_GOT_FIN) {
      if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed: FIN_WAIT_1 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
 8014244:	7fb3      	ldrb	r3, [r6, #30]
        tcp_pcb_purge(pcb);
 8014246:	4630      	mov	r0, r6
    tcp_receive(pcb);
    if (recv_flags & TF_GOT_FIN) {
      if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt)) {
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed: FIN_WAIT_1 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
 8014248:	f043 0302 	orr.w	r3, r3, #2
 801424c:	77b3      	strb	r3, [r6, #30]
        tcp_pcb_purge(pcb);
 801424e:	f7f5 fddb 	bl	8009e08 <tcp_pcb_purge>
        TCP_RMV_ACTIVE(pcb);
 8014252:	f8d9 2000 	ldr.w	r2, [r9]
 8014256:	4b48      	ldr	r3, [pc, #288]	; (8014378 <tcp_input+0x8dc>)
 8014258:	42b2      	cmp	r2, r6
 801425a:	d0d6      	beq.n	801420a <tcp_input+0x76e>
 801425c:	4b47      	ldr	r3, [pc, #284]	; (801437c <tcp_input+0x8e0>)
 801425e:	2100      	movs	r1, #0
 8014260:	601a      	str	r2, [r3, #0]
 8014262:	2a00      	cmp	r2, #0
 8014264:	f000 80b2 	beq.w	80143cc <tcp_input+0x930>
 8014268:	68d0      	ldr	r0, [r2, #12]
 801426a:	42b0      	cmp	r0, r6
 801426c:	d002      	beq.n	8014274 <tcp_input+0x7d8>
 801426e:	4602      	mov	r2, r0
 8014270:	2101      	movs	r1, #1
 8014272:	e7f6      	b.n	8014262 <tcp_input+0x7c6>
 8014274:	b911      	cbnz	r1, 801427c <tcp_input+0x7e0>
  case CLOSING:
    tcp_receive(pcb);
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_pcb_purge(pcb);
      TCP_RMV_ACTIVE(pcb);
 8014276:	68f3      	ldr	r3, [r6, #12]
 8014278:	60d3      	str	r3, [r2, #12]
 801427a:	e687      	b.n	8013f8c <tcp_input+0x4f0>
 801427c:	601a      	str	r2, [r3, #0]
 801427e:	e7fa      	b.n	8014276 <tcp_input+0x7da>
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
 8014280:	6f33      	ldr	r3, [r6, #112]	; 0x70
 8014282:	68db      	ldr	r3, [r3, #12]
 8014284:	6858      	ldr	r0, [r3, #4]
 8014286:	f7f9 fc8f 	bl	800dba8 <lwip_ntohl>
 801428a:	68a3      	ldr	r3, [r4, #8]
 801428c:	3001      	adds	r0, #1
 801428e:	4298      	cmp	r0, r3
 8014290:	f47f aea8 	bne.w	8013fe4 <tcp_input+0x548>
      pcb->snd_buf++;
      pcb->rcv_nxt = seqno + 1;
 8014294:	6863      	ldr	r3, [r4, #4]
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
      pcb->snd_buf++;
 8014296:	f8b6 2066 	ldrh.w	r2, [r6, #102]	; 0x66
      pcb->rcv_nxt = seqno + 1;
 801429a:	1c59      	adds	r1, r3, #1
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
      pcb->snd_buf++;
 801429c:	3201      	adds	r2, #1
      pcb->rcv_nxt = seqno + 1;
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
      pcb->lastack = ackno;
      pcb->snd_wnd = tcphdr->wnd;
 801429e:	68e4      	ldr	r4, [r4, #12]
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
      pcb->snd_buf++;
      pcb->rcv_nxt = seqno + 1;
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
      pcb->lastack = ackno;
 80142a0:	64b0      	str	r0, [r6, #72]	; 0x48
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
      pcb->snd_buf++;
      pcb->rcv_nxt = seqno + 1;
 80142a2:	62b1      	str	r1, [r6, #40]	; 0x28
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
 80142a4:	6331      	str	r1, [r6, #48]	; 0x30
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
      pcb->snd_buf++;
 80142a6:	f8a6 2066 	strh.w	r2, [r6, #102]	; 0x66
      pcb->rcv_nxt = seqno + 1;
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
      pcb->lastack = ackno;
      pcb->snd_wnd = tcphdr->wnd;
 80142aa:	89e2      	ldrh	r2, [r4, #14]
      pcb->snd_wnd_max = tcphdr->wnd;
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
 80142ac:	3b01      	subs	r3, #1
      pcb->state = ESTABLISHED;
 80142ae:	2104      	movs	r1, #4
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
      pcb->snd_buf++;
      pcb->rcv_nxt = seqno + 1;
      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
      pcb->lastack = ackno;
      pcb->snd_wnd = tcphdr->wnd;
 80142b0:	f8a6 2060 	strh.w	r2, [r6, #96]	; 0x60
      pcb->snd_wnd_max = tcphdr->wnd;
 80142b4:	f8a6 2062 	strh.w	r2, [r6, #98]	; 0x62
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
 80142b8:	6573      	str	r3, [r6, #84]	; 0x54
      pcb->state = ESTABLISHED;
 80142ba:	7631      	strb	r1, [r6, #24]

#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
 80142bc:	8ef0      	ldrh	r0, [r6, #54]	; 0x36
 80142be:	1871      	adds	r1, r6, r1
 80142c0:	f7f6 f8a8 	bl	800a414 <tcp_eff_send_mss>

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
 80142c4:	f8b6 204c 	ldrh.w	r2, [r6, #76]	; 0x4c
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
 80142c8:	eb00 0380 	add.w	r3, r0, r0, lsl #2
 80142cc:	005b      	lsls	r3, r3, #1

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
 80142ce:	2a01      	cmp	r2, #1
      pcb->snd_wnd_max = tcphdr->wnd;
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
      pcb->state = ESTABLISHED;

#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
 80142d0:	86f0      	strh	r0, [r6, #54]	; 0x36
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
 80142d2:	f8a6 304e 	strh.w	r3, [r6, #78]	; 0x4e

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
 80142d6:	bf08      	it	eq
 80142d8:	0040      	lsleq	r0, r0, #1
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
 80142da:	f8b6 3068 	ldrh.w	r3, [r6, #104]	; 0x68

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
 80142de:	bf08      	it	eq
 80142e0:	b280      	uxtheq	r0, r0
 80142e2:	f8a6 004c 	strh.w	r0, [r6, #76]	; 0x4c
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
 80142e6:	b933      	cbnz	r3, 80142f6 <tcp_input+0x85a>
 80142e8:	4b1a      	ldr	r3, [pc, #104]	; (8014354 <tcp_input+0x8b8>)
 80142ea:	f44f 7223 	mov.w	r2, #652	; 0x28c
 80142ee:	4924      	ldr	r1, [pc, #144]	; (8014380 <tcp_input+0x8e4>)
 80142f0:	481a      	ldr	r0, [pc, #104]	; (801435c <tcp_input+0x8c0>)
 80142f2:	f000 fd41 	bl	8014d78 <iprintf>
      --pcb->snd_queuelen;
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
 80142f6:	6f30      	ldr	r0, [r6, #112]	; 0x70
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
      --pcb->snd_queuelen;
 80142f8:	f8b6 3068 	ldrh.w	r3, [r6, #104]	; 0x68
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
      pcb->unacked = rseg->next;
 80142fc:	6802      	ldr	r2, [r0, #0]
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
      --pcb->snd_queuelen;
 80142fe:	3b01      	subs	r3, #1
 8014300:	f8a6 3068 	strh.w	r3, [r6, #104]	; 0x68
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
      pcb->unacked = rseg->next;
 8014304:	6732      	str	r2, [r6, #112]	; 0x70
      tcp_seg_free(rseg);
 8014306:	f7f5 faab 	bl	8009860 <tcp_seg_free>

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
 801430a:	6f33      	ldr	r3, [r6, #112]	; 0x70
 801430c:	b1f3      	cbz	r3, 801434c <tcp_input+0x8b0>
        pcb->rtime = -1;
      else {
        pcb->rtime = 0;
 801430e:	2300      	movs	r3, #0
 8014310:	86b3      	strh	r3, [r6, #52]	; 0x34
        pcb->nrtx = 0;
 8014312:	f886 3046 	strb.w	r3, [r6, #70]	; 0x46
      }

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
 8014316:	f8d6 3080 	ldr.w	r3, [r6, #128]	; 0x80
 801431a:	2b00      	cmp	r3, #0
 801431c:	f43f ad15 	beq.w	8013d4a <tcp_input+0x2ae>
 8014320:	2200      	movs	r2, #0
 8014322:	4631      	mov	r1, r6
 8014324:	6930      	ldr	r0, [r6, #16]
 8014326:	4798      	blx	r3
      if (err == ERR_ABRT) {
 8014328:	300a      	adds	r0, #10
 801432a:	f47f ad0e 	bne.w	8013d4a <tcp_input+0x2ae>
 801432e:	e4a1      	b.n	8013c74 <tcp_input+0x1d8>
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
 8014330:	6973      	ldr	r3, [r6, #20]
  case SYN_RCVD:
    if (flags & TCP_ACK) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
 8014332:	2204      	movs	r2, #4
 8014334:	7632      	strb	r2, [r6, #24]
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
 8014336:	2b00      	cmp	r3, #0
 8014338:	d03d      	beq.n	80143b6 <tcp_input+0x91a>
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
 801433a:	2200      	movs	r2, #0
 801433c:	4631      	mov	r1, r6
 801433e:	6930      	ldr	r0, [r6, #16]
 8014340:	4798      	blx	r3
        if (err != ERR_OK) {
 8014342:	b1f8      	cbz	r0, 8014384 <tcp_input+0x8e8>
          /* If the accept function returns with an error, we abort
           * the connection. */
          /* Already aborted? */
          if (err != ERR_ABRT) {
 8014344:	300a      	adds	r0, #10
 8014346:	f47f af19 	bne.w	801417c <tcp_input+0x6e0>
 801434a:	e493      	b.n	8013c74 <tcp_input+0x1d8>
      tcp_seg_free(rseg);

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
        pcb->rtime = -1;
 801434c:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8014350:	86b3      	strh	r3, [r6, #52]	; 0x34
 8014352:	e7e0      	b.n	8014316 <tcp_input+0x87a>
 8014354:	080183b0 	.word	0x080183b0
 8014358:	08018614 	.word	0x08018614
 801435c:	0801660c 	.word	0x0801660c
 8014360:	2000f09c 	.word	0x2000f09c
 8014364:	2000f0a4 	.word	0x2000f0a4
 8014368:	080185c8 	.word	0x080185c8
 801436c:	0801856c 	.word	0x0801856c
 8014370:	2000f044 	.word	0x2000f044
 8014374:	08018540 	.word	0x08018540
 8014378:	2000f040 	.word	0x2000f040
 801437c:	2000f04c 	.word	0x2000f04c
 8014380:	080185e8 	.word	0x080185e8
          return ERR_ABRT;
        }
        old_cwnd = pcb->cwnd;
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        tcp_receive(pcb);
 8014384:	4630      	mov	r0, r6
          if (err != ERR_ABRT) {
            tcp_abort(pcb);
          }
          return ERR_ABRT;
        }
        old_cwnd = pcb->cwnd;
 8014386:	f8b6 404c 	ldrh.w	r4, [r6, #76]	; 0x4c
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        tcp_receive(pcb);
 801438a:	f7ff f821 	bl	80133d0 <tcp_receive>

        /* Prevent ACK for SYN to generate a sent event */
        if (pcb->acked != 0) {
 801438e:	f8b6 3064 	ldrh.w	r3, [r6, #100]	; 0x64
 8014392:	b113      	cbz	r3, 801439a <tcp_input+0x8fe>
          pcb->acked--;
 8014394:	3b01      	subs	r3, #1
 8014396:	f8a6 3064 	strh.w	r3, [r6, #100]	; 0x64
        }

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
 801439a:	8ef3      	ldrh	r3, [r6, #54]	; 0x36
 801439c:	2c01      	cmp	r4, #1
 801439e:	bf08      	it	eq
 80143a0:	005b      	lsleq	r3, r3, #1

        if (recv_flags & TF_GOT_FIN) {
 80143a2:	f895 2028 	ldrb.w	r2, [r5, #40]	; 0x28
        /* Prevent ACK for SYN to generate a sent event */
        if (pcb->acked != 0) {
          pcb->acked--;
        }

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
 80143a6:	bf08      	it	eq
 80143a8:	b29b      	uxtheq	r3, r3
 80143aa:	f8a6 304c 	strh.w	r3, [r6, #76]	; 0x4c

        if (recv_flags & TF_GOT_FIN) {
 80143ae:	0693      	lsls	r3, r2, #26
 80143b0:	f57f ac4c 	bpl.w	8013c4c <tcp_input+0x1b0>
 80143b4:	e631      	b.n	801401a <tcp_input+0x57e>
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
 80143b6:	4b07      	ldr	r3, [pc, #28]	; (80143d4 <tcp_input+0x938>)
 80143b8:	f240 22b3 	movw	r2, #691	; 0x2b3
 80143bc:	4906      	ldr	r1, [pc, #24]	; (80143d8 <tcp_input+0x93c>)
 80143be:	4807      	ldr	r0, [pc, #28]	; (80143dc <tcp_input+0x940>)
 80143c0:	f000 fcda 	bl	8014d78 <iprintf>
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
 80143c4:	6973      	ldr	r3, [r6, #20]
 80143c6:	2b00      	cmp	r3, #0
 80143c8:	d1b7      	bne.n	801433a <tcp_input+0x89e>
 80143ca:	e6d7      	b.n	801417c <tcp_input+0x6e0>
 80143cc:	2900      	cmp	r1, #0
 80143ce:	f43f addd 	beq.w	8013f8c <tcp_input+0x4f0>
 80143d2:	e5da      	b.n	8013f8a <tcp_input+0x4ee>
 80143d4:	080183b0 	.word	0x080183b0
 80143d8:	08018600 	.word	0x08018600
 80143dc:	0801660c 	.word	0x0801660c

080143e0 <udp_init>:
/**
 * Initialize this module.
 */
void
udp_init(void)
{
 80143e0:	4770      	bx	lr
 80143e2:	bf00      	nop

080143e4 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
 80143e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = (struct ip_hdr *)p->payload;
 80143e8:	f8d0 9004 	ldr.w	r9, [r0, #4]

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
 80143ec:	8902      	ldrh	r2, [r0, #8]
 80143ee:	f899 3000 	ldrb.w	r3, [r9]
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
 80143f2:	468a      	mov	sl, r1
 80143f4:	f003 010f 	and.w	r1, r3, #15

  iphdr = (struct ip_hdr *)p->payload;

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
 80143f8:	1c8b      	adds	r3, r1, #2
 80143fa:	ebb2 0f83 	cmp.w	r2, r3, lsl #2
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
 80143fe:	b085      	sub	sp, #20
 8014400:	4605      	mov	r5, r0

  iphdr = (struct ip_hdr *)p->payload;

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
 8014402:	db05      	blt.n	8014410 <udp_input+0x2c>
 8014404:	0089      	lsls	r1, r1, #2
 8014406:	4249      	negs	r1, r1
 8014408:	f7fb fdb6 	bl	800ff78 <pbuf_header>
 801440c:	4607      	mov	r7, r0
 801440e:	b128      	cbz	r0, 801441c <udp_input+0x38>
    if(pbuf_header(p, -UDP_HLEN)) {
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
 8014410:	4628      	mov	r0, r5
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
}
 8014412:	b005      	add	sp, #20
 8014414:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if(pbuf_header(p, -UDP_HLEN)) {
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
 8014418:	f7fb be06 	b.w	8010028 <pbuf_free>
  }

  udphdr = (struct udp_hdr *)p->payload;

  /* is broadcast packet ? */
  broadcast = ip_addr_isbroadcast(&current_iphdr_dest, inp);
 801441c:	f8df b148 	ldr.w	fp, [pc, #328]	; 8014568 <udp_input+0x184>
 8014420:	4651      	mov	r1, sl
 8014422:	f8db 0000 	ldr.w	r0, [fp]
    snmp_inc_udpinerrors();
    pbuf_free(p);
    goto end;
  }

  udphdr = (struct udp_hdr *)p->payload;
 8014426:	686c      	ldr	r4, [r5, #4]

  /* is broadcast packet ? */
  broadcast = ip_addr_isbroadcast(&current_iphdr_dest, inp);
 8014428:	f7fa fc68 	bl	800ecfc <ip4_addr_isbroadcast>
 801442c:	4680      	mov	r8, r0

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
 801442e:	8820      	ldrh	r0, [r4, #0]
 8014430:	f7f9 fbb6 	bl	800dba0 <lwip_ntohs>
 8014434:	4606      	mov	r6, r0
  dest = ntohs(udphdr->dest);
 8014436:	8860      	ldrh	r0, [r4, #2]
 8014438:	f7f9 fbb2 	bl	800dba0 <lwip_ntohs>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 801443c:	4b48      	ldr	r3, [pc, #288]	; (8014560 <udp_input+0x17c>)
 801443e:	681b      	ldr	r3, [r3, #0]
 8014440:	461c      	mov	r4, r3
 8014442:	9303      	str	r3, [sp, #12]
 8014444:	2b00      	cmp	r3, #0
 8014446:	d04d      	beq.n	80144e4 <udp_input+0x100>
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
           ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
 8014448:	4a46      	ldr	r2, [pc, #280]	; (8014564 <udp_input+0x180>)
 801444a:	463b      	mov	r3, r7
 801444c:	f8d2 c000 	ldr.w	ip, [r2]

      /* compare PCB local addr+port to UDP destination addr+port */
      if (pcb->local_port == dest) {
        if (
           (!broadcast && ip_addr_isany(&pcb->local_ip)) ||
           ip_addr_cmp(&(pcb->local_ip), &current_iphdr_dest) ||
 8014450:	f8db e000 	ldr.w	lr, [fp]
 8014454:	4641      	mov	r1, r8
 8014456:	e004      	b.n	8014462 <udp_input+0x7e>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8014458:	68e2      	ldr	r2, [r4, #12]
 801445a:	4623      	mov	r3, r4
 801445c:	2a00      	cmp	r2, #0
 801445e:	d03e      	beq.n	80144de <udp_input+0xfa>
 8014460:	4614      	mov	r4, r2
                   ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip), pcb->local_port,
                   ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
                   ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if (pcb->local_port == dest) {
 8014462:	8a62      	ldrh	r2, [r4, #18]
 8014464:	4282      	cmp	r2, r0
 8014466:	d1f7      	bne.n	8014458 <udp_input+0x74>
        if (
           (!broadcast && ip_addr_isany(&pcb->local_ip)) ||
 8014468:	6822      	ldr	r2, [r4, #0]
                   ip4_addr1_16(&pcb->remote_ip), ip4_addr2_16(&pcb->remote_ip),
                   ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if (pcb->local_port == dest) {
        if (
 801446a:	bb29      	cbnz	r1, 80144b8 <udp_input+0xd4>
           (!broadcast && ip_addr_isany(&pcb->local_ip)) ||
 801446c:	b10a      	cbz	r2, 8014472 <udp_input+0x8e>
 801446e:	4572      	cmp	r2, lr
 8014470:	d1f2      	bne.n	8014458 <udp_input+0x74>
            (broadcast &&
             (ip_addr_isany(&pcb->local_ip) ||
              ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
#endif /* IP_SOF_BROADCAST_RECV */ 
          local_match = 1;
          if ((uncon_pcb == NULL) && 
 8014472:	2f00      	cmp	r7, #0
 8014474:	d02d      	beq.n	80144d2 <udp_input+0xee>
            uncon_pcb = pcb;
          }
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
 8014476:	8aa2      	ldrh	r2, [r4, #20]
 8014478:	42b2      	cmp	r2, r6
 801447a:	d1ed      	bne.n	8014458 <udp_input+0x74>
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
 801447c:	6862      	ldr	r2, [r4, #4]
 801447e:	b10a      	cbz	r2, 8014484 <udp_input+0xa0>
 8014480:	4562      	cmp	r2, ip
 8014482:	d1e9      	bne.n	8014458 <udp_input+0x74>
           ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
        /* the first fully matching PCB */
        if (prev != NULL) {
 8014484:	b12b      	cbz	r3, 8014492 <udp_input+0xae>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
 8014486:	68e2      	ldr	r2, [r4, #12]
          pcb->next = udp_pcbs;
          udp_pcbs = pcb;
 8014488:	4935      	ldr	r1, [pc, #212]	; (8014560 <udp_input+0x17c>)
           ip_addr_cmp(&(pcb->remote_ip), &current_iphdr_src))) {
        /* the first fully matching PCB */
        if (prev != NULL) {
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
 801448a:	60da      	str	r2, [r3, #12]
          pcb->next = udp_pcbs;
 801448c:	9b03      	ldr	r3, [sp, #12]
          udp_pcbs = pcb;
 801448e:	600c      	str	r4, [r1, #0]
        /* the first fully matching PCB */
        if (prev != NULL) {
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
          pcb->next = udp_pcbs;
 8014490:	60e3      	str	r3, [r4, #12]
          goto end;
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
 8014492:	f06f 0107 	mvn.w	r1, #7
 8014496:	4628      	mov	r0, r5
 8014498:	f7fb fd6e 	bl	800ff78 <pbuf_header>
 801449c:	2800      	cmp	r0, #0
 801449e:	d14e      	bne.n	801453e <udp_input+0x15a>
          pbuf_header(p, -(s16_t)((IPH_HL(iphdr) * 4) + UDP_HLEN));
        }
      }
#endif /* SO_REUSE && SO_REUSE_RXTOALL */
      /* callback */
      if (pcb->recv != NULL) {
 80144a0:	69a7      	ldr	r7, [r4, #24]
 80144a2:	2f00      	cmp	r7, #0
 80144a4:	d0b4      	beq.n	8014410 <udp_input+0x2c>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
 80144a6:	69e0      	ldr	r0, [r4, #28]
 80144a8:	462a      	mov	r2, r5
 80144aa:	9600      	str	r6, [sp, #0]
 80144ac:	4621      	mov	r1, r4
 80144ae:	4b2d      	ldr	r3, [pc, #180]	; (8014564 <udp_input+0x180>)
 80144b0:	47b8      	blx	r7
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
}
 80144b2:	b005      	add	sp, #20
 80144b4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                   ip4_addr3_16(&pcb->remote_ip), ip4_addr4_16(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if (pcb->local_port == dest) {
        if (
           (!broadcast && ip_addr_isany(&pcb->local_ip)) ||
 80144b8:	4572      	cmp	r2, lr
 80144ba:	d0da      	beq.n	8014472 <udp_input+0x8e>
            (broadcast && ip_get_option(pcb, SOF_BROADCAST) &&
             (ip_addr_isany(&pcb->local_ip) ||
              ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
#else /* IP_SOF_BROADCAST_RECV */
            (broadcast &&
             (ip_addr_isany(&pcb->local_ip) ||
 80144bc:	2a00      	cmp	r2, #0
 80144be:	d0d8      	beq.n	8014472 <udp_input+0x8e>
 80144c0:	ea82 080e 	eor.w	r8, r2, lr
 80144c4:	f8da 2008 	ldr.w	r2, [sl, #8]
 80144c8:	ea18 0f02 	tst.w	r8, r2
 80144cc:	d1c4      	bne.n	8014458 <udp_input+0x74>
              ip_addr_netcmp(&pcb->local_ip, ip_current_dest_addr(), &inp->netmask)))) {
#endif /* IP_SOF_BROADCAST_RECV */ 
          local_match = 1;
          if ((uncon_pcb == NULL) && 
 80144ce:	2f00      	cmp	r7, #0
 80144d0:	d1d1      	bne.n	8014476 <udp_input+0x92>
 80144d2:	7c22      	ldrb	r2, [r4, #16]
 80144d4:	f012 0f04 	tst.w	r2, #4
 80144d8:	bf08      	it	eq
 80144da:	4627      	moveq	r7, r4
 80144dc:	e7cb      	b.n	8014476 <udp_input+0x92>
 80144de:	4688      	mov	r8, r1
      pcb = uncon_pcb;
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &current_iphdr_dest)) {
 80144e0:	2f00      	cmp	r7, #0
 80144e2:	d134      	bne.n	801454e <udp_input+0x16a>
 80144e4:	f8da 2004 	ldr.w	r2, [sl, #4]
 80144e8:	f8db 3000 	ldr.w	r3, [fp]
 80144ec:	4c1e      	ldr	r4, [pc, #120]	; (8014568 <udp_input+0x184>)
 80144ee:	429a      	cmp	r2, r3
 80144f0:	d18e      	bne.n	8014410 <udp_input+0x2c>
          goto end;
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
 80144f2:	f06f 0107 	mvn.w	r1, #7
 80144f6:	4628      	mov	r0, r5
 80144f8:	f7fb fd3e 	bl	800ff78 <pbuf_header>
 80144fc:	b9f8      	cbnz	r0, 801453e <udp_input+0x15a>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!broadcast &&
 80144fe:	f1b8 0f00 	cmp.w	r8, #0
 8014502:	d185      	bne.n	8014410 <udp_input+0x2c>
 8014504:	6823      	ldr	r3, [r4, #0]
 8014506:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 801450a:	2be0      	cmp	r3, #224	; 0xe0
 801450c:	d080      	beq.n	8014410 <udp_input+0x2c>
          !ip_addr_ismulticast(&current_iphdr_dest)) {
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
 801450e:	f899 1000 	ldrb.w	r1, [r9]
 8014512:	4628      	mov	r0, r5
 8014514:	f001 010f 	and.w	r1, r1, #15
 8014518:	3102      	adds	r1, #2
 801451a:	0089      	lsls	r1, r1, #2
 801451c:	f7fb fd2c 	bl	800ff78 <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
 8014520:	686b      	ldr	r3, [r5, #4]
 8014522:	4599      	cmp	r9, r3
 8014524:	d006      	beq.n	8014534 <udp_input+0x150>
 8014526:	4b11      	ldr	r3, [pc, #68]	; (801456c <udp_input+0x188>)
 8014528:	f240 12a3 	movw	r2, #419	; 0x1a3
 801452c:	4910      	ldr	r1, [pc, #64]	; (8014570 <udp_input+0x18c>)
 801452e:	4811      	ldr	r0, [pc, #68]	; (8014574 <udp_input+0x190>)
 8014530:	f000 fc22 	bl	8014d78 <iprintf>
        icmp_dest_unreach(p, ICMP_DUR_PORT);
 8014534:	2103      	movs	r1, #3
 8014536:	4628      	mov	r0, r5
 8014538:	f000 fb54 	bl	8014be4 <icmp_dest_unreach>
 801453c:	e768      	b.n	8014410 <udp_input+0x2c>
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
 801453e:	4b0b      	ldr	r3, [pc, #44]	; (801456c <udp_input+0x188>)
 8014540:	f44f 72ac 	mov.w	r2, #344	; 0x158
 8014544:	490c      	ldr	r1, [pc, #48]	; (8014578 <udp_input+0x194>)
 8014546:	480b      	ldr	r0, [pc, #44]	; (8014574 <udp_input+0x190>)
 8014548:	f000 fc16 	bl	8014d78 <iprintf>
 801454c:	e760      	b.n	8014410 <udp_input+0x2c>
          goto end;
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
 801454e:	f06f 0107 	mvn.w	r1, #7
 8014552:	4628      	mov	r0, r5
 8014554:	f7fb fd10 	bl	800ff78 <pbuf_header>
 8014558:	2800      	cmp	r0, #0
 801455a:	d1f0      	bne.n	801453e <udp_input+0x15a>
 801455c:	463c      	mov	r4, r7
 801455e:	e79f      	b.n	80144a0 <udp_input+0xbc>
 8014560:	20016ff8 	.word	0x20016ff8
 8014564:	2000f09c 	.word	0x2000f09c
 8014568:	2000f0a4 	.word	0x2000f0a4
 801456c:	08018630 	.word	0x08018630
 8014570:	08018654 	.word	0x08018654
 8014574:	0801660c 	.word	0x0801660c
 8014578:	08018640 	.word	0x08018640

0801457c <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
 801457c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 8014580:	f8df 80cc 	ldr.w	r8, [pc, #204]	; 8014650 <udp_bind+0xd4>
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
 8014584:	4605      	mov	r5, r0
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 8014586:	f8d8 4000 	ldr.w	r4, [r8]
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
 801458a:	460f      	mov	r7, r1
 801458c:	4616      	mov	r6, r2
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 801458e:	2c00      	cmp	r4, #0
 8014590:	d054      	beq.n	801463c <udp_bind+0xc0>
 8014592:	2000      	movs	r0, #0
 8014594:	e001      	b.n	801459a <udp_bind+0x1e>
 8014596:	68e4      	ldr	r4, [r4, #12]
 8014598:	b1a4      	cbz	r4, 80145c4 <udp_bind+0x48>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
 801459a:	42a5      	cmp	r5, r4
 801459c:	d00d      	beq.n	80145ba <udp_bind+0x3e>
             !ip_get_option(ipcb, SOF_REUSEADDR)) {
#else /* SO_REUSE */
    /* port matches that of PCB in list and REUSEADDR not set -> reject */
    else {
#endif /* SO_REUSE */
      if ((ipcb->local_port == port) &&
 801459e:	8a63      	ldrh	r3, [r4, #18]
 80145a0:	42b3      	cmp	r3, r6
 80145a2:	d1f8      	bne.n	8014596 <udp_bind+0x1a>
          /* IP address matches, or one is IP_ADDR_ANY? */
          (ip_addr_isany(&(ipcb->local_ip)) ||
 80145a4:	6823      	ldr	r3, [r4, #0]
 80145a6:	b123      	cbz	r3, 80145b2 <udp_bind+0x36>
 80145a8:	b11f      	cbz	r7, 80145b2 <udp_bind+0x36>
           ip_addr_isany(ipaddr) ||
 80145aa:	683a      	ldr	r2, [r7, #0]
 80145ac:	b10a      	cbz	r2, 80145b2 <udp_bind+0x36>
 80145ae:	4293      	cmp	r3, r2
 80145b0:	d1f1      	bne.n	8014596 <udp_bind+0x1a>
           ip_addr_cmp(&(ipcb->local_ip), ipaddr))) {
        /* other PCB already binds to this local IP and port */
        LWIP_DEBUGF(UDP_DEBUG,
                    ("udp_bind: local port %"U16_F" already bound by another pcb\n", port));
        return ERR_USE;
 80145b2:	f06f 0007 	mvn.w	r0, #7
 80145b6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
 80145ba:	b980      	cbnz	r0, 80145de <udp_bind+0x62>
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 80145bc:	68e4      	ldr	r4, [r4, #12]
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
      /* pcb already in list, just rebind */
      rebind = 1;
 80145be:	2001      	movs	r0, #1
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 80145c0:	2c00      	cmp	r4, #0
 80145c2:	d1ea      	bne.n	801459a <udp_bind+0x1e>
        return ERR_USE;
      }
    }
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
 80145c4:	b107      	cbz	r7, 80145c8 <udp_bind+0x4c>
 80145c6:	683f      	ldr	r7, [r7, #0]
 80145c8:	602f      	str	r7, [r5, #0]

  /* no port specified? */
  if (port == 0) {
 80145ca:	b1a6      	cbz	r6, 80145f6 <udp_bind+0x7a>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
    }
  }
  pcb->local_port = port;
 80145cc:	826e      	strh	r6, [r5, #18]
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
 80145ce:	b978      	cbnz	r0, 80145f0 <udp_bind+0x74>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
 80145d0:	f8d8 3000 	ldr.w	r3, [r8]
    udp_pcbs = pcb;
 80145d4:	f8c8 5000 	str.w	r5, [r8]
  pcb->local_port = port;
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
 80145d8:	60eb      	str	r3, [r5, #12]
 80145da:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
 80145de:	4b18      	ldr	r3, [pc, #96]	; (8014640 <udp_bind+0xc4>)
 80145e0:	f240 320d 	movw	r2, #781	; 0x30d
 80145e4:	4917      	ldr	r1, [pc, #92]	; (8014644 <udp_bind+0xc8>)
 80145e6:	4818      	ldr	r0, [pc, #96]	; (8014648 <udp_bind+0xcc>)
 80145e8:	f000 fbc6 	bl	8014d78 <iprintf>
      /* pcb already in list, just rebind */
      rebind = 1;
 80145ec:	2001      	movs	r0, #1
 80145ee:	e7d2      	b.n	8014596 <udp_bind+0x1a>
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
               ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
               pcb->local_port));
  return ERR_OK;
 80145f0:	2000      	movs	r0, #0
}
 80145f2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
{
  u16_t n = 0;
  struct udp_pcb *pcb;
  
again:
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
 80145f6:	f64f 7eff 	movw	lr, #65535	; 0xffff
 80145fa:	4f14      	ldr	r7, [pc, #80]	; (801464c <udp_bind+0xd0>)
 80145fc:	f8d8 1000 	ldr.w	r1, [r8]
 8014600:	883b      	ldrh	r3, [r7, #0]
  }

  ip_addr_set(&pcb->local_ip, ipaddr);

  /* no port specified? */
  if (port == 0) {
 8014602:	f44f 4480 	mov.w	r4, #16384	; 0x4000
{
  u16_t n = 0;
  struct udp_pcb *pcb;
  
again:
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
 8014606:	4573      	cmp	r3, lr
 8014608:	bf1a      	itte	ne
 801460a:	3301      	addne	r3, #1
 801460c:	b29e      	uxthne	r6, r3
 801460e:	f44f 4640 	moveq.w	r6, #49152	; 0xc000
    udp_port = UDP_LOCAL_PORT_RANGE_START;
  }
  /* Check all PCBs. */
  for(pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8014612:	b151      	cbz	r1, 801462a <udp_bind+0xae>
    if (pcb->local_port == udp_port) {
 8014614:	8a4b      	ldrh	r3, [r1, #18]
 8014616:	42b3      	cmp	r3, r6
 8014618:	d009      	beq.n	801462e <udp_bind+0xb2>
 801461a:	460b      	mov	r3, r1
 801461c:	e002      	b.n	8014624 <udp_bind+0xa8>
 801461e:	8a5a      	ldrh	r2, [r3, #18]
 8014620:	42b2      	cmp	r2, r6
 8014622:	d004      	beq.n	801462e <udp_bind+0xb2>
again:
  if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
    udp_port = UDP_LOCAL_PORT_RANGE_START;
  }
  /* Check all PCBs. */
  for(pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
 8014624:	68db      	ldr	r3, [r3, #12]
 8014626:	2b00      	cmp	r3, #0
 8014628:	d1f9      	bne.n	801461e <udp_bind+0xa2>
 801462a:	803e      	strh	r6, [r7, #0]
 801462c:	e7ce      	b.n	80145cc <udp_bind+0x50>
 801462e:	3c01      	subs	r4, #1
 8014630:	b2a4      	uxth	r4, r4
 8014632:	4633      	mov	r3, r6
    if (pcb->local_port == udp_port) {
      if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
 8014634:	2c00      	cmp	r4, #0
 8014636:	d1e6      	bne.n	8014606 <udp_bind+0x8a>
 8014638:	803e      	strh	r6, [r7, #0]
 801463a:	e7ba      	b.n	80145b2 <udp_bind+0x36>

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));

  rebind = 0;
 801463c:	4620      	mov	r0, r4
 801463e:	e7c1      	b.n	80145c4 <udp_bind+0x48>
 8014640:	08018630 	.word	0x08018630
 8014644:	08018668 	.word	0x08018668
 8014648:	0801660c 	.word	0x0801660c
 801464c:	20000032 	.word	0x20000032
 8014650:	20016ff8 	.word	0x20016ff8

08014654 <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif)
{
 8014654:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    return ERR_VAL;
  }
#endif /* IP_SOF_BROADCAST */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
 8014658:	8a45      	ldrh	r5, [r0, #18]
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif)
{
 801465a:	b084      	sub	sp, #16
 801465c:	4604      	mov	r4, r0
 801465e:	460f      	mov	r7, r1
 8014660:	4692      	mov	sl, r2
 8014662:	4699      	mov	r9, r3
 8014664:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
    return ERR_VAL;
  }
#endif /* IP_SOF_BROADCAST */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
 8014668:	b92d      	cbnz	r5, 8014676 <udp_sendto_if+0x22>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
 801466a:	462a      	mov	r2, r5
 801466c:	4601      	mov	r1, r0
 801466e:	f7ff ff85 	bl	801457c <udp_bind>
    if (err != ERR_OK) {
 8014672:	2800      	cmp	r0, #0
 8014674:	d134      	bne.n	80146e0 <udp_sendto_if+0x8c>
      return err;
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
 8014676:	2108      	movs	r1, #8
 8014678:	4638      	mov	r0, r7
 801467a:	f7fb fc7d 	bl	800ff78 <pbuf_header>
 801467e:	2800      	cmp	r0, #0
 8014680:	d13f      	bne.n	8014702 <udp_sendto_if+0xae>
 8014682:	463d      	mov	r5, r7
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
 8014684:	896b      	ldrh	r3, [r5, #10]
 8014686:	2b07      	cmp	r3, #7
 8014688:	d949      	bls.n	801471e <udp_sendto_if+0xca>
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = (struct udp_hdr *)q->payload;
  udphdr->src = htons(pcb->local_port);
 801468a:	8a60      	ldrh	r0, [r4, #18]
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = (struct udp_hdr *)q->payload;
 801468c:	686e      	ldr	r6, [r5, #4]
  udphdr->src = htons(pcb->local_port);
 801468e:	f7f9 fa83 	bl	800db98 <lwip_htons>
 8014692:	8030      	strh	r0, [r6, #0]
  udphdr->dest = htons(dst_port);
 8014694:	4648      	mov	r0, r9
 8014696:	f7f9 fa7f 	bl	800db98 <lwip_htons>
  }
#endif /* LWIP_IGMP */


  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
 801469a:	46a1      	mov	r9, r4
  /* q now represents the packet to be sent */
  udphdr = (struct udp_hdr *)q->payload;
  udphdr->src = htons(pcb->local_port);
  udphdr->dest = htons(dst_port);
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
 801469c:	2300      	movs	r3, #0
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = (struct udp_hdr *)q->payload;
  udphdr->src = htons(pcb->local_port);
  udphdr->dest = htons(dst_port);
 801469e:	8070      	strh	r0, [r6, #2]
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
 80146a0:	71b3      	strb	r3, [r6, #6]
 80146a2:	71f3      	strb	r3, [r6, #7]
  }
#endif /* LWIP_IGMP */


  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
 80146a4:	6823      	ldr	r3, [r4, #0]
 80146a6:	b9f3      	cbnz	r3, 80146e6 <udp_sendto_if+0x92>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
 80146a8:	f108 0904 	add.w	r9, r8, #4
    NETIF_SET_HWADDRHINT(netif, NULL);
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
 80146ac:	8928      	ldrh	r0, [r5, #8]
 80146ae:	f7f9 fa73 	bl	800db98 <lwip_htons>
 80146b2:	80b0      	strh	r0, [r6, #4]
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
 80146b4:	7c23      	ldrb	r3, [r4, #16]
 80146b6:	07db      	lsls	r3, r3, #31
 80146b8:	d549      	bpl.n	801474e <udp_sendto_if+0xfa>
#endif /* CHECKSUM_GEN_UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP checksum 0x%04"X16_F"\n", udphdr->chksum));
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
    NETIF_SET_HWADDRHINT(netif, &pcb->addr_hint);
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);
 80146ba:	7aa3      	ldrb	r3, [r4, #10]
 80146bc:	7a64      	ldrb	r4, [r4, #9]
 80146be:	2011      	movs	r0, #17
 80146c0:	9400      	str	r4, [sp, #0]
 80146c2:	9001      	str	r0, [sp, #4]
 80146c4:	f8cd 8008 	str.w	r8, [sp, #8]
 80146c8:	4652      	mov	r2, sl
 80146ca:	4649      	mov	r1, r9
 80146cc:	4628      	mov	r0, r5
 80146ce:	f7fa fa4f 	bl	800eb70 <ip_output_if>
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
 80146d2:	42af      	cmp	r7, r5
#endif /* CHECKSUM_GEN_UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP checksum 0x%04"X16_F"\n", udphdr->chksum));
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
    NETIF_SET_HWADDRHINT(netif, &pcb->addr_hint);
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);
 80146d4:	4604      	mov	r4, r0
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
 80146d6:	d003      	beq.n	80146e0 <udp_sendto_if+0x8c>
    /* free the header pbuf */
    pbuf_free(q);
 80146d8:	4628      	mov	r0, r5
 80146da:	f7fb fca5 	bl	8010028 <pbuf_free>
    q = NULL;
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
 80146de:	4620      	mov	r0, r4
}
 80146e0:	b004      	add	sp, #16
 80146e2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
 80146e6:	f8d8 2004 	ldr.w	r2, [r8, #4]
 80146ea:	4293      	cmp	r3, r2
 80146ec:	d0de      	beq.n	80146ac <udp_sendto_if+0x58>
      /* local_ip doesn't match, drop the packet */
      if (q != p) {
 80146ee:	42af      	cmp	r7, r5
 80146f0:	d02a      	beq.n	8014748 <udp_sendto_if+0xf4>
        /* free the header pbuf */
        pbuf_free(q);
 80146f2:	4628      	mov	r0, r5
 80146f4:	f7fb fc98 	bl	8010028 <pbuf_free>
        q = NULL;
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
 80146f8:	f06f 0005 	mvn.w	r0, #5
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
}
 80146fc:	b004      	add	sp, #16
 80146fe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
 8014702:	2200      	movs	r2, #0
 8014704:	2108      	movs	r1, #8
 8014706:	2001      	movs	r0, #1
 8014708:	f7fb fce6 	bl	80100d8 <pbuf_alloc>
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
 801470c:	4605      	mov	r5, r0
 801470e:	b368      	cbz	r0, 801476c <udp_sendto_if+0x118>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
    }
    if (p->tot_len != 0) {
 8014710:	893b      	ldrh	r3, [r7, #8]
 8014712:	2b00      	cmp	r3, #0
 8014714:	d0b6      	beq.n	8014684 <udp_sendto_if+0x30>
      /* chain header q in front of given pbuf p (only if p contains data) */
      pbuf_chain(q, p);
 8014716:	4639      	mov	r1, r7
 8014718:	f7fb fe84 	bl	8010424 <pbuf_chain>
 801471c:	e7b2      	b.n	8014684 <udp_sendto_if+0x30>
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
 801471e:	4b15      	ldr	r3, [pc, #84]	; (8014774 <udp_sendto_if+0x120>)
 8014720:	f240 2262 	movw	r2, #610	; 0x262
 8014724:	4914      	ldr	r1, [pc, #80]	; (8014778 <udp_sendto_if+0x124>)
 8014726:	4815      	ldr	r0, [pc, #84]	; (801477c <udp_sendto_if+0x128>)
 8014728:	f000 fb26 	bl	8014d78 <iprintf>
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = (struct udp_hdr *)q->payload;
  udphdr->src = htons(pcb->local_port);
 801472c:	8a60      	ldrh	r0, [r4, #18]
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = (struct udp_hdr *)q->payload;
 801472e:	686e      	ldr	r6, [r5, #4]
  udphdr->src = htons(pcb->local_port);
 8014730:	f7f9 fa32 	bl	800db98 <lwip_htons>
 8014734:	8030      	strh	r0, [r6, #0]
  udphdr->dest = htons(dst_port);
 8014736:	4648      	mov	r0, r9
 8014738:	f7f9 fa2e 	bl	800db98 <lwip_htons>
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
 801473c:	2300      	movs	r3, #0
  }
#endif /* LWIP_IGMP */


  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
 801473e:	46a1      	mov	r9, r4
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = (struct udp_hdr *)q->payload;
  udphdr->src = htons(pcb->local_port);
  udphdr->dest = htons(dst_port);
 8014740:	8070      	strh	r0, [r6, #2]
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
 8014742:	71b3      	strb	r3, [r6, #6]
 8014744:	71f3      	strb	r3, [r6, #7]
 8014746:	e7ad      	b.n	80146a4 <udp_sendto_if+0x50>
        /* free the header pbuf */
        pbuf_free(q);
        q = NULL;
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
 8014748:	f06f 0005 	mvn.w	r0, #5
 801474c:	e7c8      	b.n	80146e0 <udp_sendto_if+0x8c>
        acc = udpchksum + (u16_t)~(chksum);
        udpchksum = FOLD_U32T(acc);
      } else
#endif /* LWIP_CHECKSUM_ON_COPY */
      {
        udpchksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
 801474e:	892a      	ldrh	r2, [r5, #8]
 8014750:	2311      	movs	r3, #17
 8014752:	9200      	str	r2, [sp, #0]
 8014754:	4649      	mov	r1, r9
 8014756:	4652      	mov	r2, sl
 8014758:	4628      	mov	r0, r5
 801475a:	f7fa f841 	bl	800e7e0 <inet_chksum_pseudo>
      }

      /* chksum zero must become 0xffff, as zero means 'no checksum' */
      if (udpchksum == 0x0000) {
        udpchksum = 0xffff;
 801475e:	f64f 73ff 	movw	r3, #65535	; 0xffff
      }
      udphdr->chksum = udpchksum;
 8014762:	2800      	cmp	r0, #0
 8014764:	bf08      	it	eq
 8014766:	4618      	moveq	r0, r3
 8014768:	80f0      	strh	r0, [r6, #6]
 801476a:	e7a6      	b.n	80146ba <udp_sendto_if+0x66>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
 801476c:	f04f 30ff 	mov.w	r0, #4294967295
 8014770:	e7b6      	b.n	80146e0 <udp_sendto_if+0x8c>
 8014772:	bf00      	nop
 8014774:	08018630 	.word	0x08018630
 8014778:	08018674 	.word	0x08018674
 801477c:	0801660c 	.word	0x0801660c

08014780 <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  ip_addr_t *dst_ip, u16_t dst_port)
{
 8014780:	b5f0      	push	{r4, r5, r6, r7, lr}
 8014782:	4605      	mov	r5, r0
 8014784:	b083      	sub	sp, #12

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
#else
  netif = ip_route(dst_ip);
 8014786:	4610      	mov	r0, r2
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  ip_addr_t *dst_ip, u16_t dst_port)
{
 8014788:	4614      	mov	r4, r2
 801478a:	460e      	mov	r6, r1
 801478c:	461f      	mov	r7, r3

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
#else
  netif = ip_route(dst_ip);
 801478e:	f7fa f91f 	bl	800e9d0 <ip_route>
#endif /* LWIP_IGMP */

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
 8014792:	b140      	cbz	r0, 80147a6 <udp_sendto+0x26>
    return ERR_RTE;
  }
#if LWIP_CHECKSUM_ON_COPY
  return udp_sendto_if_chksum(pcb, p, dst_ip, dst_port, netif, have_chksum, chksum);
#else /* LWIP_CHECKSUM_ON_COPY */
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
 8014794:	9000      	str	r0, [sp, #0]
 8014796:	463b      	mov	r3, r7
 8014798:	4622      	mov	r2, r4
 801479a:	4631      	mov	r1, r6
 801479c:	4628      	mov	r0, r5
 801479e:	f7ff ff59 	bl	8014654 <udp_sendto_if>
#endif /* LWIP_CHECKSUM_ON_COPY */
}
 80147a2:	b003      	add	sp, #12
 80147a4:	bdf0      	pop	{r4, r5, r6, r7, pc}
  /* no outgoing network interface could be found? */
  if (netif == NULL) {
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
      ip4_addr1_16(dst_ip), ip4_addr2_16(dst_ip), ip4_addr3_16(dst_ip), ip4_addr4_16(dst_ip)));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
 80147a6:	f06f 0003 	mvn.w	r0, #3
 80147aa:	e7fa      	b.n	80147a2 <udp_sendto+0x22>

080147ac <udp_send>:
 *
 * @see udp_disconnect() udp_sendto()
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
 80147ac:	4602      	mov	r2, r0
  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
 80147ae:	8a83      	ldrh	r3, [r0, #20]
 80147b0:	3204      	adds	r2, #4
 80147b2:	f7ff bfe5 	b.w	8014780 <udp_sendto>
 80147b6:	bf00      	nop

080147b8 <udp_connect>:
err_t
udp_connect(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
 80147b8:	8a43      	ldrh	r3, [r0, #18]
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
 80147ba:	b570      	push	{r4, r5, r6, lr}
 80147bc:	4604      	mov	r4, r0
 80147be:	460d      	mov	r5, r1
 80147c0:	4616      	mov	r6, r2
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
 80147c2:	b1bb      	cbz	r3, 80147f4 <udp_connect+0x3c>
    if (err != ERR_OK) {
      return err;
    }
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
 80147c4:	b105      	cbz	r5, 80147c8 <udp_connect+0x10>
 80147c6:	682d      	ldr	r5, [r5, #0]
               ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
               ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
               pcb->local_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 80147c8:	490f      	ldr	r1, [pc, #60]	; (8014808 <udp_connect+0x50>)
    }
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  pcb->remote_port = port;
  pcb->flags |= UDP_FLAGS_CONNECTED;
 80147ca:	7c23      	ldrb	r3, [r4, #16]
               ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
               ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
               pcb->local_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 80147cc:	680a      	ldr	r2, [r1, #0]
    }
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  pcb->remote_port = port;
  pcb->flags |= UDP_FLAGS_CONNECTED;
 80147ce:	f043 0304 	orr.w	r3, r3, #4
    if (err != ERR_OK) {
      return err;
    }
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
 80147d2:	6065      	str	r5, [r4, #4]
  pcb->remote_port = port;
 80147d4:	82a6      	strh	r6, [r4, #20]
  pcb->flags |= UDP_FLAGS_CONNECTED;
 80147d6:	7423      	strb	r3, [r4, #16]
               ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
               ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
               pcb->local_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 80147d8:	b142      	cbz	r2, 80147ec <udp_connect+0x34>
    if (pcb == ipcb) {
 80147da:	4294      	cmp	r4, r2
 80147dc:	d011      	beq.n	8014802 <udp_connect+0x4a>
 80147de:	4613      	mov	r3, r2
 80147e0:	e001      	b.n	80147e6 <udp_connect+0x2e>
 80147e2:	429c      	cmp	r4, r3
 80147e4:	d00d      	beq.n	8014802 <udp_connect+0x4a>
               ip4_addr1_16(&pcb->local_ip), ip4_addr2_16(&pcb->local_ip),
               ip4_addr3_16(&pcb->local_ip), ip4_addr4_16(&pcb->local_ip),
               pcb->local_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
 80147e6:	68db      	ldr	r3, [r3, #12]
 80147e8:	2b00      	cmp	r3, #0
 80147ea:	d1fa      	bne.n	80147e2 <udp_connect+0x2a>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
 80147ec:	60e2      	str	r2, [r4, #12]
  udp_pcbs = pcb;
 80147ee:	600c      	str	r4, [r1, #0]
  return ERR_OK;
 80147f0:	2000      	movs	r0, #0
 80147f2:	bd70      	pop	{r4, r5, r6, pc}
udp_connect(struct udp_pcb *pcb, ip_addr_t *ipaddr, u16_t port)
{
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
 80147f4:	461a      	mov	r2, r3
 80147f6:	4601      	mov	r1, r0
 80147f8:	f7ff fec0 	bl	801457c <udp_bind>
    if (err != ERR_OK) {
 80147fc:	2800      	cmp	r0, #0
 80147fe:	d0e1      	beq.n	80147c4 <udp_connect+0xc>
 8014800:	bd70      	pop	{r4, r5, r6, pc}

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    if (pcb == ipcb) {
      /* already on the list, just return */
      return ERR_OK;
 8014802:	2000      	movs	r0, #0
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  udp_pcbs = pcb;
  return ERR_OK;
}
 8014804:	bd70      	pop	{r4, r5, r6, pc}
 8014806:	bf00      	nop
 8014808:	20016ff8 	.word	0x20016ff8

0801480c <udp_disconnect>:
{
  /* reset remote address association */
  ip_addr_set_any(&pcb->remote_ip);
  pcb->remote_port = 0;
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
 801480c:	7c03      	ldrb	r3, [r0, #16]
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
  /* reset remote address association */
  ip_addr_set_any(&pcb->remote_ip);
 801480e:	2200      	movs	r2, #0
  pcb->remote_port = 0;
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
 8014810:	f023 0304 	bic.w	r3, r3, #4
 8014814:	7403      	strb	r3, [r0, #16]
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
  /* reset remote address association */
  ip_addr_set_any(&pcb->remote_ip);
 8014816:	6042      	str	r2, [r0, #4]
  pcb->remote_port = 0;
 8014818:	8282      	strh	r2, [r0, #20]
 801481a:	4770      	bx	lr

0801481c <udp_recv>:
 */
void
udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)
{
  /* remember recv() callback and user data */
  pcb->recv = recv;
 801481c:	6181      	str	r1, [r0, #24]
  pcb->recv_arg = recv_arg;
 801481e:	61c2      	str	r2, [r0, #28]
 8014820:	4770      	bx	lr
 8014822:	bf00      	nop

08014824 <udp_remove>:
{
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
 8014824:	4b0d      	ldr	r3, [pc, #52]	; (801485c <udp_remove+0x38>)
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
 8014826:	4601      	mov	r1, r0
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
 8014828:	681a      	ldr	r2, [r3, #0]
 801482a:	4282      	cmp	r2, r0
 801482c:	d011      	beq.n	8014852 <udp_remove+0x2e>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 801482e:	b13a      	cbz	r2, 8014840 <udp_remove+0x1c>
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
 8014830:	68d3      	ldr	r3, [r2, #12]
 8014832:	b12b      	cbz	r3, 8014840 <udp_remove+0x1c>
 8014834:	4299      	cmp	r1, r3
 8014836:	d006      	beq.n	8014846 <udp_remove+0x22>
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
 8014838:	461a      	mov	r2, r3
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
 801483a:	68d3      	ldr	r3, [r2, #12]
 801483c:	2b00      	cmp	r3, #0
 801483e:	d1f9      	bne.n	8014834 <udp_remove+0x10>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_UDP_PCB, pcb);
 8014840:	2001      	movs	r0, #1
 8014842:	f7fb ba5b 	b.w	800fcfc <memp_free>
  } else {
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
 8014846:	68cb      	ldr	r3, [r1, #12]
 8014848:	60d3      	str	r3, [r2, #12]
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
 801484a:	2b00      	cmp	r3, #0
 801484c:	d0f8      	beq.n	8014840 <udp_remove+0x1c>
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
 801484e:	461a      	mov	r2, r3
 8014850:	e7f3      	b.n	801483a <udp_remove+0x16>

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
 8014852:	68c2      	ldr	r2, [r0, #12]
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_UDP_PCB, pcb);
 8014854:	2001      	movs	r0, #1

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
 8014856:	601a      	str	r2, [r3, #0]
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_UDP_PCB, pcb);
 8014858:	f7fb ba50 	b.w	800fcfc <memp_free>
 801485c:	20016ff8 	.word	0x20016ff8

08014860 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
 8014860:	b510      	push	{r4, lr}
  struct udp_pcb *pcb;
  pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
 8014862:	2001      	movs	r0, #1
 8014864:	f7fb fa14 	bl	800fc90 <memp_malloc>
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
 8014868:	4604      	mov	r4, r0
 801486a:	b128      	cbz	r0, 8014878 <udp_new+0x18>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
 801486c:	2220      	movs	r2, #32
 801486e:	2100      	movs	r1, #0
 8014870:	f000 fa7a 	bl	8014d68 <memset>
    pcb->ttl = UDP_TTL;
 8014874:	23ff      	movs	r3, #255	; 0xff
 8014876:	72a3      	strb	r3, [r4, #10]
  }
  return pcb;
}
 8014878:	4620      	mov	r0, r4
 801487a:	bd10      	pop	{r4, pc}

0801487c <TOOL_CheckSum8BitGet>:
************************************************************/
INT8U TOOL_CheckSum8BitGet(INT8U *buff, INT32U len)
{
	INT8U checksum=0;

	while(len--)
 801487c:	b149      	cbz	r1, 8014892 <TOOL_CheckSum8BitGet+0x16>
 801487e:	1842      	adds	r2, r0, r1
 8014880:	2300      	movs	r3, #0
	{
		checksum += *buff++;
 8014882:	f810 1b01 	ldrb.w	r1, [r0], #1
 8014886:	440b      	add	r3, r1
************************************************************/
INT8U TOOL_CheckSum8BitGet(INT8U *buff, INT32U len)
{
	INT8U checksum=0;

	while(len--)
 8014888:	4282      	cmp	r2, r0
	{
		checksum += *buff++;
 801488a:	b2db      	uxtb	r3, r3
************************************************************/
INT8U TOOL_CheckSum8BitGet(INT8U *buff, INT32U len)
{
	INT8U checksum=0;

	while(len--)
 801488c:	d1f9      	bne.n	8014882 <TOOL_CheckSum8BitGet+0x6>
	{
		checksum += *buff++;
	}

	return ((INT8U)checksum);
}
 801488e:	4618      	mov	r0, r3
 8014890:	4770      	bx	lr
**autor:  andiman
**date:
************************************************************/
INT8U TOOL_CheckSum8BitGet(INT8U *buff, INT32U len)
{
	INT8U checksum=0;
 8014892:	460b      	mov	r3, r1
 8014894:	e7fb      	b.n	801488e <TOOL_CheckSum8BitGet+0x12>
 8014896:	bf00      	nop

08014898 <TOOL_SysTickGet>:
**return:
**autor:  andiman
**date:
************************************************************/
INT32U TOOL_SysTickGet(void)
{
 8014898:	b500      	push	{lr}
 801489a:	b083      	sub	sp, #12
	INT32U tick;
	OS_ERR err;
	
	tick = OSTimeGet(&err);
 801489c:	f10d 0006 	add.w	r0, sp, #6
 80148a0:	f7f3 f9ca 	bl	8007c38 <OSTimeGet>

	return tick;
}
 80148a4:	b003      	add	sp, #12
 80148a6:	f85d fb04 	ldr.w	pc, [sp], #4
 80148aa:	bf00      	nop

080148ac <TOOL_INT32Data2Bytebuff>:
**return:
**autor:  andiman
**date:
************************************************************/
void TOOL_INT32Data2Bytebuff(INT32U data, INT8U *buff, INT8U save_mode)
{
 80148ac:	b410      	push	{r4}
	INT8U i=0;

	if( save_mode )			// 大端在前
 80148ae:	b942      	cbnz	r2, 80148c2 <TOOL_INT32Data2Bytebuff+0x16>
		buff[i++] = (data & 0x000000FF);
	}
	else
	{
		buff[i++] = (data & 0x000000FF);
		buff[i++] = (data & 0x0000FF00)>>8;
 80148b0:	0a04      	lsrs	r4, r0, #8
		buff[i++] = (data & 0x00FF0000)>>16;
 80148b2:	0c02      	lsrs	r2, r0, #16
		buff[i++] = (data & 0xFF000000)>>24;
 80148b4:	0e03      	lsrs	r3, r0, #24
		buff[i++] = (data & 0x000000FF);
	}
	else
	{
		buff[i++] = (data & 0x000000FF);
		buff[i++] = (data & 0x0000FF00)>>8;
 80148b6:	704c      	strb	r4, [r1, #1]
		buff[i++] = (data & 0x0000FF00)>>8;
		buff[i++] = (data & 0x000000FF);
	}
	else
	{
		buff[i++] = (data & 0x000000FF);
 80148b8:	7008      	strb	r0, [r1, #0]
		buff[i++] = (data & 0x0000FF00)>>8;
		buff[i++] = (data & 0x00FF0000)>>16;
 80148ba:	708a      	strb	r2, [r1, #2]
		buff[i++] = (data & 0xFF000000)>>24;
 80148bc:	70cb      	strb	r3, [r1, #3]
	}
}
 80148be:	bc10      	pop	{r4}
 80148c0:	4770      	bx	lr
{
	INT8U i=0;

	if( save_mode )			// 大端在前
	{
		buff[i++] = (data & 0xFF000000)>>24;
 80148c2:	0e04      	lsrs	r4, r0, #24
		buff[i++] = (data & 0x00FF0000)>>16;
 80148c4:	0c02      	lsrs	r2, r0, #16
		buff[i++] = (data & 0x0000FF00)>>8;
 80148c6:	0a03      	lsrs	r3, r0, #8
{
	INT8U i=0;

	if( save_mode )			// 大端在前
	{
		buff[i++] = (data & 0xFF000000)>>24;
 80148c8:	700c      	strb	r4, [r1, #0]
		buff[i++] = (data & 0x00FF0000)>>16;
		buff[i++] = (data & 0x0000FF00)>>8;
		buff[i++] = (data & 0x000000FF);
 80148ca:	70c8      	strb	r0, [r1, #3]
	INT8U i=0;

	if( save_mode )			// 大端在前
	{
		buff[i++] = (data & 0xFF000000)>>24;
		buff[i++] = (data & 0x00FF0000)>>16;
 80148cc:	704a      	strb	r2, [r1, #1]
		buff[i++] = (data & 0x0000FF00)>>8;
 80148ce:	708b      	strb	r3, [r1, #2]
		buff[i++] = (data & 0x000000FF);
		buff[i++] = (data & 0x0000FF00)>>8;
		buff[i++] = (data & 0x00FF0000)>>16;
		buff[i++] = (data & 0xFF000000)>>24;
	}
}
 80148d0:	bc10      	pop	{r4}
 80148d2:	4770      	bx	lr

080148d4 <TOOL_INT16Data2Bytebuff>:
{
	INT8U i=0;

	if( save_mode )			// 大端在前
	{
		buff[i++] = (data & 0x0000FF00)>>8;
 80148d4:	0a03      	lsrs	r3, r0, #8
************************************************************/
void TOOL_INT16Data2Bytebuff(INT16U data, INT8U *buff, INT8U save_mode)
{
	INT8U i=0;

	if( save_mode )			// 大端在前
 80148d6:	b912      	cbnz	r2, 80148de <TOOL_INT16Data2Bytebuff+0xa>
		buff[i++] = (data & 0x0000FF00)>>8;
		buff[i++] = (data & 0x000000FF);
	}
	else
	{
		buff[i++] = (data & 0x000000FF);
 80148d8:	7008      	strb	r0, [r1, #0]
		buff[i++] = (data & 0x0000FF00)>>8;
 80148da:	704b      	strb	r3, [r1, #1]
 80148dc:	4770      	bx	lr
	INT8U i=0;

	if( save_mode )			// 大端在前
	{
		buff[i++] = (data & 0x0000FF00)>>8;
		buff[i++] = (data & 0x000000FF);
 80148de:	7048      	strb	r0, [r1, #1]
{
	INT8U i=0;

	if( save_mode )			// 大端在前
	{
		buff[i++] = (data & 0x0000FF00)>>8;
 80148e0:	700b      	strb	r3, [r1, #0]
 80148e2:	4770      	bx	lr

080148e4 <TOOL_Bytebuff2INT32Data>:
INT32U TOOL_Bytebuff2INT32Data(INT8U *buff,INT8U save_mode)
{
	INT8U i;
	INT32U data=0;

	if( save_mode )
 80148e4:	b151      	cbz	r1, 80148fc <TOOL_Bytebuff2INT32Data+0x18>
 80148e6:	1e43      	subs	r3, r0, #1
 80148e8:	2100      	movs	r1, #0
 80148ea:	3003      	adds	r0, #3
	{
		for(i=0;i<4;i++)
			data = (data << 8) + buff[i];
 80148ec:	f813 2f01 	ldrb.w	r2, [r3, #1]!
	INT8U i;
	INT32U data=0;

	if( save_mode )
	{
		for(i=0;i<4;i++)
 80148f0:	4298      	cmp	r0, r3
			data = (data << 8) + buff[i];
 80148f2:	eb02 2101 	add.w	r1, r2, r1, lsl #8
	INT8U i;
	INT32U data=0;

	if( save_mode )
	{
		for(i=0;i<4;i++)
 80148f6:	d1f9      	bne.n	80148ec <TOOL_Bytebuff2INT32Data+0x8>
		for(i=4;i!=0;i--)
			data = (data << 8) + buff[i];
	}

	return data;
}
 80148f8:	4608      	mov	r0, r1
 80148fa:	4770      	bx	lr
 80148fc:	1d03      	adds	r3, r0, #4
			data = (data << 8) + buff[i];
	}
	else
	{
		for(i=4;i!=0;i--)
			data = (data << 8) + buff[i];
 80148fe:	f813 2901 	ldrb.w	r2, [r3], #-1
		for(i=0;i<4;i++)
			data = (data << 8) + buff[i];
	}
	else
	{
		for(i=4;i!=0;i--)
 8014902:	4283      	cmp	r3, r0
			data = (data << 8) + buff[i];
 8014904:	eb02 2101 	add.w	r1, r2, r1, lsl #8
		for(i=0;i<4;i++)
			data = (data << 8) + buff[i];
	}
	else
	{
		for(i=4;i!=0;i--)
 8014908:	d1f9      	bne.n	80148fe <TOOL_Bytebuff2INT32Data+0x1a>
			data = (data << 8) + buff[i];
	}

	return data;
}
 801490a:	4608      	mov	r0, r1
 801490c:	4770      	bx	lr
 801490e:	bf00      	nop

08014910 <TOOL_Bytebuff2INT16Data>:
INT16U TOOL_Bytebuff2INT16Data(INT8U *buff,INT8U save_mode)
{
	INT8U i;
	INT32U data=0;

	if( save_mode )
 8014910:	b929      	cbnz	r1, 801491e <TOOL_Bytebuff2INT16Data+0xe>
			data = (data << 8) + buff[i];
	}
	else
	{
		for(i=2;i!=0;i--)
			data = (data << 8) + buff[i];
 8014912:	7882      	ldrb	r2, [r0, #2]
 8014914:	7843      	ldrb	r3, [r0, #1]
 8014916:	eb03 2002 	add.w	r0, r3, r2, lsl #8
	}

	return data;
}
 801491a:	b280      	uxth	r0, r0
 801491c:	4770      	bx	lr
 801491e:	1e43      	subs	r3, r0, #1
 8014920:	1cc2      	adds	r2, r0, #3
INT16U TOOL_Bytebuff2INT16Data(INT8U *buff,INT8U save_mode)
{
	INT8U i;
	INT32U data=0;

	if( save_mode )
 8014922:	2000      	movs	r0, #0
	{
		for(i=0;i<4;i++)
			data = (data << 8) + buff[i];
 8014924:	f813 1f01 	ldrb.w	r1, [r3, #1]!
	INT8U i;
	INT32U data=0;

	if( save_mode )
	{
		for(i=0;i<4;i++)
 8014928:	429a      	cmp	r2, r3
			data = (data << 8) + buff[i];
 801492a:	eb01 2000 	add.w	r0, r1, r0, lsl #8
	INT8U i;
	INT32U data=0;

	if( save_mode )
	{
		for(i=0;i<4;i++)
 801492e:	d1f9      	bne.n	8014924 <TOOL_Bytebuff2INT16Data+0x14>
		for(i=2;i!=0;i--)
			data = (data << 8) + buff[i];
	}

	return data;
}
 8014930:	b280      	uxth	r0, r0
 8014932:	4770      	bx	lr

08014934 <TOOL_GetCPI_ID>:
**date:
************************************************************/
void TOOL_GetCPI_ID(INT32U *IDbuff)  
{  
    //获取CPU唯一ID  
    IDbuff[0]=*(INT32U*)(0x1fff7a10);  
 8014934:	4b04      	ldr	r3, [pc, #16]	; (8014948 <TOOL_GetCPI_ID+0x14>)
    IDbuff[1]=*(INT32U*)(0x1fff7a14);  
 8014936:	4a05      	ldr	r2, [pc, #20]	; (801494c <TOOL_GetCPI_ID+0x18>)
**date:
************************************************************/
void TOOL_GetCPI_ID(INT32U *IDbuff)  
{  
    //获取CPU唯一ID  
    IDbuff[0]=*(INT32U*)(0x1fff7a10);  
 8014938:	6819      	ldr	r1, [r3, #0]
    IDbuff[1]=*(INT32U*)(0x1fff7a14);  
    IDbuff[2]=*(INT32U*)(0x1fff7a18);  
 801493a:	3308      	adds	r3, #8
**date:
************************************************************/
void TOOL_GetCPI_ID(INT32U *IDbuff)  
{  
    //获取CPU唯一ID  
    IDbuff[0]=*(INT32U*)(0x1fff7a10);  
 801493c:	6001      	str	r1, [r0, #0]
    IDbuff[1]=*(INT32U*)(0x1fff7a14);  
 801493e:	6812      	ldr	r2, [r2, #0]
 8014940:	6042      	str	r2, [r0, #4]
    IDbuff[2]=*(INT32U*)(0x1fff7a18);  
 8014942:	681b      	ldr	r3, [r3, #0]
 8014944:	6083      	str	r3, [r0, #8]
 8014946:	4770      	bx	lr
 8014948:	1fff7a10 	.word	0x1fff7a10
 801494c:	1fff7a14 	.word	0x1fff7a14

08014950 <TOOL_DateTime2Bytebuff>:
**return:
**autor:  andiman
**date:
************************************************************/
 void TOOL_DateTime2Bytebuff(strSysDateTime SysDateTime,INT8U *buff,INT8U buff_len)
 {
 8014950:	b084      	sub	sp, #16
 8014952:	b4f0      	push	{r4, r5, r6, r7}
 8014954:	ac04      	add	r4, sp, #16
 8014956:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
 801495a:	f89d 1028 	ldrb.w	r1, [sp, #40]	; 0x28
 801495e:	f8bd 2010 	ldrh.w	r2, [sp, #16]
 	INT8U i=0;
 	if( buff_len > 6)
 8014962:	2906      	cmp	r1, #6
**return:
**autor:  andiman
**date:
************************************************************/
 void TOOL_DateTime2Bytebuff(strSysDateTime SysDateTime,INT8U *buff,INT8U buff_len)
 {
 8014964:	9b09      	ldr	r3, [sp, #36]	; 0x24
 	INT8U i=0;
 	if( buff_len > 6)
 8014966:	d81e      	bhi.n	80149a6 <TOOL_DateTime2Bytebuff+0x56>
 	{
 		buff[i++] = (SysDateTime.year & 0xFF00)>>8;
 		buff[i++] = (SysDateTime.year & 0x00FF);
 	}
 	else
 		buff[i++] = SysDateTime.year % 100;
 8014968:	4913      	ldr	r1, [pc, #76]	; (80149b8 <TOOL_DateTime2Bytebuff+0x68>)
 801496a:	2064      	movs	r0, #100	; 0x64
 801496c:	fba1 4102 	umull	r4, r1, r1, r2
 8014970:	0949      	lsrs	r1, r1, #5
 8014972:	fb00 2211 	mls	r2, r0, r1, r2
 8014976:	2503      	movs	r5, #3
 8014978:	701a      	strb	r2, [r3, #0]
 801497a:	2105      	movs	r1, #5
 801497c:	2004      	movs	r0, #4
 801497e:	2202      	movs	r2, #2
 8014980:	2401      	movs	r4, #1
 	buff[i++] = SysDateTime.month;
 8014982:	f89d 6012 	ldrb.w	r6, [sp, #18]
 	buff[i++] = SysDateTime.day;
 8014986:	f89d 7013 	ldrb.w	r7, [sp, #19]
 		buff[i++] = (SysDateTime.year & 0xFF00)>>8;
 		buff[i++] = (SysDateTime.year & 0x00FF);
 	}
 	else
 		buff[i++] = SysDateTime.year % 100;
 	buff[i++] = SysDateTime.month;
 801498a:	551e      	strb	r6, [r3, r4]
 	buff[i++] = SysDateTime.day;
 801498c:	549f      	strb	r7, [r3, r2]
 	buff[i++] = SysDateTime.hour;
 801498e:	f89d 6014 	ldrb.w	r6, [sp, #20]
 	buff[i++] = SysDateTime.min;
 8014992:	f89d 4015 	ldrb.w	r4, [sp, #21]
 	buff[i++] = SysDateTime.senc;
 8014996:	f89d 2016 	ldrb.w	r2, [sp, #22]
 	}
 	else
 		buff[i++] = SysDateTime.year % 100;
 	buff[i++] = SysDateTime.month;
 	buff[i++] = SysDateTime.day;
 	buff[i++] = SysDateTime.hour;
 801499a:	555e      	strb	r6, [r3, r5]
 	buff[i++] = SysDateTime.min;
 801499c:	541c      	strb	r4, [r3, r0]
 	buff[i++] = SysDateTime.senc;
 801499e:	545a      	strb	r2, [r3, r1]
 }
 80149a0:	bcf0      	pop	{r4, r5, r6, r7}
 80149a2:	b004      	add	sp, #16
 80149a4:	4770      	bx	lr
 void TOOL_DateTime2Bytebuff(strSysDateTime SysDateTime,INT8U *buff,INT8U buff_len)
 {
 	INT8U i=0;
 	if( buff_len > 6)
 	{
 		buff[i++] = (SysDateTime.year & 0xFF00)>>8;
 80149a6:	0a11      	lsrs	r1, r2, #8
 		buff[i++] = (SysDateTime.year & 0x00FF);
 80149a8:	705a      	strb	r2, [r3, #1]
 void TOOL_DateTime2Bytebuff(strSysDateTime SysDateTime,INT8U *buff,INT8U buff_len)
 {
 	INT8U i=0;
 	if( buff_len > 6)
 	{
 		buff[i++] = (SysDateTime.year & 0xFF00)>>8;
 80149aa:	7019      	strb	r1, [r3, #0]
 80149ac:	2005      	movs	r0, #5
 80149ae:	2106      	movs	r1, #6
 80149b0:	2504      	movs	r5, #4
 80149b2:	2203      	movs	r2, #3
 80149b4:	2402      	movs	r4, #2
 80149b6:	e7e4      	b.n	8014982 <TOOL_DateTime2Bytebuff+0x32>
 80149b8:	51eb851f 	.word	0x51eb851f

080149bc <icmp_send_response.isra.0>:
 *          p->payload pointing to the IP header
 * @param type Type of the ICMP header
 * @param code Code of the ICMP header
 */
static void
icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
 80149bc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80149c0:	4607      	mov	r7, r0
 80149c2:	b085      	sub	sp, #20
 80149c4:	4688      	mov	r8, r1
 80149c6:	4615      	mov	r5, r2
  /* we can use the echo header here */
  struct icmp_echo_hdr *icmphdr;
  ip_addr_t iphdr_src;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
 80149c8:	2124      	movs	r1, #36	; 0x24
 80149ca:	2200      	movs	r2, #0
 80149cc:	2001      	movs	r0, #1
 80149ce:	f7fb fb83 	bl	80100d8 <pbuf_alloc>
                 PBUF_RAM);
  if (q == NULL) {
 80149d2:	b390      	cbz	r0, 8014a3a <icmp_send_response.isra.0+0x7e>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
 80149d4:	8943      	ldrh	r3, [r0, #10]
 80149d6:	4606      	mov	r6, r0
 80149d8:	2b23      	cmp	r3, #35	; 0x23
 80149da:	d806      	bhi.n	80149ea <icmp_send_response.isra.0+0x2e>
 80149dc:	4b18      	ldr	r3, [pc, #96]	; (8014a40 <icmp_send_response.isra.0+0x84>)
 80149de:	f240 1233 	movw	r2, #307	; 0x133
 80149e2:	4918      	ldr	r1, [pc, #96]	; (8014a44 <icmp_send_response.isra.0+0x88>)
 80149e4:	4818      	ldr	r0, [pc, #96]	; (8014a48 <icmp_send_response.isra.0+0x8c>)
 80149e6:	f000 f9c7 	bl	8014d78 <iprintf>
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_echo_hdr *)q->payload;
 80149ea:	6874      	ldr	r4, [r6, #4]
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
             (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = (struct ip_hdr *)p->payload;
 80149ec:	f8d7 9000 	ldr.w	r9, [r7]
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_echo_hdr *)q->payload;
  icmphdr->type = type;
  icmphdr->code = code;
 80149f0:	7065      	strb	r5, [r4, #1]
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_echo_hdr *)q->payload;
  icmphdr->type = type;
 80149f2:	f884 8000 	strb.w	r8, [r4]
  icmphdr->code = code;
  icmphdr->id = 0;
  icmphdr->seqno = 0;

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
 80149f6:	6870      	ldr	r0, [r6, #4]
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_echo_hdr *)q->payload;
  icmphdr->type = type;
  icmphdr->code = code;
  icmphdr->id = 0;
 80149f8:	2500      	movs	r5, #0
  icmphdr->seqno = 0;

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
 80149fa:	6839      	ldr	r1, [r7, #0]
 80149fc:	221c      	movs	r2, #28
 80149fe:	3008      	adds	r0, #8
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  icmphdr = (struct icmp_echo_hdr *)q->payload;
  icmphdr->type = type;
  icmphdr->code = code;
  icmphdr->id = 0;
 8014a00:	7125      	strb	r5, [r4, #4]
 8014a02:	7165      	strb	r5, [r4, #5]
  icmphdr->seqno = 0;
 8014a04:	71a5      	strb	r5, [r4, #6]
 8014a06:	71e5      	strb	r5, [r4, #7]

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
 8014a08:	f000 f9a3 	bl	8014d52 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  icmphdr->chksum = 0;
  icmphdr->chksum = inet_chksum(icmphdr, q->len);
 8014a0c:	8971      	ldrh	r1, [r6, #10]
  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  icmphdr->chksum = 0;
 8014a0e:	70a5      	strb	r5, [r4, #2]
 8014a10:	70e5      	strb	r5, [r4, #3]
  icmphdr->chksum = inet_chksum(icmphdr, q->len);
 8014a12:	4620      	mov	r0, r4
 8014a14:	f7f9 ff98 	bl	800e948 <inet_chksum>
 8014a18:	8060      	strh	r0, [r4, #2]
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_addr_copy(iphdr_src, iphdr->src);
 8014a1a:	f8d9 100c 	ldr.w	r1, [r9, #12]
 8014a1e:	aa04      	add	r2, sp, #16
  ip_output(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP);
 8014a20:	2301      	movs	r3, #1
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_addr_copy(iphdr_src, iphdr->src);
 8014a22:	f842 1d04 	str.w	r1, [r2, #-4]!
  ip_output(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP);
 8014a26:	4630      	mov	r0, r6
 8014a28:	9301      	str	r3, [sp, #4]
 8014a2a:	9500      	str	r5, [sp, #0]
 8014a2c:	4629      	mov	r1, r5
 8014a2e:	23ff      	movs	r3, #255	; 0xff
 8014a30:	f7fa f936 	bl	800eca0 <ip_output>
  pbuf_free(q);
 8014a34:	4630      	mov	r0, r6
 8014a36:	f7fb faf7 	bl	8010028 <pbuf_free>
}
 8014a3a:	b005      	add	sp, #20
 8014a3c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8014a40:	080186a4 	.word	0x080186a4
 8014a44:	080186bc 	.word	0x080186bc
 8014a48:	0801660c 	.word	0x0801660c

08014a4c <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
 8014a4c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = (struct ip_hdr *)p->payload;
 8014a50:	6847      	ldr	r7, [r0, #4]
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
 8014a52:	b085      	sub	sp, #20
  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = (struct ip_hdr *)p->payload;
  hlen = IPH_HL(iphdr) * 4;
 8014a54:	783c      	ldrb	r4, [r7, #0]
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
 8014a56:	4688      	mov	r8, r1
  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = (struct ip_hdr *)p->payload;
  hlen = IPH_HL(iphdr) * 4;
 8014a58:	f004 040f 	and.w	r4, r4, #15
 8014a5c:	00a4      	lsls	r4, r4, #2
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
 8014a5e:	4266      	negs	r6, r4
 8014a60:	b236      	sxth	r6, r6
 8014a62:	4631      	mov	r1, r6
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
 8014a64:	4605      	mov	r5, r0
  snmp_inc_icmpinmsgs();


  iphdr = (struct ip_hdr *)p->payload;
  hlen = IPH_HL(iphdr) * 4;
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
 8014a66:	f7fb fa87 	bl	800ff78 <pbuf_header>
 8014a6a:	2800      	cmp	r0, #0
 8014a6c:	d150      	bne.n	8014b10 <icmp_input+0xc4>
 8014a6e:	892b      	ldrh	r3, [r5, #8]
 8014a70:	2b03      	cmp	r3, #3
 8014a72:	d94d      	bls.n	8014b10 <icmp_input+0xc4>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
 8014a74:	686b      	ldr	r3, [r5, #4]
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
 8014a76:	781b      	ldrb	r3, [r3, #0]
 8014a78:	2b08      	cmp	r3, #8
 8014a7a:	d149      	bne.n	8014b10 <icmp_input+0xc4>
#if !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING
    {
      int accepted = 1;
#if !LWIP_MULTICAST_PING
      /* multicast destination address? */
      if (ip_addr_ismulticast(&current_iphdr_dest)) {
 8014a7c:	f8df 9158 	ldr.w	r9, [pc, #344]	; 8014bd8 <icmp_input+0x18c>
        accepted = 0;
      }
#endif /* LWIP_MULTICAST_PING */
#if !LWIP_BROADCAST_PING
      /* broadcast destination address? */
      if (ip_addr_isbroadcast(&current_iphdr_dest, inp)) {
 8014a80:	4641      	mov	r1, r8
#if !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING
    {
      int accepted = 1;
#if !LWIP_MULTICAST_PING
      /* multicast destination address? */
      if (ip_addr_ismulticast(&current_iphdr_dest)) {
 8014a82:	f8d9 a000 	ldr.w	sl, [r9]
        accepted = 0;
      }
#endif /* LWIP_MULTICAST_PING */
#if !LWIP_BROADCAST_PING
      /* broadcast destination address? */
      if (ip_addr_isbroadcast(&current_iphdr_dest, inp)) {
 8014a86:	4650      	mov	r0, sl
 8014a88:	f7fa f938 	bl	800ecfc <ip4_addr_isbroadcast>
 8014a8c:	2800      	cmp	r0, #0
 8014a8e:	d13f      	bne.n	8014b10 <icmp_input+0xc4>
        accepted = 0;
      }
#endif /* LWIP_BROADCAST_PING */
      /* broadcast or multicast destination address not acceptd? */
      if (!accepted) {
 8014a90:	f00a 0af0 	and.w	sl, sl, #240	; 0xf0
 8014a94:	f1ba 0fe0 	cmp.w	sl, #224	; 0xe0
 8014a98:	d03a      	beq.n	8014b10 <icmp_input+0xc4>
        return;
      }
    }
#endif /* !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
 8014a9a:	892b      	ldrh	r3, [r5, #8]
 8014a9c:	2b07      	cmp	r3, #7
 8014a9e:	d937      	bls.n	8014b10 <icmp_input+0xc4>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    }
    if (inet_chksum_pbuf(p) != 0) {
 8014aa0:	4628      	mov	r0, r5
 8014aa2:	f7f9 ff57 	bl	800e954 <inet_chksum_pbuf>
 8014aa6:	bb98      	cbnz	r0, 8014b10 <icmp_input+0xc4>
      ICMP_STATS_INC(icmp.chkerr);
      snmp_inc_icmpinerrors();
      return;
    }
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
 8014aa8:	2122      	movs	r1, #34	; 0x22
 8014aaa:	4628      	mov	r0, r5
  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = (struct ip_hdr *)p->payload;
  hlen = IPH_HL(iphdr) * 4;
 8014aac:	fa0f fa84 	sxth.w	sl, r4
      ICMP_STATS_INC(icmp.chkerr);
      snmp_inc_icmpinerrors();
      return;
    }
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
 8014ab0:	f7fb fa62 	bl	800ff78 <pbuf_header>
 8014ab4:	bb90      	cbnz	r0, 8014b1c <icmp_input+0xd0>
      pbuf_free(p);
      /* we now have an identical copy of p that has room for link headers */
      p = r;
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
 8014ab6:	f06f 0121 	mvn.w	r1, #33	; 0x21
 8014aba:	4628      	mov	r0, r5
 8014abc:	f7fb fa5c 	bl	800ff78 <pbuf_header>
 8014ac0:	2800      	cmp	r0, #0
 8014ac2:	d15b      	bne.n	8014b7c <icmp_input+0x130>
    ip_addr_copy(iphdr->src, *ip_current_dest_addr());
    ip_addr_copy(iphdr->dest, *ip_current_src_addr());
    ICMPH_TYPE_SET(iecho, ICMP_ER);
#if CHECKSUM_GEN_ICMP
    /* adjust the checksum */
    if (iecho->chksum >= PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
 8014ac4:	f64f 71f6 	movw	r1, #65526	; 0xfff6
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = (struct icmp_echo_hdr *)p->payload;
    ip_addr_copy(iphdr->src, *ip_current_dest_addr());
    ip_addr_copy(iphdr->dest, *ip_current_src_addr());
 8014ac8:	4b3d      	ldr	r3, [pc, #244]	; (8014bc0 <icmp_input+0x174>)
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = (struct icmp_echo_hdr *)p->payload;
    ip_addr_copy(iphdr->src, *ip_current_dest_addr());
 8014aca:	f8d9 0000 	ldr.w	r0, [r9]
    ip_addr_copy(iphdr->dest, *ip_current_src_addr());
 8014ace:	681b      	ldr	r3, [r3, #0]
    }
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = (struct icmp_echo_hdr *)p->payload;
 8014ad0:	686a      	ldr	r2, [r5, #4]
    ip_addr_copy(iphdr->src, *ip_current_dest_addr());
 8014ad2:	60f8      	str	r0, [r7, #12]
    ip_addr_copy(iphdr->dest, *ip_current_src_addr());
 8014ad4:	613b      	str	r3, [r7, #16]
    ICMPH_TYPE_SET(iecho, ICMP_ER);
#if CHECKSUM_GEN_ICMP
    /* adjust the checksum */
    if (iecho->chksum >= PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
 8014ad6:	8853      	ldrh	r3, [r2, #2]
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = (struct icmp_echo_hdr *)p->payload;
    ip_addr_copy(iphdr->src, *ip_current_dest_addr());
    ip_addr_copy(iphdr->dest, *ip_current_src_addr());
    ICMPH_TYPE_SET(iecho, ICMP_ER);
 8014ad8:	2000      	movs	r0, #0
#if CHECKSUM_GEN_ICMP
    /* adjust the checksum */
    if (iecho->chksum >= PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
 8014ada:	428b      	cmp	r3, r1
      iecho->chksum += PP_HTONS(ICMP_ECHO << 8) + 1;
 8014adc:	bf8c      	ite	hi
 8014ade:	3309      	addhi	r3, #9
    } else {
      iecho->chksum += PP_HTONS(ICMP_ECHO << 8);
 8014ae0:	3308      	addls	r3, #8
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = (struct icmp_echo_hdr *)p->payload;
    ip_addr_copy(iphdr->src, *ip_current_dest_addr());
    ip_addr_copy(iphdr->dest, *ip_current_src_addr());
    ICMPH_TYPE_SET(iecho, ICMP_ER);
 8014ae2:	7010      	strb	r0, [r2, #0]
#if CHECKSUM_GEN_ICMP
    /* adjust the checksum */
    if (iecho->chksum >= PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
      iecho->chksum += PP_HTONS(ICMP_ECHO << 8) + 1;
    } else {
      iecho->chksum += PP_HTONS(ICMP_ECHO << 8);
 8014ae4:	8053      	strh	r3, [r2, #2]
#else /* CHECKSUM_GEN_ICMP */
    iecho->chksum = 0;
#endif /* CHECKSUM_GEN_ICMP */

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
 8014ae6:	24ff      	movs	r4, #255	; 0xff
    IPH_CHKSUM_SET(iphdr, 0);
 8014ae8:	2200      	movs	r2, #0
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
 8014aea:	2114      	movs	r1, #20
#else /* CHECKSUM_GEN_ICMP */
    iecho->chksum = 0;
#endif /* CHECKSUM_GEN_ICMP */

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
 8014aec:	723c      	strb	r4, [r7, #8]
    IPH_CHKSUM_SET(iphdr, 0);
 8014aee:	72ba      	strb	r2, [r7, #10]
 8014af0:	72fa      	strb	r2, [r7, #11]
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
 8014af2:	4638      	mov	r0, r7
 8014af4:	f7f9 ff28 	bl	800e948 <inet_chksum>
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
 8014af8:	4651      	mov	r1, sl

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
    IPH_CHKSUM_SET(iphdr, 0);
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
 8014afa:	8178      	strh	r0, [r7, #10]
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
 8014afc:	4628      	mov	r0, r5
 8014afe:	f7fb fa3b 	bl	800ff78 <pbuf_header>
 8014b02:	b378      	cbz	r0, 8014b64 <icmp_input+0x118>
      LWIP_ASSERT("Can't move over header in packet", 0);
 8014b04:	4b2f      	ldr	r3, [pc, #188]	; (8014bc4 <icmp_input+0x178>)
 8014b06:	22da      	movs	r2, #218	; 0xda
 8014b08:	492f      	ldr	r1, [pc, #188]	; (8014bc8 <icmp_input+0x17c>)
 8014b0a:	4830      	ldr	r0, [pc, #192]	; (8014bcc <icmp_input+0x180>)
 8014b0c:	f000 f934 	bl	8014d78 <iprintf>
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
memerr:
  pbuf_free(p);
 8014b10:	4628      	mov	r0, r5
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
#endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
}
 8014b12:	b005      	add	sp, #20
 8014b14:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
#if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
memerr:
  pbuf_free(p);
 8014b18:	f7fb ba86 	b.w	8010028 <pbuf_free>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
 8014b1c:	4651      	mov	r1, sl
 8014b1e:	4628      	mov	r0, r5
 8014b20:	f7fb fa2a 	bl	800ff78 <pbuf_header>
 8014b24:	b130      	cbz	r0, 8014b34 <icmp_input+0xe8>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
 8014b26:	4b27      	ldr	r3, [pc, #156]	; (8014bc4 <icmp_input+0x178>)
 8014b28:	2298      	movs	r2, #152	; 0x98
 8014b2a:	4929      	ldr	r1, [pc, #164]	; (8014bd0 <icmp_input+0x184>)
 8014b2c:	4827      	ldr	r0, [pc, #156]	; (8014bcc <icmp_input+0x180>)
 8014b2e:	f000 f923 	bl	8014d78 <iprintf>
        goto memerr;
 8014b32:	e7ed      	b.n	8014b10 <icmp_input+0xc4>
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
 8014b34:	4602      	mov	r2, r0
 8014b36:	8929      	ldrh	r1, [r5, #8]
 8014b38:	2002      	movs	r0, #2
 8014b3a:	f7fb facd 	bl	80100d8 <pbuf_alloc>
      if (r == NULL) {
 8014b3e:	4683      	mov	fp, r0
 8014b40:	2800      	cmp	r0, #0
 8014b42:	d0e5      	beq.n	8014b10 <icmp_input+0xc4>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
 8014b44:	8943      	ldrh	r3, [r0, #10]
 8014b46:	3408      	adds	r4, #8
 8014b48:	42a3      	cmp	r3, r4
 8014b4a:	d32c      	bcc.n	8014ba6 <icmp_input+0x15a>
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
 8014b4c:	4629      	mov	r1, r5
 8014b4e:	4658      	mov	r0, fp
 8014b50:	f7fb fcac 	bl	80104ac <pbuf_copy>
 8014b54:	b1c8      	cbz	r0, 8014b8a <icmp_input+0x13e>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
 8014b56:	4b1b      	ldr	r3, [pc, #108]	; (8014bc4 <icmp_input+0x178>)
 8014b58:	22a5      	movs	r2, #165	; 0xa5
 8014b5a:	491e      	ldr	r1, [pc, #120]	; (8014bd4 <icmp_input+0x188>)
 8014b5c:	481b      	ldr	r0, [pc, #108]	; (8014bcc <icmp_input+0x180>)
 8014b5e:	f000 f90b 	bl	8014d78 <iprintf>
        goto memerr;
 8014b62:	e7d5      	b.n	8014b10 <icmp_input+0xc4>
    if(pbuf_header(p, hlen)) {
      LWIP_ASSERT("Can't move over header in packet", 0);
    } else {
      err_t ret;
      /* send an ICMP packet, src addr is the dest addr of the curren packet */
      ret = ip_output_if(p, ip_current_dest_addr(), IP_HDRINCL,
 8014b64:	2101      	movs	r1, #1
 8014b66:	9000      	str	r0, [sp, #0]
 8014b68:	4602      	mov	r2, r0
 8014b6a:	9101      	str	r1, [sp, #4]
 8014b6c:	f8cd 8008 	str.w	r8, [sp, #8]
 8014b70:	4623      	mov	r3, r4
 8014b72:	4919      	ldr	r1, [pc, #100]	; (8014bd8 <icmp_input+0x18c>)
 8014b74:	4628      	mov	r0, r5
 8014b76:	f7f9 fffb 	bl	800eb70 <ip_output_if>
 8014b7a:	e7c9      	b.n	8014b10 <icmp_input+0xc4>
      /* we now have an identical copy of p that has room for link headers */
      p = r;
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
 8014b7c:	4b11      	ldr	r3, [pc, #68]	; (8014bc4 <icmp_input+0x178>)
 8014b7e:	22b5      	movs	r2, #181	; 0xb5
 8014b80:	4916      	ldr	r1, [pc, #88]	; (8014bdc <icmp_input+0x190>)
 8014b82:	4812      	ldr	r0, [pc, #72]	; (8014bcc <icmp_input+0x180>)
 8014b84:	f000 f8f8 	bl	8014d78 <iprintf>
        goto memerr;
 8014b88:	e7c2      	b.n	8014b10 <icmp_input+0xc4>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
        goto memerr;
      }
      iphdr = (struct ip_hdr *)r->payload;
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
 8014b8a:	4631      	mov	r1, r6
 8014b8c:	4658      	mov	r0, fp
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
        goto memerr;
      }
      iphdr = (struct ip_hdr *)r->payload;
 8014b8e:	f8db 7004 	ldr.w	r7, [fp, #4]
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
 8014b92:	f7fb f9f1 	bl	800ff78 <pbuf_header>
 8014b96:	b168      	cbz	r0, 8014bb4 <icmp_input+0x168>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
 8014b98:	4b0a      	ldr	r3, [pc, #40]	; (8014bc4 <icmp_input+0x178>)
 8014b9a:	22ab      	movs	r2, #171	; 0xab
 8014b9c:	490f      	ldr	r1, [pc, #60]	; (8014bdc <icmp_input+0x190>)
 8014b9e:	480b      	ldr	r0, [pc, #44]	; (8014bcc <icmp_input+0x180>)
 8014ba0:	f000 f8ea 	bl	8014d78 <iprintf>
        goto memerr;
 8014ba4:	e7b4      	b.n	8014b10 <icmp_input+0xc4>
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
      if (r == NULL) {
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
 8014ba6:	4b07      	ldr	r3, [pc, #28]	; (8014bc4 <icmp_input+0x178>)
 8014ba8:	22a2      	movs	r2, #162	; 0xa2
 8014baa:	490d      	ldr	r1, [pc, #52]	; (8014be0 <icmp_input+0x194>)
 8014bac:	4807      	ldr	r0, [pc, #28]	; (8014bcc <icmp_input+0x180>)
 8014bae:	f000 f8e3 	bl	8014d78 <iprintf>
 8014bb2:	e7cb      	b.n	8014b4c <icmp_input+0x100>
      if (pbuf_header(r, -hlen)) {
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
 8014bb4:	4628      	mov	r0, r5
 8014bb6:	f7fb fa37 	bl	8010028 <pbuf_free>
 8014bba:	465d      	mov	r5, fp
 8014bbc:	e782      	b.n	8014ac4 <icmp_input+0x78>
 8014bbe:	bf00      	nop
 8014bc0:	2000f09c 	.word	0x2000f09c
 8014bc4:	080186a4 	.word	0x080186a4
 8014bc8:	08017768 	.word	0x08017768
 8014bcc:	0801660c 	.word	0x0801660c
 8014bd0:	080186e8 	.word	0x080186e8
 8014bd4:	08018754 	.word	0x08018754
 8014bd8:	2000f0a4 	.word	0x2000f0a4
 8014bdc:	0801877c 	.word	0x0801877c
 8014be0:	0801871c 	.word	0x0801871c

08014be4 <icmp_dest_unreach>:
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
  icmp_send_response(p, ICMP_DUR, t);
 8014be4:	460a      	mov	r2, r1
 8014be6:	3004      	adds	r0, #4
 8014be8:	2103      	movs	r1, #3
 8014bea:	e6e7      	b.n	80149bc <icmp_send_response.isra.0>

08014bec <icmp_time_exceeded>:
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
  icmp_send_response(p, ICMP_TE, t);
 8014bec:	460a      	mov	r2, r1
 8014bee:	3004      	adds	r0, #4
 8014bf0:	210b      	movs	r1, #11
 8014bf2:	e6e3      	b.n	80149bc <icmp_send_response.isra.0>

08014bf4 <strcmp>:
 8014bf4:	f810 2b01 	ldrb.w	r2, [r0], #1
 8014bf8:	f811 3b01 	ldrb.w	r3, [r1], #1
 8014bfc:	2a01      	cmp	r2, #1
 8014bfe:	bf28      	it	cs
 8014c00:	429a      	cmpcs	r2, r3
 8014c02:	d0f7      	beq.n	8014bf4 <strcmp>
 8014c04:	1ad0      	subs	r0, r2, r3
 8014c06:	4770      	bx	lr

08014c08 <strlen>:
 8014c08:	4603      	mov	r3, r0
 8014c0a:	f813 2b01 	ldrb.w	r2, [r3], #1
 8014c0e:	2a00      	cmp	r2, #0
 8014c10:	d1fb      	bne.n	8014c0a <strlen+0x2>
 8014c12:	1a18      	subs	r0, r3, r0
 8014c14:	3801      	subs	r0, #1
 8014c16:	4770      	bx	lr

08014c18 <Reset_Handler>:
 8014c18:	2100      	movs	r1, #0
 8014c1a:	e003      	b.n	8014c24 <LoopCopyDataInit>

08014c1c <CopyDataInit>:
 8014c1c:	4b0a      	ldr	r3, [pc, #40]	; (8014c48 <LoopFillZerobss+0x10>)
 8014c1e:	585b      	ldr	r3, [r3, r1]
 8014c20:	5043      	str	r3, [r0, r1]
 8014c22:	3104      	adds	r1, #4

08014c24 <LoopCopyDataInit>:
 8014c24:	4809      	ldr	r0, [pc, #36]	; (8014c4c <LoopFillZerobss+0x14>)
 8014c26:	4b0a      	ldr	r3, [pc, #40]	; (8014c50 <LoopFillZerobss+0x18>)
 8014c28:	1842      	adds	r2, r0, r1
 8014c2a:	429a      	cmp	r2, r3
 8014c2c:	d3f6      	bcc.n	8014c1c <CopyDataInit>
 8014c2e:	4a09      	ldr	r2, [pc, #36]	; (8014c54 <LoopFillZerobss+0x1c>)
 8014c30:	e002      	b.n	8014c38 <LoopFillZerobss>

08014c32 <FillZerobss>:
 8014c32:	2300      	movs	r3, #0
 8014c34:	f842 3b04 	str.w	r3, [r2], #4

08014c38 <LoopFillZerobss>:
 8014c38:	4b07      	ldr	r3, [pc, #28]	; (8014c58 <LoopFillZerobss+0x20>)
 8014c3a:	429a      	cmp	r2, r3
 8014c3c:	d3f9      	bcc.n	8014c32 <FillZerobss>
 8014c3e:	f7eb facf 	bl	80001e0 <SystemInit>
 8014c42:	f000 f80d 	bl	8014c60 <main>
 8014c46:	4770      	bx	lr
 8014c48:	08018974 	.word	0x08018974
 8014c4c:	20000000 	.word	0x20000000
 8014c50:	20000204 	.word	0x20000204
 8014c54:	20000204 	.word	0x20000204
 8014c58:	20017000 	.word	0x20017000

08014c5c <App_BusFault_ISR>:
 8014c5c:	e7fe      	b.n	8014c5c <App_BusFault_ISR>
	...

08014c60 <main>:
*
* Returns     : none
*********************************************************************************************************
*/
int main(void)
{
 8014c60:	b570      	push	{r4, r5, r6, lr}
 8014c62:	b08c      	sub	sp, #48	; 0x30
    OS_ERR  err;
    BSP_IntDisAll();                                            /* Disable all interrupts.                                  */
    SystemInit();
    CPU_Init();                                                 /* Initialize uC/CPU services.                              */
    OSInit(&err);                                               /* Init OS.                                                 */
 8014c64:	f10d 042e 	add.w	r4, sp, #46	; 0x2e
*********************************************************************************************************
*/
int main(void)
{
    OS_ERR  err;
    BSP_IntDisAll();                                            /* Disable all interrupts.                                  */
 8014c68:	f7eb fff4 	bl	8000c54 <BSP_IntDisAll>
    SystemInit();
    CPU_Init();                                                 /* Initialize uC/CPU services.                              */
    OSInit(&err);                                               /* Init OS.                                                 */
    
    OSTaskCreate((OS_TCB     *)&TaskStartTCB,                /* Create the start task                                    */
 8014c6c:	4e0f      	ldr	r6, [pc, #60]	; (8014cac <main+0x4c>)
*/
int main(void)
{
    OS_ERR  err;
    BSP_IntDisAll();                                            /* Disable all interrupts.                                  */
    SystemInit();
 8014c6e:	f7eb fab7 	bl	80001e0 <SystemInit>
    CPU_Init();                                                 /* Initialize uC/CPU services.                              */
 8014c72:	f7ed f805 	bl	8001c80 <CPU_Init>
    OSInit(&err);                                               /* Init OS.                                                 */
 8014c76:	4620      	mov	r0, r4
 8014c78:	f7ef f85a 	bl	8003d30 <OSInit>
    
    OSTaskCreate((OS_TCB     *)&TaskStartTCB,                /* Create the start task                                    */
 8014c7c:	2503      	movs	r5, #3
 8014c7e:	2300      	movs	r3, #0
 8014c80:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8014c84:	2166      	movs	r1, #102	; 0x66
 8014c86:	2206      	movs	r2, #6
 8014c88:	9003      	str	r0, [sp, #12]
 8014c8a:	9102      	str	r1, [sp, #8]
 8014c8c:	9200      	str	r2, [sp, #0]
 8014c8e:	4808      	ldr	r0, [pc, #32]	; (8014cb0 <main+0x50>)
 8014c90:	9408      	str	r4, [sp, #32]
 8014c92:	9601      	str	r6, [sp, #4]
 8014c94:	9507      	str	r5, [sp, #28]
 8014c96:	9306      	str	r3, [sp, #24]
 8014c98:	9305      	str	r3, [sp, #20]
 8014c9a:	9304      	str	r3, [sp, #16]
 8014c9c:	4a05      	ldr	r2, [pc, #20]	; (8014cb4 <main+0x54>)
 8014c9e:	4906      	ldr	r1, [pc, #24]	; (8014cb8 <main+0x58>)
 8014ca0:	f7f2 f9b4 	bl	800700c <OSTaskCreate>
                 (OS_TICK     ) 0,
                 (void       *) 0,
                 (OS_OPT      )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR),
                 (OS_ERR     *)&err);
    
    OSStart(&err); 
 8014ca4:	4620      	mov	r0, r4
 8014ca6:	f7ee ffe5 	bl	8003c74 <OSStart>
 8014caa:	e7fe      	b.n	8014caa <main+0x4a>
 8014cac:	20008b94 	.word	0x20008b94
 8014cb0:	20009c58 	.word	0x20009c58
 8014cb4:	0800036d 	.word	0x0800036d
 8014cb8:	08016234 	.word	0x08016234

08014cbc <isblank>:
 8014cbc:	b510      	push	{r4, lr}
 8014cbe:	4604      	mov	r4, r0
 8014cc0:	f000 f81c 	bl	8014cfc <__locale_ctype_ptr>
 8014cc4:	4420      	add	r0, r4
 8014cc6:	f990 3001 	ldrsb.w	r3, [r0, #1]
 8014cca:	2b00      	cmp	r3, #0
 8014ccc:	db04      	blt.n	8014cd8 <isblank+0x1c>
 8014cce:	f1a4 0309 	sub.w	r3, r4, #9
 8014cd2:	4258      	negs	r0, r3
 8014cd4:	4158      	adcs	r0, r3
 8014cd6:	bd10      	pop	{r4, pc}
 8014cd8:	2001      	movs	r0, #1
 8014cda:	bd10      	pop	{r4, pc}

08014cdc <__get_current_locale>:
 8014cdc:	4b03      	ldr	r3, [pc, #12]	; (8014cec <__get_current_locale+0x10>)
 8014cde:	681b      	ldr	r3, [r3, #0]
 8014ce0:	6a18      	ldr	r0, [r3, #32]
 8014ce2:	4b03      	ldr	r3, [pc, #12]	; (8014cf0 <__get_current_locale+0x14>)
 8014ce4:	2800      	cmp	r0, #0
 8014ce6:	bf08      	it	eq
 8014ce8:	4618      	moveq	r0, r3
 8014cea:	4770      	bx	lr
 8014cec:	20000094 	.word	0x20000094
 8014cf0:	20000098 	.word	0x20000098

08014cf4 <__locale_ctype_ptr_l>:
 8014cf4:	f8d0 00ec 	ldr.w	r0, [r0, #236]	; 0xec
 8014cf8:	4770      	bx	lr
	...

08014cfc <__locale_ctype_ptr>:
 8014cfc:	b508      	push	{r3, lr}
 8014cfe:	4b03      	ldr	r3, [pc, #12]	; (8014d0c <__locale_ctype_ptr+0x10>)
 8014d00:	6818      	ldr	r0, [r3, #0]
 8014d02:	f7ff ffeb 	bl	8014cdc <__get_current_locale>
 8014d06:	f8d0 00ec 	ldr.w	r0, [r0, #236]	; 0xec
 8014d0a:	bd08      	pop	{r3, pc}
 8014d0c:	20000094 	.word	0x20000094

08014d10 <__ascii_mbtowc>:
 8014d10:	b082      	sub	sp, #8
 8014d12:	b901      	cbnz	r1, 8014d16 <__ascii_mbtowc+0x6>
 8014d14:	a901      	add	r1, sp, #4
 8014d16:	b13a      	cbz	r2, 8014d28 <__ascii_mbtowc+0x18>
 8014d18:	b143      	cbz	r3, 8014d2c <__ascii_mbtowc+0x1c>
 8014d1a:	7813      	ldrb	r3, [r2, #0]
 8014d1c:	600b      	str	r3, [r1, #0]
 8014d1e:	7812      	ldrb	r2, [r2, #0]
 8014d20:	1c10      	adds	r0, r2, #0
 8014d22:	bf18      	it	ne
 8014d24:	2001      	movne	r0, #1
 8014d26:	e003      	b.n	8014d30 <__ascii_mbtowc+0x20>
 8014d28:	4610      	mov	r0, r2
 8014d2a:	e001      	b.n	8014d30 <__ascii_mbtowc+0x20>
 8014d2c:	f06f 0001 	mvn.w	r0, #1
 8014d30:	b002      	add	sp, #8
 8014d32:	4770      	bx	lr

08014d34 <memcmp>:
 8014d34:	b510      	push	{r4, lr}
 8014d36:	3901      	subs	r1, #1
 8014d38:	4402      	add	r2, r0
 8014d3a:	4290      	cmp	r0, r2
 8014d3c:	d007      	beq.n	8014d4e <memcmp+0x1a>
 8014d3e:	f810 3b01 	ldrb.w	r3, [r0], #1
 8014d42:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8014d46:	42a3      	cmp	r3, r4
 8014d48:	d0f7      	beq.n	8014d3a <memcmp+0x6>
 8014d4a:	1b18      	subs	r0, r3, r4
 8014d4c:	bd10      	pop	{r4, pc}
 8014d4e:	2000      	movs	r0, #0
 8014d50:	bd10      	pop	{r4, pc}

08014d52 <memcpy>:
 8014d52:	b510      	push	{r4, lr}
 8014d54:	1e43      	subs	r3, r0, #1
 8014d56:	440a      	add	r2, r1
 8014d58:	4291      	cmp	r1, r2
 8014d5a:	d004      	beq.n	8014d66 <memcpy+0x14>
 8014d5c:	f811 4b01 	ldrb.w	r4, [r1], #1
 8014d60:	f803 4f01 	strb.w	r4, [r3, #1]!
 8014d64:	e7f8      	b.n	8014d58 <memcpy+0x6>
 8014d66:	bd10      	pop	{r4, pc}

08014d68 <memset>:
 8014d68:	4603      	mov	r3, r0
 8014d6a:	4402      	add	r2, r0
 8014d6c:	4293      	cmp	r3, r2
 8014d6e:	d002      	beq.n	8014d76 <memset+0xe>
 8014d70:	f803 1b01 	strb.w	r1, [r3], #1
 8014d74:	e7fa      	b.n	8014d6c <memset+0x4>
 8014d76:	4770      	bx	lr

08014d78 <iprintf>:
 8014d78:	b40f      	push	{r0, r1, r2, r3}
 8014d7a:	4b0a      	ldr	r3, [pc, #40]	; (8014da4 <iprintf+0x2c>)
 8014d7c:	b513      	push	{r0, r1, r4, lr}
 8014d7e:	681c      	ldr	r4, [r3, #0]
 8014d80:	b124      	cbz	r4, 8014d8c <iprintf+0x14>
 8014d82:	69a3      	ldr	r3, [r4, #24]
 8014d84:	b913      	cbnz	r3, 8014d8c <iprintf+0x14>
 8014d86:	4620      	mov	r0, r4
 8014d88:	f000 fb38 	bl	80153fc <__sinit>
 8014d8c:	ab05      	add	r3, sp, #20
 8014d8e:	9a04      	ldr	r2, [sp, #16]
 8014d90:	68a1      	ldr	r1, [r4, #8]
 8014d92:	4620      	mov	r0, r4
 8014d94:	9301      	str	r3, [sp, #4]
 8014d96:	f000 fced 	bl	8015774 <_vfiprintf_r>
 8014d9a:	b002      	add	sp, #8
 8014d9c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8014da0:	b004      	add	sp, #16
 8014da2:	4770      	bx	lr
 8014da4:	20000094 	.word	0x20000094

08014da8 <_putc_r>:
 8014da8:	b570      	push	{r4, r5, r6, lr}
 8014daa:	460d      	mov	r5, r1
 8014dac:	4614      	mov	r4, r2
 8014dae:	4606      	mov	r6, r0
 8014db0:	b118      	cbz	r0, 8014dba <_putc_r+0x12>
 8014db2:	6983      	ldr	r3, [r0, #24]
 8014db4:	b90b      	cbnz	r3, 8014dba <_putc_r+0x12>
 8014db6:	f000 fb21 	bl	80153fc <__sinit>
 8014dba:	4b13      	ldr	r3, [pc, #76]	; (8014e08 <_putc_r+0x60>)
 8014dbc:	429c      	cmp	r4, r3
 8014dbe:	d101      	bne.n	8014dc4 <_putc_r+0x1c>
 8014dc0:	6874      	ldr	r4, [r6, #4]
 8014dc2:	e008      	b.n	8014dd6 <_putc_r+0x2e>
 8014dc4:	4b11      	ldr	r3, [pc, #68]	; (8014e0c <_putc_r+0x64>)
 8014dc6:	429c      	cmp	r4, r3
 8014dc8:	d101      	bne.n	8014dce <_putc_r+0x26>
 8014dca:	68b4      	ldr	r4, [r6, #8]
 8014dcc:	e003      	b.n	8014dd6 <_putc_r+0x2e>
 8014dce:	4b10      	ldr	r3, [pc, #64]	; (8014e10 <_putc_r+0x68>)
 8014dd0:	429c      	cmp	r4, r3
 8014dd2:	bf08      	it	eq
 8014dd4:	68f4      	ldreq	r4, [r6, #12]
 8014dd6:	68a3      	ldr	r3, [r4, #8]
 8014dd8:	3b01      	subs	r3, #1
 8014dda:	2b00      	cmp	r3, #0
 8014ddc:	60a3      	str	r3, [r4, #8]
 8014dde:	da0c      	bge.n	8014dfa <_putc_r+0x52>
 8014de0:	69a2      	ldr	r2, [r4, #24]
 8014de2:	4293      	cmp	r3, r2
 8014de4:	db02      	blt.n	8014dec <_putc_r+0x44>
 8014de6:	b2eb      	uxtb	r3, r5
 8014de8:	2b0a      	cmp	r3, #10
 8014dea:	d106      	bne.n	8014dfa <_putc_r+0x52>
 8014dec:	4622      	mov	r2, r4
 8014dee:	4629      	mov	r1, r5
 8014df0:	4630      	mov	r0, r6
 8014df2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8014df6:	f000 b941 	b.w	801507c <__swbuf_r>
 8014dfa:	6823      	ldr	r3, [r4, #0]
 8014dfc:	b2e8      	uxtb	r0, r5
 8014dfe:	1c5a      	adds	r2, r3, #1
 8014e00:	6022      	str	r2, [r4, #0]
 8014e02:	701d      	strb	r5, [r3, #0]
 8014e04:	bd70      	pop	{r4, r5, r6, pc}
 8014e06:	bf00      	nop
 8014e08:	080188c0 	.word	0x080188c0
 8014e0c:	080188e0 	.word	0x080188e0
 8014e10:	08018900 	.word	0x08018900

08014e14 <putc>:
 8014e14:	4b02      	ldr	r3, [pc, #8]	; (8014e20 <putc+0xc>)
 8014e16:	460a      	mov	r2, r1
 8014e18:	4601      	mov	r1, r0
 8014e1a:	6818      	ldr	r0, [r3, #0]
 8014e1c:	f7ff bfc4 	b.w	8014da8 <_putc_r>
 8014e20:	20000094 	.word	0x20000094

08014e24 <_puts_r>:
 8014e24:	b570      	push	{r4, r5, r6, lr}
 8014e26:	460e      	mov	r6, r1
 8014e28:	4605      	mov	r5, r0
 8014e2a:	b118      	cbz	r0, 8014e34 <_puts_r+0x10>
 8014e2c:	6983      	ldr	r3, [r0, #24]
 8014e2e:	b90b      	cbnz	r3, 8014e34 <_puts_r+0x10>
 8014e30:	f000 fae4 	bl	80153fc <__sinit>
 8014e34:	69ab      	ldr	r3, [r5, #24]
 8014e36:	68ac      	ldr	r4, [r5, #8]
 8014e38:	b913      	cbnz	r3, 8014e40 <_puts_r+0x1c>
 8014e3a:	4628      	mov	r0, r5
 8014e3c:	f000 fade 	bl	80153fc <__sinit>
 8014e40:	4b22      	ldr	r3, [pc, #136]	; (8014ecc <_puts_r+0xa8>)
 8014e42:	429c      	cmp	r4, r3
 8014e44:	d101      	bne.n	8014e4a <_puts_r+0x26>
 8014e46:	686c      	ldr	r4, [r5, #4]
 8014e48:	e008      	b.n	8014e5c <_puts_r+0x38>
 8014e4a:	4b21      	ldr	r3, [pc, #132]	; (8014ed0 <_puts_r+0xac>)
 8014e4c:	429c      	cmp	r4, r3
 8014e4e:	d101      	bne.n	8014e54 <_puts_r+0x30>
 8014e50:	68ac      	ldr	r4, [r5, #8]
 8014e52:	e003      	b.n	8014e5c <_puts_r+0x38>
 8014e54:	4b1f      	ldr	r3, [pc, #124]	; (8014ed4 <_puts_r+0xb0>)
 8014e56:	429c      	cmp	r4, r3
 8014e58:	bf08      	it	eq
 8014e5a:	68ec      	ldreq	r4, [r5, #12]
 8014e5c:	89a3      	ldrh	r3, [r4, #12]
 8014e5e:	071b      	lsls	r3, r3, #28
 8014e60:	d501      	bpl.n	8014e66 <_puts_r+0x42>
 8014e62:	6923      	ldr	r3, [r4, #16]
 8014e64:	b93b      	cbnz	r3, 8014e76 <_puts_r+0x52>
 8014e66:	4621      	mov	r1, r4
 8014e68:	4628      	mov	r0, r5
 8014e6a:	f000 f969 	bl	8015140 <__swsetup_r>
 8014e6e:	b110      	cbz	r0, 8014e76 <_puts_r+0x52>
 8014e70:	f04f 30ff 	mov.w	r0, #4294967295
 8014e74:	bd70      	pop	{r4, r5, r6, pc}
 8014e76:	3e01      	subs	r6, #1
 8014e78:	68a3      	ldr	r3, [r4, #8]
 8014e7a:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 8014e7e:	3b01      	subs	r3, #1
 8014e80:	60a3      	str	r3, [r4, #8]
 8014e82:	b191      	cbz	r1, 8014eaa <_puts_r+0x86>
 8014e84:	2b00      	cmp	r3, #0
 8014e86:	da04      	bge.n	8014e92 <_puts_r+0x6e>
 8014e88:	69a2      	ldr	r2, [r4, #24]
 8014e8a:	4293      	cmp	r3, r2
 8014e8c:	db06      	blt.n	8014e9c <_puts_r+0x78>
 8014e8e:	290a      	cmp	r1, #10
 8014e90:	d004      	beq.n	8014e9c <_puts_r+0x78>
 8014e92:	6823      	ldr	r3, [r4, #0]
 8014e94:	1c5a      	adds	r2, r3, #1
 8014e96:	6022      	str	r2, [r4, #0]
 8014e98:	7019      	strb	r1, [r3, #0]
 8014e9a:	e7ed      	b.n	8014e78 <_puts_r+0x54>
 8014e9c:	4622      	mov	r2, r4
 8014e9e:	4628      	mov	r0, r5
 8014ea0:	f000 f8ec 	bl	801507c <__swbuf_r>
 8014ea4:	3001      	adds	r0, #1
 8014ea6:	d1e7      	bne.n	8014e78 <_puts_r+0x54>
 8014ea8:	e7e2      	b.n	8014e70 <_puts_r+0x4c>
 8014eaa:	2b00      	cmp	r3, #0
 8014eac:	da08      	bge.n	8014ec0 <_puts_r+0x9c>
 8014eae:	4622      	mov	r2, r4
 8014eb0:	210a      	movs	r1, #10
 8014eb2:	4628      	mov	r0, r5
 8014eb4:	f000 f8e2 	bl	801507c <__swbuf_r>
 8014eb8:	3001      	adds	r0, #1
 8014eba:	d0d9      	beq.n	8014e70 <_puts_r+0x4c>
 8014ebc:	200a      	movs	r0, #10
 8014ebe:	bd70      	pop	{r4, r5, r6, pc}
 8014ec0:	6823      	ldr	r3, [r4, #0]
 8014ec2:	200a      	movs	r0, #10
 8014ec4:	1c5a      	adds	r2, r3, #1
 8014ec6:	6022      	str	r2, [r4, #0]
 8014ec8:	7018      	strb	r0, [r3, #0]
 8014eca:	bd70      	pop	{r4, r5, r6, pc}
 8014ecc:	080188c0 	.word	0x080188c0
 8014ed0:	080188e0 	.word	0x080188e0
 8014ed4:	08018900 	.word	0x08018900

08014ed8 <puts>:
 8014ed8:	4b02      	ldr	r3, [pc, #8]	; (8014ee4 <puts+0xc>)
 8014eda:	4601      	mov	r1, r0
 8014edc:	6818      	ldr	r0, [r3, #0]
 8014ede:	f7ff bfa1 	b.w	8014e24 <_puts_r>
 8014ee2:	bf00      	nop
 8014ee4:	20000094 	.word	0x20000094

08014ee8 <strcpy>:
 8014ee8:	4603      	mov	r3, r0
 8014eea:	f811 2b01 	ldrb.w	r2, [r1], #1
 8014eee:	f803 2b01 	strb.w	r2, [r3], #1
 8014ef2:	2a00      	cmp	r2, #0
 8014ef4:	d1f9      	bne.n	8014eea <strcpy+0x2>
 8014ef6:	4770      	bx	lr

08014ef8 <strlcpy>:
 8014ef8:	b510      	push	{r4, lr}
 8014efa:	460b      	mov	r3, r1
 8014efc:	b152      	cbz	r2, 8014f14 <strlcpy+0x1c>
 8014efe:	3a01      	subs	r2, #1
 8014f00:	d006      	beq.n	8014f10 <strlcpy+0x18>
 8014f02:	f813 4b01 	ldrb.w	r4, [r3], #1
 8014f06:	f800 4b01 	strb.w	r4, [r0], #1
 8014f0a:	2c00      	cmp	r4, #0
 8014f0c:	d1f7      	bne.n	8014efe <strlcpy+0x6>
 8014f0e:	e005      	b.n	8014f1c <strlcpy+0x24>
 8014f10:	2200      	movs	r2, #0
 8014f12:	7002      	strb	r2, [r0, #0]
 8014f14:	f813 2b01 	ldrb.w	r2, [r3], #1
 8014f18:	2a00      	cmp	r2, #0
 8014f1a:	d1fb      	bne.n	8014f14 <strlcpy+0x1c>
 8014f1c:	1a58      	subs	r0, r3, r1
 8014f1e:	3801      	subs	r0, #1
 8014f20:	bd10      	pop	{r4, pc}

08014f22 <strncmp>:
 8014f22:	b530      	push	{r4, r5, lr}
 8014f24:	b182      	cbz	r2, 8014f48 <strncmp+0x26>
 8014f26:	1e45      	subs	r5, r0, #1
 8014f28:	3901      	subs	r1, #1
 8014f2a:	f815 3f01 	ldrb.w	r3, [r5, #1]!
 8014f2e:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8014f32:	42a3      	cmp	r3, r4
 8014f34:	d106      	bne.n	8014f44 <strncmp+0x22>
 8014f36:	43ec      	mvns	r4, r5
 8014f38:	4414      	add	r4, r2
 8014f3a:	42e0      	cmn	r0, r4
 8014f3c:	d001      	beq.n	8014f42 <strncmp+0x20>
 8014f3e:	2b00      	cmp	r3, #0
 8014f40:	d1f3      	bne.n	8014f2a <strncmp+0x8>
 8014f42:	461c      	mov	r4, r3
 8014f44:	1b18      	subs	r0, r3, r4
 8014f46:	bd30      	pop	{r4, r5, pc}
 8014f48:	4610      	mov	r0, r2
 8014f4a:	bd30      	pop	{r4, r5, pc}

08014f4c <_strtoul_l.isra.0>:
 8014f4c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8014f50:	4680      	mov	r8, r0
 8014f52:	4689      	mov	r9, r1
 8014f54:	4692      	mov	sl, r2
 8014f56:	461e      	mov	r6, r3
 8014f58:	460f      	mov	r7, r1
 8014f5a:	463d      	mov	r5, r7
 8014f5c:	9808      	ldr	r0, [sp, #32]
 8014f5e:	f815 4b01 	ldrb.w	r4, [r5], #1
 8014f62:	f7ff fec7 	bl	8014cf4 <__locale_ctype_ptr_l>
 8014f66:	4420      	add	r0, r4
 8014f68:	7843      	ldrb	r3, [r0, #1]
 8014f6a:	f003 0308 	and.w	r3, r3, #8
 8014f6e:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8014f72:	b10b      	cbz	r3, 8014f78 <_strtoul_l.isra.0+0x2c>
 8014f74:	462f      	mov	r7, r5
 8014f76:	e7f0      	b.n	8014f5a <_strtoul_l.isra.0+0xe>
 8014f78:	2c2d      	cmp	r4, #45	; 0x2d
 8014f7a:	d103      	bne.n	8014f84 <_strtoul_l.isra.0+0x38>
 8014f7c:	1cbd      	adds	r5, r7, #2
 8014f7e:	787c      	ldrb	r4, [r7, #1]
 8014f80:	2201      	movs	r2, #1
 8014f82:	e003      	b.n	8014f8c <_strtoul_l.isra.0+0x40>
 8014f84:	2c2b      	cmp	r4, #43	; 0x2b
 8014f86:	bf04      	itt	eq
 8014f88:	787c      	ldrbeq	r4, [r7, #1]
 8014f8a:	1cbd      	addeq	r5, r7, #2
 8014f8c:	b116      	cbz	r6, 8014f94 <_strtoul_l.isra.0+0x48>
 8014f8e:	2e10      	cmp	r6, #16
 8014f90:	d10a      	bne.n	8014fa8 <_strtoul_l.isra.0+0x5c>
 8014f92:	e057      	b.n	8015044 <_strtoul_l.isra.0+0xf8>
 8014f94:	2c30      	cmp	r4, #48	; 0x30
 8014f96:	d153      	bne.n	8015040 <_strtoul_l.isra.0+0xf4>
 8014f98:	782b      	ldrb	r3, [r5, #0]
 8014f9a:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 8014f9e:	2b58      	cmp	r3, #88	; 0x58
 8014fa0:	d149      	bne.n	8015036 <_strtoul_l.isra.0+0xea>
 8014fa2:	786c      	ldrb	r4, [r5, #1]
 8014fa4:	2610      	movs	r6, #16
 8014fa6:	3502      	adds	r5, #2
 8014fa8:	f04f 31ff 	mov.w	r1, #4294967295
 8014fac:	fbb1 f1f6 	udiv	r1, r1, r6
 8014fb0:	fb06 fe01 	mul.w	lr, r6, r1
 8014fb4:	2300      	movs	r3, #0
 8014fb6:	ea6f 0e0e 	mvn.w	lr, lr
 8014fba:	4618      	mov	r0, r3
 8014fbc:	f1a4 0730 	sub.w	r7, r4, #48	; 0x30
 8014fc0:	2f09      	cmp	r7, #9
 8014fc2:	d801      	bhi.n	8014fc8 <_strtoul_l.isra.0+0x7c>
 8014fc4:	463c      	mov	r4, r7
 8014fc6:	e00a      	b.n	8014fde <_strtoul_l.isra.0+0x92>
 8014fc8:	f1a4 0741 	sub.w	r7, r4, #65	; 0x41
 8014fcc:	2f19      	cmp	r7, #25
 8014fce:	d801      	bhi.n	8014fd4 <_strtoul_l.isra.0+0x88>
 8014fd0:	3c37      	subs	r4, #55	; 0x37
 8014fd2:	e004      	b.n	8014fde <_strtoul_l.isra.0+0x92>
 8014fd4:	f1a4 0761 	sub.w	r7, r4, #97	; 0x61
 8014fd8:	2f19      	cmp	r7, #25
 8014fda:	d813      	bhi.n	8015004 <_strtoul_l.isra.0+0xb8>
 8014fdc:	3c57      	subs	r4, #87	; 0x57
 8014fde:	42a6      	cmp	r6, r4
 8014fe0:	dd10      	ble.n	8015004 <_strtoul_l.isra.0+0xb8>
 8014fe2:	2b00      	cmp	r3, #0
 8014fe4:	db09      	blt.n	8014ffa <_strtoul_l.isra.0+0xae>
 8014fe6:	4281      	cmp	r1, r0
 8014fe8:	d307      	bcc.n	8014ffa <_strtoul_l.isra.0+0xae>
 8014fea:	d101      	bne.n	8014ff0 <_strtoul_l.isra.0+0xa4>
 8014fec:	45a6      	cmp	lr, r4
 8014fee:	db03      	blt.n	8014ff8 <_strtoul_l.isra.0+0xac>
 8014ff0:	fb00 4006 	mla	r0, r0, r6, r4
 8014ff4:	2301      	movs	r3, #1
 8014ff6:	e002      	b.n	8014ffe <_strtoul_l.isra.0+0xb2>
 8014ff8:	4608      	mov	r0, r1
 8014ffa:	f04f 33ff 	mov.w	r3, #4294967295
 8014ffe:	f815 4b01 	ldrb.w	r4, [r5], #1
 8015002:	e7db      	b.n	8014fbc <_strtoul_l.isra.0+0x70>
 8015004:	2b00      	cmp	r3, #0
 8015006:	da09      	bge.n	801501c <_strtoul_l.isra.0+0xd0>
 8015008:	2322      	movs	r3, #34	; 0x22
 801500a:	f8c8 3000 	str.w	r3, [r8]
 801500e:	f04f 30ff 	mov.w	r0, #4294967295
 8015012:	f1ba 0f00 	cmp.w	sl, #0
 8015016:	d107      	bne.n	8015028 <_strtoul_l.isra.0+0xdc>
 8015018:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801501c:	b102      	cbz	r2, 8015020 <_strtoul_l.isra.0+0xd4>
 801501e:	4240      	negs	r0, r0
 8015020:	f1ba 0f00 	cmp.w	sl, #0
 8015024:	d011      	beq.n	801504a <_strtoul_l.isra.0+0xfe>
 8015026:	b10b      	cbz	r3, 801502c <_strtoul_l.isra.0+0xe0>
 8015028:	3d01      	subs	r5, #1
 801502a:	e000      	b.n	801502e <_strtoul_l.isra.0+0xe2>
 801502c:	464d      	mov	r5, r9
 801502e:	f8ca 5000 	str.w	r5, [sl]
 8015032:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8015036:	2430      	movs	r4, #48	; 0x30
 8015038:	2e00      	cmp	r6, #0
 801503a:	d1b5      	bne.n	8014fa8 <_strtoul_l.isra.0+0x5c>
 801503c:	2608      	movs	r6, #8
 801503e:	e7b3      	b.n	8014fa8 <_strtoul_l.isra.0+0x5c>
 8015040:	260a      	movs	r6, #10
 8015042:	e7b1      	b.n	8014fa8 <_strtoul_l.isra.0+0x5c>
 8015044:	2c30      	cmp	r4, #48	; 0x30
 8015046:	d0a7      	beq.n	8014f98 <_strtoul_l.isra.0+0x4c>
 8015048:	e7ae      	b.n	8014fa8 <_strtoul_l.isra.0+0x5c>
 801504a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	...

08015050 <strtoul>:
 8015050:	4b08      	ldr	r3, [pc, #32]	; (8015074 <strtoul+0x24>)
 8015052:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8015054:	681c      	ldr	r4, [r3, #0]
 8015056:	4d08      	ldr	r5, [pc, #32]	; (8015078 <strtoul+0x28>)
 8015058:	6a23      	ldr	r3, [r4, #32]
 801505a:	2b00      	cmp	r3, #0
 801505c:	bf08      	it	eq
 801505e:	462b      	moveq	r3, r5
 8015060:	9300      	str	r3, [sp, #0]
 8015062:	4613      	mov	r3, r2
 8015064:	460a      	mov	r2, r1
 8015066:	4601      	mov	r1, r0
 8015068:	4620      	mov	r0, r4
 801506a:	f7ff ff6f 	bl	8014f4c <_strtoul_l.isra.0>
 801506e:	b003      	add	sp, #12
 8015070:	bd30      	pop	{r4, r5, pc}
 8015072:	bf00      	nop
 8015074:	20000094 	.word	0x20000094
 8015078:	20000098 	.word	0x20000098

0801507c <__swbuf_r>:
 801507c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801507e:	460f      	mov	r7, r1
 8015080:	4614      	mov	r4, r2
 8015082:	4605      	mov	r5, r0
 8015084:	b118      	cbz	r0, 801508e <__swbuf_r+0x12>
 8015086:	6983      	ldr	r3, [r0, #24]
 8015088:	b90b      	cbnz	r3, 801508e <__swbuf_r+0x12>
 801508a:	f000 f9b7 	bl	80153fc <__sinit>
 801508e:	4b22      	ldr	r3, [pc, #136]	; (8015118 <__swbuf_r+0x9c>)
 8015090:	429c      	cmp	r4, r3
 8015092:	d101      	bne.n	8015098 <__swbuf_r+0x1c>
 8015094:	686c      	ldr	r4, [r5, #4]
 8015096:	e008      	b.n	80150aa <__swbuf_r+0x2e>
 8015098:	4b20      	ldr	r3, [pc, #128]	; (801511c <__swbuf_r+0xa0>)
 801509a:	429c      	cmp	r4, r3
 801509c:	d101      	bne.n	80150a2 <__swbuf_r+0x26>
 801509e:	68ac      	ldr	r4, [r5, #8]
 80150a0:	e003      	b.n	80150aa <__swbuf_r+0x2e>
 80150a2:	4b1f      	ldr	r3, [pc, #124]	; (8015120 <__swbuf_r+0xa4>)
 80150a4:	429c      	cmp	r4, r3
 80150a6:	bf08      	it	eq
 80150a8:	68ec      	ldreq	r4, [r5, #12]
 80150aa:	69a3      	ldr	r3, [r4, #24]
 80150ac:	60a3      	str	r3, [r4, #8]
 80150ae:	89a3      	ldrh	r3, [r4, #12]
 80150b0:	071a      	lsls	r2, r3, #28
 80150b2:	d509      	bpl.n	80150c8 <__swbuf_r+0x4c>
 80150b4:	6923      	ldr	r3, [r4, #16]
 80150b6:	b13b      	cbz	r3, 80150c8 <__swbuf_r+0x4c>
 80150b8:	6823      	ldr	r3, [r4, #0]
 80150ba:	6920      	ldr	r0, [r4, #16]
 80150bc:	b2fe      	uxtb	r6, r7
 80150be:	1a18      	subs	r0, r3, r0
 80150c0:	6963      	ldr	r3, [r4, #20]
 80150c2:	4298      	cmp	r0, r3
 80150c4:	db0f      	blt.n	80150e6 <__swbuf_r+0x6a>
 80150c6:	e008      	b.n	80150da <__swbuf_r+0x5e>
 80150c8:	4621      	mov	r1, r4
 80150ca:	4628      	mov	r0, r5
 80150cc:	f000 f838 	bl	8015140 <__swsetup_r>
 80150d0:	2800      	cmp	r0, #0
 80150d2:	d0f1      	beq.n	80150b8 <__swbuf_r+0x3c>
 80150d4:	f04f 36ff 	mov.w	r6, #4294967295
 80150d8:	e01b      	b.n	8015112 <__swbuf_r+0x96>
 80150da:	4621      	mov	r1, r4
 80150dc:	4628      	mov	r0, r5
 80150de:	f000 f923 	bl	8015328 <_fflush_r>
 80150e2:	2800      	cmp	r0, #0
 80150e4:	d1f6      	bne.n	80150d4 <__swbuf_r+0x58>
 80150e6:	68a3      	ldr	r3, [r4, #8]
 80150e8:	3001      	adds	r0, #1
 80150ea:	3b01      	subs	r3, #1
 80150ec:	60a3      	str	r3, [r4, #8]
 80150ee:	6823      	ldr	r3, [r4, #0]
 80150f0:	1c5a      	adds	r2, r3, #1
 80150f2:	6022      	str	r2, [r4, #0]
 80150f4:	701f      	strb	r7, [r3, #0]
 80150f6:	6963      	ldr	r3, [r4, #20]
 80150f8:	4298      	cmp	r0, r3
 80150fa:	d004      	beq.n	8015106 <__swbuf_r+0x8a>
 80150fc:	89a3      	ldrh	r3, [r4, #12]
 80150fe:	07db      	lsls	r3, r3, #31
 8015100:	d507      	bpl.n	8015112 <__swbuf_r+0x96>
 8015102:	2e0a      	cmp	r6, #10
 8015104:	d105      	bne.n	8015112 <__swbuf_r+0x96>
 8015106:	4621      	mov	r1, r4
 8015108:	4628      	mov	r0, r5
 801510a:	f000 f90d 	bl	8015328 <_fflush_r>
 801510e:	2800      	cmp	r0, #0
 8015110:	d1e0      	bne.n	80150d4 <__swbuf_r+0x58>
 8015112:	4630      	mov	r0, r6
 8015114:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8015116:	bf00      	nop
 8015118:	080188c0 	.word	0x080188c0
 801511c:	080188e0 	.word	0x080188e0
 8015120:	08018900 	.word	0x08018900

08015124 <__ascii_wctomb>:
 8015124:	b149      	cbz	r1, 801513a <__ascii_wctomb+0x16>
 8015126:	2aff      	cmp	r2, #255	; 0xff
 8015128:	bf85      	ittet	hi
 801512a:	238a      	movhi	r3, #138	; 0x8a
 801512c:	6003      	strhi	r3, [r0, #0]
 801512e:	700a      	strbls	r2, [r1, #0]
 8015130:	f04f 30ff 	movhi.w	r0, #4294967295
 8015134:	bf98      	it	ls
 8015136:	2001      	movls	r0, #1
 8015138:	4770      	bx	lr
 801513a:	4608      	mov	r0, r1
 801513c:	4770      	bx	lr
	...

08015140 <__swsetup_r>:
 8015140:	4b32      	ldr	r3, [pc, #200]	; (801520c <__swsetup_r+0xcc>)
 8015142:	b570      	push	{r4, r5, r6, lr}
 8015144:	681d      	ldr	r5, [r3, #0]
 8015146:	4606      	mov	r6, r0
 8015148:	460c      	mov	r4, r1
 801514a:	b125      	cbz	r5, 8015156 <__swsetup_r+0x16>
 801514c:	69ab      	ldr	r3, [r5, #24]
 801514e:	b913      	cbnz	r3, 8015156 <__swsetup_r+0x16>
 8015150:	4628      	mov	r0, r5
 8015152:	f000 f953 	bl	80153fc <__sinit>
 8015156:	4b2e      	ldr	r3, [pc, #184]	; (8015210 <__swsetup_r+0xd0>)
 8015158:	429c      	cmp	r4, r3
 801515a:	d101      	bne.n	8015160 <__swsetup_r+0x20>
 801515c:	686c      	ldr	r4, [r5, #4]
 801515e:	e008      	b.n	8015172 <__swsetup_r+0x32>
 8015160:	4b2c      	ldr	r3, [pc, #176]	; (8015214 <__swsetup_r+0xd4>)
 8015162:	429c      	cmp	r4, r3
 8015164:	d101      	bne.n	801516a <__swsetup_r+0x2a>
 8015166:	68ac      	ldr	r4, [r5, #8]
 8015168:	e003      	b.n	8015172 <__swsetup_r+0x32>
 801516a:	4b2b      	ldr	r3, [pc, #172]	; (8015218 <__swsetup_r+0xd8>)
 801516c:	429c      	cmp	r4, r3
 801516e:	bf08      	it	eq
 8015170:	68ec      	ldreq	r4, [r5, #12]
 8015172:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8015176:	b29a      	uxth	r2, r3
 8015178:	0715      	lsls	r5, r2, #28
 801517a:	d41d      	bmi.n	80151b8 <__swsetup_r+0x78>
 801517c:	06d0      	lsls	r0, r2, #27
 801517e:	d402      	bmi.n	8015186 <__swsetup_r+0x46>
 8015180:	2209      	movs	r2, #9
 8015182:	6032      	str	r2, [r6, #0]
 8015184:	e03a      	b.n	80151fc <__swsetup_r+0xbc>
 8015186:	0751      	lsls	r1, r2, #29
 8015188:	d512      	bpl.n	80151b0 <__swsetup_r+0x70>
 801518a:	6b61      	ldr	r1, [r4, #52]	; 0x34
 801518c:	b141      	cbz	r1, 80151a0 <__swsetup_r+0x60>
 801518e:	f104 0344 	add.w	r3, r4, #68	; 0x44
 8015192:	4299      	cmp	r1, r3
 8015194:	d002      	beq.n	801519c <__swsetup_r+0x5c>
 8015196:	4630      	mov	r0, r6
 8015198:	f000 fa1a 	bl	80155d0 <_free_r>
 801519c:	2300      	movs	r3, #0
 801519e:	6363      	str	r3, [r4, #52]	; 0x34
 80151a0:	89a3      	ldrh	r3, [r4, #12]
 80151a2:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 80151a6:	81a3      	strh	r3, [r4, #12]
 80151a8:	2300      	movs	r3, #0
 80151aa:	6063      	str	r3, [r4, #4]
 80151ac:	6923      	ldr	r3, [r4, #16]
 80151ae:	6023      	str	r3, [r4, #0]
 80151b0:	89a3      	ldrh	r3, [r4, #12]
 80151b2:	f043 0308 	orr.w	r3, r3, #8
 80151b6:	81a3      	strh	r3, [r4, #12]
 80151b8:	6923      	ldr	r3, [r4, #16]
 80151ba:	b94b      	cbnz	r3, 80151d0 <__swsetup_r+0x90>
 80151bc:	89a3      	ldrh	r3, [r4, #12]
 80151be:	f403 7320 	and.w	r3, r3, #640	; 0x280
 80151c2:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80151c6:	d003      	beq.n	80151d0 <__swsetup_r+0x90>
 80151c8:	4621      	mov	r1, r4
 80151ca:	4630      	mov	r0, r6
 80151cc:	f000 f9c4 	bl	8015558 <__smakebuf_r>
 80151d0:	89a2      	ldrh	r2, [r4, #12]
 80151d2:	f012 0301 	ands.w	r3, r2, #1
 80151d6:	d005      	beq.n	80151e4 <__swsetup_r+0xa4>
 80151d8:	2300      	movs	r3, #0
 80151da:	60a3      	str	r3, [r4, #8]
 80151dc:	6963      	ldr	r3, [r4, #20]
 80151de:	425b      	negs	r3, r3
 80151e0:	61a3      	str	r3, [r4, #24]
 80151e2:	e003      	b.n	80151ec <__swsetup_r+0xac>
 80151e4:	0792      	lsls	r2, r2, #30
 80151e6:	bf58      	it	pl
 80151e8:	6963      	ldrpl	r3, [r4, #20]
 80151ea:	60a3      	str	r3, [r4, #8]
 80151ec:	6923      	ldr	r3, [r4, #16]
 80151ee:	b95b      	cbnz	r3, 8015208 <__swsetup_r+0xc8>
 80151f0:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 80151f4:	f003 0080 	and.w	r0, r3, #128	; 0x80
 80151f8:	b280      	uxth	r0, r0
 80151fa:	b130      	cbz	r0, 801520a <__swsetup_r+0xca>
 80151fc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8015200:	81a3      	strh	r3, [r4, #12]
 8015202:	f04f 30ff 	mov.w	r0, #4294967295
 8015206:	bd70      	pop	{r4, r5, r6, pc}
 8015208:	2000      	movs	r0, #0
 801520a:	bd70      	pop	{r4, r5, r6, pc}
 801520c:	20000094 	.word	0x20000094
 8015210:	080188c0 	.word	0x080188c0
 8015214:	080188e0 	.word	0x080188e0
 8015218:	08018900 	.word	0x08018900

0801521c <__sflush_r>:
 801521c:	898a      	ldrh	r2, [r1, #12]
 801521e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8015222:	4605      	mov	r5, r0
 8015224:	0710      	lsls	r0, r2, #28
 8015226:	460c      	mov	r4, r1
 8015228:	d459      	bmi.n	80152de <__sflush_r+0xc2>
 801522a:	684b      	ldr	r3, [r1, #4]
 801522c:	2b00      	cmp	r3, #0
 801522e:	dc02      	bgt.n	8015236 <__sflush_r+0x1a>
 8015230:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 8015232:	2b00      	cmp	r3, #0
 8015234:	dd17      	ble.n	8015266 <__sflush_r+0x4a>
 8015236:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 8015238:	b1ae      	cbz	r6, 8015266 <__sflush_r+0x4a>
 801523a:	f402 5280 	and.w	r2, r2, #4096	; 0x1000
 801523e:	2300      	movs	r3, #0
 8015240:	b292      	uxth	r2, r2
 8015242:	682f      	ldr	r7, [r5, #0]
 8015244:	602b      	str	r3, [r5, #0]
 8015246:	b10a      	cbz	r2, 801524c <__sflush_r+0x30>
 8015248:	6d60      	ldr	r0, [r4, #84]	; 0x54
 801524a:	e015      	b.n	8015278 <__sflush_r+0x5c>
 801524c:	6a21      	ldr	r1, [r4, #32]
 801524e:	2301      	movs	r3, #1
 8015250:	4628      	mov	r0, r5
 8015252:	47b0      	blx	r6
 8015254:	1c41      	adds	r1, r0, #1
 8015256:	d10f      	bne.n	8015278 <__sflush_r+0x5c>
 8015258:	682b      	ldr	r3, [r5, #0]
 801525a:	b16b      	cbz	r3, 8015278 <__sflush_r+0x5c>
 801525c:	2b1d      	cmp	r3, #29
 801525e:	d001      	beq.n	8015264 <__sflush_r+0x48>
 8015260:	2b16      	cmp	r3, #22
 8015262:	d103      	bne.n	801526c <__sflush_r+0x50>
 8015264:	602f      	str	r7, [r5, #0]
 8015266:	2000      	movs	r0, #0
 8015268:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801526c:	89a3      	ldrh	r3, [r4, #12]
 801526e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8015272:	81a3      	strh	r3, [r4, #12]
 8015274:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8015278:	89a3      	ldrh	r3, [r4, #12]
 801527a:	075a      	lsls	r2, r3, #29
 801527c:	d505      	bpl.n	801528a <__sflush_r+0x6e>
 801527e:	6863      	ldr	r3, [r4, #4]
 8015280:	1ac0      	subs	r0, r0, r3
 8015282:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8015284:	b10b      	cbz	r3, 801528a <__sflush_r+0x6e>
 8015286:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8015288:	1ac0      	subs	r0, r0, r3
 801528a:	2300      	movs	r3, #0
 801528c:	4602      	mov	r2, r0
 801528e:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 8015290:	6a21      	ldr	r1, [r4, #32]
 8015292:	4628      	mov	r0, r5
 8015294:	47b0      	blx	r6
 8015296:	1c43      	adds	r3, r0, #1
 8015298:	89a3      	ldrh	r3, [r4, #12]
 801529a:	d106      	bne.n	80152aa <__sflush_r+0x8e>
 801529c:	6829      	ldr	r1, [r5, #0]
 801529e:	291d      	cmp	r1, #29
 80152a0:	d839      	bhi.n	8015316 <__sflush_r+0xfa>
 80152a2:	4a20      	ldr	r2, [pc, #128]	; (8015324 <__sflush_r+0x108>)
 80152a4:	40ca      	lsrs	r2, r1
 80152a6:	07d6      	lsls	r6, r2, #31
 80152a8:	d535      	bpl.n	8015316 <__sflush_r+0xfa>
 80152aa:	2200      	movs	r2, #0
 80152ac:	6062      	str	r2, [r4, #4]
 80152ae:	6922      	ldr	r2, [r4, #16]
 80152b0:	04d9      	lsls	r1, r3, #19
 80152b2:	6022      	str	r2, [r4, #0]
 80152b4:	d504      	bpl.n	80152c0 <__sflush_r+0xa4>
 80152b6:	1c42      	adds	r2, r0, #1
 80152b8:	d101      	bne.n	80152be <__sflush_r+0xa2>
 80152ba:	682b      	ldr	r3, [r5, #0]
 80152bc:	b903      	cbnz	r3, 80152c0 <__sflush_r+0xa4>
 80152be:	6560      	str	r0, [r4, #84]	; 0x54
 80152c0:	6b61      	ldr	r1, [r4, #52]	; 0x34
 80152c2:	602f      	str	r7, [r5, #0]
 80152c4:	2900      	cmp	r1, #0
 80152c6:	d0ce      	beq.n	8015266 <__sflush_r+0x4a>
 80152c8:	f104 0344 	add.w	r3, r4, #68	; 0x44
 80152cc:	4299      	cmp	r1, r3
 80152ce:	d002      	beq.n	80152d6 <__sflush_r+0xba>
 80152d0:	4628      	mov	r0, r5
 80152d2:	f000 f97d 	bl	80155d0 <_free_r>
 80152d6:	2000      	movs	r0, #0
 80152d8:	6360      	str	r0, [r4, #52]	; 0x34
 80152da:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80152de:	690f      	ldr	r7, [r1, #16]
 80152e0:	2f00      	cmp	r7, #0
 80152e2:	d0c0      	beq.n	8015266 <__sflush_r+0x4a>
 80152e4:	0793      	lsls	r3, r2, #30
 80152e6:	680e      	ldr	r6, [r1, #0]
 80152e8:	bf0c      	ite	eq
 80152ea:	694b      	ldreq	r3, [r1, #20]
 80152ec:	2300      	movne	r3, #0
 80152ee:	ebc7 0806 	rsb	r8, r7, r6
 80152f2:	600f      	str	r7, [r1, #0]
 80152f4:	608b      	str	r3, [r1, #8]
 80152f6:	e002      	b.n	80152fe <__sflush_r+0xe2>
 80152f8:	4407      	add	r7, r0
 80152fa:	ebc0 0808 	rsb	r8, r0, r8
 80152fe:	f1b8 0f00 	cmp.w	r8, #0
 8015302:	ddb0      	ble.n	8015266 <__sflush_r+0x4a>
 8015304:	4643      	mov	r3, r8
 8015306:	463a      	mov	r2, r7
 8015308:	6a21      	ldr	r1, [r4, #32]
 801530a:	4628      	mov	r0, r5
 801530c:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 801530e:	47b0      	blx	r6
 8015310:	2800      	cmp	r0, #0
 8015312:	dcf1      	bgt.n	80152f8 <__sflush_r+0xdc>
 8015314:	89a3      	ldrh	r3, [r4, #12]
 8015316:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 801531a:	81a3      	strh	r3, [r4, #12]
 801531c:	f04f 30ff 	mov.w	r0, #4294967295
 8015320:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8015324:	20400001 	.word	0x20400001

08015328 <_fflush_r>:
 8015328:	b538      	push	{r3, r4, r5, lr}
 801532a:	690b      	ldr	r3, [r1, #16]
 801532c:	4605      	mov	r5, r0
 801532e:	460c      	mov	r4, r1
 8015330:	b1db      	cbz	r3, 801536a <_fflush_r+0x42>
 8015332:	b118      	cbz	r0, 801533c <_fflush_r+0x14>
 8015334:	6983      	ldr	r3, [r0, #24]
 8015336:	b90b      	cbnz	r3, 801533c <_fflush_r+0x14>
 8015338:	f000 f860 	bl	80153fc <__sinit>
 801533c:	4b0c      	ldr	r3, [pc, #48]	; (8015370 <_fflush_r+0x48>)
 801533e:	429c      	cmp	r4, r3
 8015340:	d101      	bne.n	8015346 <_fflush_r+0x1e>
 8015342:	686c      	ldr	r4, [r5, #4]
 8015344:	e008      	b.n	8015358 <_fflush_r+0x30>
 8015346:	4b0b      	ldr	r3, [pc, #44]	; (8015374 <_fflush_r+0x4c>)
 8015348:	429c      	cmp	r4, r3
 801534a:	d101      	bne.n	8015350 <_fflush_r+0x28>
 801534c:	68ac      	ldr	r4, [r5, #8]
 801534e:	e003      	b.n	8015358 <_fflush_r+0x30>
 8015350:	4b09      	ldr	r3, [pc, #36]	; (8015378 <_fflush_r+0x50>)
 8015352:	429c      	cmp	r4, r3
 8015354:	bf08      	it	eq
 8015356:	68ec      	ldreq	r4, [r5, #12]
 8015358:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 801535c:	b12b      	cbz	r3, 801536a <_fflush_r+0x42>
 801535e:	4621      	mov	r1, r4
 8015360:	4628      	mov	r0, r5
 8015362:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8015366:	f7ff bf59 	b.w	801521c <__sflush_r>
 801536a:	2000      	movs	r0, #0
 801536c:	bd38      	pop	{r3, r4, r5, pc}
 801536e:	bf00      	nop
 8015370:	080188c0 	.word	0x080188c0
 8015374:	080188e0 	.word	0x080188e0
 8015378:	08018900 	.word	0x08018900

0801537c <_cleanup_r>:
 801537c:	4901      	ldr	r1, [pc, #4]	; (8015384 <_cleanup_r+0x8>)
 801537e:	f000 b8a9 	b.w	80154d4 <_fwalk_reent>
 8015382:	bf00      	nop
 8015384:	08015329 	.word	0x08015329

08015388 <std.isra.0>:
 8015388:	b510      	push	{r4, lr}
 801538a:	4604      	mov	r4, r0
 801538c:	2300      	movs	r3, #0
 801538e:	6003      	str	r3, [r0, #0]
 8015390:	6043      	str	r3, [r0, #4]
 8015392:	6083      	str	r3, [r0, #8]
 8015394:	8181      	strh	r1, [r0, #12]
 8015396:	6643      	str	r3, [r0, #100]	; 0x64
 8015398:	81c2      	strh	r2, [r0, #14]
 801539a:	6103      	str	r3, [r0, #16]
 801539c:	6143      	str	r3, [r0, #20]
 801539e:	6183      	str	r3, [r0, #24]
 80153a0:	4619      	mov	r1, r3
 80153a2:	2208      	movs	r2, #8
 80153a4:	305c      	adds	r0, #92	; 0x5c
 80153a6:	f7ff fcdf 	bl	8014d68 <memset>
 80153aa:	4b05      	ldr	r3, [pc, #20]	; (80153c0 <std.isra.0+0x38>)
 80153ac:	6224      	str	r4, [r4, #32]
 80153ae:	6263      	str	r3, [r4, #36]	; 0x24
 80153b0:	4b04      	ldr	r3, [pc, #16]	; (80153c4 <std.isra.0+0x3c>)
 80153b2:	62a3      	str	r3, [r4, #40]	; 0x28
 80153b4:	4b04      	ldr	r3, [pc, #16]	; (80153c8 <std.isra.0+0x40>)
 80153b6:	62e3      	str	r3, [r4, #44]	; 0x2c
 80153b8:	4b04      	ldr	r3, [pc, #16]	; (80153cc <std.isra.0+0x44>)
 80153ba:	6323      	str	r3, [r4, #48]	; 0x30
 80153bc:	bd10      	pop	{r4, pc}
 80153be:	bf00      	nop
 80153c0:	08015d05 	.word	0x08015d05
 80153c4:	08015d27 	.word	0x08015d27
 80153c8:	08015d5f 	.word	0x08015d5f
 80153cc:	08015d83 	.word	0x08015d83

080153d0 <__sfmoreglue>:
 80153d0:	b570      	push	{r4, r5, r6, lr}
 80153d2:	2368      	movs	r3, #104	; 0x68
 80153d4:	1e4d      	subs	r5, r1, #1
 80153d6:	435d      	muls	r5, r3
 80153d8:	460e      	mov	r6, r1
 80153da:	f105 0174 	add.w	r1, r5, #116	; 0x74
 80153de:	f000 f943 	bl	8015668 <_malloc_r>
 80153e2:	4604      	mov	r4, r0
 80153e4:	b140      	cbz	r0, 80153f8 <__sfmoreglue+0x28>
 80153e6:	2100      	movs	r1, #0
 80153e8:	e880 0042 	stmia.w	r0, {r1, r6}
 80153ec:	300c      	adds	r0, #12
 80153ee:	60a0      	str	r0, [r4, #8]
 80153f0:	f105 0268 	add.w	r2, r5, #104	; 0x68
 80153f4:	f7ff fcb8 	bl	8014d68 <memset>
 80153f8:	4620      	mov	r0, r4
 80153fa:	bd70      	pop	{r4, r5, r6, pc}

080153fc <__sinit>:
 80153fc:	6983      	ldr	r3, [r0, #24]
 80153fe:	b510      	push	{r4, lr}
 8015400:	4604      	mov	r4, r0
 8015402:	bb33      	cbnz	r3, 8015452 <__sinit+0x56>
 8015404:	6483      	str	r3, [r0, #72]	; 0x48
 8015406:	64c3      	str	r3, [r0, #76]	; 0x4c
 8015408:	6503      	str	r3, [r0, #80]	; 0x50
 801540a:	4b12      	ldr	r3, [pc, #72]	; (8015454 <__sinit+0x58>)
 801540c:	4a12      	ldr	r2, [pc, #72]	; (8015458 <__sinit+0x5c>)
 801540e:	681b      	ldr	r3, [r3, #0]
 8015410:	6282      	str	r2, [r0, #40]	; 0x28
 8015412:	4298      	cmp	r0, r3
 8015414:	bf04      	itt	eq
 8015416:	2301      	moveq	r3, #1
 8015418:	6183      	streq	r3, [r0, #24]
 801541a:	f000 f81f 	bl	801545c <__sfp>
 801541e:	6060      	str	r0, [r4, #4]
 8015420:	4620      	mov	r0, r4
 8015422:	f000 f81b 	bl	801545c <__sfp>
 8015426:	60a0      	str	r0, [r4, #8]
 8015428:	4620      	mov	r0, r4
 801542a:	f000 f817 	bl	801545c <__sfp>
 801542e:	2200      	movs	r2, #0
 8015430:	60e0      	str	r0, [r4, #12]
 8015432:	2104      	movs	r1, #4
 8015434:	6860      	ldr	r0, [r4, #4]
 8015436:	f7ff ffa7 	bl	8015388 <std.isra.0>
 801543a:	2201      	movs	r2, #1
 801543c:	2109      	movs	r1, #9
 801543e:	68a0      	ldr	r0, [r4, #8]
 8015440:	f7ff ffa2 	bl	8015388 <std.isra.0>
 8015444:	2202      	movs	r2, #2
 8015446:	2112      	movs	r1, #18
 8015448:	68e0      	ldr	r0, [r4, #12]
 801544a:	f7ff ff9d 	bl	8015388 <std.isra.0>
 801544e:	2301      	movs	r3, #1
 8015450:	61a3      	str	r3, [r4, #24]
 8015452:	bd10      	pop	{r4, pc}
 8015454:	080187b0 	.word	0x080187b0
 8015458:	0801537d 	.word	0x0801537d

0801545c <__sfp>:
 801545c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801545e:	4b1c      	ldr	r3, [pc, #112]	; (80154d0 <__sfp+0x74>)
 8015460:	4607      	mov	r7, r0
 8015462:	681e      	ldr	r6, [r3, #0]
 8015464:	69b3      	ldr	r3, [r6, #24]
 8015466:	b913      	cbnz	r3, 801546e <__sfp+0x12>
 8015468:	4630      	mov	r0, r6
 801546a:	f7ff ffc7 	bl	80153fc <__sinit>
 801546e:	3648      	adds	r6, #72	; 0x48
 8015470:	68b4      	ldr	r4, [r6, #8]
 8015472:	6873      	ldr	r3, [r6, #4]
 8015474:	3b01      	subs	r3, #1
 8015476:	d404      	bmi.n	8015482 <__sfp+0x26>
 8015478:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
 801547c:	b17d      	cbz	r5, 801549e <__sfp+0x42>
 801547e:	3468      	adds	r4, #104	; 0x68
 8015480:	e7f8      	b.n	8015474 <__sfp+0x18>
 8015482:	6833      	ldr	r3, [r6, #0]
 8015484:	b10b      	cbz	r3, 801548a <__sfp+0x2e>
 8015486:	6836      	ldr	r6, [r6, #0]
 8015488:	e7f2      	b.n	8015470 <__sfp+0x14>
 801548a:	2104      	movs	r1, #4
 801548c:	4638      	mov	r0, r7
 801548e:	f7ff ff9f 	bl	80153d0 <__sfmoreglue>
 8015492:	6030      	str	r0, [r6, #0]
 8015494:	2800      	cmp	r0, #0
 8015496:	d1f6      	bne.n	8015486 <__sfp+0x2a>
 8015498:	230c      	movs	r3, #12
 801549a:	603b      	str	r3, [r7, #0]
 801549c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801549e:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80154a2:	81e3      	strh	r3, [r4, #14]
 80154a4:	2301      	movs	r3, #1
 80154a6:	81a3      	strh	r3, [r4, #12]
 80154a8:	6665      	str	r5, [r4, #100]	; 0x64
 80154aa:	6025      	str	r5, [r4, #0]
 80154ac:	60a5      	str	r5, [r4, #8]
 80154ae:	6065      	str	r5, [r4, #4]
 80154b0:	6125      	str	r5, [r4, #16]
 80154b2:	6165      	str	r5, [r4, #20]
 80154b4:	61a5      	str	r5, [r4, #24]
 80154b6:	2208      	movs	r2, #8
 80154b8:	4629      	mov	r1, r5
 80154ba:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 80154be:	f7ff fc53 	bl	8014d68 <memset>
 80154c2:	6365      	str	r5, [r4, #52]	; 0x34
 80154c4:	63a5      	str	r5, [r4, #56]	; 0x38
 80154c6:	64a5      	str	r5, [r4, #72]	; 0x48
 80154c8:	64e5      	str	r5, [r4, #76]	; 0x4c
 80154ca:	4620      	mov	r0, r4
 80154cc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80154ce:	bf00      	nop
 80154d0:	080187b0 	.word	0x080187b0

080154d4 <_fwalk_reent>:
 80154d4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80154d8:	4680      	mov	r8, r0
 80154da:	4689      	mov	r9, r1
 80154dc:	f100 0448 	add.w	r4, r0, #72	; 0x48
 80154e0:	2600      	movs	r6, #0
 80154e2:	b194      	cbz	r4, 801550a <_fwalk_reent+0x36>
 80154e4:	68a5      	ldr	r5, [r4, #8]
 80154e6:	6867      	ldr	r7, [r4, #4]
 80154e8:	3f01      	subs	r7, #1
 80154ea:	d40c      	bmi.n	8015506 <_fwalk_reent+0x32>
 80154ec:	89ab      	ldrh	r3, [r5, #12]
 80154ee:	2b01      	cmp	r3, #1
 80154f0:	d907      	bls.n	8015502 <_fwalk_reent+0x2e>
 80154f2:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 80154f6:	3301      	adds	r3, #1
 80154f8:	d003      	beq.n	8015502 <_fwalk_reent+0x2e>
 80154fa:	4629      	mov	r1, r5
 80154fc:	4640      	mov	r0, r8
 80154fe:	47c8      	blx	r9
 8015500:	4306      	orrs	r6, r0
 8015502:	3568      	adds	r5, #104	; 0x68
 8015504:	e7f0      	b.n	80154e8 <_fwalk_reent+0x14>
 8015506:	6824      	ldr	r4, [r4, #0]
 8015508:	e7eb      	b.n	80154e2 <_fwalk_reent+0xe>
 801550a:	4630      	mov	r0, r6
 801550c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

08015510 <__swhatbuf_r>:
 8015510:	b570      	push	{r4, r5, r6, lr}
 8015512:	460e      	mov	r6, r1
 8015514:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8015518:	b090      	sub	sp, #64	; 0x40
 801551a:	2900      	cmp	r1, #0
 801551c:	4614      	mov	r4, r2
 801551e:	461d      	mov	r5, r3
 8015520:	da06      	bge.n	8015530 <__swhatbuf_r+0x20>
 8015522:	2300      	movs	r3, #0
 8015524:	602b      	str	r3, [r5, #0]
 8015526:	89b3      	ldrh	r3, [r6, #12]
 8015528:	061a      	lsls	r2, r3, #24
 801552a:	d50e      	bpl.n	801554a <__swhatbuf_r+0x3a>
 801552c:	2340      	movs	r3, #64	; 0x40
 801552e:	e00e      	b.n	801554e <__swhatbuf_r+0x3e>
 8015530:	aa01      	add	r2, sp, #4
 8015532:	f000 fc4d 	bl	8015dd0 <_fstat_r>
 8015536:	2800      	cmp	r0, #0
 8015538:	dbf3      	blt.n	8015522 <__swhatbuf_r+0x12>
 801553a:	9a02      	ldr	r2, [sp, #8]
 801553c:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
 8015540:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
 8015544:	425a      	negs	r2, r3
 8015546:	415a      	adcs	r2, r3
 8015548:	602a      	str	r2, [r5, #0]
 801554a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 801554e:	2000      	movs	r0, #0
 8015550:	6023      	str	r3, [r4, #0]
 8015552:	b010      	add	sp, #64	; 0x40
 8015554:	bd70      	pop	{r4, r5, r6, pc}
	...

08015558 <__smakebuf_r>:
 8015558:	898b      	ldrh	r3, [r1, #12]
 801555a:	b573      	push	{r0, r1, r4, r5, r6, lr}
 801555c:	079e      	lsls	r6, r3, #30
 801555e:	4605      	mov	r5, r0
 8015560:	460c      	mov	r4, r1
 8015562:	d410      	bmi.n	8015586 <__smakebuf_r+0x2e>
 8015564:	ab01      	add	r3, sp, #4
 8015566:	466a      	mov	r2, sp
 8015568:	f7ff ffd2 	bl	8015510 <__swhatbuf_r>
 801556c:	9900      	ldr	r1, [sp, #0]
 801556e:	4606      	mov	r6, r0
 8015570:	4628      	mov	r0, r5
 8015572:	f000 f879 	bl	8015668 <_malloc_r>
 8015576:	b968      	cbnz	r0, 8015594 <__smakebuf_r+0x3c>
 8015578:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 801557c:	059a      	lsls	r2, r3, #22
 801557e:	d422      	bmi.n	80155c6 <__smakebuf_r+0x6e>
 8015580:	f043 0302 	orr.w	r3, r3, #2
 8015584:	81a3      	strh	r3, [r4, #12]
 8015586:	f104 0347 	add.w	r3, r4, #71	; 0x47
 801558a:	6023      	str	r3, [r4, #0]
 801558c:	6123      	str	r3, [r4, #16]
 801558e:	2301      	movs	r3, #1
 8015590:	6163      	str	r3, [r4, #20]
 8015592:	e018      	b.n	80155c6 <__smakebuf_r+0x6e>
 8015594:	4b0d      	ldr	r3, [pc, #52]	; (80155cc <__smakebuf_r+0x74>)
 8015596:	62ab      	str	r3, [r5, #40]	; 0x28
 8015598:	89a3      	ldrh	r3, [r4, #12]
 801559a:	6020      	str	r0, [r4, #0]
 801559c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80155a0:	81a3      	strh	r3, [r4, #12]
 80155a2:	9b00      	ldr	r3, [sp, #0]
 80155a4:	6120      	str	r0, [r4, #16]
 80155a6:	6163      	str	r3, [r4, #20]
 80155a8:	9b01      	ldr	r3, [sp, #4]
 80155aa:	b14b      	cbz	r3, 80155c0 <__smakebuf_r+0x68>
 80155ac:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 80155b0:	4628      	mov	r0, r5
 80155b2:	f000 fc1f 	bl	8015df4 <_isatty_r>
 80155b6:	b118      	cbz	r0, 80155c0 <__smakebuf_r+0x68>
 80155b8:	89a3      	ldrh	r3, [r4, #12]
 80155ba:	f043 0301 	orr.w	r3, r3, #1
 80155be:	81a3      	strh	r3, [r4, #12]
 80155c0:	89a0      	ldrh	r0, [r4, #12]
 80155c2:	4330      	orrs	r0, r6
 80155c4:	81a0      	strh	r0, [r4, #12]
 80155c6:	b002      	add	sp, #8
 80155c8:	bd70      	pop	{r4, r5, r6, pc}
 80155ca:	bf00      	nop
 80155cc:	0801537d 	.word	0x0801537d

080155d0 <_free_r>:
 80155d0:	b538      	push	{r3, r4, r5, lr}
 80155d2:	4605      	mov	r5, r0
 80155d4:	2900      	cmp	r1, #0
 80155d6:	d044      	beq.n	8015662 <_free_r+0x92>
 80155d8:	f851 3c04 	ldr.w	r3, [r1, #-4]
 80155dc:	1f0c      	subs	r4, r1, #4
 80155de:	2b00      	cmp	r3, #0
 80155e0:	bfb8      	it	lt
 80155e2:	18e4      	addlt	r4, r4, r3
 80155e4:	f000 fc36 	bl	8015e54 <__malloc_lock>
 80155e8:	4a1e      	ldr	r2, [pc, #120]	; (8015664 <_free_r+0x94>)
 80155ea:	6813      	ldr	r3, [r2, #0]
 80155ec:	4611      	mov	r1, r2
 80155ee:	b913      	cbnz	r3, 80155f6 <_free_r+0x26>
 80155f0:	6063      	str	r3, [r4, #4]
 80155f2:	6014      	str	r4, [r2, #0]
 80155f4:	e030      	b.n	8015658 <_free_r+0x88>
 80155f6:	42a3      	cmp	r3, r4
 80155f8:	d90d      	bls.n	8015616 <_free_r+0x46>
 80155fa:	6822      	ldr	r2, [r4, #0]
 80155fc:	18a0      	adds	r0, r4, r2
 80155fe:	4283      	cmp	r3, r0
 8015600:	bf01      	itttt	eq
 8015602:	6818      	ldreq	r0, [r3, #0]
 8015604:	685b      	ldreq	r3, [r3, #4]
 8015606:	1812      	addeq	r2, r2, r0
 8015608:	6022      	streq	r2, [r4, #0]
 801560a:	6063      	str	r3, [r4, #4]
 801560c:	600c      	str	r4, [r1, #0]
 801560e:	e023      	b.n	8015658 <_free_r+0x88>
 8015610:	42a2      	cmp	r2, r4
 8015612:	d803      	bhi.n	801561c <_free_r+0x4c>
 8015614:	4613      	mov	r3, r2
 8015616:	685a      	ldr	r2, [r3, #4]
 8015618:	2a00      	cmp	r2, #0
 801561a:	d1f9      	bne.n	8015610 <_free_r+0x40>
 801561c:	6818      	ldr	r0, [r3, #0]
 801561e:	1819      	adds	r1, r3, r0
 8015620:	42a1      	cmp	r1, r4
 8015622:	d10b      	bne.n	801563c <_free_r+0x6c>
 8015624:	6821      	ldr	r1, [r4, #0]
 8015626:	4401      	add	r1, r0
 8015628:	1858      	adds	r0, r3, r1
 801562a:	4282      	cmp	r2, r0
 801562c:	6019      	str	r1, [r3, #0]
 801562e:	d113      	bne.n	8015658 <_free_r+0x88>
 8015630:	6810      	ldr	r0, [r2, #0]
 8015632:	6852      	ldr	r2, [r2, #4]
 8015634:	4401      	add	r1, r0
 8015636:	6019      	str	r1, [r3, #0]
 8015638:	605a      	str	r2, [r3, #4]
 801563a:	e00d      	b.n	8015658 <_free_r+0x88>
 801563c:	d902      	bls.n	8015644 <_free_r+0x74>
 801563e:	230c      	movs	r3, #12
 8015640:	602b      	str	r3, [r5, #0]
 8015642:	e009      	b.n	8015658 <_free_r+0x88>
 8015644:	6821      	ldr	r1, [r4, #0]
 8015646:	1860      	adds	r0, r4, r1
 8015648:	4282      	cmp	r2, r0
 801564a:	bf01      	itttt	eq
 801564c:	6810      	ldreq	r0, [r2, #0]
 801564e:	6852      	ldreq	r2, [r2, #4]
 8015650:	1809      	addeq	r1, r1, r0
 8015652:	6021      	streq	r1, [r4, #0]
 8015654:	6062      	str	r2, [r4, #4]
 8015656:	605c      	str	r4, [r3, #4]
 8015658:	4628      	mov	r0, r5
 801565a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 801565e:	f000 bbfa 	b.w	8015e56 <__malloc_unlock>
 8015662:	bd38      	pop	{r3, r4, r5, pc}
 8015664:	20004cf8 	.word	0x20004cf8

08015668 <_malloc_r>:
 8015668:	b570      	push	{r4, r5, r6, lr}
 801566a:	1ccd      	adds	r5, r1, #3
 801566c:	f025 0503 	bic.w	r5, r5, #3
 8015670:	3508      	adds	r5, #8
 8015672:	2d0c      	cmp	r5, #12
 8015674:	bf38      	it	cc
 8015676:	250c      	movcc	r5, #12
 8015678:	2d00      	cmp	r5, #0
 801567a:	4606      	mov	r6, r0
 801567c:	db01      	blt.n	8015682 <_malloc_r+0x1a>
 801567e:	42a9      	cmp	r1, r5
 8015680:	d902      	bls.n	8015688 <_malloc_r+0x20>
 8015682:	230c      	movs	r3, #12
 8015684:	6033      	str	r3, [r6, #0]
 8015686:	e046      	b.n	8015716 <_malloc_r+0xae>
 8015688:	f000 fbe4 	bl	8015e54 <__malloc_lock>
 801568c:	4b23      	ldr	r3, [pc, #140]	; (801571c <_malloc_r+0xb4>)
 801568e:	681c      	ldr	r4, [r3, #0]
 8015690:	461a      	mov	r2, r3
 8015692:	4621      	mov	r1, r4
 8015694:	b1a1      	cbz	r1, 80156c0 <_malloc_r+0x58>
 8015696:	680b      	ldr	r3, [r1, #0]
 8015698:	1b5b      	subs	r3, r3, r5
 801569a:	d40e      	bmi.n	80156ba <_malloc_r+0x52>
 801569c:	2b0b      	cmp	r3, #11
 801569e:	d903      	bls.n	80156a8 <_malloc_r+0x40>
 80156a0:	600b      	str	r3, [r1, #0]
 80156a2:	18cc      	adds	r4, r1, r3
 80156a4:	50cd      	str	r5, [r1, r3]
 80156a6:	e01e      	b.n	80156e6 <_malloc_r+0x7e>
 80156a8:	428c      	cmp	r4, r1
 80156aa:	bf0b      	itete	eq
 80156ac:	6863      	ldreq	r3, [r4, #4]
 80156ae:	684b      	ldrne	r3, [r1, #4]
 80156b0:	6013      	streq	r3, [r2, #0]
 80156b2:	6063      	strne	r3, [r4, #4]
 80156b4:	bf18      	it	ne
 80156b6:	460c      	movne	r4, r1
 80156b8:	e015      	b.n	80156e6 <_malloc_r+0x7e>
 80156ba:	460c      	mov	r4, r1
 80156bc:	6849      	ldr	r1, [r1, #4]
 80156be:	e7e9      	b.n	8015694 <_malloc_r+0x2c>
 80156c0:	4c17      	ldr	r4, [pc, #92]	; (8015720 <_malloc_r+0xb8>)
 80156c2:	6823      	ldr	r3, [r4, #0]
 80156c4:	b91b      	cbnz	r3, 80156ce <_malloc_r+0x66>
 80156c6:	4630      	mov	r0, r6
 80156c8:	f000 fb0c 	bl	8015ce4 <_sbrk_r>
 80156cc:	6020      	str	r0, [r4, #0]
 80156ce:	4629      	mov	r1, r5
 80156d0:	4630      	mov	r0, r6
 80156d2:	f000 fb07 	bl	8015ce4 <_sbrk_r>
 80156d6:	1c43      	adds	r3, r0, #1
 80156d8:	d018      	beq.n	801570c <_malloc_r+0xa4>
 80156da:	1cc4      	adds	r4, r0, #3
 80156dc:	f024 0403 	bic.w	r4, r4, #3
 80156e0:	42a0      	cmp	r0, r4
 80156e2:	d10d      	bne.n	8015700 <_malloc_r+0x98>
 80156e4:	6025      	str	r5, [r4, #0]
 80156e6:	4630      	mov	r0, r6
 80156e8:	f000 fbb5 	bl	8015e56 <__malloc_unlock>
 80156ec:	f104 000b 	add.w	r0, r4, #11
 80156f0:	1d23      	adds	r3, r4, #4
 80156f2:	f020 0007 	bic.w	r0, r0, #7
 80156f6:	1ac3      	subs	r3, r0, r3
 80156f8:	d00e      	beq.n	8015718 <_malloc_r+0xb0>
 80156fa:	425a      	negs	r2, r3
 80156fc:	50e2      	str	r2, [r4, r3]
 80156fe:	bd70      	pop	{r4, r5, r6, pc}
 8015700:	1a21      	subs	r1, r4, r0
 8015702:	4630      	mov	r0, r6
 8015704:	f000 faee 	bl	8015ce4 <_sbrk_r>
 8015708:	3001      	adds	r0, #1
 801570a:	d1eb      	bne.n	80156e4 <_malloc_r+0x7c>
 801570c:	230c      	movs	r3, #12
 801570e:	6033      	str	r3, [r6, #0]
 8015710:	4630      	mov	r0, r6
 8015712:	f000 fba0 	bl	8015e56 <__malloc_unlock>
 8015716:	2000      	movs	r0, #0
 8015718:	bd70      	pop	{r4, r5, r6, pc}
 801571a:	bf00      	nop
 801571c:	20004cf8 	.word	0x20004cf8
 8015720:	20004cf4 	.word	0x20004cf4

08015724 <__sfputc_r>:
 8015724:	6893      	ldr	r3, [r2, #8]
 8015726:	b410      	push	{r4}
 8015728:	3b01      	subs	r3, #1
 801572a:	2b00      	cmp	r3, #0
 801572c:	6093      	str	r3, [r2, #8]
 801572e:	da08      	bge.n	8015742 <__sfputc_r+0x1e>
 8015730:	6994      	ldr	r4, [r2, #24]
 8015732:	42a3      	cmp	r3, r4
 8015734:	db02      	blt.n	801573c <__sfputc_r+0x18>
 8015736:	b2cb      	uxtb	r3, r1
 8015738:	2b0a      	cmp	r3, #10
 801573a:	d102      	bne.n	8015742 <__sfputc_r+0x1e>
 801573c:	bc10      	pop	{r4}
 801573e:	f7ff bc9d 	b.w	801507c <__swbuf_r>
 8015742:	6813      	ldr	r3, [r2, #0]
 8015744:	1c58      	adds	r0, r3, #1
 8015746:	6010      	str	r0, [r2, #0]
 8015748:	7019      	strb	r1, [r3, #0]
 801574a:	b2c8      	uxtb	r0, r1
 801574c:	bc10      	pop	{r4}
 801574e:	4770      	bx	lr

08015750 <__sfputs_r>:
 8015750:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8015752:	4606      	mov	r6, r0
 8015754:	460f      	mov	r7, r1
 8015756:	4614      	mov	r4, r2
 8015758:	18d5      	adds	r5, r2, r3
 801575a:	42ac      	cmp	r4, r5
 801575c:	d008      	beq.n	8015770 <__sfputs_r+0x20>
 801575e:	463a      	mov	r2, r7
 8015760:	f814 1b01 	ldrb.w	r1, [r4], #1
 8015764:	4630      	mov	r0, r6
 8015766:	f7ff ffdd 	bl	8015724 <__sfputc_r>
 801576a:	1c43      	adds	r3, r0, #1
 801576c:	d1f5      	bne.n	801575a <__sfputs_r+0xa>
 801576e:	e000      	b.n	8015772 <__sfputs_r+0x22>
 8015770:	2000      	movs	r0, #0
 8015772:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08015774 <_vfiprintf_r>:
 8015774:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8015778:	b09d      	sub	sp, #116	; 0x74
 801577a:	460c      	mov	r4, r1
 801577c:	4617      	mov	r7, r2
 801577e:	9303      	str	r3, [sp, #12]
 8015780:	4606      	mov	r6, r0
 8015782:	b118      	cbz	r0, 801578c <_vfiprintf_r+0x18>
 8015784:	6983      	ldr	r3, [r0, #24]
 8015786:	b90b      	cbnz	r3, 801578c <_vfiprintf_r+0x18>
 8015788:	f7ff fe38 	bl	80153fc <__sinit>
 801578c:	4b7f      	ldr	r3, [pc, #508]	; (801598c <_vfiprintf_r+0x218>)
 801578e:	429c      	cmp	r4, r3
 8015790:	d101      	bne.n	8015796 <_vfiprintf_r+0x22>
 8015792:	6874      	ldr	r4, [r6, #4]
 8015794:	e008      	b.n	80157a8 <_vfiprintf_r+0x34>
 8015796:	4b7e      	ldr	r3, [pc, #504]	; (8015990 <_vfiprintf_r+0x21c>)
 8015798:	429c      	cmp	r4, r3
 801579a:	d101      	bne.n	80157a0 <_vfiprintf_r+0x2c>
 801579c:	68b4      	ldr	r4, [r6, #8]
 801579e:	e003      	b.n	80157a8 <_vfiprintf_r+0x34>
 80157a0:	4b7c      	ldr	r3, [pc, #496]	; (8015994 <_vfiprintf_r+0x220>)
 80157a2:	429c      	cmp	r4, r3
 80157a4:	bf08      	it	eq
 80157a6:	68f4      	ldreq	r4, [r6, #12]
 80157a8:	89a3      	ldrh	r3, [r4, #12]
 80157aa:	0718      	lsls	r0, r3, #28
 80157ac:	d50c      	bpl.n	80157c8 <_vfiprintf_r+0x54>
 80157ae:	6923      	ldr	r3, [r4, #16]
 80157b0:	b153      	cbz	r3, 80157c8 <_vfiprintf_r+0x54>
 80157b2:	2300      	movs	r3, #0
 80157b4:	9309      	str	r3, [sp, #36]	; 0x24
 80157b6:	2320      	movs	r3, #32
 80157b8:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 80157bc:	2330      	movs	r3, #48	; 0x30
 80157be:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 80157c2:	f8df b1d4 	ldr.w	fp, [pc, #468]	; 8015998 <_vfiprintf_r+0x224>
 80157c6:	e044      	b.n	8015852 <_vfiprintf_r+0xde>
 80157c8:	4621      	mov	r1, r4
 80157ca:	4630      	mov	r0, r6
 80157cc:	f7ff fcb8 	bl	8015140 <__swsetup_r>
 80157d0:	2800      	cmp	r0, #0
 80157d2:	d0ee      	beq.n	80157b2 <_vfiprintf_r+0x3e>
 80157d4:	f04f 30ff 	mov.w	r0, #4294967295
 80157d8:	e0d5      	b.n	8015986 <_vfiprintf_r+0x212>
 80157da:	9a03      	ldr	r2, [sp, #12]
 80157dc:	1d11      	adds	r1, r2, #4
 80157de:	6812      	ldr	r2, [r2, #0]
 80157e0:	9103      	str	r1, [sp, #12]
 80157e2:	2a00      	cmp	r2, #0
 80157e4:	f280 808c 	bge.w	8015900 <_vfiprintf_r+0x18c>
 80157e8:	4252      	negs	r2, r2
 80157ea:	f043 0002 	orr.w	r0, r3, #2
 80157ee:	9207      	str	r2, [sp, #28]
 80157f0:	9004      	str	r0, [sp, #16]
 80157f2:	f898 3000 	ldrb.w	r3, [r8]
 80157f6:	2b2e      	cmp	r3, #46	; 0x2e
 80157f8:	f000 8084 	beq.w	8015904 <_vfiprintf_r+0x190>
 80157fc:	2203      	movs	r2, #3
 80157fe:	f898 1000 	ldrb.w	r1, [r8]
 8015802:	4865      	ldr	r0, [pc, #404]	; (8015998 <_vfiprintf_r+0x224>)
 8015804:	f000 fb18 	bl	8015e38 <memchr>
 8015808:	b148      	cbz	r0, 801581e <_vfiprintf_r+0xaa>
 801580a:	2340      	movs	r3, #64	; 0x40
 801580c:	ebcb 0000 	rsb	r0, fp, r0
 8015810:	fa03 f000 	lsl.w	r0, r3, r0
 8015814:	9b04      	ldr	r3, [sp, #16]
 8015816:	f108 0801 	add.w	r8, r8, #1
 801581a:	4318      	orrs	r0, r3
 801581c:	9004      	str	r0, [sp, #16]
 801581e:	f898 1000 	ldrb.w	r1, [r8]
 8015822:	2206      	movs	r2, #6
 8015824:	485d      	ldr	r0, [pc, #372]	; (801599c <_vfiprintf_r+0x228>)
 8015826:	f108 0701 	add.w	r7, r8, #1
 801582a:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 801582e:	f000 fb03 	bl	8015e38 <memchr>
 8015832:	2800      	cmp	r0, #0
 8015834:	f000 8095 	beq.w	8015962 <_vfiprintf_r+0x1ee>
 8015838:	4b59      	ldr	r3, [pc, #356]	; (80159a0 <_vfiprintf_r+0x22c>)
 801583a:	2b00      	cmp	r3, #0
 801583c:	f040 8088 	bne.w	8015950 <_vfiprintf_r+0x1dc>
 8015840:	9b03      	ldr	r3, [sp, #12]
 8015842:	3307      	adds	r3, #7
 8015844:	f023 0307 	bic.w	r3, r3, #7
 8015848:	3308      	adds	r3, #8
 801584a:	9303      	str	r3, [sp, #12]
 801584c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801584e:	4453      	add	r3, sl
 8015850:	9309      	str	r3, [sp, #36]	; 0x24
 8015852:	46b8      	mov	r8, r7
 8015854:	4645      	mov	r5, r8
 8015856:	f815 3b01 	ldrb.w	r3, [r5], #1
 801585a:	b91b      	cbnz	r3, 8015864 <_vfiprintf_r+0xf0>
 801585c:	ebb8 0907 	subs.w	r9, r8, r7
 8015860:	d00f      	beq.n	8015882 <_vfiprintf_r+0x10e>
 8015862:	e003      	b.n	801586c <_vfiprintf_r+0xf8>
 8015864:	2b25      	cmp	r3, #37	; 0x25
 8015866:	d0f9      	beq.n	801585c <_vfiprintf_r+0xe8>
 8015868:	46a8      	mov	r8, r5
 801586a:	e7f3      	b.n	8015854 <_vfiprintf_r+0xe0>
 801586c:	464b      	mov	r3, r9
 801586e:	463a      	mov	r2, r7
 8015870:	4621      	mov	r1, r4
 8015872:	4630      	mov	r0, r6
 8015874:	f7ff ff6c 	bl	8015750 <__sfputs_r>
 8015878:	3001      	adds	r0, #1
 801587a:	d07f      	beq.n	801597c <_vfiprintf_r+0x208>
 801587c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801587e:	444b      	add	r3, r9
 8015880:	9309      	str	r3, [sp, #36]	; 0x24
 8015882:	f898 3000 	ldrb.w	r3, [r8]
 8015886:	2b00      	cmp	r3, #0
 8015888:	d078      	beq.n	801597c <_vfiprintf_r+0x208>
 801588a:	2300      	movs	r3, #0
 801588c:	f04f 32ff 	mov.w	r2, #4294967295
 8015890:	9304      	str	r3, [sp, #16]
 8015892:	9307      	str	r3, [sp, #28]
 8015894:	9205      	str	r2, [sp, #20]
 8015896:	9306      	str	r3, [sp, #24]
 8015898:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 801589c:	931a      	str	r3, [sp, #104]	; 0x68
 801589e:	2701      	movs	r7, #1
 80158a0:	2205      	movs	r2, #5
 80158a2:	7829      	ldrb	r1, [r5, #0]
 80158a4:	483f      	ldr	r0, [pc, #252]	; (80159a4 <_vfiprintf_r+0x230>)
 80158a6:	f000 fac7 	bl	8015e38 <memchr>
 80158aa:	f105 0801 	add.w	r8, r5, #1
 80158ae:	9b04      	ldr	r3, [sp, #16]
 80158b0:	b138      	cbz	r0, 80158c2 <_vfiprintf_r+0x14e>
 80158b2:	4a3c      	ldr	r2, [pc, #240]	; (80159a4 <_vfiprintf_r+0x230>)
 80158b4:	4645      	mov	r5, r8
 80158b6:	1a80      	subs	r0, r0, r2
 80158b8:	fa07 f000 	lsl.w	r0, r7, r0
 80158bc:	4318      	orrs	r0, r3
 80158be:	9004      	str	r0, [sp, #16]
 80158c0:	e7ee      	b.n	80158a0 <_vfiprintf_r+0x12c>
 80158c2:	06d9      	lsls	r1, r3, #27
 80158c4:	bf44      	itt	mi
 80158c6:	2220      	movmi	r2, #32
 80158c8:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 80158cc:	071a      	lsls	r2, r3, #28
 80158ce:	bf44      	itt	mi
 80158d0:	222b      	movmi	r2, #43	; 0x2b
 80158d2:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 80158d6:	782a      	ldrb	r2, [r5, #0]
 80158d8:	2a2a      	cmp	r2, #42	; 0x2a
 80158da:	f43f af7e 	beq.w	80157da <_vfiprintf_r+0x66>
 80158de:	9a07      	ldr	r2, [sp, #28]
 80158e0:	2100      	movs	r1, #0
 80158e2:	200a      	movs	r0, #10
 80158e4:	46a8      	mov	r8, r5
 80158e6:	f898 3000 	ldrb.w	r3, [r8]
 80158ea:	3501      	adds	r5, #1
 80158ec:	3b30      	subs	r3, #48	; 0x30
 80158ee:	2b09      	cmp	r3, #9
 80158f0:	d803      	bhi.n	80158fa <_vfiprintf_r+0x186>
 80158f2:	fb00 3202 	mla	r2, r0, r2, r3
 80158f6:	2101      	movs	r1, #1
 80158f8:	e7f4      	b.n	80158e4 <_vfiprintf_r+0x170>
 80158fa:	2900      	cmp	r1, #0
 80158fc:	f43f af79 	beq.w	80157f2 <_vfiprintf_r+0x7e>
 8015900:	9207      	str	r2, [sp, #28]
 8015902:	e776      	b.n	80157f2 <_vfiprintf_r+0x7e>
 8015904:	f898 3001 	ldrb.w	r3, [r8, #1]
 8015908:	2b2a      	cmp	r3, #42	; 0x2a
 801590a:	d10b      	bne.n	8015924 <_vfiprintf_r+0x1b0>
 801590c:	9b03      	ldr	r3, [sp, #12]
 801590e:	f108 0802 	add.w	r8, r8, #2
 8015912:	1d1a      	adds	r2, r3, #4
 8015914:	681b      	ldr	r3, [r3, #0]
 8015916:	9203      	str	r2, [sp, #12]
 8015918:	2b00      	cmp	r3, #0
 801591a:	bfb8      	it	lt
 801591c:	f04f 33ff 	movlt.w	r3, #4294967295
 8015920:	9305      	str	r3, [sp, #20]
 8015922:	e76b      	b.n	80157fc <_vfiprintf_r+0x88>
 8015924:	2300      	movs	r3, #0
 8015926:	4619      	mov	r1, r3
 8015928:	9305      	str	r3, [sp, #20]
 801592a:	f108 0001 	add.w	r0, r8, #1
 801592e:	250a      	movs	r5, #10
 8015930:	4680      	mov	r8, r0
 8015932:	f898 2000 	ldrb.w	r2, [r8]
 8015936:	3001      	adds	r0, #1
 8015938:	3a30      	subs	r2, #48	; 0x30
 801593a:	2a09      	cmp	r2, #9
 801593c:	d803      	bhi.n	8015946 <_vfiprintf_r+0x1d2>
 801593e:	fb05 2101 	mla	r1, r5, r1, r2
 8015942:	2301      	movs	r3, #1
 8015944:	e7f4      	b.n	8015930 <_vfiprintf_r+0x1bc>
 8015946:	2b00      	cmp	r3, #0
 8015948:	f43f af58 	beq.w	80157fc <_vfiprintf_r+0x88>
 801594c:	9105      	str	r1, [sp, #20]
 801594e:	e755      	b.n	80157fc <_vfiprintf_r+0x88>
 8015950:	ab03      	add	r3, sp, #12
 8015952:	9300      	str	r3, [sp, #0]
 8015954:	4622      	mov	r2, r4
 8015956:	4b14      	ldr	r3, [pc, #80]	; (80159a8 <_vfiprintf_r+0x234>)
 8015958:	a904      	add	r1, sp, #16
 801595a:	4630      	mov	r0, r6
 801595c:	f3af 8000 	nop.w
 8015960:	e007      	b.n	8015972 <_vfiprintf_r+0x1fe>
 8015962:	ab03      	add	r3, sp, #12
 8015964:	9300      	str	r3, [sp, #0]
 8015966:	4622      	mov	r2, r4
 8015968:	4b0f      	ldr	r3, [pc, #60]	; (80159a8 <_vfiprintf_r+0x234>)
 801596a:	a904      	add	r1, sp, #16
 801596c:	4630      	mov	r0, r6
 801596e:	f000 f893 	bl	8015a98 <_printf_i>
 8015972:	f1b0 3fff 	cmp.w	r0, #4294967295
 8015976:	4682      	mov	sl, r0
 8015978:	f47f af68 	bne.w	801584c <_vfiprintf_r+0xd8>
 801597c:	89a3      	ldrh	r3, [r4, #12]
 801597e:	065b      	lsls	r3, r3, #25
 8015980:	f53f af28 	bmi.w	80157d4 <_vfiprintf_r+0x60>
 8015984:	9809      	ldr	r0, [sp, #36]	; 0x24
 8015986:	b01d      	add	sp, #116	; 0x74
 8015988:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801598c:	080188c0 	.word	0x080188c0
 8015990:	080188e0 	.word	0x080188e0
 8015994:	08018900 	.word	0x08018900
 8015998:	08018926 	.word	0x08018926
 801599c:	0801892a 	.word	0x0801892a
 80159a0:	00000000 	.word	0x00000000
 80159a4:	08018920 	.word	0x08018920
 80159a8:	08015751 	.word	0x08015751

080159ac <_printf_common>:
 80159ac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80159b0:	4691      	mov	r9, r2
 80159b2:	461f      	mov	r7, r3
 80159b4:	690a      	ldr	r2, [r1, #16]
 80159b6:	688b      	ldr	r3, [r1, #8]
 80159b8:	4606      	mov	r6, r0
 80159ba:	4293      	cmp	r3, r2
 80159bc:	bfb8      	it	lt
 80159be:	4613      	movlt	r3, r2
 80159c0:	f8c9 3000 	str.w	r3, [r9]
 80159c4:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 80159c8:	460c      	mov	r4, r1
 80159ca:	f8dd 8020 	ldr.w	r8, [sp, #32]
 80159ce:	b112      	cbz	r2, 80159d6 <_printf_common+0x2a>
 80159d0:	3301      	adds	r3, #1
 80159d2:	f8c9 3000 	str.w	r3, [r9]
 80159d6:	6823      	ldr	r3, [r4, #0]
 80159d8:	0699      	lsls	r1, r3, #26
 80159da:	bf42      	ittt	mi
 80159dc:	f8d9 3000 	ldrmi.w	r3, [r9]
 80159e0:	3302      	addmi	r3, #2
 80159e2:	f8c9 3000 	strmi.w	r3, [r9]
 80159e6:	6825      	ldr	r5, [r4, #0]
 80159e8:	f015 0506 	ands.w	r5, r5, #6
 80159ec:	d110      	bne.n	8015a10 <_printf_common+0x64>
 80159ee:	f104 0a19 	add.w	sl, r4, #25
 80159f2:	e007      	b.n	8015a04 <_printf_common+0x58>
 80159f4:	2301      	movs	r3, #1
 80159f6:	4652      	mov	r2, sl
 80159f8:	4639      	mov	r1, r7
 80159fa:	4630      	mov	r0, r6
 80159fc:	47c0      	blx	r8
 80159fe:	3001      	adds	r0, #1
 8015a00:	d01a      	beq.n	8015a38 <_printf_common+0x8c>
 8015a02:	3501      	adds	r5, #1
 8015a04:	68e3      	ldr	r3, [r4, #12]
 8015a06:	f8d9 2000 	ldr.w	r2, [r9]
 8015a0a:	1a9b      	subs	r3, r3, r2
 8015a0c:	429d      	cmp	r5, r3
 8015a0e:	dbf1      	blt.n	80159f4 <_printf_common+0x48>
 8015a10:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
 8015a14:	6822      	ldr	r2, [r4, #0]
 8015a16:	3300      	adds	r3, #0
 8015a18:	bf18      	it	ne
 8015a1a:	2301      	movne	r3, #1
 8015a1c:	0692      	lsls	r2, r2, #26
 8015a1e:	d50f      	bpl.n	8015a40 <_printf_common+0x94>
 8015a20:	18e1      	adds	r1, r4, r3
 8015a22:	2030      	movs	r0, #48	; 0x30
 8015a24:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 8015a28:	1c5a      	adds	r2, r3, #1
 8015a2a:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 8015a2e:	4422      	add	r2, r4
 8015a30:	3302      	adds	r3, #2
 8015a32:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 8015a36:	e003      	b.n	8015a40 <_printf_common+0x94>
 8015a38:	f04f 30ff 	mov.w	r0, #4294967295
 8015a3c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8015a40:	f104 0243 	add.w	r2, r4, #67	; 0x43
 8015a44:	4639      	mov	r1, r7
 8015a46:	4630      	mov	r0, r6
 8015a48:	47c0      	blx	r8
 8015a4a:	3001      	adds	r0, #1
 8015a4c:	d0f4      	beq.n	8015a38 <_printf_common+0x8c>
 8015a4e:	6822      	ldr	r2, [r4, #0]
 8015a50:	f8d9 5000 	ldr.w	r5, [r9]
 8015a54:	68e3      	ldr	r3, [r4, #12]
 8015a56:	f002 0206 	and.w	r2, r2, #6
 8015a5a:	2a04      	cmp	r2, #4
 8015a5c:	bf08      	it	eq
 8015a5e:	1b5d      	subeq	r5, r3, r5
 8015a60:	6922      	ldr	r2, [r4, #16]
 8015a62:	68a3      	ldr	r3, [r4, #8]
 8015a64:	bf0c      	ite	eq
 8015a66:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 8015a6a:	2500      	movne	r5, #0
 8015a6c:	4293      	cmp	r3, r2
 8015a6e:	bfc4      	itt	gt
 8015a70:	1a9b      	subgt	r3, r3, r2
 8015a72:	18ed      	addgt	r5, r5, r3
 8015a74:	f04f 0900 	mov.w	r9, #0
 8015a78:	341a      	adds	r4, #26
 8015a7a:	454d      	cmp	r5, r9
 8015a7c:	d009      	beq.n	8015a92 <_printf_common+0xe6>
 8015a7e:	2301      	movs	r3, #1
 8015a80:	4622      	mov	r2, r4
 8015a82:	4639      	mov	r1, r7
 8015a84:	4630      	mov	r0, r6
 8015a86:	47c0      	blx	r8
 8015a88:	3001      	adds	r0, #1
 8015a8a:	d0d5      	beq.n	8015a38 <_printf_common+0x8c>
 8015a8c:	f109 0901 	add.w	r9, r9, #1
 8015a90:	e7f3      	b.n	8015a7a <_printf_common+0xce>
 8015a92:	2000      	movs	r0, #0
 8015a94:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

08015a98 <_printf_i>:
 8015a98:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8015a9c:	4617      	mov	r7, r2
 8015a9e:	7e0a      	ldrb	r2, [r1, #24]
 8015aa0:	b085      	sub	sp, #20
 8015aa2:	2a6e      	cmp	r2, #110	; 0x6e
 8015aa4:	4698      	mov	r8, r3
 8015aa6:	4606      	mov	r6, r0
 8015aa8:	460c      	mov	r4, r1
 8015aaa:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8015aac:	f101 0e43 	add.w	lr, r1, #67	; 0x43
 8015ab0:	f000 80ae 	beq.w	8015c10 <_printf_i+0x178>
 8015ab4:	d811      	bhi.n	8015ada <_printf_i+0x42>
 8015ab6:	2a63      	cmp	r2, #99	; 0x63
 8015ab8:	d022      	beq.n	8015b00 <_printf_i+0x68>
 8015aba:	d809      	bhi.n	8015ad0 <_printf_i+0x38>
 8015abc:	2a00      	cmp	r2, #0
 8015abe:	f000 80bb 	beq.w	8015c38 <_printf_i+0x1a0>
 8015ac2:	2a58      	cmp	r2, #88	; 0x58
 8015ac4:	f040 80ca 	bne.w	8015c5c <_printf_i+0x1c4>
 8015ac8:	f881 2045 	strb.w	r2, [r1, #69]	; 0x45
 8015acc:	4983      	ldr	r1, [pc, #524]	; (8015cdc <_printf_i+0x244>)
 8015ace:	e055      	b.n	8015b7c <_printf_i+0xe4>
 8015ad0:	2a64      	cmp	r2, #100	; 0x64
 8015ad2:	d01e      	beq.n	8015b12 <_printf_i+0x7a>
 8015ad4:	2a69      	cmp	r2, #105	; 0x69
 8015ad6:	d01c      	beq.n	8015b12 <_printf_i+0x7a>
 8015ad8:	e0c0      	b.n	8015c5c <_printf_i+0x1c4>
 8015ada:	2a73      	cmp	r2, #115	; 0x73
 8015adc:	f000 80b0 	beq.w	8015c40 <_printf_i+0x1a8>
 8015ae0:	d809      	bhi.n	8015af6 <_printf_i+0x5e>
 8015ae2:	2a6f      	cmp	r2, #111	; 0x6f
 8015ae4:	d02e      	beq.n	8015b44 <_printf_i+0xac>
 8015ae6:	2a70      	cmp	r2, #112	; 0x70
 8015ae8:	f040 80b8 	bne.w	8015c5c <_printf_i+0x1c4>
 8015aec:	680a      	ldr	r2, [r1, #0]
 8015aee:	f042 0220 	orr.w	r2, r2, #32
 8015af2:	600a      	str	r2, [r1, #0]
 8015af4:	e03e      	b.n	8015b74 <_printf_i+0xdc>
 8015af6:	2a75      	cmp	r2, #117	; 0x75
 8015af8:	d024      	beq.n	8015b44 <_printf_i+0xac>
 8015afa:	2a78      	cmp	r2, #120	; 0x78
 8015afc:	d03a      	beq.n	8015b74 <_printf_i+0xdc>
 8015afe:	e0ad      	b.n	8015c5c <_printf_i+0x1c4>
 8015b00:	681a      	ldr	r2, [r3, #0]
 8015b02:	f101 0542 	add.w	r5, r1, #66	; 0x42
 8015b06:	1d11      	adds	r1, r2, #4
 8015b08:	6019      	str	r1, [r3, #0]
 8015b0a:	6813      	ldr	r3, [r2, #0]
 8015b0c:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8015b10:	e0a8      	b.n	8015c64 <_printf_i+0x1cc>
 8015b12:	6821      	ldr	r1, [r4, #0]
 8015b14:	681a      	ldr	r2, [r3, #0]
 8015b16:	f011 0f80 	tst.w	r1, #128	; 0x80
 8015b1a:	d002      	beq.n	8015b22 <_printf_i+0x8a>
 8015b1c:	1d11      	adds	r1, r2, #4
 8015b1e:	6019      	str	r1, [r3, #0]
 8015b20:	e008      	b.n	8015b34 <_printf_i+0x9c>
 8015b22:	f011 0f40 	tst.w	r1, #64	; 0x40
 8015b26:	f102 0104 	add.w	r1, r2, #4
 8015b2a:	6019      	str	r1, [r3, #0]
 8015b2c:	d002      	beq.n	8015b34 <_printf_i+0x9c>
 8015b2e:	f9b2 3000 	ldrsh.w	r3, [r2]
 8015b32:	e000      	b.n	8015b36 <_printf_i+0x9e>
 8015b34:	6813      	ldr	r3, [r2, #0]
 8015b36:	2b00      	cmp	r3, #0
 8015b38:	da3c      	bge.n	8015bb4 <_printf_i+0x11c>
 8015b3a:	222d      	movs	r2, #45	; 0x2d
 8015b3c:	425b      	negs	r3, r3
 8015b3e:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
 8015b42:	e037      	b.n	8015bb4 <_printf_i+0x11c>
 8015b44:	6821      	ldr	r1, [r4, #0]
 8015b46:	681a      	ldr	r2, [r3, #0]
 8015b48:	f011 0f80 	tst.w	r1, #128	; 0x80
 8015b4c:	d002      	beq.n	8015b54 <_printf_i+0xbc>
 8015b4e:	1d11      	adds	r1, r2, #4
 8015b50:	6019      	str	r1, [r3, #0]
 8015b52:	e007      	b.n	8015b64 <_printf_i+0xcc>
 8015b54:	f011 0f40 	tst.w	r1, #64	; 0x40
 8015b58:	f102 0104 	add.w	r1, r2, #4
 8015b5c:	6019      	str	r1, [r3, #0]
 8015b5e:	d001      	beq.n	8015b64 <_printf_i+0xcc>
 8015b60:	8813      	ldrh	r3, [r2, #0]
 8015b62:	e000      	b.n	8015b66 <_printf_i+0xce>
 8015b64:	6813      	ldr	r3, [r2, #0]
 8015b66:	7e22      	ldrb	r2, [r4, #24]
 8015b68:	495c      	ldr	r1, [pc, #368]	; (8015cdc <_printf_i+0x244>)
 8015b6a:	2a6f      	cmp	r2, #111	; 0x6f
 8015b6c:	bf14      	ite	ne
 8015b6e:	220a      	movne	r2, #10
 8015b70:	2208      	moveq	r2, #8
 8015b72:	e01b      	b.n	8015bac <_printf_i+0x114>
 8015b74:	2278      	movs	r2, #120	; 0x78
 8015b76:	495a      	ldr	r1, [pc, #360]	; (8015ce0 <_printf_i+0x248>)
 8015b78:	f884 2045 	strb.w	r2, [r4, #69]	; 0x45
 8015b7c:	6822      	ldr	r2, [r4, #0]
 8015b7e:	6818      	ldr	r0, [r3, #0]
 8015b80:	f012 0f80 	tst.w	r2, #128	; 0x80
 8015b84:	f100 0504 	add.w	r5, r0, #4
 8015b88:	601d      	str	r5, [r3, #0]
 8015b8a:	d103      	bne.n	8015b94 <_printf_i+0xfc>
 8015b8c:	0655      	lsls	r5, r2, #25
 8015b8e:	d501      	bpl.n	8015b94 <_printf_i+0xfc>
 8015b90:	8803      	ldrh	r3, [r0, #0]
 8015b92:	e000      	b.n	8015b96 <_printf_i+0xfe>
 8015b94:	6803      	ldr	r3, [r0, #0]
 8015b96:	07d0      	lsls	r0, r2, #31
 8015b98:	bf44      	itt	mi
 8015b9a:	f042 0220 	orrmi.w	r2, r2, #32
 8015b9e:	6022      	strmi	r2, [r4, #0]
 8015ba0:	b91b      	cbnz	r3, 8015baa <_printf_i+0x112>
 8015ba2:	6822      	ldr	r2, [r4, #0]
 8015ba4:	f022 0220 	bic.w	r2, r2, #32
 8015ba8:	6022      	str	r2, [r4, #0]
 8015baa:	2210      	movs	r2, #16
 8015bac:	2000      	movs	r0, #0
 8015bae:	f884 0043 	strb.w	r0, [r4, #67]	; 0x43
 8015bb2:	e001      	b.n	8015bb8 <_printf_i+0x120>
 8015bb4:	4949      	ldr	r1, [pc, #292]	; (8015cdc <_printf_i+0x244>)
 8015bb6:	220a      	movs	r2, #10
 8015bb8:	6865      	ldr	r5, [r4, #4]
 8015bba:	2d00      	cmp	r5, #0
 8015bbc:	60a5      	str	r5, [r4, #8]
 8015bbe:	db08      	blt.n	8015bd2 <_printf_i+0x13a>
 8015bc0:	6820      	ldr	r0, [r4, #0]
 8015bc2:	f020 0004 	bic.w	r0, r0, #4
 8015bc6:	6020      	str	r0, [r4, #0]
 8015bc8:	b92b      	cbnz	r3, 8015bd6 <_printf_i+0x13e>
 8015bca:	2d00      	cmp	r5, #0
 8015bcc:	d17d      	bne.n	8015cca <_printf_i+0x232>
 8015bce:	4675      	mov	r5, lr
 8015bd0:	e00c      	b.n	8015bec <_printf_i+0x154>
 8015bd2:	2b00      	cmp	r3, #0
 8015bd4:	d079      	beq.n	8015cca <_printf_i+0x232>
 8015bd6:	4675      	mov	r5, lr
 8015bd8:	fbb3 f0f2 	udiv	r0, r3, r2
 8015bdc:	fb02 3310 	mls	r3, r2, r0, r3
 8015be0:	5ccb      	ldrb	r3, [r1, r3]
 8015be2:	f805 3d01 	strb.w	r3, [r5, #-1]!
 8015be6:	4603      	mov	r3, r0
 8015be8:	2800      	cmp	r0, #0
 8015bea:	d1f5      	bne.n	8015bd8 <_printf_i+0x140>
 8015bec:	2a08      	cmp	r2, #8
 8015bee:	d10b      	bne.n	8015c08 <_printf_i+0x170>
 8015bf0:	6823      	ldr	r3, [r4, #0]
 8015bf2:	07da      	lsls	r2, r3, #31
 8015bf4:	d508      	bpl.n	8015c08 <_printf_i+0x170>
 8015bf6:	6923      	ldr	r3, [r4, #16]
 8015bf8:	6862      	ldr	r2, [r4, #4]
 8015bfa:	429a      	cmp	r2, r3
 8015bfc:	bfde      	ittt	le
 8015bfe:	2330      	movle	r3, #48	; 0x30
 8015c00:	f805 3c01 	strble.w	r3, [r5, #-1]
 8015c04:	f105 35ff 	addle.w	r5, r5, #4294967295
 8015c08:	ebc5 030e 	rsb	r3, r5, lr
 8015c0c:	6123      	str	r3, [r4, #16]
 8015c0e:	e02e      	b.n	8015c6e <_printf_i+0x1d6>
 8015c10:	6808      	ldr	r0, [r1, #0]
 8015c12:	681a      	ldr	r2, [r3, #0]
 8015c14:	f010 0f80 	tst.w	r0, #128	; 0x80
 8015c18:	6949      	ldr	r1, [r1, #20]
 8015c1a:	d003      	beq.n	8015c24 <_printf_i+0x18c>
 8015c1c:	1d10      	adds	r0, r2, #4
 8015c1e:	6018      	str	r0, [r3, #0]
 8015c20:	6813      	ldr	r3, [r2, #0]
 8015c22:	e008      	b.n	8015c36 <_printf_i+0x19e>
 8015c24:	f010 0f40 	tst.w	r0, #64	; 0x40
 8015c28:	f102 0004 	add.w	r0, r2, #4
 8015c2c:	6018      	str	r0, [r3, #0]
 8015c2e:	6813      	ldr	r3, [r2, #0]
 8015c30:	d001      	beq.n	8015c36 <_printf_i+0x19e>
 8015c32:	8019      	strh	r1, [r3, #0]
 8015c34:	e000      	b.n	8015c38 <_printf_i+0x1a0>
 8015c36:	6019      	str	r1, [r3, #0]
 8015c38:	2300      	movs	r3, #0
 8015c3a:	6123      	str	r3, [r4, #16]
 8015c3c:	4675      	mov	r5, lr
 8015c3e:	e016      	b.n	8015c6e <_printf_i+0x1d6>
 8015c40:	681a      	ldr	r2, [r3, #0]
 8015c42:	1d11      	adds	r1, r2, #4
 8015c44:	6019      	str	r1, [r3, #0]
 8015c46:	6815      	ldr	r5, [r2, #0]
 8015c48:	2100      	movs	r1, #0
 8015c4a:	6862      	ldr	r2, [r4, #4]
 8015c4c:	4628      	mov	r0, r5
 8015c4e:	f000 f8f3 	bl	8015e38 <memchr>
 8015c52:	b108      	cbz	r0, 8015c58 <_printf_i+0x1c0>
 8015c54:	1b40      	subs	r0, r0, r5
 8015c56:	6060      	str	r0, [r4, #4]
 8015c58:	6863      	ldr	r3, [r4, #4]
 8015c5a:	e004      	b.n	8015c66 <_printf_i+0x1ce>
 8015c5c:	f104 0542 	add.w	r5, r4, #66	; 0x42
 8015c60:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
 8015c64:	2301      	movs	r3, #1
 8015c66:	6123      	str	r3, [r4, #16]
 8015c68:	2300      	movs	r3, #0
 8015c6a:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8015c6e:	f8cd 8000 	str.w	r8, [sp]
 8015c72:	463b      	mov	r3, r7
 8015c74:	aa03      	add	r2, sp, #12
 8015c76:	4621      	mov	r1, r4
 8015c78:	4630      	mov	r0, r6
 8015c7a:	f7ff fe97 	bl	80159ac <_printf_common>
 8015c7e:	3001      	adds	r0, #1
 8015c80:	d102      	bne.n	8015c88 <_printf_i+0x1f0>
 8015c82:	f04f 30ff 	mov.w	r0, #4294967295
 8015c86:	e026      	b.n	8015cd6 <_printf_i+0x23e>
 8015c88:	6923      	ldr	r3, [r4, #16]
 8015c8a:	462a      	mov	r2, r5
 8015c8c:	4639      	mov	r1, r7
 8015c8e:	4630      	mov	r0, r6
 8015c90:	47c0      	blx	r8
 8015c92:	3001      	adds	r0, #1
 8015c94:	d0f5      	beq.n	8015c82 <_printf_i+0x1ea>
 8015c96:	6823      	ldr	r3, [r4, #0]
 8015c98:	079b      	lsls	r3, r3, #30
 8015c9a:	d510      	bpl.n	8015cbe <_printf_i+0x226>
 8015c9c:	2500      	movs	r5, #0
 8015c9e:	f104 0919 	add.w	r9, r4, #25
 8015ca2:	e007      	b.n	8015cb4 <_printf_i+0x21c>
 8015ca4:	2301      	movs	r3, #1
 8015ca6:	464a      	mov	r2, r9
 8015ca8:	4639      	mov	r1, r7
 8015caa:	4630      	mov	r0, r6
 8015cac:	47c0      	blx	r8
 8015cae:	3001      	adds	r0, #1
 8015cb0:	d0e7      	beq.n	8015c82 <_printf_i+0x1ea>
 8015cb2:	3501      	adds	r5, #1
 8015cb4:	68e3      	ldr	r3, [r4, #12]
 8015cb6:	9a03      	ldr	r2, [sp, #12]
 8015cb8:	1a9b      	subs	r3, r3, r2
 8015cba:	429d      	cmp	r5, r3
 8015cbc:	dbf2      	blt.n	8015ca4 <_printf_i+0x20c>
 8015cbe:	68e0      	ldr	r0, [r4, #12]
 8015cc0:	9b03      	ldr	r3, [sp, #12]
 8015cc2:	4298      	cmp	r0, r3
 8015cc4:	bfb8      	it	lt
 8015cc6:	4618      	movlt	r0, r3
 8015cc8:	e005      	b.n	8015cd6 <_printf_i+0x23e>
 8015cca:	780b      	ldrb	r3, [r1, #0]
 8015ccc:	f104 0542 	add.w	r5, r4, #66	; 0x42
 8015cd0:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8015cd4:	e78a      	b.n	8015bec <_printf_i+0x154>
 8015cd6:	b005      	add	sp, #20
 8015cd8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8015cdc:	08018931 	.word	0x08018931
 8015ce0:	08018942 	.word	0x08018942

08015ce4 <_sbrk_r>:
 8015ce4:	b538      	push	{r3, r4, r5, lr}
 8015ce6:	4c06      	ldr	r4, [pc, #24]	; (8015d00 <_sbrk_r+0x1c>)
 8015ce8:	2300      	movs	r3, #0
 8015cea:	4605      	mov	r5, r0
 8015cec:	4608      	mov	r0, r1
 8015cee:	6023      	str	r3, [r4, #0]
 8015cf0:	f000 f8ec 	bl	8015ecc <_sbrk>
 8015cf4:	1c43      	adds	r3, r0, #1
 8015cf6:	d102      	bne.n	8015cfe <_sbrk_r+0x1a>
 8015cf8:	6823      	ldr	r3, [r4, #0]
 8015cfa:	b103      	cbz	r3, 8015cfe <_sbrk_r+0x1a>
 8015cfc:	602b      	str	r3, [r5, #0]
 8015cfe:	bd38      	pop	{r3, r4, r5, pc}
 8015d00:	20016ffc 	.word	0x20016ffc

08015d04 <__sread>:
 8015d04:	b510      	push	{r4, lr}
 8015d06:	460c      	mov	r4, r1
 8015d08:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8015d0c:	f000 f8a4 	bl	8015e58 <_read_r>
 8015d10:	2800      	cmp	r0, #0
 8015d12:	bfab      	itete	ge
 8015d14:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 8015d16:	89a3      	ldrhlt	r3, [r4, #12]
 8015d18:	181b      	addge	r3, r3, r0
 8015d1a:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 8015d1e:	bfac      	ite	ge
 8015d20:	6563      	strge	r3, [r4, #84]	; 0x54
 8015d22:	81a3      	strhlt	r3, [r4, #12]
 8015d24:	bd10      	pop	{r4, pc}

08015d26 <__swrite>:
 8015d26:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8015d2a:	461f      	mov	r7, r3
 8015d2c:	898b      	ldrh	r3, [r1, #12]
 8015d2e:	4605      	mov	r5, r0
 8015d30:	05db      	lsls	r3, r3, #23
 8015d32:	460c      	mov	r4, r1
 8015d34:	4616      	mov	r6, r2
 8015d36:	d505      	bpl.n	8015d44 <__swrite+0x1e>
 8015d38:	2302      	movs	r3, #2
 8015d3a:	2200      	movs	r2, #0
 8015d3c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8015d40:	f000 f868 	bl	8015e14 <_lseek_r>
 8015d44:	89a3      	ldrh	r3, [r4, #12]
 8015d46:	4632      	mov	r2, r6
 8015d48:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8015d4c:	81a3      	strh	r3, [r4, #12]
 8015d4e:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8015d52:	463b      	mov	r3, r7
 8015d54:	4628      	mov	r0, r5
 8015d56:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8015d5a:	f000 b817 	b.w	8015d8c <_write_r>

08015d5e <__sseek>:
 8015d5e:	b510      	push	{r4, lr}
 8015d60:	460c      	mov	r4, r1
 8015d62:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8015d66:	f000 f855 	bl	8015e14 <_lseek_r>
 8015d6a:	1c43      	adds	r3, r0, #1
 8015d6c:	89a3      	ldrh	r3, [r4, #12]
 8015d6e:	bf15      	itete	ne
 8015d70:	6560      	strne	r0, [r4, #84]	; 0x54
 8015d72:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 8015d76:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 8015d7a:	81a3      	strheq	r3, [r4, #12]
 8015d7c:	bf18      	it	ne
 8015d7e:	81a3      	strhne	r3, [r4, #12]
 8015d80:	bd10      	pop	{r4, pc}

08015d82 <__sclose>:
 8015d82:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8015d86:	f000 b813 	b.w	8015db0 <_close_r>
	...

08015d8c <_write_r>:
 8015d8c:	b538      	push	{r3, r4, r5, lr}
 8015d8e:	4c07      	ldr	r4, [pc, #28]	; (8015dac <_write_r+0x20>)
 8015d90:	4605      	mov	r5, r0
 8015d92:	4608      	mov	r0, r1
 8015d94:	4611      	mov	r1, r2
 8015d96:	2200      	movs	r2, #0
 8015d98:	6022      	str	r2, [r4, #0]
 8015d9a:	461a      	mov	r2, r3
 8015d9c:	f000 f8a4 	bl	8015ee8 <_write>
 8015da0:	1c43      	adds	r3, r0, #1
 8015da2:	d102      	bne.n	8015daa <_write_r+0x1e>
 8015da4:	6823      	ldr	r3, [r4, #0]
 8015da6:	b103      	cbz	r3, 8015daa <_write_r+0x1e>
 8015da8:	602b      	str	r3, [r5, #0]
 8015daa:	bd38      	pop	{r3, r4, r5, pc}
 8015dac:	20016ffc 	.word	0x20016ffc

08015db0 <_close_r>:
 8015db0:	b538      	push	{r3, r4, r5, lr}
 8015db2:	4c06      	ldr	r4, [pc, #24]	; (8015dcc <_close_r+0x1c>)
 8015db4:	2300      	movs	r3, #0
 8015db6:	4605      	mov	r5, r0
 8015db8:	4608      	mov	r0, r1
 8015dba:	6023      	str	r3, [r4, #0]
 8015dbc:	f000 f85e 	bl	8015e7c <_close>
 8015dc0:	1c43      	adds	r3, r0, #1
 8015dc2:	d102      	bne.n	8015dca <_close_r+0x1a>
 8015dc4:	6823      	ldr	r3, [r4, #0]
 8015dc6:	b103      	cbz	r3, 8015dca <_close_r+0x1a>
 8015dc8:	602b      	str	r3, [r5, #0]
 8015dca:	bd38      	pop	{r3, r4, r5, pc}
 8015dcc:	20016ffc 	.word	0x20016ffc

08015dd0 <_fstat_r>:
 8015dd0:	b538      	push	{r3, r4, r5, lr}
 8015dd2:	4c07      	ldr	r4, [pc, #28]	; (8015df0 <_fstat_r+0x20>)
 8015dd4:	2300      	movs	r3, #0
 8015dd6:	4605      	mov	r5, r0
 8015dd8:	4608      	mov	r0, r1
 8015dda:	4611      	mov	r1, r2
 8015ddc:	6023      	str	r3, [r4, #0]
 8015dde:	f000 f855 	bl	8015e8c <_fstat>
 8015de2:	1c43      	adds	r3, r0, #1
 8015de4:	d102      	bne.n	8015dec <_fstat_r+0x1c>
 8015de6:	6823      	ldr	r3, [r4, #0]
 8015de8:	b103      	cbz	r3, 8015dec <_fstat_r+0x1c>
 8015dea:	602b      	str	r3, [r5, #0]
 8015dec:	bd38      	pop	{r3, r4, r5, pc}
 8015dee:	bf00      	nop
 8015df0:	20016ffc 	.word	0x20016ffc

08015df4 <_isatty_r>:
 8015df4:	b538      	push	{r3, r4, r5, lr}
 8015df6:	4c06      	ldr	r4, [pc, #24]	; (8015e10 <_isatty_r+0x1c>)
 8015df8:	2300      	movs	r3, #0
 8015dfa:	4605      	mov	r5, r0
 8015dfc:	4608      	mov	r0, r1
 8015dfe:	6023      	str	r3, [r4, #0]
 8015e00:	f000 f84c 	bl	8015e9c <_isatty>
 8015e04:	1c43      	adds	r3, r0, #1
 8015e06:	d102      	bne.n	8015e0e <_isatty_r+0x1a>
 8015e08:	6823      	ldr	r3, [r4, #0]
 8015e0a:	b103      	cbz	r3, 8015e0e <_isatty_r+0x1a>
 8015e0c:	602b      	str	r3, [r5, #0]
 8015e0e:	bd38      	pop	{r3, r4, r5, pc}
 8015e10:	20016ffc 	.word	0x20016ffc

08015e14 <_lseek_r>:
 8015e14:	b538      	push	{r3, r4, r5, lr}
 8015e16:	4c07      	ldr	r4, [pc, #28]	; (8015e34 <_lseek_r+0x20>)
 8015e18:	4605      	mov	r5, r0
 8015e1a:	4608      	mov	r0, r1
 8015e1c:	4611      	mov	r1, r2
 8015e1e:	2200      	movs	r2, #0
 8015e20:	6022      	str	r2, [r4, #0]
 8015e22:	461a      	mov	r2, r3
 8015e24:	f000 f842 	bl	8015eac <_lseek>
 8015e28:	1c43      	adds	r3, r0, #1
 8015e2a:	d102      	bne.n	8015e32 <_lseek_r+0x1e>
 8015e2c:	6823      	ldr	r3, [r4, #0]
 8015e2e:	b103      	cbz	r3, 8015e32 <_lseek_r+0x1e>
 8015e30:	602b      	str	r3, [r5, #0]
 8015e32:	bd38      	pop	{r3, r4, r5, pc}
 8015e34:	20016ffc 	.word	0x20016ffc

08015e38 <memchr>:
 8015e38:	b510      	push	{r4, lr}
 8015e3a:	b2c9      	uxtb	r1, r1
 8015e3c:	4402      	add	r2, r0
 8015e3e:	4290      	cmp	r0, r2
 8015e40:	4603      	mov	r3, r0
 8015e42:	d005      	beq.n	8015e50 <memchr+0x18>
 8015e44:	781c      	ldrb	r4, [r3, #0]
 8015e46:	3001      	adds	r0, #1
 8015e48:	428c      	cmp	r4, r1
 8015e4a:	d1f8      	bne.n	8015e3e <memchr+0x6>
 8015e4c:	4618      	mov	r0, r3
 8015e4e:	bd10      	pop	{r4, pc}
 8015e50:	2000      	movs	r0, #0
 8015e52:	bd10      	pop	{r4, pc}

08015e54 <__malloc_lock>:
 8015e54:	4770      	bx	lr

08015e56 <__malloc_unlock>:
 8015e56:	4770      	bx	lr

08015e58 <_read_r>:
 8015e58:	b538      	push	{r3, r4, r5, lr}
 8015e5a:	4c07      	ldr	r4, [pc, #28]	; (8015e78 <_read_r+0x20>)
 8015e5c:	4605      	mov	r5, r0
 8015e5e:	4608      	mov	r0, r1
 8015e60:	4611      	mov	r1, r2
 8015e62:	2200      	movs	r2, #0
 8015e64:	6022      	str	r2, [r4, #0]
 8015e66:	461a      	mov	r2, r3
 8015e68:	f000 f828 	bl	8015ebc <_read>
 8015e6c:	1c43      	adds	r3, r0, #1
 8015e6e:	d102      	bne.n	8015e76 <_read_r+0x1e>
 8015e70:	6823      	ldr	r3, [r4, #0]
 8015e72:	b103      	cbz	r3, 8015e76 <_read_r+0x1e>
 8015e74:	602b      	str	r3, [r5, #0]
 8015e76:	bd38      	pop	{r3, r4, r5, pc}
 8015e78:	20016ffc 	.word	0x20016ffc

08015e7c <_close>:
 8015e7c:	4b02      	ldr	r3, [pc, #8]	; (8015e88 <_close+0xc>)
 8015e7e:	2258      	movs	r2, #88	; 0x58
 8015e80:	601a      	str	r2, [r3, #0]
 8015e82:	f04f 30ff 	mov.w	r0, #4294967295
 8015e86:	4770      	bx	lr
 8015e88:	20016ffc 	.word	0x20016ffc

08015e8c <_fstat>:
 8015e8c:	4b02      	ldr	r3, [pc, #8]	; (8015e98 <_fstat+0xc>)
 8015e8e:	2258      	movs	r2, #88	; 0x58
 8015e90:	601a      	str	r2, [r3, #0]
 8015e92:	f04f 30ff 	mov.w	r0, #4294967295
 8015e96:	4770      	bx	lr
 8015e98:	20016ffc 	.word	0x20016ffc

08015e9c <_isatty>:
 8015e9c:	4b02      	ldr	r3, [pc, #8]	; (8015ea8 <_isatty+0xc>)
 8015e9e:	2258      	movs	r2, #88	; 0x58
 8015ea0:	601a      	str	r2, [r3, #0]
 8015ea2:	2000      	movs	r0, #0
 8015ea4:	4770      	bx	lr
 8015ea6:	bf00      	nop
 8015ea8:	20016ffc 	.word	0x20016ffc

08015eac <_lseek>:
 8015eac:	4b02      	ldr	r3, [pc, #8]	; (8015eb8 <_lseek+0xc>)
 8015eae:	2258      	movs	r2, #88	; 0x58
 8015eb0:	601a      	str	r2, [r3, #0]
 8015eb2:	f04f 30ff 	mov.w	r0, #4294967295
 8015eb6:	4770      	bx	lr
 8015eb8:	20016ffc 	.word	0x20016ffc

08015ebc <_read>:
 8015ebc:	4b02      	ldr	r3, [pc, #8]	; (8015ec8 <_read+0xc>)
 8015ebe:	2258      	movs	r2, #88	; 0x58
 8015ec0:	601a      	str	r2, [r3, #0]
 8015ec2:	f04f 30ff 	mov.w	r0, #4294967295
 8015ec6:	4770      	bx	lr
 8015ec8:	20016ffc 	.word	0x20016ffc

08015ecc <_sbrk>:
 8015ecc:	4a04      	ldr	r2, [pc, #16]	; (8015ee0 <_sbrk+0x14>)
 8015ece:	4905      	ldr	r1, [pc, #20]	; (8015ee4 <_sbrk+0x18>)
 8015ed0:	6813      	ldr	r3, [r2, #0]
 8015ed2:	2b00      	cmp	r3, #0
 8015ed4:	bf08      	it	eq
 8015ed6:	460b      	moveq	r3, r1
 8015ed8:	4418      	add	r0, r3
 8015eda:	6010      	str	r0, [r2, #0]
 8015edc:	4618      	mov	r0, r3
 8015ede:	4770      	bx	lr
 8015ee0:	20004cfc 	.word	0x20004cfc
 8015ee4:	20017000 	.word	0x20017000

08015ee8 <_write>:
 8015ee8:	4b02      	ldr	r3, [pc, #8]	; (8015ef4 <_write+0xc>)
 8015eea:	2258      	movs	r2, #88	; 0x58
 8015eec:	601a      	str	r2, [r3, #0]
 8015eee:	f04f 30ff 	mov.w	r0, #4294967295
 8015ef2:	4770      	bx	lr
 8015ef4:	20016ffc 	.word	0x20016ffc

08015ef8 <CPU_CntLeadZerosTbl>:
 8015ef8:	06060708 05050505 04040404 04040404     ................
 8015f08:	03030303 03030303 03030303 03030303     ................
 8015f18:	02020202 02020202 02020202 02020202     ................
 8015f28:	02020202 02020202 02020202 02020202     ................
 8015f38:	01010101 01010101 01010101 01010101     ................
 8015f48:	01010101 01010101 01010101 01010101     ................
 8015f58:	01010101 01010101 01010101 01010101     ................
 8015f68:	01010101 01010101 01010101 01010101     ................
	...

08015ff8 <Str_MultOvfThTbl_Int32U>:
 8015ff8:	ffffffff ffffffff 7fffffff 55555555     ............UUUU
 8016008:	3fffffff 33333333 2aaaaaaa 24924924     ...?3333...*$I.$
 8016018:	1fffffff 1c71c71c 19999999 1745d174     ......q.....t.E.
 8016028:	15555555 13b13b13 12492492 11111111     UUU..;...$I.....
 8016038:	0fffffff 0f0f0f0f 0e38e38e 0d79435e     ..........8.^Cy.
 8016048:	0ccccccc 0c30c30c 0ba2e8ba 0b21642c     ......0.....,d!.
 8016058:	0aaaaaaa 0a3d70a3 09d89d89 097b425e     .....p=.....^B{.
 8016068:	09249249 08d3dcb0 08888888 08421084     I.$...........B.
 8016078:	07ffffff 07c1f07c 07878787 07507507     ....|........uP.
 8016088:	071c71c7                                .q..

0801608c <OSCfg_DataSizeRAM>:
 801608c:	00001020                                 ...

08016090 <OSCfg_TmrWheelSizeRAM>:
 8016090:	00000080                                ....

08016094 <OSCfg_TmrWheelSize>:
 8016094:	00000010                                ....

08016098 <OSCfg_TmrTaskStkSizeRAM>:
 8016098:	00000200                                ....

0801609c <OSCfg_TmrTaskStkSize>:
 801609c:	00000080                                ....

080160a0 <OSCfg_TmrTaskStkLimit>:
 80160a0:	0000000c                                ....

080160a4 <OSCfg_TmrTaskStkBasePtr>:
 80160a4:	2000dee8                                ... 

080160a8 <OSCfg_TmrTaskRate_Hz>:
 80160a8:	0000000a                                ....

080160ac <OSCfg_TmrTaskPrio>:
 80160ac:	0000003d                                =...

080160b0 <OSCfg_TickWheelSizeRAM>:
 80160b0:	00000080                                ....

080160b4 <OSCfg_TickWheelSize>:
 80160b4:	00000010                                ....

080160b8 <OSCfg_TickTaskStkSizeRAM>:
 80160b8:	00000200                                ....

080160bc <OSCfg_TickTaskStkSize>:
 80160bc:	00000080                                ....

080160c0 <OSCfg_TickTaskStkLimit>:
 80160c0:	0000000c                                ....

080160c4 <OSCfg_TickTaskStkBasePtr>:
 80160c4:	2000e568                                h.. 

080160c8 <OSCfg_TickTaskPrio>:
 80160c8:	00000001                                ....

080160cc <OSCfg_TickRate_Hz>:
 80160cc:	000003e8                                ....

080160d0 <OSCfg_StkSizeMin>:
 80160d0:	00000040                                @...

080160d4 <OSCfg_StatTaskStkSizeRAM>:
 80160d4:	00000200                                ....

080160d8 <OSCfg_StatTaskStkSize>:
 80160d8:	00000080                                ....

080160dc <OSCfg_StatTaskStkLimit>:
 80160dc:	0000000c                                ....

080160e0 <OSCfg_StatTaskStkBasePtr>:
 80160e0:	2000d948                                H.. 

080160e4 <OSCfg_StatTaskRate_Hz>:
 80160e4:	0000000a                                ....

080160e8 <OSCfg_StatTaskPrio>:
 80160e8:	0000003d                                =...

080160ec <OSCfg_MsgPoolBasePtr>:
 80160ec:	2000dbc8                                ... 

080160f0 <OSCfg_MsgPoolSizeRAM>:
 80160f0:	00000320                                 ...

080160f4 <OSCfg_MsgPoolSize>:
 80160f4:	00000032                                2...

080160f8 <OSCfg_ISRStkSizeRAM>:
 80160f8:	00000400                                ....

080160fc <OSCfg_ISRStkSize>:
 80160fc:	00000100                                ....

08016100 <OSCfg_ISRStkBasePtr>:
 8016100:	2000e168                                h.. 

08016104 <OSCfg_IntQTaskStkSizeRAM>:
 8016104:	00000000                                ....

08016108 <OSCfg_IntQTaskStkSize>:
 8016108:	00000000                                ....

0801610c <OSCfg_IntQTaskStkLimit>:
 801610c:	00000000                                ....

08016110 <OSCfg_IntQTaskStkBasePtr>:
 8016110:	00000000                                ....

08016114 <OSCfg_IntQSizeRAM>:
 8016114:	00000000                                ....

08016118 <OSCfg_IntQSize>:
 8016118:	00000000                                ....

0801611c <OSCfg_IntQBasePtr>:
 801611c:	00000000                                ....

08016120 <OSCfg_IdleTaskStkSizeRAM>:
 8016120:	00000200                                ....

08016124 <OSCfg_IdleTaskStkSize>:
 8016124:	00000080                                ....

08016128 <OSCfg_IdleTaskStkLimit>:
 8016128:	0000000c                                ....

0801612c <OSCfg_IdleTaskStkBasePtr>:
 801612c:	2000e768                                h.. 

08016130 <tcp_pcb_lists>:
 8016130:	2000f048 2000f050 2000f040 2000f054     H.. P.. @.. T.. 

08016140 <tcp_persist_backoff>:
 8016140:	180c0603 00786030                       ....0`x.

08016148 <tcp_backoff>:
 8016148:	04030201 07070605 07070707 00000007     ................

08016158 <tcp_state_str>:
 8016158:	080184e4 08018538 08016a38 08016a44     ....8...8j..Dj..
 8016168:	08016a50 08016a5c 08016a68 08016a74     Pj..\j..hj..tj..
 8016178:	08016a80 08016a88 08016a94              .j...j...j..

08016184 <erase_seq>:
 8016184:	00082008                                . ..

08016188 <tab_seq>:
 8016188:	20202020 20202020 00000000                      ....

08016194 <ethzero>:
	...

0801619c <ethbroadcast>:
 801619c:	ffffffff 0000ffff                       ........

080161a4 <ip_addr_broadcast>:
 80161a4:	ffffffff                                ....

080161a8 <ip_addr_any>:
 80161a8:	00000000                                ....

080161ac <memp_num>:
 80161ac:	00060004 0005000a 0005000c 00040002     ................
 80161bc:	00080008 000a001e 00140064              ........d...

080161c8 <memp_sizes>:
 80161c8:	0020001c 001c0094 00200010 00a80010     .. ....... .....
 80161d8:	00140014 00100008 02040010              ............

080161e4 <err_to_errno_table>:
 80161e4:	00000000 0000000c 00000069 0000000b     ........i.......
 80161f4:	00000071 00000073 00000016 0000000b     q...s...........
 8016204:	00000062 00000072 00000067 00000068     b...r...g...h...
 8016214:	0000006b 0000006b 00000005 ffffffff     k...k...........

08016224 <pvNullPointer>:
 8016224:	ffffffff 6b736154 65685320 00006c6c     ....Task Shell..
 8016234:	6b736154 61745320 00007472 6b736154     Task Start..Task
 8016244:	74615320 696c6c65 72546574 006b6361      SatelliteTrack.
 8016254:	6b736154 74615320 64617247 746e6569     Task SatGradient
 8016264:	63617254 0000006b 54202a2a 6d206f6f     Track...** Too m
 8016274:	20796e61 73677261 616d2820 25202e78     any args (max. %
 8016284:	2a202964 00000a2a 43202323 616d6d6f     d) **...## Comma
 8016294:	7420646e 6c206f6f 21676e6f 0000000a     nd too long!....
 80162a4:	69646e61 20746173 00000023 544e493c     andisat #...<INT
 80162b4:	55525245 0a3e5450 00000000 70257830     ERRUPT>.....0x%p
 80162c4:	25783020 0d783830 0000000a 72646461      0x%08x.....addr
 80162d4:	72615b20 2e2e2067 090a5d2e 73202d20      [arg ...].. - s
 80162e4:	74726174 70706120 6163696c 6e6f6974     tart application
 80162f4:	20746120 72646461 20737365 64646127      at address 'add
 8016304:	090a2772 70202020 69737361 2720676e     r'..   passing '
 8016314:	27677261 20736120 75677261 746e656d     arg' as argument
 8016324:	00000073 72617473 70612074 63696c70     s...start applic
 8016334:	6f697461 7461206e 64646120 73736572     ation at address
 8016344:	64612720 00277264 706c6568 00000000      'addr'.help....
 8016354:	202d090a 6e697270 72622074 20666569     ..- print brief 
 8016364:	63736564 74706972 206e6f69 6120666f     description of a
 8016374:	63206c6c 616d6d6f 0a73646e 706c6568     ll commands.help
 8016384:	6d6f6320 646e616d 2e2e2e20 202d090a      command .....- 
 8016394:	6e697270 65642074 6c696174 75206465     print detailed u
 80163a4:	65676173 20666f20 6d6f6327 646e616d     sage of 'command
 80163b4:	00000027 6e697270 6f632074 6e616d6d     '...print comman
 80163c4:	65642064 69726373 6f697470 73752f6e     d description/us
 80163d4:	00656761 0000003f 61696c61 6f662073     age.?...alias fo
 80163e4:	68272072 27706c65 00000000 0000006d     r 'help'....m...
 80163f4:	65736552 6e697474 68742067 6f622065     Resetting the bo
 8016404:	2e647261 000a2e2e 65736572 00000074     ard.....reset...
 8016414:	66726550 206d726f 45534552 666f2054     Perform RESET of
 8016424:	65687420 55504320 00000000 72655609      the CPU.....Ver
 8016434:	0000412e 64726148 65726177 72657620     .A..Hardware ver
 8016444:	6e6f6973 2520203a 000a0d73 302e3109     sion:  %s....1.0
 8016454:	302e302e 00000000 74666f53 65726177     .0.0....Software
 8016464:	72657620 6e6f6973 7325203a 00000a0d      version: %s....
 8016474:	343a3130 37323a31 00000000 20766f4e     01:41:27....Nov 
 8016484:	32203732 00383130 6c697562 69742064     27 2018.build ti
 8016494:	093a656d 20732509 0a0d7325 00000000     me:..%s %s......
 80164a4:	00726576 2d207325 0d732520 0000000a     ver.%s - %s.....
 80164b4:	67617355 0a0d3a65 00207325 6f4e202d     Usage:..%s .- No
 80164c4:	64646120 6f697469 206c616e 706c6568      additional help
 80164d4:	61766120 62616c69 0d2e656c 0000000a      available......
 80164e4:	732a2d25 7325202d 00000a0d 6e6b6e55     %-*s- %s....Unkn
 80164f4:	206e776f 6d6d6f63 20646e61 27732527     own command '%s'
 8016504:	74202d20 27207972 706c6568 69772027      - try 'help' wi
 8016514:	756f6874 72612074 656d7567 2073746e     thout arguments 
 8016524:	20726f66 7473696c 20666f20 206c6c61     for list of all 
 8016534:	776f6e6b 6f63206e 6e616d6d 0a0a7364     known commands..
 8016544:	00000000 00002020 6e6b6e55 206e776f     ....  ..Unknown 
 8016554:	6d6d6f63 20646e61 27732527 74202d20     command '%s' - t
 8016564:	27207972 706c6568 00000a27 6d6d6f43     ry 'help'...Comm
 8016574:	20646e61 27732527 69616620 3a64656c     and '%s' failed:
 8016584:	72724520 2520726f 00000a64 00000d79      Error %d...y...
 8016594:	00000d59 0d736579 00000000 0d534559     Y...yes.....YES.
 80165a4:	00000000 63616542 4d326e6f 53205543     ....Beacon2MCU S
 80165b4:	00006d65 46495753 41555f54 5f365452     em..SWIFT_UART6_
 80165c4:	646e6553 6d65535f 00000000 46495753     Send_Sem....SWIF
 80165d4:	48535f54 5f4c4c45 004d4553 2f637273     T_SHELL_SEM.src/
 80165e4:	65726f63 74656e2f 632e6669 00000000     core/netif.c....
 80165f4:	69206f4e 2074696e 636e7566 6e6f6974     No init function
 8016604:	76696720 00006e65 65737341 6f697472      given..Assertio
 8016614:	2522206e 66202273 656c6961 74612064     n "%s" failed at
 8016624:	6e696c20 64252065 206e6920 000a7325      line %d in %s..
 8016634:	4f2f4375 49492d53 64492049 5420656c     uC/OS-III Idle T
 8016644:	006b7361 6b736154 00005120 6b736154     ask.Task Q..Task
 8016654:	6d655320 00000000 414c463f 00000047      Sem....?FLAG...
 8016664:	54554d3f 00005845 0000513f 4d45533f     ?MUTEX..?Q..?SEM
 8016674:	00000000 4f2f4375 49492d53 74532049     ....uC/OS-III St
 8016684:	54207461 006b7361 7361543f 0000006b     at Task.?Task...
 8016694:	4f2f4375 49492d53 69542049 54206b63     uC/OS-III Tick T
 80166a4:	006b7361 524d543f 00000000 4f2f4375     ask.?TMR....uC/O
 80166b4:	49492d53 69542049 2072656d 6b736154     S-III Timer Task
 80166c4:	00000000 2f637273 65726f63 7063742f     ....src/core/tcp
 80166d4:	0000632e 5f706374 646e6962 6163203a     .c..tcp_bind: ca
 80166e4:	6e6f206e 6220796c 20646e69 73206e69     n only bind in s
 80166f4:	65746174 4f4c4320 00444553 5f706374     tate CLOSED.tcp_
 8016704:	7473696c 203a6e65 20626370 65726c61     listen: pcb alre
 8016714:	20796461 6e6e6f63 65746365 00000064     ady connected...
 8016724:	5f77656e 5f766372 5f6e6e61 20646e77     new_rcv_ann_wnd 
 8016734:	30203d3c 66666678 00000066 276e6f64     <= 0xffff...don'
 8016744:	61632074 74206c6c 725f7063 65766365     t call tcp_recve
 8016754:	6f662064 696c2072 6e657473 6263702d     d for listen-pcb
 8016764:	00000073 5f706374 76636572 203a6465     s...tcp_recved: 
 8016774:	206e656c 6c756f77 72772064 72207061     len would wrap r
 8016784:	775f7663 000a646e 5f706374 6e6e6f63     cv_wnd..tcp_conn
 8016794:	3a746365 6e616320 6c6e6f20 6f632079     ect: can only co
 80167a4:	63656e6e 72662074 73206d6f 65746174     nnect from state
 80167b4:	4f4c4320 00444553 5f706374 776f6c73      CLOSED.tcp_slow
 80167c4:	3a726d74 74636120 20657669 2d626370     tmr: active pcb-
 80167d4:	6174733e 21206574 4c43203d 4445534f     >state != CLOSED
 80167e4:	0000000a 5f706374 776f6c73 3a726d74     ....tcp_slowtmr:
 80167f4:	74636120 20657669 2d626370 6174733e      active pcb->sta
 8016804:	21206574 494c203d 4e455453 0000000a     te != LISTEN....
 8016814:	5f706374 776f6c73 3a726d74 74636120     tcp_slowtmr: act
 8016824:	20657669 2d626370 6174733e 21206574     ive pcb->state !
 8016834:	4954203d 572d454d 0a544941 00000000     = TIME-WAIT.....
 8016844:	5f706374 776f6c73 3a726d74 64696d20     tcp_slowtmr: mid
 8016854:	20656c64 20706374 74203d21 615f7063     dle tcp != tcp_a
 8016864:	76697463 63705f65 00007362 5f706374     ctive_pcbs..tcp_
 8016874:	776f6c73 3a726d74 72696620 70207473     slowtmr: first p
 8016884:	3d206263 6374203d 63615f70 65766974     cb == tcp_active
 8016894:	6263705f 00000073 5f706374 776f6c73     _pcbs...tcp_slow
 80168a4:	3a726d74 4d495420 41572d45 70205449     tmr: TIME-WAIT p
 80168b4:	3e2d6263 74617473 3d3d2065 4d495420     cb->state == TIM
 80168c4:	41572d45 00005449 5f706374 776f6c73     E-WAIT..tcp_slow
 80168d4:	3a726d74 64696d20 20656c64 20706374     tmr: middle tcp 
 80168e4:	74203d21 745f7063 63705f77 00007362     != tcp_tw_pcbs..
 80168f4:	5f706374 776f6c73 3a726d74 72696620     tcp_slowtmr: fir
 8016904:	70207473 3d206263 6374203d 77745f70     st pcb == tcp_tw
 8016914:	6263705f 00000073 61766e69 2064696c     _pcbs...invalid 
 8016924:	6b636f73 73207465 65746174 726f6620     socket state for
 8016934:	63657220 61632076 61626c6c 00006b63      recv callback..
 8016944:	61766e69 2064696c 6b636f73 73207465     invalid socket s
 8016954:	65746174 726f6620 6e657320 61632074     tate for sent ca
 8016964:	61626c6c 00006b63 61766e69 2064696c     llback..invalid 
 8016974:	6b636f73 73207465 65746174 726f6620     socket state for
 8016984:	72726520 6c616320 6361626c 0000006b      err callback...
 8016994:	61766e69 2064696c 6b636f73 73207465     invalid socket s
 80169a4:	65746174 726f6620 6c6f7020 0000006c     tate for poll...
 80169b4:	65736e75 7320746e 656d6765 2073746e     unsent segments 
 80169c4:	6b61656c 00676e69 63616e75 2064656b     leaking.unacked 
 80169d4:	6d676573 73746e65 61656c20 676e696b     segments leaking
 80169e4:	00000000 2d626370 616c663e 26207367     ....pcb->flags &
 80169f4:	5f465420 4c435852 4445534f 00000000      TF_RXCLOSED....
 8016a04:	276e6f64 61632074 74206c6c 615f7063     don't call tcp_a
 8016a14:	74726f62 7063742f 6162615f 6e6f646e     bort/tcp_abandon
 8016a24:	726f6620 73696c20 2d6e6574 73626370      for listen-pcbs
 8016a34:	00000000 5f4e5953 544e4553 00000000     ....SYN_SENT....
 8016a44:	5f4e5953 44564352 00000000 41545345     SYN_RCVD....ESTA
 8016a54:	53494c42 00444548 5f4e4946 54494157     BLISHED.FIN_WAIT
 8016a64:	0000315f 5f4e4946 54494157 0000325f     _1..FIN_WAIT_2..
 8016a74:	534f4c43 41575f45 00005449 534f4c43     CLOSE_WAIT..CLOS
 8016a84:	00474e49 5453414c 4b43415f 00000000     ING.LAST_ACK....
 8016a94:	454d4954 4941575f 00000054 2f637273     TIME_WAIT...src/
 8016aa4:	65726f63 7063742f 74756f5f 0000632e     core/tcp_out.c..
 8016ab4:	6465656e 636e7520 6e696168 70206465     need unchained p
 8016ac4:	00667562 63656863 6874206b 66207461     buf.check that f
 8016ad4:	74737269 75627020 61632066 6f68206e     irst pbuf can ho
 8016ae4:	7320646c 63757274 63742074 64685f70     ld struct tcp_hd
 8016af4:	00000072 5f706374 74697277 61203a65     r...tcp_write: a
 8016b04:	3d206772 554e203d 28204c4c 676f7270     rg == NULL (prog
 8016b14:	6d6d6172 76207265 616c6f69 20736574     rammer violates 
 8016b24:	29495041 00000000 5f706374 74697277     API)....tcp_writ
 8016b34:	70203a65 73667562 206e6f20 75657571     e: pbufs on queu
 8016b44:	3e3d2065 20746120 7361656c 6e6f2074     e => at least on
 8016b54:	75712065 20657565 2d6e6f6e 74706d65     e queue non-empt
 8016b64:	00000079 5f706374 74697277 6e203a65     y...tcp_write: n
 8016b74:	6270206f 20736675 71206e6f 65756575     o pbufs on queue
 8016b84:	203e3d20 68746f62 65757120 20736575      => both queues 
 8016b94:	74706d65 00000079 6f636e69 7369736e     empty...inconsis
 8016ba4:	646e6574 65766f20 7a697372 73762065     tend oversize vs
 8016bb4:	656c202e 0000006e 65736e75 6f5f746e     . len...unsent_o
 8016bc4:	73726576 20657a69 6d73696d 68637461     versize mismatch
 8016bd4:	63702820 753e2d62 6e65736e 73692074      (pcb->unsent is
 8016be4:	4c554e20 0000294c 5f706374 74697277      NULL)..tcp_writ
 8016bf4:	63203a65 6b636568 61687420 69662074     e: check that fi
 8016c04:	20747372 66756270 6e616320 6c6f6820     rst pbuf can hol
 8016c14:	68742064 6f632065 656c706d 73206574     d the complete s
 8016c24:	656c6765 0000006e 7265766f 657a6973     eglen...oversize
 8016c34:	203d3d20 00000030 76657270 6765735f      == 0...prev_seg
 8016c44:	203d2120 4c4c554e 00000000 5f706374      != NULL....tcp_
 8016c54:	74697277 63203a65 6f6e6e61 6f632074     write: cannot co
 8016c64:	7461636e 74616e65 68772065 70206e65     ncatenate when p
 8016c74:	3e2d6263 65736e75 6920746e 6d652073     cb->unsent is em
 8016c84:	00797470 5f706374 74697277 76203a65     pty.tcp_write: v
 8016c94:	64696c61 65757120 6c206575 74676e65     alid queue lengt
 8016ca4:	00000068 5f706374 75716e65 5f657565     h...tcp_enqueue_
 8016cb4:	67616c66 6e203a73 20646565 68746965     flags: need eith
 8016cc4:	54207265 535f5043 6f204e59 43542072     er TCP_SYN or TC
 8016cd4:	49465f50 6e69204e 616c6620 28207367     P_FIN in flags (
 8016ce4:	676f7270 6d6d6172 76207265 616c6f69     programmer viola
 8016cf4:	20736574 29495041 00000000 5f706374     tes API)....tcp_
 8016d04:	75716e65 5f657565 67616c66 63203a73     enqueue_flags: c
 8016d14:	6b636568 61687420 69662074 20747372     heck that first 
 8016d24:	66756270 6e616320 6c6f6820 706f2064     pbuf can hold op
 8016d34:	6e656c74 00000000 2d676573 7063743e     tlen....seg->tcp
 8016d44:	20726468 20746f6e 67696c61 0064656e     hdr not aligned.
 8016d54:	5f706374 75716e65 5f657565 67616c66     tcp_enqueue_flag
 8016d64:	69203a73 6c61766e 73206469 656d6765     s: invalid segme
 8016d74:	6c20746e 74676e65 00000068 5f706374     nt length...tcp_
 8016d84:	75716e65 5f657565 67616c66 69203a73     enqueue_flags: i
 8016d94:	6c61766e 71206469 65756575 6e656c20     nvalid queue len
 8016da4:	00687467 276e6f64 61632074 74206c6c     gth.don't call t
 8016db4:	6f5f7063 75707475 6f662074 696c2072     cp_output for li
 8016dc4:	6e657473 6263702d 00000073 20545352     sten-pcbs...RST 
 8016dd4:	20746f6e 65707865 64657463 72656820     not expected her
 8016de4:	00002165 2f637273 2f697061 69706374     e!..src/api/tcpi
 8016df4:	00632e70 69706374 68745f70 64616572     p.c.tcpip_thread
 8016e04:	6e69203a 696c6176 656d2064 67617373     : invalid messag
 8016e14:	00000065 6c696166 74206465 7263206f     e...failed to cr
 8016e24:	65746165 70637420 745f7069 61657268     eate tcpip_threa
 8016e34:	626d2064 0000786f 69706374 68745f70     d mbox..tcpip_th
 8016e44:	64616572 00000000 2f637273 65726f63     read....src/core
 8016e54:	6d69742f 2e737265 00000063 5f737973     /timers.c...sys_
 8016e64:	656d6974 3a74756f 6d697420 74756f65     timeout: timeout
 8016e74:	203d2120 4c4c554e 6f70202c 4d206c6f      != NULL, pool M
 8016e84:	5f504d45 5f535953 454d4954 2054554f     EMP_SYS_TIMEOUT 
 8016e94:	65207369 7974706d 00000000 206e6163     is empty....can 
 8016ea4:	20746f6e 646e6962 74656e20 6e6e6f63     not bind netconn
 8016eb4:	00000000 206e6163 61657263 6e206574     ....can create n
 8016ec4:	55207765 6e205044 6f637465 00006e6e     ew UDP netconn..
 8016ed4:	65706475 5f6f6863 65726874 00006461     udpecho_thread..
 8016ee4:	2f637273 2f697061 5f697061 2e62696c     src/api/api_lib.
 8016ef4:	00000063 6374656e 5f6e6e6f 76636572     c...netconn_recv
 8016f04:	6e69203a 696c6176 6f702064 65746e69     : invalid pointe
 8016f14:	00000072 6374656e 5f6e6e6f 76636572     r...netconn_recv
 8016f24:	6e69203a 696c6176 6f632064 00006e6e     : invalid conn..
 8016f34:	6374656e 5f6e6e6f 65636361 203a7470     netconn_accept: 
 8016f44:	61766e69 2064696c 76636572 786f626d     invalid recvmbox
 8016f54:	00000000 20667562 4e203d21 004c4c55     ....buf != NULL.
 8016f64:	6374656e 5f6e6e6f 736f6c63 69203a65     netconn_close: i
 8016f74:	6c61766e 63206469 006e6e6f 65657266     nvalid conn.free
 8016f84:	20676e69 6e6e6f63 74697720 74756f68     ing conn without
 8016f94:	65726620 676e6965 62637020 00000000      freeing pcb....
 8016fa4:	6e6e6f63 73616820 206f6e20 635f706f     conn has no op_c
 8016fb4:	6c706d6f 64657465 00000000 6e6e6f63     ompleted....conn
 8016fc4:	73616820 206f6e20 76636572 786f626d      has no recvmbox
 8016fd4:	00000000 6e6e6f63 63613e2d 74706563     ....conn->accept
 8016fe4:	786f626d 6f687320 6e646c75 65207427     mbox shouldn't e
 8016ff4:	74736978 00000000 6374656e 5f6e6e6f     xist....netconn_
 8017004:	61746567 3a726464 766e6920 64696c61     getaddr: invalid
 8017014:	6e6f6320 0000006e 6374656e 5f6e6e6f      conn...netconn_
 8017024:	61746567 3a726464 766e6920 64696c61     getaddr: invalid
 8017034:	64646120 00000072 6374656e 5f6e6e6f      addr...netconn_
 8017044:	61746567 3a726464 766e6920 64696c61     getaddr: invalid
 8017054:	726f7020 00000074 6374656e 5f6e6e6f      port...netconn_
 8017064:	646e6962 6e69203a 696c6176 6f632064     bind: invalid co
 8017074:	00006e6e 6374656e 5f6e6e6f 6e6e6f63     nn..netconn_conn
 8017084:	3a746365 766e6920 64696c61 6e6f6320     ect: invalid con
 8017094:	0000006e 6374656e 5f6e6e6f 63736964     n...netconn_disc
 80170a4:	656e6e6f 203a7463 61766e69 2064696c     onnect: invalid 
 80170b4:	6e6e6f63 00000000 6374656e 5f6e6e6f     conn....netconn_
 80170c4:	7473696c 203a6e65 61766e69 2064696c     listen: invalid 
 80170d4:	6e6e6f63 00000000 6374656e 5f6e6e6f     conn....netconn_
 80170e4:	65636361 203a7470 61766e69 2064696c     accept: invalid 
 80170f4:	6e696f70 00726574 6374656e 5f6e6e6f     pointer.netconn_
 8017104:	65636361 203a7470 61766e69 2064696c     accept: invalid 
 8017114:	6e6e6f63 00000000 6374656e 5f6e6e6f     conn....netconn_
 8017124:	65636361 203a7470 61766e69 2064696c     accept: invalid 
 8017134:	65636361 626d7470 0000786f 6374656e     acceptmbox..netc
 8017144:	5f6e6e6f 646e6573 6e69203a 696c6176     onn_send: invali
 8017154:	6f632064 00006e6e 6374656e 5f6e6e6f     d conn..netconn_
 8017164:	74697277 69203a65 6c61766e 63206469     write: invalid c
 8017174:	006e6e6f 6374656e 5f6e6e6f 74697277     onn.netconn_writ
 8017184:	69203a65 6c61766e 63206469 2d6e6e6f     e: invalid conn-
 8017194:	7079743e 00000065 2f637273 2f697061     >type...src/api/
 80171a4:	5f697061 2e67736d 00000063 76636572     api_msg.c...recv
 80171b4:	7064755f 73756d20 61682074 61206576     _udp must have a
 80171c4:	62637020 67726120 6e656d75 00000074      pcb argument...
 80171d4:	76636572 7064755f 73756d20 61682074     recv_udp must ha
 80171e4:	61206576 7261206e 656d7567 0000746e     ve an argument..
 80171f4:	76636572 7064755f 6572203a 66207663     recv_udp: recv f
 8017204:	7720726f 676e6f72 62637020 00000021     or wrong pcb!...
 8017214:	6e6e6f63 203d2120 4c4c554e 00000000     conn != NULL....
 8017224:	6e6e6f63 75633e2d 6e657272 736d5f74     conn->current_ms
 8017234:	3d212067 4c554e20 0000004c 6e6e6f63     g != NULL...conn
 8017244:	75633e2d 6e657272 736d5f74 3d3d2067     ->current_msg ==
 8017254:	4c554e20 0000004c 6e6e6f63 74733e2d      NULL...conn->st
 8017264:	20657461 4e203d3d 4f435445 435f4e4e     ate == NETCONN_C
 8017274:	454e4e4f 00005443 6e6f6328 633e2d6e     ONNECT..(conn->c
 8017284:	65727275 6d5f746e 21206773 554e203d     urrent_msg != NU
 8017294:	20294c4c 63207c7c 2d6e6e6f 5f6e693e     LL) || conn->in_
 80172a4:	5f6e6f6e 636f6c62 676e696b 6e6f635f     non_blocking_con
 80172b4:	7463656e 00000000 6e6e6f63 74733e2d     nect....conn->st
 80172c4:	20657461 4e203d3d 4f435445 575f4e4e     ate == NETCONN_W
 80172d4:	45544952 00000000 6e6e6f63 63703e2d     RITE....conn->pc
 80172e4:	63742e62 3d212070 4c554e20 0000004c     b.tcp != NULL...
 80172f4:	6e6e6f63 72773e2d 5f657469 7366666f     conn->write_offs
 8017304:	3c207465 6e6f6320 633e2d6e 65727275     et < conn->curre
 8017314:	6d5f746e 3e2d6773 2e67736d 656c2e77     nt_msg->msg.w.le
 8017324:	0000006e 775f6f64 65746972 65726f6d     n...do_writemore
 8017334:	6e69203a 696c6176 656c2064 6874676e     : invalid length
 8017344:	00000021 73696874 20736920 20726f66     !...this is for 
 8017354:	20706374 6374656e 736e6e6f 6c6e6f20     tcp netconns onl
 8017364:	00000079 6e6e6f63 73756d20 65622074     y...conn must be
 8017374:	206e6920 74617473 454e2065 4e4f4354      in state NETCON
 8017384:	4c435f4e 0045534f 20626370 65726c61     N_CLOSE.pcb alre
 8017394:	20796461 736f6c63 00006465 736f6c43     ady closed..Clos
 80173a4:	20676e69 696c2061 6e657473 62637020     ing a listen pcb
 80173b4:	79616d20 746f6e20 69616620 0000216c      may not fail!..
 80173c4:	76636572 7063745f 73756d20 61682074     recv_tcp must ha
 80173d4:	61206576 62637020 67726120 6e656d75     ve a pcb argumen
 80173e4:	00000074 76636572 7063745f 73756d20     t...recv_tcp mus
 80173f4:	61682074 61206576 7261206e 656d7567     t have an argume
 8017404:	0000746e 76636572 7063745f 6572203a     nt..recv_tcp: re
 8017414:	66207663 7720726f 676e6f72 62637020     cv for wrong pcb
 8017424:	00000021 20424350 7473756d 20656220     !...PCB must be 
 8017434:	6c616564 61636f6c 20646574 7374756f     deallocated outs
 8017444:	20656469 73696874 6e756620 6f697463     ide this functio
 8017454:	0000006e 76636572 786f626d 73756d20     n...recvmbox mus
 8017464:	65622074 61656420 636f6c6c 64657461     t be deallocated
 8017474:	66656220 2065726f 6c6c6163 20676e69      before calling 
 8017484:	73696874 6e756620 6f697463 0000006e     this function...
 8017494:	65636361 626d7470 6d20786f 20747375     acceptmbox must 
 80174a4:	64206562 6c6c6165 7461636f 62206465     be deallocated b
 80174b4:	726f6665 61632065 6e696c6c 68742067     efore calling th
 80174c4:	66207369 74636e75 006e6f69 2d626370     is function.pcb-
 80174d4:	6174733e 3d206574 494c203d 4e455453     >state == LISTEN
 80174e4:	61632820 64656c6c 726f6620 6f727720      (called for wro
 80174f4:	7020676e 293f6263 00000000 2d67736d     ng pcb?)....msg-
 8017504:	6e6f633e 743e2d6e 20657079 4e203d3d     >conn->type == N
 8017514:	4f435445 545f4e4e 00005043 636f6c62     ETCONN_TCP..bloc
 8017524:	676e696b 6e6f6320 7463656e 206e6920     king connect in 
 8017534:	676f7270 73736572 00000000 65726c61     progress....alre
 8017544:	20796461 74697277 20676e69 6320726f     ady writing or c
 8017554:	69736f6c 0000676e 61766e49 2064696c     losing..Invalid 
 8017564:	6374656e 206e6e6f 65707974 00000000     netconn type....
 8017574:	2d67736d 67736d3e 6c2e772e 21206e65     msg->msg.w.len !
 8017584:	0030203d 61766e69 2064696c 6374656e     = 0.invalid netc
 8017594:	5f6e6e6f 65707974 00000000 2f637273     onn_type....src/
 80175a4:	6974656e 74652f66 70726168 0000632e     netif/etharp.c..
 80175b4:	3d212071 4c554e20 0000004c 703e2d71     q != NULL...q->p
 80175c4:	203d2120 4c4c554e 00000000 703e2d72      != NULL....r->p
 80175d4:	203d2120 4c4c554e 00000000 5f707261      != NULL....arp_
 80175e4:	6c626174 5d695b65 3d20712e 554e203d     table[i].q == NU
 80175f4:	00004c4c 203c2069 5f505241 4c424154     LL..i < ARP_TABL
 8017604:	49535f45 0000455a 5f707261 6c626174     E_SIZE..arp_tabl
 8017614:	5d695b65 6174732e 3d206574 5445203d     e[i].state == ET
 8017624:	50524148 4154535f 455f4554 5954504d     HARP_STATE_EMPTY
 8017634:	00000000 6974656e 683e2d66 64646177     ....netif->hwadd
 8017644:	656c5f72 756d206e 62207473 68742065     r_len must be th
 8017654:	61732065 6120656d 54452073 50524148     e same as ETHARP
 8017664:	4157485f 5f524444 204e454c 20726f66     _HWADDR_LEN for 
 8017674:	61687465 00217072 6974656e 683e2d66     etharp!.netif->h
 8017684:	64646177 656c5f72 3d3d206e 48544520     waddr_len == ETH
 8017694:	5f505241 44415748 4c5f5244 00004e45     ARP_HWADDR_LEN..
 80176a4:	6974656e 3d212066 4c554e20 0000004c     netif != NULL...
 80176b4:	63656863 6874206b 66207461 74737269     check that first
 80176c4:	75627020 61632066 6f68206e 7320646c      pbuf can hold s
 80176d4:	63757274 74652074 70726168 7264685f     truct etharp_hdr
 80176e4:	00000000 5f707261 6c626174 72615b65     ....arp_table[ar
 80176f4:	64695f70 732e5d78 65746174 203d3e20     p_idx].state >= 
 8017704:	41485445 535f5052 45544154 4154535f     ETHARP_STATE_STA
 8017714:	00454c42 5f687465 20746572 4e203d21     BLE.eth_ret != N
 8017724:	204c4c55 69202626 65725f70 3d212074     ULL && ip_ret !=
 8017734:	4c554e20 0000004c 70206f6e 656b6361      NULL...no packe
 8017744:	75712074 73657565 6c6c6120 6465776f     t queues allowed
 8017754:	00000021 64617069 21207264 554e203d     !...ipaddr != NU
 8017764:	00004c4c 276e6143 6f6d2074 6f206576     LL..Can't move o
 8017774:	20726576 64616568 69207265 6170206e     ver header in pa
 8017784:	74656b63 00000000 2f637273 6974656e     cket....src/neti
 8017794:	74652f66 6e726568 66697465 0000632e     f/ethernetif.c..
 80177a4:	2f637273 65726f63 7670692f 6e692f34     src/core/ipv4/in
 80177b4:	635f7465 75736b68 00632e6d 656c6564     et_chksum.c.dele
 80177c4:	6d206574 00000065 2f637273 65726f63     te me...src/core
 80177d4:	7670692f 70692f34 0000632e 723e2d70     /ipv4/ip.c..p->r
 80177e4:	3d206665 0031203d 63656863 6874206b     ef == 1.check th
 80177f4:	66207461 74737269 75627020 61632066     at first pbuf ca
 8017804:	6f68206e 7320646c 63757274 70692074     n hold struct ip
 8017814:	7264685f 00000000 2f637273 65726f63     _hdr....src/core
 8017824:	7670692f 70692f34 6464615f 00632e72     /ipv4/ip_addr.c.
 8017834:	61686e75 656c646e 00000064 2f637273     unhandled...src/
 8017844:	65726f63 7670692f 70692f34 6172665f     core/ipv4/ip_fra
 8017854:	00632e67 696e6173 63207974 6b636568     g.c.sanity check
 8017864:	6e696c20 2064656b 7473696c 00000000      linked list....
 8017874:	76657270 203d2120 00727069 76657270     prev != ipr.prev
 8017884:	656e3e2d 3d207478 7069203d 00000072     ->next == ipr...
 8017894:	66756270 72665f73 20646565 6c63202b     pbufs_freed + cl
 80178a4:	3c206e65 7830203d 66666666 00000000     en <= 0xffff....
 80178b4:	725f7069 73736165 7562705f 756f6366     ip_reass_pbufcou
 80178c4:	3e20746e 6c63203d 00006e65 63656863     nt >= clen..chec
 80178d4:	7266206b 656d6761 2073746e 276e6f64     k fragments don'
 80178e4:	766f2074 616c7265 00000070 696e6173     t overlap...sani
 80178f4:	63207974 6b636568 00000000 696c6176     ty check....vali
 8017904:	65746164 7461645f 61726761 656e3a6d     date_datagram:ne
 8017914:	705f7478 21667562 4c554e3d 0000004c     xt_pbuf!=NULL...
 8017924:	696c6176 65746164 7461645f 61726761     validate_datagra
 8017934:	61643a6d 72676174 65206d61 3d21646e     m:datagram end!=
 8017944:	61746164 6d617267 6e656c20 00000000     datagram len....
 8017954:	2f637273 65726f63 6d656d2f 0000632e     src/core/mem.c..
 8017964:	6c696166 74206465 7263206f 65746165     failed to create
 8017974:	6d656d20 74756d5f 00007865 5f6d656d      mem_mutex..mem_
 8017984:	65657266 6173203a 7974696e 65686320     free: sanity che
 8017994:	61206b63 6e67696c 746e656d 00000000     ck alignment....
 80179a4:	5f6d656d 65657266 656c203a 206c6167     mem_free: legal 
 80179b4:	6f6d656d 00007972 5f6d656d 65657266     memory..mem_free
 80179c4:	656d203a 753e2d6d 00646573 67756c70     : mem->used.plug
 80179d4:	6c6f685f 203a7365 206d656d 72203d3e     _holes: mem >= r
 80179e4:	00006d61 67756c70 6c6f685f 203a7365     am..plug_holes: 
 80179f4:	206d656d 6172203c 6e655f6d 00000064     mem < ram_end...
 8017a04:	67756c70 6c6f685f 203a7365 2d6d656d     plug_holes: mem-
 8017a14:	6573753e 3d3d2064 00003020 67756c70     >used == 0..plug
 8017a24:	6c6f685f 203a7365 2d6d656d 78656e3e     _holes: mem->nex
 8017a34:	3d3c2074 4d454d20 5a49535f 4c415f45     t <= MEM_SIZE_AL
 8017a44:	454e4749 00000044 5f6d656d 6d697274     IGNED...mem_trim
 8017a54:	656c203a 206c6167 6f6d656d 00007972     : legal memory..
 8017a64:	5f6d656d 6d697274 6e616320 6c6e6f20     mem_trim can onl
 8017a74:	68732079 6b6e6972 6d656d20 0079726f     y shrink memory.
 8017a84:	5f6d656d 6c6c616d 203a636f 6f6c6c61     mem_malloc: allo
 8017a94:	65746163 656d2064 79726f6d 746f6e20     cated memory not
 8017aa4:	6f626120 72206576 655f6d61 002e646e      above ram_end..
 8017ab4:	5f6d656d 6c6c616d 203a636f 6f6c6c61     mem_malloc: allo
 8017ac4:	65746163 656d2064 79726f6d 6f727020     cated memory pro
 8017ad4:	6c726570 6c612079 656e6769 00002e64     perly aligned...
 8017ae4:	5f6d656d 6c6c616d 203a636f 696e6173     mem_malloc: sani
 8017af4:	63207974 6b636568 696c6120 656d6e67     ty check alignme
 8017b04:	0000746e 2f637273 65726f63 6d656d2f     nt..src/core/mem
 8017b14:	00632e70 706d656d 6c616d5f 3a636f6c     p.c.memp_malloc:
 8017b24:	70797420 203c2065 504d454d 58414d5f      type < MEMP_MAX
 8017b34:	00000000 706d656d 6c616d5f 3a636f6c     ....memp_malloc:
 8017b44:	6d656d20 72702070 7265706f 6120796c      memp properly a
 8017b54:	6e67696c 00006465 706d656d 6572665f     ligned..memp_fre
 8017b64:	6d203a65 70206d65 65706f72 20796c72     e: mem properly 
 8017b74:	67696c61 0064656e 2f637273 2f697061     aligned.src/api/
 8017b84:	6274656e 632e6675 00000000 6274656e     netbuf.c....netb
 8017b94:	615f6675 636f6c6c 6e69203a 696c6176     uf_alloc: invali
 8017ba4:	75622064 00000066 63656863 6874206b     d buf...check th
 8017bb4:	66207461 74737269 75627020 61632066     at first pbuf ca
 8017bc4:	6f68206e 7320646c 00657a69 6274656e     n hold size.netb
 8017bd4:	665f6675 3a656572 766e6920 64696c61     uf_free: invalid
 8017be4:	66756220 00000000 6274656e 725f6675      buf....netbuf_r
 8017bf4:	203a6665 61766e69 2064696c 00667562     ef: invalid buf.
 8017c04:	6274656e 725f6675 203a6665 61766e69     netbuf_ref: inva
 8017c14:	2064696c 64616568 00000000 6274656e     lid head....netb
 8017c24:	635f6675 6e696168 6e69203a 696c6176     uf_chain: invali
 8017c34:	61742064 00006c69 6274656e 645f6675     d tail..netbuf_d
 8017c44:	3a617461 766e6920 64696c61 66756220     ata: invalid buf
 8017c54:	00000000 6274656e 645f6675 3a617461     ....netbuf_data:
 8017c64:	766e6920 64696c61 74616420 72747061      invalid dataptr
 8017c74:	00000000 6274656e 645f6675 3a617461     ....netbuf_data:
 8017c84:	766e6920 64696c61 6e656c20 00000000      invalid len....
 8017c94:	2f637273 65726f63 7562702f 00632e66     src/core/pbuf.c.
 8017ca4:	72636e69 6e656d65 616d5f74 74696e67     increment_magnit
 8017cb4:	20656475 70203d3c 656c3e2d 0000006e     ude <= p->len...
 8017cc4:	20646162 66756270 70797420 00000065     bad pbuf type...
 8017cd4:	66756270 6572665f 73203a65 20656e61     pbuf_free: sane 
 8017ce4:	65707974 00000000 66756270 6572665f     type....pbuf_fre
 8017cf4:	70203a65 65723e2d 203e2066 00000030     e: p->ref > 0...
 8017d04:	66756270 6c6c615f 203a636f 20646162     pbuf_alloc: bad 
 8017d14:	66756270 79616c20 00007265 63656863     pbuf layer..chec
 8017d24:	2d70206b 7961703e 64616f6c 70202b20     k p->payload + p
 8017d34:	656c3e2d 6f64206e 6e207365 6f20746f     ->len does not o
 8017d44:	66726576 20776f6c 66756270 00000000     verflow pbuf....
 8017d54:	5f6d6572 206e656c 616d203c 31755f78     rem_len < max_u1
 8017d64:	00745f36 66756270 6c6c615f 203a636f     6_t.pbuf_alloc: 
 8017d74:	66756270 3e2d7120 6c796170 2064616f     pbuf q->payload 
 8017d84:	706f7270 796c7265 696c6120 64656e67     properly aligned
 8017d94:	00000000 66756270 6c6c615f 203a636f     ....pbuf_alloc: 
 8017da4:	6f727265 756f656e 79742073 00006570     erroneous type..
 8017db4:	66756270 6165725f 636f6c6c 2070203a     pbuf_realloc: p 
 8017dc4:	4e203d21 004c4c55 66756270 6165725f     != NULL.pbuf_rea
 8017dd4:	636f6c6c 6173203a 7020656e 79743e2d     lloc: sane p->ty
 8017de4:	00006570 776f7267 6d203c20 755f7861     pe..grow < max_u
 8017df4:	745f3631 00000000 66756270 6165725f     16_t....pbuf_rea
 8017e04:	636f6c6c 2071203a 4e203d21 004c4c55     lloc: q != NULL.
 8017e14:	5f6d656d 6d697274 74657220 656e7275     mem_trim returne
 8017e24:	20712064 4e203d3d 004c4c55 21206828     d q == NULL.(h !
 8017e34:	554e203d 20294c4c 28202626 3d212074     = NULL) && (t !=
 8017e44:	4c554e20 2820294c 676f7270 6d6d6172      NULL) (programm
 8017e54:	76207265 616c6f69 20736574 29495041     er violates API)
 8017e64:	00000000 743e2d70 6c5f746f 3d206e65     ....p->tot_len =
 8017e74:	2d70203d 6e656c3e 666f2820 73616c20     = p->len (of las
 8017e84:	62702074 69206675 6863206e 296e6961     t pbuf in chain)
 8017e94:	00000000 6e3e2d70 20747865 4e203d3d     ....p->next == N
 8017ea4:	004c4c55 743e2d70 6c5f746f 3d206e65     ULL.p->tot_len =
 8017eb4:	2d70203d 6e656c3e 71202b20 6f743e2d     = p->len + q->to
 8017ec4:	656c5f74 0000006e 743e2d70 6c5f746f     t_len...p->tot_l
 8017ed4:	3d206e65 2d70203d 6e656c3e 00000000     en == p->len....
 8017ee4:	66756270 706f635f 74203a79 65677261     pbuf_copy: targe
 8017ef4:	6f6e2074 69622074 6e652067 6867756f     t not big enough
 8017f04:	206f7420 646c6f68 756f7320 00656372      to hold source.
 8017f14:	7366666f 745f7465 3d3c206f 745f7020     offset_to <= p_t
 8017f24:	6c3e2d6f 00006e65 7366666f 665f7465     o->len..offset_f
 8017f34:	206d6f72 70203d3c 6f72665f 6c3e2d6d     rom <= p_from->l
 8017f44:	00006e65 6f745f70 203d2120 4c4c554e     en..p_to != NULL
 8017f54:	00000000 66756270 706f635f 20292879     ....pbuf_copy() 
 8017f64:	73656f64 746f6e20 6c6c6120 7020776f     does not allow p
 8017f74:	656b6361 75712074 73657565 00000a21     acket queues!...
 8017f84:	66756270 706f635f 61705f79 61697472     pbuf_copy_partia
 8017f94:	69203a6c 6c61766e 62206469 00006675     l: invalid buf..
 8017fa4:	66756270 706f635f 61705f79 61697472     pbuf_copy_partia
 8017fb4:	69203a6c 6c61766e 64206469 70617461     l: invalid datap
 8017fc4:	00007274 66756270 6b61745f 69203a65     tr..pbuf_take: i
 8017fd4:	6c61766e 62206469 00006675 66756270     nvalid buf..pbuf
 8017fe4:	6b61745f 69203a65 6c61766e 64206469     _take: invalid d
 8017ff4:	70617461 00007274 66756270 6b61745f     ataptr..pbuf_tak
 8018004:	69203a65 6c61766e 70206469 00667562     e: invalid pbuf.
 8018014:	20646964 20746f6e 79706f63 6c6c6120     did not copy all
 8018024:	74616420 00000061 66756270 706f635f      data...pbuf_cop
 8018034:	61662079 64656c69 00000000 2f637273     y failed....src/
 8018044:	65726f63 7761722f 0000632e 276e6143     core/raw.c..Can'
 8018054:	65722074 726f7473 65682065 72656461     t restore header
 8018064:	20657720 7473756a 6d657220 6465766f      we just removed
 8018074:	00000021 2f637273 2f697061 6b636f73     !...src/api/sock
 8018084:	2e737465 00000063 6e6b6e75 206e776f     ets.c...unknown 
 8018094:	6e657665 00000074 20677261 4e203d21     event...arg != N
 80180a4:	004c4c55 61686e75 656c646e 706f2064     ULL.unhandled op
 80180b4:	6d616e74 00000065 61686e75 656c646e     tname...unhandle
 80180c4:	656c2064 006c6576 6377656e 206e6e6f     d level.newconn 
 80180d4:	4e203d21 004c4c55 72646461 6c617620     != NULL.addr val
 80180e4:	62206469 61207475 6c726464 4e206e65     id but addrlen N
 80180f4:	004c4c55 61766e69 2064696c 6b636f73     ULL.invalid sock
 8018104:	69207465 7865646e 00000000 6377656e     et index....newc
 8018114:	2d6e6e6f 6c61633e 6361626c 3d3d206b     onn->callback ==
 8018124:	65766520 635f746e 626c6c61 006b6361      event_callback.
 8018134:	7069776c 6e69625f 69203a64 6c61766e     lwip_bind: inval
 8018144:	61206469 65726464 00007373 7069776c     id address..lwip
 8018154:	6e6f635f 7463656e 6e69203a 696c6176     _connect: invali
 8018164:	64612064 73657264 00000073 61766e69     d address...inva
 8018174:	2064696c 79706f63 2c6e656c 6e656c20     lid copylen, len
 8018184:	756f7720 7520646c 7265646e 776f6c66      would underflow
 8018194:	00000000 7069776c 6e65735f 3a6f7464     ....lwip_sendto:
 80181a4:	7a697320 756d2065 66207473 69207469      size must fit i
 80181b4:	3175206e 00745f36 7069776c 6e65735f     n u16_t.lwip_sen
 80181c4:	3a6f7464 766e6920 64696c61 64646120     dto: invalid add
 80181d4:	73736572 00000000 6b636f73 65733e2d     ress....sock->se
 80181e4:	7463656c 6961775f 676e6974 30203e20     lect_waiting > 0
 80181f4:	00000000 6b636f73 65733e2d 7463656c     ....sock->select
 8018204:	6961775f 676e6974 203d3e20 00000030     _waiting >= 0...
 8018214:	656c6573 635f7463 72702e62 3d207665     select_cb.prev =
 8018224:	554e203d 00004c4c 656c6573 635f7463     = NULL..select_c
 8018234:	72702e62 21207665 554e203d 00004c4c     b.prev != NULL..
 8018244:	6b636f73 203d2120 4c4c554e 00000000     sock != NULL....
 8018254:	5049574c 69757120 00006575 74726f70     LWIP quiue..port
 8018264:	4d54532f 612f3233 2f686372 534f4375     /STM32/arch/uCOS
 8018274:	4949492d 7379732f 6372615f 00632e68     -III/sys_arch.c.
 8018284:	4351534f 74616572 00002065 5f737973     OSQCreate ..sys_
 8018294:	786f626d 6572665f 00002065 4451534f     mbox_free ..OSQD
 80182a4:	00206c65 5f737973 786f626d 736f705f     el .sys_mbox_pos
 80182b4:	72652074 21726f72 0000000a 5049574c     t error!....LWIP
 80182c4:	6d655320 00000000 6553534f 6572436d      Sem....OSSemCre
 80182d4:	20657461 00000000 6553534f 736f506d     ate ....OSSemPos
 80182e4:	00002074 6553534f 6c65446d 00000020     t ..OSSemDel ...
 80182f4:	5049574c 53415420 5453204b 0000004b     LWIP TASK STK...
 8018304:	5f737973 74696e69 6166203a 64656c69     sys_init: failed
 8018314:	4d534f20 72436d65 65746165 4b545320      OSMemCreate STK
 8018324:	00000000 5f737973 65726874 6e5f6461     ....sys_thread_n
 8018334:	203a7765 72656874 73692065 206f6e20     ew: there is no 
 8018344:	63617073 6f662065 72702072 69726f69     space for priori
 8018354:	00007974 5f737973 65726874 6e5f6461     ty..sys_thread_n
 8018364:	203a7765 72656874 73692065 206f6e20     ew: there is no 
 8018374:	65657266 69727020 7469726f 00000079     free priority...
 8018384:	5f737973 65726874 6e5f6461 203a7765     sys_thread_new: 
 8018394:	6f706d69 62697373 7420656c 6567206f     impossible to ge
 80183a4:	20612074 63617473 0000006b 2f637273     t a stack...src/
 80183b4:	65726f63 7063742f 2e6e695f 00000063     core/tcp_in.c...
 80183c4:	5f706374 65636572 3a657669 6f727720     tcp_receive: wro
 80183d4:	7320676e 65746174 00000000 2d626370     ng state....pcb-
 80183e4:	646e733e 6575715f 656c6575 3d3e206e     >snd_queuelen >=
 80183f4:	75627020 6c635f66 6e286e65 2d747865      pbuf_clen(next-
 8018404:	0029703e 5f706374 65636572 3a657669     >p).tcp_receive:
 8018414:	6c617620 71206469 65756575 6e656c20      valid queue len
 8018424:	00687467 65736e69 20702e67 4e203d21     gth.inseg.p != N
 8018434:	004c4c55 61736e69 6f20656e 65736666     ULL.insane offse
 8018444:	00002174 66756270 6f6f7420 6f687320     t!..pbuf too sho
 8018454:	00217472 66756270 6165685f 20726564     rt!.pbuf_header 
 8018464:	6c696166 00006465 5f706374 65636572     failed..tcp_rece
 8018474:	3a657669 67657320 746e656d 746f6e20     ive: segment not
 8018484:	69727420 64656d6d 726f6320 74636572      trimmed correct
 8018494:	7420796c 6372206f 6e775f76 00000a64     ly to rcv_wnd...
 80184a4:	5f706374 65636572 3a657669 70637420     tcp_receive: tcp
 80184b4:	206e656c 6372203e 6e775f76 00000a64     len > rcv_wnd...
 80184c4:	5f706374 75706e69 61203a74 76697463     tcp_input: activ
 80184d4:	63702065 733e2d62 65746174 203d2120     e pcb->state != 
 80184e4:	534f4c43 00004445 5f706374 75706e69     CLOSED..tcp_inpu
 80184f4:	61203a74 76697463 63702065 733e2d62     t: active pcb->s
 8018504:	65746174 203d2120 454d4954 4941572d     tate != TIME-WAI
 8018514:	00000054 5f706374 75706e69 61203a74     T...tcp_input: a
 8018524:	76697463 63702065 733e2d62 65746174     ctive pcb->state
 8018534:	203d2120 5453494c 00004e45 5f706374      != LISTEN..tcp_
 8018544:	75706e69 70203a74 3e2d6263 7478656e     input: pcb->next
 8018554:	203d2120 20626370 66656228 2065726f      != pcb (before 
 8018564:	68636163 00002965 5f706374 75706e69     cache)..tcp_inpu
 8018574:	70203a74 3e2d6263 7478656e 203d2120     t: pcb->next != 
 8018584:	20626370 74666128 63207265 65686361     pcb (after cache
 8018594:	00000029 5f706374 75706e69 54203a74     )...tcp_input: T
 80185a4:	2d454d49 54494157 62637020 74733e2d     IME-WAIT pcb->st
 80185b4:	20657461 54203d3d 2d454d49 54494157     ate == TIME-WAIT
 80185c4:	00000000 5f706374 75706e69 70203a74     ....tcp_input: p
 80185d4:	3e2d6263 74617473 3d212065 4f4c4320     cb->state != CLO
 80185e4:	00444553 2d626370 646e733e 6575715f     SED.pcb->snd_que
 80185f4:	656c6575 203e206e 00000030 2d626370     uelen > 0...pcb-
 8018604:	6363613e 20747065 4e203d21 004c4c55     >accept != NULL.
 8018614:	2d626370 6665723e 64657375 7461645f     pcb->refused_dat
 8018624:	3d3d2061 4c554e20 0000004c 2f637273     a == NULL...src/
 8018634:	65726f63 7064752f 0000632e 66756270     core/udp.c..pbuf
 8018644:	6165685f 20726564 6c696166 000a6465     _header failed..
 8018654:	703e2d70 6f6c7961 3d206461 7069203d     p->payload == ip
 8018664:	00726468 69626572 3d20646e 0030203d     hdr.rebind == 0.
 8018674:	63656863 6874206b 66207461 74737269     check that first
 8018684:	75627020 61632066 6f68206e 7320646c      pbuf can hold s
 8018694:	63757274 64752074 64685f70 00000072     truct udp_hdr...
 80186a4:	2f637273 65726f63 7670692f 63692f34     src/core/ipv4/ic
 80186b4:	632e706d 00000000 63656863 6874206b     mp.c....check th
 80186c4:	66207461 74737269 75627020 61632066     at first pbuf ca
 80186d4:	6f68206e 6920646c 20706d63 7373656d     n hold icmp mess
 80186e4:	00656761 706d6369 706e695f 203a7475     age.icmp_input: 
 80186f4:	69766f6d 7020676e 61703e2d 616f6c79     moving p->payloa
 8018704:	6f742064 20706920 64616568 66207265     d to ip header f
 8018714:	656c6961 00000a64 63656863 6874206b     ailed...check th
 8018724:	66207461 74737269 75627020 61632066     at first pbuf ca
 8018734:	6f68206e 7320646c 63757274 68742074     n hold struct th
 8018744:	43492065 6820504d 65646165 00000072     e ICMP header...
 8018754:	706d6369 706e695f 203a7475 79706f63     icmp_input: copy
 8018764:	20676e69 6e206f74 70207765 20667562     ing to new pbuf 
 8018774:	6c696166 000a6465 706d6369 706e695f     failed..icmp_inp
 8018784:	203a7475 74736572 6e69726f 726f2067     ut: restoring or
 8018794:	6e696769 70206c61 61703e2d 616f6c79     iginal p->payloa
 80187a4:	61662064 64656c69 0000000a              d failed....

080187b0 <_global_impure_ptr>:
 80187b0:	20000034 4f500043 00584953 2000002e              4.. C.POSIX...

080187be <_ctype_>:
 80187be:	20202000 20202020 28282020 20282828     .         ((((( 
 80187ce:	20202020 20202020 20202020 20202020                     
 80187de:	10108820 10101010 10101010 10101010      ...............
 80187ee:	04040410 04040404 10040404 10101010     ................
 80187fe:	41411010 41414141 01010101 01010101     ..AAAAAA........
 801880e:	01010101 01010101 01010101 10101010     ................
 801881e:	42421010 42424242 02020202 02020202     ..BBBBBB........
 801882e:	02020202 02020202 02020202 10101010     ................
 801883e:	00000020 00000000 00000000 00000000      ...............
	...

080188c0 <__sf_fake_stdin>:
	...

080188e0 <__sf_fake_stdout>:
	...

08018900 <__sf_fake_stderr>:
	...
 8018920:	2b302d23 6c680020 6665004c 47464567     #-0+ .hlL.efgEFG
 8018930:	32313000 36353433 41393837 45444342     .0123456789ABCDE
 8018940:	31300046 35343332 39383736 64636261     F.0123456789abcd
 8018950:	00006665                                ef..

08018954 <_init>:
 8018954:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8018956:	bf00      	nop
 8018958:	bcf8      	pop	{r3, r4, r5, r6, r7}
 801895a:	bc08      	pop	{r3}
 801895c:	469e      	mov	lr, r3
 801895e:	4770      	bx	lr

08018960 <_fini>:
 8018960:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8018962:	bf00      	nop
 8018964:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8018966:	bc08      	pop	{r3}
 8018968:	469e      	mov	lr, r3
 801896a:	4770      	bx	lr
